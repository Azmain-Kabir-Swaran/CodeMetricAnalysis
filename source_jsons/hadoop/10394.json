{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataXceiver.java",
  "functionName": "requestShortCircuitFds",
  "functionId": "requestShortCircuitFds___blk-ExtendedBlock(modifiers-final)__token-Token__BlockTokenIdentifier__(modifiers-final)__slotId-SlotId__maxVersion-int__supportsReceiptVerification-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
  "functionStartLine": 349,
  "functionEndLine": 437,
  "numCommitsSeen": 349,
  "timeTaken": 7402,
  "changeHistory": [
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "56b88b06705441f6f171eec7fb2fa77946ca204b",
    "a3954ccab148bddc290cb96528e63ff19799bcc9",
    "38c4c14472996562eb3d610649246770c2888c6b",
    "176ff5ce90f2cbcd8342016d0f5570337d2ff79f",
    "bc9cb3e271b22069a15ca110cd60c860250aaab2",
    "32741cf3d25d85a92e3deb11c302cc2a718d71dd",
    "5aa892ed486d42ae6b94c4866b92cd2b382ea640",
    "a3616c58dd2ddb16172ca3ab5d66fad52ec0e6d7",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
    "4551da302d94cffea0313eac79479ab6f9b7cb34",
    "a18fd620d070cf8e84aaf80d93807ac9ee207a0f"
  ],
  "changeHistoryShort": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "56b88b06705441f6f171eec7fb2fa77946ca204b": "Ybodychange",
    "a3954ccab148bddc290cb96528e63ff19799bcc9": "Ybodychange",
    "38c4c14472996562eb3d610649246770c2888c6b": "Ybodychange",
    "176ff5ce90f2cbcd8342016d0f5570337d2ff79f": "Ybodychange",
    "bc9cb3e271b22069a15ca110cd60c860250aaab2": "Ymultichange(Yparameterchange,Ybodychange)",
    "32741cf3d25d85a92e3deb11c302cc2a718d71dd": "Ymultichange(Yparameterchange,Ybodychange)",
    "5aa892ed486d42ae6b94c4866b92cd2b382ea640": "Ymultichange(Yparameterchange,Ybodychange)",
    "a3616c58dd2ddb16172ca3ab5d66fad52ec0e6d7": "Ybodychange",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": "Ymultichange(Yparameterchange,Ybodychange)",
    "4551da302d94cffea0313eac79479ab6f9b7cb34": "Ybodychange",
    "a18fd620d070cf8e84aaf80d93807ac9ee207a0f": "Ybodychange"
  },
  "changeHistoryDetails": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "01/11/17 1:41 AM",
      "commitNameOld": "56b88b06705441f6f171eec7fb2fa77946ca204b",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 105.32,
      "commitsBetweenForRepo": 696,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,89 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n         throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     DataOutputStream out \u003d getBufferedOutputStream();\n     checkAccess(out, true, blk, token,\n         Op.REQUEST_SHORT_CIRCUIT_FDS, BlockTokenIdentifier.AccessMode.READ,\n         null, null);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     SlotId registeredSlotId \u003d null;\n     boolean success \u003d false;\n     try {\n       try {\n         if (peer.getDomainSocket() \u003d\u003d null) {\n           throw new IOException(\"You cannot pass file descriptors over \" +\n               \"anything but a UNIX domain socket.\");\n         }\n         if (slotId !\u003d null) {\n           boolean isCached \u003d datanode.data.\n               isCached(blk.getBlockPoolId(), blk.getBlockId());\n           datanode.shortCircuitRegistry.registerSlot(\n               ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n           registeredSlotId \u003d slotId;\n         }\n         fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n         Preconditions.checkState(fis !\u003d null);\n         bld.setStatus(SUCCESS);\n         bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       } catch (ShortCircuitFdsVersionException e) {\n         bld.setStatus(ERROR_UNSUPPORTED);\n         bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n         bld.setMessage(e.getMessage());\n       } catch (ShortCircuitFdsUnsupportedException e) {\n         bld.setStatus(ERROR_UNSUPPORTED);\n         bld.setMessage(e.getMessage());\n       } catch (IOException e) {\n         bld.setStatus(ERROR);\n         bld.setMessage(e.getMessage());\n         LOG.error(\"Request short-circuit read file descriptor\" +\n             \" failed with unknown error.\", e);\n       }\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[1];\n         if (supportsReceiptVerification) {\n           buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n         } else {\n           buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n         }\n         DomainSocket sock \u003d peer.getDomainSocket();\n         sock.sendFileDescriptors(fds, buf, 0, buf.length);\n         if (supportsReceiptVerification) {\n-          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n+          LOG.trace(\"Reading receipt verification byte for {}\", slotId);\n           int val \u003d sock.getInputStream().read();\n           if (val \u003c 0) {\n             throw new EOFException();\n           }\n         } else {\n-          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n-                    \"Not verifying \" + slotId);\n+          LOG.trace(\"Receipt verification is not enabled on the DataNode. \" +\n+                    \"Not verifying {}\", slotId);\n         }\n         success \u003d true;\n       }\n     } finally {\n       if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n-        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n-            \"requestShortCircuitFdsForRead operation failed.\");\n+        LOG.info(\"Unregistering {} because the \" +\n+            \"requestShortCircuitFdsForRead operation failed.\",\n+            registeredSlotId);\n         datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n       }\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n             blk.getBlockId(), dnR.getDatanodeUuid(), success));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(null, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n        throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    DataOutputStream out \u003d getBufferedOutputStream();\n    checkAccess(out, true, blk, token,\n        Op.REQUEST_SHORT_CIRCUIT_FDS, BlockTokenIdentifier.AccessMode.READ,\n        null, null);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    SlotId registeredSlotId \u003d null;\n    boolean success \u003d false;\n    try {\n      try {\n        if (peer.getDomainSocket() \u003d\u003d null) {\n          throw new IOException(\"You cannot pass file descriptors over \" +\n              \"anything but a UNIX domain socket.\");\n        }\n        if (slotId !\u003d null) {\n          boolean isCached \u003d datanode.data.\n              isCached(blk.getBlockPoolId(), blk.getBlockId());\n          datanode.shortCircuitRegistry.registerSlot(\n              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n          registeredSlotId \u003d slotId;\n        }\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n        Preconditions.checkState(fis !\u003d null);\n        bld.setStatus(SUCCESS);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      } catch (ShortCircuitFdsVersionException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n        bld.setMessage(e.getMessage());\n      } catch (ShortCircuitFdsUnsupportedException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setMessage(e.getMessage());\n      } catch (IOException e) {\n        bld.setStatus(ERROR);\n        bld.setMessage(e.getMessage());\n        LOG.error(\"Request short-circuit read file descriptor\" +\n            \" failed with unknown error.\", e);\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[1];\n        if (supportsReceiptVerification) {\n          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n        } else {\n          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n        }\n        DomainSocket sock \u003d peer.getDomainSocket();\n        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n        if (supportsReceiptVerification) {\n          LOG.trace(\"Reading receipt verification byte for {}\", slotId);\n          int val \u003d sock.getInputStream().read();\n          if (val \u003c 0) {\n            throw new EOFException();\n          }\n        } else {\n          LOG.trace(\"Receipt verification is not enabled on the DataNode. \" +\n                    \"Not verifying {}\", slotId);\n        }\n        success \u003d true;\n      }\n    } finally {\n      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n        LOG.info(\"Unregistering {} because the \" +\n            \"requestShortCircuitFdsForRead operation failed.\",\n            registeredSlotId);\n        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n      }\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(null, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "56b88b06705441f6f171eec7fb2fa77946ca204b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12744. More logs when short-circuit read is failed and disabled. Contributed by Weiwei Yang.\n",
      "commitDate": "01/11/17 1:41 AM",
      "commitName": "56b88b06705441f6f171eec7fb2fa77946ca204b",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "01/08/17 1:34 PM",
      "commitNameOld": "7774759830f32ef97ac9f157dbb210264b7d042a",
      "commitAuthorOld": "Sean Mackrory",
      "daysBetweenCommits": 91.51,
      "commitsBetweenForRepo": 805,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,88 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n         throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     DataOutputStream out \u003d getBufferedOutputStream();\n     checkAccess(out, true, blk, token,\n         Op.REQUEST_SHORT_CIRCUIT_FDS, BlockTokenIdentifier.AccessMode.READ,\n         null, null);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     SlotId registeredSlotId \u003d null;\n     boolean success \u003d false;\n     try {\n       try {\n         if (peer.getDomainSocket() \u003d\u003d null) {\n           throw new IOException(\"You cannot pass file descriptors over \" +\n               \"anything but a UNIX domain socket.\");\n         }\n         if (slotId !\u003d null) {\n           boolean isCached \u003d datanode.data.\n               isCached(blk.getBlockPoolId(), blk.getBlockId());\n           datanode.shortCircuitRegistry.registerSlot(\n               ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n           registeredSlotId \u003d slotId;\n         }\n         fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n         Preconditions.checkState(fis !\u003d null);\n         bld.setStatus(SUCCESS);\n         bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       } catch (ShortCircuitFdsVersionException e) {\n         bld.setStatus(ERROR_UNSUPPORTED);\n         bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n         bld.setMessage(e.getMessage());\n       } catch (ShortCircuitFdsUnsupportedException e) {\n         bld.setStatus(ERROR_UNSUPPORTED);\n         bld.setMessage(e.getMessage());\n       } catch (IOException e) {\n         bld.setStatus(ERROR);\n         bld.setMessage(e.getMessage());\n+        LOG.error(\"Request short-circuit read file descriptor\" +\n+            \" failed with unknown error.\", e);\n       }\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[1];\n         if (supportsReceiptVerification) {\n           buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n         } else {\n           buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n         }\n         DomainSocket sock \u003d peer.getDomainSocket();\n         sock.sendFileDescriptors(fds, buf, 0, buf.length);\n         if (supportsReceiptVerification) {\n           LOG.trace(\"Reading receipt verification byte for \" + slotId);\n           int val \u003d sock.getInputStream().read();\n           if (val \u003c 0) {\n             throw new EOFException();\n           }\n         } else {\n           LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                     \"Not verifying \" + slotId);\n         }\n         success \u003d true;\n       }\n     } finally {\n       if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n         LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n             \"requestShortCircuitFdsForRead operation failed.\");\n         datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n       }\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n             blk.getBlockId(), dnR.getDatanodeUuid(), success));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(null, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n        throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    DataOutputStream out \u003d getBufferedOutputStream();\n    checkAccess(out, true, blk, token,\n        Op.REQUEST_SHORT_CIRCUIT_FDS, BlockTokenIdentifier.AccessMode.READ,\n        null, null);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    SlotId registeredSlotId \u003d null;\n    boolean success \u003d false;\n    try {\n      try {\n        if (peer.getDomainSocket() \u003d\u003d null) {\n          throw new IOException(\"You cannot pass file descriptors over \" +\n              \"anything but a UNIX domain socket.\");\n        }\n        if (slotId !\u003d null) {\n          boolean isCached \u003d datanode.data.\n              isCached(blk.getBlockPoolId(), blk.getBlockId());\n          datanode.shortCircuitRegistry.registerSlot(\n              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n          registeredSlotId \u003d slotId;\n        }\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n        Preconditions.checkState(fis !\u003d null);\n        bld.setStatus(SUCCESS);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      } catch (ShortCircuitFdsVersionException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n        bld.setMessage(e.getMessage());\n      } catch (ShortCircuitFdsUnsupportedException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setMessage(e.getMessage());\n      } catch (IOException e) {\n        bld.setStatus(ERROR);\n        bld.setMessage(e.getMessage());\n        LOG.error(\"Request short-circuit read file descriptor\" +\n            \" failed with unknown error.\", e);\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[1];\n        if (supportsReceiptVerification) {\n          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n        } else {\n          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n        }\n        DomainSocket sock \u003d peer.getDomainSocket();\n        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n        if (supportsReceiptVerification) {\n          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n          int val \u003d sock.getInputStream().read();\n          if (val \u003c 0) {\n            throw new EOFException();\n          }\n        } else {\n          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                    \"Not verifying \" + slotId);\n        }\n        success \u003d true;\n      }\n    } finally {\n      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n            \"requestShortCircuitFdsForRead operation failed.\");\n        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n      }\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(null, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "a3954ccab148bddc290cb96528e63ff19799bcc9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
      "commitDate": "05/05/17 12:01 PM",
      "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "25/04/17 11:57 PM",
      "commitNameOld": "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 9.5,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,86 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n         throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     DataOutputStream out \u003d getBufferedOutputStream();\n     checkAccess(out, true, blk, token,\n-        Op.REQUEST_SHORT_CIRCUIT_FDS, BlockTokenIdentifier.AccessMode.READ);\n+        Op.REQUEST_SHORT_CIRCUIT_FDS, BlockTokenIdentifier.AccessMode.READ,\n+        null, null);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     SlotId registeredSlotId \u003d null;\n     boolean success \u003d false;\n     try {\n       try {\n         if (peer.getDomainSocket() \u003d\u003d null) {\n           throw new IOException(\"You cannot pass file descriptors over \" +\n               \"anything but a UNIX domain socket.\");\n         }\n         if (slotId !\u003d null) {\n           boolean isCached \u003d datanode.data.\n               isCached(blk.getBlockPoolId(), blk.getBlockId());\n           datanode.shortCircuitRegistry.registerSlot(\n               ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n           registeredSlotId \u003d slotId;\n         }\n         fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n         Preconditions.checkState(fis !\u003d null);\n         bld.setStatus(SUCCESS);\n         bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       } catch (ShortCircuitFdsVersionException e) {\n         bld.setStatus(ERROR_UNSUPPORTED);\n         bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n         bld.setMessage(e.getMessage());\n       } catch (ShortCircuitFdsUnsupportedException e) {\n         bld.setStatus(ERROR_UNSUPPORTED);\n         bld.setMessage(e.getMessage());\n       } catch (IOException e) {\n         bld.setStatus(ERROR);\n         bld.setMessage(e.getMessage());\n       }\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[1];\n         if (supportsReceiptVerification) {\n           buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n         } else {\n           buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n         }\n         DomainSocket sock \u003d peer.getDomainSocket();\n         sock.sendFileDescriptors(fds, buf, 0, buf.length);\n         if (supportsReceiptVerification) {\n           LOG.trace(\"Reading receipt verification byte for \" + slotId);\n           int val \u003d sock.getInputStream().read();\n           if (val \u003c 0) {\n             throw new EOFException();\n           }\n         } else {\n           LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                     \"Not verifying \" + slotId);\n         }\n         success \u003d true;\n       }\n     } finally {\n       if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n         LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n             \"requestShortCircuitFdsForRead operation failed.\");\n         datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n       }\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n             blk.getBlockId(), dnR.getDatanodeUuid(), success));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(null, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n        throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    DataOutputStream out \u003d getBufferedOutputStream();\n    checkAccess(out, true, blk, token,\n        Op.REQUEST_SHORT_CIRCUIT_FDS, BlockTokenIdentifier.AccessMode.READ,\n        null, null);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    SlotId registeredSlotId \u003d null;\n    boolean success \u003d false;\n    try {\n      try {\n        if (peer.getDomainSocket() \u003d\u003d null) {\n          throw new IOException(\"You cannot pass file descriptors over \" +\n              \"anything but a UNIX domain socket.\");\n        }\n        if (slotId !\u003d null) {\n          boolean isCached \u003d datanode.data.\n              isCached(blk.getBlockPoolId(), blk.getBlockId());\n          datanode.shortCircuitRegistry.registerSlot(\n              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n          registeredSlotId \u003d slotId;\n        }\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n        Preconditions.checkState(fis !\u003d null);\n        bld.setStatus(SUCCESS);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      } catch (ShortCircuitFdsVersionException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n        bld.setMessage(e.getMessage());\n      } catch (ShortCircuitFdsUnsupportedException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setMessage(e.getMessage());\n      } catch (IOException e) {\n        bld.setStatus(ERROR);\n        bld.setMessage(e.getMessage());\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[1];\n        if (supportsReceiptVerification) {\n          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n        } else {\n          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n        }\n        DomainSocket sock \u003d peer.getDomainSocket();\n        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n        if (supportsReceiptVerification) {\n          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n          int val \u003d sock.getInputStream().read();\n          if (val \u003c 0) {\n            throw new EOFException();\n          }\n        } else {\n          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                    \"Not verifying \" + slotId);\n        }\n        success \u003d true;\n      }\n    } finally {\n      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n            \"requestShortCircuitFdsForRead operation failed.\");\n        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n      }\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(null, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "38c4c14472996562eb3d610649246770c2888c6b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9574. Reduce client failures during datanode restart. Contributed by Kihwal Lee.\n",
      "commitDate": "08/01/16 9:13 AM",
      "commitName": "38c4c14472996562eb3d610649246770c2888c6b",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/01/16 2:32 PM",
      "commitNameOld": "778146eaae5b1e17928a1f26fb1e46536a6ee510",
      "commitAuthorOld": "Uma Mahesh",
      "daysBetweenCommits": 3.78,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n         throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n+    DataOutputStream out \u003d getBufferedOutputStream();\n+    checkAccess(out, true, blk, token,\n+        Op.REQUEST_SHORT_CIRCUIT_FDS, BlockTokenIdentifier.AccessMode.READ);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     SlotId registeredSlotId \u003d null;\n     boolean success \u003d false;\n     try {\n       try {\n         if (peer.getDomainSocket() \u003d\u003d null) {\n           throw new IOException(\"You cannot pass file descriptors over \" +\n               \"anything but a UNIX domain socket.\");\n         }\n         if (slotId !\u003d null) {\n           boolean isCached \u003d datanode.data.\n               isCached(blk.getBlockPoolId(), blk.getBlockId());\n           datanode.shortCircuitRegistry.registerSlot(\n               ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n           registeredSlotId \u003d slotId;\n         }\n         fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n         Preconditions.checkState(fis !\u003d null);\n         bld.setStatus(SUCCESS);\n         bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       } catch (ShortCircuitFdsVersionException e) {\n         bld.setStatus(ERROR_UNSUPPORTED);\n         bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n         bld.setMessage(e.getMessage());\n       } catch (ShortCircuitFdsUnsupportedException e) {\n         bld.setStatus(ERROR_UNSUPPORTED);\n         bld.setMessage(e.getMessage());\n-      } catch (InvalidToken e) {\n-        bld.setStatus(ERROR_ACCESS_TOKEN);\n-        bld.setMessage(e.getMessage());\n       } catch (IOException e) {\n         bld.setStatus(ERROR);\n         bld.setMessage(e.getMessage());\n       }\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[1];\n         if (supportsReceiptVerification) {\n           buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n         } else {\n           buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n         }\n         DomainSocket sock \u003d peer.getDomainSocket();\n         sock.sendFileDescriptors(fds, buf, 0, buf.length);\n         if (supportsReceiptVerification) {\n           LOG.trace(\"Reading receipt verification byte for \" + slotId);\n           int val \u003d sock.getInputStream().read();\n           if (val \u003c 0) {\n             throw new EOFException();\n           }\n         } else {\n           LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                     \"Not verifying \" + slotId);\n         }\n         success \u003d true;\n       }\n     } finally {\n       if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n         LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n             \"requestShortCircuitFdsForRead operation failed.\");\n         datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n       }\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n             blk.getBlockId(), dnR.getDatanodeUuid(), success));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(null, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n        throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    DataOutputStream out \u003d getBufferedOutputStream();\n    checkAccess(out, true, blk, token,\n        Op.REQUEST_SHORT_CIRCUIT_FDS, BlockTokenIdentifier.AccessMode.READ);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    SlotId registeredSlotId \u003d null;\n    boolean success \u003d false;\n    try {\n      try {\n        if (peer.getDomainSocket() \u003d\u003d null) {\n          throw new IOException(\"You cannot pass file descriptors over \" +\n              \"anything but a UNIX domain socket.\");\n        }\n        if (slotId !\u003d null) {\n          boolean isCached \u003d datanode.data.\n              isCached(blk.getBlockPoolId(), blk.getBlockId());\n          datanode.shortCircuitRegistry.registerSlot(\n              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n          registeredSlotId \u003d slotId;\n        }\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n        Preconditions.checkState(fis !\u003d null);\n        bld.setStatus(SUCCESS);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      } catch (ShortCircuitFdsVersionException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n        bld.setMessage(e.getMessage());\n      } catch (ShortCircuitFdsUnsupportedException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setMessage(e.getMessage());\n      } catch (IOException e) {\n        bld.setStatus(ERROR);\n        bld.setMessage(e.getMessage());\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[1];\n        if (supportsReceiptVerification) {\n          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n        } else {\n          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n        }\n        DomainSocket sock \u003d peer.getDomainSocket();\n        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n        if (supportsReceiptVerification) {\n          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n          int val \u003d sock.getInputStream().read();\n          if (val \u003c 0) {\n            throw new EOFException();\n          }\n        } else {\n          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                    \"Not verifying \" + slotId);\n        }\n        success \u003d true;\n      }\n    } finally {\n      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n            \"requestShortCircuitFdsForRead operation failed.\");\n        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n      }\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(null, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "176ff5ce90f2cbcd8342016d0f5570337d2ff79f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9402. Switch DataNode.LOG to use slf4j. Contributed by Walter Su.\n",
      "commitDate": "22/11/15 3:54 PM",
      "commitName": "176ff5ce90f2cbcd8342016d0f5570337d2ff79f",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "02/10/15 11:08 AM",
      "commitNameOld": "c6cafc77e697317dad0708309b67b900a2e3a413",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 51.24,
      "commitsBetweenForRepo": 383,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n         throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     SlotId registeredSlotId \u003d null;\n     boolean success \u003d false;\n     try {\n       try {\n         if (peer.getDomainSocket() \u003d\u003d null) {\n           throw new IOException(\"You cannot pass file descriptors over \" +\n               \"anything but a UNIX domain socket.\");\n         }\n         if (slotId !\u003d null) {\n           boolean isCached \u003d datanode.data.\n               isCached(blk.getBlockPoolId(), blk.getBlockId());\n           datanode.shortCircuitRegistry.registerSlot(\n               ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n           registeredSlotId \u003d slotId;\n         }\n         fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n         Preconditions.checkState(fis !\u003d null);\n         bld.setStatus(SUCCESS);\n         bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       } catch (ShortCircuitFdsVersionException e) {\n         bld.setStatus(ERROR_UNSUPPORTED);\n         bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n         bld.setMessage(e.getMessage());\n       } catch (ShortCircuitFdsUnsupportedException e) {\n         bld.setStatus(ERROR_UNSUPPORTED);\n         bld.setMessage(e.getMessage());\n       } catch (InvalidToken e) {\n         bld.setStatus(ERROR_ACCESS_TOKEN);\n         bld.setMessage(e.getMessage());\n       } catch (IOException e) {\n         bld.setStatus(ERROR);\n         bld.setMessage(e.getMessage());\n       }\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[1];\n         if (supportsReceiptVerification) {\n           buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n         } else {\n           buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n         }\n         DomainSocket sock \u003d peer.getDomainSocket();\n         sock.sendFileDescriptors(fds, buf, 0, buf.length);\n         if (supportsReceiptVerification) {\n           LOG.trace(\"Reading receipt verification byte for \" + slotId);\n           int val \u003d sock.getInputStream().read();\n           if (val \u003c 0) {\n             throw new EOFException();\n           }\n         } else {\n           LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                     \"Not verifying \" + slotId);\n         }\n         success \u003d true;\n       }\n     } finally {\n       if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n         LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n             \"requestShortCircuitFdsForRead operation failed.\");\n         datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n       }\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n             blk.getBlockId(), dnR.getDatanodeUuid(), success));\n       }\n       if (fis !\u003d null) {\n-        IOUtils.cleanup(LOG, fis);\n+        IOUtils.cleanup(null, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n        throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    SlotId registeredSlotId \u003d null;\n    boolean success \u003d false;\n    try {\n      try {\n        if (peer.getDomainSocket() \u003d\u003d null) {\n          throw new IOException(\"You cannot pass file descriptors over \" +\n              \"anything but a UNIX domain socket.\");\n        }\n        if (slotId !\u003d null) {\n          boolean isCached \u003d datanode.data.\n              isCached(blk.getBlockPoolId(), blk.getBlockId());\n          datanode.shortCircuitRegistry.registerSlot(\n              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n          registeredSlotId \u003d slotId;\n        }\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n        Preconditions.checkState(fis !\u003d null);\n        bld.setStatus(SUCCESS);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      } catch (ShortCircuitFdsVersionException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n        bld.setMessage(e.getMessage());\n      } catch (ShortCircuitFdsUnsupportedException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setMessage(e.getMessage());\n      } catch (InvalidToken e) {\n        bld.setStatus(ERROR_ACCESS_TOKEN);\n        bld.setMessage(e.getMessage());\n      } catch (IOException e) {\n        bld.setStatus(ERROR);\n        bld.setMessage(e.getMessage());\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[1];\n        if (supportsReceiptVerification) {\n          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n        } else {\n          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n        }\n        DomainSocket sock \u003d peer.getDomainSocket();\n        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n        if (supportsReceiptVerification) {\n          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n          int val \u003d sock.getInputStream().read();\n          if (val \u003c 0) {\n            throw new EOFException();\n          }\n        } else {\n          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                    \"Not verifying \" + slotId);\n        }\n        success \u003d true;\n      }\n    } finally {\n      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n            \"requestShortCircuitFdsForRead operation failed.\");\n        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n      }\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(null, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "bc9cb3e271b22069a15ca110cd60c860250aaab2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\n",
      "commitDate": "14/03/15 10:36 PM",
      "commitName": "bc9cb3e271b22069a15ca110cd60c860250aaab2",
      "commitAuthor": "Colin Patrick Mccabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\n",
          "commitDate": "14/03/15 10:36 PM",
          "commitName": "bc9cb3e271b22069a15ca110cd60c860250aaab2",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "13/03/15 6:40 PM",
          "commitNameOld": "32741cf3d25d85a92e3deb11c302cc2a718d71dd",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 1.16,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,85 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n-      SlotId slotId, int maxVersion) throws IOException {\n+      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n+        throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n+    SlotId registeredSlotId \u003d null;\n+    boolean success \u003d false;\n     try {\n-      if (peer.getDomainSocket() \u003d\u003d null) {\n-        throw new IOException(\"You cannot pass file descriptors over \" +\n-            \"anything but a UNIX domain socket.\");\n-      }\n-      if (slotId !\u003d null) {\n-        boolean isCached \u003d datanode.data.\n-            isCached(blk.getBlockPoolId(), blk.getBlockId());\n-        datanode.shortCircuitRegistry.registerSlot(\n-            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n-      }\n       try {\n-        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-      } finally {\n-        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n-          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n+        if (peer.getDomainSocket() \u003d\u003d null) {\n+          throw new IOException(\"You cannot pass file descriptors over \" +\n+              \"anything but a UNIX domain socket.\");\n         }\n+        if (slotId !\u003d null) {\n+          boolean isCached \u003d datanode.data.\n+              isCached(blk.getBlockPoolId(), blk.getBlockId());\n+          datanode.shortCircuitRegistry.registerSlot(\n+              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n+          registeredSlotId \u003d slotId;\n+        }\n+        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n+        Preconditions.checkState(fis !\u003d null);\n+        bld.setStatus(SUCCESS);\n+        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+      } catch (ShortCircuitFdsVersionException e) {\n+        bld.setStatus(ERROR_UNSUPPORTED);\n+        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+        bld.setMessage(e.getMessage());\n+      } catch (ShortCircuitFdsUnsupportedException e) {\n+        bld.setStatus(ERROR_UNSUPPORTED);\n+        bld.setMessage(e.getMessage());\n+      } catch (InvalidToken e) {\n+        bld.setStatus(ERROR_ACCESS_TOKEN);\n+        bld.setMessage(e.getMessage());\n+      } catch (IOException e) {\n+        bld.setStatus(ERROR);\n+        bld.setMessage(e.getMessage());\n       }\n-      bld.setStatus(SUCCESS);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-    } catch (ShortCircuitFdsVersionException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      bld.setMessage(e.getMessage());\n-    } catch (ShortCircuitFdsUnsupportedException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setMessage(e.getMessage());\n-    } catch (InvalidToken e) {\n-      bld.setStatus(ERROR_ACCESS_TOKEN);\n-      bld.setMessage(e.getMessage());\n-    } catch (IOException e) {\n-      bld.setStatus(ERROR);\n-      bld.setMessage(e.getMessage());\n-    }\n-    try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n-        byte buf[] \u003d new byte[] { (byte)0 };\n-        peer.getDomainSocket().\n-          sendFileDescriptors(fds, buf, 0, buf.length);\n+        byte buf[] \u003d new byte[1];\n+        if (supportsReceiptVerification) {\n+          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n+        } else {\n+          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n+        }\n+        DomainSocket sock \u003d peer.getDomainSocket();\n+        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n+        if (supportsReceiptVerification) {\n+          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n+          int val \u003d sock.getInputStream().read();\n+          if (val \u003c 0) {\n+            throw new EOFException();\n+          }\n+        } else {\n+          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n+                    \"Not verifying \" + slotId);\n+        }\n+        success \u003d true;\n       }\n     } finally {\n+      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n+        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n+            \"requestShortCircuitFdsForRead operation failed.\");\n+        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n+      }\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n-          ));\n+            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n        throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    SlotId registeredSlotId \u003d null;\n    boolean success \u003d false;\n    try {\n      try {\n        if (peer.getDomainSocket() \u003d\u003d null) {\n          throw new IOException(\"You cannot pass file descriptors over \" +\n              \"anything but a UNIX domain socket.\");\n        }\n        if (slotId !\u003d null) {\n          boolean isCached \u003d datanode.data.\n              isCached(blk.getBlockPoolId(), blk.getBlockId());\n          datanode.shortCircuitRegistry.registerSlot(\n              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n          registeredSlotId \u003d slotId;\n        }\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n        Preconditions.checkState(fis !\u003d null);\n        bld.setStatus(SUCCESS);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      } catch (ShortCircuitFdsVersionException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n        bld.setMessage(e.getMessage());\n      } catch (ShortCircuitFdsUnsupportedException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setMessage(e.getMessage());\n      } catch (InvalidToken e) {\n        bld.setStatus(ERROR_ACCESS_TOKEN);\n        bld.setMessage(e.getMessage());\n      } catch (IOException e) {\n        bld.setStatus(ERROR);\n        bld.setMessage(e.getMessage());\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[1];\n        if (supportsReceiptVerification) {\n          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n        } else {\n          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n        }\n        DomainSocket sock \u003d peer.getDomainSocket();\n        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n        if (supportsReceiptVerification) {\n          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n          int val \u003d sock.getInputStream().read();\n          if (val \u003c 0) {\n            throw new EOFException();\n          }\n        } else {\n          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                    \"Not verifying \" + slotId);\n        }\n        success \u003d true;\n      }\n    } finally {\n      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n            \"requestShortCircuitFdsForRead operation failed.\");\n        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n      }\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[blk-ExtendedBlock(modifiers-final), token-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), slotId-SlotId, maxVersion-int]",
            "newValue": "[blk-ExtendedBlock(modifiers-final), token-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), slotId-SlotId, maxVersion-int, supportsReceiptVerification-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\n",
          "commitDate": "14/03/15 10:36 PM",
          "commitName": "bc9cb3e271b22069a15ca110cd60c860250aaab2",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "13/03/15 6:40 PM",
          "commitNameOld": "32741cf3d25d85a92e3deb11c302cc2a718d71dd",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 1.16,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,85 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n-      SlotId slotId, int maxVersion) throws IOException {\n+      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n+        throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n+    SlotId registeredSlotId \u003d null;\n+    boolean success \u003d false;\n     try {\n-      if (peer.getDomainSocket() \u003d\u003d null) {\n-        throw new IOException(\"You cannot pass file descriptors over \" +\n-            \"anything but a UNIX domain socket.\");\n-      }\n-      if (slotId !\u003d null) {\n-        boolean isCached \u003d datanode.data.\n-            isCached(blk.getBlockPoolId(), blk.getBlockId());\n-        datanode.shortCircuitRegistry.registerSlot(\n-            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n-      }\n       try {\n-        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-      } finally {\n-        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n-          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n+        if (peer.getDomainSocket() \u003d\u003d null) {\n+          throw new IOException(\"You cannot pass file descriptors over \" +\n+              \"anything but a UNIX domain socket.\");\n         }\n+        if (slotId !\u003d null) {\n+          boolean isCached \u003d datanode.data.\n+              isCached(blk.getBlockPoolId(), blk.getBlockId());\n+          datanode.shortCircuitRegistry.registerSlot(\n+              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n+          registeredSlotId \u003d slotId;\n+        }\n+        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n+        Preconditions.checkState(fis !\u003d null);\n+        bld.setStatus(SUCCESS);\n+        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+      } catch (ShortCircuitFdsVersionException e) {\n+        bld.setStatus(ERROR_UNSUPPORTED);\n+        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+        bld.setMessage(e.getMessage());\n+      } catch (ShortCircuitFdsUnsupportedException e) {\n+        bld.setStatus(ERROR_UNSUPPORTED);\n+        bld.setMessage(e.getMessage());\n+      } catch (InvalidToken e) {\n+        bld.setStatus(ERROR_ACCESS_TOKEN);\n+        bld.setMessage(e.getMessage());\n+      } catch (IOException e) {\n+        bld.setStatus(ERROR);\n+        bld.setMessage(e.getMessage());\n       }\n-      bld.setStatus(SUCCESS);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-    } catch (ShortCircuitFdsVersionException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      bld.setMessage(e.getMessage());\n-    } catch (ShortCircuitFdsUnsupportedException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setMessage(e.getMessage());\n-    } catch (InvalidToken e) {\n-      bld.setStatus(ERROR_ACCESS_TOKEN);\n-      bld.setMessage(e.getMessage());\n-    } catch (IOException e) {\n-      bld.setStatus(ERROR);\n-      bld.setMessage(e.getMessage());\n-    }\n-    try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n-        byte buf[] \u003d new byte[] { (byte)0 };\n-        peer.getDomainSocket().\n-          sendFileDescriptors(fds, buf, 0, buf.length);\n+        byte buf[] \u003d new byte[1];\n+        if (supportsReceiptVerification) {\n+          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n+        } else {\n+          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n+        }\n+        DomainSocket sock \u003d peer.getDomainSocket();\n+        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n+        if (supportsReceiptVerification) {\n+          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n+          int val \u003d sock.getInputStream().read();\n+          if (val \u003c 0) {\n+            throw new EOFException();\n+          }\n+        } else {\n+          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n+                    \"Not verifying \" + slotId);\n+        }\n+        success \u003d true;\n       }\n     } finally {\n+      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n+        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n+            \"requestShortCircuitFdsForRead operation failed.\");\n+        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n+      }\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n-          ));\n+            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n        throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    SlotId registeredSlotId \u003d null;\n    boolean success \u003d false;\n    try {\n      try {\n        if (peer.getDomainSocket() \u003d\u003d null) {\n          throw new IOException(\"You cannot pass file descriptors over \" +\n              \"anything but a UNIX domain socket.\");\n        }\n        if (slotId !\u003d null) {\n          boolean isCached \u003d datanode.data.\n              isCached(blk.getBlockPoolId(), blk.getBlockId());\n          datanode.shortCircuitRegistry.registerSlot(\n              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n          registeredSlotId \u003d slotId;\n        }\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n        Preconditions.checkState(fis !\u003d null);\n        bld.setStatus(SUCCESS);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      } catch (ShortCircuitFdsVersionException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n        bld.setMessage(e.getMessage());\n      } catch (ShortCircuitFdsUnsupportedException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setMessage(e.getMessage());\n      } catch (InvalidToken e) {\n        bld.setStatus(ERROR_ACCESS_TOKEN);\n        bld.setMessage(e.getMessage());\n      } catch (IOException e) {\n        bld.setStatus(ERROR);\n        bld.setMessage(e.getMessage());\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[1];\n        if (supportsReceiptVerification) {\n          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n        } else {\n          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n        }\n        DomainSocket sock \u003d peer.getDomainSocket();\n        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n        if (supportsReceiptVerification) {\n          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n          int val \u003d sock.getInputStream().read();\n          if (val \u003c 0) {\n            throw new EOFException();\n          }\n        } else {\n          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                    \"Not verifying \" + slotId);\n        }\n        success \u003d true;\n      }\n    } finally {\n      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n            \"requestShortCircuitFdsForRead operation failed.\");\n        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n      }\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {}
        }
      ]
    },
    "32741cf3d25d85a92e3deb11c302cc2a718d71dd": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Revert \"HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\" (jenkins didn\u0027t run yet)\n\nThis reverts commit 5aa892ed486d42ae6b94c4866b92cd2b382ea640.\n",
      "commitDate": "13/03/15 6:40 PM",
      "commitName": "32741cf3d25d85a92e3deb11c302cc2a718d71dd",
      "commitAuthor": "Colin Patrick Mccabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Revert \"HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\" (jenkins didn\u0027t run yet)\n\nThis reverts commit 5aa892ed486d42ae6b94c4866b92cd2b382ea640.\n",
          "commitDate": "13/03/15 6:40 PM",
          "commitName": "32741cf3d25d85a92e3deb11c302cc2a718d71dd",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "13/03/15 6:29 PM",
          "commitNameOld": "5aa892ed486d42ae6b94c4866b92cd2b382ea640",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,85 +1,66 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n-      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n-        throws IOException {\n+      SlotId slotId, int maxVersion) throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n-    SlotId registeredSlotId \u003d null;\n-    boolean success \u003d false;\n     try {\n-      try {\n-        if (peer.getDomainSocket() \u003d\u003d null) {\n-          throw new IOException(\"You cannot pass file descriptors over \" +\n-              \"anything but a UNIX domain socket.\");\n-        }\n-        if (slotId !\u003d null) {\n-          boolean isCached \u003d datanode.data.\n-              isCached(blk.getBlockPoolId(), blk.getBlockId());\n-          datanode.shortCircuitRegistry.registerSlot(\n-              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n-          registeredSlotId \u003d slotId;\n-        }\n-        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-        Preconditions.checkState(fis !\u003d null);\n-        bld.setStatus(SUCCESS);\n-        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      } catch (ShortCircuitFdsVersionException e) {\n-        bld.setStatus(ERROR_UNSUPPORTED);\n-        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-        bld.setMessage(e.getMessage());\n-      } catch (ShortCircuitFdsUnsupportedException e) {\n-        bld.setStatus(ERROR_UNSUPPORTED);\n-        bld.setMessage(e.getMessage());\n-      } catch (InvalidToken e) {\n-        bld.setStatus(ERROR_ACCESS_TOKEN);\n-        bld.setMessage(e.getMessage());\n-      } catch (IOException e) {\n-        bld.setStatus(ERROR);\n-        bld.setMessage(e.getMessage());\n+      if (peer.getDomainSocket() \u003d\u003d null) {\n+        throw new IOException(\"You cannot pass file descriptors over \" +\n+            \"anything but a UNIX domain socket.\");\n       }\n+      if (slotId !\u003d null) {\n+        boolean isCached \u003d datanode.data.\n+            isCached(blk.getBlockPoolId(), blk.getBlockId());\n+        datanode.shortCircuitRegistry.registerSlot(\n+            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n+      }\n+      try {\n+        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n+      } finally {\n+        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n+          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n+        }\n+      }\n+      bld.setStatus(SUCCESS);\n+      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+    } catch (ShortCircuitFdsVersionException e) {\n+      bld.setStatus(ERROR_UNSUPPORTED);\n+      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+      bld.setMessage(e.getMessage());\n+    } catch (ShortCircuitFdsUnsupportedException e) {\n+      bld.setStatus(ERROR_UNSUPPORTED);\n+      bld.setMessage(e.getMessage());\n+    } catch (InvalidToken e) {\n+      bld.setStatus(ERROR_ACCESS_TOKEN);\n+      bld.setMessage(e.getMessage());\n+    } catch (IOException e) {\n+      bld.setStatus(ERROR);\n+      bld.setMessage(e.getMessage());\n+    }\n+    try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n-        byte buf[] \u003d new byte[1];\n-        if (supportsReceiptVerification) {\n-          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n-        } else {\n-          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n-        }\n-        DomainSocket sock \u003d peer.getDomainSocket();\n-        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n-        if (supportsReceiptVerification) {\n-          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n-          int val \u003d sock.getInputStream().read();\n-          if (val \u003c 0) {\n-            throw new EOFException();\n-          }\n-        } else {\n-          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n-                    \"Not verifying \" + slotId);\n-        }\n-        success \u003d true;\n+        byte buf[] \u003d new byte[] { (byte)0 };\n+        peer.getDomainSocket().\n+          sendFileDescriptors(fds, buf, 0, buf.length);\n       }\n     } finally {\n-      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n-        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n-            \"requestShortCircuitFdsForRead operation failed.\");\n-        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n-      }\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n+            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n+          ));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion) throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    try {\n      if (peer.getDomainSocket() \u003d\u003d null) {\n        throw new IOException(\"You cannot pass file descriptors over \" +\n            \"anything but a UNIX domain socket.\");\n      }\n      if (slotId !\u003d null) {\n        boolean isCached \u003d datanode.data.\n            isCached(blk.getBlockPoolId(), blk.getBlockId());\n        datanode.shortCircuitRegistry.registerSlot(\n            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n      }\n      try {\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n      } finally {\n        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n        }\n      }\n      bld.setStatus(SUCCESS);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n    } catch (ShortCircuitFdsVersionException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      bld.setMessage(e.getMessage());\n    } catch (ShortCircuitFdsUnsupportedException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setMessage(e.getMessage());\n    } catch (InvalidToken e) {\n      bld.setStatus(ERROR_ACCESS_TOKEN);\n      bld.setMessage(e.getMessage());\n    } catch (IOException e) {\n      bld.setStatus(ERROR);\n      bld.setMessage(e.getMessage());\n    }\n    try {\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[] { (byte)0 };\n        peer.getDomainSocket().\n          sendFileDescriptors(fds, buf, 0, buf.length);\n      }\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n          ));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[blk-ExtendedBlock(modifiers-final), token-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), slotId-SlotId, maxVersion-int, supportsReceiptVerification-boolean]",
            "newValue": "[blk-ExtendedBlock(modifiers-final), token-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), slotId-SlotId, maxVersion-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\" (jenkins didn\u0027t run yet)\n\nThis reverts commit 5aa892ed486d42ae6b94c4866b92cd2b382ea640.\n",
          "commitDate": "13/03/15 6:40 PM",
          "commitName": "32741cf3d25d85a92e3deb11c302cc2a718d71dd",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "13/03/15 6:29 PM",
          "commitNameOld": "5aa892ed486d42ae6b94c4866b92cd2b382ea640",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,85 +1,66 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n-      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n-        throws IOException {\n+      SlotId slotId, int maxVersion) throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n-    SlotId registeredSlotId \u003d null;\n-    boolean success \u003d false;\n     try {\n-      try {\n-        if (peer.getDomainSocket() \u003d\u003d null) {\n-          throw new IOException(\"You cannot pass file descriptors over \" +\n-              \"anything but a UNIX domain socket.\");\n-        }\n-        if (slotId !\u003d null) {\n-          boolean isCached \u003d datanode.data.\n-              isCached(blk.getBlockPoolId(), blk.getBlockId());\n-          datanode.shortCircuitRegistry.registerSlot(\n-              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n-          registeredSlotId \u003d slotId;\n-        }\n-        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-        Preconditions.checkState(fis !\u003d null);\n-        bld.setStatus(SUCCESS);\n-        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      } catch (ShortCircuitFdsVersionException e) {\n-        bld.setStatus(ERROR_UNSUPPORTED);\n-        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-        bld.setMessage(e.getMessage());\n-      } catch (ShortCircuitFdsUnsupportedException e) {\n-        bld.setStatus(ERROR_UNSUPPORTED);\n-        bld.setMessage(e.getMessage());\n-      } catch (InvalidToken e) {\n-        bld.setStatus(ERROR_ACCESS_TOKEN);\n-        bld.setMessage(e.getMessage());\n-      } catch (IOException e) {\n-        bld.setStatus(ERROR);\n-        bld.setMessage(e.getMessage());\n+      if (peer.getDomainSocket() \u003d\u003d null) {\n+        throw new IOException(\"You cannot pass file descriptors over \" +\n+            \"anything but a UNIX domain socket.\");\n       }\n+      if (slotId !\u003d null) {\n+        boolean isCached \u003d datanode.data.\n+            isCached(blk.getBlockPoolId(), blk.getBlockId());\n+        datanode.shortCircuitRegistry.registerSlot(\n+            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n+      }\n+      try {\n+        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n+      } finally {\n+        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n+          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n+        }\n+      }\n+      bld.setStatus(SUCCESS);\n+      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+    } catch (ShortCircuitFdsVersionException e) {\n+      bld.setStatus(ERROR_UNSUPPORTED);\n+      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+      bld.setMessage(e.getMessage());\n+    } catch (ShortCircuitFdsUnsupportedException e) {\n+      bld.setStatus(ERROR_UNSUPPORTED);\n+      bld.setMessage(e.getMessage());\n+    } catch (InvalidToken e) {\n+      bld.setStatus(ERROR_ACCESS_TOKEN);\n+      bld.setMessage(e.getMessage());\n+    } catch (IOException e) {\n+      bld.setStatus(ERROR);\n+      bld.setMessage(e.getMessage());\n+    }\n+    try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n-        byte buf[] \u003d new byte[1];\n-        if (supportsReceiptVerification) {\n-          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n-        } else {\n-          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n-        }\n-        DomainSocket sock \u003d peer.getDomainSocket();\n-        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n-        if (supportsReceiptVerification) {\n-          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n-          int val \u003d sock.getInputStream().read();\n-          if (val \u003c 0) {\n-            throw new EOFException();\n-          }\n-        } else {\n-          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n-                    \"Not verifying \" + slotId);\n-        }\n-        success \u003d true;\n+        byte buf[] \u003d new byte[] { (byte)0 };\n+        peer.getDomainSocket().\n+          sendFileDescriptors(fds, buf, 0, buf.length);\n       }\n     } finally {\n-      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n-        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n-            \"requestShortCircuitFdsForRead operation failed.\");\n-        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n-      }\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n+            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n+          ));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion) throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    try {\n      if (peer.getDomainSocket() \u003d\u003d null) {\n        throw new IOException(\"You cannot pass file descriptors over \" +\n            \"anything but a UNIX domain socket.\");\n      }\n      if (slotId !\u003d null) {\n        boolean isCached \u003d datanode.data.\n            isCached(blk.getBlockPoolId(), blk.getBlockId());\n        datanode.shortCircuitRegistry.registerSlot(\n            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n      }\n      try {\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n      } finally {\n        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n        }\n      }\n      bld.setStatus(SUCCESS);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n    } catch (ShortCircuitFdsVersionException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      bld.setMessage(e.getMessage());\n    } catch (ShortCircuitFdsUnsupportedException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setMessage(e.getMessage());\n    } catch (InvalidToken e) {\n      bld.setStatus(ERROR_ACCESS_TOKEN);\n      bld.setMessage(e.getMessage());\n    } catch (IOException e) {\n      bld.setStatus(ERROR);\n      bld.setMessage(e.getMessage());\n    }\n    try {\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[] { (byte)0 };\n        peer.getDomainSocket().\n          sendFileDescriptors(fds, buf, 0, buf.length);\n      }\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n          ));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {}
        }
      ]
    },
    "5aa892ed486d42ae6b94c4866b92cd2b382ea640": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\n",
      "commitDate": "13/03/15 6:29 PM",
      "commitName": "5aa892ed486d42ae6b94c4866b92cd2b382ea640",
      "commitAuthor": "Colin Patrick Mccabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\n",
          "commitDate": "13/03/15 6:29 PM",
          "commitName": "5aa892ed486d42ae6b94c4866b92cd2b382ea640",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "01/03/15 11:03 PM",
          "commitNameOld": "67ed59348d638d56e6752ba2c71fdcd69567546d",
          "commitAuthorOld": "Tsz-Wo Nicholas Sze",
          "daysBetweenCommits": 11.77,
          "commitsBetweenForRepo": 94,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,85 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n-      SlotId slotId, int maxVersion) throws IOException {\n+      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n+        throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n+    SlotId registeredSlotId \u003d null;\n+    boolean success \u003d false;\n     try {\n-      if (peer.getDomainSocket() \u003d\u003d null) {\n-        throw new IOException(\"You cannot pass file descriptors over \" +\n-            \"anything but a UNIX domain socket.\");\n-      }\n-      if (slotId !\u003d null) {\n-        boolean isCached \u003d datanode.data.\n-            isCached(blk.getBlockPoolId(), blk.getBlockId());\n-        datanode.shortCircuitRegistry.registerSlot(\n-            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n-      }\n       try {\n-        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-      } finally {\n-        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n-          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n+        if (peer.getDomainSocket() \u003d\u003d null) {\n+          throw new IOException(\"You cannot pass file descriptors over \" +\n+              \"anything but a UNIX domain socket.\");\n         }\n+        if (slotId !\u003d null) {\n+          boolean isCached \u003d datanode.data.\n+              isCached(blk.getBlockPoolId(), blk.getBlockId());\n+          datanode.shortCircuitRegistry.registerSlot(\n+              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n+          registeredSlotId \u003d slotId;\n+        }\n+        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n+        Preconditions.checkState(fis !\u003d null);\n+        bld.setStatus(SUCCESS);\n+        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+      } catch (ShortCircuitFdsVersionException e) {\n+        bld.setStatus(ERROR_UNSUPPORTED);\n+        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+        bld.setMessage(e.getMessage());\n+      } catch (ShortCircuitFdsUnsupportedException e) {\n+        bld.setStatus(ERROR_UNSUPPORTED);\n+        bld.setMessage(e.getMessage());\n+      } catch (InvalidToken e) {\n+        bld.setStatus(ERROR_ACCESS_TOKEN);\n+        bld.setMessage(e.getMessage());\n+      } catch (IOException e) {\n+        bld.setStatus(ERROR);\n+        bld.setMessage(e.getMessage());\n       }\n-      bld.setStatus(SUCCESS);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-    } catch (ShortCircuitFdsVersionException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      bld.setMessage(e.getMessage());\n-    } catch (ShortCircuitFdsUnsupportedException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setMessage(e.getMessage());\n-    } catch (InvalidToken e) {\n-      bld.setStatus(ERROR_ACCESS_TOKEN);\n-      bld.setMessage(e.getMessage());\n-    } catch (IOException e) {\n-      bld.setStatus(ERROR);\n-      bld.setMessage(e.getMessage());\n-    }\n-    try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n-        byte buf[] \u003d new byte[] { (byte)0 };\n-        peer.getDomainSocket().\n-          sendFileDescriptors(fds, buf, 0, buf.length);\n+        byte buf[] \u003d new byte[1];\n+        if (supportsReceiptVerification) {\n+          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n+        } else {\n+          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n+        }\n+        DomainSocket sock \u003d peer.getDomainSocket();\n+        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n+        if (supportsReceiptVerification) {\n+          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n+          int val \u003d sock.getInputStream().read();\n+          if (val \u003c 0) {\n+            throw new EOFException();\n+          }\n+        } else {\n+          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n+                    \"Not verifying \" + slotId);\n+        }\n+        success \u003d true;\n       }\n     } finally {\n+      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n+        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n+            \"requestShortCircuitFdsForRead operation failed.\");\n+        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n+      }\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n-          ));\n+            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n        throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    SlotId registeredSlotId \u003d null;\n    boolean success \u003d false;\n    try {\n      try {\n        if (peer.getDomainSocket() \u003d\u003d null) {\n          throw new IOException(\"You cannot pass file descriptors over \" +\n              \"anything but a UNIX domain socket.\");\n        }\n        if (slotId !\u003d null) {\n          boolean isCached \u003d datanode.data.\n              isCached(blk.getBlockPoolId(), blk.getBlockId());\n          datanode.shortCircuitRegistry.registerSlot(\n              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n          registeredSlotId \u003d slotId;\n        }\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n        Preconditions.checkState(fis !\u003d null);\n        bld.setStatus(SUCCESS);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      } catch (ShortCircuitFdsVersionException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n        bld.setMessage(e.getMessage());\n      } catch (ShortCircuitFdsUnsupportedException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setMessage(e.getMessage());\n      } catch (InvalidToken e) {\n        bld.setStatus(ERROR_ACCESS_TOKEN);\n        bld.setMessage(e.getMessage());\n      } catch (IOException e) {\n        bld.setStatus(ERROR);\n        bld.setMessage(e.getMessage());\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[1];\n        if (supportsReceiptVerification) {\n          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n        } else {\n          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n        }\n        DomainSocket sock \u003d peer.getDomainSocket();\n        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n        if (supportsReceiptVerification) {\n          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n          int val \u003d sock.getInputStream().read();\n          if (val \u003c 0) {\n            throw new EOFException();\n          }\n        } else {\n          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                    \"Not verifying \" + slotId);\n        }\n        success \u003d true;\n      }\n    } finally {\n      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n            \"requestShortCircuitFdsForRead operation failed.\");\n        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n      }\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[blk-ExtendedBlock(modifiers-final), token-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), slotId-SlotId, maxVersion-int]",
            "newValue": "[blk-ExtendedBlock(modifiers-final), token-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), slotId-SlotId, maxVersion-int, supportsReceiptVerification-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\n",
          "commitDate": "13/03/15 6:29 PM",
          "commitName": "5aa892ed486d42ae6b94c4866b92cd2b382ea640",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "01/03/15 11:03 PM",
          "commitNameOld": "67ed59348d638d56e6752ba2c71fdcd69567546d",
          "commitAuthorOld": "Tsz-Wo Nicholas Sze",
          "daysBetweenCommits": 11.77,
          "commitsBetweenForRepo": 94,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,85 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n-      SlotId slotId, int maxVersion) throws IOException {\n+      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n+        throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n+    SlotId registeredSlotId \u003d null;\n+    boolean success \u003d false;\n     try {\n-      if (peer.getDomainSocket() \u003d\u003d null) {\n-        throw new IOException(\"You cannot pass file descriptors over \" +\n-            \"anything but a UNIX domain socket.\");\n-      }\n-      if (slotId !\u003d null) {\n-        boolean isCached \u003d datanode.data.\n-            isCached(blk.getBlockPoolId(), blk.getBlockId());\n-        datanode.shortCircuitRegistry.registerSlot(\n-            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n-      }\n       try {\n-        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-      } finally {\n-        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n-          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n+        if (peer.getDomainSocket() \u003d\u003d null) {\n+          throw new IOException(\"You cannot pass file descriptors over \" +\n+              \"anything but a UNIX domain socket.\");\n         }\n+        if (slotId !\u003d null) {\n+          boolean isCached \u003d datanode.data.\n+              isCached(blk.getBlockPoolId(), blk.getBlockId());\n+          datanode.shortCircuitRegistry.registerSlot(\n+              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n+          registeredSlotId \u003d slotId;\n+        }\n+        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n+        Preconditions.checkState(fis !\u003d null);\n+        bld.setStatus(SUCCESS);\n+        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+      } catch (ShortCircuitFdsVersionException e) {\n+        bld.setStatus(ERROR_UNSUPPORTED);\n+        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n+        bld.setMessage(e.getMessage());\n+      } catch (ShortCircuitFdsUnsupportedException e) {\n+        bld.setStatus(ERROR_UNSUPPORTED);\n+        bld.setMessage(e.getMessage());\n+      } catch (InvalidToken e) {\n+        bld.setStatus(ERROR_ACCESS_TOKEN);\n+        bld.setMessage(e.getMessage());\n+      } catch (IOException e) {\n+        bld.setStatus(ERROR);\n+        bld.setMessage(e.getMessage());\n       }\n-      bld.setStatus(SUCCESS);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-    } catch (ShortCircuitFdsVersionException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      bld.setMessage(e.getMessage());\n-    } catch (ShortCircuitFdsUnsupportedException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setMessage(e.getMessage());\n-    } catch (InvalidToken e) {\n-      bld.setStatus(ERROR_ACCESS_TOKEN);\n-      bld.setMessage(e.getMessage());\n-    } catch (IOException e) {\n-      bld.setStatus(ERROR);\n-      bld.setMessage(e.getMessage());\n-    }\n-    try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n-        byte buf[] \u003d new byte[] { (byte)0 };\n-        peer.getDomainSocket().\n-          sendFileDescriptors(fds, buf, 0, buf.length);\n+        byte buf[] \u003d new byte[1];\n+        if (supportsReceiptVerification) {\n+          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n+        } else {\n+          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n+        }\n+        DomainSocket sock \u003d peer.getDomainSocket();\n+        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n+        if (supportsReceiptVerification) {\n+          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n+          int val \u003d sock.getInputStream().read();\n+          if (val \u003c 0) {\n+            throw new EOFException();\n+          }\n+        } else {\n+          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n+                    \"Not verifying \" + slotId);\n+        }\n+        success \u003d true;\n       }\n     } finally {\n+      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n+        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n+            \"requestShortCircuitFdsForRead operation failed.\");\n+        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n+      }\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n-          ));\n+            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion, boolean supportsReceiptVerification)\n        throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    SlotId registeredSlotId \u003d null;\n    boolean success \u003d false;\n    try {\n      try {\n        if (peer.getDomainSocket() \u003d\u003d null) {\n          throw new IOException(\"You cannot pass file descriptors over \" +\n              \"anything but a UNIX domain socket.\");\n        }\n        if (slotId !\u003d null) {\n          boolean isCached \u003d datanode.data.\n              isCached(blk.getBlockPoolId(), blk.getBlockId());\n          datanode.shortCircuitRegistry.registerSlot(\n              ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n          registeredSlotId \u003d slotId;\n        }\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n        Preconditions.checkState(fis !\u003d null);\n        bld.setStatus(SUCCESS);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      } catch (ShortCircuitFdsVersionException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n        bld.setMessage(e.getMessage());\n      } catch (ShortCircuitFdsUnsupportedException e) {\n        bld.setStatus(ERROR_UNSUPPORTED);\n        bld.setMessage(e.getMessage());\n      } catch (InvalidToken e) {\n        bld.setStatus(ERROR_ACCESS_TOKEN);\n        bld.setMessage(e.getMessage());\n      } catch (IOException e) {\n        bld.setStatus(ERROR);\n        bld.setMessage(e.getMessage());\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[1];\n        if (supportsReceiptVerification) {\n          buf[0] \u003d (byte)USE_RECEIPT_VERIFICATION.getNumber();\n        } else {\n          buf[0] \u003d (byte)DO_NOT_USE_RECEIPT_VERIFICATION.getNumber();\n        }\n        DomainSocket sock \u003d peer.getDomainSocket();\n        sock.sendFileDescriptors(fds, buf, 0, buf.length);\n        if (supportsReceiptVerification) {\n          LOG.trace(\"Reading receipt verification byte for \" + slotId);\n          int val \u003d sock.getInputStream().read();\n          if (val \u003c 0) {\n            throw new EOFException();\n          }\n        } else {\n          LOG.trace(\"Receipt verification is not enabled on the DataNode.  \" +\n                    \"Not verifying \" + slotId);\n        }\n        success \u003d true;\n      }\n    } finally {\n      if ((!success) \u0026\u0026 (registeredSlotId !\u003d null)) {\n        LOG.info(\"Unregistering \" + registeredSlotId + \" because the \" +\n            \"requestShortCircuitFdsForRead operation failed.\");\n        datanode.shortCircuitRegistry.unregisterSlot(registeredSlotId);\n      }\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), success));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {}
        }
      ]
    },
    "a3616c58dd2ddb16172ca3ab5d66fad52ec0e6d7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6086. Fix a case where zero-copy or no-checksum reads were not allowed even when the block was cached. (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576533 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/03/14 3:41 PM",
      "commitName": "a3616c58dd2ddb16172ca3ab5d66fad52ec0e6d7",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "03/03/14 3:51 PM",
      "commitNameOld": "9ad8dd1e8aae3eb69934b50b35909eee53ed156b",
      "commitAuthorOld": "",
      "daysBetweenCommits": 7.95,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       SlotId slotId, int maxVersion) throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     try {\n       if (peer.getDomainSocket() \u003d\u003d null) {\n         throw new IOException(\"You cannot pass file descriptors over \" +\n             \"anything but a UNIX domain socket.\");\n       }\n       if (slotId !\u003d null) {\n+        boolean isCached \u003d datanode.data.\n+            isCached(blk.getBlockPoolId(), blk.getBlockId());\n         datanode.shortCircuitRegistry.registerSlot(\n-            ExtendedBlockId.fromExtendedBlock(blk), slotId);\n+            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n       }\n       try {\n         fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n       } finally {\n         if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n           datanode.shortCircuitRegistry.unregisterSlot(slotId);\n         }\n       }\n       bld.setStatus(SUCCESS);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n     } catch (ShortCircuitFdsVersionException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       bld.setMessage(e.getMessage());\n     } catch (ShortCircuitFdsUnsupportedException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setMessage(e.getMessage());\n     } catch (InvalidToken e) {\n       bld.setStatus(ERROR_ACCESS_TOKEN);\n       bld.setMessage(e.getMessage());\n     } catch (IOException e) {\n       bld.setStatus(ERROR);\n       bld.setMessage(e.getMessage());\n     }\n     try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[] { (byte)0 };\n         peer.getDomainSocket().\n           sendFileDescriptors(fds, buf, 0, buf.length);\n       }\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n             blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n           ));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion) throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    try {\n      if (peer.getDomainSocket() \u003d\u003d null) {\n        throw new IOException(\"You cannot pass file descriptors over \" +\n            \"anything but a UNIX domain socket.\");\n      }\n      if (slotId !\u003d null) {\n        boolean isCached \u003d datanode.data.\n            isCached(blk.getBlockPoolId(), blk.getBlockId());\n        datanode.shortCircuitRegistry.registerSlot(\n            ExtendedBlockId.fromExtendedBlock(blk), slotId, isCached);\n      }\n      try {\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n      } finally {\n        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n        }\n      }\n      bld.setStatus(SUCCESS);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n    } catch (ShortCircuitFdsVersionException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      bld.setMessage(e.getMessage());\n    } catch (ShortCircuitFdsUnsupportedException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setMessage(e.getMessage());\n    } catch (InvalidToken e) {\n      bld.setStatus(ERROR_ACCESS_TOKEN);\n      bld.setMessage(e.getMessage());\n    } catch (IOException e) {\n      bld.setStatus(ERROR);\n      bld.setMessage(e.getMessage());\n    }\n    try {\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[] { (byte)0 };\n        peer.getDomainSocket().\n          sendFileDescriptors(fds, buf, 0, buf.length);\n      }\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n          ));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/03/14 7:58 PM",
      "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/03/14 7:58 PM",
          "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "30/01/14 11:15 AM",
          "commitNameOld": "3d9ad8e3b60dd21db45466f4736abe6b1812b522",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 31.36,
          "commitsBetweenForRepo": 251,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,64 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n-      int maxVersion) throws IOException {\n+      SlotId slotId, int maxVersion) throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     try {\n       if (peer.getDomainSocket() \u003d\u003d null) {\n         throw new IOException(\"You cannot pass file descriptors over \" +\n             \"anything but a UNIX domain socket.\");\n       }\n-      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n+      if (slotId !\u003d null) {\n+        datanode.shortCircuitRegistry.registerSlot(\n+            ExtendedBlockId.fromExtendedBlock(blk), slotId);\n+      }\n+      try {\n+        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n+      } finally {\n+        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n+          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n+        }\n+      }\n       bld.setStatus(SUCCESS);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n     } catch (ShortCircuitFdsVersionException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       bld.setMessage(e.getMessage());\n     } catch (ShortCircuitFdsUnsupportedException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setMessage(e.getMessage());\n     } catch (InvalidToken e) {\n       bld.setStatus(ERROR_ACCESS_TOKEN);\n       bld.setMessage(e.getMessage());\n     } catch (IOException e) {\n       bld.setStatus(ERROR);\n       bld.setMessage(e.getMessage());\n     }\n     try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[] { (byte)0 };\n         peer.getDomainSocket().\n           sendFileDescriptors(fds, buf, 0, buf.length);\n       }\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n             blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n           ));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion) throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    try {\n      if (peer.getDomainSocket() \u003d\u003d null) {\n        throw new IOException(\"You cannot pass file descriptors over \" +\n            \"anything but a UNIX domain socket.\");\n      }\n      if (slotId !\u003d null) {\n        datanode.shortCircuitRegistry.registerSlot(\n            ExtendedBlockId.fromExtendedBlock(blk), slotId);\n      }\n      try {\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n      } finally {\n        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n        }\n      }\n      bld.setStatus(SUCCESS);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n    } catch (ShortCircuitFdsVersionException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      bld.setMessage(e.getMessage());\n    } catch (ShortCircuitFdsUnsupportedException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setMessage(e.getMessage());\n    } catch (InvalidToken e) {\n      bld.setStatus(ERROR_ACCESS_TOKEN);\n      bld.setMessage(e.getMessage());\n    } catch (IOException e) {\n      bld.setStatus(ERROR);\n      bld.setMessage(e.getMessage());\n    }\n    try {\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[] { (byte)0 };\n        peer.getDomainSocket().\n          sendFileDescriptors(fds, buf, 0, buf.length);\n      }\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n          ));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[blk-ExtendedBlock(modifiers-final), token-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), maxVersion-int]",
            "newValue": "[blk-ExtendedBlock(modifiers-final), token-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), slotId-SlotId, maxVersion-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/03/14 7:58 PM",
          "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "30/01/14 11:15 AM",
          "commitNameOld": "3d9ad8e3b60dd21db45466f4736abe6b1812b522",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 31.36,
          "commitsBetweenForRepo": 251,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,64 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n-      int maxVersion) throws IOException {\n+      SlotId slotId, int maxVersion) throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     try {\n       if (peer.getDomainSocket() \u003d\u003d null) {\n         throw new IOException(\"You cannot pass file descriptors over \" +\n             \"anything but a UNIX domain socket.\");\n       }\n-      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n+      if (slotId !\u003d null) {\n+        datanode.shortCircuitRegistry.registerSlot(\n+            ExtendedBlockId.fromExtendedBlock(blk), slotId);\n+      }\n+      try {\n+        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n+      } finally {\n+        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n+          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n+        }\n+      }\n       bld.setStatus(SUCCESS);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n     } catch (ShortCircuitFdsVersionException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       bld.setMessage(e.getMessage());\n     } catch (ShortCircuitFdsUnsupportedException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setMessage(e.getMessage());\n     } catch (InvalidToken e) {\n       bld.setStatus(ERROR_ACCESS_TOKEN);\n       bld.setMessage(e.getMessage());\n     } catch (IOException e) {\n       bld.setStatus(ERROR);\n       bld.setMessage(e.getMessage());\n     }\n     try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[] { (byte)0 };\n         peer.getDomainSocket().\n           sendFileDescriptors(fds, buf, 0, buf.length);\n       }\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n             blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n           ));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      SlotId slotId, int maxVersion) throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    try {\n      if (peer.getDomainSocket() \u003d\u003d null) {\n        throw new IOException(\"You cannot pass file descriptors over \" +\n            \"anything but a UNIX domain socket.\");\n      }\n      if (slotId !\u003d null) {\n        datanode.shortCircuitRegistry.registerSlot(\n            ExtendedBlockId.fromExtendedBlock(blk), slotId);\n      }\n      try {\n        fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n      } finally {\n        if ((fis \u003d\u003d null) \u0026\u0026 (slotId !\u003d null)) {\n          datanode.shortCircuitRegistry.unregisterSlot(slotId);\n        }\n      }\n      bld.setStatus(SUCCESS);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n    } catch (ShortCircuitFdsVersionException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      bld.setMessage(e.getMessage());\n    } catch (ShortCircuitFdsUnsupportedException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setMessage(e.getMessage());\n    } catch (InvalidToken e) {\n      bld.setStatus(ERROR_ACCESS_TOKEN);\n      bld.setMessage(e.getMessage());\n    } catch (IOException e) {\n      bld.setStatus(ERROR);\n      bld.setMessage(e.getMessage());\n    }\n    try {\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[] { (byte)0 };\n        peer.getDomainSocket().\n          sendFileDescriptors(fds, buf, 0, buf.length);\n      }\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n          ));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {}
        }
      ]
    },
    "4551da302d94cffea0313eac79479ab6f9b7cb34": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5233. Use Datanode UUID to identify Datanodes.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1525407 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/09/13 11:03 AM",
      "commitName": "4551da302d94cffea0313eac79479ab6f9b7cb34",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "22/07/13 11:15 AM",
      "commitNameOld": "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 61.99,
      "commitsBetweenForRepo": 352,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       int maxVersion) throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     try {\n       if (peer.getDomainSocket() \u003d\u003d null) {\n         throw new IOException(\"You cannot pass file descriptors over \" +\n             \"anything but a UNIX domain socket.\");\n       }\n       fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n       bld.setStatus(SUCCESS);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n     } catch (ShortCircuitFdsVersionException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       bld.setMessage(e.getMessage());\n     } catch (ShortCircuitFdsUnsupportedException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setMessage(e.getMessage());\n     } catch (InvalidToken e) {\n       bld.setStatus(ERROR_ACCESS_TOKEN);\n       bld.setMessage(e.getMessage());\n     } catch (IOException e) {\n       bld.setStatus(ERROR);\n       bld.setMessage(e.getMessage());\n     }\n     try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[] { (byte)0 };\n         peer.getDomainSocket().\n           sendFileDescriptors(fds, buf, 0, buf.length);\n       }\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getStorageID(), (fis !\u003d null)\n+            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n           ));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      int maxVersion) throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    try {\n      if (peer.getDomainSocket() \u003d\u003d null) {\n        throw new IOException(\"You cannot pass file descriptors over \" +\n            \"anything but a UNIX domain socket.\");\n      }\n      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n      bld.setStatus(SUCCESS);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n    } catch (ShortCircuitFdsVersionException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      bld.setMessage(e.getMessage());\n    } catch (ShortCircuitFdsUnsupportedException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setMessage(e.getMessage());\n    } catch (InvalidToken e) {\n      bld.setStatus(ERROR_ACCESS_TOKEN);\n      bld.setMessage(e.getMessage());\n    } catch (IOException e) {\n      bld.setStatus(ERROR);\n      bld.setMessage(e.getMessage());\n    }\n    try {\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[] { (byte)0 };\n        peer.getDomainSocket().\n          sendFileDescriptors(fds, buf, 0, buf.length);\n      }\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n          ));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "a18fd620d070cf8e84aaf80d93807ac9ee207a0f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4661. A few little code cleanups of some HDFS-347-related code. Contributed by Colin Patrick McCabe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480839 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/05/13 5:03 PM",
      "commitName": "a18fd620d070cf8e84aaf80d93807ac9ee207a0f",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "23/01/13 10:38 AM",
      "commitNameOld": "d12f465c674b3bb5102671b6d6c2746261602d7e",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 106.23,
      "commitsBetweenForRepo": 615,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,54 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       int maxVersion) throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     try {\n       if (peer.getDomainSocket() \u003d\u003d null) {\n         throw new IOException(\"You cannot pass file descriptors over \" +\n             \"anything but a UNIX domain socket.\");\n       }\n       fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n       bld.setStatus(SUCCESS);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n     } catch (ShortCircuitFdsVersionException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       bld.setMessage(e.getMessage());\n     } catch (ShortCircuitFdsUnsupportedException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setMessage(e.getMessage());\n     } catch (InvalidToken e) {\n       bld.setStatus(ERROR_ACCESS_TOKEN);\n       bld.setMessage(e.getMessage());\n     } catch (IOException e) {\n       bld.setStatus(ERROR);\n       bld.setMessage(e.getMessage());\n     }\n     try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[] { (byte)0 };\n         peer.getDomainSocket().\n           sendFileDescriptors(fds, buf, 0, buf.length);\n       }\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n-          String.format(\n-            \"src: %s, dest: %s, op: %s, blockid: %s, srvID: %s, \" +\n-              \"success: %b\",\n-            \"127.0.0.1\",                   // src IP\n-            \"127.0.0.1\",                   // dst IP\n-            \"REQUEST_SHORT_CIRCUIT_FDS\",   // operation\n-            blk.getBlockId(),             // block id\n-            dnR.getStorageID(),\n-            (fis !\u003d null)\n-          )));\n+            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n+            \" blockid: %s, srvID: %s, success: %b\",\n+            blk.getBlockId(), dnR.getStorageID(), (fis !\u003d null)\n+          ));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      int maxVersion) throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    try {\n      if (peer.getDomainSocket() \u003d\u003d null) {\n        throw new IOException(\"You cannot pass file descriptors over \" +\n            \"anything but a UNIX domain socket.\");\n      }\n      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n      bld.setStatus(SUCCESS);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n    } catch (ShortCircuitFdsVersionException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      bld.setMessage(e.getMessage());\n    } catch (ShortCircuitFdsUnsupportedException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setMessage(e.getMessage());\n    } catch (InvalidToken e) {\n      bld.setStatus(ERROR_ACCESS_TOKEN);\n      bld.setMessage(e.getMessage());\n    } catch (IOException e) {\n      bld.setStatus(ERROR);\n      bld.setMessage(e.getMessage());\n    }\n    try {\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[] { (byte)0 };\n        peer.getDomainSocket().\n          sendFileDescriptors(fds, buf, 0, buf.length);\n      }\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getStorageID(), (fis !\u003d null)\n          ));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    }
  }
}