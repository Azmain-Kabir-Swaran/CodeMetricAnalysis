{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FederationClientInterceptor.java",
  "functionName": "invokeConcurrent",
  "functionId": "invokeConcurrent___clusterIds-ArrayList__SubClusterId____request-ClientMethod__clazz-Class__R__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-router/src/main/java/org/apache/hadoop/yarn/server/router/clientrm/FederationClientInterceptor.java",
  "functionStartLine": 622,
  "functionEndLine": 677,
  "numCommitsSeen": 16,
  "timeTaken": 2427,
  "changeHistory": [
    "3f2f4186f6543272cf4bb7c815f1f46ba50e7640",
    "7093afd8746cc120875eb27053bad692482d2aab",
    "3dc2988a3779590409cbe7062046e3fee68f8d22"
  ],
  "changeHistoryShort": {
    "3f2f4186f6543272cf4bb7c815f1f46ba50e7640": "Ybodychange",
    "7093afd8746cc120875eb27053bad692482d2aab": "Ybodychange",
    "3dc2988a3779590409cbe7062046e3fee68f8d22": "Yintroduced"
  },
  "changeHistoryDetails": {
    "3f2f4186f6543272cf4bb7c815f1f46ba50e7640": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9424. Change getDeclaredMethods to getMethods in FederationClientInterceptor#invokeConcurrent. Contributed by Shen Yinjie.\n",
      "commitDate": "23/04/19 7:58 PM",
      "commitName": "3f2f4186f6543272cf4bb7c815f1f46ba50e7640",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 39.15,
      "commitsBetweenForRepo": 264,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n   \u003cR\u003e Map\u003cSubClusterId, R\u003e invokeConcurrent(ArrayList\u003cSubClusterId\u003e clusterIds,\n       ClientMethod request, Class\u003cR\u003e clazz) throws YarnException, IOException {\n     List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n     List\u003cFuture\u003cObject\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n     Map\u003cSubClusterId, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n     for (SubClusterId subClusterId : clusterIds) {\n       callables.add(new Callable\u003cObject\u003e() {\n         @Override\n         public Object call() throws Exception {\n           ApplicationClientProtocol protocol \u003d\n               getClientRMProxyForSubCluster(subClusterId);\n           Method method \u003d ApplicationClientProtocol.class\n-              .getDeclaredMethod(request.getMethodName(), request.getTypes());\n+              .getMethod(request.getMethodName(), request.getTypes());\n           return method.invoke(protocol, request.getParams());\n         }\n       });\n     }\n     Map\u003cSubClusterId, R\u003e results \u003d new TreeMap\u003c\u003e();\n     try {\n       futures.addAll(executorService.invokeAll(callables));\n       for (int i \u003d 0; i \u003c futures.size(); i++) {\n         SubClusterId subClusterId \u003d clusterIds.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(subClusterId, clazz.cast(result));\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Cannot execute {} on {}: {}\", request.getMethodName(),\n               subClusterId.getId(), cause.getMessage());\n           IOException ioe;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else if (cause instanceof YarnException) {\n             throw (YarnException) cause;\n           } else {\n             ioe \u003d new IOException(\n                 \"Unhandled exception while calling \" + request.getMethodName()\n                     + \": \" + cause.getMessage(), cause);\n           }\n           // Store the exceptions\n           exceptions.put(subClusterId, ioe);\n         }\n       }\n       if (results.isEmpty() \u0026\u0026 !clusterIds.isEmpty()) {\n         SubClusterId subClusterId \u003d clusterIds.get(0);\n         IOException ioe \u003d exceptions.get(subClusterId);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n     } catch (InterruptedException e) {\n       throw new YarnException(e);\n     }\n     return results;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  \u003cR\u003e Map\u003cSubClusterId, R\u003e invokeConcurrent(ArrayList\u003cSubClusterId\u003e clusterIds,\n      ClientMethod request, Class\u003cR\u003e clazz) throws YarnException, IOException {\n    List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n    List\u003cFuture\u003cObject\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n    Map\u003cSubClusterId, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n    for (SubClusterId subClusterId : clusterIds) {\n      callables.add(new Callable\u003cObject\u003e() {\n        @Override\n        public Object call() throws Exception {\n          ApplicationClientProtocol protocol \u003d\n              getClientRMProxyForSubCluster(subClusterId);\n          Method method \u003d ApplicationClientProtocol.class\n              .getMethod(request.getMethodName(), request.getTypes());\n          return method.invoke(protocol, request.getParams());\n        }\n      });\n    }\n    Map\u003cSubClusterId, R\u003e results \u003d new TreeMap\u003c\u003e();\n    try {\n      futures.addAll(executorService.invokeAll(callables));\n      for (int i \u003d 0; i \u003c futures.size(); i++) {\n        SubClusterId subClusterId \u003d clusterIds.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(subClusterId, clazz.cast(result));\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Cannot execute {} on {}: {}\", request.getMethodName(),\n              subClusterId.getId(), cause.getMessage());\n          IOException ioe;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else if (cause instanceof YarnException) {\n            throw (YarnException) cause;\n          } else {\n            ioe \u003d new IOException(\n                \"Unhandled exception while calling \" + request.getMethodName()\n                    + \": \" + cause.getMessage(), cause);\n          }\n          // Store the exceptions\n          exceptions.put(subClusterId, ioe);\n        }\n      }\n      if (results.isEmpty() \u0026\u0026 !clusterIds.isEmpty()) {\n        SubClusterId subClusterId \u003d clusterIds.get(0);\n        IOException ioe \u003d exceptions.get(subClusterId);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n    } catch (InterruptedException e) {\n      throw new YarnException(e);\n    }\n    return results;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-router/src/main/java/org/apache/hadoop/yarn/server/router/clientrm/FederationClientInterceptor.java",
      "extendedDetails": {}
    },
    "7093afd8746cc120875eb27053bad692482d2aab": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8829. Cluster metrics can fail with IndexOutOfBoundsException. Contributed by Akshay Agarwal.\n",
      "commitDate": "28/09/18 12:05 AM",
      "commitName": "7093afd8746cc120875eb27053bad692482d2aab",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "8cf6a9a2bde9d4ccad95a514885634792889ec7f",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 15.86,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n   \u003cR\u003e Map\u003cSubClusterId, R\u003e invokeConcurrent(ArrayList\u003cSubClusterId\u003e clusterIds,\n       ClientMethod request, Class\u003cR\u003e clazz) throws YarnException, IOException {\n     List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n     List\u003cFuture\u003cObject\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n     Map\u003cSubClusterId, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n     for (SubClusterId subClusterId : clusterIds) {\n       callables.add(new Callable\u003cObject\u003e() {\n         @Override\n         public Object call() throws Exception {\n           ApplicationClientProtocol protocol \u003d\n               getClientRMProxyForSubCluster(subClusterId);\n           Method method \u003d ApplicationClientProtocol.class\n               .getDeclaredMethod(request.getMethodName(), request.getTypes());\n           return method.invoke(protocol, request.getParams());\n         }\n       });\n     }\n     Map\u003cSubClusterId, R\u003e results \u003d new TreeMap\u003c\u003e();\n     try {\n       futures.addAll(executorService.invokeAll(callables));\n       for (int i \u003d 0; i \u003c futures.size(); i++) {\n         SubClusterId subClusterId \u003d clusterIds.get(i);\n         try {\n           Future\u003cObject\u003e future \u003d futures.get(i);\n           Object result \u003d future.get();\n           results.put(subClusterId, clazz.cast(result));\n         } catch (ExecutionException ex) {\n           Throwable cause \u003d ex.getCause();\n           LOG.debug(\"Cannot execute {} on {}: {}\", request.getMethodName(),\n               subClusterId.getId(), cause.getMessage());\n           IOException ioe;\n           if (cause instanceof IOException) {\n             ioe \u003d (IOException) cause;\n           } else if (cause instanceof YarnException) {\n             throw (YarnException) cause;\n           } else {\n             ioe \u003d new IOException(\n                 \"Unhandled exception while calling \" + request.getMethodName()\n                     + \": \" + cause.getMessage(), cause);\n           }\n           // Store the exceptions\n           exceptions.put(subClusterId, ioe);\n         }\n       }\n-      if (results.isEmpty()) {\n+      if (results.isEmpty() \u0026\u0026 !clusterIds.isEmpty()) {\n         SubClusterId subClusterId \u003d clusterIds.get(0);\n         IOException ioe \u003d exceptions.get(subClusterId);\n         if (ioe !\u003d null) {\n           throw ioe;\n         }\n       }\n     } catch (InterruptedException e) {\n       throw new YarnException(e);\n     }\n     return results;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  \u003cR\u003e Map\u003cSubClusterId, R\u003e invokeConcurrent(ArrayList\u003cSubClusterId\u003e clusterIds,\n      ClientMethod request, Class\u003cR\u003e clazz) throws YarnException, IOException {\n    List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n    List\u003cFuture\u003cObject\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n    Map\u003cSubClusterId, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n    for (SubClusterId subClusterId : clusterIds) {\n      callables.add(new Callable\u003cObject\u003e() {\n        @Override\n        public Object call() throws Exception {\n          ApplicationClientProtocol protocol \u003d\n              getClientRMProxyForSubCluster(subClusterId);\n          Method method \u003d ApplicationClientProtocol.class\n              .getDeclaredMethod(request.getMethodName(), request.getTypes());\n          return method.invoke(protocol, request.getParams());\n        }\n      });\n    }\n    Map\u003cSubClusterId, R\u003e results \u003d new TreeMap\u003c\u003e();\n    try {\n      futures.addAll(executorService.invokeAll(callables));\n      for (int i \u003d 0; i \u003c futures.size(); i++) {\n        SubClusterId subClusterId \u003d clusterIds.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(subClusterId, clazz.cast(result));\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Cannot execute {} on {}: {}\", request.getMethodName(),\n              subClusterId.getId(), cause.getMessage());\n          IOException ioe;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else if (cause instanceof YarnException) {\n            throw (YarnException) cause;\n          } else {\n            ioe \u003d new IOException(\n                \"Unhandled exception while calling \" + request.getMethodName()\n                    + \": \" + cause.getMessage(), cause);\n          }\n          // Store the exceptions\n          exceptions.put(subClusterId, ioe);\n        }\n      }\n      if (results.isEmpty() \u0026\u0026 !clusterIds.isEmpty()) {\n        SubClusterId subClusterId \u003d clusterIds.get(0);\n        IOException ioe \u003d exceptions.get(subClusterId);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n    } catch (InterruptedException e) {\n      throw new YarnException(e);\n    }\n    return results;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-router/src/main/java/org/apache/hadoop/yarn/server/router/clientrm/FederationClientInterceptor.java",
      "extendedDetails": {}
    },
    "3dc2988a3779590409cbe7062046e3fee68f8d22": {
      "type": "Yintroduced",
      "commitMessage": "YARN-8699. Add Yarnclient#yarnclusterMetrics API implementation in router. Contributed by Bibin A Chundatt.\n",
      "commitDate": "07/09/18 11:32 AM",
      "commitName": "3dc2988a3779590409cbe7062046e3fee68f8d22",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "diff": "@@ -0,0 +1,56 @@\n+  \u003cR\u003e Map\u003cSubClusterId, R\u003e invokeConcurrent(ArrayList\u003cSubClusterId\u003e clusterIds,\n+      ClientMethod request, Class\u003cR\u003e clazz) throws YarnException, IOException {\n+    List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n+    List\u003cFuture\u003cObject\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n+    Map\u003cSubClusterId, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n+    for (SubClusterId subClusterId : clusterIds) {\n+      callables.add(new Callable\u003cObject\u003e() {\n+        @Override\n+        public Object call() throws Exception {\n+          ApplicationClientProtocol protocol \u003d\n+              getClientRMProxyForSubCluster(subClusterId);\n+          Method method \u003d ApplicationClientProtocol.class\n+              .getDeclaredMethod(request.getMethodName(), request.getTypes());\n+          return method.invoke(protocol, request.getParams());\n+        }\n+      });\n+    }\n+    Map\u003cSubClusterId, R\u003e results \u003d new TreeMap\u003c\u003e();\n+    try {\n+      futures.addAll(executorService.invokeAll(callables));\n+      for (int i \u003d 0; i \u003c futures.size(); i++) {\n+        SubClusterId subClusterId \u003d clusterIds.get(i);\n+        try {\n+          Future\u003cObject\u003e future \u003d futures.get(i);\n+          Object result \u003d future.get();\n+          results.put(subClusterId, clazz.cast(result));\n+        } catch (ExecutionException ex) {\n+          Throwable cause \u003d ex.getCause();\n+          LOG.debug(\"Cannot execute {} on {}: {}\", request.getMethodName(),\n+              subClusterId.getId(), cause.getMessage());\n+          IOException ioe;\n+          if (cause instanceof IOException) {\n+            ioe \u003d (IOException) cause;\n+          } else if (cause instanceof YarnException) {\n+            throw (YarnException) cause;\n+          } else {\n+            ioe \u003d new IOException(\n+                \"Unhandled exception while calling \" + request.getMethodName()\n+                    + \": \" + cause.getMessage(), cause);\n+          }\n+          // Store the exceptions\n+          exceptions.put(subClusterId, ioe);\n+        }\n+      }\n+      if (results.isEmpty()) {\n+        SubClusterId subClusterId \u003d clusterIds.get(0);\n+        IOException ioe \u003d exceptions.get(subClusterId);\n+        if (ioe !\u003d null) {\n+          throw ioe;\n+        }\n+      }\n+    } catch (InterruptedException e) {\n+      throw new YarnException(e);\n+    }\n+    return results;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  \u003cR\u003e Map\u003cSubClusterId, R\u003e invokeConcurrent(ArrayList\u003cSubClusterId\u003e clusterIds,\n      ClientMethod request, Class\u003cR\u003e clazz) throws YarnException, IOException {\n    List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n    List\u003cFuture\u003cObject\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n    Map\u003cSubClusterId, IOException\u003e exceptions \u003d new TreeMap\u003c\u003e();\n    for (SubClusterId subClusterId : clusterIds) {\n      callables.add(new Callable\u003cObject\u003e() {\n        @Override\n        public Object call() throws Exception {\n          ApplicationClientProtocol protocol \u003d\n              getClientRMProxyForSubCluster(subClusterId);\n          Method method \u003d ApplicationClientProtocol.class\n              .getDeclaredMethod(request.getMethodName(), request.getTypes());\n          return method.invoke(protocol, request.getParams());\n        }\n      });\n    }\n    Map\u003cSubClusterId, R\u003e results \u003d new TreeMap\u003c\u003e();\n    try {\n      futures.addAll(executorService.invokeAll(callables));\n      for (int i \u003d 0; i \u003c futures.size(); i++) {\n        SubClusterId subClusterId \u003d clusterIds.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          Object result \u003d future.get();\n          results.put(subClusterId, clazz.cast(result));\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Cannot execute {} on {}: {}\", request.getMethodName(),\n              subClusterId.getId(), cause.getMessage());\n          IOException ioe;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else if (cause instanceof YarnException) {\n            throw (YarnException) cause;\n          } else {\n            ioe \u003d new IOException(\n                \"Unhandled exception while calling \" + request.getMethodName()\n                    + \": \" + cause.getMessage(), cause);\n          }\n          // Store the exceptions\n          exceptions.put(subClusterId, ioe);\n        }\n      }\n      if (results.isEmpty()) {\n        SubClusterId subClusterId \u003d clusterIds.get(0);\n        IOException ioe \u003d exceptions.get(subClusterId);\n        if (ioe !\u003d null) {\n          throw ioe;\n        }\n      }\n    } catch (InterruptedException e) {\n      throw new YarnException(e);\n    }\n    return results;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-router/src/main/java/org/apache/hadoop/yarn/server/router/clientrm/FederationClientInterceptor.java"
    }
  }
}