{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AvailableSpaceVolumeChoosingPolicy.java",
  "functionName": "chooseVolume",
  "functionId": "chooseVolume___volumes-List__V____replicaSize-long__storageId-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java",
  "functionStartLine": 117,
  "functionEndLine": 131,
  "numCommitsSeen": 27,
  "timeTaken": 3922,
  "changeHistory": [
    "a3954ccab148bddc290cb96528e63ff19799bcc9",
    "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e",
    "a317bd7b02c37bd57743bfad59593ec12f53f4ed",
    "9528ed939df8f2cf0604bac7220fe8cd7394edd8",
    "a9d515aed870535ea80500c6dac7612720774cda"
  ],
  "changeHistoryShort": {
    "a3954ccab148bddc290cb96528e63ff19799bcc9": "Ymultichange(Yparameterchange,Ybodychange)",
    "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e": "Ymultichange(Ymodifierchange,Ybodychange)",
    "a317bd7b02c37bd57743bfad59593ec12f53f4ed": "Yparametermetachange",
    "9528ed939df8f2cf0604bac7220fe8cd7394edd8": "Ybodychange",
    "a9d515aed870535ea80500c6dac7612720774cda": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a3954ccab148bddc290cb96528e63ff19799bcc9": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
      "commitDate": "05/05/17 12:01 PM",
      "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
      "commitAuthor": "Chris Douglas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
          "commitDate": "05/05/17 12:01 PM",
          "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "17/02/16 11:29 AM",
          "commitNameOld": "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 442.98,
          "commitsBetweenForRepo": 2921,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,15 +1,15 @@\n-  public V chooseVolume(List\u003cV\u003e volumes,\n-      long replicaSize) throws IOException {\n+  public V chooseVolume(List\u003cV\u003e volumes, long replicaSize, String storageId)\n+      throws IOException {\n     if (volumes.size() \u003c 1) {\n       throw new DiskOutOfSpaceException(\"No more available volumes\");\n     }\n     // As all the items in volumes are with the same storage type,\n     // so only need to get the storage type index of the first item in volumes\n     StorageType storageType \u003d volumes.get(0).getStorageType();\n     int index \u003d storageType !\u003d null ?\n             storageType.ordinal() : StorageType.DEFAULT.ordinal();\n \n     synchronized (syncLocks[index]) {\n-      return doChooseVolume(volumes, replicaSize);\n+      return doChooseVolume(volumes, replicaSize, storageId);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public V chooseVolume(List\u003cV\u003e volumes, long replicaSize, String storageId)\n      throws IOException {\n    if (volumes.size() \u003c 1) {\n      throw new DiskOutOfSpaceException(\"No more available volumes\");\n    }\n    // As all the items in volumes are with the same storage type,\n    // so only need to get the storage type index of the first item in volumes\n    StorageType storageType \u003d volumes.get(0).getStorageType();\n    int index \u003d storageType !\u003d null ?\n            storageType.ordinal() : StorageType.DEFAULT.ordinal();\n\n    synchronized (syncLocks[index]) {\n      return doChooseVolume(volumes, replicaSize, storageId);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java",
          "extendedDetails": {
            "oldValue": "[volumes-List\u003cV\u003e, replicaSize-long]",
            "newValue": "[volumes-List\u003cV\u003e, replicaSize-long, storageId-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
          "commitDate": "05/05/17 12:01 PM",
          "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "17/02/16 11:29 AM",
          "commitNameOld": "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 442.98,
          "commitsBetweenForRepo": 2921,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,15 +1,15 @@\n-  public V chooseVolume(List\u003cV\u003e volumes,\n-      long replicaSize) throws IOException {\n+  public V chooseVolume(List\u003cV\u003e volumes, long replicaSize, String storageId)\n+      throws IOException {\n     if (volumes.size() \u003c 1) {\n       throw new DiskOutOfSpaceException(\"No more available volumes\");\n     }\n     // As all the items in volumes are with the same storage type,\n     // so only need to get the storage type index of the first item in volumes\n     StorageType storageType \u003d volumes.get(0).getStorageType();\n     int index \u003d storageType !\u003d null ?\n             storageType.ordinal() : StorageType.DEFAULT.ordinal();\n \n     synchronized (syncLocks[index]) {\n-      return doChooseVolume(volumes, replicaSize);\n+      return doChooseVolume(volumes, replicaSize, storageId);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public V chooseVolume(List\u003cV\u003e volumes, long replicaSize, String storageId)\n      throws IOException {\n    if (volumes.size() \u003c 1) {\n      throw new DiskOutOfSpaceException(\"No more available volumes\");\n    }\n    // As all the items in volumes are with the same storage type,\n    // so only need to get the storage type index of the first item in volumes\n    StorageType storageType \u003d volumes.get(0).getStorageType();\n    int index \u003d storageType !\u003d null ?\n            storageType.ordinal() : StorageType.DEFAULT.ordinal();\n\n    synchronized (syncLocks[index]) {\n      return doChooseVolume(volumes, replicaSize, storageId);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-9608. Disk IO imbalance in HDFS with heterogeneous storages. Contributed by Wei Zhou.\n",
      "commitDate": "17/02/16 11:29 AM",
      "commitName": "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-9608. Disk IO imbalance in HDFS with heterogeneous storages. Contributed by Wei Zhou.\n",
          "commitDate": "17/02/16 11:29 AM",
          "commitName": "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "27/08/14 9:47 PM",
          "commitNameOld": "eb448e14399e17f11b9e523e4050de245b9b0408",
          "commitAuthorOld": "arp",
          "daysBetweenCommits": 538.61,
          "commitsBetweenForRepo": 4373,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,15 @@\n-  public synchronized V chooseVolume(List\u003cV\u003e volumes,\n+  public V chooseVolume(List\u003cV\u003e volumes,\n       long replicaSize) throws IOException {\n     if (volumes.size() \u003c 1) {\n       throw new DiskOutOfSpaceException(\"No more available volumes\");\n     }\n-    \n-    AvailableSpaceVolumeList volumesWithSpaces \u003d\n-        new AvailableSpaceVolumeList(volumes);\n-    \n-    if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n-      // If they\u0027re actually not too far out of whack, fall back on pure round\n-      // robin.\n-      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"All volumes are within the configured free space balance \" +\n-            \"threshold. Selecting \" + volume + \" for write of block size \" +\n-            replicaSize);\n-      }\n-      return volume;\n-    } else {\n-      V volume \u003d null;\n-      // If none of the volumes with low free space have enough space for the\n-      // replica, always try to choose a volume with a lot of free space.\n-      long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n-          .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n-      \n-      List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n-          volumesWithSpaces.getVolumesWithHighAvailableSpace());\n-      List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n-          volumesWithSpaces.getVolumesWithLowAvailableSpace());\n-      \n-      float preferencePercentScaler \u003d\n-          (highAvailableVolumes.size() * balancedPreferencePercent) +\n-          (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n-      float scaledPreferencePercent \u003d\n-          (highAvailableVolumes.size() * balancedPreferencePercent) /\n-          preferencePercentScaler;\n-      if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n-          random.nextFloat() \u003c scaledPreferencePercent) {\n-        volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n-            highAvailableVolumes, replicaSize);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n-              \" from high available space volumes for write of block size \"\n-              + replicaSize);\n-        }\n-      } else {\n-        volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n-            lowAvailableVolumes, replicaSize);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n-              \" from low available space volumes for write of block size \"\n-              + replicaSize);\n-        }\n-      }\n-      return volume;\n+    // As all the items in volumes are with the same storage type,\n+    // so only need to get the storage type index of the first item in volumes\n+    StorageType storageType \u003d volumes.get(0).getStorageType();\n+    int index \u003d storageType !\u003d null ?\n+            storageType.ordinal() : StorageType.DEFAULT.ordinal();\n+\n+    synchronized (syncLocks[index]) {\n+      return doChooseVolume(volumes, replicaSize);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public V chooseVolume(List\u003cV\u003e volumes,\n      long replicaSize) throws IOException {\n    if (volumes.size() \u003c 1) {\n      throw new DiskOutOfSpaceException(\"No more available volumes\");\n    }\n    // As all the items in volumes are with the same storage type,\n    // so only need to get the storage type index of the first item in volumes\n    StorageType storageType \u003d volumes.get(0).getStorageType();\n    int index \u003d storageType !\u003d null ?\n            storageType.ordinal() : StorageType.DEFAULT.ordinal();\n\n    synchronized (syncLocks[index]) {\n      return doChooseVolume(volumes, replicaSize);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9608. Disk IO imbalance in HDFS with heterogeneous storages. Contributed by Wei Zhou.\n",
          "commitDate": "17/02/16 11:29 AM",
          "commitName": "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "27/08/14 9:47 PM",
          "commitNameOld": "eb448e14399e17f11b9e523e4050de245b9b0408",
          "commitAuthorOld": "arp",
          "daysBetweenCommits": 538.61,
          "commitsBetweenForRepo": 4373,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,15 @@\n-  public synchronized V chooseVolume(List\u003cV\u003e volumes,\n+  public V chooseVolume(List\u003cV\u003e volumes,\n       long replicaSize) throws IOException {\n     if (volumes.size() \u003c 1) {\n       throw new DiskOutOfSpaceException(\"No more available volumes\");\n     }\n-    \n-    AvailableSpaceVolumeList volumesWithSpaces \u003d\n-        new AvailableSpaceVolumeList(volumes);\n-    \n-    if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n-      // If they\u0027re actually not too far out of whack, fall back on pure round\n-      // robin.\n-      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"All volumes are within the configured free space balance \" +\n-            \"threshold. Selecting \" + volume + \" for write of block size \" +\n-            replicaSize);\n-      }\n-      return volume;\n-    } else {\n-      V volume \u003d null;\n-      // If none of the volumes with low free space have enough space for the\n-      // replica, always try to choose a volume with a lot of free space.\n-      long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n-          .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n-      \n-      List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n-          volumesWithSpaces.getVolumesWithHighAvailableSpace());\n-      List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n-          volumesWithSpaces.getVolumesWithLowAvailableSpace());\n-      \n-      float preferencePercentScaler \u003d\n-          (highAvailableVolumes.size() * balancedPreferencePercent) +\n-          (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n-      float scaledPreferencePercent \u003d\n-          (highAvailableVolumes.size() * balancedPreferencePercent) /\n-          preferencePercentScaler;\n-      if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n-          random.nextFloat() \u003c scaledPreferencePercent) {\n-        volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n-            highAvailableVolumes, replicaSize);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n-              \" from high available space volumes for write of block size \"\n-              + replicaSize);\n-        }\n-      } else {\n-        volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n-            lowAvailableVolumes, replicaSize);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n-              \" from low available space volumes for write of block size \"\n-              + replicaSize);\n-        }\n-      }\n-      return volume;\n+    // As all the items in volumes are with the same storage type,\n+    // so only need to get the storage type index of the first item in volumes\n+    StorageType storageType \u003d volumes.get(0).getStorageType();\n+    int index \u003d storageType !\u003d null ?\n+            storageType.ordinal() : StorageType.DEFAULT.ordinal();\n+\n+    synchronized (syncLocks[index]) {\n+      return doChooseVolume(volumes, replicaSize);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public V chooseVolume(List\u003cV\u003e volumes,\n      long replicaSize) throws IOException {\n    if (volumes.size() \u003c 1) {\n      throw new DiskOutOfSpaceException(\"No more available volumes\");\n    }\n    // As all the items in volumes are with the same storage type,\n    // so only need to get the storage type index of the first item in volumes\n    StorageType storageType \u003d volumes.get(0).getStorageType();\n    int index \u003d storageType !\u003d null ?\n            storageType.ordinal() : StorageType.DEFAULT.ordinal();\n\n    synchronized (syncLocks[index]) {\n      return doChooseVolume(volumes, replicaSize);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "a317bd7b02c37bd57743bfad59593ec12f53f4ed": {
      "type": "Yparametermetachange",
      "commitMessage": "HDFS-6925. DataNode should attempt to place replicas on transient storage first if lazyPersist flag is received. (Arpit Agarwal)\n",
      "commitDate": "27/08/14 9:47 PM",
      "commitName": "a317bd7b02c37bd57743bfad59593ec12f53f4ed",
      "commitAuthor": "arp",
      "commitDateOld": "06/06/14 4:40 PM",
      "commitNameOld": "9528ed939df8f2cf0604bac7220fe8cd7394edd8",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 82.21,
      "commitsBetweenForRepo": 643,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public synchronized V chooseVolume(List\u003cV\u003e volumes,\n-      final long replicaSize) throws IOException {\n+      long replicaSize) throws IOException {\n     if (volumes.size() \u003c 1) {\n       throw new DiskOutOfSpaceException(\"No more available volumes\");\n     }\n     \n     AvailableSpaceVolumeList volumesWithSpaces \u003d\n         new AvailableSpaceVolumeList(volumes);\n     \n     if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n       // If they\u0027re actually not too far out of whack, fall back on pure round\n       // robin.\n       V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"All volumes are within the configured free space balance \" +\n             \"threshold. Selecting \" + volume + \" for write of block size \" +\n             replicaSize);\n       }\n       return volume;\n     } else {\n       V volume \u003d null;\n       // If none of the volumes with low free space have enough space for the\n       // replica, always try to choose a volume with a lot of free space.\n       long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n           .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n       \n       List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n           volumesWithSpaces.getVolumesWithHighAvailableSpace());\n       List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n           volumesWithSpaces.getVolumesWithLowAvailableSpace());\n       \n       float preferencePercentScaler \u003d\n           (highAvailableVolumes.size() * balancedPreferencePercent) +\n           (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n       float scaledPreferencePercent \u003d\n           (highAvailableVolumes.size() * balancedPreferencePercent) /\n           preferencePercentScaler;\n       if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n           random.nextFloat() \u003c scaledPreferencePercent) {\n         volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n             highAvailableVolumes,\n             replicaSize);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n               \" from high available space volumes for write of block size \"\n               + replicaSize);\n         }\n       } else {\n         volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n             lowAvailableVolumes,\n             replicaSize);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n               \" from low available space volumes for write of block size \"\n               + replicaSize);\n         }\n       }\n       return volume;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized V chooseVolume(List\u003cV\u003e volumes,\n      long replicaSize) throws IOException {\n    if (volumes.size() \u003c 1) {\n      throw new DiskOutOfSpaceException(\"No more available volumes\");\n    }\n    \n    AvailableSpaceVolumeList volumesWithSpaces \u003d\n        new AvailableSpaceVolumeList(volumes);\n    \n    if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n      // If they\u0027re actually not too far out of whack, fall back on pure round\n      // robin.\n      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"All volumes are within the configured free space balance \" +\n            \"threshold. Selecting \" + volume + \" for write of block size \" +\n            replicaSize);\n      }\n      return volume;\n    } else {\n      V volume \u003d null;\n      // If none of the volumes with low free space have enough space for the\n      // replica, always try to choose a volume with a lot of free space.\n      long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n          .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n      \n      List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithHighAvailableSpace());\n      List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithLowAvailableSpace());\n      \n      float preferencePercentScaler \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) +\n          (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n      float scaledPreferencePercent \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) /\n          preferencePercentScaler;\n      if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n          random.nextFloat() \u003c scaledPreferencePercent) {\n        volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n            highAvailableVolumes,\n            replicaSize);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from high available space volumes for write of block size \"\n              + replicaSize);\n        }\n      } else {\n        volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n            lowAvailableVolumes,\n            replicaSize);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from low available space volumes for write of block size \"\n              + replicaSize);\n        }\n      }\n      return volume;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java",
      "extendedDetails": {
        "oldValue": "[volumes-List\u003cV\u003e, replicaSize-long(modifiers-final)]",
        "newValue": "[volumes-List\u003cV\u003e, replicaSize-long]"
      }
    },
    "9528ed939df8f2cf0604bac7220fe8cd7394edd8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6497. Make TestAvailableSpaceVolumeChoosingPolicy deterministic (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601035 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/14 4:40 PM",
      "commitName": "9528ed939df8f2cf0604bac7220fe8cd7394edd8",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "23/04/14 1:13 PM",
      "commitNameOld": "876fd8ab7913a259ff9f69c16cc2d9af46ad3f9b",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 44.14,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public synchronized V chooseVolume(List\u003cV\u003e volumes,\n       final long replicaSize) throws IOException {\n     if (volumes.size() \u003c 1) {\n       throw new DiskOutOfSpaceException(\"No more available volumes\");\n     }\n     \n     AvailableSpaceVolumeList volumesWithSpaces \u003d\n         new AvailableSpaceVolumeList(volumes);\n     \n     if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n       // If they\u0027re actually not too far out of whack, fall back on pure round\n       // robin.\n       V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"All volumes are within the configured free space balance \" +\n             \"threshold. Selecting \" + volume + \" for write of block size \" +\n             replicaSize);\n       }\n       return volume;\n     } else {\n       V volume \u003d null;\n       // If none of the volumes with low free space have enough space for the\n       // replica, always try to choose a volume with a lot of free space.\n       long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n           .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n       \n       List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n           volumesWithSpaces.getVolumesWithHighAvailableSpace());\n       List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n           volumesWithSpaces.getVolumesWithLowAvailableSpace());\n       \n       float preferencePercentScaler \u003d\n           (highAvailableVolumes.size() * balancedPreferencePercent) +\n           (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n       float scaledPreferencePercent \u003d\n           (highAvailableVolumes.size() * balancedPreferencePercent) /\n           preferencePercentScaler;\n       if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n-          RAND.nextFloat() \u003c scaledPreferencePercent) {\n+          random.nextFloat() \u003c scaledPreferencePercent) {\n         volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n             highAvailableVolumes,\n             replicaSize);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n               \" from high available space volumes for write of block size \"\n               + replicaSize);\n         }\n       } else {\n         volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n             lowAvailableVolumes,\n             replicaSize);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n               \" from low available space volumes for write of block size \"\n               + replicaSize);\n         }\n       }\n       return volume;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized V chooseVolume(List\u003cV\u003e volumes,\n      final long replicaSize) throws IOException {\n    if (volumes.size() \u003c 1) {\n      throw new DiskOutOfSpaceException(\"No more available volumes\");\n    }\n    \n    AvailableSpaceVolumeList volumesWithSpaces \u003d\n        new AvailableSpaceVolumeList(volumes);\n    \n    if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n      // If they\u0027re actually not too far out of whack, fall back on pure round\n      // robin.\n      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"All volumes are within the configured free space balance \" +\n            \"threshold. Selecting \" + volume + \" for write of block size \" +\n            replicaSize);\n      }\n      return volume;\n    } else {\n      V volume \u003d null;\n      // If none of the volumes with low free space have enough space for the\n      // replica, always try to choose a volume with a lot of free space.\n      long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n          .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n      \n      List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithHighAvailableSpace());\n      List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithLowAvailableSpace());\n      \n      float preferencePercentScaler \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) +\n          (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n      float scaledPreferencePercent \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) /\n          preferencePercentScaler;\n      if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n          random.nextFloat() \u003c scaledPreferencePercent) {\n        volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n            highAvailableVolumes,\n            replicaSize);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from high available space volumes for write of block size \"\n              + replicaSize);\n        }\n      } else {\n        volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n            lowAvailableVolumes,\n            replicaSize);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from low available space volumes for write of block size \"\n              + replicaSize);\n        }\n      }\n      return volume;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java",
      "extendedDetails": {}
    },
    "a9d515aed870535ea80500c6dac7612720774cda": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-1804. Add a new block-volume device choosing policy that looks at free space. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1465183 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/04/13 9:08 PM",
      "commitName": "a9d515aed870535ea80500c6dac7612720774cda",
      "commitAuthor": "Aaron Myers",
      "diff": "@@ -0,0 +1,60 @@\n+  public synchronized V chooseVolume(List\u003cV\u003e volumes,\n+      final long replicaSize) throws IOException {\n+    if (volumes.size() \u003c 1) {\n+      throw new DiskOutOfSpaceException(\"No more available volumes\");\n+    }\n+    \n+    AvailableSpaceVolumeList volumesWithSpaces \u003d\n+        new AvailableSpaceVolumeList(volumes);\n+    \n+    if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n+      // If they\u0027re actually not too far out of whack, fall back on pure round\n+      // robin.\n+      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"All volumes are within the configured free space balance \" +\n+            \"threshold. Selecting \" + volume + \" for write of block size \" +\n+            replicaSize);\n+      }\n+      return volume;\n+    } else {\n+      V volume \u003d null;\n+      // If none of the volumes with low free space have enough space for the\n+      // replica, always try to choose a volume with a lot of free space.\n+      long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n+          .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n+      \n+      List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n+          volumesWithSpaces.getVolumesWithHighAvailableSpace());\n+      List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n+          volumesWithSpaces.getVolumesWithLowAvailableSpace());\n+      \n+      float preferencePercentScaler \u003d\n+          (highAvailableVolumes.size() * balancedPreferencePercent) +\n+          (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n+      float scaledPreferencePercent \u003d\n+          (highAvailableVolumes.size() * balancedPreferencePercent) /\n+          preferencePercentScaler;\n+      if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n+          RAND.nextFloat() \u003c scaledPreferencePercent) {\n+        volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n+            highAvailableVolumes,\n+            replicaSize);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n+              \" from high available space volumes for write of block size \"\n+              + replicaSize);\n+        }\n+      } else {\n+        volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n+            lowAvailableVolumes,\n+            replicaSize);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n+              \" from low available space volumes for write of block size \"\n+              + replicaSize);\n+        }\n+      }\n+      return volume;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized V chooseVolume(List\u003cV\u003e volumes,\n      final long replicaSize) throws IOException {\n    if (volumes.size() \u003c 1) {\n      throw new DiskOutOfSpaceException(\"No more available volumes\");\n    }\n    \n    AvailableSpaceVolumeList volumesWithSpaces \u003d\n        new AvailableSpaceVolumeList(volumes);\n    \n    if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n      // If they\u0027re actually not too far out of whack, fall back on pure round\n      // robin.\n      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"All volumes are within the configured free space balance \" +\n            \"threshold. Selecting \" + volume + \" for write of block size \" +\n            replicaSize);\n      }\n      return volume;\n    } else {\n      V volume \u003d null;\n      // If none of the volumes with low free space have enough space for the\n      // replica, always try to choose a volume with a lot of free space.\n      long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n          .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n      \n      List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithHighAvailableSpace());\n      List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithLowAvailableSpace());\n      \n      float preferencePercentScaler \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) +\n          (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n      float scaledPreferencePercent \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) /\n          preferencePercentScaler;\n      if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n          RAND.nextFloat() \u003c scaledPreferencePercent) {\n        volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n            highAvailableVolumes,\n            replicaSize);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from high available space volumes for write of block size \"\n              + replicaSize);\n        }\n      } else {\n        volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n            lowAvailableVolumes,\n            replicaSize);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from low available space volumes for write of block size \"\n              + replicaSize);\n        }\n      }\n      return volume;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java"
    }
  }
}