{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "WebServices.java",
  "functionName": "getApps",
  "functionId": "getApps___req-HttpServletRequest__res-HttpServletResponse__stateQuery-String__statesQuery-Set__String____finalStatusQuery-String__userQuery-String__queueQuery-String__count-String__startedBegin-String__startedEnd-String__finishBegin-String__finishEnd-String__nameQuery-String__applicationTypes-Set__String__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
  "functionStartLine": 75,
  "functionEndLine": 220,
  "numCommitsSeen": 42,
  "timeTaken": 7143,
  "changeHistory": [
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
    "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
    "4002bf0a9e7e3619a3bdcff071f0369cbf2873ad",
    "722ee841948db1f246f0056acec9a1ac464fe1f9",
    "e2a02702178db60150cc0c2253d48b8532a474c2",
    "8d0ef3163287d811381e94cc0101dbc9847ee2db",
    "54504133f41e36eaea6bb06c7b9ddb249468ecd7",
    "95bfd087dc89e57a93340604cc8b96042fa1a05a",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
    "9cedad11d8d2197a54732667a15344983de5c437",
    "946456c6d88780abe0251b098dd771e9e1e93ab3",
    "c05b581a5522eed499d3ba16af9fa6dc694563f6",
    "6b8b1608e64e300e4e1d23c60476febaca29ca38",
    "cbee889711eddc5c67a61df4a6531b4ab3cd205a"
  ],
  "changeHistoryShort": {
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411": "Ymultichange(Yparameterchange,Ybodychange)",
    "652bcbb3e4950758e61ce123ecc1798ae2b60a7f": "Ybodychange",
    "4002bf0a9e7e3619a3bdcff071f0369cbf2873ad": "Ybodychange",
    "722ee841948db1f246f0056acec9a1ac464fe1f9": "Ybodychange",
    "e2a02702178db60150cc0c2253d48b8532a474c2": "Ybodychange",
    "8d0ef3163287d811381e94cc0101dbc9847ee2db": "Ybodychange",
    "54504133f41e36eaea6bb06c7b9ddb249468ecd7": "Ybodychange",
    "95bfd087dc89e57a93340604cc8b96042fa1a05a": "Ybodychange",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": "Ybodychange",
    "9cedad11d8d2197a54732667a15344983de5c437": "Ybodychange",
    "946456c6d88780abe0251b098dd771e9e1e93ab3": "Ybodychange",
    "c05b581a5522eed499d3ba16af9fa6dc694563f6": "Ybodychange",
    "6b8b1608e64e300e4e1d23c60476febaca29ca38": "Ybodychange",
    "cbee889711eddc5c67a61df4a6531b4ab3cd205a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-10035. Add ability to filter the Cluster Applications API request by name. Contributed by Adam Antal\n",
      "commitDate": "06/01/20 7:26 AM",
      "commitName": "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
      "commitAuthor": "Szilard Nemeth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-10035. Add ability to filter the Cluster Applications API request by name. Contributed by Adam Antal\n",
          "commitDate": "06/01/20 7:26 AM",
          "commitName": "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "19/07/18 9:30 AM",
          "commitNameOld": "5836e0a46bf9793e0a61bb8ec46536f4a67d38d7",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 535.96,
          "commitsBetweenForRepo": 3854,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,141 +1,146 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n-      String startedEnd, String finishBegin, String finishEnd,\n+      String startedEnd, String finishBegin, String finishEnd, String nameQuery,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d Long.MAX_VALUE;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     final GetApplicationsRequest request \u003d\n         GetApplicationsRequest.newInstance();\n     request.setLimit(countNum);\n     request.setStartRange(Range.between(sBegin, sEnd));\n     try {\n       if (callerUGI \u003d\u003d null) {\n         // TODO: the request should take the params like what RMWebServices does\n         // in YARN-1819.\n         appReports \u003d getApplicationsReport(request);\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n             return getApplicationsReport(request);\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n     if (appReports \u003d\u003d null) {\n       return allApps;\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkAppStates \u0026\u0026\n           !appStates.contains(StringUtils.toLowerCase(\n               appReport.getYarnApplicationState().toString()))) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (appReport.getQueue() \u003d\u003d null || !appReport.getQueue()\n             .equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes \u0026\u0026\n           !appTypes.contains(\n               StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n         continue;\n       }\n \n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n+\n+      if (nameQuery !\u003d null \u0026\u0026 !nameQuery.equals(appReport.getName())) {\n+        continue;\n+      }\n+\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd, String nameQuery,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d Long.MAX_VALUE;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    final GetApplicationsRequest request \u003d\n        GetApplicationsRequest.newInstance();\n    request.setLimit(countNum);\n    request.setStartRange(Range.between(sBegin, sEnd));\n    try {\n      if (callerUGI \u003d\u003d null) {\n        // TODO: the request should take the params like what RMWebServices does\n        // in YARN-1819.\n        appReports \u003d getApplicationsReport(request);\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return getApplicationsReport(request);\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    if (appReports \u003d\u003d null) {\n      return allApps;\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkAppStates \u0026\u0026\n          !appStates.contains(StringUtils.toLowerCase(\n              appReport.getYarnApplicationState().toString()))) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (appReport.getQueue() \u003d\u003d null || !appReport.getQueue()\n            .equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes \u0026\u0026\n          !appTypes.contains(\n              StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n        continue;\n      }\n\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n\n      if (nameQuery !\u003d null \u0026\u0026 !nameQuery.equals(appReport.getName())) {\n        continue;\n      }\n\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
          "extendedDetails": {
            "oldValue": "[req-HttpServletRequest, res-HttpServletResponse, stateQuery-String, statesQuery-Set\u003cString\u003e, finalStatusQuery-String, userQuery-String, queueQuery-String, count-String, startedBegin-String, startedEnd-String, finishBegin-String, finishEnd-String, applicationTypes-Set\u003cString\u003e]",
            "newValue": "[req-HttpServletRequest, res-HttpServletResponse, stateQuery-String, statesQuery-Set\u003cString\u003e, finalStatusQuery-String, userQuery-String, queueQuery-String, count-String, startedBegin-String, startedEnd-String, finishBegin-String, finishEnd-String, nameQuery-String, applicationTypes-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-10035. Add ability to filter the Cluster Applications API request by name. Contributed by Adam Antal\n",
          "commitDate": "06/01/20 7:26 AM",
          "commitName": "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "19/07/18 9:30 AM",
          "commitNameOld": "5836e0a46bf9793e0a61bb8ec46536f4a67d38d7",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 535.96,
          "commitsBetweenForRepo": 3854,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,141 +1,146 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n-      String startedEnd, String finishBegin, String finishEnd,\n+      String startedEnd, String finishBegin, String finishEnd, String nameQuery,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d Long.MAX_VALUE;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     final GetApplicationsRequest request \u003d\n         GetApplicationsRequest.newInstance();\n     request.setLimit(countNum);\n     request.setStartRange(Range.between(sBegin, sEnd));\n     try {\n       if (callerUGI \u003d\u003d null) {\n         // TODO: the request should take the params like what RMWebServices does\n         // in YARN-1819.\n         appReports \u003d getApplicationsReport(request);\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n             return getApplicationsReport(request);\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n     if (appReports \u003d\u003d null) {\n       return allApps;\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkAppStates \u0026\u0026\n           !appStates.contains(StringUtils.toLowerCase(\n               appReport.getYarnApplicationState().toString()))) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (appReport.getQueue() \u003d\u003d null || !appReport.getQueue()\n             .equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes \u0026\u0026\n           !appTypes.contains(\n               StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n         continue;\n       }\n \n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n+\n+      if (nameQuery !\u003d null \u0026\u0026 !nameQuery.equals(appReport.getName())) {\n+        continue;\n+      }\n+\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd, String nameQuery,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d Long.MAX_VALUE;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    final GetApplicationsRequest request \u003d\n        GetApplicationsRequest.newInstance();\n    request.setLimit(countNum);\n    request.setStartRange(Range.between(sBegin, sEnd));\n    try {\n      if (callerUGI \u003d\u003d null) {\n        // TODO: the request should take the params like what RMWebServices does\n        // in YARN-1819.\n        appReports \u003d getApplicationsReport(request);\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return getApplicationsReport(request);\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    if (appReports \u003d\u003d null) {\n      return allApps;\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkAppStates \u0026\u0026\n          !appStates.contains(StringUtils.toLowerCase(\n              appReport.getYarnApplicationState().toString()))) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (appReport.getQueue() \u003d\u003d null || !appReport.getQueue()\n            .equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes \u0026\u0026\n          !appTypes.contains(\n              StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n        continue;\n      }\n\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n\n      if (nameQuery !\u003d null \u0026\u0026 !nameQuery.equals(appReport.getName())) {\n        continue;\n      }\n\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "652bcbb3e4950758e61ce123ecc1798ae2b60a7f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8363. Upgrade commons-lang version to 3.7 in hadoop-yarn-project. Contributed by Takanobu Asanuma.\n",
      "commitDate": "12/06/18 8:35 AM",
      "commitName": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "10/05/18 7:05 PM",
      "commitNameOld": "d76fbbc9b82e720d7d5188f9ae2f56a8d78f3a98",
      "commitAuthorOld": "Vinod Kumar Vavilapalli (I am also known as @tshooter.)",
      "daysBetweenCommits": 32.56,
      "commitsBetweenForRepo": 267,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,141 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d Long.MAX_VALUE;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     final GetApplicationsRequest request \u003d\n         GetApplicationsRequest.newInstance();\n     request.setLimit(countNum);\n-    request.setStartRange(new LongRange(sBegin, sEnd));\n+    request.setStartRange(Range.between(sBegin, sEnd));\n     try {\n       if (callerUGI \u003d\u003d null) {\n         // TODO: the request should take the params like what RMWebServices does\n         // in YARN-1819.\n         appReports \u003d getApplicationsReport(request);\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n             return getApplicationsReport(request);\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n     if (appReports \u003d\u003d null) {\n       return allApps;\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkAppStates \u0026\u0026\n           !appStates.contains(StringUtils.toLowerCase(\n               appReport.getYarnApplicationState().toString()))) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (appReport.getQueue() \u003d\u003d null || !appReport.getQueue()\n             .equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes \u0026\u0026\n           !appTypes.contains(\n               StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n         continue;\n       }\n \n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d Long.MAX_VALUE;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    final GetApplicationsRequest request \u003d\n        GetApplicationsRequest.newInstance();\n    request.setLimit(countNum);\n    request.setStartRange(Range.between(sBegin, sEnd));\n    try {\n      if (callerUGI \u003d\u003d null) {\n        // TODO: the request should take the params like what RMWebServices does\n        // in YARN-1819.\n        appReports \u003d getApplicationsReport(request);\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return getApplicationsReport(request);\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    if (appReports \u003d\u003d null) {\n      return allApps;\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkAppStates \u0026\u0026\n          !appStates.contains(StringUtils.toLowerCase(\n              appReport.getYarnApplicationState().toString()))) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (appReport.getQueue() \u003d\u003d null || !appReport.getQueue()\n            .equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes \u0026\u0026\n          !appTypes.contains(\n              StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n        continue;\n      }\n\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "4002bf0a9e7e3619a3bdcff071f0369cbf2873ad": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7118. AHS REST API can return NullPointerException. Contributed by Billie Rinaldi.\n",
      "commitDate": "22/09/17 1:58 PM",
      "commitName": "4002bf0a9e7e3619a3bdcff071f0369cbf2873ad",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/09/17 9:58 PM",
      "commitNameOld": "722ee841948db1f246f0056acec9a1ac464fe1f9",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 11.67,
      "commitsBetweenForRepo": 152,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,141 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d Long.MAX_VALUE;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     final GetApplicationsRequest request \u003d\n         GetApplicationsRequest.newInstance();\n     request.setLimit(countNum);\n     request.setStartRange(new LongRange(sBegin, sEnd));\n     try {\n       if (callerUGI \u003d\u003d null) {\n         // TODO: the request should take the params like what RMWebServices does\n         // in YARN-1819.\n         appReports \u003d getApplicationsReport(request);\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n             return getApplicationsReport(request);\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n     if (appReports \u003d\u003d null) {\n       return allApps;\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkAppStates \u0026\u0026\n           !appStates.contains(StringUtils.toLowerCase(\n               appReport.getYarnApplicationState().toString()))) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n-        if (!appReport.getQueue().equals(queueQuery)) {\n+        if (appReport.getQueue() \u003d\u003d null || !appReport.getQueue()\n+            .equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes \u0026\u0026\n           !appTypes.contains(\n               StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n         continue;\n       }\n \n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d Long.MAX_VALUE;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    final GetApplicationsRequest request \u003d\n        GetApplicationsRequest.newInstance();\n    request.setLimit(countNum);\n    request.setStartRange(new LongRange(sBegin, sEnd));\n    try {\n      if (callerUGI \u003d\u003d null) {\n        // TODO: the request should take the params like what RMWebServices does\n        // in YARN-1819.\n        appReports \u003d getApplicationsReport(request);\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return getApplicationsReport(request);\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    if (appReports \u003d\u003d null) {\n      return allApps;\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkAppStates \u0026\u0026\n          !appStates.contains(StringUtils.toLowerCase(\n              appReport.getYarnApplicationState().toString()))) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (appReport.getQueue() \u003d\u003d null || !appReport.getQueue()\n            .equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes \u0026\u0026\n          !appTypes.contains(\n              StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n        continue;\n      }\n\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "722ee841948db1f246f0056acec9a1ac464fe1f9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7163. RMContext need not to be injected to webapp and other Always Running services. Contributed by Rohith Sharma K S.\n",
      "commitDate": "10/09/17 9:58 PM",
      "commitName": "722ee841948db1f246f0056acec9a1ac464fe1f9",
      "commitAuthor": "Sunil G",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 453.29,
      "commitsBetweenForRepo": 2971,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,140 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d Long.MAX_VALUE;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     final GetApplicationsRequest request \u003d\n         GetApplicationsRequest.newInstance();\n     request.setLimit(countNum);\n     request.setStartRange(new LongRange(sBegin, sEnd));\n     try {\n       if (callerUGI \u003d\u003d null) {\n         // TODO: the request should take the params like what RMWebServices does\n         // in YARN-1819.\n-        appReports \u003d appBaseProt.getApplications(request).getApplicationList();\n+        appReports \u003d getApplicationsReport(request);\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n-            return appBaseProt.getApplications(request).getApplicationList();\n+            return getApplicationsReport(request);\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n     if (appReports \u003d\u003d null) {\n       return allApps;\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkAppStates \u0026\u0026\n           !appStates.contains(StringUtils.toLowerCase(\n               appReport.getYarnApplicationState().toString()))) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (!appReport.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes \u0026\u0026\n           !appTypes.contains(\n               StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n         continue;\n       }\n \n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d Long.MAX_VALUE;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    final GetApplicationsRequest request \u003d\n        GetApplicationsRequest.newInstance();\n    request.setLimit(countNum);\n    request.setStartRange(new LongRange(sBegin, sEnd));\n    try {\n      if (callerUGI \u003d\u003d null) {\n        // TODO: the request should take the params like what RMWebServices does\n        // in YARN-1819.\n        appReports \u003d getApplicationsReport(request);\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return getApplicationsReport(request);\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    if (appReports \u003d\u003d null) {\n      return allApps;\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkAppStates \u0026\u0026\n          !appStates.contains(StringUtils.toLowerCase(\n              appReport.getYarnApplicationState().toString()))) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (!appReport.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes \u0026\u0026\n          !appTypes.contains(\n              StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n        continue;\n      }\n\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "e2a02702178db60150cc0c2253d48b8532a474c2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4151. Fix findbugs errors in hadoop-yarn-server-common module. (Meng Ding via wangda)\n",
      "commitDate": "14/09/15 4:00 PM",
      "commitName": "e2a02702178db60150cc0c2253d48b8532a474c2",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/06/15 11:14 PM",
      "commitNameOld": "8d0ef3163287d811381e94cc0101dbc9847ee2db",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 97.7,
      "commitsBetweenForRepo": 563,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,140 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d Long.MAX_VALUE;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     final GetApplicationsRequest request \u003d\n         GetApplicationsRequest.newInstance();\n     request.setLimit(countNum);\n     request.setStartRange(new LongRange(sBegin, sEnd));\n     try {\n       if (callerUGI \u003d\u003d null) {\n         // TODO: the request should take the params like what RMWebServices does\n         // in YARN-1819.\n         appReports \u003d appBaseProt.getApplications(request).getApplicationList();\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n             return appBaseProt.getApplications(request).getApplicationList();\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n+    if (appReports \u003d\u003d null) {\n+      return allApps;\n+    }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkAppStates \u0026\u0026\n           !appStates.contains(StringUtils.toLowerCase(\n               appReport.getYarnApplicationState().toString()))) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (!appReport.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes \u0026\u0026\n           !appTypes.contains(\n               StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n         continue;\n       }\n \n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d Long.MAX_VALUE;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    final GetApplicationsRequest request \u003d\n        GetApplicationsRequest.newInstance();\n    request.setLimit(countNum);\n    request.setStartRange(new LongRange(sBegin, sEnd));\n    try {\n      if (callerUGI \u003d\u003d null) {\n        // TODO: the request should take the params like what RMWebServices does\n        // in YARN-1819.\n        appReports \u003d appBaseProt.getApplications(request).getApplicationList();\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return appBaseProt.getApplications(request).getApplicationList();\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    if (appReports \u003d\u003d null) {\n      return allApps;\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkAppStates \u0026\u0026\n          !appStates.contains(StringUtils.toLowerCase(\n              appReport.getYarnApplicationState().toString()))) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (!appReport.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes \u0026\u0026\n          !appTypes.contains(\n              StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n        continue;\n      }\n\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "8d0ef3163287d811381e94cc0101dbc9847ee2db": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3787. Allowed generic history service to load a number of applications whose started time is within the given range. Contributed by Xuan Gong.\n",
      "commitDate": "08/06/15 11:14 PM",
      "commitName": "8d0ef3163287d811381e94cc0101dbc9847ee2db",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "31/05/15 3:37 PM",
      "commitNameOld": "9686261ecb872ad159fac3ca44f1792143c6d7db",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 8.32,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,137 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n-    boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d Long.MAX_VALUE;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n-      checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n-      checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     final GetApplicationsRequest request \u003d\n         GetApplicationsRequest.newInstance();\n     request.setLimit(countNum);\n+    request.setStartRange(new LongRange(sBegin, sEnd));\n     try {\n       if (callerUGI \u003d\u003d null) {\n         // TODO: the request should take the params like what RMWebServices does\n         // in YARN-1819.\n         appReports \u003d appBaseProt.getApplications(request).getApplicationList();\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n             return appBaseProt.getApplications(request).getApplicationList();\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkAppStates \u0026\u0026\n           !appStates.contains(StringUtils.toLowerCase(\n               appReport.getYarnApplicationState().toString()))) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (!appReport.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes \u0026\u0026\n           !appTypes.contains(\n               StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n         continue;\n       }\n \n-      if (checkStart\n-          \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n-        continue;\n-      }\n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d Long.MAX_VALUE;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    final GetApplicationsRequest request \u003d\n        GetApplicationsRequest.newInstance();\n    request.setLimit(countNum);\n    request.setStartRange(new LongRange(sBegin, sEnd));\n    try {\n      if (callerUGI \u003d\u003d null) {\n        // TODO: the request should take the params like what RMWebServices does\n        // in YARN-1819.\n        appReports \u003d appBaseProt.getApplications(request).getApplicationList();\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return appBaseProt.getApplications(request).getApplicationList();\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkAppStates \u0026\u0026\n          !appStates.contains(StringUtils.toLowerCase(\n              appReport.getYarnApplicationState().toString()))) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (!appReport.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes \u0026\u0026\n          !appTypes.contains(\n              StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n        continue;\n      }\n\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "54504133f41e36eaea6bb06c7b9ddb249468ecd7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3700. Made generic history service load a number of latest applications according to the parameter or the configuration. Contributed by Xuan Gong.\n",
      "commitDate": "27/05/15 4:52 PM",
      "commitName": "54504133f41e36eaea6bb06c7b9ddb249468ecd7",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "05/03/15 9:20 PM",
      "commitNameOld": "95bfd087dc89e57a93340604cc8b96042fa1a05a",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 82.77,
      "commitsBetweenForRepo": 781,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,143 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n-    long num \u003d 0;\n-    boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n-    long countNum \u003d 0;\n+    long countNum \u003d Long.MAX_VALUE;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n-      checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n+    final GetApplicationsRequest request \u003d\n+        GetApplicationsRequest.newInstance();\n+    request.setLimit(countNum);\n     try {\n       if (callerUGI \u003d\u003d null) {\n         // TODO: the request should take the params like what RMWebServices does\n         // in YARN-1819.\n-        GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n         appReports \u003d appBaseProt.getApplications(request).getApplicationList();\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n-            return appBaseProt.getApplications(\n-                GetApplicationsRequest.newInstance()).getApplicationList();\n+            return appBaseProt.getApplications(request).getApplicationList();\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n     for (ApplicationReport appReport : appReports) {\n \n-      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n-        break;\n-      }\n-\n       if (checkAppStates \u0026\u0026\n           !appStates.contains(StringUtils.toLowerCase(\n               appReport.getYarnApplicationState().toString()))) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (!appReport.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes \u0026\u0026\n           !appTypes.contains(\n               StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n         continue;\n       }\n \n       if (checkStart\n           \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n-      num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d Long.MAX_VALUE;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    final GetApplicationsRequest request \u003d\n        GetApplicationsRequest.newInstance();\n    request.setLimit(countNum);\n    try {\n      if (callerUGI \u003d\u003d null) {\n        // TODO: the request should take the params like what RMWebServices does\n        // in YARN-1819.\n        appReports \u003d appBaseProt.getApplications(request).getApplicationList();\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return appBaseProt.getApplications(request).getApplicationList();\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkAppStates \u0026\u0026\n          !appStates.contains(StringUtils.toLowerCase(\n              appReport.getYarnApplicationState().toString()))) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (!appReport.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes \u0026\u0026\n          !appTypes.contains(\n              StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "95bfd087dc89e57a93340604cc8b96042fa1a05a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1809. Synchronize RM and TimeLineServer Web-UIs. Contributed by Zhijie Shen and Xuan Gong\n",
      "commitDate": "05/03/15 9:20 PM",
      "commitName": "95bfd087dc89e57a93340604cc8b96042fa1a05a",
      "commitAuthor": "Jian He",
      "commitDateOld": "02/03/15 9:17 PM",
      "commitNameOld": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,150 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       if (callerUGI \u003d\u003d null) {\n-        appReports \u003d appContext.getAllApplications().values();\n+        // TODO: the request should take the params like what RMWebServices does\n+        // in YARN-1819.\n+        GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n+        appReports \u003d appBaseProt.getApplications(request).getApplicationList();\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n-            return appContext.getAllApplications().values();\n+            return appBaseProt.getApplications(\n+                GetApplicationsRequest.newInstance()).getApplicationList();\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n \n       if (checkAppStates \u0026\u0026\n           !appStates.contains(StringUtils.toLowerCase(\n               appReport.getYarnApplicationState().toString()))) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (!appReport.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes \u0026\u0026\n           !appTypes.contains(\n               StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n         continue;\n       }\n \n       if (checkStart\n           \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      if (callerUGI \u003d\u003d null) {\n        // TODO: the request should take the params like what RMWebServices does\n        // in YARN-1819.\n        GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n        appReports \u003d appBaseProt.getApplications(request).getApplicationList();\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return appBaseProt.getApplications(\n                GetApplicationsRequest.newInstance()).getApplicationList();\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n\n      if (checkAppStates \u0026\u0026\n          !appStates.contains(StringUtils.toLowerCase(\n              appReport.getYarnApplicationState().toString()))) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (!appReport.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes \u0026\u0026\n          !appTypes.contains(\n              StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "02/03/15 9:17 PM",
      "commitName": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "24/02/15 7:32 AM",
      "commitNameOld": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,146 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       if (callerUGI \u003d\u003d null) {\n         appReports \u003d appContext.getAllApplications().values();\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n             return appContext.getAllApplications().values();\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n \n-      if (checkAppStates\n-          \u0026\u0026 !appStates.contains(appReport.getYarnApplicationState().toString()\n-            .toLowerCase())) {\n+      if (checkAppStates \u0026\u0026\n+          !appStates.contains(StringUtils.toLowerCase(\n+              appReport.getYarnApplicationState().toString()))) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (!appReport.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n-      if (checkAppTypes\n-          \u0026\u0026 !appTypes.contains(appReport.getApplicationType().trim()\n-            .toLowerCase())) {\n+      if (checkAppTypes \u0026\u0026\n+          !appTypes.contains(\n+              StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n         continue;\n       }\n \n       if (checkStart\n           \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      if (callerUGI \u003d\u003d null) {\n        appReports \u003d appContext.getAllApplications().values();\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return appContext.getAllApplications().values();\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n\n      if (checkAppStates \u0026\u0026\n          !appStates.contains(StringUtils.toLowerCase(\n              appReport.getYarnApplicationState().toString()))) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (!appReport.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes \u0026\u0026\n          !appTypes.contains(\n              StringUtils.toLowerCase(appReport.getApplicationType().trim()))) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "9cedad11d8d2197a54732667a15344983de5c437": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\"\n\nThis reverts commit 946456c6d88780abe0251b098dd771e9e1e93ab3.\n\nConflicts:\n\thadoop-common-project/hadoop-common/CHANGES.txt\n\thadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/QuotaByStorageTypeEntry.java\n",
      "commitDate": "24/02/15 7:32 AM",
      "commitName": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "18/02/15 8:06 PM",
      "commitNameOld": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 5.48,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,146 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       if (callerUGI \u003d\u003d null) {\n         appReports \u003d appContext.getAllApplications().values();\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n             return appContext.getAllApplications().values();\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n \n       if (checkAppStates\n           \u0026\u0026 !appStates.contains(appReport.getYarnApplicationState().toString()\n-            .toLowerCase(Locale.ENGLISH))) {\n+            .toLowerCase())) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (!appReport.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes\n           \u0026\u0026 !appTypes.contains(appReport.getApplicationType().trim()\n-            .toLowerCase(Locale.ENGLISH))) {\n+            .toLowerCase())) {\n         continue;\n       }\n \n       if (checkStart\n           \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      if (callerUGI \u003d\u003d null) {\n        appReports \u003d appContext.getAllApplications().values();\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return appContext.getAllApplications().values();\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n\n      if (checkAppStates\n          \u0026\u0026 !appStates.contains(appReport.getYarnApplicationState().toString()\n            .toLowerCase())) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (!appReport.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes\n          \u0026\u0026 !appTypes.contains(appReport.getApplicationType().trim()\n            .toLowerCase())) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "946456c6d88780abe0251b098dd771e9e1e93ab3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "18/02/15 8:06 PM",
      "commitName": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "27/10/14 10:45 AM",
      "commitNameOld": "c05b581a5522eed499d3ba16af9fa6dc694563f6",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 114.43,
      "commitsBetweenForRepo": 908,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,146 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       if (callerUGI \u003d\u003d null) {\n         appReports \u003d appContext.getAllApplications().values();\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n             return appContext.getAllApplications().values();\n           }\n         });\n       }\n     } catch (Exception e) {\n       rewrapAndThrowException(e);\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n \n       if (checkAppStates\n           \u0026\u0026 !appStates.contains(appReport.getYarnApplicationState().toString()\n-            .toLowerCase())) {\n+            .toLowerCase(Locale.ENGLISH))) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (!appReport.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes\n           \u0026\u0026 !appTypes.contains(appReport.getApplicationType().trim()\n-            .toLowerCase())) {\n+            .toLowerCase(Locale.ENGLISH))) {\n         continue;\n       }\n \n       if (checkStart\n           \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      if (callerUGI \u003d\u003d null) {\n        appReports \u003d appContext.getAllApplications().values();\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return appContext.getAllApplications().values();\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n\n      if (checkAppStates\n          \u0026\u0026 !appStates.contains(appReport.getYarnApplicationState().toString()\n            .toLowerCase(Locale.ENGLISH))) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (!appReport.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes\n          \u0026\u0026 !appTypes.contains(appReport.getApplicationType().trim()\n            .toLowerCase(Locale.ENGLISH))) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "c05b581a5522eed499d3ba16af9fa6dc694563f6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2591. Fixed AHSWebServices to return FORBIDDEN(403) if the request user doesn\u0027t have access to the history data. Contributed by Zhijie Shen\n",
      "commitDate": "27/10/14 10:45 AM",
      "commitName": "c05b581a5522eed499d3ba16af9fa6dc694563f6",
      "commitAuthor": "Jian He",
      "commitDateOld": "11/09/14 7:04 PM",
      "commitNameOld": "6b8b1608e64e300e4e1d23c60476febaca29ca38",
      "commitAuthorOld": "junping_du",
      "daysBetweenCommits": 45.65,
      "commitsBetweenForRepo": 445,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,146 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n     UserGroupInformation callerUGI \u003d getUser(req);\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       if (callerUGI \u003d\u003d null) {\n         appReports \u003d appContext.getAllApplications().values();\n       } else {\n         appReports \u003d callerUGI.doAs(\n             new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n           @Override\n           public Collection\u003cApplicationReport\u003e run() throws Exception {\n             return appContext.getAllApplications().values();\n           }\n         });\n       }\n     } catch (Exception e) {\n-      throw new WebApplicationException(e);\n+      rewrapAndThrowException(e);\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n \n       if (checkAppStates\n           \u0026\u0026 !appStates.contains(appReport.getYarnApplicationState().toString()\n             .toLowerCase())) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (!appReport.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes\n           \u0026\u0026 !appTypes.contains(appReport.getApplicationType().trim()\n             .toLowerCase())) {\n         continue;\n       }\n \n       if (checkStart\n           \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      if (callerUGI \u003d\u003d null) {\n        appReports \u003d appContext.getAllApplications().values();\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return appContext.getAllApplications().values();\n          }\n        });\n      }\n    } catch (Exception e) {\n      rewrapAndThrowException(e);\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n\n      if (checkAppStates\n          \u0026\u0026 !appStates.contains(appReport.getYarnApplicationState().toString()\n            .toLowerCase())) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (!appReport.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes\n          \u0026\u0026 !appTypes.contains(appReport.getApplicationType().trim()\n            .toLowerCase())) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "6b8b1608e64e300e4e1d23c60476febaca29ca38": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2033. Merging generic-history into the Timeline Store (Contributed by Zhijie Shen)\n",
      "commitDate": "11/09/14 7:04 PM",
      "commitName": "6b8b1608e64e300e4e1d23c60476febaca29ca38",
      "commitAuthor": "junping_du",
      "commitDateOld": "25/01/14 8:51 PM",
      "commitNameOld": "cbee889711eddc5c67a61df4a6531b4ab3cd205a",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 228.88,
      "commitsBetweenForRepo": 1735,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,146 @@\n   public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n       String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n       String userQuery, String queueQuery, String count, String startedBegin,\n       String startedEnd, String finishBegin, String finishEnd,\n       Set\u003cString\u003e applicationTypes) {\n+    UserGroupInformation callerUGI \u003d getUser(req);\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n         \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n         \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     AppsInfo allApps \u003d new AppsInfo();\n     Collection\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n-      appReports \u003d appContext.getAllApplications().values();\n-    } catch (IOException e) {\n+      if (callerUGI \u003d\u003d null) {\n+        appReports \u003d appContext.getAllApplications().values();\n+      } else {\n+        appReports \u003d callerUGI.doAs(\n+            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n+          @Override\n+          public Collection\u003cApplicationReport\u003e run() throws Exception {\n+            return appContext.getAllApplications().values();\n+          }\n+        });\n+      }\n+    } catch (Exception e) {\n       throw new WebApplicationException(e);\n     }\n     for (ApplicationReport appReport : appReports) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n \n       if (checkAppStates\n           \u0026\u0026 !appStates.contains(appReport.getYarnApplicationState().toString()\n             .toLowerCase())) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!appReport.getFinalApplicationStatus().toString()\n           .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!appReport.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         if (!appReport.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes\n           \u0026\u0026 !appTypes.contains(appReport.getApplicationType().trim()\n             .toLowerCase())) {\n         continue;\n       }\n \n       if (checkStart\n           \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(appReport);\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    UserGroupInformation callerUGI \u003d getUser(req);\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      if (callerUGI \u003d\u003d null) {\n        appReports \u003d appContext.getAllApplications().values();\n      } else {\n        appReports \u003d callerUGI.doAs(\n            new PrivilegedExceptionAction\u003cCollection\u003cApplicationReport\u003e\u003e () {\n          @Override\n          public Collection\u003cApplicationReport\u003e run() throws Exception {\n            return appContext.getAllApplications().values();\n          }\n        });\n      }\n    } catch (Exception e) {\n      throw new WebApplicationException(e);\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n\n      if (checkAppStates\n          \u0026\u0026 !appStates.contains(appReport.getYarnApplicationState().toString()\n            .toLowerCase())) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (!appReport.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes\n          \u0026\u0026 !appTypes.contains(appReport.getApplicationType().trim()\n            .toLowerCase())) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java",
      "extendedDetails": {}
    },
    "cbee889711eddc5c67a61df4a6531b4ab3cd205a": {
      "type": "Yintroduced",
      "commitMessage": "YARN-321. Merging YARN-321 branch to trunk.\nsvn merge ../branches/YARN-321\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561452 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/14 8:51 PM",
      "commitName": "cbee889711eddc5c67a61df4a6531b4ab3cd205a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,135 @@\n+  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n+      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n+      String userQuery, String queueQuery, String count, String startedBegin,\n+      String startedEnd, String finishBegin, String finishEnd,\n+      Set\u003cString\u003e applicationTypes) {\n+    long num \u003d 0;\n+    boolean checkCount \u003d false;\n+    boolean checkStart \u003d false;\n+    boolean checkEnd \u003d false;\n+    boolean checkAppTypes \u003d false;\n+    boolean checkAppStates \u003d false;\n+    long countNum \u003d 0;\n+\n+    // set values suitable in case both of begin/end not specified\n+    long sBegin \u003d 0;\n+    long sEnd \u003d Long.MAX_VALUE;\n+    long fBegin \u003d 0;\n+    long fEnd \u003d Long.MAX_VALUE;\n+\n+    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n+      checkCount \u003d true;\n+      countNum \u003d Long.parseLong(count);\n+      if (countNum \u003c\u003d 0) {\n+        throw new BadRequestException(\"limit value must be greater then 0\");\n+      }\n+    }\n+\n+    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n+      checkStart \u003d true;\n+      sBegin \u003d Long.parseLong(startedBegin);\n+      if (sBegin \u003c 0) {\n+        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n+      }\n+    }\n+    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n+      checkStart \u003d true;\n+      sEnd \u003d Long.parseLong(startedEnd);\n+      if (sEnd \u003c 0) {\n+        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n+      }\n+    }\n+    if (sBegin \u003e sEnd) {\n+      throw new BadRequestException(\n+        \"startedTimeEnd must be greater than startTimeBegin\");\n+    }\n+\n+    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n+      checkEnd \u003d true;\n+      fBegin \u003d Long.parseLong(finishBegin);\n+      if (fBegin \u003c 0) {\n+        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n+      }\n+    }\n+    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n+      checkEnd \u003d true;\n+      fEnd \u003d Long.parseLong(finishEnd);\n+      if (fEnd \u003c 0) {\n+        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n+      }\n+    }\n+    if (fBegin \u003e fEnd) {\n+      throw new BadRequestException(\n+        \"finishTimeEnd must be greater than finishTimeBegin\");\n+    }\n+\n+    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n+    if (!appTypes.isEmpty()) {\n+      checkAppTypes \u003d true;\n+    }\n+\n+    // stateQuery is deprecated.\n+    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n+      statesQuery.add(stateQuery);\n+    }\n+    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n+    if (!appStates.isEmpty()) {\n+      checkAppStates \u003d true;\n+    }\n+\n+    AppsInfo allApps \u003d new AppsInfo();\n+    Collection\u003cApplicationReport\u003e appReports \u003d null;\n+    try {\n+      appReports \u003d appContext.getAllApplications().values();\n+    } catch (IOException e) {\n+      throw new WebApplicationException(e);\n+    }\n+    for (ApplicationReport appReport : appReports) {\n+\n+      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n+        break;\n+      }\n+\n+      if (checkAppStates\n+          \u0026\u0026 !appStates.contains(appReport.getYarnApplicationState().toString()\n+            .toLowerCase())) {\n+        continue;\n+      }\n+      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n+        FinalApplicationStatus.valueOf(finalStatusQuery);\n+        if (!appReport.getFinalApplicationStatus().toString()\n+          .equalsIgnoreCase(finalStatusQuery)) {\n+          continue;\n+        }\n+      }\n+      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n+        if (!appReport.getUser().equals(userQuery)) {\n+          continue;\n+        }\n+      }\n+      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n+        if (!appReport.getQueue().equals(queueQuery)) {\n+          continue;\n+        }\n+      }\n+      if (checkAppTypes\n+          \u0026\u0026 !appTypes.contains(appReport.getApplicationType().trim()\n+            .toLowerCase())) {\n+        continue;\n+      }\n+\n+      if (checkStart\n+          \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n+        continue;\n+      }\n+      if (checkEnd\n+          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n+        continue;\n+      }\n+      AppInfo app \u003d new AppInfo(appReport);\n+\n+      allApps.add(app);\n+      num++;\n+    }\n+    return allApps;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest req, HttpServletResponse res,\n      String stateQuery, Set\u003cString\u003e statesQuery, String finalStatusQuery,\n      String userQuery, String queueQuery, String count, String startedBegin,\n      String startedEnd, String finishBegin, String finishEnd,\n      Set\u003cString\u003e applicationTypes) {\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n        \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n        \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    AppsInfo allApps \u003d new AppsInfo();\n    Collection\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d appContext.getAllApplications().values();\n    } catch (IOException e) {\n      throw new WebApplicationException(e);\n    }\n    for (ApplicationReport appReport : appReports) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n\n      if (checkAppStates\n          \u0026\u0026 !appStates.contains(appReport.getYarnApplicationState().toString()\n            .toLowerCase())) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!appReport.getFinalApplicationStatus().toString()\n          .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!appReport.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        if (!appReport.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes\n          \u0026\u0026 !appTypes.contains(appReport.getApplicationType().trim()\n            .toLowerCase())) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (appReport.getStartTime() \u003c sBegin || appReport.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (appReport.getFinishTime() \u003c fBegin || appReport.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(appReport);\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/webapp/WebServices.java"
    }
  }
}