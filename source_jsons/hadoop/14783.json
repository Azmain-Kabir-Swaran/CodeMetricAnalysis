{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DelegationTokenFetcher.java",
  "functionName": "main",
  "functionId": "main___conf-Configuration__args-String[](modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
  "functionStartLine": 86,
  "functionEndLine": 152,
  "numCommitsSeen": 65,
  "timeTaken": 8051,
  "changeHistory": [
    "2addebb94f592e46b261e2edd9e95a82e83bd761",
    "e24fe2641b4117601105fa097c8848d82b96b74c",
    "fb1d7fb596b8e8bb9a5f141c89acb1949bade87a",
    "8c505adddbaec558c25f3dd26f92eb6107150281",
    "d8a23834614581a292aad214dddcbcc4bbe86d27",
    "43fa41fdeee53471e9aa34c89f58e53e8aa164e5",
    "8fa10b184e607a33f59e67bd4b1fbe5a2e683941",
    "28e87740c5797e87a9038d7f151c8b21a5b04592",
    "231a52a7dfa73f7f302cc3bf671d433312373873",
    "f026d8bb1ba6f9b059db5526f1fb1261f818ffd0",
    "5dbbe0e0a5d31689d3425e490865f95057dc051c",
    "ea868d3d8b6c5e018eb104a560890c60d30fa269",
    "002dd6968b89ded6a77858ccb50c9b2df074c226",
    "201b7879ba6994400c1aa955f242665c16c2c0ea",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "2addebb94f592e46b261e2edd9e95a82e83bd761": "Ymultichange(Yparameterchange,Ybodychange)",
    "e24fe2641b4117601105fa097c8848d82b96b74c": "Ybodychange",
    "fb1d7fb596b8e8bb9a5f141c89acb1949bade87a": "Ybodychange",
    "8c505adddbaec558c25f3dd26f92eb6107150281": "Ybodychange",
    "d8a23834614581a292aad214dddcbcc4bbe86d27": "Ybodychange",
    "43fa41fdeee53471e9aa34c89f58e53e8aa164e5": "Ybodychange",
    "8fa10b184e607a33f59e67bd4b1fbe5a2e683941": "Ybodychange",
    "28e87740c5797e87a9038d7f151c8b21a5b04592": "Ybodychange",
    "231a52a7dfa73f7f302cc3bf671d433312373873": "Ybodychange",
    "f026d8bb1ba6f9b059db5526f1fb1261f818ffd0": "Ybodychange",
    "5dbbe0e0a5d31689d3425e490865f95057dc051c": "Ybodychange",
    "ea868d3d8b6c5e018eb104a560890c60d30fa269": "Ybodychange",
    "002dd6968b89ded6a77858ccb50c9b2df074c226": "Ybodychange",
    "201b7879ba6994400c1aa955f242665c16c2c0ea": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2addebb94f592e46b261e2edd9e95a82e83bd761": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-13951. HDFS DelegationTokenFetcher can\u0027t print non-HDFS tokens in a tokenfile.\nContributed by Steve Loughran.\n",
      "commitDate": "11/10/18 12:03 PM",
      "commitName": "2addebb94f592e46b261e2edd9e95a82e83bd761",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13951. HDFS DelegationTokenFetcher can\u0027t print non-HDFS tokens in a tokenfile.\nContributed by Steve Loughran.\n",
          "commitDate": "11/10/18 12:03 PM",
          "commitName": "2addebb94f592e46b261e2edd9e95a82e83bd761",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "06/09/18 2:48 PM",
          "commitNameOld": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 34.89,
          "commitsBetweenForRepo": 367,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,67 @@\n-  public static void main(final String[] args) throws Exception {\n-    final Configuration conf \u003d new HdfsConfiguration();\n+  public static void main(Configuration conf, final String[] args)\n+      throws Exception {\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions\n       .addOption(WEBSERVICE, true, \"HTTP url to reach the NameNode at\")\n       .addOption(RENEWER, true, \"Name of the delegation token renewer\")\n       .addOption(CANCEL, false, \"cancel the token\")\n       .addOption(RENEW, false, \"renew the token\")\n       .addOption(PRINT, false, \"print the token\")\n       .addOption(VERBOSE, false, \"print verbose output\")\n       .addOption(HELP_SHORT, HELP, false, \"print out help information\");\n \n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n             fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n \n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n             .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? cmd.getOptionValue\n             (RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n     final boolean verbose \u003d cmd.hasOption(VERBOSE);\n     final boolean help \u003d cmd.hasOption(HELP);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (help) {\n       printUsage(System.out);\n-      System.exit(0);\n+      return;\n     }\n \n     int commandCount \u003d (cancel ? 1 : 0) + (renew ? 1 : 0) + (print ? 1 : 0);\n     if (commandCount \u003e 1) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n+      return;\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n+      return;\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n       @Override\n       public Object run() throws Exception {\n         if (print) {\n           printTokens(conf, tokenFile, verbose);\n         } else if (cancel) {\n           cancelTokens(conf, tokenFile);\n         } else if (renew) {\n           renewTokens(conf, tokenFile);\n         } else {\n           // otherwise we are fetching\n           FileSystem fs \u003d getFileSystem(conf, webUrl);\n           saveDelegationToken(conf, fs, renewer, tokenFile);\n         }\n         return null;\n       }\n     });\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void main(Configuration conf, final String[] args)\n      throws Exception {\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions\n      .addOption(WEBSERVICE, true, \"HTTP url to reach the NameNode at\")\n      .addOption(RENEWER, true, \"Name of the delegation token renewer\")\n      .addOption(CANCEL, false, \"cancel the token\")\n      .addOption(RENEW, false, \"renew the token\")\n      .addOption(PRINT, false, \"print the token\")\n      .addOption(VERBOSE, false, \"print verbose output\")\n      .addOption(HELP_SHORT, HELP, false, \"print out help information\");\n\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n            fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n            .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? cmd.getOptionValue\n            (RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    final boolean verbose \u003d cmd.hasOption(VERBOSE);\n    final boolean help \u003d cmd.hasOption(HELP);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (help) {\n      printUsage(System.out);\n      return;\n    }\n\n    int commandCount \u003d (cancel ? 1 : 0) + (renew ? 1 : 0) + (print ? 1 : 0);\n    if (commandCount \u003e 1) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n      return;\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n      return;\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n      @Override\n      public Object run() throws Exception {\n        if (print) {\n          printTokens(conf, tokenFile, verbose);\n        } else if (cancel) {\n          cancelTokens(conf, tokenFile);\n        } else if (renew) {\n          renewTokens(conf, tokenFile);\n        } else {\n          // otherwise we are fetching\n          FileSystem fs \u003d getFileSystem(conf, webUrl);\n          saveDelegationToken(conf, fs, renewer, tokenFile);\n        }\n        return null;\n      }\n    });\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
          "extendedDetails": {
            "oldValue": "[args-String[](modifiers-final)]",
            "newValue": "[conf-Configuration, args-String[](modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13951. HDFS DelegationTokenFetcher can\u0027t print non-HDFS tokens in a tokenfile.\nContributed by Steve Loughran.\n",
          "commitDate": "11/10/18 12:03 PM",
          "commitName": "2addebb94f592e46b261e2edd9e95a82e83bd761",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "06/09/18 2:48 PM",
          "commitNameOld": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 34.89,
          "commitsBetweenForRepo": 367,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,67 @@\n-  public static void main(final String[] args) throws Exception {\n-    final Configuration conf \u003d new HdfsConfiguration();\n+  public static void main(Configuration conf, final String[] args)\n+      throws Exception {\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions\n       .addOption(WEBSERVICE, true, \"HTTP url to reach the NameNode at\")\n       .addOption(RENEWER, true, \"Name of the delegation token renewer\")\n       .addOption(CANCEL, false, \"cancel the token\")\n       .addOption(RENEW, false, \"renew the token\")\n       .addOption(PRINT, false, \"print the token\")\n       .addOption(VERBOSE, false, \"print verbose output\")\n       .addOption(HELP_SHORT, HELP, false, \"print out help information\");\n \n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n             fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n \n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n             .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? cmd.getOptionValue\n             (RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n     final boolean verbose \u003d cmd.hasOption(VERBOSE);\n     final boolean help \u003d cmd.hasOption(HELP);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (help) {\n       printUsage(System.out);\n-      System.exit(0);\n+      return;\n     }\n \n     int commandCount \u003d (cancel ? 1 : 0) + (renew ? 1 : 0) + (print ? 1 : 0);\n     if (commandCount \u003e 1) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n+      return;\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n+      return;\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n       @Override\n       public Object run() throws Exception {\n         if (print) {\n           printTokens(conf, tokenFile, verbose);\n         } else if (cancel) {\n           cancelTokens(conf, tokenFile);\n         } else if (renew) {\n           renewTokens(conf, tokenFile);\n         } else {\n           // otherwise we are fetching\n           FileSystem fs \u003d getFileSystem(conf, webUrl);\n           saveDelegationToken(conf, fs, renewer, tokenFile);\n         }\n         return null;\n       }\n     });\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void main(Configuration conf, final String[] args)\n      throws Exception {\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions\n      .addOption(WEBSERVICE, true, \"HTTP url to reach the NameNode at\")\n      .addOption(RENEWER, true, \"Name of the delegation token renewer\")\n      .addOption(CANCEL, false, \"cancel the token\")\n      .addOption(RENEW, false, \"renew the token\")\n      .addOption(PRINT, false, \"print the token\")\n      .addOption(VERBOSE, false, \"print verbose output\")\n      .addOption(HELP_SHORT, HELP, false, \"print out help information\");\n\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n            fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n            .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? cmd.getOptionValue\n            (RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    final boolean verbose \u003d cmd.hasOption(VERBOSE);\n    final boolean help \u003d cmd.hasOption(HELP);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (help) {\n      printUsage(System.out);\n      return;\n    }\n\n    int commandCount \u003d (cancel ? 1 : 0) + (renew ? 1 : 0) + (print ? 1 : 0);\n    if (commandCount \u003e 1) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n      return;\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n      return;\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n      @Override\n      public Object run() throws Exception {\n        if (print) {\n          printTokens(conf, tokenFile, verbose);\n        } else if (cancel) {\n          cancelTokens(conf, tokenFile);\n        } else if (renew) {\n          renewTokens(conf, tokenFile);\n        } else {\n          // otherwise we are fetching\n          FileSystem fs \u003d getFileSystem(conf, webUrl);\n          saveDelegationToken(conf, fs, renewer, tokenFile);\n        }\n        return null;\n      }\n    });\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
          "extendedDetails": {}
        }
      ]
    },
    "e24fe2641b4117601105fa097c8848d82b96b74c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9732, Improve DelegationTokenIdentifier.toString() for better logging. Contributed by Yongjun Zhang.\n",
      "commitDate": "17/05/16 2:03 PM",
      "commitName": "e24fe2641b4117601105fa097c8848d82b96b74c",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "29/04/16 10:32 PM",
      "commitNameOld": "2753185a010e70f8d9539f42151c79177781122d",
      "commitAuthorOld": "Ravi Prakash",
      "daysBetweenCommits": 17.65,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,65 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions\n       .addOption(WEBSERVICE, true, \"HTTP url to reach the NameNode at\")\n       .addOption(RENEWER, true, \"Name of the delegation token renewer\")\n       .addOption(CANCEL, false, \"cancel the token\")\n       .addOption(RENEW, false, \"renew the token\")\n       .addOption(PRINT, false, \"print the token\")\n+      .addOption(VERBOSE, false, \"print verbose output\")\n       .addOption(HELP_SHORT, HELP, false, \"print out help information\");\n \n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n             fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n \n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n             .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? cmd.getOptionValue\n             (RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n+    final boolean verbose \u003d cmd.hasOption(VERBOSE);\n     final boolean help \u003d cmd.hasOption(HELP);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (help) {\n       printUsage(System.out);\n       System.exit(0);\n     }\n \n     int commandCount \u003d (cancel ? 1 : 0) + (renew ? 1 : 0) + (print ? 1 : 0);\n     if (commandCount \u003e 1) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n       @Override\n       public Object run() throws Exception {\n         if (print) {\n-          printTokens(conf, tokenFile);\n+          printTokens(conf, tokenFile, verbose);\n         } else if (cancel) {\n           cancelTokens(conf, tokenFile);\n         } else if (renew) {\n           renewTokens(conf, tokenFile);\n         } else {\n           // otherwise we are fetching\n           FileSystem fs \u003d getFileSystem(conf, webUrl);\n           saveDelegationToken(conf, fs, renewer, tokenFile);\n         }\n         return null;\n       }\n     });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions\n      .addOption(WEBSERVICE, true, \"HTTP url to reach the NameNode at\")\n      .addOption(RENEWER, true, \"Name of the delegation token renewer\")\n      .addOption(CANCEL, false, \"cancel the token\")\n      .addOption(RENEW, false, \"renew the token\")\n      .addOption(PRINT, false, \"print the token\")\n      .addOption(VERBOSE, false, \"print verbose output\")\n      .addOption(HELP_SHORT, HELP, false, \"print out help information\");\n\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n            fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n            .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? cmd.getOptionValue\n            (RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    final boolean verbose \u003d cmd.hasOption(VERBOSE);\n    final boolean help \u003d cmd.hasOption(HELP);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (help) {\n      printUsage(System.out);\n      System.exit(0);\n    }\n\n    int commandCount \u003d (cancel ? 1 : 0) + (renew ? 1 : 0) + (print ? 1 : 0);\n    if (commandCount \u003e 1) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n      @Override\n      public Object run() throws Exception {\n        if (print) {\n          printTokens(conf, tokenFile, verbose);\n        } else if (cancel) {\n          cancelTokens(conf, tokenFile);\n        } else if (renew) {\n          renewTokens(conf, tokenFile);\n        } else {\n          // otherwise we are fetching\n          FileSystem fs \u003d getFileSystem(conf, webUrl);\n          saveDelegationToken(conf, fs, renewer, tokenFile);\n        }\n        return null;\n      }\n    });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "fb1d7fb596b8e8bb9a5f141c89acb1949bade87a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5570. Deprecate hftp / hsftp and replace them with webhdfs / swebhdfs. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1584100 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/04/14 10:28 AM",
      "commitName": "fb1d7fb596b8e8bb9a5f141c89acb1949bade87a",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "24/03/14 10:51 PM",
      "commitNameOld": "3a61d25457606b93f7e99a48fe8f66984f4084b0",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 8.48,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,63 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n-    fetcherOptions.addOption(WEBSERVICE, true,\n-        \"HTTP url to reach the NameNode at\");\n-    fetcherOptions.addOption(RENEWER, true,\n-        \"Name of the delegation token renewer\");\n-    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n-    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n-    fetcherOptions.addOption(PRINT, false, \"print the token\");\n-    fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n+    fetcherOptions\n+      .addOption(WEBSERVICE, true, \"HTTP url to reach the NameNode at\")\n+      .addOption(RENEWER, true, \"Name of the delegation token renewer\")\n+      .addOption(CANCEL, false, \"cancel the token\")\n+      .addOption(RENEW, false, \"renew the token\")\n+      .addOption(PRINT, false, \"print the token\")\n+      .addOption(HELP_SHORT, HELP, false, \"print out help information\");\n+\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n-        fetcherOptions, args);\n+            fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n-    \n-    // get options\n+\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n-        .getOptionValue(WEBSERVICE) : null;\n-    final String renewer \u003d cmd.hasOption(RENEWER) ? \n-        cmd.getOptionValue(RENEWER) : null;\n+            .getOptionValue(WEBSERVICE) : null;\n+    final String renewer \u003d cmd.hasOption(RENEWER) ? cmd.getOptionValue\n+            (RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n     final boolean help \u003d cmd.hasOption(HELP);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (help) {\n       printUsage(System.out);\n       System.exit(0);\n     }\n-    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n-        \u0026\u0026 print) {\n+\n+    int commandCount \u003d (cancel ? 1 : 0) + (renew ? 1 : 0) + (print ? 1 : 0);\n+    if (commandCount \u003e 1) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n-    final URLConnectionFactory connectionFactory \u003d URLConnectionFactory.DEFAULT_SYSTEM_CONNECTION_FACTORY;\n \n     // Login the current user\n-    UserGroupInformation.getCurrentUser().doAs(\n-        new PrivilegedExceptionAction\u003cObject\u003e() {\n-          @Override\n-          public Object run() throws Exception {\n-\n-            if (print) {\n-              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n-                  0, 0, 0, 0, null).createIdentifier();\n-              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n-                DataInputStream in \u003d new DataInputStream(\n-                    new ByteArrayInputStream(token.getIdentifier()));\n-                id.readFields(in);\n-                System.out.println(\"Token (\" + id + \") for \" + \n-                                   token.getService());\n-              }\n-            } else if (cancel) {\n-              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n-                if (token.isManaged()) {\n-                  token.cancel(conf);\n-                  if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Cancelled token for \" + token.getService());\n-                  }\n-                }\n-              }\n-            } else if (renew) {\n-              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n-                if (token.isManaged()) {\n-                  long result \u003d token.renew(conf);\n-                  if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Renewed token for \" + token.getService()\n-                        + \" until: \" + new Date(result));\n-                  }\n-                }\n-              }\n-            } else {\n-              // otherwise we are fetching\n-              if (webUrl !\u003d null) {\n-                Credentials creds \u003d getDTfromRemote(connectionFactory, new URI(\n-                    webUrl), renewer, null);\n-                creds.writeTokenStorageFile(tokenFile, conf);\n-                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n-                  if(LOG.isDebugEnabled()) {\t\n-                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n-                        + token.getService() + \" into \" + tokenFile);\n-                  }\n-                }\n-              } else {\n-                FileSystem fs \u003d FileSystem.get(conf);\n-                Credentials cred \u003d new Credentials();\n-                Token\u003c?\u003e tokens[] \u003d fs.addDelegationTokens(renewer, cred);\n-                cred.writeTokenStorageFile(tokenFile, conf);\n-                if(LOG.isDebugEnabled()) {\n-                  for (Token\u003c?\u003e token : tokens) {\n-                    LOG.debug(\"Fetched token for \" + token.getService()\n-                        + \" into \" + tokenFile);\n-                  }\n-                }\n-              }\n-            }\n-            return null;\n-          }\n-        });\n+    UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+      @Override\n+      public Object run() throws Exception {\n+        if (print) {\n+          printTokens(conf, tokenFile);\n+        } else if (cancel) {\n+          cancelTokens(conf, tokenFile);\n+        } else if (renew) {\n+          renewTokens(conf, tokenFile);\n+        } else {\n+          // otherwise we are fetching\n+          FileSystem fs \u003d getFileSystem(conf, webUrl);\n+          saveDelegationToken(conf, fs, renewer, tokenFile);\n+        }\n+        return null;\n+      }\n+    });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions\n      .addOption(WEBSERVICE, true, \"HTTP url to reach the NameNode at\")\n      .addOption(RENEWER, true, \"Name of the delegation token renewer\")\n      .addOption(CANCEL, false, \"cancel the token\")\n      .addOption(RENEW, false, \"renew the token\")\n      .addOption(PRINT, false, \"print the token\")\n      .addOption(HELP_SHORT, HELP, false, \"print out help information\");\n\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n            fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n            .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? cmd.getOptionValue\n            (RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    final boolean help \u003d cmd.hasOption(HELP);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (help) {\n      printUsage(System.out);\n      System.exit(0);\n    }\n\n    int commandCount \u003d (cancel ? 1 : 0) + (renew ? 1 : 0) + (print ? 1 : 0);\n    if (commandCount \u003e 1) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n      @Override\n      public Object run() throws Exception {\n        if (print) {\n          printTokens(conf, tokenFile);\n        } else if (cancel) {\n          cancelTokens(conf, tokenFile);\n        } else if (renew) {\n          renewTokens(conf, tokenFile);\n        } else {\n          // otherwise we are fetching\n          FileSystem fs \u003d getFileSystem(conf, webUrl);\n          saveDelegationToken(conf, fs, renewer, tokenFile);\n        }\n        return null;\n      }\n    });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "8c505adddbaec558c25f3dd26f92eb6107150281": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5842. Cannot create hftp filesystem when using a proxy user ugi and a doAs on a secure cluster. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1562603 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/01/14 1:53 PM",
      "commitName": "8c505adddbaec558c25f3dd26f92eb6107150281",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "25/11/13 5:16 PM",
      "commitNameOld": "d8a23834614581a292aad214dddcbcc4bbe86d27",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 64.86,
      "commitsBetweenForRepo": 318,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,109 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions.addOption(WEBSERVICE, true,\n         \"HTTP url to reach the NameNode at\");\n     fetcherOptions.addOption(RENEWER, true,\n         \"Name of the delegation token renewer\");\n     fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n     fetcherOptions.addOption(RENEW, false, \"renew the token\");\n     fetcherOptions.addOption(PRINT, false, \"print the token\");\n     fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n         fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n     \n     // get options\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n         .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? \n         cmd.getOptionValue(RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n     final boolean help \u003d cmd.hasOption(HELP);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (help) {\n       printUsage(System.out);\n       System.exit(0);\n     }\n     if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n         \u0026\u0026 print) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n     final URLConnectionFactory connectionFactory \u003d URLConnectionFactory.DEFAULT_SYSTEM_CONNECTION_FACTORY;\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(\n         new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n \n             if (print) {\n               DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                   0, 0, 0, 0, null).createIdentifier();\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 DataInputStream in \u003d new DataInputStream(\n                     new ByteArrayInputStream(token.getIdentifier()));\n                 id.readFields(in);\n                 System.out.println(\"Token (\" + id + \") for \" + \n                                    token.getService());\n               }\n             } else if (cancel) {\n               for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   token.cancel(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Cancelled token for \" + token.getService());\n                   }\n                 }\n               }\n             } else if (renew) {\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   long result \u003d token.renew(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Renewed token for \" + token.getService()\n                         + \" until: \" + new Date(result));\n                   }\n                 }\n               }\n             } else {\n               // otherwise we are fetching\n               if (webUrl !\u003d null) {\n-                Credentials creds \u003d getDTfromRemote(connectionFactory, new URI(webUrl),\n-                    renewer);\n+                Credentials creds \u003d getDTfromRemote(connectionFactory, new URI(\n+                    webUrl), renewer, null);\n                 creds.writeTokenStorageFile(tokenFile, conf);\n                 for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                   if(LOG.isDebugEnabled()) {\t\n                     LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                         + token.getService() + \" into \" + tokenFile);\n                   }\n                 }\n               } else {\n                 FileSystem fs \u003d FileSystem.get(conf);\n                 Credentials cred \u003d new Credentials();\n                 Token\u003c?\u003e tokens[] \u003d fs.addDelegationTokens(renewer, cred);\n                 cred.writeTokenStorageFile(tokenFile, conf);\n                 if(LOG.isDebugEnabled()) {\n                   for (Token\u003c?\u003e token : tokens) {\n                     LOG.debug(\"Fetched token for \" + token.getService()\n                         + \" into \" + tokenFile);\n                   }\n                 }\n               }\n             }\n             return null;\n           }\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTP url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    final boolean help \u003d cmd.hasOption(HELP);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (help) {\n      printUsage(System.out);\n      System.exit(0);\n    }\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n    final URLConnectionFactory connectionFactory \u003d URLConnectionFactory.DEFAULT_SYSTEM_CONNECTION_FACTORY;\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + \n                                   token.getService());\n              }\n            } else if (cancel) {\n              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  token.cancel(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token for \" + token.getService());\n                  }\n                }\n              }\n            } else if (renew) {\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  long result \u003d token.renew(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Renewed token for \" + token.getService()\n                        + \" until: \" + new Date(result));\n                  }\n                }\n              }\n            } else {\n              // otherwise we are fetching\n              if (webUrl !\u003d null) {\n                Credentials creds \u003d getDTfromRemote(connectionFactory, new URI(\n                    webUrl), renewer, null);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  if(LOG.isDebugEnabled()) {\t\n                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                        + token.getService() + \" into \" + tokenFile);\n                  }\n                }\n              } else {\n                FileSystem fs \u003d FileSystem.get(conf);\n                Credentials cred \u003d new Credentials();\n                Token\u003c?\u003e tokens[] \u003d fs.addDelegationTokens(renewer, cred);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                if(LOG.isDebugEnabled()) {\n                  for (Token\u003c?\u003e token : tokens) {\n                    LOG.debug(\"Fetched token for \" + token.getService()\n                        + \" into \" + tokenFile);\n                  }\n                }\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "d8a23834614581a292aad214dddcbcc4bbe86d27": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5538. URLConnectionFactory should pick up the SSL related configuration by default. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1545491 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/11/13 5:16 PM",
      "commitName": "d8a23834614581a292aad214dddcbcc4bbe86d27",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "15/11/13 5:00 PM",
      "commitNameOld": "fef8f49c5885ba05dcd73e8a02de7c2be5ec3f0e",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 10.01,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,109 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions.addOption(WEBSERVICE, true,\n         \"HTTP url to reach the NameNode at\");\n     fetcherOptions.addOption(RENEWER, true,\n         \"Name of the delegation token renewer\");\n     fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n     fetcherOptions.addOption(RENEW, false, \"renew the token\");\n     fetcherOptions.addOption(PRINT, false, \"print the token\");\n     fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n         fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n     \n     // get options\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n         .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? \n         cmd.getOptionValue(RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n     final boolean help \u003d cmd.hasOption(HELP);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (help) {\n       printUsage(System.out);\n       System.exit(0);\n     }\n     if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n         \u0026\u0026 print) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n-    final URLConnectionFactory connectionFactory \u003d URLConnectionFactory.DEFAULT_CONNECTION_FACTORY;\n+    final URLConnectionFactory connectionFactory \u003d URLConnectionFactory.DEFAULT_SYSTEM_CONNECTION_FACTORY;\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(\n         new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n \n             if (print) {\n               DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                   0, 0, 0, 0, null).createIdentifier();\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 DataInputStream in \u003d new DataInputStream(\n                     new ByteArrayInputStream(token.getIdentifier()));\n                 id.readFields(in);\n                 System.out.println(\"Token (\" + id + \") for \" + \n                                    token.getService());\n               }\n             } else if (cancel) {\n               for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   token.cancel(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Cancelled token for \" + token.getService());\n                   }\n                 }\n               }\n             } else if (renew) {\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   long result \u003d token.renew(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Renewed token for \" + token.getService()\n                         + \" until: \" + new Date(result));\n                   }\n                 }\n               }\n             } else {\n               // otherwise we are fetching\n               if (webUrl !\u003d null) {\n                 Credentials creds \u003d getDTfromRemote(connectionFactory, new URI(webUrl),\n                     renewer);\n                 creds.writeTokenStorageFile(tokenFile, conf);\n                 for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                   if(LOG.isDebugEnabled()) {\t\n                     LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                         + token.getService() + \" into \" + tokenFile);\n                   }\n                 }\n               } else {\n                 FileSystem fs \u003d FileSystem.get(conf);\n                 Credentials cred \u003d new Credentials();\n                 Token\u003c?\u003e tokens[] \u003d fs.addDelegationTokens(renewer, cred);\n                 cred.writeTokenStorageFile(tokenFile, conf);\n                 if(LOG.isDebugEnabled()) {\n                   for (Token\u003c?\u003e token : tokens) {\n                     LOG.debug(\"Fetched token for \" + token.getService()\n                         + \" into \" + tokenFile);\n                   }\n                 }\n               }\n             }\n             return null;\n           }\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTP url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    final boolean help \u003d cmd.hasOption(HELP);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (help) {\n      printUsage(System.out);\n      System.exit(0);\n    }\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n    final URLConnectionFactory connectionFactory \u003d URLConnectionFactory.DEFAULT_SYSTEM_CONNECTION_FACTORY;\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + \n                                   token.getService());\n              }\n            } else if (cancel) {\n              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  token.cancel(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token for \" + token.getService());\n                  }\n                }\n              }\n            } else if (renew) {\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  long result \u003d token.renew(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Renewed token for \" + token.getService()\n                        + \" until: \" + new Date(result));\n                  }\n                }\n              }\n            } else {\n              // otherwise we are fetching\n              if (webUrl !\u003d null) {\n                Credentials creds \u003d getDTfromRemote(connectionFactory, new URI(webUrl),\n                    renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  if(LOG.isDebugEnabled()) {\t\n                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                        + token.getService() + \" into \" + tokenFile);\n                  }\n                }\n              } else {\n                FileSystem fs \u003d FileSystem.get(conf);\n                Credentials cred \u003d new Credentials();\n                Token\u003c?\u003e tokens[] \u003d fs.addDelegationTokens(renewer, cred);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                if(LOG.isDebugEnabled()) {\n                  for (Token\u003c?\u003e token : tokens) {\n                    LOG.debug(\"Fetched token for \" + token.getService()\n                        + \" into \" + tokenFile);\n                  }\n                }\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "43fa41fdeee53471e9aa34c89f58e53e8aa164e5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5506. Use URLConnectionFactory in DelegationTokenFetcher. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1542011 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/13 10:40 AM",
      "commitName": "43fa41fdeee53471e9aa34c89f58e53e8aa164e5",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "29/10/13 3:44 PM",
      "commitNameOld": "68a79b0d3f189dfdbd3a3e2a0b906627db3eff8d",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 15.83,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,109 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions.addOption(WEBSERVICE, true,\n         \"HTTP url to reach the NameNode at\");\n     fetcherOptions.addOption(RENEWER, true,\n         \"Name of the delegation token renewer\");\n     fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n     fetcherOptions.addOption(RENEW, false, \"renew the token\");\n     fetcherOptions.addOption(PRINT, false, \"print the token\");\n     fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n         fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n     \n     // get options\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n         .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? \n         cmd.getOptionValue(RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n     final boolean help \u003d cmd.hasOption(HELP);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (help) {\n       printUsage(System.out);\n       System.exit(0);\n     }\n     if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n         \u0026\u0026 print) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n+    final URLConnectionFactory connectionFactory \u003d URLConnectionFactory.DEFAULT_CONNECTION_FACTORY;\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(\n         new PrivilegedExceptionAction\u003cObject\u003e() {\n-          @SuppressWarnings(\"unchecked\")\n           @Override\n           public Object run() throws Exception {\n \n             if (print) {\n               DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                   0, 0, 0, 0, null).createIdentifier();\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 DataInputStream in \u003d new DataInputStream(\n                     new ByteArrayInputStream(token.getIdentifier()));\n                 id.readFields(in);\n                 System.out.println(\"Token (\" + id + \") for \" + \n                                    token.getService());\n               }\n             } else if (cancel) {\n               for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   token.cancel(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Cancelled token for \" + token.getService());\n                   }\n                 }\n               }\n             } else if (renew) {\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   long result \u003d token.renew(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Renewed token for \" + token.getService()\n                         + \" until: \" + new Date(result));\n                   }\n                 }\n               }\n             } else {\n               // otherwise we are fetching\n               if (webUrl !\u003d null) {\n-                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n+                Credentials creds \u003d getDTfromRemote(connectionFactory, new URI(webUrl),\n+                    renewer);\n                 creds.writeTokenStorageFile(tokenFile, conf);\n                 for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                   if(LOG.isDebugEnabled()) {\t\n                     LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                         + token.getService() + \" into \" + tokenFile);\n                   }\n                 }\n               } else {\n                 FileSystem fs \u003d FileSystem.get(conf);\n                 Credentials cred \u003d new Credentials();\n                 Token\u003c?\u003e tokens[] \u003d fs.addDelegationTokens(renewer, cred);\n                 cred.writeTokenStorageFile(tokenFile, conf);\n                 if(LOG.isDebugEnabled()) {\n                   for (Token\u003c?\u003e token : tokens) {\n                     LOG.debug(\"Fetched token for \" + token.getService()\n                         + \" into \" + tokenFile);\n                   }\n                 }\n               }\n             }\n             return null;\n           }\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTP url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    final boolean help \u003d cmd.hasOption(HELP);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (help) {\n      printUsage(System.out);\n      System.exit(0);\n    }\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n    final URLConnectionFactory connectionFactory \u003d URLConnectionFactory.DEFAULT_CONNECTION_FACTORY;\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + \n                                   token.getService());\n              }\n            } else if (cancel) {\n              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  token.cancel(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token for \" + token.getService());\n                  }\n                }\n              }\n            } else if (renew) {\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  long result \u003d token.renew(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Renewed token for \" + token.getService()\n                        + \" until: \" + new Date(result));\n                  }\n                }\n              }\n            } else {\n              // otherwise we are fetching\n              if (webUrl !\u003d null) {\n                Credentials creds \u003d getDTfromRemote(connectionFactory, new URI(webUrl),\n                    renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  if(LOG.isDebugEnabled()) {\t\n                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                        + token.getService() + \" into \" + tokenFile);\n                  }\n                }\n              } else {\n                FileSystem fs \u003d FileSystem.get(conf);\n                Credentials cred \u003d new Credentials();\n                Token\u003c?\u003e tokens[] \u003d fs.addDelegationTokens(renewer, cred);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                if(LOG.isDebugEnabled()) {\n                  for (Token\u003c?\u003e token : tokens) {\n                    LOG.debug(\"Fetched token for \" + token.getService()\n                        + \" into \" + tokenFile);\n                  }\n                }\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "8fa10b184e607a33f59e67bd4b1fbe5a2e683941": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7967. Need generalized multi-token filesystem support (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1374271 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/08/12 7:05 AM",
      "commitName": "8fa10b184e607a33f59e67bd4b1fbe5a2e683941",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "14/08/12 5:28 PM",
      "commitNameOld": "28e87740c5797e87a9038d7f151c8b21a5b04592",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 2.57,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,108 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions.addOption(WEBSERVICE, true,\n         \"HTTP url to reach the NameNode at\");\n     fetcherOptions.addOption(RENEWER, true,\n         \"Name of the delegation token renewer\");\n     fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n     fetcherOptions.addOption(RENEW, false, \"renew the token\");\n     fetcherOptions.addOption(PRINT, false, \"print the token\");\n     fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n         fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n     \n     // get options\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n         .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? \n         cmd.getOptionValue(RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n     final boolean help \u003d cmd.hasOption(HELP);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (help) {\n       printUsage(System.out);\n       System.exit(0);\n     }\n     if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n         \u0026\u0026 print) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(\n         new PrivilegedExceptionAction\u003cObject\u003e() {\n           @SuppressWarnings(\"unchecked\")\n           @Override\n           public Object run() throws Exception {\n \n             if (print) {\n               DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                   0, 0, 0, 0, null).createIdentifier();\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 DataInputStream in \u003d new DataInputStream(\n                     new ByteArrayInputStream(token.getIdentifier()));\n                 id.readFields(in);\n                 System.out.println(\"Token (\" + id + \") for \" + \n                                    token.getService());\n               }\n             } else if (cancel) {\n               for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   token.cancel(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Cancelled token for \" + token.getService());\n                   }\n                 }\n               }\n             } else if (renew) {\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   long result \u003d token.renew(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Renewed token for \" + token.getService()\n                         + \" until: \" + new Date(result));\n                   }\n                 }\n               }\n             } else {\n               // otherwise we are fetching\n               if (webUrl !\u003d null) {\n                 Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                 creds.writeTokenStorageFile(tokenFile, conf);\n                 for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                   if(LOG.isDebugEnabled()) {\t\n                     LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                         + token.getService() + \" into \" + tokenFile);\n                   }\n                 }\n               } else {\n                 FileSystem fs \u003d FileSystem.get(conf);\n-                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                 Credentials cred \u003d new Credentials();\n-                cred.addToken(token.getService(), token);\n+                Token\u003c?\u003e tokens[] \u003d fs.addDelegationTokens(renewer, cred);\n                 cred.writeTokenStorageFile(tokenFile, conf);\n                 if(LOG.isDebugEnabled()) {\n-                  LOG.debug(\"Fetched token for \" + token.getService()\n-                      + \" into \" + tokenFile);\n+                  for (Token\u003c?\u003e token : tokens) {\n+                    LOG.debug(\"Fetched token for \" + token.getService()\n+                        + \" into \" + tokenFile);\n+                  }\n                 }\n               }\n             }\n             return null;\n           }\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTP url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    final boolean help \u003d cmd.hasOption(HELP);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (help) {\n      printUsage(System.out);\n      System.exit(0);\n    }\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @SuppressWarnings(\"unchecked\")\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + \n                                   token.getService());\n              }\n            } else if (cancel) {\n              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  token.cancel(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token for \" + token.getService());\n                  }\n                }\n              }\n            } else if (renew) {\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  long result \u003d token.renew(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Renewed token for \" + token.getService()\n                        + \" until: \" + new Date(result));\n                  }\n                }\n              }\n            } else {\n              // otherwise we are fetching\n              if (webUrl !\u003d null) {\n                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  if(LOG.isDebugEnabled()) {\t\n                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                        + token.getService() + \" into \" + tokenFile);\n                  }\n                }\n              } else {\n                FileSystem fs \u003d FileSystem.get(conf);\n                Credentials cred \u003d new Credentials();\n                Token\u003c?\u003e tokens[] \u003d fs.addDelegationTokens(renewer, cred);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                if(LOG.isDebugEnabled()) {\n                  for (Token\u003c?\u003e token : tokens) {\n                    LOG.debug(\"Fetched token for \" + token.getService()\n                        + \" into \" + tokenFile);\n                  }\n                }\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "28e87740c5797e87a9038d7f151c8b21a5b04592": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3723. Add support -h, -help to all the commands. Contributed by Jing Zhao\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1373173 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/12 5:28 PM",
      "commitName": "28e87740c5797e87a9038d7f151c8b21a5b04592",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "14/08/12 5:25 PM",
      "commitNameOld": "231a52a7dfa73f7f302cc3bf671d433312373873",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,107 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions.addOption(WEBSERVICE, true,\n         \"HTTP url to reach the NameNode at\");\n     fetcherOptions.addOption(RENEWER, true,\n         \"Name of the delegation token renewer\");\n     fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n     fetcherOptions.addOption(RENEW, false, \"renew the token\");\n     fetcherOptions.addOption(PRINT, false, \"print the token\");\n+    fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n         fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n     \n     // get options\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n         .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? \n         cmd.getOptionValue(RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n+    final boolean help \u003d cmd.hasOption(HELP);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n+    if (help) {\n+      printUsage(System.out);\n+      System.exit(0);\n+    }\n     if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n         \u0026\u0026 print) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(\n         new PrivilegedExceptionAction\u003cObject\u003e() {\n           @SuppressWarnings(\"unchecked\")\n           @Override\n           public Object run() throws Exception {\n \n             if (print) {\n               DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                   0, 0, 0, 0, null).createIdentifier();\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 DataInputStream in \u003d new DataInputStream(\n                     new ByteArrayInputStream(token.getIdentifier()));\n                 id.readFields(in);\n                 System.out.println(\"Token (\" + id + \") for \" + \n                                    token.getService());\n               }\n             } else if (cancel) {\n               for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   token.cancel(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Cancelled token for \" + token.getService());\n                   }\n                 }\n               }\n             } else if (renew) {\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   long result \u003d token.renew(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Renewed token for \" + token.getService()\n                         + \" until: \" + new Date(result));\n                   }\n                 }\n               }\n             } else {\n               // otherwise we are fetching\n               if (webUrl !\u003d null) {\n                 Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                 creds.writeTokenStorageFile(tokenFile, conf);\n                 for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                   if(LOG.isDebugEnabled()) {\t\n                     LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                         + token.getService() + \" into \" + tokenFile);\n                   }\n                 }\n               } else {\n                 FileSystem fs \u003d FileSystem.get(conf);\n                 Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                 Credentials cred \u003d new Credentials();\n                 cred.addToken(token.getService(), token);\n                 cred.writeTokenStorageFile(tokenFile, conf);\n                 if(LOG.isDebugEnabled()) {\n                   LOG.debug(\"Fetched token for \" + token.getService()\n                       + \" into \" + tokenFile);\n                 }\n               }\n             }\n             return null;\n           }\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTP url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    final boolean help \u003d cmd.hasOption(HELP);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (help) {\n      printUsage(System.out);\n      System.exit(0);\n    }\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @SuppressWarnings(\"unchecked\")\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + \n                                   token.getService());\n              }\n            } else if (cancel) {\n              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  token.cancel(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token for \" + token.getService());\n                  }\n                }\n              }\n            } else if (renew) {\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  long result \u003d token.renew(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Renewed token for \" + token.getService()\n                        + \" until: \" + new Date(result));\n                  }\n                }\n              }\n            } else {\n              // otherwise we are fetching\n              if (webUrl !\u003d null) {\n                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  if(LOG.isDebugEnabled()) {\t\n                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                        + token.getService() + \" into \" + tokenFile);\n                  }\n                }\n              } else {\n                FileSystem fs \u003d FileSystem.get(conf);\n                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                Credentials cred \u003d new Credentials();\n                cred.addToken(token.getService(), token);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                if(LOG.isDebugEnabled()) {\n                  LOG.debug(\"Fetched token for \" + token.getService()\n                      + \" into \" + tokenFile);\n                }\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "231a52a7dfa73f7f302cc3bf671d433312373873": {
      "type": "Ybodychange",
      "commitMessage": "Reverting previous incomplete change r1373170 for HDFS-3723\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1373172 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/12 5:25 PM",
      "commitName": "231a52a7dfa73f7f302cc3bf671d433312373873",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "14/08/12 5:03 PM",
      "commitNameOld": "f026d8bb1ba6f9b059db5526f1fb1261f818ffd0",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,101 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions.addOption(WEBSERVICE, true,\n         \"HTTP url to reach the NameNode at\");\n     fetcherOptions.addOption(RENEWER, true,\n         \"Name of the delegation token renewer\");\n     fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n     fetcherOptions.addOption(RENEW, false, \"renew the token\");\n     fetcherOptions.addOption(PRINT, false, \"print the token\");\n-    fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n         fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n     \n     // get options\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n         .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? \n         cmd.getOptionValue(RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n-    final boolean help \u003d cmd.hasOption(HELP);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n-    if (help) {\n-      printUsage(System.out);\n-      System.exit(0);\n-    }\n     if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n         \u0026\u0026 print) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(\n         new PrivilegedExceptionAction\u003cObject\u003e() {\n           @SuppressWarnings(\"unchecked\")\n           @Override\n           public Object run() throws Exception {\n \n             if (print) {\n               DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                   0, 0, 0, 0, null).createIdentifier();\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 DataInputStream in \u003d new DataInputStream(\n                     new ByteArrayInputStream(token.getIdentifier()));\n                 id.readFields(in);\n                 System.out.println(\"Token (\" + id + \") for \" + \n                                    token.getService());\n               }\n             } else if (cancel) {\n               for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   token.cancel(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Cancelled token for \" + token.getService());\n                   }\n                 }\n               }\n             } else if (renew) {\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   long result \u003d token.renew(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Renewed token for \" + token.getService()\n                         + \" until: \" + new Date(result));\n                   }\n                 }\n               }\n             } else {\n               // otherwise we are fetching\n               if (webUrl !\u003d null) {\n                 Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                 creds.writeTokenStorageFile(tokenFile, conf);\n                 for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                   if(LOG.isDebugEnabled()) {\t\n                     LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                         + token.getService() + \" into \" + tokenFile);\n                   }\n                 }\n               } else {\n                 FileSystem fs \u003d FileSystem.get(conf);\n                 Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                 Credentials cred \u003d new Credentials();\n                 cred.addToken(token.getService(), token);\n                 cred.writeTokenStorageFile(tokenFile, conf);\n                 if(LOG.isDebugEnabled()) {\n                   LOG.debug(\"Fetched token for \" + token.getService()\n                       + \" into \" + tokenFile);\n                 }\n               }\n             }\n             return null;\n           }\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTP url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @SuppressWarnings(\"unchecked\")\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + \n                                   token.getService());\n              }\n            } else if (cancel) {\n              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  token.cancel(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token for \" + token.getService());\n                  }\n                }\n              }\n            } else if (renew) {\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  long result \u003d token.renew(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Renewed token for \" + token.getService()\n                        + \" until: \" + new Date(result));\n                  }\n                }\n              }\n            } else {\n              // otherwise we are fetching\n              if (webUrl !\u003d null) {\n                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  if(LOG.isDebugEnabled()) {\t\n                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                        + token.getService() + \" into \" + tokenFile);\n                  }\n                }\n              } else {\n                FileSystem fs \u003d FileSystem.get(conf);\n                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                Credentials cred \u003d new Credentials();\n                cred.addToken(token.getService(), token);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                if(LOG.isDebugEnabled()) {\n                  LOG.debug(\"Fetched token for \" + token.getService()\n                      + \" into \" + tokenFile);\n                }\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "f026d8bb1ba6f9b059db5526f1fb1261f818ffd0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3723. Add support -h, -help to all the commands. Contributed by Jing Zhao.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1373170 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/12 5:03 PM",
      "commitName": "f026d8bb1ba6f9b059db5526f1fb1261f818ffd0",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "02/08/12 3:10 PM",
      "commitNameOld": "42d071ab6f7cdba1d021cf563879996685f82634",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 12.08,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,107 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions.addOption(WEBSERVICE, true,\n         \"HTTP url to reach the NameNode at\");\n     fetcherOptions.addOption(RENEWER, true,\n         \"Name of the delegation token renewer\");\n     fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n     fetcherOptions.addOption(RENEW, false, \"renew the token\");\n     fetcherOptions.addOption(PRINT, false, \"print the token\");\n+    fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n         fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n     \n     // get options\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n         .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? \n         cmd.getOptionValue(RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n+    final boolean help \u003d cmd.hasOption(HELP);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n+    if (help) {\n+      printUsage(System.out);\n+      System.exit(0);\n+    }\n     if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n         \u0026\u0026 print) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(\n         new PrivilegedExceptionAction\u003cObject\u003e() {\n           @SuppressWarnings(\"unchecked\")\n           @Override\n           public Object run() throws Exception {\n \n             if (print) {\n               DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                   0, 0, 0, 0, null).createIdentifier();\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 DataInputStream in \u003d new DataInputStream(\n                     new ByteArrayInputStream(token.getIdentifier()));\n                 id.readFields(in);\n                 System.out.println(\"Token (\" + id + \") for \" + \n                                    token.getService());\n               }\n             } else if (cancel) {\n               for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   token.cancel(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Cancelled token for \" + token.getService());\n                   }\n                 }\n               }\n             } else if (renew) {\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   long result \u003d token.renew(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Renewed token for \" + token.getService()\n                         + \" until: \" + new Date(result));\n                   }\n                 }\n               }\n             } else {\n               // otherwise we are fetching\n               if (webUrl !\u003d null) {\n                 Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                 creds.writeTokenStorageFile(tokenFile, conf);\n                 for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                   if(LOG.isDebugEnabled()) {\t\n                     LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                         + token.getService() + \" into \" + tokenFile);\n                   }\n                 }\n               } else {\n                 FileSystem fs \u003d FileSystem.get(conf);\n                 Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                 Credentials cred \u003d new Credentials();\n                 cred.addToken(token.getService(), token);\n                 cred.writeTokenStorageFile(tokenFile, conf);\n                 if(LOG.isDebugEnabled()) {\n                   LOG.debug(\"Fetched token for \" + token.getService()\n                       + \" into \" + tokenFile);\n                 }\n               }\n             }\n             return null;\n           }\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTP url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    fetcherOptions.addOption(HELP_SHORT, HELP, false, \"print out help information\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    final boolean help \u003d cmd.hasOption(HELP);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (help) {\n      printUsage(System.out);\n      System.exit(0);\n    }\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @SuppressWarnings(\"unchecked\")\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + \n                                   token.getService());\n              }\n            } else if (cancel) {\n              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  token.cancel(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token for \" + token.getService());\n                  }\n                }\n              }\n            } else if (renew) {\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  long result \u003d token.renew(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Renewed token for \" + token.getService()\n                        + \" until: \" + new Date(result));\n                  }\n                }\n              }\n            } else {\n              // otherwise we are fetching\n              if (webUrl !\u003d null) {\n                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  if(LOG.isDebugEnabled()) {\t\n                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                        + token.getService() + \" into \" + tokenFile);\n                  }\n                }\n              } else {\n                FileSystem fs \u003d FileSystem.get(conf);\n                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                Credentials cred \u003d new Credentials();\n                cred.addToken(token.getService(), token);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                if(LOG.isDebugEnabled()) {\n                  LOG.debug(\"Fetched token for \" + token.getService()\n                      + \" into \" + tokenFile);\n                }\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "5dbbe0e0a5d31689d3425e490865f95057dc051c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2617. Replaced Kerberized SSL for image transfer and fsck with SPNEGO-based solution. Contributed by Jakob Homan, Alejandro Abdelnur, and Aaron T. Myers\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1334216 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/12 2:58 PM",
      "commitName": "5dbbe0e0a5d31689d3425e490865f95057dc051c",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "03/04/12 12:26 PM",
      "commitNameOld": "0db8003e2e3da9b22b952020d8b02af7f7d6d7c8",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 31.11,
      "commitsBetweenForRepo": 244,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions.addOption(WEBSERVICE, true,\n-        \"HTTPS url to reach the NameNode at\");\n+        \"HTTP url to reach the NameNode at\");\n     fetcherOptions.addOption(RENEWER, true,\n         \"Name of the delegation token renewer\");\n     fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n     fetcherOptions.addOption(RENEW, false, \"renew the token\");\n     fetcherOptions.addOption(PRINT, false, \"print the token\");\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n         fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n     \n     // get options\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n         .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? \n         cmd.getOptionValue(RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n         \u0026\u0026 print) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(\n         new PrivilegedExceptionAction\u003cObject\u003e() {\n           @SuppressWarnings(\"unchecked\")\n           @Override\n           public Object run() throws Exception {\n \n             if (print) {\n               DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                   0, 0, 0, 0, null).createIdentifier();\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 DataInputStream in \u003d new DataInputStream(\n                     new ByteArrayInputStream(token.getIdentifier()));\n                 id.readFields(in);\n                 System.out.println(\"Token (\" + id + \") for \" + \n                                    token.getService());\n               }\n             } else if (cancel) {\n               for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   token.cancel(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Cancelled token for \" + token.getService());\n                   }\n                 }\n               }\n             } else if (renew) {\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   long result \u003d token.renew(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Renewed token for \" + token.getService()\n                         + \" until: \" + new Date(result));\n                   }\n                 }\n               }\n             } else {\n               // otherwise we are fetching\n               if (webUrl !\u003d null) {\n                 Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                 creds.writeTokenStorageFile(tokenFile, conf);\n                 for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                   if(LOG.isDebugEnabled()) {\t\n                     LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                         + token.getService() + \" into \" + tokenFile);\n                   }\n                 }\n               } else {\n                 FileSystem fs \u003d FileSystem.get(conf);\n                 Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                 Credentials cred \u003d new Credentials();\n                 cred.addToken(token.getService(), token);\n                 cred.writeTokenStorageFile(tokenFile, conf);\n                 if(LOG.isDebugEnabled()) {\n                   LOG.debug(\"Fetched token for \" + token.getService()\n                       + \" into \" + tokenFile);\n                 }\n               }\n             }\n             return null;\n           }\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTP url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @SuppressWarnings(\"unchecked\")\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + \n                                   token.getService());\n              }\n            } else if (cancel) {\n              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  token.cancel(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token for \" + token.getService());\n                  }\n                }\n              }\n            } else if (renew) {\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  long result \u003d token.renew(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Renewed token for \" + token.getService()\n                        + \" until: \" + new Date(result));\n                  }\n                }\n              }\n            } else {\n              // otherwise we are fetching\n              if (webUrl !\u003d null) {\n                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  if(LOG.isDebugEnabled()) {\t\n                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                        + token.getService() + \" into \" + tokenFile);\n                  }\n                }\n              } else {\n                FileSystem fs \u003d FileSystem.get(conf);\n                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                Credentials cred \u003d new Credentials();\n                cred.addToken(token.getService(), token);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                if(LOG.isDebugEnabled()) {\n                  LOG.debug(\"Fetched token for \" + token.getService()\n                      + \" into \" + tokenFile);\n                }\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "ea868d3d8b6c5e018eb104a560890c60d30fa269": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3116. Typo in fetchdt error message. Contributed by AOE Takashi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1304996 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/12 1:45 AM",
      "commitName": "ea868d3d8b6c5e018eb104a560890c60d30fa269",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "02/02/12 11:04 AM",
      "commitNameOld": "9eb8f4d267ca38c16e3ba191a3b754de7d167669",
      "commitAuthorOld": "Jitendra Nath Pandey",
      "daysBetweenCommits": 51.57,
      "commitsBetweenForRepo": 391,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions.addOption(WEBSERVICE, true,\n         \"HTTPS url to reach the NameNode at\");\n     fetcherOptions.addOption(RENEWER, true,\n         \"Name of the delegation token renewer\");\n     fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n     fetcherOptions.addOption(RENEW, false, \"renew the token\");\n     fetcherOptions.addOption(PRINT, false, \"print the token\");\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n         fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n     \n     // get options\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n         .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? \n         cmd.getOptionValue(RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n         \u0026\u0026 print) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n-      System.err.println(\"ERROR: Must specify exacltly one token file\");\n+      System.err.println(\"ERROR: Must specify exactly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(\n         new PrivilegedExceptionAction\u003cObject\u003e() {\n           @SuppressWarnings(\"unchecked\")\n           @Override\n           public Object run() throws Exception {\n \n             if (print) {\n               DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                   0, 0, 0, 0, null).createIdentifier();\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 DataInputStream in \u003d new DataInputStream(\n                     new ByteArrayInputStream(token.getIdentifier()));\n                 id.readFields(in);\n                 System.out.println(\"Token (\" + id + \") for \" + \n                                    token.getService());\n               }\n             } else if (cancel) {\n               for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   token.cancel(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Cancelled token for \" + token.getService());\n                   }\n                 }\n               }\n             } else if (renew) {\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 if (token.isManaged()) {\n                   long result \u003d token.renew(conf);\n                   if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Renewed token for \" + token.getService()\n                         + \" until: \" + new Date(result));\n                   }\n                 }\n               }\n             } else {\n               // otherwise we are fetching\n               if (webUrl !\u003d null) {\n                 Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                 creds.writeTokenStorageFile(tokenFile, conf);\n                 for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                   if(LOG.isDebugEnabled()) {\t\n                     LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                         + token.getService() + \" into \" + tokenFile);\n                   }\n                 }\n               } else {\n                 FileSystem fs \u003d FileSystem.get(conf);\n                 Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                 Credentials cred \u003d new Credentials();\n                 cred.addToken(token.getService(), token);\n                 cred.writeTokenStorageFile(tokenFile, conf);\n                 if(LOG.isDebugEnabled()) {\n                   LOG.debug(\"Fetched token for \" + token.getService()\n                       + \" into \" + tokenFile);\n                 }\n               }\n             }\n             return null;\n           }\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTPS url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exactly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @SuppressWarnings(\"unchecked\")\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + \n                                   token.getService());\n              }\n            } else if (cancel) {\n              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  token.cancel(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token for \" + token.getService());\n                  }\n                }\n              }\n            } else if (renew) {\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  long result \u003d token.renew(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Renewed token for \" + token.getService()\n                        + \" until: \" + new Date(result));\n                  }\n                }\n              }\n            } else {\n              // otherwise we are fetching\n              if (webUrl !\u003d null) {\n                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  if(LOG.isDebugEnabled()) {\t\n                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                        + token.getService() + \" into \" + tokenFile);\n                  }\n                }\n              } else {\n                FileSystem fs \u003d FileSystem.get(conf);\n                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                Credentials cred \u003d new Credentials();\n                cred.addToken(token.getService(), token);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                if(LOG.isDebugEnabled()) {\n                  LOG.debug(\"Fetched token for \" + token.getService()\n                      + \" into \" + tokenFile);\n                }\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "002dd6968b89ded6a77858ccb50c9b2df074c226": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2764. Fix renewal of dfs delegation tokens. Contributed by Owen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1183187 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/10/11 6:24 PM",
      "commitName": "002dd6968b89ded6a77858ccb50c9b2df074c226",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "27/09/11 4:16 PM",
      "commitNameOld": "201b7879ba6994400c1aa955f242665c16c2c0ea",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 16.09,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,101 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions.addOption(WEBSERVICE, true,\n         \"HTTPS url to reach the NameNode at\");\n     fetcherOptions.addOption(RENEWER, true,\n         \"Name of the delegation token renewer\");\n     fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n     fetcherOptions.addOption(RENEW, false, \"renew the token\");\n     fetcherOptions.addOption(PRINT, false, \"print the token\");\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n         fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n     \n     // get options\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n         .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? \n         cmd.getOptionValue(RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n         \u0026\u0026 print) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exacltly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(\n         new PrivilegedExceptionAction\u003cObject\u003e() {\n           @SuppressWarnings(\"unchecked\")\n           @Override\n           public Object run() throws Exception {\n \n             if (print) {\n               DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                   0, 0, 0, 0, null).createIdentifier();\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 DataInputStream in \u003d new DataInputStream(\n                     new ByteArrayInputStream(token.getIdentifier()));\n                 id.readFields(in);\n-                if(LOG.isDebugEnabled()) {\n-                  LOG.debug(\"Token (\" + id + \") for \" + token.getService());\n+                System.out.println(\"Token (\" + id + \") for \" + \n+                                   token.getService());\n+              }\n+            } else if (cancel) {\n+              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n+                if (token.isManaged()) {\n+                  token.cancel(conf);\n+                  if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Cancelled token for \" + token.getService());\n+                  }\n                 }\n               }\n-              return null;\n-            }\n-            \n-            if (webUrl !\u003d null) {\n-              if (renew) {\n-                long result;\n-                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n-                  result \u003d renewDelegationToken(webUrl,\n-                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n-                  if(LOG.isDebugEnabled()) {\n-                \t  LOG.debug(\"Renewed token via \" + webUrl + \" for \"\n-                          + token.getService() + \" until: \" + new Date(result));\n+            } else if (renew) {\n+              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n+                if (token.isManaged()) {\n+                  long result \u003d token.renew(conf);\n+                  if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Renewed token for \" + token.getService()\n+                        + \" until: \" + new Date(result));\n                   }\n                 }\n-              } else if (cancel) {\n-                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n-                  cancelDelegationToken(webUrl,\n-                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n-                  if(LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Cancelled token via \" + webUrl + \" for \"\n-                \t    + token.getService());\n-                  }\n-                }\n-              } else {\n+              }\n+            } else {\n+              // otherwise we are fetching\n+              if (webUrl !\u003d null) {\n                 Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                 creds.writeTokenStorageFile(tokenFile, conf);\n                 for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                   if(LOG.isDebugEnabled()) {\t\n                     LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                         + token.getService() + \" into \" + tokenFile);\n                   }\n                 }\n-              }\n-            } else {\n-              FileSystem fs \u003d FileSystem.get(conf);\n-              if (cancel) {\n-                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n-                  ((DistributedFileSystem) fs)\n-                      .cancelDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n-                  if(LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Cancelled token for \"\n-                        + token.getService());\n-                  }\n-                }\n-              } else if (renew) {\n-                long result;\n-                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n-                  result \u003d ((DistributedFileSystem) fs)\n-                      .renewDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n-                  if(LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Renewed token for \" + token.getService()\n-                        + \" until: \" + new Date(result));\n-                  }\n-                }\n               } else {\n+                FileSystem fs \u003d FileSystem.get(conf);\n                 Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                 Credentials cred \u003d new Credentials();\n                 cred.addToken(token.getService(), token);\n                 cred.writeTokenStorageFile(tokenFile, conf);\n                 if(LOG.isDebugEnabled()) {\n                   LOG.debug(\"Fetched token for \" + token.getService()\n                       + \" into \" + tokenFile);\n                 }\n               }\n             }\n             return null;\n           }\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTPS url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exacltly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @SuppressWarnings(\"unchecked\")\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + \n                                   token.getService());\n              }\n            } else if (cancel) {\n              for(Token\u003c?\u003e token: readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  token.cancel(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token for \" + token.getService());\n                  }\n                }\n              }\n            } else if (renew) {\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                if (token.isManaged()) {\n                  long result \u003d token.renew(conf);\n                  if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Renewed token for \" + token.getService()\n                        + \" until: \" + new Date(result));\n                  }\n                }\n              }\n            } else {\n              // otherwise we are fetching\n              if (webUrl !\u003d null) {\n                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  if(LOG.isDebugEnabled()) {\t\n                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                        + token.getService() + \" into \" + tokenFile);\n                  }\n                }\n              } else {\n                FileSystem fs \u003d FileSystem.get(conf);\n                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                Credentials cred \u003d new Credentials();\n                cred.addToken(token.getService(), token);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                if(LOG.isDebugEnabled()) {\n                  LOG.debug(\"Fetched token for \" + token.getService()\n                      + \" into \" + tokenFile);\n                }\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "201b7879ba6994400c1aa955f242665c16c2c0ea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2373. Commands using webhdfs and hftp print unnecessary debug info on the console with security enabled. Contributed by Arpit Gupta.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1176654 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/09/11 4:16 PM",
      "commitName": "201b7879ba6994400c1aa955f242665c16c2c0ea",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 33.96,
      "commitsBetweenForRepo": 207,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,125 @@\n   public static void main(final String[] args) throws Exception {\n     final Configuration conf \u003d new HdfsConfiguration();\n     Options fetcherOptions \u003d new Options();\n     fetcherOptions.addOption(WEBSERVICE, true,\n         \"HTTPS url to reach the NameNode at\");\n     fetcherOptions.addOption(RENEWER, true,\n         \"Name of the delegation token renewer\");\n     fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n     fetcherOptions.addOption(RENEW, false, \"renew the token\");\n     fetcherOptions.addOption(PRINT, false, \"print the token\");\n     GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n         fetcherOptions, args);\n     CommandLine cmd \u003d parser.getCommandLine();\n     \n     // get options\n     final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n         .getOptionValue(WEBSERVICE) : null;\n     final String renewer \u003d cmd.hasOption(RENEWER) ? \n         cmd.getOptionValue(RENEWER) : null;\n     final boolean cancel \u003d cmd.hasOption(CANCEL);\n     final boolean renew \u003d cmd.hasOption(RENEW);\n     final boolean print \u003d cmd.hasOption(PRINT);\n     String[] remaining \u003d parser.getRemainingArgs();\n \n     // check option validity\n     if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n         \u0026\u0026 print) {\n       System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n       printUsage(System.err);\n     }\n     if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n       System.err.println(\"ERROR: Must specify exacltly one token file\");\n       printUsage(System.err);\n     }\n     // default to using the local file system\n     FileSystem local \u003d FileSystem.getLocal(conf);\n     final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n \n     // Login the current user\n     UserGroupInformation.getCurrentUser().doAs(\n         new PrivilegedExceptionAction\u003cObject\u003e() {\n           @SuppressWarnings(\"unchecked\")\n           @Override\n           public Object run() throws Exception {\n \n             if (print) {\n               DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                   0, 0, 0, 0, null).createIdentifier();\n               for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                 DataInputStream in \u003d new DataInputStream(\n                     new ByteArrayInputStream(token.getIdentifier()));\n                 id.readFields(in);\n-                System.out.println(\"Token (\" + id + \") for \" + token.getService());\n+                if(LOG.isDebugEnabled()) {\n+                  LOG.debug(\"Token (\" + id + \") for \" + token.getService());\n+                }\n               }\n               return null;\n             }\n             \n             if (webUrl !\u003d null) {\n               if (renew) {\n                 long result;\n                 for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                   result \u003d renewDelegationToken(webUrl,\n                       (Token\u003cDelegationTokenIdentifier\u003e) token);\n-                  System.out.println(\"Renewed token via \" + webUrl + \" for \"\n-                      + token.getService() + \" until: \" + new Date(result));\n+                  if(LOG.isDebugEnabled()) {\n+                \t  LOG.debug(\"Renewed token via \" + webUrl + \" for \"\n+                          + token.getService() + \" until: \" + new Date(result));\n+                  }\n                 }\n               } else if (cancel) {\n                 for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                   cancelDelegationToken(webUrl,\n                       (Token\u003cDelegationTokenIdentifier\u003e) token);\n-                  System.out.println(\"Cancelled token via \" + webUrl + \" for \"\n-                      + token.getService());\n+                  if(LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Cancelled token via \" + webUrl + \" for \"\n+                \t    + token.getService());\n+                  }\n                 }\n               } else {\n                 Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                 creds.writeTokenStorageFile(tokenFile, conf);\n                 for (Token\u003c?\u003e token : creds.getAllTokens()) {\n-                  System.out.println(\"Fetched token via \" + webUrl + \" for \"\n-                      + token.getService() + \" into \" + tokenFile);\n+                  if(LOG.isDebugEnabled()) {\t\n+                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n+                        + token.getService() + \" into \" + tokenFile);\n+                  }\n                 }\n               }\n             } else {\n               FileSystem fs \u003d FileSystem.get(conf);\n               if (cancel) {\n                 for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                   ((DistributedFileSystem) fs)\n                       .cancelDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n-                  System.out.println(\"Cancelled token for \"\n-                      + token.getService());\n+                  if(LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Cancelled token for \"\n+                        + token.getService());\n+                  }\n                 }\n               } else if (renew) {\n                 long result;\n                 for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                   result \u003d ((DistributedFileSystem) fs)\n                       .renewDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n-                  System.out.println(\"Renewed token for \" + token.getService()\n-                      + \" until: \" + new Date(result));\n+                  if(LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Renewed token for \" + token.getService()\n+                        + \" until: \" + new Date(result));\n+                  }\n                 }\n               } else {\n                 Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                 Credentials cred \u003d new Credentials();\n                 cred.addToken(token.getService(), token);\n                 cred.writeTokenStorageFile(tokenFile, conf);\n-                System.out.println(\"Fetched token for \" + token.getService()\n-                    + \" into \" + tokenFile);\n+                if(LOG.isDebugEnabled()) {\n+                  LOG.debug(\"Fetched token for \" + token.getService()\n+                      + \" into \" + tokenFile);\n+                }\n               }\n             }\n             return null;\n           }\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTPS url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exacltly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @SuppressWarnings(\"unchecked\")\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                if(LOG.isDebugEnabled()) {\n                  LOG.debug(\"Token (\" + id + \") for \" + token.getService());\n                }\n              }\n              return null;\n            }\n            \n            if (webUrl !\u003d null) {\n              if (renew) {\n                long result;\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  result \u003d renewDelegationToken(webUrl,\n                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n                  if(LOG.isDebugEnabled()) {\n                \t  LOG.debug(\"Renewed token via \" + webUrl + \" for \"\n                          + token.getService() + \" until: \" + new Date(result));\n                  }\n                }\n              } else if (cancel) {\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  cancelDelegationToken(webUrl,\n                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n                  if(LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token via \" + webUrl + \" for \"\n                \t    + token.getService());\n                  }\n                }\n              } else {\n                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  if(LOG.isDebugEnabled()) {\t\n                    LOG.debug(\"Fetched token via \" + webUrl + \" for \"\n                        + token.getService() + \" into \" + tokenFile);\n                  }\n                }\n              }\n            } else {\n              FileSystem fs \u003d FileSystem.get(conf);\n              if (cancel) {\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  ((DistributedFileSystem) fs)\n                      .cancelDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n                  if(LOG.isDebugEnabled()) {\n                    LOG.debug(\"Cancelled token for \"\n                        + token.getService());\n                  }\n                }\n              } else if (renew) {\n                long result;\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  result \u003d ((DistributedFileSystem) fs)\n                      .renewDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n                  if(LOG.isDebugEnabled()) {\n                    LOG.debug(\"Renewed token for \" + token.getService()\n                        + \" until: \" + new Date(result));\n                  }\n                }\n              } else {\n                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                Credentials cred \u003d new Credentials();\n                cred.addToken(token.getService(), token);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                if(LOG.isDebugEnabled()) {\n                  LOG.debug(\"Fetched token for \" + token.getService()\n                      + \" into \" + tokenFile);\n                }\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTPS url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exacltly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @SuppressWarnings(\"unchecked\")\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + token.getService());\n              }\n              return null;\n            }\n            \n            if (webUrl !\u003d null) {\n              if (renew) {\n                long result;\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  result \u003d renewDelegationToken(webUrl,\n                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Renewed token via \" + webUrl + \" for \"\n                      + token.getService() + \" until: \" + new Date(result));\n                }\n              } else if (cancel) {\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  cancelDelegationToken(webUrl,\n                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Cancelled token via \" + webUrl + \" for \"\n                      + token.getService());\n                }\n              } else {\n                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  System.out.println(\"Fetched token via \" + webUrl + \" for \"\n                      + token.getService() + \" into \" + tokenFile);\n                }\n              }\n            } else {\n              FileSystem fs \u003d FileSystem.get(conf);\n              if (cancel) {\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  ((DistributedFileSystem) fs)\n                      .cancelDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Cancelled token for \"\n                      + token.getService());\n                }\n              } else if (renew) {\n                long result;\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  result \u003d ((DistributedFileSystem) fs)\n                      .renewDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Renewed token for \" + token.getService()\n                      + \" until: \" + new Date(result));\n                }\n              } else {\n                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                Credentials cred \u003d new Credentials();\n                cred.addToken(token.getService(), token);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                System.out.println(\"Fetched token for \" + token.getService()\n                    + \" into \" + tokenFile);\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTPS url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exacltly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @SuppressWarnings(\"unchecked\")\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + token.getService());\n              }\n              return null;\n            }\n            \n            if (webUrl !\u003d null) {\n              if (renew) {\n                long result;\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  result \u003d renewDelegationToken(webUrl,\n                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Renewed token via \" + webUrl + \" for \"\n                      + token.getService() + \" until: \" + new Date(result));\n                }\n              } else if (cancel) {\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  cancelDelegationToken(webUrl,\n                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Cancelled token via \" + webUrl + \" for \"\n                      + token.getService());\n                }\n              } else {\n                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  System.out.println(\"Fetched token via \" + webUrl + \" for \"\n                      + token.getService() + \" into \" + tokenFile);\n                }\n              }\n            } else {\n              FileSystem fs \u003d FileSystem.get(conf);\n              if (cancel) {\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  ((DistributedFileSystem) fs)\n                      .cancelDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Cancelled token for \"\n                      + token.getService());\n                }\n              } else if (renew) {\n                long result;\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  result \u003d ((DistributedFileSystem) fs)\n                      .renewDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Renewed token for \" + token.getService()\n                      + \" until: \" + new Date(result));\n                }\n              } else {\n                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                Credentials cred \u003d new Credentials();\n                cred.addToken(token.getService(), token);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                System.out.println(\"Fetched token for \" + token.getService()\n                    + \" into \" + tokenFile);\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,111 @@\n+  public static void main(final String[] args) throws Exception {\n+    final Configuration conf \u003d new HdfsConfiguration();\n+    Options fetcherOptions \u003d new Options();\n+    fetcherOptions.addOption(WEBSERVICE, true,\n+        \"HTTPS url to reach the NameNode at\");\n+    fetcherOptions.addOption(RENEWER, true,\n+        \"Name of the delegation token renewer\");\n+    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n+    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n+    fetcherOptions.addOption(PRINT, false, \"print the token\");\n+    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n+        fetcherOptions, args);\n+    CommandLine cmd \u003d parser.getCommandLine();\n+    \n+    // get options\n+    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n+        .getOptionValue(WEBSERVICE) : null;\n+    final String renewer \u003d cmd.hasOption(RENEWER) ? \n+        cmd.getOptionValue(RENEWER) : null;\n+    final boolean cancel \u003d cmd.hasOption(CANCEL);\n+    final boolean renew \u003d cmd.hasOption(RENEW);\n+    final boolean print \u003d cmd.hasOption(PRINT);\n+    String[] remaining \u003d parser.getRemainingArgs();\n+\n+    // check option validity\n+    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n+        \u0026\u0026 print) {\n+      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n+      printUsage(System.err);\n+    }\n+    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n+      System.err.println(\"ERROR: Must specify exacltly one token file\");\n+      printUsage(System.err);\n+    }\n+    // default to using the local file system\n+    FileSystem local \u003d FileSystem.getLocal(conf);\n+    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n+\n+    // Login the current user\n+    UserGroupInformation.getCurrentUser().doAs(\n+        new PrivilegedExceptionAction\u003cObject\u003e() {\n+          @SuppressWarnings(\"unchecked\")\n+          @Override\n+          public Object run() throws Exception {\n+\n+            if (print) {\n+              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n+                  0, 0, 0, 0, null).createIdentifier();\n+              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n+                DataInputStream in \u003d new DataInputStream(\n+                    new ByteArrayInputStream(token.getIdentifier()));\n+                id.readFields(in);\n+                System.out.println(\"Token (\" + id + \") for \" + token.getService());\n+              }\n+              return null;\n+            }\n+            \n+            if (webUrl !\u003d null) {\n+              if (renew) {\n+                long result;\n+                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n+                  result \u003d renewDelegationToken(webUrl,\n+                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n+                  System.out.println(\"Renewed token via \" + webUrl + \" for \"\n+                      + token.getService() + \" until: \" + new Date(result));\n+                }\n+              } else if (cancel) {\n+                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n+                  cancelDelegationToken(webUrl,\n+                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n+                  System.out.println(\"Cancelled token via \" + webUrl + \" for \"\n+                      + token.getService());\n+                }\n+              } else {\n+                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n+                creds.writeTokenStorageFile(tokenFile, conf);\n+                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n+                  System.out.println(\"Fetched token via \" + webUrl + \" for \"\n+                      + token.getService() + \" into \" + tokenFile);\n+                }\n+              }\n+            } else {\n+              FileSystem fs \u003d FileSystem.get(conf);\n+              if (cancel) {\n+                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n+                  ((DistributedFileSystem) fs)\n+                      .cancelDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n+                  System.out.println(\"Cancelled token for \"\n+                      + token.getService());\n+                }\n+              } else if (renew) {\n+                long result;\n+                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n+                  result \u003d ((DistributedFileSystem) fs)\n+                      .renewDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n+                  System.out.println(\"Renewed token for \" + token.getService()\n+                      + \" until: \" + new Date(result));\n+                }\n+              } else {\n+                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n+                Credentials cred \u003d new Credentials();\n+                cred.addToken(token.getService(), token);\n+                cred.writeTokenStorageFile(tokenFile, conf);\n+                System.out.println(\"Fetched token for \" + token.getService()\n+                    + \" into \" + tokenFile);\n+              }\n+            }\n+            return null;\n+          }\n+        });\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(final String[] args) throws Exception {\n    final Configuration conf \u003d new HdfsConfiguration();\n    Options fetcherOptions \u003d new Options();\n    fetcherOptions.addOption(WEBSERVICE, true,\n        \"HTTPS url to reach the NameNode at\");\n    fetcherOptions.addOption(RENEWER, true,\n        \"Name of the delegation token renewer\");\n    fetcherOptions.addOption(CANCEL, false, \"cancel the token\");\n    fetcherOptions.addOption(RENEW, false, \"renew the token\");\n    fetcherOptions.addOption(PRINT, false, \"print the token\");\n    GenericOptionsParser parser \u003d new GenericOptionsParser(conf,\n        fetcherOptions, args);\n    CommandLine cmd \u003d parser.getCommandLine();\n    \n    // get options\n    final String webUrl \u003d cmd.hasOption(WEBSERVICE) ? cmd\n        .getOptionValue(WEBSERVICE) : null;\n    final String renewer \u003d cmd.hasOption(RENEWER) ? \n        cmd.getOptionValue(RENEWER) : null;\n    final boolean cancel \u003d cmd.hasOption(CANCEL);\n    final boolean renew \u003d cmd.hasOption(RENEW);\n    final boolean print \u003d cmd.hasOption(PRINT);\n    String[] remaining \u003d parser.getRemainingArgs();\n\n    // check option validity\n    if (cancel \u0026\u0026 renew || cancel \u0026\u0026 print || renew \u0026\u0026 print || cancel \u0026\u0026 renew\n        \u0026\u0026 print) {\n      System.err.println(\"ERROR: Only specify cancel, renew or print.\");\n      printUsage(System.err);\n    }\n    if (remaining.length !\u003d 1 || remaining[0].charAt(0) \u003d\u003d \u0027-\u0027) {\n      System.err.println(\"ERROR: Must specify exacltly one token file\");\n      printUsage(System.err);\n    }\n    // default to using the local file system\n    FileSystem local \u003d FileSystem.getLocal(conf);\n    final Path tokenFile \u003d new Path(local.getWorkingDirectory(), remaining[0]);\n\n    // Login the current user\n    UserGroupInformation.getCurrentUser().doAs(\n        new PrivilegedExceptionAction\u003cObject\u003e() {\n          @SuppressWarnings(\"unchecked\")\n          @Override\n          public Object run() throws Exception {\n\n            if (print) {\n              DelegationTokenIdentifier id \u003d new DelegationTokenSecretManager(\n                  0, 0, 0, 0, null).createIdentifier();\n              for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                DataInputStream in \u003d new DataInputStream(\n                    new ByteArrayInputStream(token.getIdentifier()));\n                id.readFields(in);\n                System.out.println(\"Token (\" + id + \") for \" + token.getService());\n              }\n              return null;\n            }\n            \n            if (webUrl !\u003d null) {\n              if (renew) {\n                long result;\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  result \u003d renewDelegationToken(webUrl,\n                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Renewed token via \" + webUrl + \" for \"\n                      + token.getService() + \" until: \" + new Date(result));\n                }\n              } else if (cancel) {\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  cancelDelegationToken(webUrl,\n                      (Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Cancelled token via \" + webUrl + \" for \"\n                      + token.getService());\n                }\n              } else {\n                Credentials creds \u003d getDTfromRemote(webUrl, renewer);\n                creds.writeTokenStorageFile(tokenFile, conf);\n                for (Token\u003c?\u003e token : creds.getAllTokens()) {\n                  System.out.println(\"Fetched token via \" + webUrl + \" for \"\n                      + token.getService() + \" into \" + tokenFile);\n                }\n              }\n            } else {\n              FileSystem fs \u003d FileSystem.get(conf);\n              if (cancel) {\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  ((DistributedFileSystem) fs)\n                      .cancelDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Cancelled token for \"\n                      + token.getService());\n                }\n              } else if (renew) {\n                long result;\n                for (Token\u003c?\u003e token : readTokens(tokenFile, conf)) {\n                  result \u003d ((DistributedFileSystem) fs)\n                      .renewDelegationToken((Token\u003cDelegationTokenIdentifier\u003e) token);\n                  System.out.println(\"Renewed token for \" + token.getService()\n                      + \" until: \" + new Date(result));\n                }\n              } else {\n                Token\u003c?\u003e token \u003d fs.getDelegationToken(renewer);\n                Credentials cred \u003d new Credentials();\n                cred.addToken(token.getService(), token);\n                cred.writeTokenStorageFile(tokenFile, conf);\n                System.out.println(\"Fetched token for \" + token.getService()\n                    + \" into \" + tokenFile);\n              }\n            }\n            return null;\n          }\n        });\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java"
    }
  }
}