{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSPreemptionThread.java",
  "functionName": "identifyContainersToPreemptOnNode",
  "functionId": "identifyContainersToPreemptOnNode___request-Resource__node-FSSchedulerNode__maxAMContainers-int",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSPreemptionThread.java",
  "functionStartLine": 178,
  "functionEndLine": 224,
  "numCommitsSeen": 14,
  "timeTaken": 2672,
  "changeHistory": [
    "215f2052fc3b7e366e8bd1bd332663966fa9206c",
    "2bde3aedf139368fc71f053d8dd6580b498ff46d",
    "9902be72cbf7a170caa5cb1f13c227d881a39064",
    "c3375175d616e0380560f89d491b6b9753a8f3e1",
    "abedb8a9d86b4593a37fd3d2313fbcb057c7846a"
  ],
  "changeHistoryShort": {
    "215f2052fc3b7e366e8bd1bd332663966fa9206c": "Ybodychange",
    "2bde3aedf139368fc71f053d8dd6580b498ff46d": "Ybodychange",
    "9902be72cbf7a170caa5cb1f13c227d881a39064": "Ybodychange",
    "c3375175d616e0380560f89d491b6b9753a8f3e1": "Ybodychange",
    "abedb8a9d86b4593a37fd3d2313fbcb057c7846a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "215f2052fc3b7e366e8bd1bd332663966fa9206c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9984. FSPreemptionThread can cause NullPointerException while app is unregistered with containers running on a node. Contributed by Wilfred Spiegelenburg.\n",
      "commitDate": "19/11/19 12:33 AM",
      "commitName": "215f2052fc3b7e366e8bd1bd332663966fa9206c",
      "commitAuthor": "Sunil G",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 259.14,
      "commitsBetweenForRepo": 1864,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,47 @@\n   private PreemptableContainers identifyContainersToPreemptOnNode(\n       Resource request, FSSchedulerNode node, int maxAMContainers) {\n     PreemptableContainers preemptableContainers \u003d\n         new PreemptableContainers(maxAMContainers);\n \n     // Figure out list of containers to consider\n     List\u003cRMContainer\u003e containersToCheck \u003d\n         node.getRunningContainersWithAMsAtTheEnd();\n     containersToCheck.removeAll(node.getContainersForPreemption());\n \n     // Initialize potential with unallocated but not reserved resources\n     Resource potential \u003d Resources.subtractFromNonNegative(\n         Resources.clone(node.getUnallocatedResource()),\n         node.getTotalReserved());\n \n     for (RMContainer container : containersToCheck) {\n       FSAppAttempt app \u003d\n           scheduler.getSchedulerApp(container.getApplicationAttemptId());\n+      // If the app has unregistered while building the container list the app\n+      // might be null, just skip this container: it should be cleaned up soon\n+      if (app \u003d\u003d null) {\n+        LOG.info(\"Found container \" + container + \" on node \"\n+            + node.getNodeName() + \"without app, skipping preemption\");\n+        continue;\n+      }\n       ApplicationId appId \u003d app.getApplicationId();\n \n       if (app.canContainerBePreempted(container,\n               preemptableContainers.getResourcesToPreemptForApp(appId))) {\n         // Flag container for preemption\n         if (!preemptableContainers.addContainer(container, appId)) {\n           return null;\n         }\n \n         Resources.addTo(potential, container.getAllocatedResource());\n       }\n \n       // Check if we have already identified enough containers\n       if (Resources.fitsIn(request, potential)) {\n         return preemptableContainers;\n       }\n     }\n \n     // Return null if the sum of all preemptable containers\u0027 resources\n     // isn\u0027t enough to satisfy the starved request.\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private PreemptableContainers identifyContainersToPreemptOnNode(\n      Resource request, FSSchedulerNode node, int maxAMContainers) {\n    PreemptableContainers preemptableContainers \u003d\n        new PreemptableContainers(maxAMContainers);\n\n    // Figure out list of containers to consider\n    List\u003cRMContainer\u003e containersToCheck \u003d\n        node.getRunningContainersWithAMsAtTheEnd();\n    containersToCheck.removeAll(node.getContainersForPreemption());\n\n    // Initialize potential with unallocated but not reserved resources\n    Resource potential \u003d Resources.subtractFromNonNegative(\n        Resources.clone(node.getUnallocatedResource()),\n        node.getTotalReserved());\n\n    for (RMContainer container : containersToCheck) {\n      FSAppAttempt app \u003d\n          scheduler.getSchedulerApp(container.getApplicationAttemptId());\n      // If the app has unregistered while building the container list the app\n      // might be null, just skip this container: it should be cleaned up soon\n      if (app \u003d\u003d null) {\n        LOG.info(\"Found container \" + container + \" on node \"\n            + node.getNodeName() + \"without app, skipping preemption\");\n        continue;\n      }\n      ApplicationId appId \u003d app.getApplicationId();\n\n      if (app.canContainerBePreempted(container,\n              preemptableContainers.getResourcesToPreemptForApp(appId))) {\n        // Flag container for preemption\n        if (!preemptableContainers.addContainer(container, appId)) {\n          return null;\n        }\n\n        Resources.addTo(potential, container.getAllocatedResource());\n      }\n\n      // Check if we have already identified enough containers\n      if (Resources.fitsIn(request, potential)) {\n        return preemptableContainers;\n      }\n    }\n\n    // Return null if the sum of all preemptable containers\u0027 resources\n    // isn\u0027t enough to satisfy the starved request.\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSPreemptionThread.java",
      "extendedDetails": {}
    },
    "2bde3aedf139368fc71f053d8dd6580b498ff46d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7290. Method canContainerBePreempted can return true when it shouldn\u0027t. (Contributed by Steven Rand)\n",
      "commitDate": "24/11/17 11:32 PM",
      "commitName": "2bde3aedf139368fc71f053d8dd6580b498ff46d",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "27/07/17 11:19 PM",
      "commitNameOld": "9902be72cbf7a170caa5cb1f13c227d881a39064",
      "commitAuthorOld": "Yufei Gu",
      "daysBetweenCommits": 120.05,
      "commitsBetweenForRepo": 1058,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,40 @@\n   private PreemptableContainers identifyContainersToPreemptOnNode(\n       Resource request, FSSchedulerNode node, int maxAMContainers) {\n     PreemptableContainers preemptableContainers \u003d\n         new PreemptableContainers(maxAMContainers);\n \n     // Figure out list of containers to consider\n     List\u003cRMContainer\u003e containersToCheck \u003d\n         node.getRunningContainersWithAMsAtTheEnd();\n     containersToCheck.removeAll(node.getContainersForPreemption());\n \n     // Initialize potential with unallocated but not reserved resources\n     Resource potential \u003d Resources.subtractFromNonNegative(\n         Resources.clone(node.getUnallocatedResource()),\n         node.getTotalReserved());\n \n     for (RMContainer container : containersToCheck) {\n       FSAppAttempt app \u003d\n           scheduler.getSchedulerApp(container.getApplicationAttemptId());\n+      ApplicationId appId \u003d app.getApplicationId();\n \n-      if (app.canContainerBePreempted(container)) {\n+      if (app.canContainerBePreempted(container,\n+              preemptableContainers.getResourcesToPreemptForApp(appId))) {\n         // Flag container for preemption\n-        if (!preemptableContainers.addContainer(container)) {\n+        if (!preemptableContainers.addContainer(container, appId)) {\n           return null;\n         }\n \n         Resources.addTo(potential, container.getAllocatedResource());\n       }\n \n       // Check if we have already identified enough containers\n       if (Resources.fitsIn(request, potential)) {\n         return preemptableContainers;\n       }\n     }\n \n     // Return null if the sum of all preemptable containers\u0027 resources\n     // isn\u0027t enough to satisfy the starved request.\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private PreemptableContainers identifyContainersToPreemptOnNode(\n      Resource request, FSSchedulerNode node, int maxAMContainers) {\n    PreemptableContainers preemptableContainers \u003d\n        new PreemptableContainers(maxAMContainers);\n\n    // Figure out list of containers to consider\n    List\u003cRMContainer\u003e containersToCheck \u003d\n        node.getRunningContainersWithAMsAtTheEnd();\n    containersToCheck.removeAll(node.getContainersForPreemption());\n\n    // Initialize potential with unallocated but not reserved resources\n    Resource potential \u003d Resources.subtractFromNonNegative(\n        Resources.clone(node.getUnallocatedResource()),\n        node.getTotalReserved());\n\n    for (RMContainer container : containersToCheck) {\n      FSAppAttempt app \u003d\n          scheduler.getSchedulerApp(container.getApplicationAttemptId());\n      ApplicationId appId \u003d app.getApplicationId();\n\n      if (app.canContainerBePreempted(container,\n              preemptableContainers.getResourcesToPreemptForApp(appId))) {\n        // Flag container for preemption\n        if (!preemptableContainers.addContainer(container, appId)) {\n          return null;\n        }\n\n        Resources.addTo(potential, container.getAllocatedResource());\n      }\n\n      // Check if we have already identified enough containers\n      if (Resources.fitsIn(request, potential)) {\n        return preemptableContainers;\n      }\n    }\n\n    // Return null if the sum of all preemptable containers\u0027 resources\n    // isn\u0027t enough to satisfy the starved request.\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSPreemptionThread.java",
      "extendedDetails": {}
    },
    "9902be72cbf7a170caa5cb1f13c227d881a39064": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6864. FSPreemptionThread cleanup for readability. (Daniel Templeton via Yufei Gu)\n",
      "commitDate": "27/07/17 11:19 PM",
      "commitName": "9902be72cbf7a170caa5cb1f13c227d881a39064",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "12/04/17 2:21 PM",
      "commitNameOld": "c3375175d616e0380560f89d491b6b9753a8f3e1",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 106.37,
      "commitsBetweenForRepo": 519,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,38 @@\n   private PreemptableContainers identifyContainersToPreemptOnNode(\n       Resource request, FSSchedulerNode node, int maxAMContainers) {\n     PreemptableContainers preemptableContainers \u003d\n         new PreemptableContainers(maxAMContainers);\n \n     // Figure out list of containers to consider\n     List\u003cRMContainer\u003e containersToCheck \u003d\n         node.getRunningContainersWithAMsAtTheEnd();\n     containersToCheck.removeAll(node.getContainersForPreemption());\n \n     // Initialize potential with unallocated but not reserved resources\n     Resource potential \u003d Resources.subtractFromNonNegative(\n         Resources.clone(node.getUnallocatedResource()),\n         node.getTotalReserved());\n \n     for (RMContainer container : containersToCheck) {\n       FSAppAttempt app \u003d\n           scheduler.getSchedulerApp(container.getApplicationAttemptId());\n \n       if (app.canContainerBePreempted(container)) {\n         // Flag container for preemption\n         if (!preemptableContainers.addContainer(container)) {\n           return null;\n         }\n \n         Resources.addTo(potential, container.getAllocatedResource());\n       }\n \n       // Check if we have already identified enough containers\n       if (Resources.fitsIn(request, potential)) {\n         return preemptableContainers;\n       }\n     }\n+\n+    // Return null if the sum of all preemptable containers\u0027 resources\n+    // isn\u0027t enough to satisfy the starved request.\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private PreemptableContainers identifyContainersToPreemptOnNode(\n      Resource request, FSSchedulerNode node, int maxAMContainers) {\n    PreemptableContainers preemptableContainers \u003d\n        new PreemptableContainers(maxAMContainers);\n\n    // Figure out list of containers to consider\n    List\u003cRMContainer\u003e containersToCheck \u003d\n        node.getRunningContainersWithAMsAtTheEnd();\n    containersToCheck.removeAll(node.getContainersForPreemption());\n\n    // Initialize potential with unallocated but not reserved resources\n    Resource potential \u003d Resources.subtractFromNonNegative(\n        Resources.clone(node.getUnallocatedResource()),\n        node.getTotalReserved());\n\n    for (RMContainer container : containersToCheck) {\n      FSAppAttempt app \u003d\n          scheduler.getSchedulerApp(container.getApplicationAttemptId());\n\n      if (app.canContainerBePreempted(container)) {\n        // Flag container for preemption\n        if (!preemptableContainers.addContainer(container)) {\n          return null;\n        }\n\n        Resources.addTo(potential, container.getAllocatedResource());\n      }\n\n      // Check if we have already identified enough containers\n      if (Resources.fitsIn(request, potential)) {\n        return preemptableContainers;\n      }\n    }\n\n    // Return null if the sum of all preemptable containers\u0027 resources\n    // isn\u0027t enough to satisfy the starved request.\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSPreemptionThread.java",
      "extendedDetails": {}
    },
    "c3375175d616e0380560f89d491b6b9753a8f3e1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6432. FairScheduler: Reserve preempted resources for corresponding applications. (Miklos Szegedi via kasha)\n",
      "commitDate": "12/04/17 2:21 PM",
      "commitName": "c3375175d616e0380560f89d491b6b9753a8f3e1",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "26/02/17 8:16 PM",
      "commitNameOld": "815d53506fb0c5ca029c993d6b094db2ac0ca6eb",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 44.71,
      "commitsBetweenForRepo": 287,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private PreemptableContainers identifyContainersToPreemptOnNode(\n       Resource request, FSSchedulerNode node, int maxAMContainers) {\n     PreemptableContainers preemptableContainers \u003d\n         new PreemptableContainers(maxAMContainers);\n \n     // Figure out list of containers to consider\n     List\u003cRMContainer\u003e containersToCheck \u003d\n         node.getRunningContainersWithAMsAtTheEnd();\n     containersToCheck.removeAll(node.getContainersForPreemption());\n \n-    // Initialize potential with unallocated resources\n-    Resource potential \u003d Resources.clone(node.getUnallocatedResource());\n+    // Initialize potential with unallocated but not reserved resources\n+    Resource potential \u003d Resources.subtractFromNonNegative(\n+        Resources.clone(node.getUnallocatedResource()),\n+        node.getTotalReserved());\n \n     for (RMContainer container : containersToCheck) {\n       FSAppAttempt app \u003d\n           scheduler.getSchedulerApp(container.getApplicationAttemptId());\n \n       if (app.canContainerBePreempted(container)) {\n         // Flag container for preemption\n         if (!preemptableContainers.addContainer(container)) {\n           return null;\n         }\n \n         Resources.addTo(potential, container.getAllocatedResource());\n       }\n \n       // Check if we have already identified enough containers\n       if (Resources.fitsIn(request, potential)) {\n         return preemptableContainers;\n-      } else {\n-        // TODO (YARN-5829): Unreserve the node for the starved app.\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private PreemptableContainers identifyContainersToPreemptOnNode(\n      Resource request, FSSchedulerNode node, int maxAMContainers) {\n    PreemptableContainers preemptableContainers \u003d\n        new PreemptableContainers(maxAMContainers);\n\n    // Figure out list of containers to consider\n    List\u003cRMContainer\u003e containersToCheck \u003d\n        node.getRunningContainersWithAMsAtTheEnd();\n    containersToCheck.removeAll(node.getContainersForPreemption());\n\n    // Initialize potential with unallocated but not reserved resources\n    Resource potential \u003d Resources.subtractFromNonNegative(\n        Resources.clone(node.getUnallocatedResource()),\n        node.getTotalReserved());\n\n    for (RMContainer container : containersToCheck) {\n      FSAppAttempt app \u003d\n          scheduler.getSchedulerApp(container.getApplicationAttemptId());\n\n      if (app.canContainerBePreempted(container)) {\n        // Flag container for preemption\n        if (!preemptableContainers.addContainer(container)) {\n          return null;\n        }\n\n        Resources.addTo(potential, container.getAllocatedResource());\n      }\n\n      // Check if we have already identified enough containers\n      if (Resources.fitsIn(request, potential)) {\n        return preemptableContainers;\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSPreemptionThread.java",
      "extendedDetails": {}
    },
    "abedb8a9d86b4593a37fd3d2313fbcb057c7846a": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5830. FairScheduler: Avoid preempting AM containers. (Yufei Gu via kasha)\n",
      "commitDate": "25/01/17 12:17 PM",
      "commitName": "abedb8a9d86b4593a37fd3d2313fbcb057c7846a",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,35 @@\n+  private PreemptableContainers identifyContainersToPreemptOnNode(\n+      Resource request, FSSchedulerNode node, int maxAMContainers) {\n+    PreemptableContainers preemptableContainers \u003d\n+        new PreemptableContainers(maxAMContainers);\n+\n+    // Figure out list of containers to consider\n+    List\u003cRMContainer\u003e containersToCheck \u003d\n+        node.getRunningContainersWithAMsAtTheEnd();\n+    containersToCheck.removeAll(node.getContainersForPreemption());\n+\n+    // Initialize potential with unallocated resources\n+    Resource potential \u003d Resources.clone(node.getUnallocatedResource());\n+\n+    for (RMContainer container : containersToCheck) {\n+      FSAppAttempt app \u003d\n+          scheduler.getSchedulerApp(container.getApplicationAttemptId());\n+\n+      if (app.canContainerBePreempted(container)) {\n+        // Flag container for preemption\n+        if (!preemptableContainers.addContainer(container)) {\n+          return null;\n+        }\n+\n+        Resources.addTo(potential, container.getAllocatedResource());\n+      }\n+\n+      // Check if we have already identified enough containers\n+      if (Resources.fitsIn(request, potential)) {\n+        return preemptableContainers;\n+      } else {\n+        // TODO (YARN-5829): Unreserve the node for the starved app.\n+      }\n+    }\n+    return null;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private PreemptableContainers identifyContainersToPreemptOnNode(\n      Resource request, FSSchedulerNode node, int maxAMContainers) {\n    PreemptableContainers preemptableContainers \u003d\n        new PreemptableContainers(maxAMContainers);\n\n    // Figure out list of containers to consider\n    List\u003cRMContainer\u003e containersToCheck \u003d\n        node.getRunningContainersWithAMsAtTheEnd();\n    containersToCheck.removeAll(node.getContainersForPreemption());\n\n    // Initialize potential with unallocated resources\n    Resource potential \u003d Resources.clone(node.getUnallocatedResource());\n\n    for (RMContainer container : containersToCheck) {\n      FSAppAttempt app \u003d\n          scheduler.getSchedulerApp(container.getApplicationAttemptId());\n\n      if (app.canContainerBePreempted(container)) {\n        // Flag container for preemption\n        if (!preemptableContainers.addContainer(container)) {\n          return null;\n        }\n\n        Resources.addTo(potential, container.getAllocatedResource());\n      }\n\n      // Check if we have already identified enough containers\n      if (Resources.fitsIn(request, potential)) {\n        return preemptableContainers;\n      } else {\n        // TODO (YARN-5829): Unreserve the node for the starved app.\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSPreemptionThread.java"
    }
  }
}