{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSPermissionChecker.java",
  "functionName": "checkPermission",
  "functionId": "checkPermission___fsOwner-String__supergroup-String__callerUgi-UserGroupInformation__inodeAttrs-INodeAttributes[]__inodes-INode[]__components-byte[][]__snapshotId-int__path-String__ancestorIndex-int__doCheckOwner-boolean__ancestorAccess-FsAction__parentAccess-FsAction__access-FsAction__subAccess-FsAction__ignoreEmptyDir-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
  "functionStartLine": 312,
  "functionEndLine": 352,
  "numCommitsSeen": 117,
  "timeTaken": 4998,
  "changeHistory": [
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
    "5ea6fd85c7aff6df28b87789f607bb57ee920639",
    "2ff6faf954eb0f1ab2b339d589edb30040087669",
    "970daaa5e44d3c09afd46d1c8e923a5096708c44",
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
    "6a52febfbd97f3b54318e07d4918cea2a9292f53"
  ],
  "changeHistoryShort": {
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": "Ybodychange",
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068": "Ymultichange(Yparameterchange,Ybodychange)",
    "5ea6fd85c7aff6df28b87789f607bb57ee920639": "Ybodychange",
    "2ff6faf954eb0f1ab2b339d589edb30040087669": "Ybodychange",
    "970daaa5e44d3c09afd46d1c8e923a5096708c44": "Ybodychange",
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
    "6a52febfbd97f3b54318e07d4918cea2a9292f53": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
      "commitDate": "24/10/16 3:14 PM",
      "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "19/08/16 7:12 AM",
      "commitNameOld": "2550371f66c49fe0e40aadaa68744311270084ce",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 66.34,
      "commitsBetweenForRepo": 421,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,41 @@\n   public void checkPermission(String fsOwner, String supergroup,\n       UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n       INode[] inodes, byte[][] components, int snapshotId, String path,\n       int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n       FsAction parentAccess, FsAction access, FsAction subAccess,\n       boolean ignoreEmptyDir)\n       throws AccessControlException {\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n \n-    checkTraverse(inodeAttrs, ancestorIndex);\n+    try {\n+      checkTraverse(inodeAttrs, inodes, components, ancestorIndex);\n+    } catch (UnresolvedPathException | ParentNotDirectoryException ex) {\n+      // must tunnel these exceptions out to avoid breaking interface for\n+      // external enforcer\n+      throw new TraverseAccessControlException(ex);\n+    }\n \n     final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodeAttrs, inodeAttrs.length - 2);\n+      checkStickyBit(inodeAttrs, components, inodeAttrs.length - 2);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, ancestorIndex, ancestorAccess);\n+      check(inodeAttrs, components, ancestorIndex, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, inodeAttrs.length - 2, parentAccess);\n+      check(inodeAttrs, components, inodeAttrs.length - 2, parentAccess);\n     }\n     if (access !\u003d null) {\n-      check(inodeAttrs, inodeAttrs.length - 1, access);\n+      check(inodeAttrs, components, inodeAttrs.length - 1, access);\n     }\n     if (subAccess !\u003d null) {\n       INode rawLast \u003d inodes[inodeAttrs.length - 1];\n       checkSubAccess(components, inodeAttrs.length - 1, rawLast,\n           snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n-      checkOwner(inodeAttrs, inodeAttrs.length - 1);\n+      checkOwner(inodeAttrs, components, inodeAttrs.length - 1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] components, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n\n    try {\n      checkTraverse(inodeAttrs, inodes, components, ancestorIndex);\n    } catch (UnresolvedPathException | ParentNotDirectoryException ex) {\n      // must tunnel these exceptions out to avoid breaking interface for\n      // external enforcer\n      throw new TraverseAccessControlException(ex);\n    }\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs, components, inodeAttrs.length - 2);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, components, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, components, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(inodeAttrs, components, inodeAttrs.length - 1, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(components, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(inodeAttrs, components, inodeAttrs.length - 1);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
      "commitDate": "04/08/16 2:14 PM",
      "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
          "commitDate": "04/08/16 2:14 PM",
          "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "27/05/16 10:02 AM",
          "commitNameOld": "5ea6fd85c7aff6df28b87789f607bb57ee920639",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 69.18,
          "commitsBetweenForRepo": 580,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,35 @@\n   public void checkPermission(String fsOwner, String supergroup,\n       UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n-      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n+      INode[] inodes, byte[][] components, int snapshotId, String path,\n       int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n       FsAction parentAccess, FsAction access, FsAction subAccess,\n       boolean ignoreEmptyDir)\n       throws AccessControlException {\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n \n-    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n+    checkTraverse(inodeAttrs, ancestorIndex);\n \n     final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n+      checkStickyBit(inodeAttrs, inodeAttrs.length - 2);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n+      check(inodeAttrs, ancestorIndex, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n+      check(inodeAttrs, inodeAttrs.length - 2, parentAccess);\n     }\n     if (access !\u003d null) {\n-      check(last, path, access);\n+      check(inodeAttrs, inodeAttrs.length - 1, access);\n     }\n     if (subAccess !\u003d null) {\n       INode rawLast \u003d inodes[inodeAttrs.length - 1];\n-      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n+      checkSubAccess(components, inodeAttrs.length - 1, rawLast,\n           snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n-      checkOwner(last);\n+      checkOwner(inodeAttrs, inodeAttrs.length - 1);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] components, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n\n    checkTraverse(inodeAttrs, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs, inodeAttrs.length - 2);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(inodeAttrs, inodeAttrs.length - 1, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(components, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(inodeAttrs, inodeAttrs.length - 1);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[fsOwner-String, supergroup-String, callerUgi-UserGroupInformation, inodeAttrs-INodeAttributes[], inodes-INode[], pathByNameArr-byte[][], snapshotId-int, path-String, ancestorIndex-int, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, ignoreEmptyDir-boolean]",
            "newValue": "[fsOwner-String, supergroup-String, callerUgi-UserGroupInformation, inodeAttrs-INodeAttributes[], inodes-INode[], components-byte[][], snapshotId-int, path-String, ancestorIndex-int, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, ignoreEmptyDir-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
          "commitDate": "04/08/16 2:14 PM",
          "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "27/05/16 10:02 AM",
          "commitNameOld": "5ea6fd85c7aff6df28b87789f607bb57ee920639",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 69.18,
          "commitsBetweenForRepo": 580,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,35 @@\n   public void checkPermission(String fsOwner, String supergroup,\n       UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n-      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n+      INode[] inodes, byte[][] components, int snapshotId, String path,\n       int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n       FsAction parentAccess, FsAction access, FsAction subAccess,\n       boolean ignoreEmptyDir)\n       throws AccessControlException {\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n \n-    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n+    checkTraverse(inodeAttrs, ancestorIndex);\n \n     final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n+      checkStickyBit(inodeAttrs, inodeAttrs.length - 2);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n+      check(inodeAttrs, ancestorIndex, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n-      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n+      check(inodeAttrs, inodeAttrs.length - 2, parentAccess);\n     }\n     if (access !\u003d null) {\n-      check(last, path, access);\n+      check(inodeAttrs, inodeAttrs.length - 1, access);\n     }\n     if (subAccess !\u003d null) {\n       INode rawLast \u003d inodes[inodeAttrs.length - 1];\n-      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n+      checkSubAccess(components, inodeAttrs.length - 1, rawLast,\n           snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n-      checkOwner(last);\n+      checkOwner(inodeAttrs, inodeAttrs.length - 1);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] components, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n\n    checkTraverse(inodeAttrs, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs, inodeAttrs.length - 2);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(inodeAttrs, inodeAttrs.length - 1, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(components, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(inodeAttrs, inodeAttrs.length - 1);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {}
        }
      ]
    },
    "5ea6fd85c7aff6df28b87789f607bb57ee920639": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10276. HDFS should not expose path info that user has no permission to see. (Yuanbo Liu via Yongjun Zhang)\n",
      "commitDate": "27/05/16 10:02 AM",
      "commitName": "5ea6fd85c7aff6df28b87789f607bb57ee920639",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "18/09/15 7:17 AM",
      "commitNameOld": "2ff6faf954eb0f1ab2b339d589edb30040087669",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 252.11,
      "commitsBetweenForRepo": 1699,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,35 @@\n   public void checkPermission(String fsOwner, String supergroup,\n       UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n       INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n       int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n       FsAction parentAccess, FsAction access, FsAction subAccess,\n       boolean ignoreEmptyDir)\n       throws AccessControlException {\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n-    try {\n-      checkTraverse(inodeAttrs, path, ancestorIndex);\n-    } catch (AccessControlException e) {\n-      checkAncestorType(inodes, ancestorIndex, e);\n-    }\n+\n+    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n \n     final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n       checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, path, access);\n     }\n     if (subAccess !\u003d null) {\n       INode rawLast \u003d inodes[inodeAttrs.length - 1];\n       checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n           snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n\n    checkTraverse(inodeAttrs, inodes, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "2ff6faf954eb0f1ab2b339d589edb30040087669": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5802. NameNode does not check for inode type before traversing down a path. (Xiao Chen via Yongjun Zhang)\n",
      "commitDate": "18/09/15 7:17 AM",
      "commitName": "2ff6faf954eb0f1ab2b339d589edb30040087669",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "08/09/15 9:57 AM",
      "commitNameOld": "970daaa5e44d3c09afd46d1c8e923a5096708c44",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 9.89,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,38 @@\n   public void checkPermission(String fsOwner, String supergroup,\n       UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n       INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n       int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n       FsAction parentAccess, FsAction access, FsAction subAccess,\n       boolean ignoreEmptyDir)\n       throws AccessControlException {\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n-    checkTraverse(inodeAttrs, path, ancestorIndex);\n+    try {\n+      checkTraverse(inodeAttrs, path, ancestorIndex);\n+    } catch (AccessControlException e) {\n+      checkAncestorType(inodes, ancestorIndex, e);\n+    }\n \n     final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n       checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, path, access);\n     }\n     if (subAccess !\u003d null) {\n       INode rawLast \u003d inodes[inodeAttrs.length - 1];\n       checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n           snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    try {\n      checkTraverse(inodeAttrs, path, ancestorIndex);\n    } catch (AccessControlException e) {\n      checkAncestorType(inodes, ancestorIndex, e);\n    }\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "970daaa5e44d3c09afd46d1c8e923a5096708c44": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9019. Adding informative message to sticky bit permission denied exception. Contributed by Xiaoyu Yao.\n",
      "commitDate": "08/09/15 9:57 AM",
      "commitName": "970daaa5e44d3c09afd46d1c8e923a5096708c44",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "24/03/15 4:02 PM",
      "commitNameOld": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
      "commitAuthorOld": "Jitendra Pandey",
      "daysBetweenCommits": 167.75,
      "commitsBetweenForRepo": 1241,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   public void checkPermission(String fsOwner, String supergroup,\n       UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n       INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n       int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n       FsAction parentAccess, FsAction access, FsAction subAccess,\n       boolean ignoreEmptyDir)\n       throws AccessControlException {\n     for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n         ancestorIndex--);\n     checkTraverse(inodeAttrs, path, ancestorIndex);\n \n     final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n     if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n         \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n-      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n+      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n     }\n     if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n     if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n       check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n     if (access !\u003d null) {\n       check(last, path, access);\n     }\n     if (subAccess !\u003d null) {\n       INode rawLast \u003d inodes[inodeAttrs.length - 1];\n       checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n           snapshotId, subAccess, ignoreEmptyDir);\n     }\n     if (doCheckOwner) {\n       checkOwner(last);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodeAttrs, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last, path);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
      "commitDate": "24/03/15 4:02 PM",
      "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
      "commitAuthor": "Jitendra Pandey",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
          "commitDate": "24/03/15 4:02 PM",
          "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "09/12/14 6:57 PM",
          "commitNameOld": "d93f3b9815f90d24c838574a56013e6dc60dc5ad",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 104.84,
          "commitsBetweenForRepo": 828,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,34 @@\n-  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n-      FsPermission mode) throws AccessControlException {\n-    if (user.equals(inode.getUserName(snapshotId))) { //user class\n-      if (mode.getUserAction().implies(access)) { return; }\n+  public void checkPermission(String fsOwner, String supergroup,\n+      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n+      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n+      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n+      FsAction parentAccess, FsAction access, FsAction subAccess,\n+      boolean ignoreEmptyDir)\n+      throws AccessControlException {\n+    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n+        ancestorIndex--);\n+    checkTraverse(inodeAttrs, path, ancestorIndex);\n+\n+    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n+    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n+      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n     }\n-    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n-      if (mode.getGroupAction().implies(access)) { return; }\n+    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n-    else { //other class\n-      if (mode.getOtherAction().implies(access)) { return; }\n+    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n-    throw new AccessControlException(\n-      toAccessControlString(inode, snapshotId, access, mode));\n+    if (access !\u003d null) {\n+      check(last, path, access);\n+    }\n+    if (subAccess !\u003d null) {\n+      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n+      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n+          snapshotId, subAccess, ignoreEmptyDir);\n+    }\n+    if (doCheckOwner) {\n+      checkOwner(last);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodeAttrs, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "checkFsPermission",
            "newValue": "checkPermission"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
          "commitDate": "24/03/15 4:02 PM",
          "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "09/12/14 6:57 PM",
          "commitNameOld": "d93f3b9815f90d24c838574a56013e6dc60dc5ad",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 104.84,
          "commitsBetweenForRepo": 828,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,34 @@\n-  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n-      FsPermission mode) throws AccessControlException {\n-    if (user.equals(inode.getUserName(snapshotId))) { //user class\n-      if (mode.getUserAction().implies(access)) { return; }\n+  public void checkPermission(String fsOwner, String supergroup,\n+      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n+      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n+      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n+      FsAction parentAccess, FsAction access, FsAction subAccess,\n+      boolean ignoreEmptyDir)\n+      throws AccessControlException {\n+    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n+        ancestorIndex--);\n+    checkTraverse(inodeAttrs, path, ancestorIndex);\n+\n+    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n+    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n+      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n     }\n-    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n-      if (mode.getGroupAction().implies(access)) { return; }\n+    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n-    else { //other class\n-      if (mode.getOtherAction().implies(access)) { return; }\n+    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n-    throw new AccessControlException(\n-      toAccessControlString(inode, snapshotId, access, mode));\n+    if (access !\u003d null) {\n+      check(last, path, access);\n+    }\n+    if (subAccess !\u003d null) {\n+      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n+      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n+          snapshotId, subAccess, ignoreEmptyDir);\n+    }\n+    if (doCheckOwner) {\n+      checkOwner(last);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodeAttrs, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[inode-INode, snapshotId-int, access-FsAction, mode-FsPermission]",
            "newValue": "[fsOwner-String, supergroup-String, callerUgi-UserGroupInformation, inodeAttrs-INodeAttributes[], inodes-INode[], pathByNameArr-byte[][], snapshotId-int, path-String, ancestorIndex-int, doCheckOwner-boolean, ancestorAccess-FsAction, parentAccess-FsAction, access-FsAction, subAccess-FsAction, ignoreEmptyDir-boolean]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
          "commitDate": "24/03/15 4:02 PM",
          "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "09/12/14 6:57 PM",
          "commitNameOld": "d93f3b9815f90d24c838574a56013e6dc60dc5ad",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 104.84,
          "commitsBetweenForRepo": 828,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,34 @@\n-  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n-      FsPermission mode) throws AccessControlException {\n-    if (user.equals(inode.getUserName(snapshotId))) { //user class\n-      if (mode.getUserAction().implies(access)) { return; }\n+  public void checkPermission(String fsOwner, String supergroup,\n+      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n+      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n+      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n+      FsAction parentAccess, FsAction access, FsAction subAccess,\n+      boolean ignoreEmptyDir)\n+      throws AccessControlException {\n+    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n+        ancestorIndex--);\n+    checkTraverse(inodeAttrs, path, ancestorIndex);\n+\n+    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n+    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n+      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n     }\n-    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n-      if (mode.getGroupAction().implies(access)) { return; }\n+    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n-    else { //other class\n-      if (mode.getOtherAction().implies(access)) { return; }\n+    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n-    throw new AccessControlException(\n-      toAccessControlString(inode, snapshotId, access, mode));\n+    if (access !\u003d null) {\n+      check(last, path, access);\n+    }\n+    if (subAccess !\u003d null) {\n+      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n+      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n+          snapshotId, subAccess, ignoreEmptyDir);\n+    }\n+    if (doCheckOwner) {\n+      checkOwner(last);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodeAttrs, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
          "commitDate": "24/03/15 4:02 PM",
          "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "09/12/14 6:57 PM",
          "commitNameOld": "d93f3b9815f90d24c838574a56013e6dc60dc5ad",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 104.84,
          "commitsBetweenForRepo": 828,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,34 @@\n-  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n-      FsPermission mode) throws AccessControlException {\n-    if (user.equals(inode.getUserName(snapshotId))) { //user class\n-      if (mode.getUserAction().implies(access)) { return; }\n+  public void checkPermission(String fsOwner, String supergroup,\n+      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n+      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n+      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n+      FsAction parentAccess, FsAction access, FsAction subAccess,\n+      boolean ignoreEmptyDir)\n+      throws AccessControlException {\n+    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n+        ancestorIndex--);\n+    checkTraverse(inodeAttrs, path, ancestorIndex);\n+\n+    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n+    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n+        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n+      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n     }\n-    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n-      if (mode.getGroupAction().implies(access)) { return; }\n+    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n     }\n-    else { //other class\n-      if (mode.getOtherAction().implies(access)) { return; }\n+    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n+      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n     }\n-    throw new AccessControlException(\n-      toAccessControlString(inode, snapshotId, access, mode));\n+    if (access !\u003d null) {\n+      check(last, path, access);\n+    }\n+    if (subAccess !\u003d null) {\n+      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n+      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n+          snapshotId, subAccess, ignoreEmptyDir);\n+    }\n+    if (doCheckOwner) {\n+      checkOwner(last);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkPermission(String fsOwner, String supergroup,\n      UserGroupInformation callerUgi, INodeAttributes[] inodeAttrs,\n      INode[] inodes, byte[][] pathByNameArr, int snapshotId, String path,\n      int ancestorIndex, boolean doCheckOwner, FsAction ancestorAccess,\n      FsAction parentAccess, FsAction access, FsAction subAccess,\n      boolean ignoreEmptyDir)\n      throws AccessControlException {\n    for(; ancestorIndex \u003e\u003d 0 \u0026\u0026 inodes[ancestorIndex] \u003d\u003d null;\n        ancestorIndex--);\n    checkTraverse(inodeAttrs, path, ancestorIndex);\n\n    final INodeAttributes last \u003d inodeAttrs[inodeAttrs.length - 1];\n    if (parentAccess !\u003d null \u0026\u0026 parentAccess.implies(FsAction.WRITE)\n        \u0026\u0026 inodeAttrs.length \u003e 1 \u0026\u0026 last !\u003d null) {\n      checkStickyBit(inodeAttrs[inodeAttrs.length - 2], last);\n    }\n    if (ancestorAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, ancestorIndex, ancestorAccess);\n    }\n    if (parentAccess !\u003d null \u0026\u0026 inodeAttrs.length \u003e 1) {\n      check(inodeAttrs, path, inodeAttrs.length - 2, parentAccess);\n    }\n    if (access !\u003d null) {\n      check(last, path, access);\n    }\n    if (subAccess !\u003d null) {\n      INode rawLast \u003d inodes[inodeAttrs.length - 1];\n      checkSubAccess(pathByNameArr, inodeAttrs.length - 1, rawLast,\n          snapshotId, subAccess, ignoreEmptyDir);\n    }\n    if (doCheckOwner) {\n      checkOwner(last);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
          "extendedDetails": {}
        }
      ]
    },
    "6a52febfbd97f3b54318e07d4918cea2a9292f53": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5612. NameNode: change all permission checks to enforce ACLs in addition to permissions. Contributued by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1559281 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/01/14 3:28 PM",
      "commitName": "6a52febfbd97f3b54318e07d4918cea2a9292f53",
      "commitAuthor": "Haohui Mai",
      "diff": "@@ -0,0 +1,14 @@\n+  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n+      FsPermission mode) throws AccessControlException {\n+    if (user.equals(inode.getUserName(snapshotId))) { //user class\n+      if (mode.getUserAction().implies(access)) { return; }\n+    }\n+    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n+      if (mode.getGroupAction().implies(access)) { return; }\n+    }\n+    else { //other class\n+      if (mode.getOtherAction().implies(access)) { return; }\n+    }\n+    throw new AccessControlException(\n+      toAccessControlString(inode, snapshotId, access, mode));\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void checkFsPermission(INode inode, int snapshotId, FsAction access,\n      FsPermission mode) throws AccessControlException {\n    if (user.equals(inode.getUserName(snapshotId))) { //user class\n      if (mode.getUserAction().implies(access)) { return; }\n    }\n    else if (groups.contains(inode.getGroupName(snapshotId))) { //group class\n      if (mode.getGroupAction().implies(access)) { return; }\n    }\n    else { //other class\n      if (mode.getOtherAction().implies(access)) { return; }\n    }\n    throw new AccessControlException(\n      toAccessControlString(inode, snapshotId, access, mode));\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java"
    }
  }
}