{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "KMSWebApp.java",
  "functionName": "contextInitialized",
  "functionId": "contextInitialized___sce-ServletContextEvent",
  "sourceFilePath": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
  "functionStartLine": 90,
  "functionEndLine": 183,
  "numCommitsSeen": 19,
  "timeTaken": 3874,
  "changeHistory": [
    "781437c219dc3422797a32dc7ba72cd4f5ee38e2",
    "21c66614610a3c3c9189832faeb120a2ba8069bb",
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78",
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99",
    "d88497d44a7c34ae4cf0295c89b3584d834057d5",
    "fa397e74fe988bcbb05c816de73eb738794ace4b",
    "3476156807733505746951f0c9346592742bbbb2",
    "a963baba10648859ad88d4ed9a4325b66b1af0d5",
    "adf0b67a7104bd457b20c95ff78dd48753dcd699",
    "10e8602f32b553a1424f1a9b5f9f74f7b68a49d1",
    "b02a4b40610e93eef6559db09a11d287e859446d",
    "b7e67db37238e775150180ff4de65da27a99e282",
    "bda9c584c828fdd18e9c066747d58dbf751a585d",
    "0c1469ece38556cf02a0c7bd23761d6bf79d9a64",
    "0a3ea6c486b43a798d487f9a20668d418f539b8b",
    "17d4fbbf0af9b93de9502afb274e91533140d1c6"
  ],
  "changeHistoryShort": {
    "781437c219dc3422797a32dc7ba72cd4f5ee38e2": "Ybodychange",
    "21c66614610a3c3c9189832faeb120a2ba8069bb": "Ybodychange",
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78": "Ybodychange",
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99": "Ybodychange",
    "d88497d44a7c34ae4cf0295c89b3584d834057d5": "Ybodychange",
    "fa397e74fe988bcbb05c816de73eb738794ace4b": "Ybodychange",
    "3476156807733505746951f0c9346592742bbbb2": "Ybodychange",
    "a963baba10648859ad88d4ed9a4325b66b1af0d5": "Ybodychange",
    "adf0b67a7104bd457b20c95ff78dd48753dcd699": "Ybodychange",
    "10e8602f32b553a1424f1a9b5f9f74f7b68a49d1": "Ybodychange",
    "b02a4b40610e93eef6559db09a11d287e859446d": "Ybodychange",
    "b7e67db37238e775150180ff4de65da27a99e282": "Ybodychange",
    "bda9c584c828fdd18e9c066747d58dbf751a585d": "Ybodychange",
    "0c1469ece38556cf02a0c7bd23761d6bf79d9a64": "Ybodychange",
    "0a3ea6c486b43a798d487f9a20668d418f539b8b": "Ybodychange",
    "17d4fbbf0af9b93de9502afb274e91533140d1c6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "781437c219dc3422797a32dc7ba72cd4f5ee38e2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15698. KMS log4j is not initialized properly at startup. Contributed by Kitti Nanasi.\n",
      "commitDate": "29/08/18 10:07 PM",
      "commitName": "781437c219dc3422797a32dc7ba72cd4f5ee38e2",
      "commitAuthor": "Kitti Nanasi",
      "commitDateOld": "15/03/18 8:17 PM",
      "commitNameOld": "21c66614610a3c3c9189832faeb120a2ba8069bb",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 167.08,
      "commitsBetweenForRepo": 1822,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,94 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n-      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n-      if (confDir \u003d\u003d null) {\n-        throw new RuntimeException(\"System property \u0027\" +\n-            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n-      }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n-      initLogging(confDir);\n       UserGroupInformation.setConfiguration(kmsConf);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       kmsAcls \u003d new KMSACLs();\n       kmsAcls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       reencryptEEKCallsMeter \u003d metricRegistry.register(REENCRYPT_EEK_METER,\n           new Meter());\n       reencryptEEKBatchCallsMeter \u003d metricRegistry.register(\n           REENCRYPT_EEK_BATCH_METER, new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       kmsAudit \u003d new KMSAudit(kmsConf);\n \n       // initializing the KeyProvider\n       String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n       if (providerString \u003d\u003d null) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       KeyProvider keyProvider \u003d\n           KeyProviderFactory.get(new URI(providerString), kmsConf);\n       Preconditions.checkNotNull(keyProvider, String.format(\"No\" +\n               \" KeyProvider has been initialized, please\" +\n               \" check whether %s \u0027%s\u0027 is configured correctly in\" +\n               \" kms-site.xml.\", KMSConfiguration.KEY_PROVIDER_URI,\n           providerString));\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       LOG.info(\"Initialized KeyProvider \" + keyProvider);\n \n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n           KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n         keyProviderCryptoExtension \u003d\n             new KeyAuthorizationKeyProvider(\n                 keyProviderCryptoExtension, kmsAcls);\n       }\n         \n       LOG.info(\"Initialized KeyProviderCryptoExtension \"\n           + keyProviderCryptoExtension);\n       final int defaultBitlength \u003d kmsConf\n           .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n               KeyProvider.DEFAULT_BITLENGTH);\n       LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      UserGroupInformation.setConfiguration(kmsConf);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      kmsAcls \u003d new KMSACLs();\n      kmsAcls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      reencryptEEKCallsMeter \u003d metricRegistry.register(REENCRYPT_EEK_METER,\n          new Meter());\n      reencryptEEKBatchCallsMeter \u003d metricRegistry.register(\n          REENCRYPT_EEK_BATCH_METER, new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d new KMSAudit(kmsConf);\n\n      // initializing the KeyProvider\n      String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n      if (providerString \u003d\u003d null) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      KeyProvider keyProvider \u003d\n          KeyProviderFactory.get(new URI(providerString), kmsConf);\n      Preconditions.checkNotNull(keyProvider, String.format(\"No\" +\n              \" KeyProvider has been initialized, please\" +\n              \" check whether %s \u0027%s\u0027 is configured correctly in\" +\n              \" kms-site.xml.\", KMSConfiguration.KEY_PROVIDER_URI,\n          providerString));\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n        keyProviderCryptoExtension \u003d\n            new KeyAuthorizationKeyProvider(\n                keyProviderCryptoExtension, kmsAcls);\n      }\n        \n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "21c66614610a3c3c9189832faeb120a2ba8069bb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15234. Throw meaningful message on null when initializing KMSWebApp. Contributed by fang zhenyi.\n",
      "commitDate": "15/03/18 8:17 PM",
      "commitName": "21c66614610a3c3c9189832faeb120a2ba8069bb",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "24/02/18 2:41 PM",
      "commitNameOld": "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 19.19,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,100 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       UserGroupInformation.setConfiguration(kmsConf);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       kmsAcls \u003d new KMSACLs();\n       kmsAcls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       reencryptEEKCallsMeter \u003d metricRegistry.register(REENCRYPT_EEK_METER,\n           new Meter());\n       reencryptEEKBatchCallsMeter \u003d metricRegistry.register(\n           REENCRYPT_EEK_BATCH_METER, new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       kmsAudit \u003d new KMSAudit(kmsConf);\n \n       // initializing the KeyProvider\n       String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n       if (providerString \u003d\u003d null) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       KeyProvider keyProvider \u003d\n           KeyProviderFactory.get(new URI(providerString), kmsConf);\n+      Preconditions.checkNotNull(keyProvider, String.format(\"No\" +\n+              \" KeyProvider has been initialized, please\" +\n+              \" check whether %s \u0027%s\u0027 is configured correctly in\" +\n+              \" kms-site.xml.\", KMSConfiguration.KEY_PROVIDER_URI,\n+          providerString));\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       LOG.info(\"Initialized KeyProvider \" + keyProvider);\n \n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n           KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n         keyProviderCryptoExtension \u003d\n             new KeyAuthorizationKeyProvider(\n                 keyProviderCryptoExtension, kmsAcls);\n       }\n         \n       LOG.info(\"Initialized KeyProviderCryptoExtension \"\n           + keyProviderCryptoExtension);\n       final int defaultBitlength \u003d kmsConf\n           .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n               KeyProvider.DEFAULT_BITLENGTH);\n       LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      UserGroupInformation.setConfiguration(kmsConf);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      kmsAcls \u003d new KMSACLs();\n      kmsAcls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      reencryptEEKCallsMeter \u003d metricRegistry.register(REENCRYPT_EEK_METER,\n          new Meter());\n      reencryptEEKBatchCallsMeter \u003d metricRegistry.register(\n          REENCRYPT_EEK_BATCH_METER, new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d new KMSAudit(kmsConf);\n\n      // initializing the KeyProvider\n      String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n      if (providerString \u003d\u003d null) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      KeyProvider keyProvider \u003d\n          KeyProviderFactory.get(new URI(providerString), kmsConf);\n      Preconditions.checkNotNull(keyProvider, String.format(\"No\" +\n              \" KeyProvider has been initialized, please\" +\n              \" check whether %s \u0027%s\u0027 is configured correctly in\" +\n              \" kms-site.xml.\", KMSConfiguration.KEY_PROVIDER_URI,\n          providerString));\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n        keyProviderCryptoExtension \u003d\n            new KeyAuthorizationKeyProvider(\n                keyProviderCryptoExtension, kmsAcls);\n      }\n        \n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15254. Correct the wrong word spelling \u0027intialize\u0027. Contributed by fang zhenyi.\n",
      "commitDate": "24/02/18 2:41 PM",
      "commitName": "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "22/08/17 7:47 AM",
      "commitNameOld": "4ec5acc70418a3f2327cf83ecae1789a057fdd99",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 186.33,
      "commitsBetweenForRepo": 1379,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,95 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       UserGroupInformation.setConfiguration(kmsConf);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       kmsAcls \u003d new KMSACLs();\n       kmsAcls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       reencryptEEKCallsMeter \u003d metricRegistry.register(REENCRYPT_EEK_METER,\n           new Meter());\n       reencryptEEKBatchCallsMeter \u003d metricRegistry.register(\n           REENCRYPT_EEK_BATCH_METER, new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       kmsAudit \u003d new KMSAudit(kmsConf);\n \n-      // intializing the KeyProvider\n+      // initializing the KeyProvider\n       String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n       if (providerString \u003d\u003d null) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       KeyProvider keyProvider \u003d\n           KeyProviderFactory.get(new URI(providerString), kmsConf);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       LOG.info(\"Initialized KeyProvider \" + keyProvider);\n \n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n           KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n         keyProviderCryptoExtension \u003d\n             new KeyAuthorizationKeyProvider(\n                 keyProviderCryptoExtension, kmsAcls);\n       }\n         \n       LOG.info(\"Initialized KeyProviderCryptoExtension \"\n           + keyProviderCryptoExtension);\n       final int defaultBitlength \u003d kmsConf\n           .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n               KeyProvider.DEFAULT_BITLENGTH);\n       LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      UserGroupInformation.setConfiguration(kmsConf);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      kmsAcls \u003d new KMSACLs();\n      kmsAcls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      reencryptEEKCallsMeter \u003d metricRegistry.register(REENCRYPT_EEK_METER,\n          new Meter());\n      reencryptEEKBatchCallsMeter \u003d metricRegistry.register(\n          REENCRYPT_EEK_BATCH_METER, new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d new KMSAudit(kmsConf);\n\n      // initializing the KeyProvider\n      String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n      if (providerString \u003d\u003d null) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      KeyProvider keyProvider \u003d\n          KeyProviderFactory.get(new URI(providerString), kmsConf);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n        keyProviderCryptoExtension \u003d\n            new KeyAuthorizationKeyProvider(\n                keyProviderCryptoExtension, kmsAcls);\n      }\n        \n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14705. Add batched interface reencryptEncryptedKeys to KMS.\n",
      "commitDate": "22/08/17 7:47 AM",
      "commitName": "4ec5acc70418a3f2327cf83ecae1789a057fdd99",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "06/02/17 1:14 PM",
      "commitNameOld": "d88497d44a7c34ae4cf0295c89b3584d834057d5",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 196.73,
      "commitsBetweenForRepo": 1132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,95 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       UserGroupInformation.setConfiguration(kmsConf);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       kmsAcls \u003d new KMSACLs();\n       kmsAcls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n+      reencryptEEKCallsMeter \u003d metricRegistry.register(REENCRYPT_EEK_METER,\n+          new Meter());\n+      reencryptEEKBatchCallsMeter \u003d metricRegistry.register(\n+          REENCRYPT_EEK_BATCH_METER, new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       kmsAudit \u003d new KMSAudit(kmsConf);\n \n       // intializing the KeyProvider\n       String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n       if (providerString \u003d\u003d null) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       KeyProvider keyProvider \u003d\n           KeyProviderFactory.get(new URI(providerString), kmsConf);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       LOG.info(\"Initialized KeyProvider \" + keyProvider);\n \n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n           KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n         keyProviderCryptoExtension \u003d\n             new KeyAuthorizationKeyProvider(\n                 keyProviderCryptoExtension, kmsAcls);\n       }\n         \n       LOG.info(\"Initialized KeyProviderCryptoExtension \"\n           + keyProviderCryptoExtension);\n       final int defaultBitlength \u003d kmsConf\n           .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n               KeyProvider.DEFAULT_BITLENGTH);\n       LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      UserGroupInformation.setConfiguration(kmsConf);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      kmsAcls \u003d new KMSACLs();\n      kmsAcls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      reencryptEEKCallsMeter \u003d metricRegistry.register(REENCRYPT_EEK_METER,\n          new Meter());\n      reencryptEEKBatchCallsMeter \u003d metricRegistry.register(\n          REENCRYPT_EEK_BATCH_METER, new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d new KMSAudit(kmsConf);\n\n      // intializing the KeyProvider\n      String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n      if (providerString \u003d\u003d null) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      KeyProvider keyProvider \u003d\n          KeyProviderFactory.get(new URI(providerString), kmsConf);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n        keyProviderCryptoExtension \u003d\n            new KeyAuthorizationKeyProvider(\n                keyProviderCryptoExtension, kmsAcls);\n      }\n        \n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "d88497d44a7c34ae4cf0295c89b3584d834057d5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14047. Require admin to access KMS instrumentation servlets. Contributed by John Zhuge.\n",
      "commitDate": "06/02/17 1:14 PM",
      "commitName": "d88497d44a7c34ae4cf0295c89b3584d834057d5",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "05/01/17 5:21 PM",
      "commitNameOld": "5d182949badb2eb80393de7ba3838102d006488b",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 31.83,
      "commitsBetweenForRepo": 147,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,91 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       UserGroupInformation.setConfiguration(kmsConf);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       kmsAcls \u003d new KMSACLs();\n       kmsAcls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       kmsAudit \u003d new KMSAudit(kmsConf);\n \n-      // this is required for the the JMXJsonServlet to work properly.\n-      // the JMXJsonServlet is behind the authentication filter,\n-      // thus the \u0027*\u0027 ACL.\n-      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n-          kmsConf);\n-      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n-          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n-\n       // intializing the KeyProvider\n       String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n       if (providerString \u003d\u003d null) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       KeyProvider keyProvider \u003d\n           KeyProviderFactory.get(new URI(providerString), kmsConf);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       LOG.info(\"Initialized KeyProvider \" + keyProvider);\n \n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n           KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n         keyProviderCryptoExtension \u003d\n             new KeyAuthorizationKeyProvider(\n                 keyProviderCryptoExtension, kmsAcls);\n       }\n         \n       LOG.info(\"Initialized KeyProviderCryptoExtension \"\n           + keyProviderCryptoExtension);\n       final int defaultBitlength \u003d kmsConf\n           .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n               KeyProvider.DEFAULT_BITLENGTH);\n       LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      UserGroupInformation.setConfiguration(kmsConf);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      kmsAcls \u003d new KMSACLs();\n      kmsAcls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d new KMSAudit(kmsConf);\n\n      // intializing the KeyProvider\n      String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n      if (providerString \u003d\u003d null) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      KeyProvider keyProvider \u003d\n          KeyProviderFactory.get(new URI(providerString), kmsConf);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n        keyProviderCryptoExtension \u003d\n            new KeyAuthorizationKeyProvider(\n                keyProviderCryptoExtension, kmsAcls);\n      }\n        \n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "fa397e74fe988bcbb05c816de73eb738794ace4b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13638. KMS should set UGI\u0027s Configuration object properly. Contributed by Wei-Chiu Chuang.\n",
      "commitDate": "26/09/16 1:00 PM",
      "commitName": "fa397e74fe988bcbb05c816de73eb738794ace4b",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "24/08/16 10:14 AM",
      "commitNameOld": "3476156807733505746951f0c9346592742bbbb2",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 33.12,
      "commitsBetweenForRepo": 172,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,99 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n+      UserGroupInformation.setConfiguration(kmsConf);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       kmsAcls \u003d new KMSACLs();\n       kmsAcls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       kmsAudit \u003d new KMSAudit(kmsConf);\n \n       // this is required for the the JMXJsonServlet to work properly.\n       // the JMXJsonServlet is behind the authentication filter,\n       // thus the \u0027*\u0027 ACL.\n       sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n           kmsConf);\n       sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n           new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n \n       // intializing the KeyProvider\n       String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n       if (providerString \u003d\u003d null) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       KeyProvider keyProvider \u003d\n           KeyProviderFactory.get(new URI(providerString), kmsConf);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       LOG.info(\"Initialized KeyProvider \" + keyProvider);\n \n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n           KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n         keyProviderCryptoExtension \u003d\n             new KeyAuthorizationKeyProvider(\n                 keyProviderCryptoExtension, kmsAcls);\n       }\n         \n       LOG.info(\"Initialized KeyProviderCryptoExtension \"\n           + keyProviderCryptoExtension);\n       final int defaultBitlength \u003d kmsConf\n           .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n               KeyProvider.DEFAULT_BITLENGTH);\n       LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      UserGroupInformation.setConfiguration(kmsConf);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      kmsAcls \u003d new KMSACLs();\n      kmsAcls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d new KMSAudit(kmsConf);\n\n      // this is required for the the JMXJsonServlet to work properly.\n      // the JMXJsonServlet is behind the authentication filter,\n      // thus the \u0027*\u0027 ACL.\n      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n          kmsConf);\n      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n\n      // intializing the KeyProvider\n      String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n      if (providerString \u003d\u003d null) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      KeyProvider keyProvider \u003d\n          KeyProviderFactory.get(new URI(providerString), kmsConf);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n        keyProviderCryptoExtension \u003d\n            new KeyAuthorizationKeyProvider(\n                keyProviderCryptoExtension, kmsAcls);\n      }\n        \n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "3476156807733505746951f0c9346592742bbbb2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13396. Allow pluggable audit loggers in KMS. Contributed by Xiao Chen\n",
      "commitDate": "24/08/16 10:14 AM",
      "commitName": "3476156807733505746951f0c9346592742bbbb2",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "19/02/16 9:41 AM",
      "commitNameOld": "a963baba10648859ad88d4ed9a4325b66b1af0d5",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 186.98,
      "commitsBetweenForRepo": 1345,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,98 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       kmsAcls \u003d new KMSACLs();\n       kmsAcls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n-      kmsAudit \u003d\n-          new KMSAudit(kmsConf.getLong(\n-              KMSConfiguration.KMS_AUDIT_AGGREGATION_WINDOW,\n-              KMSConfiguration.KMS_AUDIT_AGGREGATION_WINDOW_DEFAULT));\n+      kmsAudit \u003d new KMSAudit(kmsConf);\n \n       // this is required for the the JMXJsonServlet to work properly.\n       // the JMXJsonServlet is behind the authentication filter,\n       // thus the \u0027*\u0027 ACL.\n       sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n           kmsConf);\n       sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n           new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n \n       // intializing the KeyProvider\n       String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n       if (providerString \u003d\u003d null) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       KeyProvider keyProvider \u003d\n           KeyProviderFactory.get(new URI(providerString), kmsConf);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       LOG.info(\"Initialized KeyProvider \" + keyProvider);\n \n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n           KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n         keyProviderCryptoExtension \u003d\n             new KeyAuthorizationKeyProvider(\n                 keyProviderCryptoExtension, kmsAcls);\n       }\n         \n       LOG.info(\"Initialized KeyProviderCryptoExtension \"\n           + keyProviderCryptoExtension);\n       final int defaultBitlength \u003d kmsConf\n           .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n               KeyProvider.DEFAULT_BITLENGTH);\n       LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      kmsAcls \u003d new KMSACLs();\n      kmsAcls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d new KMSAudit(kmsConf);\n\n      // this is required for the the JMXJsonServlet to work properly.\n      // the JMXJsonServlet is behind the authentication filter,\n      // thus the \u0027*\u0027 ACL.\n      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n          kmsConf);\n      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n\n      // intializing the KeyProvider\n      String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n      if (providerString \u003d\u003d null) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      KeyProvider keyProvider \u003d\n          KeyProviderFactory.get(new URI(providerString), kmsConf);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n        keyProviderCryptoExtension \u003d\n            new KeyAuthorizationKeyProvider(\n                keyProviderCryptoExtension, kmsAcls);\n      }\n        \n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "a963baba10648859ad88d4ed9a4325b66b1af0d5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12828. Print user when services are started. (Wei-Chiu Chuang via Yongjun Zhang)\n",
      "commitDate": "19/02/16 9:41 AM",
      "commitName": "a963baba10648859ad88d4ed9a4325b66b1af0d5",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "19/09/14 2:59 PM",
      "commitNameOld": "adf0b67a7104bd457b20c95ff78dd48753dcd699",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 517.82,
      "commitsBetweenForRepo": 4131,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,101 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n+      LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       kmsAcls \u003d new KMSACLs();\n       kmsAcls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       kmsAudit \u003d\n           new KMSAudit(kmsConf.getLong(\n               KMSConfiguration.KMS_AUDIT_AGGREGATION_WINDOW,\n               KMSConfiguration.KMS_AUDIT_AGGREGATION_WINDOW_DEFAULT));\n \n       // this is required for the the JMXJsonServlet to work properly.\n       // the JMXJsonServlet is behind the authentication filter,\n       // thus the \u0027*\u0027 ACL.\n       sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n           kmsConf);\n       sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n           new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n \n       // intializing the KeyProvider\n       String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n       if (providerString \u003d\u003d null) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       KeyProvider keyProvider \u003d\n           KeyProviderFactory.get(new URI(providerString), kmsConf);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       LOG.info(\"Initialized KeyProvider \" + keyProvider);\n \n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n           KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n         keyProviderCryptoExtension \u003d\n             new KeyAuthorizationKeyProvider(\n                 keyProviderCryptoExtension, kmsAcls);\n       }\n         \n       LOG.info(\"Initialized KeyProviderCryptoExtension \"\n           + keyProviderCryptoExtension);\n       final int defaultBitlength \u003d kmsConf\n           .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n               KeyProvider.DEFAULT_BITLENGTH);\n       LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  User: {}\", System.getProperty(\"user.name\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      kmsAcls \u003d new KMSACLs();\n      kmsAcls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d\n          new KMSAudit(kmsConf.getLong(\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_WINDOW,\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_WINDOW_DEFAULT));\n\n      // this is required for the the JMXJsonServlet to work properly.\n      // the JMXJsonServlet is behind the authentication filter,\n      // thus the \u0027*\u0027 ACL.\n      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n          kmsConf);\n      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n\n      // intializing the KeyProvider\n      String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n      if (providerString \u003d\u003d null) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      KeyProvider keyProvider \u003d\n          KeyProviderFactory.get(new URI(providerString), kmsConf);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n        keyProviderCryptoExtension \u003d\n            new KeyAuthorizationKeyProvider(\n                keyProviderCryptoExtension, kmsAcls);\n      }\n        \n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "adf0b67a7104bd457b20c95ff78dd48753dcd699": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10970. Cleanup KMS configuration keys. (wang)\n",
      "commitDate": "19/09/14 2:59 PM",
      "commitName": "adf0b67a7104bd457b20c95ff78dd48753dcd699",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "17/09/14 8:14 PM",
      "commitNameOld": "10e8602f32b553a1424f1a9b5f9f74f7b68a49d1",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,100 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       kmsAcls \u003d new KMSACLs();\n       kmsAcls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       kmsAudit \u003d\n           new KMSAudit(kmsConf.getLong(\n-              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY,\n-              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY_DEFAULT));\n+              KMSConfiguration.KMS_AUDIT_AGGREGATION_WINDOW,\n+              KMSConfiguration.KMS_AUDIT_AGGREGATION_WINDOW_DEFAULT));\n \n       // this is required for the the JMXJsonServlet to work properly.\n       // the JMXJsonServlet is behind the authentication filter,\n       // thus the \u0027*\u0027 ACL.\n       sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n           kmsConf);\n       sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n           new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n \n       // intializing the KeyProvider\n       String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n       if (providerString \u003d\u003d null) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       KeyProvider keyProvider \u003d\n           KeyProviderFactory.get(new URI(providerString), kmsConf);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       LOG.info(\"Initialized KeyProvider \" + keyProvider);\n \n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n           KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n         keyProviderCryptoExtension \u003d\n             new KeyAuthorizationKeyProvider(\n                 keyProviderCryptoExtension, kmsAcls);\n       }\n         \n       LOG.info(\"Initialized KeyProviderCryptoExtension \"\n           + keyProviderCryptoExtension);\n       final int defaultBitlength \u003d kmsConf\n           .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n               KeyProvider.DEFAULT_BITLENGTH);\n       LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      kmsAcls \u003d new KMSACLs();\n      kmsAcls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d\n          new KMSAudit(kmsConf.getLong(\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_WINDOW,\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_WINDOW_DEFAULT));\n\n      // this is required for the the JMXJsonServlet to work properly.\n      // the JMXJsonServlet is behind the authentication filter,\n      // thus the \u0027*\u0027 ACL.\n      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n          kmsConf);\n      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n\n      // intializing the KeyProvider\n      String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n      if (providerString \u003d\u003d null) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      KeyProvider keyProvider \u003d\n          KeyProviderFactory.get(new URI(providerString), kmsConf);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n        keyProviderCryptoExtension \u003d\n            new KeyAuthorizationKeyProvider(\n                keyProviderCryptoExtension, kmsAcls);\n      }\n        \n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "10e8602f32b553a1424f1a9b5f9f74f7b68a49d1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7004. Update KeyProvider instantiation to create by URI. (wang)\n",
      "commitDate": "17/09/14 8:14 PM",
      "commitName": "10e8602f32b553a1424f1a9b5f9f74f7b68a49d1",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "10/09/14 2:26 PM",
      "commitNameOld": "b02a4b40610e93eef6559db09a11d287e859446d",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 7.24,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,100 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       kmsAcls \u003d new KMSACLs();\n       kmsAcls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       kmsAudit \u003d\n           new KMSAudit(kmsConf.getLong(\n               KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY,\n               KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY_DEFAULT));\n \n       // this is required for the the JMXJsonServlet to work properly.\n       // the JMXJsonServlet is behind the authentication filter,\n       // thus the \u0027*\u0027 ACL.\n       sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n           kmsConf);\n       sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n           new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n \n       // intializing the KeyProvider\n-\n-      List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n-      if (providers.isEmpty()) {\n+      String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n+      if (providerString \u003d\u003d null) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n-      if (providers.size() \u003e 1) {\n-        LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n-            \"the first provider\",\n-            kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n-      }\n-      KeyProvider keyProvider \u003d providers.get(0);\n+      KeyProvider keyProvider \u003d\n+          KeyProviderFactory.get(new URI(providerString), kmsConf);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       LOG.info(\"Initialized KeyProvider \" + keyProvider);\n \n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n           KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n         keyProviderCryptoExtension \u003d\n             new KeyAuthorizationKeyProvider(\n                 keyProviderCryptoExtension, kmsAcls);\n       }\n         \n       LOG.info(\"Initialized KeyProviderCryptoExtension \"\n           + keyProviderCryptoExtension);\n       final int defaultBitlength \u003d kmsConf\n           .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n               KeyProvider.DEFAULT_BITLENGTH);\n       LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      kmsAcls \u003d new KMSACLs();\n      kmsAcls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d\n          new KMSAudit(kmsConf.getLong(\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY,\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY_DEFAULT));\n\n      // this is required for the the JMXJsonServlet to work properly.\n      // the JMXJsonServlet is behind the authentication filter,\n      // thus the \u0027*\u0027 ACL.\n      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n          kmsConf);\n      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n\n      // intializing the KeyProvider\n      String providerString \u003d kmsConf.get(KMSConfiguration.KEY_PROVIDER_URI);\n      if (providerString \u003d\u003d null) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      KeyProvider keyProvider \u003d\n          KeyProviderFactory.get(new URI(providerString), kmsConf);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n        keyProviderCryptoExtension \u003d\n            new KeyAuthorizationKeyProvider(\n                keyProviderCryptoExtension, kmsAcls);\n      }\n        \n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "b02a4b40610e93eef6559db09a11d287e859446d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10758. KMS: add ACLs on per key basis. (tucu)\n",
      "commitDate": "10/09/14 2:26 PM",
      "commitName": "b02a4b40610e93eef6559db09a11d287e859446d",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "04/08/14 7:32 PM",
      "commitNameOld": "b7e67db37238e775150180ff4de65da27a99e282",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 36.79,
      "commitsBetweenForRepo": 294,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,105 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n-      acls \u003d new KMSACLs();\n-      acls.startReloader();\n+      kmsAcls \u003d new KMSACLs();\n+      kmsAcls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       kmsAudit \u003d\n           new KMSAudit(kmsConf.getLong(\n               KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY,\n               KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY_DEFAULT));\n \n       // this is required for the the JMXJsonServlet to work properly.\n       // the JMXJsonServlet is behind the authentication filter,\n       // thus the \u0027*\u0027 ACL.\n       sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n           kmsConf);\n       sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n           new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n \n       // intializing the KeyProvider\n \n       List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n       if (providers.isEmpty()) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       if (providers.size() \u003e 1) {\n         LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n             \"the first provider\",\n             kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n       }\n       KeyProvider keyProvider \u003d providers.get(0);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       LOG.info(\"Initialized KeyProvider \" + keyProvider);\n \n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n+      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n+          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n+        keyProviderCryptoExtension \u003d\n+            new KeyAuthorizationKeyProvider(\n+                keyProviderCryptoExtension, kmsAcls);\n+      }\n+        \n       LOG.info(\"Initialized KeyProviderCryptoExtension \"\n           + keyProviderCryptoExtension);\n       final int defaultBitlength \u003d kmsConf\n           .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n               KeyProvider.DEFAULT_BITLENGTH);\n       LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      kmsAcls \u003d new KMSACLs();\n      kmsAcls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d\n          new KMSAudit(kmsConf.getLong(\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY,\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY_DEFAULT));\n\n      // this is required for the the JMXJsonServlet to work properly.\n      // the JMXJsonServlet is behind the authentication filter,\n      // thus the \u0027*\u0027 ACL.\n      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n          kmsConf);\n      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n\n      // intializing the KeyProvider\n\n      List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n      if (providers.isEmpty()) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      if (providers.size() \u003e 1) {\n        LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n            \"the first provider\",\n            kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n      }\n      KeyProvider keyProvider \u003d providers.get(0);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_AUTHORIZATION_ENABLE,\n          KMSConfiguration.KEY_AUTHORIZATION_ENABLE_DEFAULT)) {\n        keyProviderCryptoExtension \u003d\n            new KeyAuthorizationKeyProvider(\n                keyProviderCryptoExtension, kmsAcls);\n      }\n        \n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "b7e67db37238e775150180ff4de65da27a99e282": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10936. Change default KeyProvider bitlength to 128. (wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615850 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/08/14 7:32 PM",
      "commitName": "b7e67db37238e775150180ff4de65da27a99e282",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "30/07/14 10:54 AM",
      "commitNameOld": "bda9c584c828fdd18e9c066747d58dbf751a585d",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 5.36,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,98 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       acls \u003d new KMSACLs();\n       acls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       kmsAudit \u003d\n           new KMSAudit(kmsConf.getLong(\n               KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY,\n               KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY_DEFAULT));\n \n       // this is required for the the JMXJsonServlet to work properly.\n       // the JMXJsonServlet is behind the authentication filter,\n       // thus the \u0027*\u0027 ACL.\n       sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n           kmsConf);\n       sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n           new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n \n       // intializing the KeyProvider\n \n       List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n       if (providers.isEmpty()) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       if (providers.size() \u003e 1) {\n         LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n             \"the first provider\",\n             kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n       }\n       KeyProvider keyProvider \u003d providers.get(0);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n+      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n+\n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n-\n+      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n+          + keyProviderCryptoExtension);\n+      final int defaultBitlength \u003d kmsConf\n+          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n+              KeyProvider.DEFAULT_BITLENGTH);\n+      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      acls \u003d new KMSACLs();\n      acls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d\n          new KMSAudit(kmsConf.getLong(\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY,\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY_DEFAULT));\n\n      // this is required for the the JMXJsonServlet to work properly.\n      // the JMXJsonServlet is behind the authentication filter,\n      // thus the \u0027*\u0027 ACL.\n      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n          kmsConf);\n      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n\n      // intializing the KeyProvider\n\n      List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n      if (providers.isEmpty()) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      if (providers.size() \u003e 1) {\n        LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n            \"the first provider\",\n            kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n      }\n      KeyProvider keyProvider \u003d providers.get(0);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      LOG.info(\"Initialized KeyProvider \" + keyProvider);\n\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n      LOG.info(\"Initialized KeyProviderCryptoExtension \"\n          + keyProviderCryptoExtension);\n      final int defaultBitlength \u003d kmsConf\n          .getInt(KeyProvider.DEFAULT_BITLENGTH_NAME,\n              KeyProvider.DEFAULT_BITLENGTH);\n      LOG.info(\"Default key bitlength is {}\", defaultBitlength);\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "bda9c584c828fdd18e9c066747d58dbf751a585d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10756. KMS audit log should consolidate successful similar requests. (asuresh via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1614725 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/07/14 10:54 AM",
      "commitName": "bda9c584c828fdd18e9c066747d58dbf751a585d",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "21/07/14 1:55 PM",
      "commitNameOld": "0c1469ece38556cf02a0c7bd23761d6bf79d9a64",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 8.87,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,91 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       acls \u003d new KMSACLs();\n       acls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n           new Meter());\n       decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n           new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n+      kmsAudit \u003d\n+          new KMSAudit(kmsConf.getLong(\n+              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY,\n+              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY_DEFAULT));\n+\n       // this is required for the the JMXJsonServlet to work properly.\n       // the JMXJsonServlet is behind the authentication filter,\n       // thus the \u0027*\u0027 ACL.\n       sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n           kmsConf);\n       sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n           new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n \n       // intializing the KeyProvider\n \n       List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n       if (providers.isEmpty()) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       if (providers.size() \u003e 1) {\n         LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n             \"the first provider\",\n             kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n       }\n       KeyProvider keyProvider \u003d providers.get(0);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n       keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n           createKeyProviderCryptoExtension(keyProvider);\n       keyProviderCryptoExtension \u003d \n           new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n               keyProviderCryptoExtension);\n \n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      acls \u003d new KMSACLs();\n      acls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      kmsAudit \u003d\n          new KMSAudit(kmsConf.getLong(\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY,\n              KMSConfiguration.KMS_AUDIT_AGGREGATION_DELAY_DEFAULT));\n\n      // this is required for the the JMXJsonServlet to work properly.\n      // the JMXJsonServlet is behind the authentication filter,\n      // thus the \u0027*\u0027 ACL.\n      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n          kmsConf);\n      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n\n      // intializing the KeyProvider\n\n      List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n      if (providers.isEmpty()) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      if (providers.size() \u003e 1) {\n        LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n            \"the first provider\",\n            kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n      }\n      KeyProvider keyProvider \u003d providers.get(0);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "0c1469ece38556cf02a0c7bd23761d6bf79d9a64": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10720. KMS: Implement generateEncryptedKey and decryptEncryptedKey in the REST API. (asuresh via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612399 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/07/14 1:55 PM",
      "commitName": "0c1469ece38556cf02a0c7bd23761d6bf79d9a64",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "18/07/14 3:01 PM",
      "commitNameOld": "0a3ea6c486b43a798d487f9a20668d418f539b8b",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,86 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       acls \u003d new KMSACLs();\n       acls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n+      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n+          new Meter());\n+      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n+          new Meter());\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       // this is required for the the JMXJsonServlet to work properly.\n       // the JMXJsonServlet is behind the authentication filter,\n       // thus the \u0027*\u0027 ACL.\n       sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n           kmsConf);\n       sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n           new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n \n       // intializing the KeyProvider\n \n       List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n       if (providers.isEmpty()) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       if (providers.size() \u003e 1) {\n         LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n             \"the first provider\",\n             kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n       }\n-      keyProvider \u003d providers.get(0);\n+      KeyProvider keyProvider \u003d providers.get(0);\n       if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n           KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n         long keyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n         long currKeyTimeOutMillis \u003d\n             kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                 KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n         keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n             currKeyTimeOutMillis);\n       }\n+      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n+          createKeyProviderCryptoExtension(keyProvider);\n+      keyProviderCryptoExtension \u003d \n+          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n+              keyProviderCryptoExtension);\n \n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      acls \u003d new KMSACLs();\n      acls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      generateEEKCallsMeter \u003d metricRegistry.register(GENERATE_EEK_METER,\n          new Meter());\n      decryptEEKCallsMeter \u003d metricRegistry.register(DECRYPT_EEK_METER,\n          new Meter());\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      // this is required for the the JMXJsonServlet to work properly.\n      // the JMXJsonServlet is behind the authentication filter,\n      // thus the \u0027*\u0027 ACL.\n      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n          kmsConf);\n      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n\n      // intializing the KeyProvider\n\n      List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n      if (providers.isEmpty()) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      if (providers.size() \u003e 1) {\n        LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n            \"the first provider\",\n            kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n      }\n      KeyProvider keyProvider \u003d providers.get(0);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n      keyProviderCryptoExtension \u003d KeyProviderCryptoExtension.\n          createKeyProviderCryptoExtension(keyProvider);\n      keyProviderCryptoExtension \u003d \n          new EagerKeyGeneratorKeyProviderCryptoExtension(kmsConf, \n              keyProviderCryptoExtension);\n\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "0a3ea6c486b43a798d487f9a20668d418f539b8b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10750. KMSKeyProviderCache should be in hadoop-common. (asuresh via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611823 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/14 3:01 PM",
      "commitName": "0a3ea6c486b43a798d487f9a20668d418f539b8b",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "05/05/14 2:43 PM",
      "commitNameOld": "17d4fbbf0af9b93de9502afb274e91533140d1c6",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 74.01,
      "commitsBetweenForRepo": 476,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,77 @@\n   public void contextInitialized(ServletContextEvent sce) {\n     try {\n       String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n       if (confDir \u003d\u003d null) {\n         throw new RuntimeException(\"System property \u0027\" +\n             KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n       }\n       kmsConf \u003d KMSConfiguration.getKMSConf();\n       initLogging(confDir);\n       LOG.info(\"-------------------------------------------------------------\");\n       LOG.info(\"  Java runtime version : {}\", System.getProperty(\n           \"java.runtime.version\"));\n       LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n       LOG.info(\"-------------------------------------------------------------\");\n \n       acls \u003d new KMSACLs();\n       acls.startReloader();\n \n       metricRegistry \u003d new MetricRegistry();\n       jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n       jmxReporter.start();\n       adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n       keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n       invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n           new Meter());\n       unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n           new Meter());\n       unauthenticatedCallsMeter \u003d metricRegistry.register(\n           UNAUTHENTICATED_CALLS_METER, new Meter());\n \n       // this is required for the the JMXJsonServlet to work properly.\n       // the JMXJsonServlet is behind the authentication filter,\n       // thus the \u0027*\u0027 ACL.\n       sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n           kmsConf);\n       sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n           new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n \n       // intializing the KeyProvider\n \n       List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n       if (providers.isEmpty()) {\n         throw new IllegalStateException(\"No KeyProvider has been defined\");\n       }\n       if (providers.size() \u003e 1) {\n         LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n             \"the first provider\",\n             kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n       }\n       keyProvider \u003d providers.get(0);\n-      long timeOutMillis \u003d\n-          kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n-              KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n-      keyProvider \u003d new KMSCacheKeyProvider(keyProvider, timeOutMillis);\n+      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n+          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n+        long keyTimeOutMillis \u003d\n+            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n+                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n+        long currKeyTimeOutMillis \u003d\n+            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n+                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n+        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n+            currKeyTimeOutMillis);\n+      }\n \n       LOG.info(\"KMS Started\");\n     } catch (Throwable ex) {\n       System.out.println();\n       System.out.println(\"ERROR: Hadoop KMS could not be started\");\n       System.out.println();\n       System.out.println(\"REASON: \" + ex.toString());\n       System.out.println();\n       System.out.println(\"Stacktrace:\");\n       System.out.println(\"---------------------------------------------------\");\n       ex.printStackTrace(System.out);\n       System.out.println(\"---------------------------------------------------\");\n       System.out.println();\n       System.exit(1);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      acls \u003d new KMSACLs();\n      acls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      // this is required for the the JMXJsonServlet to work properly.\n      // the JMXJsonServlet is behind the authentication filter,\n      // thus the \u0027*\u0027 ACL.\n      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n          kmsConf);\n      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n\n      // intializing the KeyProvider\n\n      List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n      if (providers.isEmpty()) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      if (providers.size() \u003e 1) {\n        LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n            \"the first provider\",\n            kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n      }\n      keyProvider \u003d providers.get(0);\n      if (kmsConf.getBoolean(KMSConfiguration.KEY_CACHE_ENABLE,\n          KMSConfiguration.KEY_CACHE_ENABLE_DEFAULT)) {\n        long keyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n        long currKeyTimeOutMillis \u003d\n            kmsConf.getLong(KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_KEY,\n                KMSConfiguration.CURR_KEY_CACHE_TIMEOUT_DEFAULT);\n        keyProvider \u003d new CachingKeyProvider(keyProvider, keyTimeOutMillis,\n            currKeyTimeOutMillis);\n      }\n\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java",
      "extendedDetails": {}
    },
    "17d4fbbf0af9b93de9502afb274e91533140d1c6": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10433. Key Management Server based on KeyProvider API. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1592637 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/05/14 2:43 PM",
      "commitName": "17d4fbbf0af9b93de9502afb274e91533140d1c6",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,70 @@\n+  public void contextInitialized(ServletContextEvent sce) {\n+    try {\n+      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n+      if (confDir \u003d\u003d null) {\n+        throw new RuntimeException(\"System property \u0027\" +\n+            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n+      }\n+      kmsConf \u003d KMSConfiguration.getKMSConf();\n+      initLogging(confDir);\n+      LOG.info(\"-------------------------------------------------------------\");\n+      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n+          \"java.runtime.version\"));\n+      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n+      LOG.info(\"-------------------------------------------------------------\");\n+\n+      acls \u003d new KMSACLs();\n+      acls.startReloader();\n+\n+      metricRegistry \u003d new MetricRegistry();\n+      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n+      jmxReporter.start();\n+      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n+      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n+      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n+          new Meter());\n+      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n+          new Meter());\n+      unauthenticatedCallsMeter \u003d metricRegistry.register(\n+          UNAUTHENTICATED_CALLS_METER, new Meter());\n+\n+      // this is required for the the JMXJsonServlet to work properly.\n+      // the JMXJsonServlet is behind the authentication filter,\n+      // thus the \u0027*\u0027 ACL.\n+      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n+          kmsConf);\n+      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n+          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n+\n+      // intializing the KeyProvider\n+\n+      List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n+      if (providers.isEmpty()) {\n+        throw new IllegalStateException(\"No KeyProvider has been defined\");\n+      }\n+      if (providers.size() \u003e 1) {\n+        LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n+            \"the first provider\",\n+            kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n+      }\n+      keyProvider \u003d providers.get(0);\n+      long timeOutMillis \u003d\n+          kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n+              KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n+      keyProvider \u003d new KMSCacheKeyProvider(keyProvider, timeOutMillis);\n+\n+      LOG.info(\"KMS Started\");\n+    } catch (Throwable ex) {\n+      System.out.println();\n+      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n+      System.out.println();\n+      System.out.println(\"REASON: \" + ex.toString());\n+      System.out.println();\n+      System.out.println(\"Stacktrace:\");\n+      System.out.println(\"---------------------------------------------------\");\n+      ex.printStackTrace(System.out);\n+      System.out.println(\"---------------------------------------------------\");\n+      System.out.println();\n+      System.exit(1);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void contextInitialized(ServletContextEvent sce) {\n    try {\n      String confDir \u003d System.getProperty(KMSConfiguration.KMS_CONFIG_DIR);\n      if (confDir \u003d\u003d null) {\n        throw new RuntimeException(\"System property \u0027\" +\n            KMSConfiguration.KMS_CONFIG_DIR + \"\u0027 not defined\");\n      }\n      kmsConf \u003d KMSConfiguration.getKMSConf();\n      initLogging(confDir);\n      LOG.info(\"-------------------------------------------------------------\");\n      LOG.info(\"  Java runtime version : {}\", System.getProperty(\n          \"java.runtime.version\"));\n      LOG.info(\"  KMS Hadoop Version: \" + VersionInfo.getVersion());\n      LOG.info(\"-------------------------------------------------------------\");\n\n      acls \u003d new KMSACLs();\n      acls.startReloader();\n\n      metricRegistry \u003d new MetricRegistry();\n      jmxReporter \u003d JmxReporter.forRegistry(metricRegistry).build();\n      jmxReporter.start();\n      adminCallsMeter \u003d metricRegistry.register(ADMIN_CALLS_METER, new Meter());\n      keyCallsMeter \u003d metricRegistry.register(KEY_CALLS_METER, new Meter());\n      invalidCallsMeter \u003d metricRegistry.register(INVALID_CALLS_METER,\n          new Meter());\n      unauthorizedCallsMeter \u003d metricRegistry.register(UNAUTHORIZED_CALLS_METER,\n          new Meter());\n      unauthenticatedCallsMeter \u003d metricRegistry.register(\n          UNAUTHENTICATED_CALLS_METER, new Meter());\n\n      // this is required for the the JMXJsonServlet to work properly.\n      // the JMXJsonServlet is behind the authentication filter,\n      // thus the \u0027*\u0027 ACL.\n      sce.getServletContext().setAttribute(HttpServer2.CONF_CONTEXT_ATTRIBUTE,\n          kmsConf);\n      sce.getServletContext().setAttribute(HttpServer2.ADMINS_ACL,\n          new AccessControlList(AccessControlList.WILDCARD_ACL_VALUE));\n\n      // intializing the KeyProvider\n\n      List\u003cKeyProvider\u003e providers \u003d KeyProviderFactory.getProviders(kmsConf);\n      if (providers.isEmpty()) {\n        throw new IllegalStateException(\"No KeyProvider has been defined\");\n      }\n      if (providers.size() \u003e 1) {\n        LOG.warn(\"There is more than one KeyProvider configured \u0027{}\u0027, using \" +\n            \"the first provider\",\n            kmsConf.get(KeyProviderFactory.KEY_PROVIDER_PATH));\n      }\n      keyProvider \u003d providers.get(0);\n      long timeOutMillis \u003d\n          kmsConf.getLong(KMSConfiguration.KEY_CACHE_TIMEOUT_KEY,\n              KMSConfiguration.KEY_CACHE_TIMEOUT_DEFAULT);\n      keyProvider \u003d new KMSCacheKeyProvider(keyProvider, timeOutMillis);\n\n      LOG.info(\"KMS Started\");\n    } catch (Throwable ex) {\n      System.out.println();\n      System.out.println(\"ERROR: Hadoop KMS could not be started\");\n      System.out.println();\n      System.out.println(\"REASON: \" + ex.toString());\n      System.out.println();\n      System.out.println(\"Stacktrace:\");\n      System.out.println(\"---------------------------------------------------\");\n      ex.printStackTrace(System.out);\n      System.out.println(\"---------------------------------------------------\");\n      System.out.println();\n      System.exit(1);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSWebApp.java"
    }
  }
}