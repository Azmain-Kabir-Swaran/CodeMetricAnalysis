{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerLauncherImpl.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
  "functionStartLine": 381,
  "functionEndLine": 407,
  "numCommitsSeen": 50,
  "timeTaken": 10532,
  "changeHistory": [
    "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5",
    "444836b3dcd3ee28238af7b5e753d644e8095788",
    "0a80f82a304fc8bb3d9cf5ec016e12e6415270fc",
    "849c68c7b5f80064de3692d766444c2f8864f47a",
    "239a5549eadeccb0ab433abb38079dbe19f862ff",
    "00b50a5c94df63668b07ca1623c40fe7252f1322",
    "2df83e5b4d7a3516a9c7ec11309023e3c42a869b",
    "7f4dc277572df6ba25fa961073b99a5bdb086c00",
    "724f21734316343873386a14059a347067d65a10",
    "ade0f0560f729e50382c6992f713f29e2dd5b270",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5": "Ybodychange",
    "444836b3dcd3ee28238af7b5e753d644e8095788": "Ybodychange",
    "0a80f82a304fc8bb3d9cf5ec016e12e6415270fc": "Ybodychange",
    "849c68c7b5f80064de3692d766444c2f8864f47a": "Ybodychange",
    "239a5549eadeccb0ab433abb38079dbe19f862ff": "Ybodychange",
    "00b50a5c94df63668b07ca1623c40fe7252f1322": "Ybodychange",
    "2df83e5b4d7a3516a9c7ec11309023e3c42a869b": "Ybodychange",
    "7f4dc277572df6ba25fa961073b99a5bdb086c00": "Ybodychange",
    "724f21734316343873386a14059a347067d65a10": "Ybodychange",
    "ade0f0560f729e50382c6992f713f29e2dd5b270": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Ymultichange(Ymovefromfile,Ybodychange)",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5044. Have AM trigger jstack on task attempts that timeout before killing them. (Eric Payne and Gera Shegalov via mingma)\n",
      "commitDate": "06/06/16 2:30 PM",
      "commitName": "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "18/02/16 12:48 AM",
      "commitNameOld": "2440671a117f165dcda5056404bc898df3c50803",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 109.53,
      "commitsBetweenForRepo": 694,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n     public void run() {\n       LOG.info(\"Processing the event \" + event.toString());\n \n       // Load ContainerManager tokens before creating a connection.\n       // TODO: Do it only once per NodeManager.\n       ContainerId containerID \u003d event.getContainerID();\n \n       Container c \u003d getContainer(event);\n       switch(event.getType()) {\n \n       case CONTAINER_REMOTE_LAUNCH:\n         ContainerRemoteLaunchEvent launchEvent\n             \u003d (ContainerRemoteLaunchEvent) event;\n         c.launch(launchEvent);\n         break;\n \n       case CONTAINER_REMOTE_CLEANUP:\n-        c.kill();\n+        c.kill(event.getDumpContainerThreads());\n         break;\n \n       case CONTAINER_COMPLETED:\n         c.done();\n         break;\n \n       }\n       removeContainerIfDone(containerID);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      ContainerId containerID \u003d event.getContainerID();\n\n      Container c \u003d getContainer(event);\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEvent\n            \u003d (ContainerRemoteLaunchEvent) event;\n        c.launch(launchEvent);\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        c.kill(event.getDumpContainerThreads());\n        break;\n\n      case CONTAINER_COMPLETED:\n        c.done();\n        break;\n\n      }\n      removeContainerIfDone(containerID);\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "444836b3dcd3ee28238af7b5e753d644e8095788": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5465. Tasks are often killed before they exit on their own. Contributed by Ming Ma\n",
      "commitDate": "11/05/15 3:37 PM",
      "commitName": "444836b3dcd3ee28238af7b5e753d644e8095788",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "14/03/15 12:44 AM",
      "commitNameOld": "9d38520c8e42530a817a7f69c9aa73a9ad40639c",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 58.62,
      "commitsBetweenForRepo": 595,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,27 @@\n     public void run() {\n       LOG.info(\"Processing the event \" + event.toString());\n \n       // Load ContainerManager tokens before creating a connection.\n       // TODO: Do it only once per NodeManager.\n       ContainerId containerID \u003d event.getContainerID();\n \n       Container c \u003d getContainer(event);\n       switch(event.getType()) {\n \n       case CONTAINER_REMOTE_LAUNCH:\n         ContainerRemoteLaunchEvent launchEvent\n             \u003d (ContainerRemoteLaunchEvent) event;\n         c.launch(launchEvent);\n         break;\n \n       case CONTAINER_REMOTE_CLEANUP:\n         c.kill();\n         break;\n+\n+      case CONTAINER_COMPLETED:\n+        c.done();\n+        break;\n+\n       }\n       removeContainerIfDone(containerID);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      ContainerId containerID \u003d event.getContainerID();\n\n      Container c \u003d getContainer(event);\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEvent\n            \u003d (ContainerRemoteLaunchEvent) event;\n        c.launch(launchEvent);\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        c.kill();\n        break;\n\n      case CONTAINER_COMPLETED:\n        c.done();\n        break;\n\n      }\n      removeContainerIfDone(containerID);\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "0a80f82a304fc8bb3d9cf5ec016e12e6415270fc": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4152. map task left hanging after AM dies trying to connect to RM (Tom Graves via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1344283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/12 7:48 AM",
      "commitName": "0a80f82a304fc8bb3d9cf5ec016e12e6415270fc",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "08/05/12 8:07 AM",
      "commitNameOld": "aa60da6c2ec049cc70897afee6c368cb70493773",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 21.99,
      "commitsBetweenForRepo": 120,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,22 @@\n     public void run() {\n       LOG.info(\"Processing the event \" + event.toString());\n \n       // Load ContainerManager tokens before creating a connection.\n       // TODO: Do it only once per NodeManager.\n       ContainerId containerID \u003d event.getContainerID();\n \n-      Container c \u003d getContainer(containerID);\n+      Container c \u003d getContainer(event);\n       switch(event.getType()) {\n \n       case CONTAINER_REMOTE_LAUNCH:\n         ContainerRemoteLaunchEvent launchEvent\n             \u003d (ContainerRemoteLaunchEvent) event;\n         c.launch(launchEvent);\n         break;\n \n       case CONTAINER_REMOTE_CLEANUP:\n-        c.kill(event);\n+        c.kill();\n         break;\n       }\n       removeContainerIfDone(containerID);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      ContainerId containerID \u003d event.getContainerID();\n\n      Container c \u003d getContainer(event);\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEvent\n            \u003d (ContainerRemoteLaunchEvent) event;\n        c.launch(launchEvent);\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        c.kill();\n        break;\n      }\n      removeContainerIfDone(containerID);\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "849c68c7b5f80064de3692d766444c2f8864f47a": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3312. Modified MR AM to not send a stop-container request for a container that isn\u0027t launched at all. Contributed by Robert Joseph Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1229451 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/12 6:15 PM",
      "commitName": "849c68c7b5f80064de3692d766444c2f8864f47a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "09/01/12 2:20 PM",
      "commitNameOld": "239a5549eadeccb0ab433abb38079dbe19f862ff",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,168 +1,22 @@\n     public void run() {\n       LOG.info(\"Processing the event \" + event.toString());\n \n       // Load ContainerManager tokens before creating a connection.\n       // TODO: Do it only once per NodeManager.\n-      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n       ContainerId containerID \u003d event.getContainerID();\n-      ContainerToken containerToken \u003d event.getContainerToken();\n-      TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n \n-      ContainerManager proxy \u003d null;\n-\n-      CommandTimerTask timerTask \u003d new CommandTimerTask(Thread\n-          .currentThread(), event);\n-\n+      Container c \u003d getContainer(containerID);\n       switch(event.getType()) {\n \n       case CONTAINER_REMOTE_LAUNCH:\n         ContainerRemoteLaunchEvent launchEvent\n             \u003d (ContainerRemoteLaunchEvent) event;\n-\n-        try {\n-          commandTimer.schedule(timerTask, nmTimeOut);\n-\n-          proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n-              containerToken);\n-\n-          // Interrupted during getProxy, but that didn\u0027t throw exception\n-          if (Thread.interrupted()) {\n-            // The timer cancelled the command in the mean while.\n-            String message \u003d \"Container launch failed for \" + containerID\n-                + \" : Start-container for \" + event.getContainerID()\n-                + \" got interrupted. Returning.\";\n-            sendContainerLaunchFailedMsg(taskAttemptID, message);\n-            return;\n-          }\n-\n-          // Construct the actual Container\n-          ContainerLaunchContext containerLaunchContext \u003d\n-              launchEvent.getContainer();\n-\n-          // Now launch the actual container\n-          StartContainerRequest startRequest \u003d Records\n-              .newRecord(StartContainerRequest.class);\n-          startRequest.setContainerLaunchContext(containerLaunchContext);\n-          StartContainerResponse response \u003d proxy.startContainer(startRequest);\n-\n-          // container started properly. Stop the timer\n-          timerTask.cancel();\n-          if (Thread.interrupted()) {\n-            // The timer cancelled the command in the mean while, but\n-            // startContainer didn\u0027t throw exception\n-            String message \u003d \"Container launch failed for \" + containerID\n-                + \" : Start-container for \" + event.getContainerID()\n-                + \" got interrupted. Returning.\";\n-            sendContainerLaunchFailedMsg(taskAttemptID, message);\n-            return;\n-          }\n-\n-          ByteBuffer portInfo \u003d response\n-              .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n-          int port \u003d -1;\n-          if(portInfo !\u003d null) {\n-            port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n-          }\n-          LOG.info(\"Shuffle port returned by ContainerManager for \"\n-              + taskAttemptID + \" : \" + port);\n-          \n-          if(port \u003c 0) {\n-            throw new IllegalStateException(\"Invalid shuffle port number \"\n-                + port + \" returned for \" + taskAttemptID);\n-          }\n-\n-          // after launching, send launched event to task attempt to move\n-          // it from ASSIGNED to RUNNING state\n-          context.getEventHandler().handle(\n-              new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n-        } catch (Throwable t) {\n-          if (Thread.interrupted()) {\n-            // The timer cancelled the command in the mean while.\n-            LOG.info(\"Start-container for \" + event.getContainerID()\n-                + \" got interrupted.\");\n-          }\n-          String message \u003d \"Container launch failed for \" + containerID\n-              + \" : \" + StringUtils.stringifyException(t);\n-          sendContainerLaunchFailedMsg(taskAttemptID, message);\n-        } finally {\n-          timerTask.cancel();\n-          if (proxy !\u003d null) {\n-            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n-          }\n-        }\n-\n+        c.launch(launchEvent);\n         break;\n \n       case CONTAINER_REMOTE_CLEANUP:\n-        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n-        // and not yet processed\n-        if (eventQueue.contains(event)) {\n-          eventQueue.remove(event); // TODO: Any synchro needed?\n-          //deallocate the container\n-          context.getEventHandler().handle(\n-              new ContainerAllocatorEvent(taskAttemptID,\n-                  ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n-        } else {\n-\n-          try {\n-            commandTimer.schedule(timerTask, nmTimeOut);\n-\n-            proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n-                containerToken);\n-\n-            if (Thread.interrupted()) {\n-              // The timer cancelled the command in the mean while. No need to\n-              // return, send cleanedup event anyways.\n-              LOG.info(\"Stop-container for \" + event.getContainerID()\n-                  + \" got interrupted.\");\n-            } else {\n-\n-              // TODO:check whether container is launched\n-\n-              // kill the remote container if already launched\n-              StopContainerRequest stopRequest \u003d Records\n-                  .newRecord(StopContainerRequest.class);\n-              stopRequest.setContainerId(event.getContainerID());\n-              proxy.stopContainer(stopRequest);\n-            }\n-          } catch (Throwable t) {\n-\n-            if (Thread.interrupted()) {\n-              // The timer cancelled the command in the mean while, clear the\n-              // interrupt flag\n-              LOG.info(\"Stop-container for \" + event.getContainerID()\n-                  + \" got interrupted.\");\n-            }\n-\n-            // ignore the cleanup failure\n-            String message \u003d \"cleanup failed for container \"\n-                + event.getContainerID() + \" : \"\n-                + StringUtils.stringifyException(t);\n-            context.getEventHandler()\n-                .handle(\n-                    new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n-                        message));\n-            LOG.warn(message);\n-          } finally {\n-            timerTask.cancel();\n-            if (Thread.interrupted()) {\n-              LOG.info(\"Stop-container for \" + event.getContainerID()\n-                  + \" got interrupted.\");\n-              // ignore the cleanup failure\n-              context.getEventHandler()\n-                  .handle(new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n-                    \"cleanup failed for container \" + event.getContainerID()));\n-            }\n-            if (proxy !\u003d null) {\n-              ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n-            }\n-          }\n-\n-          // after killing, send killed event to taskattempt\n-          context.getEventHandler().handle(\n-              new TaskAttemptEvent(event.getTaskAttemptID(),\n-                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n-        }\n+        c.kill(event);\n         break;\n       }\n+      removeContainerIfDone(containerID);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      ContainerId containerID \u003d event.getContainerID();\n\n      Container c \u003d getContainer(containerID);\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEvent\n            \u003d (ContainerRemoteLaunchEvent) event;\n        c.launch(launchEvent);\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        c.kill(event);\n        break;\n      }\n      removeContainerIfDone(containerID);\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "239a5549eadeccb0ab433abb38079dbe19f862ff": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3616. Thread pool for launching containers in MR AM not expanding as expected. (Contributed by Vinod Kumar Vavilapalli) \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1229394 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/12 2:20 PM",
      "commitName": "239a5549eadeccb0ab433abb38079dbe19f862ff",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "16/11/11 7:37 AM",
      "commitNameOld": "00b50a5c94df63668b07ca1623c40fe7252f1322",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 54.28,
      "commitsBetweenForRepo": 276,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,168 +1,168 @@\n     public void run() {\n       LOG.info(\"Processing the event \" + event.toString());\n \n       // Load ContainerManager tokens before creating a connection.\n       // TODO: Do it only once per NodeManager.\n       final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n       ContainerId containerID \u003d event.getContainerID();\n       ContainerToken containerToken \u003d event.getContainerToken();\n       TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n \n       ContainerManager proxy \u003d null;\n \n       CommandTimerTask timerTask \u003d new CommandTimerTask(Thread\n           .currentThread(), event);\n \n       switch(event.getType()) {\n \n       case CONTAINER_REMOTE_LAUNCH:\n         ContainerRemoteLaunchEvent launchEvent\n             \u003d (ContainerRemoteLaunchEvent) event;\n \n         try {\n           commandTimer.schedule(timerTask, nmTimeOut);\n \n           proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n               containerToken);\n \n-          // Interruped during getProxy, but that didn\u0027t throw exception\n+          // Interrupted during getProxy, but that didn\u0027t throw exception\n           if (Thread.interrupted()) {\n             // The timer cancelled the command in the mean while.\n             String message \u003d \"Container launch failed for \" + containerID\n                 + \" : Start-container for \" + event.getContainerID()\n                 + \" got interrupted. Returning.\";\n             sendContainerLaunchFailedMsg(taskAttemptID, message);\n             return;\n           }\n \n           // Construct the actual Container\n           ContainerLaunchContext containerLaunchContext \u003d\n               launchEvent.getContainer();\n \n           // Now launch the actual container\n           StartContainerRequest startRequest \u003d Records\n               .newRecord(StartContainerRequest.class);\n           startRequest.setContainerLaunchContext(containerLaunchContext);\n           StartContainerResponse response \u003d proxy.startContainer(startRequest);\n \n           // container started properly. Stop the timer\n           timerTask.cancel();\n           if (Thread.interrupted()) {\n             // The timer cancelled the command in the mean while, but\n             // startContainer didn\u0027t throw exception\n             String message \u003d \"Container launch failed for \" + containerID\n                 + \" : Start-container for \" + event.getContainerID()\n                 + \" got interrupted. Returning.\";\n             sendContainerLaunchFailedMsg(taskAttemptID, message);\n             return;\n           }\n \n           ByteBuffer portInfo \u003d response\n               .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n           int port \u003d -1;\n           if(portInfo !\u003d null) {\n             port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n           }\n           LOG.info(\"Shuffle port returned by ContainerManager for \"\n               + taskAttemptID + \" : \" + port);\n           \n           if(port \u003c 0) {\n             throw new IllegalStateException(\"Invalid shuffle port number \"\n                 + port + \" returned for \" + taskAttemptID);\n           }\n \n           // after launching, send launched event to task attempt to move\n           // it from ASSIGNED to RUNNING state\n           context.getEventHandler().handle(\n               new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n         } catch (Throwable t) {\n           if (Thread.interrupted()) {\n             // The timer cancelled the command in the mean while.\n             LOG.info(\"Start-container for \" + event.getContainerID()\n                 + \" got interrupted.\");\n           }\n           String message \u003d \"Container launch failed for \" + containerID\n               + \" : \" + StringUtils.stringifyException(t);\n           sendContainerLaunchFailedMsg(taskAttemptID, message);\n         } finally {\n           timerTask.cancel();\n           if (proxy !\u003d null) {\n             ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n           }\n         }\n \n         break;\n \n       case CONTAINER_REMOTE_CLEANUP:\n         // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n         // and not yet processed\n         if (eventQueue.contains(event)) {\n           eventQueue.remove(event); // TODO: Any synchro needed?\n           //deallocate the container\n           context.getEventHandler().handle(\n               new ContainerAllocatorEvent(taskAttemptID,\n                   ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n         } else {\n \n           try {\n             commandTimer.schedule(timerTask, nmTimeOut);\n \n             proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n                 containerToken);\n \n             if (Thread.interrupted()) {\n               // The timer cancelled the command in the mean while. No need to\n               // return, send cleanedup event anyways.\n               LOG.info(\"Stop-container for \" + event.getContainerID()\n                   + \" got interrupted.\");\n             } else {\n \n               // TODO:check whether container is launched\n \n               // kill the remote container if already launched\n               StopContainerRequest stopRequest \u003d Records\n                   .newRecord(StopContainerRequest.class);\n               stopRequest.setContainerId(event.getContainerID());\n               proxy.stopContainer(stopRequest);\n             }\n           } catch (Throwable t) {\n \n             if (Thread.interrupted()) {\n               // The timer cancelled the command in the mean while, clear the\n               // interrupt flag\n               LOG.info(\"Stop-container for \" + event.getContainerID()\n                   + \" got interrupted.\");\n             }\n \n             // ignore the cleanup failure\n             String message \u003d \"cleanup failed for container \"\n                 + event.getContainerID() + \" : \"\n                 + StringUtils.stringifyException(t);\n             context.getEventHandler()\n                 .handle(\n                     new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                         message));\n             LOG.warn(message);\n           } finally {\n             timerTask.cancel();\n             if (Thread.interrupted()) {\n               LOG.info(\"Stop-container for \" + event.getContainerID()\n                   + \" got interrupted.\");\n               // ignore the cleanup failure\n               context.getEventHandler()\n                   .handle(new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                     \"cleanup failed for container \" + event.getContainerID()));\n             }\n             if (proxy !\u003d null) {\n               ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n             }\n           }\n \n           // after killing, send killed event to taskattempt\n           context.getEventHandler().handle(\n               new TaskAttemptEvent(event.getTaskAttemptID(),\n                   TaskAttemptEventType.TA_CONTAINER_CLEANED));\n         }\n         break;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n      ContainerId containerID \u003d event.getContainerID();\n      ContainerToken containerToken \u003d event.getContainerToken();\n      TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n\n      ContainerManager proxy \u003d null;\n\n      CommandTimerTask timerTask \u003d new CommandTimerTask(Thread\n          .currentThread(), event);\n\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEvent\n            \u003d (ContainerRemoteLaunchEvent) event;\n\n        try {\n          commandTimer.schedule(timerTask, nmTimeOut);\n\n          proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n              containerToken);\n\n          // Interrupted during getProxy, but that didn\u0027t throw exception\n          if (Thread.interrupted()) {\n            // The timer cancelled the command in the mean while.\n            String message \u003d \"Container launch failed for \" + containerID\n                + \" : Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          // Construct the actual Container\n          ContainerLaunchContext containerLaunchContext \u003d\n              launchEvent.getContainer();\n\n          // Now launch the actual container\n          StartContainerRequest startRequest \u003d Records\n              .newRecord(StartContainerRequest.class);\n          startRequest.setContainerLaunchContext(containerLaunchContext);\n          StartContainerResponse response \u003d proxy.startContainer(startRequest);\n\n          // container started properly. Stop the timer\n          timerTask.cancel();\n          if (Thread.interrupted()) {\n            // The timer cancelled the command in the mean while, but\n            // startContainer didn\u0027t throw exception\n            String message \u003d \"Container launch failed for \" + containerID\n                + \" : Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          ByteBuffer portInfo \u003d response\n              .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n          int port \u003d -1;\n          if(portInfo !\u003d null) {\n            port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n          }\n          LOG.info(\"Shuffle port returned by ContainerManager for \"\n              + taskAttemptID + \" : \" + port);\n          \n          if(port \u003c 0) {\n            throw new IllegalStateException(\"Invalid shuffle port number \"\n                + port + \" returned for \" + taskAttemptID);\n          }\n\n          // after launching, send launched event to task attempt to move\n          // it from ASSIGNED to RUNNING state\n          context.getEventHandler().handle(\n              new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n        } catch (Throwable t) {\n          if (Thread.interrupted()) {\n            // The timer cancelled the command in the mean while.\n            LOG.info(\"Start-container for \" + event.getContainerID()\n                + \" got interrupted.\");\n          }\n          String message \u003d \"Container launch failed for \" + containerID\n              + \" : \" + StringUtils.stringifyException(t);\n          sendContainerLaunchFailedMsg(taskAttemptID, message);\n        } finally {\n          timerTask.cancel();\n          if (proxy !\u003d null) {\n            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n          }\n        }\n\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n        // and not yet processed\n        if (eventQueue.contains(event)) {\n          eventQueue.remove(event); // TODO: Any synchro needed?\n          //deallocate the container\n          context.getEventHandler().handle(\n              new ContainerAllocatorEvent(taskAttemptID,\n                  ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n        } else {\n\n          try {\n            commandTimer.schedule(timerTask, nmTimeOut);\n\n            proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n                containerToken);\n\n            if (Thread.interrupted()) {\n              // The timer cancelled the command in the mean while. No need to\n              // return, send cleanedup event anyways.\n              LOG.info(\"Stop-container for \" + event.getContainerID()\n                  + \" got interrupted.\");\n            } else {\n\n              // TODO:check whether container is launched\n\n              // kill the remote container if already launched\n              StopContainerRequest stopRequest \u003d Records\n                  .newRecord(StopContainerRequest.class);\n              stopRequest.setContainerId(event.getContainerID());\n              proxy.stopContainer(stopRequest);\n            }\n          } catch (Throwable t) {\n\n            if (Thread.interrupted()) {\n              // The timer cancelled the command in the mean while, clear the\n              // interrupt flag\n              LOG.info(\"Stop-container for \" + event.getContainerID()\n                  + \" got interrupted.\");\n            }\n\n            // ignore the cleanup failure\n            String message \u003d \"cleanup failed for container \"\n                + event.getContainerID() + \" : \"\n                + StringUtils.stringifyException(t);\n            context.getEventHandler()\n                .handle(\n                    new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                        message));\n            LOG.warn(message);\n          } finally {\n            timerTask.cancel();\n            if (Thread.interrupted()) {\n              LOG.info(\"Stop-container for \" + event.getContainerID()\n                  + \" got interrupted.\");\n              // ignore the cleanup failure\n              context.getEventHandler()\n                  .handle(new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                    \"cleanup failed for container \" + event.getContainerID()));\n            }\n            if (proxy !\u003d null) {\n              ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n            }\n          }\n\n          // after killing, send killed event to taskattempt\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(event.getTaskAttemptID(),\n                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n        }\n        break;\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "00b50a5c94df63668b07ca1623c40fe7252f1322": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3355. Fixed MR AM\u0027s ContainerLauncher to handle node-command timeouts correctly. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1202744 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/11/11 7:37 AM",
      "commitName": "00b50a5c94df63668b07ca1623c40fe7252f1322",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "09/11/11 5:41 AM",
      "commitNameOld": "2df83e5b4d7a3516a9c7ec11309023e3c42a869b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.08,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,168 @@\n     public void run() {\n       LOG.info(\"Processing the event \" + event.toString());\n \n       // Load ContainerManager tokens before creating a connection.\n       // TODO: Do it only once per NodeManager.\n       final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n       ContainerId containerID \u003d event.getContainerID();\n       ContainerToken containerToken \u003d event.getContainerToken();\n       TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n \n-      Timer timer \u003d new Timer(true);\n-\n       ContainerManager proxy \u003d null;\n \n+      CommandTimerTask timerTask \u003d new CommandTimerTask(Thread\n+          .currentThread(), event);\n+\n       switch(event.getType()) {\n \n       case CONTAINER_REMOTE_LAUNCH:\n         ContainerRemoteLaunchEvent launchEvent\n             \u003d (ContainerRemoteLaunchEvent) event;\n \n         try {\n-          timer.schedule(new CommandTimer(Thread.currentThread(), event),\n-              nmTimeOut);\n+          commandTimer.schedule(timerTask, nmTimeOut);\n \n           proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n               containerToken);\n \n           // Interruped during getProxy, but that didn\u0027t throw exception\n-          if (Thread.currentThread().isInterrupted()) {\n+          if (Thread.interrupted()) {\n             // The timer cancelled the command in the mean while.\n-            String message \u003d \"Start-container for \" + event.getContainerID()\n+            String message \u003d \"Container launch failed for \" + containerID\n+                + \" : Start-container for \" + event.getContainerID()\n                 + \" got interrupted. Returning.\";\n             sendContainerLaunchFailedMsg(taskAttemptID, message);\n             return;\n           }\n \n           // Construct the actual Container\n           ContainerLaunchContext containerLaunchContext \u003d\n               launchEvent.getContainer();\n \n           // Now launch the actual container\n           StartContainerRequest startRequest \u003d Records\n               .newRecord(StartContainerRequest.class);\n           startRequest.setContainerLaunchContext(containerLaunchContext);\n           StartContainerResponse response \u003d proxy.startContainer(startRequest);\n \n           // container started properly. Stop the timer\n-          timer.cancel();\n-          if (Thread.currentThread().isInterrupted()) {\n+          timerTask.cancel();\n+          if (Thread.interrupted()) {\n             // The timer cancelled the command in the mean while, but\n             // startContainer didn\u0027t throw exception\n-            String message \u003d \"Start-container for \" + event.getContainerID()\n+            String message \u003d \"Container launch failed for \" + containerID\n+                + \" : Start-container for \" + event.getContainerID()\n                 + \" got interrupted. Returning.\";\n             sendContainerLaunchFailedMsg(taskAttemptID, message);\n             return;\n           }\n \n           ByteBuffer portInfo \u003d response\n               .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n           int port \u003d -1;\n           if(portInfo !\u003d null) {\n             port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n           }\n           LOG.info(\"Shuffle port returned by ContainerManager for \"\n               + taskAttemptID + \" : \" + port);\n           \n           if(port \u003c 0) {\n             throw new IllegalStateException(\"Invalid shuffle port number \"\n                 + port + \" returned for \" + taskAttemptID);\n           }\n \n           // after launching, send launched event to task attempt to move\n           // it from ASSIGNED to RUNNING state\n           context.getEventHandler().handle(\n               new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n         } catch (Throwable t) {\n+          if (Thread.interrupted()) {\n+            // The timer cancelled the command in the mean while.\n+            LOG.info(\"Start-container for \" + event.getContainerID()\n+                + \" got interrupted.\");\n+          }\n           String message \u003d \"Container launch failed for \" + containerID\n               + \" : \" + StringUtils.stringifyException(t);\n           sendContainerLaunchFailedMsg(taskAttemptID, message);\n         } finally {\n-          timer.cancel();\n-          ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n+          timerTask.cancel();\n+          if (proxy !\u003d null) {\n+            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n+          }\n         }\n \n         break;\n \n       case CONTAINER_REMOTE_CLEANUP:\n         // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n         // and not yet processed\n         if (eventQueue.contains(event)) {\n           eventQueue.remove(event); // TODO: Any synchro needed?\n           //deallocate the container\n           context.getEventHandler().handle(\n               new ContainerAllocatorEvent(taskAttemptID,\n                   ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n         } else {\n \n           try {\n-            timer.schedule(new CommandTimer(Thread.currentThread(), event),\n-                nmTimeOut);\n+            commandTimer.schedule(timerTask, nmTimeOut);\n \n             proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n                 containerToken);\n \n-            if (Thread.currentThread().isInterrupted()) {\n+            if (Thread.interrupted()) {\n               // The timer cancelled the command in the mean while. No need to\n               // return, send cleanedup event anyways.\n               LOG.info(\"Stop-container for \" + event.getContainerID()\n                   + \" got interrupted.\");\n             } else {\n \n               // TODO:check whether container is launched\n \n               // kill the remote container if already launched\n               StopContainerRequest stopRequest \u003d Records\n                   .newRecord(StopContainerRequest.class);\n               stopRequest.setContainerId(event.getContainerID());\n               proxy.stopContainer(stopRequest);\n             }\n           } catch (Throwable t) {\n+\n+            if (Thread.interrupted()) {\n+              // The timer cancelled the command in the mean while, clear the\n+              // interrupt flag\n+              LOG.info(\"Stop-container for \" + event.getContainerID()\n+                  + \" got interrupted.\");\n+            }\n+\n             // ignore the cleanup failure\n             String message \u003d \"cleanup failed for container \"\n                 + event.getContainerID() + \" : \"\n                 + StringUtils.stringifyException(t);\n             context.getEventHandler()\n                 .handle(\n                     new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                         message));\n             LOG.warn(message);\n           } finally {\n-            timer.cancel();\n-            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n+            timerTask.cancel();\n+            if (Thread.interrupted()) {\n+              LOG.info(\"Stop-container for \" + event.getContainerID()\n+                  + \" got interrupted.\");\n+              // ignore the cleanup failure\n+              context.getEventHandler()\n+                  .handle(new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n+                    \"cleanup failed for container \" + event.getContainerID()));\n+            }\n+            if (proxy !\u003d null) {\n+              ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n+            }\n           }\n \n           // after killing, send killed event to taskattempt\n           context.getEventHandler().handle(\n               new TaskAttemptEvent(event.getTaskAttemptID(),\n                   TaskAttemptEventType.TA_CONTAINER_CLEANED));\n         }\n         break;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n      ContainerId containerID \u003d event.getContainerID();\n      ContainerToken containerToken \u003d event.getContainerToken();\n      TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n\n      ContainerManager proxy \u003d null;\n\n      CommandTimerTask timerTask \u003d new CommandTimerTask(Thread\n          .currentThread(), event);\n\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEvent\n            \u003d (ContainerRemoteLaunchEvent) event;\n\n        try {\n          commandTimer.schedule(timerTask, nmTimeOut);\n\n          proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n              containerToken);\n\n          // Interruped during getProxy, but that didn\u0027t throw exception\n          if (Thread.interrupted()) {\n            // The timer cancelled the command in the mean while.\n            String message \u003d \"Container launch failed for \" + containerID\n                + \" : Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          // Construct the actual Container\n          ContainerLaunchContext containerLaunchContext \u003d\n              launchEvent.getContainer();\n\n          // Now launch the actual container\n          StartContainerRequest startRequest \u003d Records\n              .newRecord(StartContainerRequest.class);\n          startRequest.setContainerLaunchContext(containerLaunchContext);\n          StartContainerResponse response \u003d proxy.startContainer(startRequest);\n\n          // container started properly. Stop the timer\n          timerTask.cancel();\n          if (Thread.interrupted()) {\n            // The timer cancelled the command in the mean while, but\n            // startContainer didn\u0027t throw exception\n            String message \u003d \"Container launch failed for \" + containerID\n                + \" : Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          ByteBuffer portInfo \u003d response\n              .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n          int port \u003d -1;\n          if(portInfo !\u003d null) {\n            port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n          }\n          LOG.info(\"Shuffle port returned by ContainerManager for \"\n              + taskAttemptID + \" : \" + port);\n          \n          if(port \u003c 0) {\n            throw new IllegalStateException(\"Invalid shuffle port number \"\n                + port + \" returned for \" + taskAttemptID);\n          }\n\n          // after launching, send launched event to task attempt to move\n          // it from ASSIGNED to RUNNING state\n          context.getEventHandler().handle(\n              new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n        } catch (Throwable t) {\n          if (Thread.interrupted()) {\n            // The timer cancelled the command in the mean while.\n            LOG.info(\"Start-container for \" + event.getContainerID()\n                + \" got interrupted.\");\n          }\n          String message \u003d \"Container launch failed for \" + containerID\n              + \" : \" + StringUtils.stringifyException(t);\n          sendContainerLaunchFailedMsg(taskAttemptID, message);\n        } finally {\n          timerTask.cancel();\n          if (proxy !\u003d null) {\n            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n          }\n        }\n\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n        // and not yet processed\n        if (eventQueue.contains(event)) {\n          eventQueue.remove(event); // TODO: Any synchro needed?\n          //deallocate the container\n          context.getEventHandler().handle(\n              new ContainerAllocatorEvent(taskAttemptID,\n                  ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n        } else {\n\n          try {\n            commandTimer.schedule(timerTask, nmTimeOut);\n\n            proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n                containerToken);\n\n            if (Thread.interrupted()) {\n              // The timer cancelled the command in the mean while. No need to\n              // return, send cleanedup event anyways.\n              LOG.info(\"Stop-container for \" + event.getContainerID()\n                  + \" got interrupted.\");\n            } else {\n\n              // TODO:check whether container is launched\n\n              // kill the remote container if already launched\n              StopContainerRequest stopRequest \u003d Records\n                  .newRecord(StopContainerRequest.class);\n              stopRequest.setContainerId(event.getContainerID());\n              proxy.stopContainer(stopRequest);\n            }\n          } catch (Throwable t) {\n\n            if (Thread.interrupted()) {\n              // The timer cancelled the command in the mean while, clear the\n              // interrupt flag\n              LOG.info(\"Stop-container for \" + event.getContainerID()\n                  + \" got interrupted.\");\n            }\n\n            // ignore the cleanup failure\n            String message \u003d \"cleanup failed for container \"\n                + event.getContainerID() + \" : \"\n                + StringUtils.stringifyException(t);\n            context.getEventHandler()\n                .handle(\n                    new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                        message));\n            LOG.warn(message);\n          } finally {\n            timerTask.cancel();\n            if (Thread.interrupted()) {\n              LOG.info(\"Stop-container for \" + event.getContainerID()\n                  + \" got interrupted.\");\n              // ignore the cleanup failure\n              context.getEventHandler()\n                  .handle(new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                    \"cleanup failed for container \" + event.getContainerID()));\n            }\n            if (proxy !\u003d null) {\n              ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n            }\n          }\n\n          // after killing, send killed event to taskattempt\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(event.getTaskAttemptID(),\n                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n        }\n        break;\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "2df83e5b4d7a3516a9c7ec11309023e3c42a869b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3333. Fixed bugs in ContainerLauncher of MR AppMaster due to which per-container connections to NodeManager were lingering long enough to hit the ulimits on number of processes. (vinodkv)  \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1199751 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/11/11 5:41 AM",
      "commitName": "2df83e5b4d7a3516a9c7ec11309023e3c42a869b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "29/10/11 2:35 AM",
      "commitNameOld": "7f4dc277572df6ba25fa961073b99a5bdb086c00",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 11.17,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,138 +1,142 @@\n     public void run() {\n       LOG.info(\"Processing the event \" + event.toString());\n \n       // Load ContainerManager tokens before creating a connection.\n       // TODO: Do it only once per NodeManager.\n       final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n       ContainerId containerID \u003d event.getContainerID();\n       ContainerToken containerToken \u003d event.getContainerToken();\n       TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n \n       Timer timer \u003d new Timer(true);\n \n+      ContainerManager proxy \u003d null;\n+\n       switch(event.getType()) {\n \n       case CONTAINER_REMOTE_LAUNCH:\n         ContainerRemoteLaunchEvent launchEvent\n             \u003d (ContainerRemoteLaunchEvent) event;\n \n         try {\n           timer.schedule(new CommandTimer(Thread.currentThread(), event),\n               nmTimeOut);\n \n-          ContainerManager proxy \u003d getCMProxy(containerID,\n-              containerManagerBindAddr, containerToken);\n+          proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n+              containerToken);\n \n           // Interruped during getProxy, but that didn\u0027t throw exception\n           if (Thread.currentThread().isInterrupted()) {\n             // The timer cancelled the command in the mean while.\n             String message \u003d \"Start-container for \" + event.getContainerID()\n                 + \" got interrupted. Returning.\";\n             sendContainerLaunchFailedMsg(taskAttemptID, message);\n             return;\n           }\n \n           // Construct the actual Container\n           ContainerLaunchContext containerLaunchContext \u003d\n               launchEvent.getContainer();\n \n           // Now launch the actual container\n-          StartContainerRequest startRequest \u003d recordFactory\n-              .newRecordInstance(StartContainerRequest.class);\n+          StartContainerRequest startRequest \u003d Records\n+              .newRecord(StartContainerRequest.class);\n           startRequest.setContainerLaunchContext(containerLaunchContext);\n           StartContainerResponse response \u003d proxy.startContainer(startRequest);\n \n           // container started properly. Stop the timer\n           timer.cancel();\n           if (Thread.currentThread().isInterrupted()) {\n             // The timer cancelled the command in the mean while, but\n             // startContainer didn\u0027t throw exception\n             String message \u003d \"Start-container for \" + event.getContainerID()\n                 + \" got interrupted. Returning.\";\n             sendContainerLaunchFailedMsg(taskAttemptID, message);\n             return;\n           }\n \n           ByteBuffer portInfo \u003d response\n               .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n           int port \u003d -1;\n           if(portInfo !\u003d null) {\n             port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n           }\n           LOG.info(\"Shuffle port returned by ContainerManager for \"\n               + taskAttemptID + \" : \" + port);\n           \n           if(port \u003c 0) {\n             throw new IllegalStateException(\"Invalid shuffle port number \"\n                 + port + \" returned for \" + taskAttemptID);\n           }\n \n           // after launching, send launched event to task attempt to move\n           // it from ASSIGNED to RUNNING state\n           context.getEventHandler().handle(\n               new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n         } catch (Throwable t) {\n           String message \u003d \"Container launch failed for \" + containerID\n               + \" : \" + StringUtils.stringifyException(t);\n           sendContainerLaunchFailedMsg(taskAttemptID, message);\n         } finally {\n           timer.cancel();\n+          ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n         }\n \n         break;\n \n       case CONTAINER_REMOTE_CLEANUP:\n         // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n         // and not yet processed\n         if (eventQueue.contains(event)) {\n           eventQueue.remove(event); // TODO: Any synchro needed?\n           //deallocate the container\n           context.getEventHandler().handle(\n               new ContainerAllocatorEvent(taskAttemptID,\n                   ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n         } else {\n \n           try {\n             timer.schedule(new CommandTimer(Thread.currentThread(), event),\n                 nmTimeOut);\n \n-            ContainerManager proxy \u003d getCMProxy(containerID,\n-                containerManagerBindAddr, containerToken);\n+            proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n+                containerToken);\n \n             if (Thread.currentThread().isInterrupted()) {\n               // The timer cancelled the command in the mean while. No need to\n               // return, send cleanedup event anyways.\n               LOG.info(\"Stop-container for \" + event.getContainerID()\n                   + \" got interrupted.\");\n             } else {\n \n               // TODO:check whether container is launched\n \n               // kill the remote container if already launched\n-              StopContainerRequest stopRequest \u003d recordFactory\n-                  .newRecordInstance(StopContainerRequest.class);\n+              StopContainerRequest stopRequest \u003d Records\n+                  .newRecord(StopContainerRequest.class);\n               stopRequest.setContainerId(event.getContainerID());\n               proxy.stopContainer(stopRequest);\n             }\n           } catch (Throwable t) {\n             // ignore the cleanup failure\n             String message \u003d \"cleanup failed for container \"\n                 + event.getContainerID() + \" : \"\n                 + StringUtils.stringifyException(t);\n             context.getEventHandler()\n                 .handle(\n                     new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                         message));\n             LOG.warn(message);\n           } finally {\n             timer.cancel();\n+            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n           }\n \n           // after killing, send killed event to taskattempt\n           context.getEventHandler().handle(\n               new TaskAttemptEvent(event.getTaskAttemptID(),\n                   TaskAttemptEventType.TA_CONTAINER_CLEANED));\n         }\n         break;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n      ContainerId containerID \u003d event.getContainerID();\n      ContainerToken containerToken \u003d event.getContainerToken();\n      TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n\n      Timer timer \u003d new Timer(true);\n\n      ContainerManager proxy \u003d null;\n\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEvent\n            \u003d (ContainerRemoteLaunchEvent) event;\n\n        try {\n          timer.schedule(new CommandTimer(Thread.currentThread(), event),\n              nmTimeOut);\n\n          proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n              containerToken);\n\n          // Interruped during getProxy, but that didn\u0027t throw exception\n          if (Thread.currentThread().isInterrupted()) {\n            // The timer cancelled the command in the mean while.\n            String message \u003d \"Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          // Construct the actual Container\n          ContainerLaunchContext containerLaunchContext \u003d\n              launchEvent.getContainer();\n\n          // Now launch the actual container\n          StartContainerRequest startRequest \u003d Records\n              .newRecord(StartContainerRequest.class);\n          startRequest.setContainerLaunchContext(containerLaunchContext);\n          StartContainerResponse response \u003d proxy.startContainer(startRequest);\n\n          // container started properly. Stop the timer\n          timer.cancel();\n          if (Thread.currentThread().isInterrupted()) {\n            // The timer cancelled the command in the mean while, but\n            // startContainer didn\u0027t throw exception\n            String message \u003d \"Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          ByteBuffer portInfo \u003d response\n              .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n          int port \u003d -1;\n          if(portInfo !\u003d null) {\n            port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n          }\n          LOG.info(\"Shuffle port returned by ContainerManager for \"\n              + taskAttemptID + \" : \" + port);\n          \n          if(port \u003c 0) {\n            throw new IllegalStateException(\"Invalid shuffle port number \"\n                + port + \" returned for \" + taskAttemptID);\n          }\n\n          // after launching, send launched event to task attempt to move\n          // it from ASSIGNED to RUNNING state\n          context.getEventHandler().handle(\n              new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n        } catch (Throwable t) {\n          String message \u003d \"Container launch failed for \" + containerID\n              + \" : \" + StringUtils.stringifyException(t);\n          sendContainerLaunchFailedMsg(taskAttemptID, message);\n        } finally {\n          timer.cancel();\n          ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n        }\n\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n        // and not yet processed\n        if (eventQueue.contains(event)) {\n          eventQueue.remove(event); // TODO: Any synchro needed?\n          //deallocate the container\n          context.getEventHandler().handle(\n              new ContainerAllocatorEvent(taskAttemptID,\n                  ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n        } else {\n\n          try {\n            timer.schedule(new CommandTimer(Thread.currentThread(), event),\n                nmTimeOut);\n\n            proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n                containerToken);\n\n            if (Thread.currentThread().isInterrupted()) {\n              // The timer cancelled the command in the mean while. No need to\n              // return, send cleanedup event anyways.\n              LOG.info(\"Stop-container for \" + event.getContainerID()\n                  + \" got interrupted.\");\n            } else {\n\n              // TODO:check whether container is launched\n\n              // kill the remote container if already launched\n              StopContainerRequest stopRequest \u003d Records\n                  .newRecord(StopContainerRequest.class);\n              stopRequest.setContainerId(event.getContainerID());\n              proxy.stopContainer(stopRequest);\n            }\n          } catch (Throwable t) {\n            // ignore the cleanup failure\n            String message \u003d \"cleanup failed for container \"\n                + event.getContainerID() + \" : \"\n                + StringUtils.stringifyException(t);\n            context.getEventHandler()\n                .handle(\n                    new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                        message));\n            LOG.warn(message);\n          } finally {\n            timer.cancel();\n            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n          }\n\n          // after killing, send killed event to taskattempt\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(event.getTaskAttemptID(),\n                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n        }\n        break;\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "7f4dc277572df6ba25fa961073b99a5bdb086c00": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3256. Added authorization checks for the protocol between NodeManager and ApplicationMaster. Contributed by Vinod K V.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1194850 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/10/11 2:35 AM",
      "commitName": "7f4dc277572df6ba25fa961073b99a5bdb086c00",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "27/10/11 10:32 AM",
      "commitNameOld": "724f21734316343873386a14059a347067d65a10",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.67,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,138 +1,138 @@\n     public void run() {\n       LOG.info(\"Processing the event \" + event.toString());\n \n       // Load ContainerManager tokens before creating a connection.\n       // TODO: Do it only once per NodeManager.\n       final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n       ContainerId containerID \u003d event.getContainerID();\n       ContainerToken containerToken \u003d event.getContainerToken();\n       TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n \n       Timer timer \u003d new Timer(true);\n \n       switch(event.getType()) {\n \n       case CONTAINER_REMOTE_LAUNCH:\n         ContainerRemoteLaunchEvent launchEvent\n             \u003d (ContainerRemoteLaunchEvent) event;\n \n         try {\n           timer.schedule(new CommandTimer(Thread.currentThread(), event),\n               nmTimeOut);\n \n-          ContainerManager proxy \u003d getCMProxy(containerManagerBindAddr,\n-              containerToken);\n+          ContainerManager proxy \u003d getCMProxy(containerID,\n+              containerManagerBindAddr, containerToken);\n \n           // Interruped during getProxy, but that didn\u0027t throw exception\n           if (Thread.currentThread().isInterrupted()) {\n             // The timer cancelled the command in the mean while.\n             String message \u003d \"Start-container for \" + event.getContainerID()\n                 + \" got interrupted. Returning.\";\n             sendContainerLaunchFailedMsg(taskAttemptID, message);\n             return;\n           }\n \n           // Construct the actual Container\n           ContainerLaunchContext containerLaunchContext \u003d\n               launchEvent.getContainer();\n \n           // Now launch the actual container\n           StartContainerRequest startRequest \u003d recordFactory\n               .newRecordInstance(StartContainerRequest.class);\n           startRequest.setContainerLaunchContext(containerLaunchContext);\n           StartContainerResponse response \u003d proxy.startContainer(startRequest);\n \n           // container started properly. Stop the timer\n           timer.cancel();\n           if (Thread.currentThread().isInterrupted()) {\n             // The timer cancelled the command in the mean while, but\n             // startContainer didn\u0027t throw exception\n             String message \u003d \"Start-container for \" + event.getContainerID()\n                 + \" got interrupted. Returning.\";\n             sendContainerLaunchFailedMsg(taskAttemptID, message);\n             return;\n           }\n \n           ByteBuffer portInfo \u003d response\n               .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n           int port \u003d -1;\n           if(portInfo !\u003d null) {\n             port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n           }\n           LOG.info(\"Shuffle port returned by ContainerManager for \"\n               + taskAttemptID + \" : \" + port);\n           \n           if(port \u003c 0) {\n             throw new IllegalStateException(\"Invalid shuffle port number \"\n                 + port + \" returned for \" + taskAttemptID);\n           }\n \n           // after launching, send launched event to task attempt to move\n           // it from ASSIGNED to RUNNING state\n           context.getEventHandler().handle(\n               new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n         } catch (Throwable t) {\n           String message \u003d \"Container launch failed for \" + containerID\n               + \" : \" + StringUtils.stringifyException(t);\n           sendContainerLaunchFailedMsg(taskAttemptID, message);\n         } finally {\n           timer.cancel();\n         }\n \n         break;\n \n       case CONTAINER_REMOTE_CLEANUP:\n         // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n         // and not yet processed\n         if (eventQueue.contains(event)) {\n           eventQueue.remove(event); // TODO: Any synchro needed?\n           //deallocate the container\n           context.getEventHandler().handle(\n               new ContainerAllocatorEvent(taskAttemptID,\n                   ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n         } else {\n \n           try {\n             timer.schedule(new CommandTimer(Thread.currentThread(), event),\n                 nmTimeOut);\n \n-            ContainerManager proxy \u003d getCMProxy(containerManagerBindAddr,\n-                containerToken);\n+            ContainerManager proxy \u003d getCMProxy(containerID,\n+                containerManagerBindAddr, containerToken);\n \n             if (Thread.currentThread().isInterrupted()) {\n               // The timer cancelled the command in the mean while. No need to\n               // return, send cleanedup event anyways.\n               LOG.info(\"Stop-container for \" + event.getContainerID()\n                   + \" got interrupted.\");\n             } else {\n \n               // TODO:check whether container is launched\n \n               // kill the remote container if already launched\n               StopContainerRequest stopRequest \u003d recordFactory\n                   .newRecordInstance(StopContainerRequest.class);\n               stopRequest.setContainerId(event.getContainerID());\n               proxy.stopContainer(stopRequest);\n             }\n           } catch (Throwable t) {\n             // ignore the cleanup failure\n             String message \u003d \"cleanup failed for container \"\n                 + event.getContainerID() + \" : \"\n                 + StringUtils.stringifyException(t);\n             context.getEventHandler()\n                 .handle(\n                     new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                         message));\n             LOG.warn(message);\n           } finally {\n             timer.cancel();\n           }\n \n           // after killing, send killed event to taskattempt\n           context.getEventHandler().handle(\n               new TaskAttemptEvent(event.getTaskAttemptID(),\n                   TaskAttemptEventType.TA_CONTAINER_CLEANED));\n         }\n         break;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n      ContainerId containerID \u003d event.getContainerID();\n      ContainerToken containerToken \u003d event.getContainerToken();\n      TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n\n      Timer timer \u003d new Timer(true);\n\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEvent\n            \u003d (ContainerRemoteLaunchEvent) event;\n\n        try {\n          timer.schedule(new CommandTimer(Thread.currentThread(), event),\n              nmTimeOut);\n\n          ContainerManager proxy \u003d getCMProxy(containerID,\n              containerManagerBindAddr, containerToken);\n\n          // Interruped during getProxy, but that didn\u0027t throw exception\n          if (Thread.currentThread().isInterrupted()) {\n            // The timer cancelled the command in the mean while.\n            String message \u003d \"Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          // Construct the actual Container\n          ContainerLaunchContext containerLaunchContext \u003d\n              launchEvent.getContainer();\n\n          // Now launch the actual container\n          StartContainerRequest startRequest \u003d recordFactory\n              .newRecordInstance(StartContainerRequest.class);\n          startRequest.setContainerLaunchContext(containerLaunchContext);\n          StartContainerResponse response \u003d proxy.startContainer(startRequest);\n\n          // container started properly. Stop the timer\n          timer.cancel();\n          if (Thread.currentThread().isInterrupted()) {\n            // The timer cancelled the command in the mean while, but\n            // startContainer didn\u0027t throw exception\n            String message \u003d \"Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          ByteBuffer portInfo \u003d response\n              .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n          int port \u003d -1;\n          if(portInfo !\u003d null) {\n            port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n          }\n          LOG.info(\"Shuffle port returned by ContainerManager for \"\n              + taskAttemptID + \" : \" + port);\n          \n          if(port \u003c 0) {\n            throw new IllegalStateException(\"Invalid shuffle port number \"\n                + port + \" returned for \" + taskAttemptID);\n          }\n\n          // after launching, send launched event to task attempt to move\n          // it from ASSIGNED to RUNNING state\n          context.getEventHandler().handle(\n              new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n        } catch (Throwable t) {\n          String message \u003d \"Container launch failed for \" + containerID\n              + \" : \" + StringUtils.stringifyException(t);\n          sendContainerLaunchFailedMsg(taskAttemptID, message);\n        } finally {\n          timer.cancel();\n        }\n\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n        // and not yet processed\n        if (eventQueue.contains(event)) {\n          eventQueue.remove(event); // TODO: Any synchro needed?\n          //deallocate the container\n          context.getEventHandler().handle(\n              new ContainerAllocatorEvent(taskAttemptID,\n                  ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n        } else {\n\n          try {\n            timer.schedule(new CommandTimer(Thread.currentThread(), event),\n                nmTimeOut);\n\n            ContainerManager proxy \u003d getCMProxy(containerID,\n                containerManagerBindAddr, containerToken);\n\n            if (Thread.currentThread().isInterrupted()) {\n              // The timer cancelled the command in the mean while. No need to\n              // return, send cleanedup event anyways.\n              LOG.info(\"Stop-container for \" + event.getContainerID()\n                  + \" got interrupted.\");\n            } else {\n\n              // TODO:check whether container is launched\n\n              // kill the remote container if already launched\n              StopContainerRequest stopRequest \u003d recordFactory\n                  .newRecordInstance(StopContainerRequest.class);\n              stopRequest.setContainerId(event.getContainerID());\n              proxy.stopContainer(stopRequest);\n            }\n          } catch (Throwable t) {\n            // ignore the cleanup failure\n            String message \u003d \"cleanup failed for container \"\n                + event.getContainerID() + \" : \"\n                + StringUtils.stringifyException(t);\n            context.getEventHandler()\n                .handle(\n                    new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                        message));\n            LOG.warn(message);\n          } finally {\n            timer.cancel();\n          }\n\n          // after killing, send killed event to taskattempt\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(event.getTaskAttemptID(),\n                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n        }\n        break;\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "724f21734316343873386a14059a347067d65a10": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3228. Fixed MR AM to timeout RPCs to bad NodeManagers. Contributed by Vinod K V.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189879 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 10:32 AM",
      "commitName": "724f21734316343873386a14059a347067d65a10",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "26/10/11 11:24 PM",
      "commitNameOld": "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.46,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,138 @@\n     public void run() {\n       LOG.info(\"Processing the event \" + event.toString());\n \n       // Load ContainerManager tokens before creating a connection.\n       // TODO: Do it only once per NodeManager.\n       final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n       ContainerId containerID \u003d event.getContainerID();\n       ContainerToken containerToken \u003d event.getContainerToken();\n+      TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n+\n+      Timer timer \u003d new Timer(true);\n \n       switch(event.getType()) {\n \n       case CONTAINER_REMOTE_LAUNCH:\n-        ContainerRemoteLaunchEvent launchEv \u003d (ContainerRemoteLaunchEvent) event;\n+        ContainerRemoteLaunchEvent launchEvent\n+            \u003d (ContainerRemoteLaunchEvent) event;\n \n-        TaskAttemptId taskAttemptID \u003d launchEv.getTaskAttemptID();\n         try {\n-          \n-          ContainerManager proxy \u003d \n-            getCMProxy(containerID, containerManagerBindAddr, containerToken);\n-          \n+          timer.schedule(new CommandTimer(Thread.currentThread(), event),\n+              nmTimeOut);\n+\n+          ContainerManager proxy \u003d getCMProxy(containerManagerBindAddr,\n+              containerToken);\n+\n+          // Interruped during getProxy, but that didn\u0027t throw exception\n+          if (Thread.currentThread().isInterrupted()) {\n+            // The timer cancelled the command in the mean while.\n+            String message \u003d \"Start-container for \" + event.getContainerID()\n+                + \" got interrupted. Returning.\";\n+            sendContainerLaunchFailedMsg(taskAttemptID, message);\n+            return;\n+          }\n+\n           // Construct the actual Container\n           ContainerLaunchContext containerLaunchContext \u003d\n-              launchEv.getContainer();\n+              launchEvent.getContainer();\n \n           // Now launch the actual container\n           StartContainerRequest startRequest \u003d recordFactory\n               .newRecordInstance(StartContainerRequest.class);\n           startRequest.setContainerLaunchContext(containerLaunchContext);\n           StartContainerResponse response \u003d proxy.startContainer(startRequest);\n+\n+          // container started properly. Stop the timer\n+          timer.cancel();\n+          if (Thread.currentThread().isInterrupted()) {\n+            // The timer cancelled the command in the mean while, but\n+            // startContainer didn\u0027t throw exception\n+            String message \u003d \"Start-container for \" + event.getContainerID()\n+                + \" got interrupted. Returning.\";\n+            sendContainerLaunchFailedMsg(taskAttemptID, message);\n+            return;\n+          }\n+\n           ByteBuffer portInfo \u003d response\n               .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n           int port \u003d -1;\n           if(portInfo !\u003d null) {\n             port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n           }\n           LOG.info(\"Shuffle port returned by ContainerManager for \"\n               + taskAttemptID + \" : \" + port);\n           \n           if(port \u003c 0) {\n             throw new IllegalStateException(\"Invalid shuffle port number \"\n                 + port + \" returned for \" + taskAttemptID);\n           }\n \n           // after launching, send launched event to task attempt to move\n           // it from ASSIGNED to RUNNING state\n           context.getEventHandler().handle(\n               new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n         } catch (Throwable t) {\n           String message \u003d \"Container launch failed for \" + containerID\n               + \" : \" + StringUtils.stringifyException(t);\n-          LOG.error(message);\n-          context.getEventHandler().handle(\n-              new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n-          context.getEventHandler().handle(\n-              new TaskAttemptEvent(taskAttemptID,\n-                  TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED));\n+          sendContainerLaunchFailedMsg(taskAttemptID, message);\n+        } finally {\n+          timer.cancel();\n         }\n \n         break;\n \n       case CONTAINER_REMOTE_CLEANUP:\n         // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n         // and not yet processed\n         if (eventQueue.contains(event)) {\n           eventQueue.remove(event); // TODO: Any synchro needed?\n           //deallocate the container\n           context.getEventHandler().handle(\n-              new ContainerAllocatorEvent(event.getTaskAttemptID(),\n-              ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n+              new ContainerAllocatorEvent(taskAttemptID,\n+                  ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n         } else {\n+\n           try {\n-            ContainerManager proxy \u003d \n-              getCMProxy(containerID, containerManagerBindAddr, containerToken);\n-            // TODO:check whether container is launched\n+            timer.schedule(new CommandTimer(Thread.currentThread(), event),\n+                nmTimeOut);\n \n-            // kill the remote container if already launched\n-            StopContainerRequest stopRequest \u003d recordFactory\n-                .newRecordInstance(StopContainerRequest.class);\n-            stopRequest.setContainerId(event.getContainerID());\n-            proxy.stopContainer(stopRequest);\n+            ContainerManager proxy \u003d getCMProxy(containerManagerBindAddr,\n+                containerToken);\n \n+            if (Thread.currentThread().isInterrupted()) {\n+              // The timer cancelled the command in the mean while. No need to\n+              // return, send cleanedup event anyways.\n+              LOG.info(\"Stop-container for \" + event.getContainerID()\n+                  + \" got interrupted.\");\n+            } else {\n+\n+              // TODO:check whether container is launched\n+\n+              // kill the remote container if already launched\n+              StopContainerRequest stopRequest \u003d recordFactory\n+                  .newRecordInstance(StopContainerRequest.class);\n+              stopRequest.setContainerId(event.getContainerID());\n+              proxy.stopContainer(stopRequest);\n+            }\n           } catch (Throwable t) {\n-            //ignore the cleanup failure\n-            LOG.warn(\"cleanup failed for container \" + event.getContainerID() ,\n-                t);\n+            // ignore the cleanup failure\n+            String message \u003d \"cleanup failed for container \"\n+                + event.getContainerID() + \" : \"\n+                + StringUtils.stringifyException(t);\n+            context.getEventHandler()\n+                .handle(\n+                    new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n+                        message));\n+            LOG.warn(message);\n+          } finally {\n+            timer.cancel();\n           }\n \n           // after killing, send killed event to taskattempt\n           context.getEventHandler().handle(\n               new TaskAttemptEvent(event.getTaskAttemptID(),\n                   TaskAttemptEventType.TA_CONTAINER_CLEANED));\n         }\n         break;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n      ContainerId containerID \u003d event.getContainerID();\n      ContainerToken containerToken \u003d event.getContainerToken();\n      TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n\n      Timer timer \u003d new Timer(true);\n\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEvent\n            \u003d (ContainerRemoteLaunchEvent) event;\n\n        try {\n          timer.schedule(new CommandTimer(Thread.currentThread(), event),\n              nmTimeOut);\n\n          ContainerManager proxy \u003d getCMProxy(containerManagerBindAddr,\n              containerToken);\n\n          // Interruped during getProxy, but that didn\u0027t throw exception\n          if (Thread.currentThread().isInterrupted()) {\n            // The timer cancelled the command in the mean while.\n            String message \u003d \"Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          // Construct the actual Container\n          ContainerLaunchContext containerLaunchContext \u003d\n              launchEvent.getContainer();\n\n          // Now launch the actual container\n          StartContainerRequest startRequest \u003d recordFactory\n              .newRecordInstance(StartContainerRequest.class);\n          startRequest.setContainerLaunchContext(containerLaunchContext);\n          StartContainerResponse response \u003d proxy.startContainer(startRequest);\n\n          // container started properly. Stop the timer\n          timer.cancel();\n          if (Thread.currentThread().isInterrupted()) {\n            // The timer cancelled the command in the mean while, but\n            // startContainer didn\u0027t throw exception\n            String message \u003d \"Start-container for \" + event.getContainerID()\n                + \" got interrupted. Returning.\";\n            sendContainerLaunchFailedMsg(taskAttemptID, message);\n            return;\n          }\n\n          ByteBuffer portInfo \u003d response\n              .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n          int port \u003d -1;\n          if(portInfo !\u003d null) {\n            port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n          }\n          LOG.info(\"Shuffle port returned by ContainerManager for \"\n              + taskAttemptID + \" : \" + port);\n          \n          if(port \u003c 0) {\n            throw new IllegalStateException(\"Invalid shuffle port number \"\n                + port + \" returned for \" + taskAttemptID);\n          }\n\n          // after launching, send launched event to task attempt to move\n          // it from ASSIGNED to RUNNING state\n          context.getEventHandler().handle(\n              new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n        } catch (Throwable t) {\n          String message \u003d \"Container launch failed for \" + containerID\n              + \" : \" + StringUtils.stringifyException(t);\n          sendContainerLaunchFailedMsg(taskAttemptID, message);\n        } finally {\n          timer.cancel();\n        }\n\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n        // and not yet processed\n        if (eventQueue.contains(event)) {\n          eventQueue.remove(event); // TODO: Any synchro needed?\n          //deallocate the container\n          context.getEventHandler().handle(\n              new ContainerAllocatorEvent(taskAttemptID,\n                  ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n        } else {\n\n          try {\n            timer.schedule(new CommandTimer(Thread.currentThread(), event),\n                nmTimeOut);\n\n            ContainerManager proxy \u003d getCMProxy(containerManagerBindAddr,\n                containerToken);\n\n            if (Thread.currentThread().isInterrupted()) {\n              // The timer cancelled the command in the mean while. No need to\n              // return, send cleanedup event anyways.\n              LOG.info(\"Stop-container for \" + event.getContainerID()\n                  + \" got interrupted.\");\n            } else {\n\n              // TODO:check whether container is launched\n\n              // kill the remote container if already launched\n              StopContainerRequest stopRequest \u003d recordFactory\n                  .newRecordInstance(StopContainerRequest.class);\n              stopRequest.setContainerId(event.getContainerID());\n              proxy.stopContainer(stopRequest);\n            }\n          } catch (Throwable t) {\n            // ignore the cleanup failure\n            String message \u003d \"cleanup failed for container \"\n                + event.getContainerID() + \" : \"\n                + StringUtils.stringifyException(t);\n            context.getEventHandler()\n                .handle(\n                    new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                        message));\n            LOG.warn(message);\n          } finally {\n            timer.cancel();\n          }\n\n          // after killing, send killed event to taskattempt\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(event.getTaskAttemptID(),\n                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n        }\n        break;\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "ade0f0560f729e50382c6992f713f29e2dd5b270": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2652. Enabled multiple NMs to be runnable on a single node by making shuffle service port to be truely configurable. Contributed by Robert Joseph Evans.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1163585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/11 4:38 AM",
      "commitName": "ade0f0560f729e50382c6992f713f29e2dd5b270",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 6.48,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,95 @@\n     public void run() {\n       LOG.info(\"Processing the event \" + event.toString());\n \n       // Load ContainerManager tokens before creating a connection.\n       // TODO: Do it only once per NodeManager.\n       final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n       ContainerId containerID \u003d event.getContainerID();\n       ContainerToken containerToken \u003d event.getContainerToken();\n \n       switch(event.getType()) {\n \n       case CONTAINER_REMOTE_LAUNCH:\n         ContainerRemoteLaunchEvent launchEv \u003d (ContainerRemoteLaunchEvent) event;\n \n         TaskAttemptId taskAttemptID \u003d launchEv.getTaskAttemptID();\n         try {\n           \n           ContainerManager proxy \u003d \n             getCMProxy(containerID, containerManagerBindAddr, containerToken);\n           \n           // Construct the actual Container\n           ContainerLaunchContext containerLaunchContext \u003d\n               launchEv.getContainer();\n \n           // Now launch the actual container\n           StartContainerRequest startRequest \u003d recordFactory\n               .newRecordInstance(StartContainerRequest.class);\n           startRequest.setContainerLaunchContext(containerLaunchContext);\n-          proxy.startContainer(startRequest);\n-\n-          LOG.info(\"Returning from container-launch for \" + taskAttemptID);\n+          StartContainerResponse response \u003d proxy.startContainer(startRequest);\n+          ByteBuffer portInfo \u003d response\n+              .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n+          int port \u003d -1;\n+          if(portInfo !\u003d null) {\n+            port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n+          }\n+          LOG.info(\"Shuffle port returned by ContainerManager for \"\n+              + taskAttemptID + \" : \" + port);\n+          \n+          if(port \u003c 0) {\n+            throw new IllegalStateException(\"Invalid shuffle port number \"\n+                + port + \" returned for \" + taskAttemptID);\n+          }\n \n           // after launching, send launched event to task attempt to move\n           // it from ASSIGNED to RUNNING state\n           context.getEventHandler().handle(\n-              new TaskAttemptEvent(taskAttemptID,\n-                  TaskAttemptEventType.TA_CONTAINER_LAUNCHED));\n+              new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n         } catch (Throwable t) {\n           String message \u003d \"Container launch failed for \" + containerID\n               + \" : \" + StringUtils.stringifyException(t);\n           LOG.error(message);\n           context.getEventHandler().handle(\n               new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n           context.getEventHandler().handle(\n               new TaskAttemptEvent(taskAttemptID,\n                   TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED));\n         }\n \n         break;\n \n       case CONTAINER_REMOTE_CLEANUP:\n         // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n         // and not yet processed\n         if (eventQueue.contains(event)) {\n           eventQueue.remove(event); // TODO: Any synchro needed?\n           //deallocate the container\n           context.getEventHandler().handle(\n               new ContainerAllocatorEvent(event.getTaskAttemptID(),\n               ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n         } else {\n           try {\n             ContainerManager proxy \u003d \n               getCMProxy(containerID, containerManagerBindAddr, containerToken);\n             // TODO:check whether container is launched\n \n             // kill the remote container if already launched\n             StopContainerRequest stopRequest \u003d recordFactory\n                 .newRecordInstance(StopContainerRequest.class);\n             stopRequest.setContainerId(event.getContainerID());\n             proxy.stopContainer(stopRequest);\n \n           } catch (Throwable t) {\n             //ignore the cleanup failure\n             LOG.warn(\"cleanup failed for container \" + event.getContainerID() ,\n                 t);\n           }\n \n           // after killing, send killed event to taskattempt\n           context.getEventHandler().handle(\n               new TaskAttemptEvent(event.getTaskAttemptID(),\n                   TaskAttemptEventType.TA_CONTAINER_CLEANED));\n         }\n         break;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n      ContainerId containerID \u003d event.getContainerID();\n      ContainerToken containerToken \u003d event.getContainerToken();\n\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEv \u003d (ContainerRemoteLaunchEvent) event;\n\n        TaskAttemptId taskAttemptID \u003d launchEv.getTaskAttemptID();\n        try {\n          \n          ContainerManager proxy \u003d \n            getCMProxy(containerID, containerManagerBindAddr, containerToken);\n          \n          // Construct the actual Container\n          ContainerLaunchContext containerLaunchContext \u003d\n              launchEv.getContainer();\n\n          // Now launch the actual container\n          StartContainerRequest startRequest \u003d recordFactory\n              .newRecordInstance(StartContainerRequest.class);\n          startRequest.setContainerLaunchContext(containerLaunchContext);\n          StartContainerResponse response \u003d proxy.startContainer(startRequest);\n          ByteBuffer portInfo \u003d response\n              .getServiceResponse(ShuffleHandler.MAPREDUCE_SHUFFLE_SERVICEID);\n          int port \u003d -1;\n          if(portInfo !\u003d null) {\n            port \u003d ShuffleHandler.deserializeMetaData(portInfo);\n          }\n          LOG.info(\"Shuffle port returned by ContainerManager for \"\n              + taskAttemptID + \" : \" + port);\n          \n          if(port \u003c 0) {\n            throw new IllegalStateException(\"Invalid shuffle port number \"\n                + port + \" returned for \" + taskAttemptID);\n          }\n\n          // after launching, send launched event to task attempt to move\n          // it from ASSIGNED to RUNNING state\n          context.getEventHandler().handle(\n              new TaskAttemptContainerLaunchedEvent(taskAttemptID, port));\n        } catch (Throwable t) {\n          String message \u003d \"Container launch failed for \" + containerID\n              + \" : \" + StringUtils.stringifyException(t);\n          LOG.error(message);\n          context.getEventHandler().handle(\n              new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(taskAttemptID,\n                  TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED));\n        }\n\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n        // and not yet processed\n        if (eventQueue.contains(event)) {\n          eventQueue.remove(event); // TODO: Any synchro needed?\n          //deallocate the container\n          context.getEventHandler().handle(\n              new ContainerAllocatorEvent(event.getTaskAttemptID(),\n              ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n        } else {\n          try {\n            ContainerManager proxy \u003d \n              getCMProxy(containerID, containerManagerBindAddr, containerToken);\n            // TODO:check whether container is launched\n\n            // kill the remote container if already launched\n            StopContainerRequest stopRequest \u003d recordFactory\n                .newRecordInstance(StopContainerRequest.class);\n            stopRequest.setContainerId(event.getContainerID());\n            proxy.stopContainer(stopRequest);\n\n          } catch (Throwable t) {\n            //ignore the cleanup failure\n            LOG.warn(\"cleanup failed for container \" + event.getContainerID() ,\n                t);\n          }\n\n          // after killing, send killed event to taskattempt\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(event.getTaskAttemptID(),\n                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n        }\n        break;\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n      ContainerId containerID \u003d event.getContainerID();\n      ContainerToken containerToken \u003d event.getContainerToken();\n\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEv \u003d (ContainerRemoteLaunchEvent) event;\n\n        TaskAttemptId taskAttemptID \u003d launchEv.getTaskAttemptID();\n        try {\n          \n          ContainerManager proxy \u003d \n            getCMProxy(containerID, containerManagerBindAddr, containerToken);\n          \n          // Construct the actual Container\n          ContainerLaunchContext containerLaunchContext \u003d\n              launchEv.getContainer();\n\n          // Now launch the actual container\n          StartContainerRequest startRequest \u003d recordFactory\n              .newRecordInstance(StartContainerRequest.class);\n          startRequest.setContainerLaunchContext(containerLaunchContext);\n          proxy.startContainer(startRequest);\n\n          LOG.info(\"Returning from container-launch for \" + taskAttemptID);\n\n          // after launching, send launched event to task attempt to move\n          // it from ASSIGNED to RUNNING state\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(taskAttemptID,\n                  TaskAttemptEventType.TA_CONTAINER_LAUNCHED));\n        } catch (Throwable t) {\n          String message \u003d \"Container launch failed for \" + containerID\n              + \" : \" + StringUtils.stringifyException(t);\n          LOG.error(message);\n          context.getEventHandler().handle(\n              new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(taskAttemptID,\n                  TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED));\n        }\n\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n        // and not yet processed\n        if (eventQueue.contains(event)) {\n          eventQueue.remove(event); // TODO: Any synchro needed?\n          //deallocate the container\n          context.getEventHandler().handle(\n              new ContainerAllocatorEvent(event.getTaskAttemptID(),\n              ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n        } else {\n          try {\n            ContainerManager proxy \u003d \n              getCMProxy(containerID, containerManagerBindAddr, containerToken);\n            // TODO:check whether container is launched\n\n            // kill the remote container if already launched\n            StopContainerRequest stopRequest \u003d recordFactory\n                .newRecordInstance(StopContainerRequest.class);\n            stopRequest.setContainerId(event.getContainerID());\n            proxy.stopContainer(stopRequest);\n\n          } catch (Throwable t) {\n            //ignore the cleanup failure\n            LOG.warn(\"cleanup failed for container \" + event.getContainerID() ,\n                t);\n          }\n\n          // after killing, send killed event to taskattempt\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(event.getTaskAttemptID(),\n                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n        }\n        break;\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,85 @@\n     public void run() {\n-      while (!Thread.interrupted()) {\n+      LOG.info(\"Processing the event \" + event.toString());\n+\n+      // Load ContainerManager tokens before creating a connection.\n+      // TODO: Do it only once per NodeManager.\n+      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n+      ContainerId containerID \u003d event.getContainerID();\n+      ContainerToken containerToken \u003d event.getContainerToken();\n+\n+      switch(event.getType()) {\n+\n+      case CONTAINER_REMOTE_LAUNCH:\n+        ContainerRemoteLaunchEvent launchEv \u003d (ContainerRemoteLaunchEvent) event;\n+\n+        TaskAttemptId taskAttemptID \u003d launchEv.getTaskAttemptID();\n         try {\n-          TaskInProgress tip;\n-          Task task;\n-          synchronized (tasksToLaunch) {\n-            while (tasksToLaunch.isEmpty()) {\n-              tasksToLaunch.wait();\n-            }\n-            //get the TIP\n-            tip \u003d tasksToLaunch.remove(0);\n-            task \u003d tip.getTask();\n-            LOG.info(\"Trying to launch : \" + tip.getTask().getTaskID() + \n-                     \" which needs \" + task.getNumSlotsRequired() + \" slots\");\n-          }\n-          //wait for free slots to run\n-          synchronized (numFreeSlots) {\n-            boolean canLaunch \u003d true;\n-            while (numFreeSlots.get() \u003c task.getNumSlotsRequired()) {\n-              //Make sure that there is no kill task action for this task!\n-              //We are not locking tip here, because it would reverse the\n-              //locking order!\n-              //Also, Lock for the tip is not required here! because :\n-              // 1. runState of TaskStatus is volatile\n-              // 2. Any notification is not missed because notification is\n-              // synchronized on numFreeSlots. So, while we are doing the check,\n-              // if the tip is half way through the kill(), we don\u0027t miss\n-              // notification for the following wait(). \n-              if (!tip.canBeLaunched()) {\n-                //got killed externally while still in the launcher queue\n-                LOG.info(\"Not blocking slots for \" + task.getTaskID()\n-                    + \" as it got killed externally. Task\u0027s state is \"\n-                    + tip.getRunState());\n-                canLaunch \u003d false;\n-                break;\n-              }              \n-              LOG.info(\"TaskLauncher : Waiting for \" + task.getNumSlotsRequired() + \n-                       \" to launch \" + task.getTaskID() + \", currently we have \" + \n-                       numFreeSlots.get() + \" free slots\");\n-              numFreeSlots.wait();\n-            }\n-            if (!canLaunch) {\n-              continue;\n-            }\n-            LOG.info(\"In TaskLauncher, current free slots : \" + numFreeSlots.get()+\n-                     \" and trying to launch \"+tip.getTask().getTaskID() + \n-                     \" which needs \" + task.getNumSlotsRequired() + \" slots\");\n-            numFreeSlots.set(numFreeSlots.get() - task.getNumSlotsRequired());\n-            assert (numFreeSlots.get() \u003e\u003d 0);\n-          }\n-          synchronized (tip) {\n-            //to make sure that there is no kill task action for this\n-            if (!tip.canBeLaunched()) {\n-              //got killed externally while still in the launcher queue\n-              LOG.info(\"Not launching task \" + task.getTaskID() + \" as it got\"\n-                + \" killed externally. Task\u0027s state is \" + tip.getRunState());\n-              addFreeSlots(task.getNumSlotsRequired());\n-              continue;\n-            }\n-            tip.slotTaken \u003d true;\n-          }\n-          //got a free slot. launch the task\n-          startNewTask(tip);\n-        } catch (InterruptedException e) { \n-          return; // ALL DONE\n-        } catch (Throwable th) {\n-          LOG.error(\"TaskLauncher error \" + \n-              StringUtils.stringifyException(th));\n+          \n+          ContainerManager proxy \u003d \n+            getCMProxy(containerID, containerManagerBindAddr, containerToken);\n+          \n+          // Construct the actual Container\n+          ContainerLaunchContext containerLaunchContext \u003d\n+              launchEv.getContainer();\n+\n+          // Now launch the actual container\n+          StartContainerRequest startRequest \u003d recordFactory\n+              .newRecordInstance(StartContainerRequest.class);\n+          startRequest.setContainerLaunchContext(containerLaunchContext);\n+          proxy.startContainer(startRequest);\n+\n+          LOG.info(\"Returning from container-launch for \" + taskAttemptID);\n+\n+          // after launching, send launched event to task attempt to move\n+          // it from ASSIGNED to RUNNING state\n+          context.getEventHandler().handle(\n+              new TaskAttemptEvent(taskAttemptID,\n+                  TaskAttemptEventType.TA_CONTAINER_LAUNCHED));\n+        } catch (Throwable t) {\n+          String message \u003d \"Container launch failed for \" + containerID\n+              + \" : \" + StringUtils.stringifyException(t);\n+          LOG.error(message);\n+          context.getEventHandler().handle(\n+              new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n+          context.getEventHandler().handle(\n+              new TaskAttemptEvent(taskAttemptID,\n+                  TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED));\n         }\n+\n+        break;\n+\n+      case CONTAINER_REMOTE_CLEANUP:\n+        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n+        // and not yet processed\n+        if (eventQueue.contains(event)) {\n+          eventQueue.remove(event); // TODO: Any synchro needed?\n+          //deallocate the container\n+          context.getEventHandler().handle(\n+              new ContainerAllocatorEvent(event.getTaskAttemptID(),\n+              ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n+        } else {\n+          try {\n+            ContainerManager proxy \u003d \n+              getCMProxy(containerID, containerManagerBindAddr, containerToken);\n+            // TODO:check whether container is launched\n+\n+            // kill the remote container if already launched\n+            StopContainerRequest stopRequest \u003d recordFactory\n+                .newRecordInstance(StopContainerRequest.class);\n+            stopRequest.setContainerId(event.getContainerID());\n+            proxy.stopContainer(stopRequest);\n+\n+          } catch (Throwable t) {\n+            //ignore the cleanup failure\n+            LOG.warn(\"cleanup failed for container \" + event.getContainerID() ,\n+                t);\n+          }\n+\n+          // after killing, send killed event to taskattempt\n+          context.getEventHandler().handle(\n+              new TaskAttemptEvent(event.getTaskAttemptID(),\n+                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n+        }\n+        break;\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n      ContainerId containerID \u003d event.getContainerID();\n      ContainerToken containerToken \u003d event.getContainerToken();\n\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEv \u003d (ContainerRemoteLaunchEvent) event;\n\n        TaskAttemptId taskAttemptID \u003d launchEv.getTaskAttemptID();\n        try {\n          \n          ContainerManager proxy \u003d \n            getCMProxy(containerID, containerManagerBindAddr, containerToken);\n          \n          // Construct the actual Container\n          ContainerLaunchContext containerLaunchContext \u003d\n              launchEv.getContainer();\n\n          // Now launch the actual container\n          StartContainerRequest startRequest \u003d recordFactory\n              .newRecordInstance(StartContainerRequest.class);\n          startRequest.setContainerLaunchContext(containerLaunchContext);\n          proxy.startContainer(startRequest);\n\n          LOG.info(\"Returning from container-launch for \" + taskAttemptID);\n\n          // after launching, send launched event to task attempt to move\n          // it from ASSIGNED to RUNNING state\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(taskAttemptID,\n                  TaskAttemptEventType.TA_CONTAINER_LAUNCHED));\n        } catch (Throwable t) {\n          String message \u003d \"Container launch failed for \" + containerID\n              + \" : \" + StringUtils.stringifyException(t);\n          LOG.error(message);\n          context.getEventHandler().handle(\n              new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(taskAttemptID,\n                  TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED));\n        }\n\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n        // and not yet processed\n        if (eventQueue.contains(event)) {\n          eventQueue.remove(event); // TODO: Any synchro needed?\n          //deallocate the container\n          context.getEventHandler().handle(\n              new ContainerAllocatorEvent(event.getTaskAttemptID(),\n              ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n        } else {\n          try {\n            ContainerManager proxy \u003d \n              getCMProxy(containerID, containerManagerBindAddr, containerToken);\n            // TODO:check whether container is launched\n\n            // kill the remote container if already launched\n            StopContainerRequest stopRequest \u003d recordFactory\n                .newRecordInstance(StopContainerRequest.class);\n            stopRequest.setContainerId(event.getContainerID());\n            proxy.stopContainer(stopRequest);\n\n          } catch (Throwable t) {\n            //ignore the cleanup failure\n            LOG.warn(\"cleanup failed for container \" + event.getContainerID() ,\n                t);\n          }\n\n          // after killing, send killed event to taskattempt\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(event.getTaskAttemptID(),\n                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n        }\n        break;\n      }\n    }",
          "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
          "extendedDetails": {
            "oldPath": "mapreduce/src/java/org/apache/hadoop/mapred/TaskTracker.java",
            "newPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
            "oldMethodName": "run",
            "newMethodName": "run"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,85 @@\n     public void run() {\n-      while (!Thread.interrupted()) {\n+      LOG.info(\"Processing the event \" + event.toString());\n+\n+      // Load ContainerManager tokens before creating a connection.\n+      // TODO: Do it only once per NodeManager.\n+      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n+      ContainerId containerID \u003d event.getContainerID();\n+      ContainerToken containerToken \u003d event.getContainerToken();\n+\n+      switch(event.getType()) {\n+\n+      case CONTAINER_REMOTE_LAUNCH:\n+        ContainerRemoteLaunchEvent launchEv \u003d (ContainerRemoteLaunchEvent) event;\n+\n+        TaskAttemptId taskAttemptID \u003d launchEv.getTaskAttemptID();\n         try {\n-          TaskInProgress tip;\n-          Task task;\n-          synchronized (tasksToLaunch) {\n-            while (tasksToLaunch.isEmpty()) {\n-              tasksToLaunch.wait();\n-            }\n-            //get the TIP\n-            tip \u003d tasksToLaunch.remove(0);\n-            task \u003d tip.getTask();\n-            LOG.info(\"Trying to launch : \" + tip.getTask().getTaskID() + \n-                     \" which needs \" + task.getNumSlotsRequired() + \" slots\");\n-          }\n-          //wait for free slots to run\n-          synchronized (numFreeSlots) {\n-            boolean canLaunch \u003d true;\n-            while (numFreeSlots.get() \u003c task.getNumSlotsRequired()) {\n-              //Make sure that there is no kill task action for this task!\n-              //We are not locking tip here, because it would reverse the\n-              //locking order!\n-              //Also, Lock for the tip is not required here! because :\n-              // 1. runState of TaskStatus is volatile\n-              // 2. Any notification is not missed because notification is\n-              // synchronized on numFreeSlots. So, while we are doing the check,\n-              // if the tip is half way through the kill(), we don\u0027t miss\n-              // notification for the following wait(). \n-              if (!tip.canBeLaunched()) {\n-                //got killed externally while still in the launcher queue\n-                LOG.info(\"Not blocking slots for \" + task.getTaskID()\n-                    + \" as it got killed externally. Task\u0027s state is \"\n-                    + tip.getRunState());\n-                canLaunch \u003d false;\n-                break;\n-              }              \n-              LOG.info(\"TaskLauncher : Waiting for \" + task.getNumSlotsRequired() + \n-                       \" to launch \" + task.getTaskID() + \", currently we have \" + \n-                       numFreeSlots.get() + \" free slots\");\n-              numFreeSlots.wait();\n-            }\n-            if (!canLaunch) {\n-              continue;\n-            }\n-            LOG.info(\"In TaskLauncher, current free slots : \" + numFreeSlots.get()+\n-                     \" and trying to launch \"+tip.getTask().getTaskID() + \n-                     \" which needs \" + task.getNumSlotsRequired() + \" slots\");\n-            numFreeSlots.set(numFreeSlots.get() - task.getNumSlotsRequired());\n-            assert (numFreeSlots.get() \u003e\u003d 0);\n-          }\n-          synchronized (tip) {\n-            //to make sure that there is no kill task action for this\n-            if (!tip.canBeLaunched()) {\n-              //got killed externally while still in the launcher queue\n-              LOG.info(\"Not launching task \" + task.getTaskID() + \" as it got\"\n-                + \" killed externally. Task\u0027s state is \" + tip.getRunState());\n-              addFreeSlots(task.getNumSlotsRequired());\n-              continue;\n-            }\n-            tip.slotTaken \u003d true;\n-          }\n-          //got a free slot. launch the task\n-          startNewTask(tip);\n-        } catch (InterruptedException e) { \n-          return; // ALL DONE\n-        } catch (Throwable th) {\n-          LOG.error(\"TaskLauncher error \" + \n-              StringUtils.stringifyException(th));\n+          \n+          ContainerManager proxy \u003d \n+            getCMProxy(containerID, containerManagerBindAddr, containerToken);\n+          \n+          // Construct the actual Container\n+          ContainerLaunchContext containerLaunchContext \u003d\n+              launchEv.getContainer();\n+\n+          // Now launch the actual container\n+          StartContainerRequest startRequest \u003d recordFactory\n+              .newRecordInstance(StartContainerRequest.class);\n+          startRequest.setContainerLaunchContext(containerLaunchContext);\n+          proxy.startContainer(startRequest);\n+\n+          LOG.info(\"Returning from container-launch for \" + taskAttemptID);\n+\n+          // after launching, send launched event to task attempt to move\n+          // it from ASSIGNED to RUNNING state\n+          context.getEventHandler().handle(\n+              new TaskAttemptEvent(taskAttemptID,\n+                  TaskAttemptEventType.TA_CONTAINER_LAUNCHED));\n+        } catch (Throwable t) {\n+          String message \u003d \"Container launch failed for \" + containerID\n+              + \" : \" + StringUtils.stringifyException(t);\n+          LOG.error(message);\n+          context.getEventHandler().handle(\n+              new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n+          context.getEventHandler().handle(\n+              new TaskAttemptEvent(taskAttemptID,\n+                  TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED));\n         }\n+\n+        break;\n+\n+      case CONTAINER_REMOTE_CLEANUP:\n+        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n+        // and not yet processed\n+        if (eventQueue.contains(event)) {\n+          eventQueue.remove(event); // TODO: Any synchro needed?\n+          //deallocate the container\n+          context.getEventHandler().handle(\n+              new ContainerAllocatorEvent(event.getTaskAttemptID(),\n+              ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n+        } else {\n+          try {\n+            ContainerManager proxy \u003d \n+              getCMProxy(containerID, containerManagerBindAddr, containerToken);\n+            // TODO:check whether container is launched\n+\n+            // kill the remote container if already launched\n+            StopContainerRequest stopRequest \u003d recordFactory\n+                .newRecordInstance(StopContainerRequest.class);\n+            stopRequest.setContainerId(event.getContainerID());\n+            proxy.stopContainer(stopRequest);\n+\n+          } catch (Throwable t) {\n+            //ignore the cleanup failure\n+            LOG.warn(\"cleanup failed for container \" + event.getContainerID() ,\n+                t);\n+          }\n+\n+          // after killing, send killed event to taskattempt\n+          context.getEventHandler().handle(\n+              new TaskAttemptEvent(event.getTaskAttemptID(),\n+                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n+        }\n+        break;\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void run() {\n      LOG.info(\"Processing the event \" + event.toString());\n\n      // Load ContainerManager tokens before creating a connection.\n      // TODO: Do it only once per NodeManager.\n      final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n      ContainerId containerID \u003d event.getContainerID();\n      ContainerToken containerToken \u003d event.getContainerToken();\n\n      switch(event.getType()) {\n\n      case CONTAINER_REMOTE_LAUNCH:\n        ContainerRemoteLaunchEvent launchEv \u003d (ContainerRemoteLaunchEvent) event;\n\n        TaskAttemptId taskAttemptID \u003d launchEv.getTaskAttemptID();\n        try {\n          \n          ContainerManager proxy \u003d \n            getCMProxy(containerID, containerManagerBindAddr, containerToken);\n          \n          // Construct the actual Container\n          ContainerLaunchContext containerLaunchContext \u003d\n              launchEv.getContainer();\n\n          // Now launch the actual container\n          StartContainerRequest startRequest \u003d recordFactory\n              .newRecordInstance(StartContainerRequest.class);\n          startRequest.setContainerLaunchContext(containerLaunchContext);\n          proxy.startContainer(startRequest);\n\n          LOG.info(\"Returning from container-launch for \" + taskAttemptID);\n\n          // after launching, send launched event to task attempt to move\n          // it from ASSIGNED to RUNNING state\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(taskAttemptID,\n                  TaskAttemptEventType.TA_CONTAINER_LAUNCHED));\n        } catch (Throwable t) {\n          String message \u003d \"Container launch failed for \" + containerID\n              + \" : \" + StringUtils.stringifyException(t);\n          LOG.error(message);\n          context.getEventHandler().handle(\n              new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(taskAttemptID,\n                  TaskAttemptEventType.TA_CONTAINER_LAUNCH_FAILED));\n        }\n\n        break;\n\n      case CONTAINER_REMOTE_CLEANUP:\n        // We will have to remove the launch (meant \"cleanup\"? FIXME) event if it is still in eventQueue\n        // and not yet processed\n        if (eventQueue.contains(event)) {\n          eventQueue.remove(event); // TODO: Any synchro needed?\n          //deallocate the container\n          context.getEventHandler().handle(\n              new ContainerAllocatorEvent(event.getTaskAttemptID(),\n              ContainerAllocator.EventType.CONTAINER_DEALLOCATE));\n        } else {\n          try {\n            ContainerManager proxy \u003d \n              getCMProxy(containerID, containerManagerBindAddr, containerToken);\n            // TODO:check whether container is launched\n\n            // kill the remote container if already launched\n            StopContainerRequest stopRequest \u003d recordFactory\n                .newRecordInstance(StopContainerRequest.class);\n            stopRequest.setContainerId(event.getContainerID());\n            proxy.stopContainer(stopRequest);\n\n          } catch (Throwable t) {\n            //ignore the cleanup failure\n            LOG.warn(\"cleanup failed for container \" + event.getContainerID() ,\n                t);\n          }\n\n          // after killing, send killed event to taskattempt\n          context.getEventHandler().handle(\n              new TaskAttemptEvent(event.getTaskAttemptID(),\n                  TaskAttemptEventType.TA_CONTAINER_CLEANED));\n        }\n        break;\n      }\n    }",
          "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,48 @@\n+  public void run() {\n+    try {\n+      startCleanupThreads();\n+      boolean denied \u003d false;\n+      while (running \u0026\u0026 !shuttingDown \u0026\u0026 !denied) {\n+        boolean staleState \u003d false;\n+        try {\n+          // This while-loop attempts reconnects if we get network errors\n+          while (running \u0026\u0026 !staleState \u0026\u0026 !shuttingDown \u0026\u0026 !denied) {\n+            try {\n+              State osState \u003d offerService();\n+              if (osState \u003d\u003d State.STALE) {\n+                staleState \u003d true;\n+              } else if (osState \u003d\u003d State.DENIED) {\n+                denied \u003d true;\n+              }\n+            } catch (Exception ex) {\n+              if (!shuttingDown) {\n+                LOG.info(\"Lost connection to JobTracker [\" +\n+                         jobTrackAddr + \"].  Retrying...\", ex);\n+                try {\n+                  Thread.sleep(5000);\n+                } catch (InterruptedException ie) {\n+                }\n+              }\n+            }\n+          }\n+        } finally {\n+          close();\n+        }\n+        if (shuttingDown) { return; }\n+        LOG.warn(\"Reinitializing local state\");\n+        initialize();\n+      }\n+      if (denied) {\n+        shutdown();\n+      }\n+    } catch (IOException iex) {\n+      LOG.error(\"Got fatal exception while reinitializing TaskTracker: \" +\n+                StringUtils.stringifyException(iex));\n+      return;\n+    }\n+    catch (InterruptedException i) {\n+      LOG.error(\"Got interrupted while reinitializing TaskTracker: \" + \n+          i.getMessage());\n+      return;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    try {\n      startCleanupThreads();\n      boolean denied \u003d false;\n      while (running \u0026\u0026 !shuttingDown \u0026\u0026 !denied) {\n        boolean staleState \u003d false;\n        try {\n          // This while-loop attempts reconnects if we get network errors\n          while (running \u0026\u0026 !staleState \u0026\u0026 !shuttingDown \u0026\u0026 !denied) {\n            try {\n              State osState \u003d offerService();\n              if (osState \u003d\u003d State.STALE) {\n                staleState \u003d true;\n              } else if (osState \u003d\u003d State.DENIED) {\n                denied \u003d true;\n              }\n            } catch (Exception ex) {\n              if (!shuttingDown) {\n                LOG.info(\"Lost connection to JobTracker [\" +\n                         jobTrackAddr + \"].  Retrying...\", ex);\n                try {\n                  Thread.sleep(5000);\n                } catch (InterruptedException ie) {\n                }\n              }\n            }\n          }\n        } finally {\n          close();\n        }\n        if (shuttingDown) { return; }\n        LOG.warn(\"Reinitializing local state\");\n        initialize();\n      }\n      if (denied) {\n        shutdown();\n      }\n    } catch (IOException iex) {\n      LOG.error(\"Got fatal exception while reinitializing TaskTracker: \" +\n                StringUtils.stringifyException(iex));\n      return;\n    }\n    catch (InterruptedException i) {\n      LOG.error(\"Got interrupted while reinitializing TaskTracker: \" + \n          i.getMessage());\n      return;\n    }\n  }",
      "path": "mapreduce/src/java/org/apache/hadoop/mapred/TaskTracker.java"
    }
  }
}