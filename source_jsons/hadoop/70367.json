{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "getFolderContentsToDelete",
  "functionId": "getFolderContentsToDelete___folderToDelete-FileMetadata__finalList-ArrayList__FileMetadata__",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 2461,
  "functionEndLine": 2552,
  "numCommitsSeen": 66,
  "timeTaken": 1890,
  "changeHistory": [
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
    "a530e7ab3b3f5bd71143a91266b46787962ac532"
  ],
  "changeHistoryShort": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": "Ybodychange",
    "a530e7ab3b3f5bd71143a91266b46787962ac532": "Yintroduced"
  },
  "changeHistoryDetails": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15547/ WASB: improve listStatus performance.\nContributed by Thomas Marquardt.\n\n(cherry picked from commit 749fff577ed9afb4ef8a54b8948f74be083cc620)\n",
      "commitDate": "19/07/18 12:31 PM",
      "commitName": "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "27/06/18 10:37 PM",
      "commitNameOld": "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 21.58,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n   private boolean getFolderContentsToDelete(FileMetadata folderToDelete,\n       ArrayList\u003cFileMetadata\u003e finalList) throws IOException {\n \n     final int maxListingDepth \u003d 1;\n     Stack\u003cFileMetadata\u003e foldersToProcess \u003d new Stack\u003cFileMetadata\u003e();\n     HashMap\u003cString, FileMetadata\u003e folderContentsMap \u003d new HashMap\u003cString, FileMetadata\u003e();\n \n     boolean isPartialDelete \u003d false;\n \n-    Path pathToDelete \u003d makeAbsolute(keyToPath(folderToDelete.getKey()));\n+    Path pathToDelete \u003d makeAbsolute(folderToDelete.getPath());\n     foldersToProcess.push(folderToDelete);\n \n     while (!foldersToProcess.empty()) {\n \n       FileMetadata currentFolder \u003d foldersToProcess.pop();\n-      Path currentPath \u003d makeAbsolute(keyToPath(currentFolder.getKey()));\n+      Path currentPath \u003d makeAbsolute(currentFolder.getPath());\n       boolean canDeleteChildren \u003d true;\n \n       // If authorization is enabled, check for \u0027write\u0027 permission on current folder\n       // This check maps to subfolders \u0027write\u0027 check for deleting contents recursively.\n       try {\n         performAuthCheck(currentPath, WasbAuthorizationOperations.WRITE, \"delete\", pathToDelete);\n       } catch (WasbAuthorizationException we) {\n         LOG.debug(\"Authorization check failed for {}\", currentPath);\n         // We cannot delete the children of currentFolder since \u0027write\u0027 check on parent failed\n         canDeleteChildren \u003d false;\n       }\n \n       if (canDeleteChildren) {\n \n         // get immediate children list\n-        ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d getChildrenMetadata(currentFolder.getKey(),\n-            maxListingDepth);\n+        FileMetadata[] fileMetadataList \u003d store.list(currentFolder.getKey(),\n+            AZURE_LIST_ALL, maxListingDepth);\n \n         // Process children of currentFolder and add them to list of contents\n         // that can be deleted. We Perform stickybit check on every file and\n         // folder under currentFolder in case stickybit is set on currentFolder.\n         for (FileMetadata childItem : fileMetadataList) {\n           if (isStickyBitCheckViolated(childItem, currentFolder, false)) {\n             // Stickybit check failed for the childItem that is being processed.\n             // This file/folder cannot be deleted and neither can the parent paths be deleted.\n             // Remove parent paths from list of contents that can be deleted.\n             canDeleteChildren \u003d false;\n-            Path filePath \u003d makeAbsolute(keyToPath(childItem.getKey()));\n+            Path filePath \u003d makeAbsolute(childItem.getPath());\n             LOG.error(\"User does not have permissions to delete {}. \"\n               + \"Parent directory has sticky bit set.\", filePath);\n           } else {\n             // push the child directories to the stack to process their contents\n-            if (childItem.isDir()) {\n+            if (childItem.isDirectory()) {\n               foldersToProcess.push(childItem);\n             }\n             // Add items to list of contents that can be deleted.\n             folderContentsMap.put(childItem.getKey(), childItem);\n           }\n         }\n \n       } else {\n         // Cannot delete children since parent permission check has not passed and\n         // if there are files/folders under currentFolder they will not be deleted.\n         LOG.error(\"Authorization check failed. Files or folders under {} \"\n           + \"will not be processed for deletion.\", currentPath);\n       }\n \n       if (!canDeleteChildren) {\n         // We reach here if\n         // 1. cannot delete children since \u0027write\u0027 check on parent failed or\n         // 2. One of the files under the current folder cannot be deleted due to stickybit check.\n         // In this case we remove all the parent paths from the list of contents\n         // that can be deleted till we reach the original path of delete request\n         String pathToRemove \u003d currentFolder.getKey();\n         while (!pathToRemove.equals(folderToDelete.getKey())) {\n           if (folderContentsMap.containsKey(pathToRemove)) {\n             LOG.debug(\"Cannot delete {} since some of its contents \"\n               + \"cannot be deleted\", pathToRemove);\n             folderContentsMap.remove(pathToRemove);\n           }\n           Path parentPath \u003d keyToPath(pathToRemove).getParent();\n           pathToRemove \u003d pathToKey(parentPath);\n         }\n         // Since one or more files/folders cannot be deleted return value should indicate\n         // partial delete, so that the delete on the path requested by user is not performed\n         isPartialDelete \u003d true;\n       }\n     }\n \n     // final list of contents that can be deleted\n     for (HashMap.Entry\u003cString, FileMetadata\u003e entry : folderContentsMap.entrySet()) {\n       finalList.add(entry.getValue());\n     }\n \n     return isPartialDelete;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean getFolderContentsToDelete(FileMetadata folderToDelete,\n      ArrayList\u003cFileMetadata\u003e finalList) throws IOException {\n\n    final int maxListingDepth \u003d 1;\n    Stack\u003cFileMetadata\u003e foldersToProcess \u003d new Stack\u003cFileMetadata\u003e();\n    HashMap\u003cString, FileMetadata\u003e folderContentsMap \u003d new HashMap\u003cString, FileMetadata\u003e();\n\n    boolean isPartialDelete \u003d false;\n\n    Path pathToDelete \u003d makeAbsolute(folderToDelete.getPath());\n    foldersToProcess.push(folderToDelete);\n\n    while (!foldersToProcess.empty()) {\n\n      FileMetadata currentFolder \u003d foldersToProcess.pop();\n      Path currentPath \u003d makeAbsolute(currentFolder.getPath());\n      boolean canDeleteChildren \u003d true;\n\n      // If authorization is enabled, check for \u0027write\u0027 permission on current folder\n      // This check maps to subfolders \u0027write\u0027 check for deleting contents recursively.\n      try {\n        performAuthCheck(currentPath, WasbAuthorizationOperations.WRITE, \"delete\", pathToDelete);\n      } catch (WasbAuthorizationException we) {\n        LOG.debug(\"Authorization check failed for {}\", currentPath);\n        // We cannot delete the children of currentFolder since \u0027write\u0027 check on parent failed\n        canDeleteChildren \u003d false;\n      }\n\n      if (canDeleteChildren) {\n\n        // get immediate children list\n        FileMetadata[] fileMetadataList \u003d store.list(currentFolder.getKey(),\n            AZURE_LIST_ALL, maxListingDepth);\n\n        // Process children of currentFolder and add them to list of contents\n        // that can be deleted. We Perform stickybit check on every file and\n        // folder under currentFolder in case stickybit is set on currentFolder.\n        for (FileMetadata childItem : fileMetadataList) {\n          if (isStickyBitCheckViolated(childItem, currentFolder, false)) {\n            // Stickybit check failed for the childItem that is being processed.\n            // This file/folder cannot be deleted and neither can the parent paths be deleted.\n            // Remove parent paths from list of contents that can be deleted.\n            canDeleteChildren \u003d false;\n            Path filePath \u003d makeAbsolute(childItem.getPath());\n            LOG.error(\"User does not have permissions to delete {}. \"\n              + \"Parent directory has sticky bit set.\", filePath);\n          } else {\n            // push the child directories to the stack to process their contents\n            if (childItem.isDirectory()) {\n              foldersToProcess.push(childItem);\n            }\n            // Add items to list of contents that can be deleted.\n            folderContentsMap.put(childItem.getKey(), childItem);\n          }\n        }\n\n      } else {\n        // Cannot delete children since parent permission check has not passed and\n        // if there are files/folders under currentFolder they will not be deleted.\n        LOG.error(\"Authorization check failed. Files or folders under {} \"\n          + \"will not be processed for deletion.\", currentPath);\n      }\n\n      if (!canDeleteChildren) {\n        // We reach here if\n        // 1. cannot delete children since \u0027write\u0027 check on parent failed or\n        // 2. One of the files under the current folder cannot be deleted due to stickybit check.\n        // In this case we remove all the parent paths from the list of contents\n        // that can be deleted till we reach the original path of delete request\n        String pathToRemove \u003d currentFolder.getKey();\n        while (!pathToRemove.equals(folderToDelete.getKey())) {\n          if (folderContentsMap.containsKey(pathToRemove)) {\n            LOG.debug(\"Cannot delete {} since some of its contents \"\n              + \"cannot be deleted\", pathToRemove);\n            folderContentsMap.remove(pathToRemove);\n          }\n          Path parentPath \u003d keyToPath(pathToRemove).getParent();\n          pathToRemove \u003d pathToKey(parentPath);\n        }\n        // Since one or more files/folders cannot be deleted return value should indicate\n        // partial delete, so that the delete on the path requested by user is not performed\n        isPartialDelete \u003d true;\n      }\n    }\n\n    // final list of contents that can be deleted\n    for (HashMap.Entry\u003cString, FileMetadata\u003e entry : folderContentsMap.entrySet()) {\n      finalList.add(entry.getValue());\n    }\n\n    return isPartialDelete;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "a530e7ab3b3f5bd71143a91266b46787962ac532": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-14768. Honoring sticky bit during Deletion when authorization is enabled in WASB\nContributed by Varada Hemeswari\n",
      "commitDate": "28/09/17 11:52 AM",
      "commitName": "a530e7ab3b3f5bd71143a91266b46787962ac532",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,92 @@\n+  private boolean getFolderContentsToDelete(FileMetadata folderToDelete,\n+      ArrayList\u003cFileMetadata\u003e finalList) throws IOException {\n+\n+    final int maxListingDepth \u003d 1;\n+    Stack\u003cFileMetadata\u003e foldersToProcess \u003d new Stack\u003cFileMetadata\u003e();\n+    HashMap\u003cString, FileMetadata\u003e folderContentsMap \u003d new HashMap\u003cString, FileMetadata\u003e();\n+\n+    boolean isPartialDelete \u003d false;\n+\n+    Path pathToDelete \u003d makeAbsolute(keyToPath(folderToDelete.getKey()));\n+    foldersToProcess.push(folderToDelete);\n+\n+    while (!foldersToProcess.empty()) {\n+\n+      FileMetadata currentFolder \u003d foldersToProcess.pop();\n+      Path currentPath \u003d makeAbsolute(keyToPath(currentFolder.getKey()));\n+      boolean canDeleteChildren \u003d true;\n+\n+      // If authorization is enabled, check for \u0027write\u0027 permission on current folder\n+      // This check maps to subfolders \u0027write\u0027 check for deleting contents recursively.\n+      try {\n+        performAuthCheck(currentPath, WasbAuthorizationOperations.WRITE, \"delete\", pathToDelete);\n+      } catch (WasbAuthorizationException we) {\n+        LOG.debug(\"Authorization check failed for {}\", currentPath);\n+        // We cannot delete the children of currentFolder since \u0027write\u0027 check on parent failed\n+        canDeleteChildren \u003d false;\n+      }\n+\n+      if (canDeleteChildren) {\n+\n+        // get immediate children list\n+        ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d getChildrenMetadata(currentFolder.getKey(),\n+            maxListingDepth);\n+\n+        // Process children of currentFolder and add them to list of contents\n+        // that can be deleted. We Perform stickybit check on every file and\n+        // folder under currentFolder in case stickybit is set on currentFolder.\n+        for (FileMetadata childItem : fileMetadataList) {\n+          if (isStickyBitCheckViolated(childItem, currentFolder, false)) {\n+            // Stickybit check failed for the childItem that is being processed.\n+            // This file/folder cannot be deleted and neither can the parent paths be deleted.\n+            // Remove parent paths from list of contents that can be deleted.\n+            canDeleteChildren \u003d false;\n+            Path filePath \u003d makeAbsolute(keyToPath(childItem.getKey()));\n+            LOG.error(\"User does not have permissions to delete {}. \"\n+              + \"Parent directory has sticky bit set.\", filePath);\n+          } else {\n+            // push the child directories to the stack to process their contents\n+            if (childItem.isDir()) {\n+              foldersToProcess.push(childItem);\n+            }\n+            // Add items to list of contents that can be deleted.\n+            folderContentsMap.put(childItem.getKey(), childItem);\n+          }\n+        }\n+\n+      } else {\n+        // Cannot delete children since parent permission check has not passed and\n+        // if there are files/folders under currentFolder they will not be deleted.\n+        LOG.error(\"Authorization check failed. Files or folders under {} \"\n+          + \"will not be processed for deletion.\", currentPath);\n+      }\n+\n+      if (!canDeleteChildren) {\n+        // We reach here if\n+        // 1. cannot delete children since \u0027write\u0027 check on parent failed or\n+        // 2. One of the files under the current folder cannot be deleted due to stickybit check.\n+        // In this case we remove all the parent paths from the list of contents\n+        // that can be deleted till we reach the original path of delete request\n+        String pathToRemove \u003d currentFolder.getKey();\n+        while (!pathToRemove.equals(folderToDelete.getKey())) {\n+          if (folderContentsMap.containsKey(pathToRemove)) {\n+            LOG.debug(\"Cannot delete {} since some of its contents \"\n+              + \"cannot be deleted\", pathToRemove);\n+            folderContentsMap.remove(pathToRemove);\n+          }\n+          Path parentPath \u003d keyToPath(pathToRemove).getParent();\n+          pathToRemove \u003d pathToKey(parentPath);\n+        }\n+        // Since one or more files/folders cannot be deleted return value should indicate\n+        // partial delete, so that the delete on the path requested by user is not performed\n+        isPartialDelete \u003d true;\n+      }\n+    }\n+\n+    // final list of contents that can be deleted\n+    for (HashMap.Entry\u003cString, FileMetadata\u003e entry : folderContentsMap.entrySet()) {\n+      finalList.add(entry.getValue());\n+    }\n+\n+    return isPartialDelete;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean getFolderContentsToDelete(FileMetadata folderToDelete,\n      ArrayList\u003cFileMetadata\u003e finalList) throws IOException {\n\n    final int maxListingDepth \u003d 1;\n    Stack\u003cFileMetadata\u003e foldersToProcess \u003d new Stack\u003cFileMetadata\u003e();\n    HashMap\u003cString, FileMetadata\u003e folderContentsMap \u003d new HashMap\u003cString, FileMetadata\u003e();\n\n    boolean isPartialDelete \u003d false;\n\n    Path pathToDelete \u003d makeAbsolute(keyToPath(folderToDelete.getKey()));\n    foldersToProcess.push(folderToDelete);\n\n    while (!foldersToProcess.empty()) {\n\n      FileMetadata currentFolder \u003d foldersToProcess.pop();\n      Path currentPath \u003d makeAbsolute(keyToPath(currentFolder.getKey()));\n      boolean canDeleteChildren \u003d true;\n\n      // If authorization is enabled, check for \u0027write\u0027 permission on current folder\n      // This check maps to subfolders \u0027write\u0027 check for deleting contents recursively.\n      try {\n        performAuthCheck(currentPath, WasbAuthorizationOperations.WRITE, \"delete\", pathToDelete);\n      } catch (WasbAuthorizationException we) {\n        LOG.debug(\"Authorization check failed for {}\", currentPath);\n        // We cannot delete the children of currentFolder since \u0027write\u0027 check on parent failed\n        canDeleteChildren \u003d false;\n      }\n\n      if (canDeleteChildren) {\n\n        // get immediate children list\n        ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d getChildrenMetadata(currentFolder.getKey(),\n            maxListingDepth);\n\n        // Process children of currentFolder and add them to list of contents\n        // that can be deleted. We Perform stickybit check on every file and\n        // folder under currentFolder in case stickybit is set on currentFolder.\n        for (FileMetadata childItem : fileMetadataList) {\n          if (isStickyBitCheckViolated(childItem, currentFolder, false)) {\n            // Stickybit check failed for the childItem that is being processed.\n            // This file/folder cannot be deleted and neither can the parent paths be deleted.\n            // Remove parent paths from list of contents that can be deleted.\n            canDeleteChildren \u003d false;\n            Path filePath \u003d makeAbsolute(keyToPath(childItem.getKey()));\n            LOG.error(\"User does not have permissions to delete {}. \"\n              + \"Parent directory has sticky bit set.\", filePath);\n          } else {\n            // push the child directories to the stack to process their contents\n            if (childItem.isDir()) {\n              foldersToProcess.push(childItem);\n            }\n            // Add items to list of contents that can be deleted.\n            folderContentsMap.put(childItem.getKey(), childItem);\n          }\n        }\n\n      } else {\n        // Cannot delete children since parent permission check has not passed and\n        // if there are files/folders under currentFolder they will not be deleted.\n        LOG.error(\"Authorization check failed. Files or folders under {} \"\n          + \"will not be processed for deletion.\", currentPath);\n      }\n\n      if (!canDeleteChildren) {\n        // We reach here if\n        // 1. cannot delete children since \u0027write\u0027 check on parent failed or\n        // 2. One of the files under the current folder cannot be deleted due to stickybit check.\n        // In this case we remove all the parent paths from the list of contents\n        // that can be deleted till we reach the original path of delete request\n        String pathToRemove \u003d currentFolder.getKey();\n        while (!pathToRemove.equals(folderToDelete.getKey())) {\n          if (folderContentsMap.containsKey(pathToRemove)) {\n            LOG.debug(\"Cannot delete {} since some of its contents \"\n              + \"cannot be deleted\", pathToRemove);\n            folderContentsMap.remove(pathToRemove);\n          }\n          Path parentPath \u003d keyToPath(pathToRemove).getParent();\n          pathToRemove \u003d pathToKey(parentPath);\n        }\n        // Since one or more files/folders cannot be deleted return value should indicate\n        // partial delete, so that the delete on the path requested by user is not performed\n        isPartialDelete \u003d true;\n      }\n    }\n\n    // final list of contents that can be deleted\n    for (HashMap.Entry\u003cString, FileMetadata\u003e entry : folderContentsMap.entrySet()) {\n      finalList.add(entry.getValue());\n    }\n\n    return isPartialDelete;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}