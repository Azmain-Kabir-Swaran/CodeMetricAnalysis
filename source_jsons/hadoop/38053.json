{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DBManager.java",
  "functionName": "initDatabase",
  "functionId": "initDatabase___configurationFile-File__options-Options__initMethod-Consumer__DB__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DBManager.java",
  "functionStartLine": 49,
  "functionEndLine": 70,
  "numCommitsSeen": 28,
  "timeTaken": 9545,
  "changeHistory": [
    "76900b4f5b7ad8d11baf505abc43f7b24d364071",
    "348685dcb9c1a0ea50b536170b3a8c77a8f8df06",
    "be901f49628a553cfe6a3942478cb528cce2b266",
    "fb1ecff6a26875c7f2b86ef07d7b9145c469377e",
    "4510970e2f7728d036c750b596985e5ffa357b60",
    "d6622daaa3c95a5040d06f91dc0c793bafa70f95",
    "ff39c0de206a4fce1f0e8a416357a7a8261f8634",
    "74ba6ffa0b601badc68366685dcf993a0844520a"
  ],
  "changeHistoryShort": {
    "76900b4f5b7ad8d11baf505abc43f7b24d364071": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yrename)",
    "348685dcb9c1a0ea50b536170b3a8c77a8f8df06": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
    "be901f49628a553cfe6a3942478cb528cce2b266": "Ybodychange",
    "fb1ecff6a26875c7f2b86ef07d7b9145c469377e": "Ybodychange",
    "4510970e2f7728d036c750b596985e5ffa357b60": "Ybodychange",
    "d6622daaa3c95a5040d06f91dc0c793bafa70f95": "Ymultichange(Yreturntypechange,Ybodychange)",
    "ff39c0de206a4fce1f0e8a416357a7a8261f8634": "Ybodychange",
    "74ba6ffa0b601badc68366685dcf993a0844520a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "76900b4f5b7ad8d11baf505abc43f7b24d364071": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yrename)",
      "commitMessage": "YARN-10189. Code cleanup in LeveldbRMStateStore. Contributed by Benjamin Teke\n",
      "commitDate": "18/04/20 12:57 AM",
      "commitName": "76900b4f5b7ad8d11baf505abc43f7b24d364071",
      "commitAuthor": "Szilard Nemeth",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-10189. Code cleanup in LeveldbRMStateStore. Contributed by Benjamin Teke\n",
          "commitDate": "18/04/20 12:57 AM",
          "commitName": "76900b4f5b7ad8d11baf505abc43f7b24d364071",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "17/04/20 2:38 PM",
          "commitNameOld": "ac40daece17e9a6339927dbcadab76034bd7882c",
          "commitAuthorOld": "Masatake Iwasaki",
          "daysBetweenCommits": 0.43,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,22 @@\n-  private DB initDatabaseHelper(File configurationFile, Options options,\n-      Consumer\u003cDB\u003e initMethod) throws Exception {\n-    DB database;\n+  public DB initDatabase(File configurationFile, Options options,\n+                         Consumer\u003cDB\u003e initMethod) throws Exception {\n     try {\n-      database \u003d JniDBFactory.factory.open(configurationFile, options);\n+      db \u003d JniDBFactory.factory.open(configurationFile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n         LOG.info(\"Creating configuration version/database at {}\",\n             configurationFile);\n         options.createIfMissing(true);\n         try {\n-          database \u003d JniDBFactory.factory.open(configurationFile, options);\n-          initMethod.accept(database);\n+          db \u003d JniDBFactory.factory.open(configurationFile, options);\n+          initMethod.accept(db);\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n \n-    return database;\n+    return db;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DB initDatabase(File configurationFile, Options options,\n                         Consumer\u003cDB\u003e initMethod) throws Exception {\n    try {\n      db \u003d JniDBFactory.factory.open(configurationFile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating configuration version/database at {}\",\n            configurationFile);\n        options.createIfMissing(true);\n        try {\n          db \u003d JniDBFactory.factory.open(configurationFile, options);\n          initMethod.accept(db);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n\n    return db;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DBManager.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DBManager.java",
            "oldMethodName": "initDatabaseHelper",
            "newMethodName": "initDatabase"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-10189. Code cleanup in LeveldbRMStateStore. Contributed by Benjamin Teke\n",
          "commitDate": "18/04/20 12:57 AM",
          "commitName": "76900b4f5b7ad8d11baf505abc43f7b24d364071",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "17/04/20 2:38 PM",
          "commitNameOld": "ac40daece17e9a6339927dbcadab76034bd7882c",
          "commitAuthorOld": "Masatake Iwasaki",
          "daysBetweenCommits": 0.43,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,22 @@\n-  private DB initDatabaseHelper(File configurationFile, Options options,\n-      Consumer\u003cDB\u003e initMethod) throws Exception {\n-    DB database;\n+  public DB initDatabase(File configurationFile, Options options,\n+                         Consumer\u003cDB\u003e initMethod) throws Exception {\n     try {\n-      database \u003d JniDBFactory.factory.open(configurationFile, options);\n+      db \u003d JniDBFactory.factory.open(configurationFile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n         LOG.info(\"Creating configuration version/database at {}\",\n             configurationFile);\n         options.createIfMissing(true);\n         try {\n-          database \u003d JniDBFactory.factory.open(configurationFile, options);\n-          initMethod.accept(database);\n+          db \u003d JniDBFactory.factory.open(configurationFile, options);\n+          initMethod.accept(db);\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n \n-    return database;\n+    return db;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DB initDatabase(File configurationFile, Options options,\n                         Consumer\u003cDB\u003e initMethod) throws Exception {\n    try {\n      db \u003d JniDBFactory.factory.open(configurationFile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating configuration version/database at {}\",\n            configurationFile);\n        options.createIfMissing(true);\n        try {\n          db \u003d JniDBFactory.factory.open(configurationFile, options);\n          initMethod.accept(db);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n\n    return db;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DBManager.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-10189. Code cleanup in LeveldbRMStateStore. Contributed by Benjamin Teke\n",
          "commitDate": "18/04/20 12:57 AM",
          "commitName": "76900b4f5b7ad8d11baf505abc43f7b24d364071",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "17/04/20 2:38 PM",
          "commitNameOld": "ac40daece17e9a6339927dbcadab76034bd7882c",
          "commitAuthorOld": "Masatake Iwasaki",
          "daysBetweenCommits": 0.43,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,22 @@\n-  private DB initDatabaseHelper(File configurationFile, Options options,\n-      Consumer\u003cDB\u003e initMethod) throws Exception {\n-    DB database;\n+  public DB initDatabase(File configurationFile, Options options,\n+                         Consumer\u003cDB\u003e initMethod) throws Exception {\n     try {\n-      database \u003d JniDBFactory.factory.open(configurationFile, options);\n+      db \u003d JniDBFactory.factory.open(configurationFile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n         LOG.info(\"Creating configuration version/database at {}\",\n             configurationFile);\n         options.createIfMissing(true);\n         try {\n-          database \u003d JniDBFactory.factory.open(configurationFile, options);\n-          initMethod.accept(database);\n+          db \u003d JniDBFactory.factory.open(configurationFile, options);\n+          initMethod.accept(db);\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n \n-    return database;\n+    return db;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DB initDatabase(File configurationFile, Options options,\n                         Consumer\u003cDB\u003e initMethod) throws Exception {\n    try {\n      db \u003d JniDBFactory.factory.open(configurationFile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating configuration version/database at {}\",\n            configurationFile);\n        options.createIfMissing(true);\n        try {\n          db \u003d JniDBFactory.factory.open(configurationFile, options);\n          initMethod.accept(db);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n\n    return db;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DBManager.java",
          "extendedDetails": {}
        },
        {
          "type": "Yrename",
          "commitMessage": "YARN-10189. Code cleanup in LeveldbRMStateStore. Contributed by Benjamin Teke\n",
          "commitDate": "18/04/20 12:57 AM",
          "commitName": "76900b4f5b7ad8d11baf505abc43f7b24d364071",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "17/04/20 2:38 PM",
          "commitNameOld": "ac40daece17e9a6339927dbcadab76034bd7882c",
          "commitAuthorOld": "Masatake Iwasaki",
          "daysBetweenCommits": 0.43,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,22 @@\n-  private DB initDatabaseHelper(File configurationFile, Options options,\n-      Consumer\u003cDB\u003e initMethod) throws Exception {\n-    DB database;\n+  public DB initDatabase(File configurationFile, Options options,\n+                         Consumer\u003cDB\u003e initMethod) throws Exception {\n     try {\n-      database \u003d JniDBFactory.factory.open(configurationFile, options);\n+      db \u003d JniDBFactory.factory.open(configurationFile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n         LOG.info(\"Creating configuration version/database at {}\",\n             configurationFile);\n         options.createIfMissing(true);\n         try {\n-          database \u003d JniDBFactory.factory.open(configurationFile, options);\n-          initMethod.accept(database);\n+          db \u003d JniDBFactory.factory.open(configurationFile, options);\n+          initMethod.accept(db);\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n \n-    return database;\n+    return db;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DB initDatabase(File configurationFile, Options options,\n                         Consumer\u003cDB\u003e initMethod) throws Exception {\n    try {\n      db \u003d JniDBFactory.factory.open(configurationFile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating configuration version/database at {}\",\n            configurationFile);\n        options.createIfMissing(true);\n        try {\n          db \u003d JniDBFactory.factory.open(configurationFile, options);\n          initMethod.accept(db);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n\n    return db;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DBManager.java",
          "extendedDetails": {
            "oldValue": "initDatabaseHelper",
            "newValue": "initDatabase"
          }
        }
      ]
    },
    "348685dcb9c1a0ea50b536170b3a8c77a8f8df06": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-9998. Code cleanup in LeveldbConfigurationStore. Contributed by Benjamin Teke\n",
      "commitDate": "26/03/20 4:18 AM",
      "commitName": "348685dcb9c1a0ea50b536170b3a8c77a8f8df06",
      "commitAuthor": "Szilard Nemeth",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-9998. Code cleanup in LeveldbConfigurationStore. Contributed by Benjamin Teke\n",
          "commitDate": "26/03/20 4:18 AM",
          "commitName": "348685dcb9c1a0ea50b536170b3a8c77a8f8df06",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "10/03/20 8:35 AM",
          "commitNameOld": "61f4cf3055e60e64a95f4599ebceac5a924bba02",
          "commitAuthorOld": "Szilard Nemeth",
          "daysBetweenCommits": 15.82,
          "commitsBetweenForRepo": 57,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,87 +1,23 @@\n-  private void initDatabase(Configuration config) throws Exception {\n-    Path storeRoot \u003d createStorageDir(DB_NAME);\n-    Options options \u003d new Options();\n-    options.createIfMissing(false);\n-    options.comparator(new DBComparator() {\n-      @Override\n-      public int compare(byte[] key1, byte[] key2) {\n-        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n-        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n-        if (key1Str.equals(key2Str)) {\n-          return 0;\n-        } else if (key1Str.equals(VERSION_KEY)) {\n-          return 1;\n-        } else if (key2Str.equals(VERSION_KEY)) {\n-          return -1;\n-        } else if (key1Str.equals(LOG_KEY)) {\n-          return 1;\n-        } else if (key2Str.equals(LOG_KEY)) {\n-          return -1;\n-        }\n-        return key1Str.compareTo(key2Str);\n-      }\n-\n-      @Override\n-      public String name() {\n-        return \"keyComparator\";\n-      }\n-\n-      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n-        return start;\n-      }\n-\n-      public byte[] findShortSuccessor(byte[] key) {\n-        return key;\n-      }\n-    });\n-\n-    Path confVersion \u003d createStorageDir(CONF_VERSION_NAME);\n-    Options confOptions \u003d new Options();\n-    confOptions.createIfMissing(false);\n-    LOG.info(\"Using conf version at \" + confVersion);\n-    File confVersionFile \u003d new File(confVersion.toString());\n+  private DB initDatabaseHelper(File configurationFile, Options options,\n+      Consumer\u003cDB\u003e initMethod) throws Exception {\n+    DB database;\n     try {\n-      versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n+      database \u003d JniDBFactory.factory.open(configurationFile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n-        LOG.info(\"Creating conf version at \" + confVersionFile);\n-        confOptions.createIfMissing(true);\n-        try {\n-          versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n-          versiondb.put(bytes(CONF_VERSION_KEY), bytes(String.valueOf(0)));\n-        } catch (DBException dbErr) {\n-          throw new IOException(dbErr.getMessage(), dbErr);\n-        }\n-      } else {\n-        throw e;\n-      }\n-    }\n-\n-\n-    LOG.info(\"Using conf database at \" + storeRoot);\n-    File dbfile \u003d new File(storeRoot.toString());\n-    try {\n-      db \u003d JniDBFactory.factory.open(dbfile, options);\n-    } catch (NativeDB.DBException e) {\n-      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n-        LOG.info(\"Creating conf database at \" + dbfile);\n+        LOG.info(\"Creating configuration version/database at {}\",\n+            configurationFile);\n         options.createIfMissing(true);\n         try {\n-          db \u003d JniDBFactory.factory.open(dbfile, options);\n-          // Write the initial scheduler configuration\n-          WriteBatch initBatch \u003d db.createWriteBatch();\n-          for (Map.Entry\u003cString, String\u003e kv : config) {\n-            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n-          }\n-          db.write(initBatch);\n-          long configVersion \u003d getConfigVersion() + 1L;\n-          versiondb.put(bytes(CONF_VERSION_KEY),\n-              bytes(String.valueOf(configVersion)));\n+          database \u003d JniDBFactory.factory.open(configurationFile, options);\n+          initMethod.accept(database);\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n+\n+    return database;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private DB initDatabaseHelper(File configurationFile, Options options,\n      Consumer\u003cDB\u003e initMethod) throws Exception {\n    DB database;\n    try {\n      database \u003d JniDBFactory.factory.open(configurationFile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating configuration version/database at {}\",\n            configurationFile);\n        options.createIfMissing(true);\n        try {\n          database \u003d JniDBFactory.factory.open(configurationFile, options);\n          initMethod.accept(database);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n\n    return database;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java",
          "extendedDetails": {
            "oldValue": "initDatabase",
            "newValue": "initDatabaseHelper"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-9998. Code cleanup in LeveldbConfigurationStore. Contributed by Benjamin Teke\n",
          "commitDate": "26/03/20 4:18 AM",
          "commitName": "348685dcb9c1a0ea50b536170b3a8c77a8f8df06",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "10/03/20 8:35 AM",
          "commitNameOld": "61f4cf3055e60e64a95f4599ebceac5a924bba02",
          "commitAuthorOld": "Szilard Nemeth",
          "daysBetweenCommits": 15.82,
          "commitsBetweenForRepo": 57,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,87 +1,23 @@\n-  private void initDatabase(Configuration config) throws Exception {\n-    Path storeRoot \u003d createStorageDir(DB_NAME);\n-    Options options \u003d new Options();\n-    options.createIfMissing(false);\n-    options.comparator(new DBComparator() {\n-      @Override\n-      public int compare(byte[] key1, byte[] key2) {\n-        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n-        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n-        if (key1Str.equals(key2Str)) {\n-          return 0;\n-        } else if (key1Str.equals(VERSION_KEY)) {\n-          return 1;\n-        } else if (key2Str.equals(VERSION_KEY)) {\n-          return -1;\n-        } else if (key1Str.equals(LOG_KEY)) {\n-          return 1;\n-        } else if (key2Str.equals(LOG_KEY)) {\n-          return -1;\n-        }\n-        return key1Str.compareTo(key2Str);\n-      }\n-\n-      @Override\n-      public String name() {\n-        return \"keyComparator\";\n-      }\n-\n-      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n-        return start;\n-      }\n-\n-      public byte[] findShortSuccessor(byte[] key) {\n-        return key;\n-      }\n-    });\n-\n-    Path confVersion \u003d createStorageDir(CONF_VERSION_NAME);\n-    Options confOptions \u003d new Options();\n-    confOptions.createIfMissing(false);\n-    LOG.info(\"Using conf version at \" + confVersion);\n-    File confVersionFile \u003d new File(confVersion.toString());\n+  private DB initDatabaseHelper(File configurationFile, Options options,\n+      Consumer\u003cDB\u003e initMethod) throws Exception {\n+    DB database;\n     try {\n-      versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n+      database \u003d JniDBFactory.factory.open(configurationFile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n-        LOG.info(\"Creating conf version at \" + confVersionFile);\n-        confOptions.createIfMissing(true);\n-        try {\n-          versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n-          versiondb.put(bytes(CONF_VERSION_KEY), bytes(String.valueOf(0)));\n-        } catch (DBException dbErr) {\n-          throw new IOException(dbErr.getMessage(), dbErr);\n-        }\n-      } else {\n-        throw e;\n-      }\n-    }\n-\n-\n-    LOG.info(\"Using conf database at \" + storeRoot);\n-    File dbfile \u003d new File(storeRoot.toString());\n-    try {\n-      db \u003d JniDBFactory.factory.open(dbfile, options);\n-    } catch (NativeDB.DBException e) {\n-      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n-        LOG.info(\"Creating conf database at \" + dbfile);\n+        LOG.info(\"Creating configuration version/database at {}\",\n+            configurationFile);\n         options.createIfMissing(true);\n         try {\n-          db \u003d JniDBFactory.factory.open(dbfile, options);\n-          // Write the initial scheduler configuration\n-          WriteBatch initBatch \u003d db.createWriteBatch();\n-          for (Map.Entry\u003cString, String\u003e kv : config) {\n-            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n-          }\n-          db.write(initBatch);\n-          long configVersion \u003d getConfigVersion() + 1L;\n-          versiondb.put(bytes(CONF_VERSION_KEY),\n-              bytes(String.valueOf(configVersion)));\n+          database \u003d JniDBFactory.factory.open(configurationFile, options);\n+          initMethod.accept(database);\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n+\n+    return database;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private DB initDatabaseHelper(File configurationFile, Options options,\n      Consumer\u003cDB\u003e initMethod) throws Exception {\n    DB database;\n    try {\n      database \u003d JniDBFactory.factory.open(configurationFile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating configuration version/database at {}\",\n            configurationFile);\n        options.createIfMissing(true);\n        try {\n          database \u003d JniDBFactory.factory.open(configurationFile, options);\n          initMethod.accept(database);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n\n    return database;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java",
          "extendedDetails": {
            "oldValue": "[config-Configuration]",
            "newValue": "[configurationFile-File, options-Options, initMethod-Consumer\u003cDB\u003e]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-9998. Code cleanup in LeveldbConfigurationStore. Contributed by Benjamin Teke\n",
          "commitDate": "26/03/20 4:18 AM",
          "commitName": "348685dcb9c1a0ea50b536170b3a8c77a8f8df06",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "10/03/20 8:35 AM",
          "commitNameOld": "61f4cf3055e60e64a95f4599ebceac5a924bba02",
          "commitAuthorOld": "Szilard Nemeth",
          "daysBetweenCommits": 15.82,
          "commitsBetweenForRepo": 57,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,87 +1,23 @@\n-  private void initDatabase(Configuration config) throws Exception {\n-    Path storeRoot \u003d createStorageDir(DB_NAME);\n-    Options options \u003d new Options();\n-    options.createIfMissing(false);\n-    options.comparator(new DBComparator() {\n-      @Override\n-      public int compare(byte[] key1, byte[] key2) {\n-        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n-        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n-        if (key1Str.equals(key2Str)) {\n-          return 0;\n-        } else if (key1Str.equals(VERSION_KEY)) {\n-          return 1;\n-        } else if (key2Str.equals(VERSION_KEY)) {\n-          return -1;\n-        } else if (key1Str.equals(LOG_KEY)) {\n-          return 1;\n-        } else if (key2Str.equals(LOG_KEY)) {\n-          return -1;\n-        }\n-        return key1Str.compareTo(key2Str);\n-      }\n-\n-      @Override\n-      public String name() {\n-        return \"keyComparator\";\n-      }\n-\n-      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n-        return start;\n-      }\n-\n-      public byte[] findShortSuccessor(byte[] key) {\n-        return key;\n-      }\n-    });\n-\n-    Path confVersion \u003d createStorageDir(CONF_VERSION_NAME);\n-    Options confOptions \u003d new Options();\n-    confOptions.createIfMissing(false);\n-    LOG.info(\"Using conf version at \" + confVersion);\n-    File confVersionFile \u003d new File(confVersion.toString());\n+  private DB initDatabaseHelper(File configurationFile, Options options,\n+      Consumer\u003cDB\u003e initMethod) throws Exception {\n+    DB database;\n     try {\n-      versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n+      database \u003d JniDBFactory.factory.open(configurationFile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n-        LOG.info(\"Creating conf version at \" + confVersionFile);\n-        confOptions.createIfMissing(true);\n-        try {\n-          versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n-          versiondb.put(bytes(CONF_VERSION_KEY), bytes(String.valueOf(0)));\n-        } catch (DBException dbErr) {\n-          throw new IOException(dbErr.getMessage(), dbErr);\n-        }\n-      } else {\n-        throw e;\n-      }\n-    }\n-\n-\n-    LOG.info(\"Using conf database at \" + storeRoot);\n-    File dbfile \u003d new File(storeRoot.toString());\n-    try {\n-      db \u003d JniDBFactory.factory.open(dbfile, options);\n-    } catch (NativeDB.DBException e) {\n-      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n-        LOG.info(\"Creating conf database at \" + dbfile);\n+        LOG.info(\"Creating configuration version/database at {}\",\n+            configurationFile);\n         options.createIfMissing(true);\n         try {\n-          db \u003d JniDBFactory.factory.open(dbfile, options);\n-          // Write the initial scheduler configuration\n-          WriteBatch initBatch \u003d db.createWriteBatch();\n-          for (Map.Entry\u003cString, String\u003e kv : config) {\n-            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n-          }\n-          db.write(initBatch);\n-          long configVersion \u003d getConfigVersion() + 1L;\n-          versiondb.put(bytes(CONF_VERSION_KEY),\n-              bytes(String.valueOf(configVersion)));\n+          database \u003d JniDBFactory.factory.open(configurationFile, options);\n+          initMethod.accept(database);\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n+\n+    return database;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private DB initDatabaseHelper(File configurationFile, Options options,\n      Consumer\u003cDB\u003e initMethod) throws Exception {\n    DB database;\n    try {\n      database \u003d JniDBFactory.factory.open(configurationFile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating configuration version/database at {}\",\n            configurationFile);\n        options.createIfMissing(true);\n        try {\n          database \u003d JniDBFactory.factory.open(configurationFile, options);\n          initMethod.accept(database);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n\n    return database;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "DB"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9998. Code cleanup in LeveldbConfigurationStore. Contributed by Benjamin Teke\n",
          "commitDate": "26/03/20 4:18 AM",
          "commitName": "348685dcb9c1a0ea50b536170b3a8c77a8f8df06",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "10/03/20 8:35 AM",
          "commitNameOld": "61f4cf3055e60e64a95f4599ebceac5a924bba02",
          "commitAuthorOld": "Szilard Nemeth",
          "daysBetweenCommits": 15.82,
          "commitsBetweenForRepo": 57,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,87 +1,23 @@\n-  private void initDatabase(Configuration config) throws Exception {\n-    Path storeRoot \u003d createStorageDir(DB_NAME);\n-    Options options \u003d new Options();\n-    options.createIfMissing(false);\n-    options.comparator(new DBComparator() {\n-      @Override\n-      public int compare(byte[] key1, byte[] key2) {\n-        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n-        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n-        if (key1Str.equals(key2Str)) {\n-          return 0;\n-        } else if (key1Str.equals(VERSION_KEY)) {\n-          return 1;\n-        } else if (key2Str.equals(VERSION_KEY)) {\n-          return -1;\n-        } else if (key1Str.equals(LOG_KEY)) {\n-          return 1;\n-        } else if (key2Str.equals(LOG_KEY)) {\n-          return -1;\n-        }\n-        return key1Str.compareTo(key2Str);\n-      }\n-\n-      @Override\n-      public String name() {\n-        return \"keyComparator\";\n-      }\n-\n-      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n-        return start;\n-      }\n-\n-      public byte[] findShortSuccessor(byte[] key) {\n-        return key;\n-      }\n-    });\n-\n-    Path confVersion \u003d createStorageDir(CONF_VERSION_NAME);\n-    Options confOptions \u003d new Options();\n-    confOptions.createIfMissing(false);\n-    LOG.info(\"Using conf version at \" + confVersion);\n-    File confVersionFile \u003d new File(confVersion.toString());\n+  private DB initDatabaseHelper(File configurationFile, Options options,\n+      Consumer\u003cDB\u003e initMethod) throws Exception {\n+    DB database;\n     try {\n-      versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n+      database \u003d JniDBFactory.factory.open(configurationFile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n-        LOG.info(\"Creating conf version at \" + confVersionFile);\n-        confOptions.createIfMissing(true);\n-        try {\n-          versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n-          versiondb.put(bytes(CONF_VERSION_KEY), bytes(String.valueOf(0)));\n-        } catch (DBException dbErr) {\n-          throw new IOException(dbErr.getMessage(), dbErr);\n-        }\n-      } else {\n-        throw e;\n-      }\n-    }\n-\n-\n-    LOG.info(\"Using conf database at \" + storeRoot);\n-    File dbfile \u003d new File(storeRoot.toString());\n-    try {\n-      db \u003d JniDBFactory.factory.open(dbfile, options);\n-    } catch (NativeDB.DBException e) {\n-      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n-        LOG.info(\"Creating conf database at \" + dbfile);\n+        LOG.info(\"Creating configuration version/database at {}\",\n+            configurationFile);\n         options.createIfMissing(true);\n         try {\n-          db \u003d JniDBFactory.factory.open(dbfile, options);\n-          // Write the initial scheduler configuration\n-          WriteBatch initBatch \u003d db.createWriteBatch();\n-          for (Map.Entry\u003cString, String\u003e kv : config) {\n-            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n-          }\n-          db.write(initBatch);\n-          long configVersion \u003d getConfigVersion() + 1L;\n-          versiondb.put(bytes(CONF_VERSION_KEY),\n-              bytes(String.valueOf(configVersion)));\n+          database \u003d JniDBFactory.factory.open(configurationFile, options);\n+          initMethod.accept(database);\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n+\n+    return database;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private DB initDatabaseHelper(File configurationFile, Options options,\n      Consumer\u003cDB\u003e initMethod) throws Exception {\n    DB database;\n    try {\n      database \u003d JniDBFactory.factory.open(configurationFile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating configuration version/database at {}\",\n            configurationFile);\n        options.createIfMissing(true);\n        try {\n          database \u003d JniDBFactory.factory.open(configurationFile, options);\n          initMethod.accept(database);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n\n    return database;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "be901f49628a553cfe6a3942478cb528cce2b266": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9873. Mutation API Config Change need to update Version Number. Contributed by Prabhu Joseph\n",
      "commitDate": "09/10/19 3:23 AM",
      "commitName": "be901f49628a553cfe6a3942478cb528cce2b266",
      "commitAuthor": "Sunil G",
      "commitDateOld": "04/10/19 8:45 PM",
      "commitNameOld": "fb1ecff6a26875c7f2b86ef07d7b9145c469377e",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 4.28,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,87 @@\n   private void initDatabase(Configuration config) throws Exception {\n-    Path storeRoot \u003d createStorageDir();\n+    Path storeRoot \u003d createStorageDir(DB_NAME);\n     Options options \u003d new Options();\n     options.createIfMissing(false);\n     options.comparator(new DBComparator() {\n       @Override\n       public int compare(byte[] key1, byte[] key2) {\n         String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n         String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n         if (key1Str.equals(key2Str)) {\n           return 0;\n         } else if (key1Str.equals(VERSION_KEY)) {\n           return 1;\n         } else if (key2Str.equals(VERSION_KEY)) {\n           return -1;\n         } else if (key1Str.equals(LOG_KEY)) {\n           return 1;\n         } else if (key2Str.equals(LOG_KEY)) {\n           return -1;\n         }\n         return key1Str.compareTo(key2Str);\n       }\n \n       @Override\n       public String name() {\n         return \"keyComparator\";\n       }\n \n       public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n         return start;\n       }\n \n       public byte[] findShortSuccessor(byte[] key) {\n         return key;\n       }\n     });\n \n+    Path confVersion \u003d createStorageDir(CONF_VERSION_NAME);\n+    Options confOptions \u003d new Options();\n+    confOptions.createIfMissing(false);\n+    LOG.info(\"Using conf version at \" + confVersion);\n+    File confVersionFile \u003d new File(confVersion.toString());\n+    try {\n+      versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n+    } catch (NativeDB.DBException e) {\n+      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n+        LOG.info(\"Creating conf version at \" + confVersionFile);\n+        confOptions.createIfMissing(true);\n+        try {\n+          versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n+          versiondb.put(bytes(CONF_VERSION_KEY), bytes(String.valueOf(0)));\n+        } catch (DBException dbErr) {\n+          throw new IOException(dbErr.getMessage(), dbErr);\n+        }\n+      } else {\n+        throw e;\n+      }\n+    }\n+\n+\n     LOG.info(\"Using conf database at \" + storeRoot);\n     File dbfile \u003d new File(storeRoot.toString());\n     try {\n       db \u003d JniDBFactory.factory.open(dbfile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n         LOG.info(\"Creating conf database at \" + dbfile);\n         options.createIfMissing(true);\n         try {\n           db \u003d JniDBFactory.factory.open(dbfile, options);\n           // Write the initial scheduler configuration\n           WriteBatch initBatch \u003d db.createWriteBatch();\n           for (Map.Entry\u003cString, String\u003e kv : config) {\n             initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n           }\n           db.write(initBatch);\n+          long configVersion \u003d getConfigVersion() + 1L;\n+          versiondb.put(bytes(CONF_VERSION_KEY),\n+              bytes(String.valueOf(configVersion)));\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initDatabase(Configuration config) throws Exception {\n    Path storeRoot \u003d createStorageDir(DB_NAME);\n    Options options \u003d new Options();\n    options.createIfMissing(false);\n    options.comparator(new DBComparator() {\n      @Override\n      public int compare(byte[] key1, byte[] key2) {\n        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n        if (key1Str.equals(key2Str)) {\n          return 0;\n        } else if (key1Str.equals(VERSION_KEY)) {\n          return 1;\n        } else if (key2Str.equals(VERSION_KEY)) {\n          return -1;\n        } else if (key1Str.equals(LOG_KEY)) {\n          return 1;\n        } else if (key2Str.equals(LOG_KEY)) {\n          return -1;\n        }\n        return key1Str.compareTo(key2Str);\n      }\n\n      @Override\n      public String name() {\n        return \"keyComparator\";\n      }\n\n      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n        return start;\n      }\n\n      public byte[] findShortSuccessor(byte[] key) {\n        return key;\n      }\n    });\n\n    Path confVersion \u003d createStorageDir(CONF_VERSION_NAME);\n    Options confOptions \u003d new Options();\n    confOptions.createIfMissing(false);\n    LOG.info(\"Using conf version at \" + confVersion);\n    File confVersionFile \u003d new File(confVersion.toString());\n    try {\n      versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating conf version at \" + confVersionFile);\n        confOptions.createIfMissing(true);\n        try {\n          versiondb \u003d JniDBFactory.factory.open(confVersionFile, confOptions);\n          versiondb.put(bytes(CONF_VERSION_KEY), bytes(String.valueOf(0)));\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n\n\n    LOG.info(\"Using conf database at \" + storeRoot);\n    File dbfile \u003d new File(storeRoot.toString());\n    try {\n      db \u003d JniDBFactory.factory.open(dbfile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating conf database at \" + dbfile);\n        options.createIfMissing(true);\n        try {\n          db \u003d JniDBFactory.factory.open(dbfile, options);\n          // Write the initial scheduler configuration\n          WriteBatch initBatch \u003d db.createWriteBatch();\n          for (Map.Entry\u003cString, String\u003e kv : config) {\n            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n          }\n          db.write(initBatch);\n          long configVersion \u003d getConfigVersion() + 1L;\n          versiondb.put(bytes(CONF_VERSION_KEY),\n              bytes(String.valueOf(configVersion)));\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java",
      "extendedDetails": {}
    },
    "fb1ecff6a26875c7f2b86ef07d7b9145c469377e": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-9873. Mutation API Config Change updates Version Number. Contributed by Prabhu Joseph\"\n\nThis reverts commit 4510970e2f7728d036c750b596985e5ffa357b60.\n",
      "commitDate": "04/10/19 8:45 PM",
      "commitName": "fb1ecff6a26875c7f2b86ef07d7b9145c469377e",
      "commitAuthor": "Sunil G",
      "commitDateOld": "04/10/19 9:19 AM",
      "commitNameOld": "4510970e2f7728d036c750b596985e5ffa357b60",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 0.48,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,61 @@\n   private void initDatabase(Configuration config) throws Exception {\n     Path storeRoot \u003d createStorageDir();\n     Options options \u003d new Options();\n     options.createIfMissing(false);\n     options.comparator(new DBComparator() {\n       @Override\n       public int compare(byte[] key1, byte[] key2) {\n         String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n         String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n         if (key1Str.equals(key2Str)) {\n           return 0;\n         } else if (key1Str.equals(VERSION_KEY)) {\n           return 1;\n         } else if (key2Str.equals(VERSION_KEY)) {\n           return -1;\n         } else if (key1Str.equals(LOG_KEY)) {\n           return 1;\n         } else if (key2Str.equals(LOG_KEY)) {\n           return -1;\n-        } else if (key1Str.equals(CONF_VERSION_KEY)) {\n-          return 1;\n-        } else if (key2Str.equals(CONF_VERSION_KEY)) {\n-          return -1;\n         }\n         return key1Str.compareTo(key2Str);\n       }\n \n       @Override\n       public String name() {\n         return \"keyComparator\";\n       }\n \n       public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n         return start;\n       }\n \n       public byte[] findShortSuccessor(byte[] key) {\n         return key;\n       }\n     });\n \n     LOG.info(\"Using conf database at \" + storeRoot);\n     File dbfile \u003d new File(storeRoot.toString());\n     try {\n       db \u003d JniDBFactory.factory.open(dbfile, options);\n-      if (db.get(bytes(CONF_VERSION_KEY)) \u003d\u003d null) {\n-        db.put(bytes(CONF_VERSION_KEY),\n-            bytes(String.valueOf(System.currentTimeMillis())));\n-      }\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n         LOG.info(\"Creating conf database at \" + dbfile);\n         options.createIfMissing(true);\n         try {\n           db \u003d JniDBFactory.factory.open(dbfile, options);\n           // Write the initial scheduler configuration\n           WriteBatch initBatch \u003d db.createWriteBatch();\n           for (Map.Entry\u003cString, String\u003e kv : config) {\n             initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n           }\n           db.write(initBatch);\n-          db.put(bytes(CONF_VERSION_KEY),\n-              bytes(String.valueOf(System.currentTimeMillis())));\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initDatabase(Configuration config) throws Exception {\n    Path storeRoot \u003d createStorageDir();\n    Options options \u003d new Options();\n    options.createIfMissing(false);\n    options.comparator(new DBComparator() {\n      @Override\n      public int compare(byte[] key1, byte[] key2) {\n        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n        if (key1Str.equals(key2Str)) {\n          return 0;\n        } else if (key1Str.equals(VERSION_KEY)) {\n          return 1;\n        } else if (key2Str.equals(VERSION_KEY)) {\n          return -1;\n        } else if (key1Str.equals(LOG_KEY)) {\n          return 1;\n        } else if (key2Str.equals(LOG_KEY)) {\n          return -1;\n        }\n        return key1Str.compareTo(key2Str);\n      }\n\n      @Override\n      public String name() {\n        return \"keyComparator\";\n      }\n\n      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n        return start;\n      }\n\n      public byte[] findShortSuccessor(byte[] key) {\n        return key;\n      }\n    });\n\n    LOG.info(\"Using conf database at \" + storeRoot);\n    File dbfile \u003d new File(storeRoot.toString());\n    try {\n      db \u003d JniDBFactory.factory.open(dbfile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating conf database at \" + dbfile);\n        options.createIfMissing(true);\n        try {\n          db \u003d JniDBFactory.factory.open(dbfile, options);\n          // Write the initial scheduler configuration\n          WriteBatch initBatch \u003d db.createWriteBatch();\n          for (Map.Entry\u003cString, String\u003e kv : config) {\n            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n          }\n          db.write(initBatch);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java",
      "extendedDetails": {}
    },
    "4510970e2f7728d036c750b596985e5ffa357b60": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9873. Mutation API Config Change updates Version Number. Contributed by Prabhu Joseph\n",
      "commitDate": "04/10/19 9:19 AM",
      "commitName": "4510970e2f7728d036c750b596985e5ffa357b60",
      "commitAuthor": "Sunil G",
      "commitDateOld": "30/09/19 8:38 PM",
      "commitNameOld": "137546a78a45adbfb5ef338c1c2984a97b3cecc2",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 3.53,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,71 @@\n   private void initDatabase(Configuration config) throws Exception {\n     Path storeRoot \u003d createStorageDir();\n     Options options \u003d new Options();\n     options.createIfMissing(false);\n     options.comparator(new DBComparator() {\n       @Override\n       public int compare(byte[] key1, byte[] key2) {\n         String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n         String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n         if (key1Str.equals(key2Str)) {\n           return 0;\n         } else if (key1Str.equals(VERSION_KEY)) {\n           return 1;\n         } else if (key2Str.equals(VERSION_KEY)) {\n           return -1;\n         } else if (key1Str.equals(LOG_KEY)) {\n           return 1;\n         } else if (key2Str.equals(LOG_KEY)) {\n           return -1;\n+        } else if (key1Str.equals(CONF_VERSION_KEY)) {\n+          return 1;\n+        } else if (key2Str.equals(CONF_VERSION_KEY)) {\n+          return -1;\n         }\n         return key1Str.compareTo(key2Str);\n       }\n \n       @Override\n       public String name() {\n         return \"keyComparator\";\n       }\n \n       public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n         return start;\n       }\n \n       public byte[] findShortSuccessor(byte[] key) {\n         return key;\n       }\n     });\n \n     LOG.info(\"Using conf database at \" + storeRoot);\n     File dbfile \u003d new File(storeRoot.toString());\n     try {\n       db \u003d JniDBFactory.factory.open(dbfile, options);\n+      if (db.get(bytes(CONF_VERSION_KEY)) \u003d\u003d null) {\n+        db.put(bytes(CONF_VERSION_KEY),\n+            bytes(String.valueOf(System.currentTimeMillis())));\n+      }\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n         LOG.info(\"Creating conf database at \" + dbfile);\n         options.createIfMissing(true);\n         try {\n           db \u003d JniDBFactory.factory.open(dbfile, options);\n           // Write the initial scheduler configuration\n           WriteBatch initBatch \u003d db.createWriteBatch();\n           for (Map.Entry\u003cString, String\u003e kv : config) {\n             initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n           }\n           db.write(initBatch);\n+          db.put(bytes(CONF_VERSION_KEY),\n+              bytes(String.valueOf(System.currentTimeMillis())));\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initDatabase(Configuration config) throws Exception {\n    Path storeRoot \u003d createStorageDir();\n    Options options \u003d new Options();\n    options.createIfMissing(false);\n    options.comparator(new DBComparator() {\n      @Override\n      public int compare(byte[] key1, byte[] key2) {\n        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n        if (key1Str.equals(key2Str)) {\n          return 0;\n        } else if (key1Str.equals(VERSION_KEY)) {\n          return 1;\n        } else if (key2Str.equals(VERSION_KEY)) {\n          return -1;\n        } else if (key1Str.equals(LOG_KEY)) {\n          return 1;\n        } else if (key2Str.equals(LOG_KEY)) {\n          return -1;\n        } else if (key1Str.equals(CONF_VERSION_KEY)) {\n          return 1;\n        } else if (key2Str.equals(CONF_VERSION_KEY)) {\n          return -1;\n        }\n        return key1Str.compareTo(key2Str);\n      }\n\n      @Override\n      public String name() {\n        return \"keyComparator\";\n      }\n\n      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n        return start;\n      }\n\n      public byte[] findShortSuccessor(byte[] key) {\n        return key;\n      }\n    });\n\n    LOG.info(\"Using conf database at \" + storeRoot);\n    File dbfile \u003d new File(storeRoot.toString());\n    try {\n      db \u003d JniDBFactory.factory.open(dbfile, options);\n      if (db.get(bytes(CONF_VERSION_KEY)) \u003d\u003d null) {\n        db.put(bytes(CONF_VERSION_KEY),\n            bytes(String.valueOf(System.currentTimeMillis())));\n      }\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating conf database at \" + dbfile);\n        options.createIfMissing(true);\n        try {\n          db \u003d JniDBFactory.factory.open(dbfile, options);\n          // Write the initial scheduler configuration\n          WriteBatch initBatch \u003d db.createWriteBatch();\n          for (Map.Entry\u003cString, String\u003e kv : config) {\n            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n          }\n          db.write(initBatch);\n          db.put(bytes(CONF_VERSION_KEY),\n              bytes(String.valueOf(System.currentTimeMillis())));\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java",
      "extendedDetails": {}
    },
    "d6622daaa3c95a5040d06f91dc0c793bafa70f95": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-7046. Add closing logic to configuration store\n",
      "commitDate": "09/10/17 11:11 AM",
      "commitName": "d6622daaa3c95a5040d06f91dc0c793bafa70f95",
      "commitAuthor": "Jonathan Hung",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-7046. Add closing logic to configuration store\n",
          "commitDate": "09/10/17 11:11 AM",
          "commitName": "d6622daaa3c95a5040d06f91dc0c793bafa70f95",
          "commitAuthor": "Jonathan Hung",
          "commitDateOld": "09/10/17 11:11 AM",
          "commitNameOld": "ff39c0de206a4fce1f0e8a416357a7a8261f8634",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,61 @@\n-  private DB initDatabase(Configuration config) throws Exception {\n+  private void initDatabase(Configuration config) throws Exception {\n     Path storeRoot \u003d createStorageDir();\n     Options options \u003d new Options();\n     options.createIfMissing(false);\n     options.comparator(new DBComparator() {\n       @Override\n       public int compare(byte[] key1, byte[] key2) {\n         String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n         String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n         if (key1Str.equals(key2Str)) {\n           return 0;\n         } else if (key1Str.equals(VERSION_KEY)) {\n-          return -1;\n+          return 1;\n         } else if (key2Str.equals(VERSION_KEY)) {\n-          return 1;\n-        } else if (key1Str.equals(LOG_KEY)) {\n           return -1;\n-        } else if (key2Str.equals(LOG_KEY)) {\n+        } else if (key1Str.equals(LOG_KEY)) {\n           return 1;\n+        } else if (key2Str.equals(LOG_KEY)) {\n+          return -1;\n         }\n         return key1Str.compareTo(key2Str);\n       }\n \n       @Override\n       public String name() {\n         return \"keyComparator\";\n       }\n \n       public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n         return start;\n       }\n \n       public byte[] findShortSuccessor(byte[] key) {\n         return key;\n       }\n     });\n \n     LOG.info(\"Using conf database at \" + storeRoot);\n     File dbfile \u003d new File(storeRoot.toString());\n     try {\n       db \u003d JniDBFactory.factory.open(dbfile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n         LOG.info(\"Creating conf database at \" + dbfile);\n         options.createIfMissing(true);\n         try {\n           db \u003d JniDBFactory.factory.open(dbfile, options);\n           // Write the initial scheduler configuration\n           WriteBatch initBatch \u003d db.createWriteBatch();\n           for (Map.Entry\u003cString, String\u003e kv : config) {\n             initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n           }\n           db.write(initBatch);\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n-    return db;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void initDatabase(Configuration config) throws Exception {\n    Path storeRoot \u003d createStorageDir();\n    Options options \u003d new Options();\n    options.createIfMissing(false);\n    options.comparator(new DBComparator() {\n      @Override\n      public int compare(byte[] key1, byte[] key2) {\n        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n        if (key1Str.equals(key2Str)) {\n          return 0;\n        } else if (key1Str.equals(VERSION_KEY)) {\n          return 1;\n        } else if (key2Str.equals(VERSION_KEY)) {\n          return -1;\n        } else if (key1Str.equals(LOG_KEY)) {\n          return 1;\n        } else if (key2Str.equals(LOG_KEY)) {\n          return -1;\n        }\n        return key1Str.compareTo(key2Str);\n      }\n\n      @Override\n      public String name() {\n        return \"keyComparator\";\n      }\n\n      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n        return start;\n      }\n\n      public byte[] findShortSuccessor(byte[] key) {\n        return key;\n      }\n    });\n\n    LOG.info(\"Using conf database at \" + storeRoot);\n    File dbfile \u003d new File(storeRoot.toString());\n    try {\n      db \u003d JniDBFactory.factory.open(dbfile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating conf database at \" + dbfile);\n        options.createIfMissing(true);\n        try {\n          db \u003d JniDBFactory.factory.open(dbfile, options);\n          // Write the initial scheduler configuration\n          WriteBatch initBatch \u003d db.createWriteBatch();\n          for (Map.Entry\u003cString, String\u003e kv : config) {\n            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n          }\n          db.write(initBatch);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java",
          "extendedDetails": {
            "oldValue": "DB",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7046. Add closing logic to configuration store\n",
          "commitDate": "09/10/17 11:11 AM",
          "commitName": "d6622daaa3c95a5040d06f91dc0c793bafa70f95",
          "commitAuthor": "Jonathan Hung",
          "commitDateOld": "09/10/17 11:11 AM",
          "commitNameOld": "ff39c0de206a4fce1f0e8a416357a7a8261f8634",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,61 @@\n-  private DB initDatabase(Configuration config) throws Exception {\n+  private void initDatabase(Configuration config) throws Exception {\n     Path storeRoot \u003d createStorageDir();\n     Options options \u003d new Options();\n     options.createIfMissing(false);\n     options.comparator(new DBComparator() {\n       @Override\n       public int compare(byte[] key1, byte[] key2) {\n         String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n         String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n         if (key1Str.equals(key2Str)) {\n           return 0;\n         } else if (key1Str.equals(VERSION_KEY)) {\n-          return -1;\n+          return 1;\n         } else if (key2Str.equals(VERSION_KEY)) {\n-          return 1;\n-        } else if (key1Str.equals(LOG_KEY)) {\n           return -1;\n-        } else if (key2Str.equals(LOG_KEY)) {\n+        } else if (key1Str.equals(LOG_KEY)) {\n           return 1;\n+        } else if (key2Str.equals(LOG_KEY)) {\n+          return -1;\n         }\n         return key1Str.compareTo(key2Str);\n       }\n \n       @Override\n       public String name() {\n         return \"keyComparator\";\n       }\n \n       public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n         return start;\n       }\n \n       public byte[] findShortSuccessor(byte[] key) {\n         return key;\n       }\n     });\n \n     LOG.info(\"Using conf database at \" + storeRoot);\n     File dbfile \u003d new File(storeRoot.toString());\n     try {\n       db \u003d JniDBFactory.factory.open(dbfile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n         LOG.info(\"Creating conf database at \" + dbfile);\n         options.createIfMissing(true);\n         try {\n           db \u003d JniDBFactory.factory.open(dbfile, options);\n           // Write the initial scheduler configuration\n           WriteBatch initBatch \u003d db.createWriteBatch();\n           for (Map.Entry\u003cString, String\u003e kv : config) {\n             initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n           }\n           db.write(initBatch);\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n-    return db;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void initDatabase(Configuration config) throws Exception {\n    Path storeRoot \u003d createStorageDir();\n    Options options \u003d new Options();\n    options.createIfMissing(false);\n    options.comparator(new DBComparator() {\n      @Override\n      public int compare(byte[] key1, byte[] key2) {\n        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n        if (key1Str.equals(key2Str)) {\n          return 0;\n        } else if (key1Str.equals(VERSION_KEY)) {\n          return 1;\n        } else if (key2Str.equals(VERSION_KEY)) {\n          return -1;\n        } else if (key1Str.equals(LOG_KEY)) {\n          return 1;\n        } else if (key2Str.equals(LOG_KEY)) {\n          return -1;\n        }\n        return key1Str.compareTo(key2Str);\n      }\n\n      @Override\n      public String name() {\n        return \"keyComparator\";\n      }\n\n      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n        return start;\n      }\n\n      public byte[] findShortSuccessor(byte[] key) {\n        return key;\n      }\n    });\n\n    LOG.info(\"Using conf database at \" + storeRoot);\n    File dbfile \u003d new File(storeRoot.toString());\n    try {\n      db \u003d JniDBFactory.factory.open(dbfile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating conf database at \" + dbfile);\n        options.createIfMissing(true);\n        try {\n          db \u003d JniDBFactory.factory.open(dbfile, options);\n          // Write the initial scheduler configuration\n          WriteBatch initBatch \u003d db.createWriteBatch();\n          for (Map.Entry\u003cString, String\u003e kv : config) {\n            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n          }\n          db.write(initBatch);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "ff39c0de206a4fce1f0e8a416357a7a8261f8634": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6840. Implement zookeeper based store for scheduler configuration updates. (Jonathan Hung via wangda)\n\nChange-Id: I9debea674fe8c7e4109d4ca136965a1ea4c48bcc\n",
      "commitDate": "09/10/17 11:11 AM",
      "commitName": "ff39c0de206a4fce1f0e8a416357a7a8261f8634",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/10/17 11:11 AM",
      "commitNameOld": "4d8abd84f40a6124e7b05b34c14b4035309623ef",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,62 @@\n   private DB initDatabase(Configuration config) throws Exception {\n     Path storeRoot \u003d createStorageDir();\n     Options options \u003d new Options();\n     options.createIfMissing(false);\n     options.comparator(new DBComparator() {\n       @Override\n       public int compare(byte[] key1, byte[] key2) {\n         String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n         String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n-        int key1Txn \u003d Integer.MAX_VALUE;\n-        int key2Txn \u003d Integer.MAX_VALUE;\n-        if (key1Str.startsWith(LOG_PREFIX)) {\n-          key1Txn \u003d Integer.parseInt(key1Str.substring(\n-              key1Str.indexOf(\u0027.\u0027) + 1));\n+        if (key1Str.equals(key2Str)) {\n+          return 0;\n+        } else if (key1Str.equals(VERSION_KEY)) {\n+          return -1;\n+        } else if (key2Str.equals(VERSION_KEY)) {\n+          return 1;\n+        } else if (key1Str.equals(LOG_KEY)) {\n+          return -1;\n+        } else if (key2Str.equals(LOG_KEY)) {\n+          return 1;\n         }\n-        if (key2Str.startsWith(LOG_PREFIX)) {\n-          key2Txn \u003d Integer.parseInt(key2Str.substring(\n-              key2Str.indexOf(\u0027.\u0027) + 1));\n-        }\n-        // TODO txnId could overflow, in theory\n-        if (key1Txn \u003d\u003d Integer.MAX_VALUE \u0026\u0026 key2Txn \u003d\u003d Integer.MAX_VALUE) {\n-          if (key1Str.equals(key2Str) \u0026\u0026 key1Str.equals(LOG_COMMITTED_TXN)) {\n-            return 0;\n-          } else if (key1Str.equals(LOG_COMMITTED_TXN)) {\n-            return -1;\n-          } else if (key2Str.equals(LOG_COMMITTED_TXN)) {\n-            return 1;\n-          }\n-          return key1Str.compareTo(key2Str);\n-        }\n-        return key1Txn - key2Txn;\n+        return key1Str.compareTo(key2Str);\n       }\n \n       @Override\n       public String name() {\n-        return \"logComparator\";\n+        return \"keyComparator\";\n       }\n \n       public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n         return start;\n       }\n \n       public byte[] findShortSuccessor(byte[] key) {\n         return key;\n       }\n     });\n+\n     LOG.info(\"Using conf database at \" + storeRoot);\n     File dbfile \u003d new File(storeRoot.toString());\n     try {\n       db \u003d JniDBFactory.factory.open(dbfile, options);\n     } catch (NativeDB.DBException e) {\n       if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n         LOG.info(\"Creating conf database at \" + dbfile);\n         options.createIfMissing(true);\n         try {\n           db \u003d JniDBFactory.factory.open(dbfile, options);\n           // Write the initial scheduler configuration\n           WriteBatch initBatch \u003d db.createWriteBatch();\n           for (Map.Entry\u003cString, String\u003e kv : config) {\n             initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n           }\n-          initBatch.put(bytes(LOG_COMMITTED_TXN), bytes(\"0\"));\n           db.write(initBatch);\n         } catch (DBException dbErr) {\n           throw new IOException(dbErr.getMessage(), dbErr);\n         }\n       } else {\n         throw e;\n       }\n     }\n     return db;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private DB initDatabase(Configuration config) throws Exception {\n    Path storeRoot \u003d createStorageDir();\n    Options options \u003d new Options();\n    options.createIfMissing(false);\n    options.comparator(new DBComparator() {\n      @Override\n      public int compare(byte[] key1, byte[] key2) {\n        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n        if (key1Str.equals(key2Str)) {\n          return 0;\n        } else if (key1Str.equals(VERSION_KEY)) {\n          return -1;\n        } else if (key2Str.equals(VERSION_KEY)) {\n          return 1;\n        } else if (key1Str.equals(LOG_KEY)) {\n          return -1;\n        } else if (key2Str.equals(LOG_KEY)) {\n          return 1;\n        }\n        return key1Str.compareTo(key2Str);\n      }\n\n      @Override\n      public String name() {\n        return \"keyComparator\";\n      }\n\n      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n        return start;\n      }\n\n      public byte[] findShortSuccessor(byte[] key) {\n        return key;\n      }\n    });\n\n    LOG.info(\"Using conf database at \" + storeRoot);\n    File dbfile \u003d new File(storeRoot.toString());\n    try {\n      db \u003d JniDBFactory.factory.open(dbfile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating conf database at \" + dbfile);\n        options.createIfMissing(true);\n        try {\n          db \u003d JniDBFactory.factory.open(dbfile, options);\n          // Write the initial scheduler configuration\n          WriteBatch initBatch \u003d db.createWriteBatch();\n          for (Map.Entry\u003cString, String\u003e kv : config) {\n            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n          }\n          db.write(initBatch);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n    return db;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java",
      "extendedDetails": {}
    },
    "74ba6ffa0b601badc68366685dcf993a0844520a": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5947: Create LeveldbConfigurationStore class using Leveldb as backing store. Contributed by Jonathan Hung\n",
      "commitDate": "09/10/17 11:11 AM",
      "commitName": "74ba6ffa0b601badc68366685dcf993a0844520a",
      "commitAuthor": "Xuan",
      "diff": "@@ -0,0 +1,72 @@\n+  private DB initDatabase(Configuration config) throws Exception {\n+    Path storeRoot \u003d createStorageDir();\n+    Options options \u003d new Options();\n+    options.createIfMissing(false);\n+    options.comparator(new DBComparator() {\n+      @Override\n+      public int compare(byte[] key1, byte[] key2) {\n+        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n+        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n+        int key1Txn \u003d Integer.MAX_VALUE;\n+        int key2Txn \u003d Integer.MAX_VALUE;\n+        if (key1Str.startsWith(LOG_PREFIX)) {\n+          key1Txn \u003d Integer.parseInt(key1Str.substring(\n+              key1Str.indexOf(\u0027.\u0027) + 1));\n+        }\n+        if (key2Str.startsWith(LOG_PREFIX)) {\n+          key2Txn \u003d Integer.parseInt(key2Str.substring(\n+              key2Str.indexOf(\u0027.\u0027) + 1));\n+        }\n+        // TODO txnId could overflow, in theory\n+        if (key1Txn \u003d\u003d Integer.MAX_VALUE \u0026\u0026 key2Txn \u003d\u003d Integer.MAX_VALUE) {\n+          if (key1Str.equals(key2Str) \u0026\u0026 key1Str.equals(LOG_COMMITTED_TXN)) {\n+            return 0;\n+          } else if (key1Str.equals(LOG_COMMITTED_TXN)) {\n+            return -1;\n+          } else if (key2Str.equals(LOG_COMMITTED_TXN)) {\n+            return 1;\n+          }\n+          return key1Str.compareTo(key2Str);\n+        }\n+        return key1Txn - key2Txn;\n+      }\n+\n+      @Override\n+      public String name() {\n+        return \"logComparator\";\n+      }\n+\n+      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n+        return start;\n+      }\n+\n+      public byte[] findShortSuccessor(byte[] key) {\n+        return key;\n+      }\n+    });\n+    LOG.info(\"Using conf database at \" + storeRoot);\n+    File dbfile \u003d new File(storeRoot.toString());\n+    try {\n+      db \u003d JniDBFactory.factory.open(dbfile, options);\n+    } catch (NativeDB.DBException e) {\n+      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n+        LOG.info(\"Creating conf database at \" + dbfile);\n+        options.createIfMissing(true);\n+        try {\n+          db \u003d JniDBFactory.factory.open(dbfile, options);\n+          // Write the initial scheduler configuration\n+          WriteBatch initBatch \u003d db.createWriteBatch();\n+          for (Map.Entry\u003cString, String\u003e kv : config) {\n+            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n+          }\n+          initBatch.put(bytes(LOG_COMMITTED_TXN), bytes(\"0\"));\n+          db.write(initBatch);\n+        } catch (DBException dbErr) {\n+          throw new IOException(dbErr.getMessage(), dbErr);\n+        }\n+      } else {\n+        throw e;\n+      }\n+    }\n+    return db;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private DB initDatabase(Configuration config) throws Exception {\n    Path storeRoot \u003d createStorageDir();\n    Options options \u003d new Options();\n    options.createIfMissing(false);\n    options.comparator(new DBComparator() {\n      @Override\n      public int compare(byte[] key1, byte[] key2) {\n        String key1Str \u003d new String(key1, StandardCharsets.UTF_8);\n        String key2Str \u003d new String(key2, StandardCharsets.UTF_8);\n        int key1Txn \u003d Integer.MAX_VALUE;\n        int key2Txn \u003d Integer.MAX_VALUE;\n        if (key1Str.startsWith(LOG_PREFIX)) {\n          key1Txn \u003d Integer.parseInt(key1Str.substring(\n              key1Str.indexOf(\u0027.\u0027) + 1));\n        }\n        if (key2Str.startsWith(LOG_PREFIX)) {\n          key2Txn \u003d Integer.parseInt(key2Str.substring(\n              key2Str.indexOf(\u0027.\u0027) + 1));\n        }\n        // TODO txnId could overflow, in theory\n        if (key1Txn \u003d\u003d Integer.MAX_VALUE \u0026\u0026 key2Txn \u003d\u003d Integer.MAX_VALUE) {\n          if (key1Str.equals(key2Str) \u0026\u0026 key1Str.equals(LOG_COMMITTED_TXN)) {\n            return 0;\n          } else if (key1Str.equals(LOG_COMMITTED_TXN)) {\n            return -1;\n          } else if (key2Str.equals(LOG_COMMITTED_TXN)) {\n            return 1;\n          }\n          return key1Str.compareTo(key2Str);\n        }\n        return key1Txn - key2Txn;\n      }\n\n      @Override\n      public String name() {\n        return \"logComparator\";\n      }\n\n      public byte[] findShortestSeparator(byte[] start, byte[] limit) {\n        return start;\n      }\n\n      public byte[] findShortSuccessor(byte[] key) {\n        return key;\n      }\n    });\n    LOG.info(\"Using conf database at \" + storeRoot);\n    File dbfile \u003d new File(storeRoot.toString());\n    try {\n      db \u003d JniDBFactory.factory.open(dbfile, options);\n    } catch (NativeDB.DBException e) {\n      if (e.isNotFound() || e.getMessage().contains(\" does not exist \")) {\n        LOG.info(\"Creating conf database at \" + dbfile);\n        options.createIfMissing(true);\n        try {\n          db \u003d JniDBFactory.factory.open(dbfile, options);\n          // Write the initial scheduler configuration\n          WriteBatch initBatch \u003d db.createWriteBatch();\n          for (Map.Entry\u003cString, String\u003e kv : config) {\n            initBatch.put(bytes(kv.getKey()), bytes(kv.getValue()));\n          }\n          initBatch.put(bytes(LOG_COMMITTED_TXN), bytes(\"0\"));\n          db.write(initBatch);\n        } catch (DBException dbErr) {\n          throw new IOException(dbErr.getMessage(), dbErr);\n        }\n      } else {\n        throw e;\n      }\n    }\n    return db;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/conf/LeveldbConfigurationStore.java"
    }
  }
}