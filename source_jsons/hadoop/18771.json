{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FrameworkUploader.java",
  "functionName": "beginUpload",
  "functionId": "beginUpload",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
  "functionStartLine": 176,
  "functionEndLine": 259,
  "numCommitsSeen": 12,
  "timeTaken": 2956,
  "changeHistory": [
    "8d6ff87c1870cf88c3cbc39c4274e283ab6b7423",
    "9886c27c71147a2bcef87b42ff21c2bbe98c8ab4",
    "836643d793c68bf1bee883abece84f024591da7c",
    "d716084f4503bf826ef10424d7025ea1ff4ee104",
    "2316f526902e827b6c1b92a5bddef72d211bc742",
    "3b78607a02f3a81ad730975ecdfa35967413271d"
  ],
  "changeHistoryShort": {
    "8d6ff87c1870cf88c3cbc39c4274e283ab6b7423": "Ybodychange",
    "9886c27c71147a2bcef87b42ff21c2bbe98c8ab4": "Ybodychange",
    "836643d793c68bf1bee883abece84f024591da7c": "Ybodychange",
    "d716084f4503bf826ef10424d7025ea1ff4ee104": "Ybodychange",
    "2316f526902e827b6c1b92a5bddef72d211bc742": "Ymultichange(Ymodifierchange,Ybodychange)",
    "3b78607a02f3a81ad730975ecdfa35967413271d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8d6ff87c1870cf88c3cbc39c4274e283ab6b7423": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7263. Remove obsolete validateTargetPath() from FrameworkUploader. Contributed by Marton Hudaky\n",
      "commitDate": "12/02/20 6:53 AM",
      "commitName": "8d6ff87c1870cf88c3cbc39c4274e283ab6b7423",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "04/12/19 11:02 PM",
      "commitNameOld": "da9aa9c90964a60bef320e8786f3f767ca3e443d",
      "commitAuthorOld": "prabhujoseph",
      "daysBetweenCommits": 69.33,
      "commitsBetweenForRepo": 230,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,84 @@\n   void beginUpload() throws IOException, UploaderException {\n     if (targetStream \u003d\u003d null) {\n-      validateTargetPath();\n       int lastIndex \u003d target.indexOf(\u0027#\u0027);\n       targetPath \u003d\n           new Path(\n               target.substring(\n                   0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n       alias \u003d lastIndex !\u003d -1 ?\n           target.substring(lastIndex + 1) :\n           targetPath.getName();\n       LOG.info(\"Target \" + targetPath);\n       FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n \n       targetStream \u003d null;\n       if (fileSystem instanceof DistributedFileSystem) {\n         LOG.info(\"Set replication to \" +\n             initialReplication + \" for path: \" + targetPath);\n         LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n         DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n         DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n             dfs.createFile(targetPath)\n             .overwrite(true)\n             .ecPolicyName(\n                 SystemErasureCodingPolicies.getReplicationPolicy().getName());\n         if (initialReplication \u003e 0) {\n           builder.replication(initialReplication);\n         }\n         targetStream \u003d builder.build();\n       } else {\n         LOG.warn(\"Cannot set replication to \" +\n             initialReplication + \" for path: \" + targetPath +\n             \" on a non-distributed fileystem \" +\n             fileSystem.getClass().getName());\n       }\n       if (targetStream \u003d\u003d null) {\n         targetStream \u003d fileSystem.create(targetPath, true);\n       }\n \n       if (!FRAMEWORK_PERMISSION.equals(\n           FRAMEWORK_PERMISSION.applyUMask(FsPermission.getUMask(conf)))) {\n         LOG.info(\"Modifying permissions to \" + FRAMEWORK_PERMISSION);\n         fileSystem.setPermission(targetPath, FRAMEWORK_PERMISSION);\n       }\n \n       fsDataStream \u003d (FSDataOutputStream) targetStream;\n       if (targetPath.getName().endsWith(\"gz\") ||\n           targetPath.getName().endsWith(\"tgz\")) {\n         LOG.info(\"Creating GZip\");\n         targetStream \u003d new GZIPOutputStream(targetStream);\n       }\n \n       Path current \u003d targetPath.getParent();\n       // Walk the path backwards to verify that the uploaded\n       // framework is accessible for all users\n       while (current !\u003d null) {\n         try {\n           FileStatus fstat \u003d fileSystem.getFileStatus(current);\n           FsPermission perm \u003d fstat.getPermission();\n \n           // Note: READ is not necessary to enter the directory.\n           // We need to check only the EXECUTE flag\n           boolean userCanEnter \u003d perm.getUserAction()\n               .implies(FsAction.EXECUTE);\n           boolean groupCanEnter \u003d perm.getGroupAction()\n               .implies(FsAction.EXECUTE);\n           boolean othersCanEnter \u003d perm.getOtherAction()\n               .implies(FsAction.EXECUTE);\n \n           if (!userCanEnter || !groupCanEnter || !othersCanEnter) {\n             LOG.warn(\"Path \" + current + \" is not accessible\"\n                 + \" for all users. Current permissions are: \" + perm);\n             LOG.warn(\"Please set EXECUTE permissions on this directory\");\n           }\n           current \u003d current.getParent();\n         } catch (AccessControlException e) {\n           LOG.warn(\"Path \" + current + \" is not accessible,\"\n               + \" cannot retrieve permissions\");\n           LOG.warn(\"Please set EXECUTE permissions on this directory\");\n           LOG.debug(\"Stack trace\", e);\n           break;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void beginUpload() throws IOException, UploaderException {\n    if (targetStream \u003d\u003d null) {\n      int lastIndex \u003d target.indexOf(\u0027#\u0027);\n      targetPath \u003d\n          new Path(\n              target.substring(\n                  0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n      alias \u003d lastIndex !\u003d -1 ?\n          target.substring(lastIndex + 1) :\n          targetPath.getName();\n      LOG.info(\"Target \" + targetPath);\n      FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n\n      targetStream \u003d null;\n      if (fileSystem instanceof DistributedFileSystem) {\n        LOG.info(\"Set replication to \" +\n            initialReplication + \" for path: \" + targetPath);\n        LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n        DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n        DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n            dfs.createFile(targetPath)\n            .overwrite(true)\n            .ecPolicyName(\n                SystemErasureCodingPolicies.getReplicationPolicy().getName());\n        if (initialReplication \u003e 0) {\n          builder.replication(initialReplication);\n        }\n        targetStream \u003d builder.build();\n      } else {\n        LOG.warn(\"Cannot set replication to \" +\n            initialReplication + \" for path: \" + targetPath +\n            \" on a non-distributed fileystem \" +\n            fileSystem.getClass().getName());\n      }\n      if (targetStream \u003d\u003d null) {\n        targetStream \u003d fileSystem.create(targetPath, true);\n      }\n\n      if (!FRAMEWORK_PERMISSION.equals(\n          FRAMEWORK_PERMISSION.applyUMask(FsPermission.getUMask(conf)))) {\n        LOG.info(\"Modifying permissions to \" + FRAMEWORK_PERMISSION);\n        fileSystem.setPermission(targetPath, FRAMEWORK_PERMISSION);\n      }\n\n      fsDataStream \u003d (FSDataOutputStream) targetStream;\n      if (targetPath.getName().endsWith(\"gz\") ||\n          targetPath.getName().endsWith(\"tgz\")) {\n        LOG.info(\"Creating GZip\");\n        targetStream \u003d new GZIPOutputStream(targetStream);\n      }\n\n      Path current \u003d targetPath.getParent();\n      // Walk the path backwards to verify that the uploaded\n      // framework is accessible for all users\n      while (current !\u003d null) {\n        try {\n          FileStatus fstat \u003d fileSystem.getFileStatus(current);\n          FsPermission perm \u003d fstat.getPermission();\n\n          // Note: READ is not necessary to enter the directory.\n          // We need to check only the EXECUTE flag\n          boolean userCanEnter \u003d perm.getUserAction()\n              .implies(FsAction.EXECUTE);\n          boolean groupCanEnter \u003d perm.getGroupAction()\n              .implies(FsAction.EXECUTE);\n          boolean othersCanEnter \u003d perm.getOtherAction()\n              .implies(FsAction.EXECUTE);\n\n          if (!userCanEnter || !groupCanEnter || !othersCanEnter) {\n            LOG.warn(\"Path \" + current + \" is not accessible\"\n                + \" for all users. Current permissions are: \" + perm);\n            LOG.warn(\"Please set EXECUTE permissions on this directory\");\n          }\n          current \u003d current.getParent();\n        } catch (AccessControlException e) {\n          LOG.warn(\"Path \" + current + \" is not accessible,\"\n              + \" cannot retrieve permissions\");\n          LOG.warn(\"Please set EXECUTE permissions on this directory\");\n          LOG.debug(\"Stack trace\", e);\n          break;\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
      "extendedDetails": {}
    },
    "9886c27c71147a2bcef87b42ff21c2bbe98c8ab4": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7159. FrameworkUploader: ensure proper permissions of generated framework tar.gz if restrictive umask is used. Contributed by Peter Bacsko\n",
      "commitDate": "06/12/18 12:48 PM",
      "commitName": "9886c27c71147a2bcef87b42ff21c2bbe98c8ab4",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "22/06/18 1:05 PM",
      "commitNameOld": "ae055622edeb3cbf82baa6ed952fc2abc84c021e",
      "commitAuthorOld": "Miklos Szegedi",
      "daysBetweenCommits": 167.03,
      "commitsBetweenForRepo": 1357,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,85 @@\n   void beginUpload() throws IOException, UploaderException {\n     if (targetStream \u003d\u003d null) {\n       validateTargetPath();\n       int lastIndex \u003d target.indexOf(\u0027#\u0027);\n       targetPath \u003d\n           new Path(\n               target.substring(\n                   0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n       alias \u003d lastIndex !\u003d -1 ?\n           target.substring(lastIndex + 1) :\n           targetPath.getName();\n       LOG.info(\"Target \" + targetPath);\n       FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n \n       targetStream \u003d null;\n       if (fileSystem instanceof DistributedFileSystem) {\n         LOG.info(\"Set replication to \" +\n             initialReplication + \" for path: \" + targetPath);\n         LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n         DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n         DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n             dfs.createFile(targetPath)\n             .overwrite(true)\n             .ecPolicyName(\n                 SystemErasureCodingPolicies.getReplicationPolicy().getName());\n         if (initialReplication \u003e 0) {\n           builder.replication(initialReplication);\n         }\n         targetStream \u003d builder.build();\n       } else {\n         LOG.warn(\"Cannot set replication to \" +\n             initialReplication + \" for path: \" + targetPath +\n             \" on a non-distributed fileystem \" +\n             fileSystem.getClass().getName());\n       }\n       if (targetStream \u003d\u003d null) {\n         targetStream \u003d fileSystem.create(targetPath, true);\n       }\n \n+      if (!FRAMEWORK_PERMISSION.equals(\n+          FRAMEWORK_PERMISSION.applyUMask(FsPermission.getUMask(conf)))) {\n+        LOG.info(\"Modifying permissions to \" + FRAMEWORK_PERMISSION);\n+        fileSystem.setPermission(targetPath, FRAMEWORK_PERMISSION);\n+      }\n+\n+      fsDataStream \u003d (FSDataOutputStream) targetStream;\n       if (targetPath.getName().endsWith(\"gz\") ||\n           targetPath.getName().endsWith(\"tgz\")) {\n         LOG.info(\"Creating GZip\");\n         targetStream \u003d new GZIPOutputStream(targetStream);\n       }\n+\n+      Path current \u003d targetPath.getParent();\n+      // Walk the path backwards to verify that the uploaded\n+      // framework is accessible for all users\n+      while (current !\u003d null) {\n+        try {\n+          FileStatus fstat \u003d fileSystem.getFileStatus(current);\n+          FsPermission perm \u003d fstat.getPermission();\n+\n+          // Note: READ is not necessary to enter the directory.\n+          // We need to check only the EXECUTE flag\n+          boolean userCanEnter \u003d perm.getUserAction()\n+              .implies(FsAction.EXECUTE);\n+          boolean groupCanEnter \u003d perm.getGroupAction()\n+              .implies(FsAction.EXECUTE);\n+          boolean othersCanEnter \u003d perm.getOtherAction()\n+              .implies(FsAction.EXECUTE);\n+\n+          if (!userCanEnter || !groupCanEnter || !othersCanEnter) {\n+            LOG.warn(\"Path \" + current + \" is not accessible\"\n+                + \" for all users. Current permissions are: \" + perm);\n+            LOG.warn(\"Please set EXECUTE permissions on this directory\");\n+          }\n+          current \u003d current.getParent();\n+        } catch (AccessControlException e) {\n+          LOG.warn(\"Path \" + current + \" is not accessible,\"\n+              + \" cannot retrieve permissions\");\n+          LOG.warn(\"Please set EXECUTE permissions on this directory\");\n+          LOG.debug(\"Stack trace\", e);\n+          break;\n+        }\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void beginUpload() throws IOException, UploaderException {\n    if (targetStream \u003d\u003d null) {\n      validateTargetPath();\n      int lastIndex \u003d target.indexOf(\u0027#\u0027);\n      targetPath \u003d\n          new Path(\n              target.substring(\n                  0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n      alias \u003d lastIndex !\u003d -1 ?\n          target.substring(lastIndex + 1) :\n          targetPath.getName();\n      LOG.info(\"Target \" + targetPath);\n      FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n\n      targetStream \u003d null;\n      if (fileSystem instanceof DistributedFileSystem) {\n        LOG.info(\"Set replication to \" +\n            initialReplication + \" for path: \" + targetPath);\n        LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n        DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n        DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n            dfs.createFile(targetPath)\n            .overwrite(true)\n            .ecPolicyName(\n                SystemErasureCodingPolicies.getReplicationPolicy().getName());\n        if (initialReplication \u003e 0) {\n          builder.replication(initialReplication);\n        }\n        targetStream \u003d builder.build();\n      } else {\n        LOG.warn(\"Cannot set replication to \" +\n            initialReplication + \" for path: \" + targetPath +\n            \" on a non-distributed fileystem \" +\n            fileSystem.getClass().getName());\n      }\n      if (targetStream \u003d\u003d null) {\n        targetStream \u003d fileSystem.create(targetPath, true);\n      }\n\n      if (!FRAMEWORK_PERMISSION.equals(\n          FRAMEWORK_PERMISSION.applyUMask(FsPermission.getUMask(conf)))) {\n        LOG.info(\"Modifying permissions to \" + FRAMEWORK_PERMISSION);\n        fileSystem.setPermission(targetPath, FRAMEWORK_PERMISSION);\n      }\n\n      fsDataStream \u003d (FSDataOutputStream) targetStream;\n      if (targetPath.getName().endsWith(\"gz\") ||\n          targetPath.getName().endsWith(\"tgz\")) {\n        LOG.info(\"Creating GZip\");\n        targetStream \u003d new GZIPOutputStream(targetStream);\n      }\n\n      Path current \u003d targetPath.getParent();\n      // Walk the path backwards to verify that the uploaded\n      // framework is accessible for all users\n      while (current !\u003d null) {\n        try {\n          FileStatus fstat \u003d fileSystem.getFileStatus(current);\n          FsPermission perm \u003d fstat.getPermission();\n\n          // Note: READ is not necessary to enter the directory.\n          // We need to check only the EXECUTE flag\n          boolean userCanEnter \u003d perm.getUserAction()\n              .implies(FsAction.EXECUTE);\n          boolean groupCanEnter \u003d perm.getGroupAction()\n              .implies(FsAction.EXECUTE);\n          boolean othersCanEnter \u003d perm.getOtherAction()\n              .implies(FsAction.EXECUTE);\n\n          if (!userCanEnter || !groupCanEnter || !othersCanEnter) {\n            LOG.warn(\"Path \" + current + \" is not accessible\"\n                + \" for all users. Current permissions are: \" + perm);\n            LOG.warn(\"Please set EXECUTE permissions on this directory\");\n          }\n          current \u003d current.getParent();\n        } catch (AccessControlException e) {\n          LOG.warn(\"Path \" + current + \" is not accessible,\"\n              + \" cannot retrieve permissions\");\n          LOG.warn(\"Please set EXECUTE permissions on this directory\");\n          LOG.debug(\"Stack trace\", e);\n          break;\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
      "extendedDetails": {}
    },
    "836643d793c68bf1bee883abece84f024591da7c": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6995. Uploader tool for Distributed Cache Deploy documentation (miklos.szegedi@cloudera.com via rkanter)\n",
      "commitDate": "19/01/18 5:57 PM",
      "commitName": "836643d793c68bf1bee883abece84f024591da7c",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "16/01/18 10:45 AM",
      "commitNameOld": "d716084f4503bf826ef10424d7025ea1ff4ee104",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 3.3,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   void beginUpload() throws IOException, UploaderException {\n     if (targetStream \u003d\u003d null) {\n       validateTargetPath();\n       int lastIndex \u003d target.indexOf(\u0027#\u0027);\n       targetPath \u003d\n           new Path(\n               target.substring(\n                   0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n       alias \u003d lastIndex !\u003d -1 ?\n           target.substring(lastIndex + 1) :\n           targetPath.getName();\n       LOG.info(\"Target \" + targetPath);\n-      FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n+      FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n \n       targetStream \u003d null;\n       if (fileSystem instanceof DistributedFileSystem) {\n         LOG.info(\"Set replication to \" +\n             initialReplication + \" for path: \" + targetPath);\n         LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n         DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n         DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n             dfs.createFile(targetPath)\n             .overwrite(true)\n             .ecPolicyName(\n                 SystemErasureCodingPolicies.getReplicationPolicy().getName());\n         if (initialReplication \u003e 0) {\n           builder.replication(initialReplication);\n         }\n         targetStream \u003d builder.build();\n       } else {\n         LOG.warn(\"Cannot set replication to \" +\n             initialReplication + \" for path: \" + targetPath +\n             \" on a non-distributed fileystem \" +\n             fileSystem.getClass().getName());\n       }\n       if (targetStream \u003d\u003d null) {\n         targetStream \u003d fileSystem.create(targetPath, true);\n       }\n \n       if (targetPath.getName().endsWith(\"gz\") ||\n           targetPath.getName().endsWith(\"tgz\")) {\n         LOG.info(\"Creating GZip\");\n         targetStream \u003d new GZIPOutputStream(targetStream);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void beginUpload() throws IOException, UploaderException {\n    if (targetStream \u003d\u003d null) {\n      validateTargetPath();\n      int lastIndex \u003d target.indexOf(\u0027#\u0027);\n      targetPath \u003d\n          new Path(\n              target.substring(\n                  0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n      alias \u003d lastIndex !\u003d -1 ?\n          target.substring(lastIndex + 1) :\n          targetPath.getName();\n      LOG.info(\"Target \" + targetPath);\n      FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n\n      targetStream \u003d null;\n      if (fileSystem instanceof DistributedFileSystem) {\n        LOG.info(\"Set replication to \" +\n            initialReplication + \" for path: \" + targetPath);\n        LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n        DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n        DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n            dfs.createFile(targetPath)\n            .overwrite(true)\n            .ecPolicyName(\n                SystemErasureCodingPolicies.getReplicationPolicy().getName());\n        if (initialReplication \u003e 0) {\n          builder.replication(initialReplication);\n        }\n        targetStream \u003d builder.build();\n      } else {\n        LOG.warn(\"Cannot set replication to \" +\n            initialReplication + \" for path: \" + targetPath +\n            \" on a non-distributed fileystem \" +\n            fileSystem.getClass().getName());\n      }\n      if (targetStream \u003d\u003d null) {\n        targetStream \u003d fileSystem.create(targetPath, true);\n      }\n\n      if (targetPath.getName().endsWith(\"gz\") ||\n          targetPath.getName().endsWith(\"tgz\")) {\n        LOG.info(\"Creating GZip\");\n        targetStream \u003d new GZIPOutputStream(targetStream);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
      "extendedDetails": {}
    },
    "d716084f4503bf826ef10424d7025ea1ff4ee104": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7032. Add the ability to specify a delayed replication count (miklos.szegedi@cloudera.com via rkanter)\n",
      "commitDate": "16/01/18 10:45 AM",
      "commitName": "d716084f4503bf826ef10424d7025ea1ff4ee104",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "12/01/18 2:18 PM",
      "commitNameOld": "e404650f489727d2df9a8813fddc4e0d682fbbee",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 3.85,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   void beginUpload() throws IOException, UploaderException {\n     if (targetStream \u003d\u003d null) {\n       validateTargetPath();\n       int lastIndex \u003d target.indexOf(\u0027#\u0027);\n-      Path targetPath \u003d\n+      targetPath \u003d\n           new Path(\n               target.substring(\n                   0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n       alias \u003d lastIndex !\u003d -1 ?\n           target.substring(lastIndex + 1) :\n           targetPath.getName();\n       LOG.info(\"Target \" + targetPath);\n       FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n \n       targetStream \u003d null;\n       if (fileSystem instanceof DistributedFileSystem) {\n         LOG.info(\"Set replication to \" +\n-            replication + \" for path: \" + targetPath);\n+            initialReplication + \" for path: \" + targetPath);\n         LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n         DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n         DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n             dfs.createFile(targetPath)\n             .overwrite(true)\n             .ecPolicyName(\n                 SystemErasureCodingPolicies.getReplicationPolicy().getName());\n-        if (replication \u003e 0) {\n-          builder.replication(replication);\n+        if (initialReplication \u003e 0) {\n+          builder.replication(initialReplication);\n         }\n         targetStream \u003d builder.build();\n       } else {\n         LOG.warn(\"Cannot set replication to \" +\n-            replication + \" for path: \" + targetPath +\n+            initialReplication + \" for path: \" + targetPath +\n             \" on a non-distributed fileystem \" +\n             fileSystem.getClass().getName());\n       }\n       if (targetStream \u003d\u003d null) {\n         targetStream \u003d fileSystem.create(targetPath, true);\n       }\n \n       if (targetPath.getName().endsWith(\"gz\") ||\n           targetPath.getName().endsWith(\"tgz\")) {\n         LOG.info(\"Creating GZip\");\n         targetStream \u003d new GZIPOutputStream(targetStream);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void beginUpload() throws IOException, UploaderException {\n    if (targetStream \u003d\u003d null) {\n      validateTargetPath();\n      int lastIndex \u003d target.indexOf(\u0027#\u0027);\n      targetPath \u003d\n          new Path(\n              target.substring(\n                  0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n      alias \u003d lastIndex !\u003d -1 ?\n          target.substring(lastIndex + 1) :\n          targetPath.getName();\n      LOG.info(\"Target \" + targetPath);\n      FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n\n      targetStream \u003d null;\n      if (fileSystem instanceof DistributedFileSystem) {\n        LOG.info(\"Set replication to \" +\n            initialReplication + \" for path: \" + targetPath);\n        LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n        DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n        DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n            dfs.createFile(targetPath)\n            .overwrite(true)\n            .ecPolicyName(\n                SystemErasureCodingPolicies.getReplicationPolicy().getName());\n        if (initialReplication \u003e 0) {\n          builder.replication(initialReplication);\n        }\n        targetStream \u003d builder.build();\n      } else {\n        LOG.warn(\"Cannot set replication to \" +\n            initialReplication + \" for path: \" + targetPath +\n            \" on a non-distributed fileystem \" +\n            fileSystem.getClass().getName());\n      }\n      if (targetStream \u003d\u003d null) {\n        targetStream \u003d fileSystem.create(targetPath, true);\n      }\n\n      if (targetPath.getName().endsWith(\"gz\") ||\n          targetPath.getName().endsWith(\"tgz\")) {\n        LOG.info(\"Creating GZip\");\n        targetStream \u003d new GZIPOutputStream(targetStream);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
      "extendedDetails": {}
    },
    "2316f526902e827b6c1b92a5bddef72d211bc742": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-7018. Apply erasure coding properly to framework tarball and support plain tar (miklos.szegedi@cloudera.com via rkanter)\n",
      "commitDate": "11/12/17 2:00 PM",
      "commitName": "2316f526902e827b6c1b92a5bddef72d211bc742",
      "commitAuthor": "Robert Kanter",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "MAPREDUCE-7018. Apply erasure coding properly to framework tarball and support plain tar (miklos.szegedi@cloudera.com via rkanter)\n",
          "commitDate": "11/12/17 2:00 PM",
          "commitName": "2316f526902e827b6c1b92a5bddef72d211bc742",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "01/12/17 12:12 PM",
          "commitNameOld": "3b78607a02f3a81ad730975ecdfa35967413271d",
          "commitAuthorOld": "Robert Kanter",
          "daysBetweenCommits": 10.08,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,46 @@\n-  private void beginUpload() throws IOException, UploaderException {\n+  void beginUpload() throws IOException, UploaderException {\n     if (targetStream \u003d\u003d null) {\n       validateTargetPath();\n       int lastIndex \u003d target.indexOf(\u0027#\u0027);\n-      targetPath \u003d\n+      Path targetPath \u003d\n           new Path(\n               target.substring(\n                   0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n       alias \u003d lastIndex !\u003d -1 ?\n           target.substring(lastIndex + 1) :\n           targetPath.getName();\n       LOG.info(\"Target \" + targetPath);\n       FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n-      targetStream \u003d fileSystem.create(targetPath, true);\n+\n+      targetStream \u003d null;\n+      if (fileSystem instanceof DistributedFileSystem) {\n+        LOG.info(\"Set replication to \" +\n+            replication + \" for path: \" + targetPath);\n+        LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n+        DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n+        DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n+            dfs.createFile(targetPath)\n+            .overwrite(true)\n+            .ecPolicyName(\n+                SystemErasureCodingPolicies.getReplicationPolicy().getName());\n+        if (replication \u003e 0) {\n+          builder.replication(replication);\n+        }\n+        targetStream \u003d builder.build();\n+      } else {\n+        LOG.warn(\"Cannot set replication to \" +\n+            replication + \" for path: \" + targetPath +\n+            \" on a non-distributed fileystem \" +\n+            fileSystem.getClass().getName());\n+      }\n+      if (targetStream \u003d\u003d null) {\n+        targetStream \u003d fileSystem.create(targetPath, true);\n+      }\n+\n+      if (targetPath.getName().endsWith(\"gz\") ||\n+          targetPath.getName().endsWith(\"tgz\")) {\n+        LOG.info(\"Creating GZip\");\n+        targetStream \u003d new GZIPOutputStream(targetStream);\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void beginUpload() throws IOException, UploaderException {\n    if (targetStream \u003d\u003d null) {\n      validateTargetPath();\n      int lastIndex \u003d target.indexOf(\u0027#\u0027);\n      Path targetPath \u003d\n          new Path(\n              target.substring(\n                  0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n      alias \u003d lastIndex !\u003d -1 ?\n          target.substring(lastIndex + 1) :\n          targetPath.getName();\n      LOG.info(\"Target \" + targetPath);\n      FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n\n      targetStream \u003d null;\n      if (fileSystem instanceof DistributedFileSystem) {\n        LOG.info(\"Set replication to \" +\n            replication + \" for path: \" + targetPath);\n        LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n        DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n        DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n            dfs.createFile(targetPath)\n            .overwrite(true)\n            .ecPolicyName(\n                SystemErasureCodingPolicies.getReplicationPolicy().getName());\n        if (replication \u003e 0) {\n          builder.replication(replication);\n        }\n        targetStream \u003d builder.build();\n      } else {\n        LOG.warn(\"Cannot set replication to \" +\n            replication + \" for path: \" + targetPath +\n            \" on a non-distributed fileystem \" +\n            fileSystem.getClass().getName());\n      }\n      if (targetStream \u003d\u003d null) {\n        targetStream \u003d fileSystem.create(targetPath, true);\n      }\n\n      if (targetPath.getName().endsWith(\"gz\") ||\n          targetPath.getName().endsWith(\"tgz\")) {\n        LOG.info(\"Creating GZip\");\n        targetStream \u003d new GZIPOutputStream(targetStream);\n      }\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-7018. Apply erasure coding properly to framework tarball and support plain tar (miklos.szegedi@cloudera.com via rkanter)\n",
          "commitDate": "11/12/17 2:00 PM",
          "commitName": "2316f526902e827b6c1b92a5bddef72d211bc742",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "01/12/17 12:12 PM",
          "commitNameOld": "3b78607a02f3a81ad730975ecdfa35967413271d",
          "commitAuthorOld": "Robert Kanter",
          "daysBetweenCommits": 10.08,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,46 @@\n-  private void beginUpload() throws IOException, UploaderException {\n+  void beginUpload() throws IOException, UploaderException {\n     if (targetStream \u003d\u003d null) {\n       validateTargetPath();\n       int lastIndex \u003d target.indexOf(\u0027#\u0027);\n-      targetPath \u003d\n+      Path targetPath \u003d\n           new Path(\n               target.substring(\n                   0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n       alias \u003d lastIndex !\u003d -1 ?\n           target.substring(lastIndex + 1) :\n           targetPath.getName();\n       LOG.info(\"Target \" + targetPath);\n       FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n-      targetStream \u003d fileSystem.create(targetPath, true);\n+\n+      targetStream \u003d null;\n+      if (fileSystem instanceof DistributedFileSystem) {\n+        LOG.info(\"Set replication to \" +\n+            replication + \" for path: \" + targetPath);\n+        LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n+        DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n+        DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n+            dfs.createFile(targetPath)\n+            .overwrite(true)\n+            .ecPolicyName(\n+                SystemErasureCodingPolicies.getReplicationPolicy().getName());\n+        if (replication \u003e 0) {\n+          builder.replication(replication);\n+        }\n+        targetStream \u003d builder.build();\n+      } else {\n+        LOG.warn(\"Cannot set replication to \" +\n+            replication + \" for path: \" + targetPath +\n+            \" on a non-distributed fileystem \" +\n+            fileSystem.getClass().getName());\n+      }\n+      if (targetStream \u003d\u003d null) {\n+        targetStream \u003d fileSystem.create(targetPath, true);\n+      }\n+\n+      if (targetPath.getName().endsWith(\"gz\") ||\n+          targetPath.getName().endsWith(\"tgz\")) {\n+        LOG.info(\"Creating GZip\");\n+        targetStream \u003d new GZIPOutputStream(targetStream);\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void beginUpload() throws IOException, UploaderException {\n    if (targetStream \u003d\u003d null) {\n      validateTargetPath();\n      int lastIndex \u003d target.indexOf(\u0027#\u0027);\n      Path targetPath \u003d\n          new Path(\n              target.substring(\n                  0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n      alias \u003d lastIndex !\u003d -1 ?\n          target.substring(lastIndex + 1) :\n          targetPath.getName();\n      LOG.info(\"Target \" + targetPath);\n      FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n\n      targetStream \u003d null;\n      if (fileSystem instanceof DistributedFileSystem) {\n        LOG.info(\"Set replication to \" +\n            replication + \" for path: \" + targetPath);\n        LOG.info(\"Disabling Erasure Coding for path: \" + targetPath);\n        DistributedFileSystem dfs \u003d (DistributedFileSystem)fileSystem;\n        DistributedFileSystem.HdfsDataOutputStreamBuilder builder \u003d\n            dfs.createFile(targetPath)\n            .overwrite(true)\n            .ecPolicyName(\n                SystemErasureCodingPolicies.getReplicationPolicy().getName());\n        if (replication \u003e 0) {\n          builder.replication(replication);\n        }\n        targetStream \u003d builder.build();\n      } else {\n        LOG.warn(\"Cannot set replication to \" +\n            replication + \" for path: \" + targetPath +\n            \" on a non-distributed fileystem \" +\n            fileSystem.getClass().getName());\n      }\n      if (targetStream \u003d\u003d null) {\n        targetStream \u003d fileSystem.create(targetPath, true);\n      }\n\n      if (targetPath.getName().endsWith(\"gz\") ||\n          targetPath.getName().endsWith(\"tgz\")) {\n        LOG.info(\"Creating GZip\");\n        targetStream \u003d new GZIPOutputStream(targetStream);\n      }\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
          "extendedDetails": {}
        }
      ]
    },
    "3b78607a02f3a81ad730975ecdfa35967413271d": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-6994. Uploader tool for Distributed Cache Deploy code changes  (miklos.szegedi@cloudera.com via rkanter)\n",
      "commitDate": "01/12/17 12:12 PM",
      "commitName": "3b78607a02f3a81ad730975ecdfa35967413271d",
      "commitAuthor": "Robert Kanter",
      "diff": "@@ -0,0 +1,16 @@\n+  private void beginUpload() throws IOException, UploaderException {\n+    if (targetStream \u003d\u003d null) {\n+      validateTargetPath();\n+      int lastIndex \u003d target.indexOf(\u0027#\u0027);\n+      targetPath \u003d\n+          new Path(\n+              target.substring(\n+                  0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n+      alias \u003d lastIndex !\u003d -1 ?\n+          target.substring(lastIndex + 1) :\n+          targetPath.getName();\n+      LOG.info(\"Target \" + targetPath);\n+      FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n+      targetStream \u003d fileSystem.create(targetPath, true);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void beginUpload() throws IOException, UploaderException {\n    if (targetStream \u003d\u003d null) {\n      validateTargetPath();\n      int lastIndex \u003d target.indexOf(\u0027#\u0027);\n      targetPath \u003d\n          new Path(\n              target.substring(\n                  0, lastIndex \u003d\u003d -1 ? target.length() : lastIndex));\n      alias \u003d lastIndex !\u003d -1 ?\n          target.substring(lastIndex + 1) :\n          targetPath.getName();\n      LOG.info(\"Target \" + targetPath);\n      FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n      targetStream \u003d fileSystem.create(targetPath, true);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java"
    }
  }
}