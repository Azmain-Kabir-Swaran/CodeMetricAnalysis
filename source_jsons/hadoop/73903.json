{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Server.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
  "functionStartLine": 2901,
  "functionEndLine": 2980,
  "numCommitsSeen": 205,
  "timeTaken": 6324,
  "changeHistory": [
    "1da81363fac49152ef34d2fcc536935bda0ba990",
    "7ec67c5118e8d13e2cb0ab09d04f0609b645a676",
    "725623534ce7ab20c28af6e0cdf57bd7278551dd",
    "52703c2d0d9e2ad89d0ffca079e37eee339b89b7",
    "e8477759ac7df7f30d0f74d3689458075cae0d9f",
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
    "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9",
    "9cf3e0805f5967d1ed792c32728ab826fb7c927b",
    "65200998c01b17e017d1814e8b1f4d82ac334a23",
    "229a3a23127e33f596d485dec580e31c48ba9057",
    "e3c696551952941ae0e38afed0323b80e02168c0",
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
    "b97a4d40c8752451fc02168a7f6eb3e93e459c2d",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "1191be630ff05c9f1a540b952a8e34665f7fc181",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "2f6c03ad54725e59e3d18866cfaaea734bb37c82",
    "50f24d774e0ca5906535519ada6afc94432ef771",
    "6b9fb8c78b4c18211145deeac7abc5fc0af5d185",
    "9871771bb55b3da4fd03435ddb5990e20e546c0e",
    "d099c1c78a9782378397e32f1ecd4330ade8c5b6",
    "0c5734e4aca873f405fbf994e5fe7061e31731c8",
    "29a1ba1e8fb11432404cea49e46eef47c36bb70a",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "1da81363fac49152ef34d2fcc536935bda0ba990": "Ybodychange",
    "7ec67c5118e8d13e2cb0ab09d04f0609b645a676": "Ybodychange",
    "725623534ce7ab20c28af6e0cdf57bd7278551dd": "Ybodychange",
    "52703c2d0d9e2ad89d0ffca079e37eee339b89b7": "Ybodychange",
    "e8477759ac7df7f30d0f74d3689458075cae0d9f": "Ybodychange",
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3": "Ybodychange",
    "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9": "Ybodychange",
    "9cf3e0805f5967d1ed792c32728ab826fb7c927b": "Ybodychange",
    "65200998c01b17e017d1814e8b1f4d82ac334a23": "Ybodychange",
    "229a3a23127e33f596d485dec580e31c48ba9057": "Ybodychange",
    "e3c696551952941ae0e38afed0323b80e02168c0": "Ybodychange",
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9": "Ybodychange",
    "b97a4d40c8752451fc02168a7f6eb3e93e459c2d": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "1191be630ff05c9f1a540b952a8e34665f7fc181": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "2f6c03ad54725e59e3d18866cfaaea734bb37c82": "Ybodychange",
    "50f24d774e0ca5906535519ada6afc94432ef771": "Ybodychange",
    "6b9fb8c78b4c18211145deeac7abc5fc0af5d185": "Ybodychange",
    "9871771bb55b3da4fd03435ddb5990e20e546c0e": "Ybodychange",
    "d099c1c78a9782378397e32f1ecd4330ade8c5b6": "Ybodychange",
    "0c5734e4aca873f405fbf994e5fe7061e31731c8": "Ybodychange",
    "29a1ba1e8fb11432404cea49e46eef47c36bb70a": "Ybodychange",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1da81363fac49152ef34d2fcc536935bda0ba990": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9955. RPC idle connection closing is extremely inefficient (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1542111 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/13 2:55 PM",
      "commitName": "1da81363fac49152ef34d2fcc536935bda0ba990",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "13/11/13 1:37 PM",
      "commitNameOld": "e43255302aa7c5a493a3795ec40832994a2dfb19",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 1.05,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,15 @@\n-    public void run() {\n-      LOG.debug(getName() + \": starting\");\n-      SERVER.set(Server.this);\n-      ByteArrayOutputStream buf \u003d \n-        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n-      while (running) {\n-        try {\n-          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n+        public void run() {\n+          if (!running) {\n+            return;\n+          }\n           if (LOG.isDebugEnabled()) {\n-            LOG.debug(getName() + \": \" + call + \" for RpcKind \" + call.rpcKind);\n+            LOG.debug(Thread.currentThread().getName()+\": task running\");\n           }\n-          String errorClass \u003d null;\n-          String error \u003d null;\n-          RpcStatusProto returnStatus \u003d RpcStatusProto.SUCCESS;\n-          RpcErrorCodeProto detailedErr \u003d null;\n-          Writable value \u003d null;\n-\n-          CurCall.set(call);\n           try {\n-            // Make the call as the user via Subject.doAs, thus associating\n-            // the call with the Subject\n-            if (call.connection.user \u003d\u003d null) {\n-              value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n-                           call.timestamp);\n-            } else {\n-              value \u003d \n-                call.connection.user.doAs\n-                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n-                     @Override\n-                     public Writable run() throws Exception {\n-                       // make the call\n-                       return call(call.rpcKind, call.connection.protocolName, \n-                                   call.rpcRequest, call.timestamp);\n-\n-                     }\n-                   }\n-                  );\n-            }\n-          } catch (Throwable e) {\n-            if (e instanceof UndeclaredThrowableException) {\n-              e \u003d e.getCause();\n-            }\n-            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n-            if (e instanceof RuntimeException || e instanceof Error) {\n-              // These exception types indicate something is probably wrong\n-              // on the server side, as opposed to just a normal exceptional\n-              // result.\n-              LOG.warn(logMsg, e);\n-            } else if (exceptionsHandler.isTerse(e.getClass())) {\n-             // Don\u0027t log the whole stack trace of these exceptions.\n-              // Way too noisy!\n-              LOG.info(logMsg);\n-            } else {\n-              LOG.info(logMsg, e);\n-            }\n-            if (e instanceof RpcServerException) {\n-              RpcServerException rse \u003d ((RpcServerException)e); \n-              returnStatus \u003d rse.getRpcStatusProto();\n-              detailedErr \u003d rse.getRpcErrorCodeProto();\n-            } else {\n-              returnStatus \u003d RpcStatusProto.ERROR;\n-              detailedErr \u003d RpcErrorCodeProto.ERROR_APPLICATION;\n-            }\n-            errorClass \u003d e.getClass().getName();\n-            error \u003d StringUtils.stringifyException(e);\n-            // Remove redundant error class name from the beginning of the stack trace\n-            String exceptionHdr \u003d errorClass + \": \";\n-            if (error.startsWith(exceptionHdr)) {\n-              error \u003d error.substring(exceptionHdr.length());\n-            }\n+            closeIdle(false);\n+          } finally {\n+            // explicitly reschedule so next execution occurs relative\n+            // to the end of this scan, not the beginning\n+            scheduleIdleScanTask();\n           }\n-          CurCall.set(null);\n-          synchronized (call.connection.responseQueue) {\n-            // setupResponse() needs to be sync\u0027ed together with \n-            // responder.doResponse() since setupResponse may use\n-            // SASL to encrypt response data and SASL enforces\n-            // its own message ordering.\n-            setupResponse(buf, call, returnStatus, detailedErr, \n-                value, errorClass, error);\n-            \n-            // Discard the large buf and reset it back to smaller size \n-            // to free up heap\n-            if (buf.size() \u003e maxRespSize) {\n-              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n-                  + call.toString());\n-              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n-            }\n-            responder.doRespond(call);\n-          }\n-        } catch (InterruptedException e) {\n-          if (running) {                          // unexpected -- log it\n-            LOG.info(getName() + \" unexpectedly interrupted\", e);\n-          }\n-        } catch (Exception e) {\n-          LOG.info(getName() + \" caught an exception\", e);\n-        }\n-      }\n-      LOG.debug(getName() + \": exiting\");\n-    }\n\\ No newline at end of file\n+        }\n\\ No newline at end of file\n",
      "actualSource": "        public void run() {\n          if (!running) {\n            return;\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(Thread.currentThread().getName()+\": task running\");\n          }\n          try {\n            closeIdle(false);\n          } finally {\n            // explicitly reschedule so next execution occurs relative\n            // to the end of this scan, not the beginning\n            scheduleIdleScanTask();\n          }\n        }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "7ec67c5118e8d13e2cb0ab09d04f0609b645a676": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9716. Rpc retries should use the same call ID as the original call.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504362 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/07/13 9:42 PM",
      "commitName": "7ec67c5118e8d13e2cb0ab09d04f0609b645a676",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "16/07/13 10:59 AM",
      "commitNameOld": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 1.45,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,99 @@\n     public void run() {\n       LOG.debug(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n           if (LOG.isDebugEnabled()) {\n-            LOG.debug(getName() + \": has Call#\" + call.callId + \n-                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n+            LOG.debug(getName() + \": \" + call + \" for RpcKind \" + call.rpcKind);\n           }\n           String errorClass \u003d null;\n           String error \u003d null;\n           RpcStatusProto returnStatus \u003d RpcStatusProto.SUCCESS;\n           RpcErrorCodeProto detailedErr \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.rpcKind, call.connection.protocolName, \n                                    call.rpcRequest, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             if (e instanceof UndeclaredThrowableException) {\n               e \u003d e.getCause();\n             }\n             String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n             if (e instanceof RuntimeException || e instanceof Error) {\n               // These exception types indicate something is probably wrong\n               // on the server side, as opposed to just a normal exceptional\n               // result.\n               LOG.warn(logMsg, e);\n             } else if (exceptionsHandler.isTerse(e.getClass())) {\n              // Don\u0027t log the whole stack trace of these exceptions.\n               // Way too noisy!\n               LOG.info(logMsg);\n             } else {\n               LOG.info(logMsg, e);\n             }\n             if (e instanceof RpcServerException) {\n               RpcServerException rse \u003d ((RpcServerException)e); \n               returnStatus \u003d rse.getRpcStatusProto();\n               detailedErr \u003d rse.getRpcErrorCodeProto();\n             } else {\n               returnStatus \u003d RpcStatusProto.ERROR;\n               detailedErr \u003d RpcErrorCodeProto.ERROR_APPLICATION;\n             }\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, returnStatus, detailedErr, \n                 value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.debug(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.debug(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(getName() + \": \" + call + \" for RpcKind \" + call.rpcKind);\n          }\n          String errorClass \u003d null;\n          String error \u003d null;\n          RpcStatusProto returnStatus \u003d RpcStatusProto.SUCCESS;\n          RpcErrorCodeProto detailedErr \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.rpcKind, call.connection.protocolName, \n                                   call.rpcRequest, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            if (e instanceof UndeclaredThrowableException) {\n              e \u003d e.getCause();\n            }\n            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n            if (e instanceof RuntimeException || e instanceof Error) {\n              // These exception types indicate something is probably wrong\n              // on the server side, as opposed to just a normal exceptional\n              // result.\n              LOG.warn(logMsg, e);\n            } else if (exceptionsHandler.isTerse(e.getClass())) {\n             // Don\u0027t log the whole stack trace of these exceptions.\n              // Way too noisy!\n              LOG.info(logMsg);\n            } else {\n              LOG.info(logMsg, e);\n            }\n            if (e instanceof RpcServerException) {\n              RpcServerException rse \u003d ((RpcServerException)e); \n              returnStatus \u003d rse.getRpcStatusProto();\n              detailedErr \u003d rse.getRpcErrorCodeProto();\n            } else {\n              returnStatus \u003d RpcStatusProto.ERROR;\n              detailedErr \u003d RpcErrorCodeProto.ERROR_APPLICATION;\n            }\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, returnStatus, detailedErr, \n                value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.debug(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "725623534ce7ab20c28af6e0cdf57bd7278551dd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9425 Add error codes to rpc-response (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/13 10:51 AM",
      "commitName": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "27/03/13 11:51 AM",
      "commitNameOld": "fc0a4de670c3e6dcf5d30305d3969fe4946a0fed",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 37.96,
      "commitsBetweenForRepo": 210,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,100 @@\n     public void run() {\n       LOG.debug(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(getName() + \": has Call#\" + call.callId + \n                 \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n           }\n           String errorClass \u003d null;\n           String error \u003d null;\n+          RpcStatusProto returnStatus \u003d RpcStatusProto.SUCCESS;\n+          RpcErrorCodeProto detailedErr \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.rpcKind, call.connection.protocolName, \n                                    call.rpcRequest, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             if (e instanceof UndeclaredThrowableException) {\n               e \u003d e.getCause();\n             }\n             String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n             if (e instanceof RuntimeException || e instanceof Error) {\n               // These exception types indicate something is probably wrong\n               // on the server side, as opposed to just a normal exceptional\n               // result.\n               LOG.warn(logMsg, e);\n             } else if (exceptionsHandler.isTerse(e.getClass())) {\n              // Don\u0027t log the whole stack trace of these exceptions.\n               // Way too noisy!\n               LOG.info(logMsg);\n             } else {\n               LOG.info(logMsg, e);\n             }\n-\n+            if (e instanceof RpcServerException) {\n+              RpcServerException rse \u003d ((RpcServerException)e); \n+              returnStatus \u003d rse.getRpcStatusProto();\n+              detailedErr \u003d rse.getRpcErrorCodeProto();\n+            } else {\n+              returnStatus \u003d RpcStatusProto.ERROR;\n+              detailedErr \u003d RpcErrorCodeProto.ERROR_APPLICATION;\n+            }\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n-            setupResponse(buf, call, (error \u003d\u003d null) ? RpcStatusProto.SUCCESS\n-                : RpcStatusProto.ERROR, value, errorClass, error);\n+            setupResponse(buf, call, returnStatus, detailedErr, \n+                value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.debug(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.debug(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(getName() + \": has Call#\" + call.callId + \n                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n          }\n          String errorClass \u003d null;\n          String error \u003d null;\n          RpcStatusProto returnStatus \u003d RpcStatusProto.SUCCESS;\n          RpcErrorCodeProto detailedErr \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.rpcKind, call.connection.protocolName, \n                                   call.rpcRequest, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            if (e instanceof UndeclaredThrowableException) {\n              e \u003d e.getCause();\n            }\n            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n            if (e instanceof RuntimeException || e instanceof Error) {\n              // These exception types indicate something is probably wrong\n              // on the server side, as opposed to just a normal exceptional\n              // result.\n              LOG.warn(logMsg, e);\n            } else if (exceptionsHandler.isTerse(e.getClass())) {\n             // Don\u0027t log the whole stack trace of these exceptions.\n              // Way too noisy!\n              LOG.info(logMsg);\n            } else {\n              LOG.info(logMsg, e);\n            }\n            if (e instanceof RpcServerException) {\n              RpcServerException rse \u003d ((RpcServerException)e); \n              returnStatus \u003d rse.getRpcStatusProto();\n              detailedErr \u003d rse.getRpcErrorCodeProto();\n            } else {\n              returnStatus \u003d RpcStatusProto.ERROR;\n              detailedErr \u003d RpcErrorCodeProto.ERROR_APPLICATION;\n            }\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, returnStatus, detailedErr, \n                value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.debug(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "52703c2d0d9e2ad89d0ffca079e37eee339b89b7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9343. Allow additional exceptions through the RPC layer. (sseth)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1452918 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/03/13 9:56 AM",
      "commitName": "52703c2d0d9e2ad89d0ffca079e37eee339b89b7",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "28/02/13 2:01 PM",
      "commitNameOld": "c5368561f9b0326cbd185ace9cbf7b37be7b3f2c",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,91 @@\n     public void run() {\n       LOG.debug(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(getName() + \": has Call#\" + call.callId + \n                 \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n           }\n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.rpcKind, call.connection.protocolName, \n                                    call.rpcRequest, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n+            if (e instanceof UndeclaredThrowableException) {\n+              e \u003d e.getCause();\n+            }\n             String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n             if (e instanceof RuntimeException || e instanceof Error) {\n               // These exception types indicate something is probably wrong\n               // on the server side, as opposed to just a normal exceptional\n               // result.\n               LOG.warn(logMsg, e);\n             } else if (exceptionsHandler.isTerse(e.getClass())) {\n              // Don\u0027t log the whole stack trace of these exceptions.\n               // Way too noisy!\n               LOG.info(logMsg);\n             } else {\n               LOG.info(logMsg, e);\n             }\n \n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? RpcStatusProto.SUCCESS\n                 : RpcStatusProto.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.debug(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.debug(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(getName() + \": has Call#\" + call.callId + \n                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n          }\n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.rpcKind, call.connection.protocolName, \n                                   call.rpcRequest, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            if (e instanceof UndeclaredThrowableException) {\n              e \u003d e.getCause();\n            }\n            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n            if (e instanceof RuntimeException || e instanceof Error) {\n              // These exception types indicate something is probably wrong\n              // on the server side, as opposed to just a normal exceptional\n              // result.\n              LOG.warn(logMsg, e);\n            } else if (exceptionsHandler.isTerse(e.getClass())) {\n             // Don\u0027t log the whole stack trace of these exceptions.\n              // Way too noisy!\n              LOG.info(logMsg);\n            } else {\n              LOG.info(logMsg, e);\n            }\n\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? RpcStatusProto.SUCCESS\n                : RpcStatusProto.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.debug(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "e8477759ac7df7f30d0f74d3689458075cae0d9f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8711. IPC Server supports adding exceptions for which the message is printed and the stack trace is not printed to avoid chatter. Contributed by Brandon Li.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1375790 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/08/12 2:01 PM",
      "commitName": "e8477759ac7df7f30d0f74d3689458075cae0d9f",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "20/07/12 1:50 PM",
      "commitNameOld": "80e2b4117be43cb744cbfe9949ce6c590140fbb3",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 32.01,
      "commitsBetweenForRepo": 147,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n     public void run() {\n       LOG.debug(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(getName() + \": has Call#\" + call.callId + \n                 \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n           }\n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.rpcKind, call.connection.protocolName, \n                                    call.rpcRequest, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n             if (e instanceof RuntimeException || e instanceof Error) {\n               // These exception types indicate something is probably wrong\n               // on the server side, as opposed to just a normal exceptional\n               // result.\n               LOG.warn(logMsg, e);\n-            } else if (e instanceof StandbyException) {\n-              // Don\u0027t log the whole stack trace of these exceptions.\n+            } else if (exceptionsHandler.isTerse(e.getClass())) {\n+             // Don\u0027t log the whole stack trace of these exceptions.\n               // Way too noisy!\n               LOG.info(logMsg);\n             } else {\n               LOG.info(logMsg, e);\n             }\n \n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? RpcStatusProto.SUCCESS\n                 : RpcStatusProto.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.debug(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.debug(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(getName() + \": has Call#\" + call.callId + \n                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n          }\n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.rpcKind, call.connection.protocolName, \n                                   call.rpcRequest, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n            if (e instanceof RuntimeException || e instanceof Error) {\n              // These exception types indicate something is probably wrong\n              // on the server side, as opposed to just a normal exceptional\n              // result.\n              LOG.warn(logMsg, e);\n            } else if (exceptionsHandler.isTerse(e.getClass())) {\n             // Don\u0027t log the whole stack trace of these exceptions.\n              // Way too noisy!\n              LOG.info(logMsg);\n            } else {\n              LOG.info(logMsg, e);\n            }\n\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? RpcStatusProto.SUCCESS\n                : RpcStatusProto.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.debug(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-8366 Use ProtoBuf for RpcResponseHeader (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1337283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/05/12 9:56 AM",
      "commitName": "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "02/05/12 11:35 PM",
      "commitNameOld": "d94899877709836153244c2f0c5f14c37c9d4795",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 8.43,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n     public void run() {\n       LOG.debug(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(getName() + \": has Call#\" + call.callId + \n                 \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n           }\n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.rpcKind, call.connection.protocolName, \n                                    call.rpcRequest, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n             if (e instanceof RuntimeException || e instanceof Error) {\n               // These exception types indicate something is probably wrong\n               // on the server side, as opposed to just a normal exceptional\n               // result.\n               LOG.warn(logMsg, e);\n             } else if (e instanceof StandbyException) {\n               // Don\u0027t log the whole stack trace of these exceptions.\n               // Way too noisy!\n               LOG.info(logMsg);\n             } else {\n               LOG.info(logMsg, e);\n             }\n \n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n-            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n-                : Status.ERROR, value, errorClass, error);\n+            setupResponse(buf, call, (error \u003d\u003d null) ? RpcStatusProto.SUCCESS\n+                : RpcStatusProto.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.debug(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.debug(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(getName() + \": has Call#\" + call.callId + \n                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n          }\n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.rpcKind, call.connection.protocolName, \n                                   call.rpcRequest, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n            if (e instanceof RuntimeException || e instanceof Error) {\n              // These exception types indicate something is probably wrong\n              // on the server side, as opposed to just a normal exceptional\n              // result.\n              LOG.warn(logMsg, e);\n            } else if (e instanceof StandbyException) {\n              // Don\u0027t log the whole stack trace of these exceptions.\n              // Way too noisy!\n              LOG.info(logMsg);\n            } else {\n              LOG.info(logMsg, e);\n            }\n\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? RpcStatusProto.SUCCESS\n                : RpcStatusProto.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.debug(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-7557 Make IPC header be extensible (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1295261 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/02/12 12:43 PM",
      "commitName": "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "23/02/12 8:05 PM",
      "commitNameOld": "22d5944c42b4bef5144a9f6426751b15717c5a3e",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 5.69,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,84 @@\n     public void run() {\n       LOG.debug(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n-\n-          if (LOG.isDebugEnabled())\n+          if (LOG.isDebugEnabled()) {\n             LOG.debug(getName() + \": has Call#\" + call.callId + \n                 \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n-          \n+          }\n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.rpcKind, call.connection.protocolName, \n                                    call.rpcRequest, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n             if (e instanceof RuntimeException || e instanceof Error) {\n               // These exception types indicate something is probably wrong\n               // on the server side, as opposed to just a normal exceptional\n               // result.\n               LOG.warn(logMsg, e);\n             } else {\n               LOG.info(logMsg, e);\n             }\n \n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.debug(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.debug(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(getName() + \": has Call#\" + call.callId + \n                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n          }\n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.rpcKind, call.connection.protocolName, \n                                   call.rpcRequest, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n            if (e instanceof RuntimeException || e instanceof Error) {\n              // These exception types indicate something is probably wrong\n              // on the server side, as opposed to just a normal exceptional\n              // result.\n              LOG.warn(logMsg, e);\n            } else {\n              LOG.info(logMsg, e);\n            }\n\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.debug(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "9cf3e0805f5967d1ed792c32728ab826fb7c927b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7922. Improve some logging for client IPC failovers and StandbyExceptions. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1214082 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 11:51 PM",
      "commitName": "9cf3e0805f5967d1ed792c32728ab826fb7c927b",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "13/12/11 1:18 AM",
      "commitNameOld": "186df142cc19c2969c1f8b56df0d8f75e3db66b1",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,89 @@\n     public void run() {\n       LOG.debug(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has Call#\" + call.callId + \n                 \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.rpcKind, call.connection.protocolName, \n                                    call.rpcRequest, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n             if (e instanceof RuntimeException || e instanceof Error) {\n               // These exception types indicate something is probably wrong\n               // on the server side, as opposed to just a normal exceptional\n               // result.\n               LOG.warn(logMsg, e);\n+            } else if (e instanceof StandbyException) {\n+              // Don\u0027t log the whole stack trace of these exceptions.\n+              // Way too noisy!\n+              LOG.info(logMsg);\n             } else {\n               LOG.info(logMsg, e);\n             }\n \n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.debug(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.debug(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has Call#\" + call.callId + \n                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.rpcKind, call.connection.protocolName, \n                                   call.rpcRequest, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n            if (e instanceof RuntimeException || e instanceof Error) {\n              // These exception types indicate something is probably wrong\n              // on the server side, as opposed to just a normal exceptional\n              // result.\n              LOG.warn(logMsg, e);\n            } else if (e instanceof StandbyException) {\n              // Don\u0027t log the whole stack trace of these exceptions.\n              // Way too noisy!\n              LOG.info(logMsg);\n            } else {\n              LOG.info(logMsg, e);\n            }\n\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.debug(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "65200998c01b17e017d1814e8b1f4d82ac334a23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7862  Move the support for multiple protocols to lower layer so that Writable, PB and Avro can all use it (includes HDFS and MR changes to match) (Sanjay) \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1210208 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/11 12:44 PM",
      "commitName": "65200998c01b17e017d1814e8b1f4d82ac334a23",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "27/11/11 12:27 PM",
      "commitNameOld": "229a3a23127e33f596d485dec580e31c48ba9057",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 7.01,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n     public void run() {\n       LOG.debug(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has Call#\" + call.callId + \n                 \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n-              value \u003d call(call.connection.protocolName, call.rpcRequest, \n+              value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n-                       return call(call.connection.protocolName, \n+                       return call(call.rpcKind, call.connection.protocolName, \n                                    call.rpcRequest, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n             if (e instanceof RuntimeException || e instanceof Error) {\n               // These exception types indicate something is probably wrong\n               // on the server side, as opposed to just a normal exceptional\n               // result.\n               LOG.warn(logMsg, e);\n             } else {\n               LOG.info(logMsg, e);\n             }\n \n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.debug(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.debug(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has Call#\" + call.callId + \n                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.rpcKind, call.connection.protocolName, call.rpcRequest, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.rpcKind, call.connection.protocolName, \n                                   call.rpcRequest, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n            if (e instanceof RuntimeException || e instanceof Error) {\n              // These exception types indicate something is probably wrong\n              // on the server side, as opposed to just a normal exceptional\n              // result.\n              LOG.warn(logMsg, e);\n            } else {\n              LOG.info(logMsg, e);\n            }\n\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.debug(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "229a3a23127e33f596d485dec580e31c48ba9057": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7858. Drop some info logging to DEBUG level in IPC, metrics, and HTTP. Contributed by Todd Lipcon\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1206830 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/11 12:27 PM",
      "commitName": "229a3a23127e33f596d485dec580e31c48ba9057",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "23/11/11 5:52 PM",
      "commitNameOld": "e3c696551952941ae0e38afed0323b80e02168c0",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n     public void run() {\n-      LOG.info(getName() + \": starting\");\n+      LOG.debug(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has Call#\" + call.callId + \n                 \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.connection.protocolName, call.rpcRequest, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.connection.protocolName, \n                                    call.rpcRequest, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n             if (e instanceof RuntimeException || e instanceof Error) {\n               // These exception types indicate something is probably wrong\n               // on the server side, as opposed to just a normal exceptional\n               // result.\n               LOG.warn(logMsg, e);\n             } else {\n               LOG.info(logMsg, e);\n             }\n \n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n-      LOG.info(getName() + \": exiting\");\n+      LOG.debug(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.debug(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has Call#\" + call.callId + \n                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocolName, call.rpcRequest, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocolName, \n                                   call.rpcRequest, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n            if (e instanceof RuntimeException || e instanceof Error) {\n              // These exception types indicate something is probably wrong\n              // on the server side, as opposed to just a normal exceptional\n              // result.\n              LOG.warn(logMsg, e);\n            } else {\n              LOG.info(logMsg, e);\n            }\n\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.debug(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "e3c696551952941ae0e38afed0323b80e02168c0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7358. Improve log levels when exceptions caught in RPC handler. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1205697 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/11/11 5:52 PM",
      "commitName": "e3c696551952941ae0e38afed0323b80e02168c0",
      "commitAuthor": "Konstantin Shvachko",
      "commitDateOld": "04/11/11 10:06 PM",
      "commitNameOld": "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 18.87,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,85 @@\n     public void run() {\n       LOG.info(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has Call#\" + call.callId + \n                 \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.connection.protocolName, call.rpcRequest, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.connection.protocolName, \n                                    call.rpcRequest, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n-            LOG.info(getName() + \", call: \" + call + \", error: \", e);\n+            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n+            if (e instanceof RuntimeException || e instanceof Error) {\n+              // These exception types indicate something is probably wrong\n+              // on the server side, as opposed to just a normal exceptional\n+              // result.\n+              LOG.warn(logMsg, e);\n+            } else {\n+              LOG.info(logMsg, e);\n+            }\n+\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.info(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has Call#\" + call.callId + \n                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocolName, call.rpcRequest, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocolName, \n                                   call.rpcRequest, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            String logMsg \u003d getName() + \", call \" + call + \": error: \" + e;\n            if (e instanceof RuntimeException || e instanceof Error) {\n              // These exception types indicate something is probably wrong\n              // on the server side, as opposed to just a normal exceptional\n              // result.\n              LOG.warn(logMsg, e);\n            } else {\n              LOG.info(logMsg, e);\n            }\n\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9": {
      "type": "Ybodychange",
      "commitMessage": "\t\tHADOOP-7776 Make the Ipc-Header in a RPC-Payload an explicit header (sanjay)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1197885 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/11/11 10:06 PM",
      "commitName": "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "24/10/11 11:07 PM",
      "commitNameOld": "d19cfe01642f9582e1fe5d567beb480399c37a01",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 10.96,
      "commitsBetweenForRepo": 133,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n     public void run() {\n       LOG.info(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n-            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n-                      call.connection);\n+            LOG.debug(getName() + \": has Call#\" + call.callId + \n+                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n-              value \u003d call(call.connection.protocolName, call.param, \n+              value \u003d call(call.connection.protocolName, call.rpcRequest, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.connection.protocolName, \n-                                   call.param, call.timestamp);\n+                                   call.rpcRequest, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             LOG.info(getName() + \", call: \" + call + \", error: \", e);\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.info(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has Call#\" + call.callId + \n                \"for RpcKind \" + call.rpcKind + \" from \" + call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocolName, call.rpcRequest, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocolName, \n                                   call.rpcRequest, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName() + \", call: \" + call + \", error: \", e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "b97a4d40c8752451fc02168a7f6eb3e93e459c2d": {
      "type": "Ybodychange",
      "commitMessage": "  HADOOP-7524 and MapReduce-2887 Change RPC to allow multiple protocols including multuple versions of the same protocol (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1164771 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/09/11 5:31 PM",
      "commitName": "b97a4d40c8752451fc02168a7f6eb3e93e459c2d",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 9.01,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n     public void run() {\n       LOG.info(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                       call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n-              value \u003d call(call.connection.protocol, call.param, \n+              value \u003d call(call.connection.protocolName, call.param, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n-                       return call(call.connection.protocol, \n+                       return call(call.connection.protocolName, \n                                    call.param, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             LOG.info(getName() + \", call: \" + call + \", error: \", e);\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.info(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocolName, call.param, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocolName, \n                                   call.param, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName() + \", call: \" + call + \", error: \", e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocol, call.param, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocol, \n                                   call.param, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName() + \", call: \" + call + \", error: \", e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocol, call.param, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocol, \n                                   call.param, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName() + \", call: \" + call + \", error: \", e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "1191be630ff05c9f1a540b952a8e34665f7fc181": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7385 Remove StringUtils.stringifyException(ie) in logger functions.  Contributed by Bharath Mundlapudi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139123 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/06/11 4:55 PM",
      "commitName": "1191be630ff05c9f1a540b952a8e34665f7fc181",
      "commitAuthor": "Tanping Wang",
      "commitDateOld": "12/06/11 3:00 PM",
      "commitNameOld": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 11.08,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n     public void run() {\n       LOG.info(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                       call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.connection.protocol, call.param, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.connection.protocol, \n                                    call.param, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n-            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n+            LOG.info(getName() + \", call: \" + call + \", error: \", e);\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.info(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocol, call.param, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocol, \n                                   call.param, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName() + \", call: \" + call + \", error: \", e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "common/src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocol, call.param, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocol, \n                                   call.param, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "common/src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "common/src/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "2f6c03ad54725e59e3d18866cfaaea734bb37c82": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7146. RPC server leaks file descriptors. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1127811 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/05/11 12:48 AM",
      "commitName": "2f6c03ad54725e59e3d18866cfaaea734bb37c82",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "17/05/11 10:41 AM",
      "commitNameOld": "31a77f91cf34bb05e12fdf6e70410923230f68aa",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 8.59,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,76 @@\n     public void run() {\n       LOG.info(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                       call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.connection.protocol, call.param, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.connection.protocol, \n                                    call.param, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n             // Remove redundant error class name from the beginning of the stack trace\n             String exceptionHdr \u003d errorClass + \": \";\n             if (error.startsWith(exceptionHdr)) {\n               error \u003d error.substring(exceptionHdr.length());\n             }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n-            LOG.info(getName() + \" caught: \" +\n-                     StringUtils.stringifyException(e));\n+            LOG.info(getName() + \" unexpectedly interrupted\", e);\n           }\n         } catch (Exception e) {\n-          LOG.info(getName() + \" caught: \" +\n-                   StringUtils.stringifyException(e));\n+          LOG.info(getName() + \" caught an exception\", e);\n         }\n       }\n       LOG.info(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocol, call.param, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocol, \n                                   call.param, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" unexpectedly interrupted\", e);\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught an exception\", e);\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "50f24d774e0ca5906535519ada6afc94432ef771": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6686. Remove redundant exception class name from the exception message for the exceptions thrown at RPC client. Contributed by Suresh Srinivas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@937183 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/10 1:05 AM",
      "commitName": "50f24d774e0ca5906535519ada6afc94432ef771",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "13/04/10 4:01 PM",
      "commitNameOld": "b802476d9d44e581d64f810c55fc8f0c35171401",
      "commitAuthorOld": "Boris Shkolnik",
      "daysBetweenCommits": 9.38,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,78 @@\n     public void run() {\n       LOG.info(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                       call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.connection.protocol, call.param, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.connection.protocol, \n                                    call.param, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n+            // Remove redundant error class name from the beginning of the stack trace\n+            String exceptionHdr \u003d errorClass + \": \";\n+            if (error.startsWith(exceptionHdr)) {\n+              error \u003d error.substring(exceptionHdr.length());\n+            }\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n             \n             // Discard the large buf and reset it back to smaller size \n             // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" caught: \" +\n                      StringUtils.stringifyException(e));\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught: \" +\n                    StringUtils.stringifyException(e));\n         }\n       }\n       LOG.info(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocol, call.param, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocol, \n                                   call.param, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n            // Remove redundant error class name from the beginning of the stack trace\n            String exceptionHdr \u003d errorClass + \": \";\n            if (error.startsWith(exceptionHdr)) {\n              error \u003d error.substring(exceptionHdr.length());\n            }\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" caught: \" +\n                     StringUtils.stringifyException(e));\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught: \" +\n                   StringUtils.stringifyException(e));\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "6b9fb8c78b4c18211145deeac7abc5fc0af5d185": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6599  Split existing RpcMetrics into RpcMetrics \u0026 RpcDetailedMetrics.\n   (Suresh Srinivas via Sanjay Radia)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@917737 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/03/10 1:36 PM",
      "commitName": "6b9fb8c78b4c18211145deeac7abc5fc0af5d185",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "26/02/10 10:17 PM",
      "commitNameOld": "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 2.64,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,73 @@\n     public void run() {\n       LOG.info(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                       call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.connection.protocol, call.param, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.connection.protocol, \n                                    call.param, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n-            // Discard the large buf and reset it back to\n-            // smaller size to freeup heap\n+            \n+            // Discard the large buf and reset it back to smaller size \n+            // to free up heap\n             if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" caught: \" +\n                      StringUtils.stringifyException(e));\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught: \" +\n                    StringUtils.stringifyException(e));\n         }\n       }\n       LOG.info(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocol, call.param, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocol, \n                                   call.param, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            \n            // Discard the large buf and reset it back to smaller size \n            // to free up heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" caught: \" +\n                     StringUtils.stringifyException(e));\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught: \" +\n                   StringUtils.stringifyException(e));\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "9871771bb55b3da4fd03435ddb5990e20e546c0e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6577. Add hidden configuration option \"ipc.server.max.response.size\" to change the default 1 MB, the maximum size when large IPC handler response buffer is reset. Contributed by Suresh Srinivas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@912056 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/02/10 5:23 PM",
      "commitName": "9871771bb55b3da4fd03435ddb5990e20e546c0e",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "19/02/10 1:04 AM",
      "commitNameOld": "d099c1c78a9782378397e32f1ecd4330ade8c5b6",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 0.68,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n     public void run() {\n       LOG.info(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                       call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.connection.protocol, call.param, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.connection.protocol, \n                                    call.param, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n           }\n           CurCall.set(null);\n           synchronized (call.connection.responseQueue) {\n             // setupResponse() needs to be sync\u0027ed together with \n             // responder.doResponse() since setupResponse may use\n             // SASL to encrypt response data and SASL enforces\n             // its own message ordering.\n             setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                 : Status.ERROR, value, errorClass, error);\n             // Discard the large buf and reset it back to\n             // smaller size to freeup heap\n-            if (buf.size() \u003e MAX_RESP_BUF_SIZE) {\n+            if (buf.size() \u003e maxRespSize) {\n               LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                   + call.toString());\n               buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n             }\n             responder.doRespond(call);\n           }\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" caught: \" +\n                      StringUtils.stringifyException(e));\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught: \" +\n                    StringUtils.stringifyException(e));\n         }\n       }\n       LOG.info(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocol, call.param, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocol, \n                                   call.param, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            // Discard the large buf and reset it back to\n            // smaller size to freeup heap\n            if (buf.size() \u003e maxRespSize) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" caught: \" +\n                     StringUtils.stringifyException(e));\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught: \" +\n                   StringUtils.stringifyException(e));\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "d099c1c78a9782378397e32f1ecd4330ade8c5b6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6572. Makes sure that SASL encryption and push to responder queue for the RPC response happens atomically. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@911748 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/02/10 1:04 AM",
      "commitName": "d099c1c78a9782378397e32f1ecd4330ade8c5b6",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "07/02/10 8:55 PM",
      "commitNameOld": "1793e7d9094cd984ae402177c5935239059d74e8",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 11.17,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,72 @@\n     public void run() {\n       LOG.info(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                       call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             if (call.connection.user \u003d\u003d null) {\n               value \u003d call(call.connection.protocol, call.param, \n                            call.timestamp);\n             } else {\n               value \u003d \n                 call.connection.user.doAs\n                   (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                      @Override\n                      public Writable run() throws Exception {\n                        // make the call\n                        return call(call.connection.protocol, \n                                    call.param, call.timestamp);\n \n                      }\n                    }\n                   );\n             }\n           } catch (Throwable e) {\n             LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n           }\n           CurCall.set(null);\n-          setupResponse(buf, call, \n-                        (error \u003d\u003d null) ? Status.SUCCESS : Status.ERROR, \n-                        value, errorClass, error);\n-          // Discard the large buf and reset it back to \n-          // smaller size to freeup heap\n-          if (buf.size() \u003e MAX_RESP_BUF_SIZE) {\n-            LOG.warn(\"Large response size \" + buf.size() + \" for call \" + \n-                call.toString());\n-            buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n+          synchronized (call.connection.responseQueue) {\n+            // setupResponse() needs to be sync\u0027ed together with \n+            // responder.doResponse() since setupResponse may use\n+            // SASL to encrypt response data and SASL enforces\n+            // its own message ordering.\n+            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n+                : Status.ERROR, value, errorClass, error);\n+            // Discard the large buf and reset it back to\n+            // smaller size to freeup heap\n+            if (buf.size() \u003e MAX_RESP_BUF_SIZE) {\n+              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n+                  + call.toString());\n+              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n+            }\n+            responder.doRespond(call);\n           }\n-          responder.doRespond(call);\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" caught: \" +\n                      StringUtils.stringifyException(e));\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught: \" +\n                    StringUtils.stringifyException(e));\n         }\n       }\n       LOG.info(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocol, call.param, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocol, \n                                   call.param, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n          }\n          CurCall.set(null);\n          synchronized (call.connection.responseQueue) {\n            // setupResponse() needs to be sync\u0027ed together with \n            // responder.doResponse() since setupResponse may use\n            // SASL to encrypt response data and SASL enforces\n            // its own message ordering.\n            setupResponse(buf, call, (error \u003d\u003d null) ? Status.SUCCESS\n                : Status.ERROR, value, errorClass, error);\n            // Discard the large buf and reset it back to\n            // smaller size to freeup heap\n            if (buf.size() \u003e MAX_RESP_BUF_SIZE) {\n              LOG.warn(\"Large response size \" + buf.size() + \" for call \"\n                  + call.toString());\n              buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n            }\n            responder.doRespond(call);\n          }\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" caught: \" +\n                     StringUtils.stringifyException(e));\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught: \" +\n                   StringUtils.stringifyException(e));\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "0c5734e4aca873f405fbf994e5fe7061e31731c8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6299. Reimplement the UserGroupInformation to use the OS\nspecific and Kerberos JAAS login. (omalley)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@903560 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/01/10 12:08 AM",
      "commitName": "0c5734e4aca873f405fbf994e5fe7061e31731c8",
      "commitAuthor": "Owen O\u0027Malley",
      "commitDateOld": "23/12/09 4:47 PM",
      "commitNameOld": "29a1ba1e8fb11432404cea49e46eef47c36bb70a",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 34.31,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,67 @@\n     public void run() {\n       LOG.info(getName() + \": starting\");\n       SERVER.set(Server.this);\n       ByteArrayOutputStream buf \u003d \n         new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                       call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n-            value \u003d \n-              Subject.doAs(call.connection.user, \n-                           new PrivilegedExceptionAction\u003cWritable\u003e() {\n-                              @Override\n-                              public Writable run() throws Exception {\n-                                // make the call\n-                                return call(call.connection.protocol, \n-                                            call.param, call.timestamp);\n+            if (call.connection.user \u003d\u003d null) {\n+              value \u003d call(call.connection.protocol, call.param, \n+                           call.timestamp);\n+            } else {\n+              value \u003d \n+                call.connection.user.doAs\n+                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n+                     @Override\n+                     public Writable run() throws Exception {\n+                       // make the call\n+                       return call(call.connection.protocol, \n+                                   call.param, call.timestamp);\n \n-                              }\n-                           }\n-                          );\n-              \n-          } catch (PrivilegedActionException pae) {\n-            Exception e \u003d pae.getException();\n-            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n-            errorClass \u003d e.getClass().getName();\n-            error \u003d StringUtils.stringifyException(e);\n+                     }\n+                   }\n+                  );\n+            }\n           } catch (Throwable e) {\n             LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n           }\n           CurCall.set(null);\n           setupResponse(buf, call, \n                         (error \u003d\u003d null) ? Status.SUCCESS : Status.ERROR, \n                         value, errorClass, error);\n           // Discard the large buf and reset it back to \n           // smaller size to freeup heap\n           if (buf.size() \u003e MAX_RESP_BUF_SIZE) {\n             LOG.warn(\"Large response size \" + buf.size() + \" for call \" + \n                 call.toString());\n             buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n           }\n           responder.doRespond(call);\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" caught: \" +\n                      StringUtils.stringifyException(e));\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught: \" +\n                    StringUtils.stringifyException(e));\n         }\n       }\n       LOG.info(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            if (call.connection.user \u003d\u003d null) {\n              value \u003d call(call.connection.protocol, call.param, \n                           call.timestamp);\n            } else {\n              value \u003d \n                call.connection.user.doAs\n                  (new PrivilegedExceptionAction\u003cWritable\u003e() {\n                     @Override\n                     public Writable run() throws Exception {\n                       // make the call\n                       return call(call.connection.protocol, \n                                   call.param, call.timestamp);\n\n                     }\n                   }\n                  );\n            }\n          } catch (Throwable e) {\n            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n          }\n          CurCall.set(null);\n          setupResponse(buf, call, \n                        (error \u003d\u003d null) ? Status.SUCCESS : Status.ERROR, \n                        value, errorClass, error);\n          // Discard the large buf and reset it back to \n          // smaller size to freeup heap\n          if (buf.size() \u003e MAX_RESP_BUF_SIZE) {\n            LOG.warn(\"Large response size \" + buf.size() + \" for call \" + \n                call.toString());\n            buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n          }\n          responder.doRespond(call);\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" caught: \" +\n                     StringUtils.stringifyException(e));\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught: \" +\n                   StringUtils.stringifyException(e));\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "29a1ba1e8fb11432404cea49e46eef47c36bb70a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6460. Reinitializes buffers used for serializing responses in ipc server on exceeding maximum response size to free up Java heap. Contributed by Suresh Srinivas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@893666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/12/09 4:47 PM",
      "commitName": "29a1ba1e8fb11432404cea49e46eef47c36bb70a",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "17/12/09 5:29 PM",
      "commitNameOld": "ae93ba7501d95e9d26a29de25f4cc39e5225ca20",
      "commitAuthorOld": "Boris Shkolnik",
      "daysBetweenCommits": 5.97,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,68 @@\n     public void run() {\n       LOG.info(getName() + \": starting\");\n       SERVER.set(Server.this);\n-      ByteArrayOutputStream buf \u003d new ByteArrayOutputStream(10240);\n+      ByteArrayOutputStream buf \u003d \n+        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n       while (running) {\n         try {\n           final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n \n           if (LOG.isDebugEnabled())\n             LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                       call.connection);\n           \n           String errorClass \u003d null;\n           String error \u003d null;\n           Writable value \u003d null;\n \n           CurCall.set(call);\n           try {\n             // Make the call as the user via Subject.doAs, thus associating\n             // the call with the Subject\n             value \u003d \n               Subject.doAs(call.connection.user, \n                            new PrivilegedExceptionAction\u003cWritable\u003e() {\n                               @Override\n                               public Writable run() throws Exception {\n                                 // make the call\n                                 return call(call.connection.protocol, \n                                             call.param, call.timestamp);\n \n                               }\n                            }\n                           );\n               \n           } catch (PrivilegedActionException pae) {\n             Exception e \u003d pae.getException();\n             LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n           } catch (Throwable e) {\n             LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n             errorClass \u003d e.getClass().getName();\n             error \u003d StringUtils.stringifyException(e);\n           }\n           CurCall.set(null);\n-\n           setupResponse(buf, call, \n                         (error \u003d\u003d null) ? Status.SUCCESS : Status.ERROR, \n                         value, errorClass, error);\n+          // Discard the large buf and reset it back to \n+          // smaller size to freeup heap\n+          if (buf.size() \u003e MAX_RESP_BUF_SIZE) {\n+            LOG.warn(\"Large response size \" + buf.size() + \" for call \" + \n+                call.toString());\n+            buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n+          }\n           responder.doRespond(call);\n         } catch (InterruptedException e) {\n           if (running) {                          // unexpected -- log it\n             LOG.info(getName() + \" caught: \" +\n                      StringUtils.stringifyException(e));\n           }\n         } catch (Exception e) {\n           LOG.info(getName() + \" caught: \" +\n                    StringUtils.stringifyException(e));\n         }\n       }\n       LOG.info(getName() + \": exiting\");\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d \n        new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            value \u003d \n              Subject.doAs(call.connection.user, \n                           new PrivilegedExceptionAction\u003cWritable\u003e() {\n                              @Override\n                              public Writable run() throws Exception {\n                                // make the call\n                                return call(call.connection.protocol, \n                                            call.param, call.timestamp);\n\n                              }\n                           }\n                          );\n              \n          } catch (PrivilegedActionException pae) {\n            Exception e \u003d pae.getException();\n            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n          } catch (Throwable e) {\n            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n          }\n          CurCall.set(null);\n          setupResponse(buf, call, \n                        (error \u003d\u003d null) ? Status.SUCCESS : Status.ERROR, \n                        value, errorClass, error);\n          // Discard the large buf and reset it back to \n          // smaller size to freeup heap\n          if (buf.size() \u003e MAX_RESP_BUF_SIZE) {\n            LOG.warn(\"Large response size \" + buf.size() + \" for call \" + \n                call.toString());\n            buf \u003d new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);\n          }\n          responder.doRespond(call);\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" caught: \" +\n                     StringUtils.stringifyException(e));\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught: \" +\n                   StringUtils.stringifyException(e));\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,61 @@\n+    public void run() {\n+      LOG.info(getName() + \": starting\");\n+      SERVER.set(Server.this);\n+      ByteArrayOutputStream buf \u003d new ByteArrayOutputStream(10240);\n+      while (running) {\n+        try {\n+          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n+\n+          if (LOG.isDebugEnabled())\n+            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n+                      call.connection);\n+          \n+          String errorClass \u003d null;\n+          String error \u003d null;\n+          Writable value \u003d null;\n+\n+          CurCall.set(call);\n+          try {\n+            // Make the call as the user via Subject.doAs, thus associating\n+            // the call with the Subject\n+            value \u003d \n+              Subject.doAs(call.connection.user, \n+                           new PrivilegedExceptionAction\u003cWritable\u003e() {\n+                              @Override\n+                              public Writable run() throws Exception {\n+                                // make the call\n+                                return call(call.connection.protocol, \n+                                            call.param, call.timestamp);\n+\n+                              }\n+                           }\n+                          );\n+              \n+          } catch (PrivilegedActionException pae) {\n+            Exception e \u003d pae.getException();\n+            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n+            errorClass \u003d e.getClass().getName();\n+            error \u003d StringUtils.stringifyException(e);\n+          } catch (Throwable e) {\n+            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n+            errorClass \u003d e.getClass().getName();\n+            error \u003d StringUtils.stringifyException(e);\n+          }\n+          CurCall.set(null);\n+\n+          setupResponse(buf, call, \n+                        (error \u003d\u003d null) ? Status.SUCCESS : Status.ERROR, \n+                        value, errorClass, error);\n+          responder.doRespond(call);\n+        } catch (InterruptedException e) {\n+          if (running) {                          // unexpected -- log it\n+            LOG.info(getName() + \" caught: \" +\n+                     StringUtils.stringifyException(e));\n+          }\n+        } catch (Exception e) {\n+          LOG.info(getName() + \" caught: \" +\n+                   StringUtils.stringifyException(e));\n+        }\n+      }\n+      LOG.info(getName() + \": exiting\");\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(getName() + \": starting\");\n      SERVER.set(Server.this);\n      ByteArrayOutputStream buf \u003d new ByteArrayOutputStream(10240);\n      while (running) {\n        try {\n          final Call call \u003d callQueue.take(); // pop the queue; maybe blocked here\n\n          if (LOG.isDebugEnabled())\n            LOG.debug(getName() + \": has #\" + call.id + \" from \" +\n                      call.connection);\n          \n          String errorClass \u003d null;\n          String error \u003d null;\n          Writable value \u003d null;\n\n          CurCall.set(call);\n          try {\n            // Make the call as the user via Subject.doAs, thus associating\n            // the call with the Subject\n            value \u003d \n              Subject.doAs(call.connection.user, \n                           new PrivilegedExceptionAction\u003cWritable\u003e() {\n                              @Override\n                              public Writable run() throws Exception {\n                                // make the call\n                                return call(call.connection.protocol, \n                                            call.param, call.timestamp);\n\n                              }\n                           }\n                          );\n              \n          } catch (PrivilegedActionException pae) {\n            Exception e \u003d pae.getException();\n            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n          } catch (Throwable e) {\n            LOG.info(getName()+\", call \"+call+\": error: \" + e, e);\n            errorClass \u003d e.getClass().getName();\n            error \u003d StringUtils.stringifyException(e);\n          }\n          CurCall.set(null);\n\n          setupResponse(buf, call, \n                        (error \u003d\u003d null) ? Status.SUCCESS : Status.ERROR, \n                        value, errorClass, error);\n          responder.doRespond(call);\n        } catch (InterruptedException e) {\n          if (running) {                          // unexpected -- log it\n            LOG.info(getName() + \" caught: \" +\n                     StringUtils.stringifyException(e));\n          }\n        } catch (Exception e) {\n          LOG.info(getName() + \" caught: \" +\n                   StringUtils.stringifyException(e));\n        }\n      }\n      LOG.info(getName() + \": exiting\");\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java"
    }
  }
}