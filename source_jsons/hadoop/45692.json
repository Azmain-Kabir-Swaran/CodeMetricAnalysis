{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "IndexedFileAggregatedLogsBlock.java",
  "functionName": "render",
  "functionId": "render___html-Block",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/IndexedFileAggregatedLogsBlock.java",
  "functionStartLine": 72,
  "functionEndLine": 194,
  "numCommitsSeen": 8,
  "timeTaken": 3250,
  "changeHistory": [
    "74411ce0ce7336c0f7bb5793939fdd64a5dcdef6",
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
    "d4c98579e36df7eeb788352d7b76cd2c7448c511",
    "631b5c2db733b0733a779e843b8035f68d0fcdf3",
    "d57dba99428cbe3f3dfcec834d79f709e7529ef9",
    "280080fad01304c85a9ede4d4f7b707eb36c0155",
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc"
  ],
  "changeHistoryShort": {
    "74411ce0ce7336c0f7bb5793939fdd64a5dcdef6": "Ybodychange",
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": "Ybodychange",
    "d4c98579e36df7eeb788352d7b76cd2c7448c511": "Ybodychange",
    "631b5c2db733b0733a779e843b8035f68d0fcdf3": "Ybodychange",
    "d57dba99428cbe3f3dfcec834d79f709e7529ef9": "Ybodychange",
    "280080fad01304c85a9ede4d4f7b707eb36c0155": "Ybodychange",
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "74411ce0ce7336c0f7bb5793939fdd64a5dcdef6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7417. Remove duplicated code from IndexedFileAggregatedLogsBlock\n           and TFileAggregatedLogsBlock.\n           Contributed by Zian Chen\n",
      "commitDate": "13/08/18 1:50 PM",
      "commitName": "74411ce0ce7336c0f7bb5793939fdd64a5dcdef6",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "30/07/18 10:55 AM",
      "commitNameOld": "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 14.12,
      "commitsBetweenForRepo": 153,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,203 +1,123 @@\n   protected void render(Block html) {\n     BlockParameters params \u003d verifyAndParseParameters(html);\n     if (params \u003d\u003d null) {\n       return;\n     }\n \n     ApplicationId appId \u003d params.getAppId();\n     ContainerId containerId \u003d params.getContainerId();\n     NodeId nodeId \u003d params.getNodeId();\n     String appOwner \u003d params.getAppOwner();\n     String logEntity \u003d params.getLogEntity();\n     long start \u003d params.getStartIndex();\n     long end \u003d params.getEndIndex();\n     long startTime \u003d params.getStartTime();\n     long endTime \u003d params.getEndTime();\n \n     List\u003cFileStatus\u003e nodeFiles \u003d null;\n     try {\n       nodeFiles \u003d LogAggregationUtils\n           .getRemoteNodeFileList(conf, appId, appOwner,\n               this.fileController.getRemoteRootLogDir(),\n               this.fileController.getRemoteRootLogDirSuffix());\n     } catch(Exception ex) {\n       html.h1(\"Unable to locate any logs for container \"\n           + containerId.toString());\n       LOG.error(ex.getMessage());\n       return;\n     }\n \n     Map\u003cString, Long\u003e checkSumFiles;\n     try {\n       checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     List\u003cFileStatus\u003e fileToRead;\n     try {\n       fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n           nodeId.toString(), appId);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       for (FileStatus thisNodeFile : fileToRead) {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta indexedLogsMeta \u003d null;\n         try {\n           indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n               thisNodeFile.getPath(), endIndex, appId);\n         } catch (Exception ex) {\n           // DO NOTHING\n           LOG.warn(\"Can not load log meta from the log file:\"\n               + thisNodeFile.getPath());\n           continue;\n         }\n         if (indexedLogsMeta \u003d\u003d null) {\n           continue;\n         }\n         Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n         String user \u003d indexedLogsMeta.getUser();\n         String remoteUser \u003d request().getRemoteUser();\n         if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n           html.h1().__(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity\n               + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n               .__();\n           LOG.error(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity);\n           continue;\n         }\n         String compressAlgo \u003d indexedLogsMeta.getCompressName();\n         List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n         for (IndexedPerAggregationLogMeta logMeta\n             : indexedLogsMeta.getLogMetas()) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n               : logMeta.getLogMetas().entrySet()) {\n             for (IndexedFileLogMeta log : meta.getValue()) {\n               if (!log.getContainerId().equals(containerId.toString())) {\n                 continue;\n               }\n               if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                   \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                 continue;\n               }\n               candidates.add(log);\n             }\n           }\n         }\n         if (candidates.isEmpty()) {\n           continue;\n         }\n \n-        Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n-            compressAlgo);\n-        Decompressor decompressor \u003d compressName.getDecompressor();\n-        FileContext fileContext \u003d FileContext.getFileContext(\n-            thisNodeFile.getPath().toUri(), conf);\n-        FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n-        int bufferSize \u003d 65536;\n-        for (IndexedFileLogMeta candidate : candidates) {\n-          if (candidate.getLastModifiedTime() \u003c startTime\n-              || candidate.getLastModifiedTime() \u003e endTime) {\n-            continue;\n-          }\n-          byte[] cbuf \u003d new byte[bufferSize];\n-          InputStream in \u003d null;\n-          try {\n-            in \u003d compressName.createDecompressionStream(\n-                new BoundedRangeFileInputStream(fsin,\n-                    candidate.getStartIndex(),\n-                    candidate.getFileCompressedSize()),\n-                    decompressor,\n-                    LogAggregationIndexedFileController.getFSInputBufferSize(\n-                        conf));\n-            long logLength \u003d candidate.getFileSize();\n-            html.pre().__(\"\\n\\n\").__();\n-            html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n-            html.p().__(\"Log Upload Time: \" + Times.format(\n-                candidate.getLastModifiedTime())).__();\n-            html.p().__(\"Log Length: \" + Long.toString(\n-                logLength)).__();\n-            long startIndex \u003d start \u003c 0\n-                ? logLength + start : start;\n-            startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n-            startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n-            long endLogIndex \u003d end \u003c 0\n-                ? logLength + end : end;\n-            endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n-            endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n-            endLogIndex \u003d endLogIndex \u003c startIndex ?\n-                startIndex : endLogIndex;\n-            long toRead \u003d endLogIndex - startIndex;\n-            if (toRead \u003c logLength) {\n-              html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n-                  + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n-                      $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n-                      candidate.getFileName(), \"?start\u003d0\u0026start.time\u003d\"\n-                      + startTime + \"\u0026end.time\u003d\" + endTime), \"here\").\n-                      __(\" for the full log.\").__();\n-            }\n-            long totalSkipped \u003d 0;\n-            while (totalSkipped \u003c startIndex) {\n-              long ret \u003d in.skip(startIndex - totalSkipped);\n-              if (ret \u003d\u003d 0) {\n-                //Read one byte\n-                int nextByte \u003d in.read();\n-                // Check if we have reached EOF\n-                if (nextByte \u003d\u003d -1) {\n-                  throw new IOException(\"Premature EOF from container log\");\n-                }\n-                ret \u003d 1;\n-              }\n-              totalSkipped +\u003d ret;\n-            }\n-            int len \u003d 0;\n-            int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n-            PRE\u003cHamlet\u003e pre \u003d html.pre();\n-\n-            while (toRead \u003e 0\n-                \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n-              pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n-              toRead \u003d toRead - len;\n-              currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n-            }\n-\n-            pre.__();\n-            foundLog \u003d true;\n-          } catch (Exception ex) {\n-            LOG.error(\"Error getting logs for \" + logEntity, ex);\n-            continue;\n-          } finally {\n-            IOUtils.closeQuietly(in);\n-          }\n-        }\n+        foundLog \u003d readContainerLog(compressAlgo, html, thisNodeFile, start,\n+            end, candidates, startTime, endTime, foundLog, logEntity);\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \" + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (RuntimeException e) {\n       throw e;\n     } catch (Exception ex) {\n       html.h1().__(\"Error getting logs for \" + logEntity).__();\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    BlockParameters params \u003d verifyAndParseParameters(html);\n    if (params \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId appId \u003d params.getAppId();\n    ContainerId containerId \u003d params.getContainerId();\n    NodeId nodeId \u003d params.getNodeId();\n    String appOwner \u003d params.getAppOwner();\n    String logEntity \u003d params.getLogEntity();\n    long start \u003d params.getStartIndex();\n    long end \u003d params.getEndIndex();\n    long startTime \u003d params.getStartTime();\n    long endTime \u003d params.getEndTime();\n\n    List\u003cFileStatus\u003e nodeFiles \u003d null;\n    try {\n      nodeFiles \u003d LogAggregationUtils\n          .getRemoteNodeFileList(conf, appId, appOwner,\n              this.fileController.getRemoteRootLogDir(),\n              this.fileController.getRemoteRootLogDirSuffix());\n    } catch(Exception ex) {\n      html.h1(\"Unable to locate any logs for container \"\n          + containerId.toString());\n      LOG.error(ex.getMessage());\n      return;\n    }\n\n    Map\u003cString, Long\u003e checkSumFiles;\n    try {\n      checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    List\u003cFileStatus\u003e fileToRead;\n    try {\n      fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n          nodeId.toString(), appId);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      for (FileStatus thisNodeFile : fileToRead) {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta indexedLogsMeta \u003d null;\n        try {\n          indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n              thisNodeFile.getPath(), endIndex, appId);\n        } catch (Exception ex) {\n          // DO NOTHING\n          LOG.warn(\"Can not load log meta from the log file:\"\n              + thisNodeFile.getPath());\n          continue;\n        }\n        if (indexedLogsMeta \u003d\u003d null) {\n          continue;\n        }\n        Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n        String user \u003d indexedLogsMeta.getUser();\n        String remoteUser \u003d request().getRemoteUser();\n        if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n          html.h1().__(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity\n              + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n              .__();\n          LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n          continue;\n        }\n        String compressAlgo \u003d indexedLogsMeta.getCompressName();\n        List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n        for (IndexedPerAggregationLogMeta logMeta\n            : indexedLogsMeta.getLogMetas()) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n              : logMeta.getLogMetas().entrySet()) {\n            for (IndexedFileLogMeta log : meta.getValue()) {\n              if (!log.getContainerId().equals(containerId.toString())) {\n                continue;\n              }\n              if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                  \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                continue;\n              }\n              candidates.add(log);\n            }\n          }\n        }\n        if (candidates.isEmpty()) {\n          continue;\n        }\n\n        foundLog \u003d readContainerLog(compressAlgo, html, thisNodeFile, start,\n            end, candidates, startTime, endTime, foundLog, logEntity);\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception ex) {\n      html.h1().__(\"Error getting logs for \" + logEntity).__();\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/IndexedFileAggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8584. Several typos in Log Aggregation related classes. Contributed by Szilard Nemeth.\n",
      "commitDate": "30/07/18 10:55 AM",
      "commitName": "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "11/02/18 6:28 PM",
      "commitNameOld": "d4c98579e36df7eeb788352d7b76cd2c7448c511",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 168.64,
      "commitsBetweenForRepo": 1796,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,203 +1,203 @@\n   protected void render(Block html) {\n     BlockParameters params \u003d verifyAndParseParameters(html);\n     if (params \u003d\u003d null) {\n       return;\n     }\n \n     ApplicationId appId \u003d params.getAppId();\n     ContainerId containerId \u003d params.getContainerId();\n     NodeId nodeId \u003d params.getNodeId();\n     String appOwner \u003d params.getAppOwner();\n     String logEntity \u003d params.getLogEntity();\n     long start \u003d params.getStartIndex();\n     long end \u003d params.getEndIndex();\n     long startTime \u003d params.getStartTime();\n     long endTime \u003d params.getEndTime();\n \n     List\u003cFileStatus\u003e nodeFiles \u003d null;\n     try {\n       nodeFiles \u003d LogAggregationUtils\n           .getRemoteNodeFileList(conf, appId, appOwner,\n               this.fileController.getRemoteRootLogDir(),\n               this.fileController.getRemoteRootLogDirSuffix());\n     } catch(Exception ex) {\n       html.h1(\"Unable to locate any logs for container \"\n           + containerId.toString());\n       LOG.error(ex.getMessage());\n       return;\n     }\n \n     Map\u003cString, Long\u003e checkSumFiles;\n     try {\n       checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     List\u003cFileStatus\u003e fileToRead;\n     try {\n       fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n           nodeId.toString(), appId);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       for (FileStatus thisNodeFile : fileToRead) {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta indexedLogsMeta \u003d null;\n         try {\n           indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n               thisNodeFile.getPath(), endIndex, appId);\n         } catch (Exception ex) {\n           // DO NOTHING\n           LOG.warn(\"Can not load log meta from the log file:\"\n               + thisNodeFile.getPath());\n           continue;\n         }\n         if (indexedLogsMeta \u003d\u003d null) {\n           continue;\n         }\n         Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n         String user \u003d indexedLogsMeta.getUser();\n         String remoteUser \u003d request().getRemoteUser();\n         if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n           html.h1().__(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity\n               + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n               .__();\n           LOG.error(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity);\n           continue;\n         }\n         String compressAlgo \u003d indexedLogsMeta.getCompressName();\n         List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n         for (IndexedPerAggregationLogMeta logMeta\n             : indexedLogsMeta.getLogMetas()) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n               : logMeta.getLogMetas().entrySet()) {\n             for (IndexedFileLogMeta log : meta.getValue()) {\n               if (!log.getContainerId().equals(containerId.toString())) {\n                 continue;\n               }\n               if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                   \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                 continue;\n               }\n               candidates.add(log);\n             }\n           }\n         }\n         if (candidates.isEmpty()) {\n           continue;\n         }\n \n         Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n             compressAlgo);\n         Decompressor decompressor \u003d compressName.getDecompressor();\n         FileContext fileContext \u003d FileContext.getFileContext(\n             thisNodeFile.getPath().toUri(), conf);\n         FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n         int bufferSize \u003d 65536;\n         for (IndexedFileLogMeta candidate : candidates) {\n-          if (candidate.getLastModificatedTime() \u003c startTime\n-              || candidate.getLastModificatedTime() \u003e endTime) {\n+          if (candidate.getLastModifiedTime() \u003c startTime\n+              || candidate.getLastModifiedTime() \u003e endTime) {\n             continue;\n           }\n           byte[] cbuf \u003d new byte[bufferSize];\n           InputStream in \u003d null;\n           try {\n             in \u003d compressName.createDecompressionStream(\n                 new BoundedRangeFileInputStream(fsin,\n                     candidate.getStartIndex(),\n                     candidate.getFileCompressedSize()),\n                     decompressor,\n                     LogAggregationIndexedFileController.getFSInputBufferSize(\n                         conf));\n             long logLength \u003d candidate.getFileSize();\n             html.pre().__(\"\\n\\n\").__();\n             html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n             html.p().__(\"Log Upload Time: \" + Times.format(\n-                candidate.getLastModificatedTime())).__();\n+                candidate.getLastModifiedTime())).__();\n             html.p().__(\"Log Length: \" + Long.toString(\n                 logLength)).__();\n             long startIndex \u003d start \u003c 0\n                 ? logLength + start : start;\n             startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n             startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n             long endLogIndex \u003d end \u003c 0\n                 ? logLength + end : end;\n             endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n             endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n             endLogIndex \u003d endLogIndex \u003c startIndex ?\n                 startIndex : endLogIndex;\n             long toRead \u003d endLogIndex - startIndex;\n             if (toRead \u003c logLength) {\n               html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n                   + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n                       $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n                       candidate.getFileName(), \"?start\u003d0\u0026start.time\u003d\"\n                       + startTime + \"\u0026end.time\u003d\" + endTime), \"here\").\n                       __(\" for the full log.\").__();\n             }\n             long totalSkipped \u003d 0;\n             while (totalSkipped \u003c startIndex) {\n               long ret \u003d in.skip(startIndex - totalSkipped);\n               if (ret \u003d\u003d 0) {\n                 //Read one byte\n                 int nextByte \u003d in.read();\n                 // Check if we have reached EOF\n                 if (nextByte \u003d\u003d -1) {\n                   throw new IOException(\"Premature EOF from container log\");\n                 }\n                 ret \u003d 1;\n               }\n               totalSkipped +\u003d ret;\n             }\n             int len \u003d 0;\n             int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n             PRE\u003cHamlet\u003e pre \u003d html.pre();\n \n             while (toRead \u003e 0\n                 \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n               pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n               toRead \u003d toRead - len;\n               currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n             }\n \n             pre.__();\n             foundLog \u003d true;\n           } catch (Exception ex) {\n             LOG.error(\"Error getting logs for \" + logEntity, ex);\n             continue;\n           } finally {\n             IOUtils.closeQuietly(in);\n           }\n         }\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \" + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (RuntimeException e) {\n       throw e;\n     } catch (Exception ex) {\n       html.h1().__(\"Error getting logs for \" + logEntity).__();\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    BlockParameters params \u003d verifyAndParseParameters(html);\n    if (params \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId appId \u003d params.getAppId();\n    ContainerId containerId \u003d params.getContainerId();\n    NodeId nodeId \u003d params.getNodeId();\n    String appOwner \u003d params.getAppOwner();\n    String logEntity \u003d params.getLogEntity();\n    long start \u003d params.getStartIndex();\n    long end \u003d params.getEndIndex();\n    long startTime \u003d params.getStartTime();\n    long endTime \u003d params.getEndTime();\n\n    List\u003cFileStatus\u003e nodeFiles \u003d null;\n    try {\n      nodeFiles \u003d LogAggregationUtils\n          .getRemoteNodeFileList(conf, appId, appOwner,\n              this.fileController.getRemoteRootLogDir(),\n              this.fileController.getRemoteRootLogDirSuffix());\n    } catch(Exception ex) {\n      html.h1(\"Unable to locate any logs for container \"\n          + containerId.toString());\n      LOG.error(ex.getMessage());\n      return;\n    }\n\n    Map\u003cString, Long\u003e checkSumFiles;\n    try {\n      checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    List\u003cFileStatus\u003e fileToRead;\n    try {\n      fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n          nodeId.toString(), appId);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      for (FileStatus thisNodeFile : fileToRead) {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta indexedLogsMeta \u003d null;\n        try {\n          indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n              thisNodeFile.getPath(), endIndex, appId);\n        } catch (Exception ex) {\n          // DO NOTHING\n          LOG.warn(\"Can not load log meta from the log file:\"\n              + thisNodeFile.getPath());\n          continue;\n        }\n        if (indexedLogsMeta \u003d\u003d null) {\n          continue;\n        }\n        Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n        String user \u003d indexedLogsMeta.getUser();\n        String remoteUser \u003d request().getRemoteUser();\n        if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n          html.h1().__(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity\n              + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n              .__();\n          LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n          continue;\n        }\n        String compressAlgo \u003d indexedLogsMeta.getCompressName();\n        List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n        for (IndexedPerAggregationLogMeta logMeta\n            : indexedLogsMeta.getLogMetas()) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n              : logMeta.getLogMetas().entrySet()) {\n            for (IndexedFileLogMeta log : meta.getValue()) {\n              if (!log.getContainerId().equals(containerId.toString())) {\n                continue;\n              }\n              if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                  \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                continue;\n              }\n              candidates.add(log);\n            }\n          }\n        }\n        if (candidates.isEmpty()) {\n          continue;\n        }\n\n        Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n            compressAlgo);\n        Decompressor decompressor \u003d compressName.getDecompressor();\n        FileContext fileContext \u003d FileContext.getFileContext(\n            thisNodeFile.getPath().toUri(), conf);\n        FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n        int bufferSize \u003d 65536;\n        for (IndexedFileLogMeta candidate : candidates) {\n          if (candidate.getLastModifiedTime() \u003c startTime\n              || candidate.getLastModifiedTime() \u003e endTime) {\n            continue;\n          }\n          byte[] cbuf \u003d new byte[bufferSize];\n          InputStream in \u003d null;\n          try {\n            in \u003d compressName.createDecompressionStream(\n                new BoundedRangeFileInputStream(fsin,\n                    candidate.getStartIndex(),\n                    candidate.getFileCompressedSize()),\n                    decompressor,\n                    LogAggregationIndexedFileController.getFSInputBufferSize(\n                        conf));\n            long logLength \u003d candidate.getFileSize();\n            html.pre().__(\"\\n\\n\").__();\n            html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n            html.p().__(\"Log Upload Time: \" + Times.format(\n                candidate.getLastModifiedTime())).__();\n            html.p().__(\"Log Length: \" + Long.toString(\n                logLength)).__();\n            long startIndex \u003d start \u003c 0\n                ? logLength + start : start;\n            startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n            startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n            long endLogIndex \u003d end \u003c 0\n                ? logLength + end : end;\n            endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003c startIndex ?\n                startIndex : endLogIndex;\n            long toRead \u003d endLogIndex - startIndex;\n            if (toRead \u003c logLength) {\n              html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n                  + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n                      $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n                      candidate.getFileName(), \"?start\u003d0\u0026start.time\u003d\"\n                      + startTime + \"\u0026end.time\u003d\" + endTime), \"here\").\n                      __(\" for the full log.\").__();\n            }\n            long totalSkipped \u003d 0;\n            while (totalSkipped \u003c startIndex) {\n              long ret \u003d in.skip(startIndex - totalSkipped);\n              if (ret \u003d\u003d 0) {\n                //Read one byte\n                int nextByte \u003d in.read();\n                // Check if we have reached EOF\n                if (nextByte \u003d\u003d -1) {\n                  throw new IOException(\"Premature EOF from container log\");\n                }\n                ret \u003d 1;\n              }\n              totalSkipped +\u003d ret;\n            }\n            int len \u003d 0;\n            int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            PRE\u003cHamlet\u003e pre \u003d html.pre();\n\n            while (toRead \u003e 0\n                \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n              pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n              toRead \u003d toRead - len;\n              currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            }\n\n            pre.__();\n            foundLog \u003d true;\n          } catch (Exception ex) {\n            LOG.error(\"Error getting logs for \" + logEntity, ex);\n            continue;\n          } finally {\n            IOUtils.closeQuietly(in);\n          }\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception ex) {\n      html.h1().__(\"Error getting logs for \" + logEntity).__();\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/IndexedFileAggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "d4c98579e36df7eeb788352d7b76cd2c7448c511": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7697. NM goes down with OOM due to leak in log-aggregation. (Xuan Gong via wangda)\n\nChange-Id: Ie4fc7979d834e25f37a033c314f3efceeb8f4a9e\n",
      "commitDate": "11/02/18 6:28 PM",
      "commitName": "d4c98579e36df7eeb788352d7b76cd2c7448c511",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "15/12/17 3:38 PM",
      "commitNameOld": "631b5c2db733b0733a779e843b8035f68d0fcdf3",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 58.12,
      "commitsBetweenForRepo": 328,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,203 +1,203 @@\n   protected void render(Block html) {\n     BlockParameters params \u003d verifyAndParseParameters(html);\n     if (params \u003d\u003d null) {\n       return;\n     }\n \n     ApplicationId appId \u003d params.getAppId();\n     ContainerId containerId \u003d params.getContainerId();\n     NodeId nodeId \u003d params.getNodeId();\n     String appOwner \u003d params.getAppOwner();\n     String logEntity \u003d params.getLogEntity();\n     long start \u003d params.getStartIndex();\n     long end \u003d params.getEndIndex();\n     long startTime \u003d params.getStartTime();\n     long endTime \u003d params.getEndTime();\n \n     List\u003cFileStatus\u003e nodeFiles \u003d null;\n     try {\n       nodeFiles \u003d LogAggregationUtils\n           .getRemoteNodeFileList(conf, appId, appOwner,\n               this.fileController.getRemoteRootLogDir(),\n               this.fileController.getRemoteRootLogDirSuffix());\n     } catch(Exception ex) {\n       html.h1(\"Unable to locate any logs for container \"\n           + containerId.toString());\n       LOG.error(ex.getMessage());\n       return;\n     }\n \n     Map\u003cString, Long\u003e checkSumFiles;\n     try {\n       checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     List\u003cFileStatus\u003e fileToRead;\n     try {\n       fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n           nodeId.toString(), appId);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       for (FileStatus thisNodeFile : fileToRead) {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta indexedLogsMeta \u003d null;\n         try {\n           indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n-              thisNodeFile.getPath(), endIndex);\n+              thisNodeFile.getPath(), endIndex, appId);\n         } catch (Exception ex) {\n           // DO NOTHING\n           LOG.warn(\"Can not load log meta from the log file:\"\n               + thisNodeFile.getPath());\n           continue;\n         }\n         if (indexedLogsMeta \u003d\u003d null) {\n           continue;\n         }\n         Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n         String user \u003d indexedLogsMeta.getUser();\n         String remoteUser \u003d request().getRemoteUser();\n         if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n           html.h1().__(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity\n               + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n               .__();\n           LOG.error(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity);\n           continue;\n         }\n         String compressAlgo \u003d indexedLogsMeta.getCompressName();\n         List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n         for (IndexedPerAggregationLogMeta logMeta\n             : indexedLogsMeta.getLogMetas()) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n               : logMeta.getLogMetas().entrySet()) {\n             for (IndexedFileLogMeta log : meta.getValue()) {\n               if (!log.getContainerId().equals(containerId.toString())) {\n                 continue;\n               }\n               if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                   \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                 continue;\n               }\n               candidates.add(log);\n             }\n           }\n         }\n         if (candidates.isEmpty()) {\n           continue;\n         }\n \n         Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n             compressAlgo);\n         Decompressor decompressor \u003d compressName.getDecompressor();\n         FileContext fileContext \u003d FileContext.getFileContext(\n             thisNodeFile.getPath().toUri(), conf);\n         FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n         int bufferSize \u003d 65536;\n         for (IndexedFileLogMeta candidate : candidates) {\n           if (candidate.getLastModificatedTime() \u003c startTime\n               || candidate.getLastModificatedTime() \u003e endTime) {\n             continue;\n           }\n           byte[] cbuf \u003d new byte[bufferSize];\n           InputStream in \u003d null;\n           try {\n             in \u003d compressName.createDecompressionStream(\n                 new BoundedRangeFileInputStream(fsin,\n                     candidate.getStartIndex(),\n                     candidate.getFileCompressedSize()),\n                     decompressor,\n                     LogAggregationIndexedFileController.getFSInputBufferSize(\n                         conf));\n             long logLength \u003d candidate.getFileSize();\n             html.pre().__(\"\\n\\n\").__();\n             html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n             html.p().__(\"Log Upload Time: \" + Times.format(\n                 candidate.getLastModificatedTime())).__();\n             html.p().__(\"Log Length: \" + Long.toString(\n                 logLength)).__();\n             long startIndex \u003d start \u003c 0\n                 ? logLength + start : start;\n             startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n             startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n             long endLogIndex \u003d end \u003c 0\n                 ? logLength + end : end;\n             endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n             endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n             endLogIndex \u003d endLogIndex \u003c startIndex ?\n                 startIndex : endLogIndex;\n             long toRead \u003d endLogIndex - startIndex;\n             if (toRead \u003c logLength) {\n               html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n                   + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n                       $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n                       candidate.getFileName(), \"?start\u003d0\u0026start.time\u003d\"\n                       + startTime + \"\u0026end.time\u003d\" + endTime), \"here\").\n                       __(\" for the full log.\").__();\n             }\n             long totalSkipped \u003d 0;\n             while (totalSkipped \u003c startIndex) {\n               long ret \u003d in.skip(startIndex - totalSkipped);\n               if (ret \u003d\u003d 0) {\n                 //Read one byte\n                 int nextByte \u003d in.read();\n                 // Check if we have reached EOF\n                 if (nextByte \u003d\u003d -1) {\n                   throw new IOException(\"Premature EOF from container log\");\n                 }\n                 ret \u003d 1;\n               }\n               totalSkipped +\u003d ret;\n             }\n             int len \u003d 0;\n             int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n             PRE\u003cHamlet\u003e pre \u003d html.pre();\n \n             while (toRead \u003e 0\n                 \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n               pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n               toRead \u003d toRead - len;\n               currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n             }\n \n             pre.__();\n             foundLog \u003d true;\n           } catch (Exception ex) {\n             LOG.error(\"Error getting logs for \" + logEntity, ex);\n             continue;\n           } finally {\n             IOUtils.closeQuietly(in);\n           }\n         }\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \" + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (RuntimeException e) {\n       throw e;\n     } catch (Exception ex) {\n       html.h1().__(\"Error getting logs for \" + logEntity).__();\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    BlockParameters params \u003d verifyAndParseParameters(html);\n    if (params \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId appId \u003d params.getAppId();\n    ContainerId containerId \u003d params.getContainerId();\n    NodeId nodeId \u003d params.getNodeId();\n    String appOwner \u003d params.getAppOwner();\n    String logEntity \u003d params.getLogEntity();\n    long start \u003d params.getStartIndex();\n    long end \u003d params.getEndIndex();\n    long startTime \u003d params.getStartTime();\n    long endTime \u003d params.getEndTime();\n\n    List\u003cFileStatus\u003e nodeFiles \u003d null;\n    try {\n      nodeFiles \u003d LogAggregationUtils\n          .getRemoteNodeFileList(conf, appId, appOwner,\n              this.fileController.getRemoteRootLogDir(),\n              this.fileController.getRemoteRootLogDirSuffix());\n    } catch(Exception ex) {\n      html.h1(\"Unable to locate any logs for container \"\n          + containerId.toString());\n      LOG.error(ex.getMessage());\n      return;\n    }\n\n    Map\u003cString, Long\u003e checkSumFiles;\n    try {\n      checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    List\u003cFileStatus\u003e fileToRead;\n    try {\n      fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n          nodeId.toString(), appId);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      for (FileStatus thisNodeFile : fileToRead) {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta indexedLogsMeta \u003d null;\n        try {\n          indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n              thisNodeFile.getPath(), endIndex, appId);\n        } catch (Exception ex) {\n          // DO NOTHING\n          LOG.warn(\"Can not load log meta from the log file:\"\n              + thisNodeFile.getPath());\n          continue;\n        }\n        if (indexedLogsMeta \u003d\u003d null) {\n          continue;\n        }\n        Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n        String user \u003d indexedLogsMeta.getUser();\n        String remoteUser \u003d request().getRemoteUser();\n        if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n          html.h1().__(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity\n              + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n              .__();\n          LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n          continue;\n        }\n        String compressAlgo \u003d indexedLogsMeta.getCompressName();\n        List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n        for (IndexedPerAggregationLogMeta logMeta\n            : indexedLogsMeta.getLogMetas()) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n              : logMeta.getLogMetas().entrySet()) {\n            for (IndexedFileLogMeta log : meta.getValue()) {\n              if (!log.getContainerId().equals(containerId.toString())) {\n                continue;\n              }\n              if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                  \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                continue;\n              }\n              candidates.add(log);\n            }\n          }\n        }\n        if (candidates.isEmpty()) {\n          continue;\n        }\n\n        Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n            compressAlgo);\n        Decompressor decompressor \u003d compressName.getDecompressor();\n        FileContext fileContext \u003d FileContext.getFileContext(\n            thisNodeFile.getPath().toUri(), conf);\n        FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n        int bufferSize \u003d 65536;\n        for (IndexedFileLogMeta candidate : candidates) {\n          if (candidate.getLastModificatedTime() \u003c startTime\n              || candidate.getLastModificatedTime() \u003e endTime) {\n            continue;\n          }\n          byte[] cbuf \u003d new byte[bufferSize];\n          InputStream in \u003d null;\n          try {\n            in \u003d compressName.createDecompressionStream(\n                new BoundedRangeFileInputStream(fsin,\n                    candidate.getStartIndex(),\n                    candidate.getFileCompressedSize()),\n                    decompressor,\n                    LogAggregationIndexedFileController.getFSInputBufferSize(\n                        conf));\n            long logLength \u003d candidate.getFileSize();\n            html.pre().__(\"\\n\\n\").__();\n            html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n            html.p().__(\"Log Upload Time: \" + Times.format(\n                candidate.getLastModificatedTime())).__();\n            html.p().__(\"Log Length: \" + Long.toString(\n                logLength)).__();\n            long startIndex \u003d start \u003c 0\n                ? logLength + start : start;\n            startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n            startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n            long endLogIndex \u003d end \u003c 0\n                ? logLength + end : end;\n            endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003c startIndex ?\n                startIndex : endLogIndex;\n            long toRead \u003d endLogIndex - startIndex;\n            if (toRead \u003c logLength) {\n              html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n                  + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n                      $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n                      candidate.getFileName(), \"?start\u003d0\u0026start.time\u003d\"\n                      + startTime + \"\u0026end.time\u003d\" + endTime), \"here\").\n                      __(\" for the full log.\").__();\n            }\n            long totalSkipped \u003d 0;\n            while (totalSkipped \u003c startIndex) {\n              long ret \u003d in.skip(startIndex - totalSkipped);\n              if (ret \u003d\u003d 0) {\n                //Read one byte\n                int nextByte \u003d in.read();\n                // Check if we have reached EOF\n                if (nextByte \u003d\u003d -1) {\n                  throw new IOException(\"Premature EOF from container log\");\n                }\n                ret \u003d 1;\n              }\n              totalSkipped +\u003d ret;\n            }\n            int len \u003d 0;\n            int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            PRE\u003cHamlet\u003e pre \u003d html.pre();\n\n            while (toRead \u003e 0\n                \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n              pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n              toRead \u003d toRead - len;\n              currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            }\n\n            pre.__();\n            foundLog \u003d true;\n          } catch (Exception ex) {\n            LOG.error(\"Error getting logs for \" + logEntity, ex);\n            continue;\n          } finally {\n            IOUtils.closeQuietly(in);\n          }\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception ex) {\n      html.h1().__(\"Error getting logs for \" + logEntity).__();\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/IndexedFileAggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "631b5c2db733b0733a779e843b8035f68d0fcdf3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5418. When partial log aggregation is enabled, display the list of aggregated files on the container log page. (Xuan Gong via wangda)\n\nChange-Id: I1befb0bbaeb89fb315bafe3e2f3379663f8cf1ec\n",
      "commitDate": "15/12/17 3:38 PM",
      "commitName": "631b5c2db733b0733a779e843b8035f68d0fcdf3",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "01/11/17 2:48 PM",
      "commitNameOld": "d57dba99428cbe3f3dfcec834d79f709e7529ef9",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 44.08,
      "commitsBetweenForRepo": 351,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,196 +1,203 @@\n   protected void render(Block html) {\n     BlockParameters params \u003d verifyAndParseParameters(html);\n     if (params \u003d\u003d null) {\n       return;\n     }\n \n     ApplicationId appId \u003d params.getAppId();\n     ContainerId containerId \u003d params.getContainerId();\n     NodeId nodeId \u003d params.getNodeId();\n     String appOwner \u003d params.getAppOwner();\n     String logEntity \u003d params.getLogEntity();\n     long start \u003d params.getStartIndex();\n     long end \u003d params.getEndIndex();\n+    long startTime \u003d params.getStartTime();\n+    long endTime \u003d params.getEndTime();\n \n     List\u003cFileStatus\u003e nodeFiles \u003d null;\n     try {\n       nodeFiles \u003d LogAggregationUtils\n           .getRemoteNodeFileList(conf, appId, appOwner,\n               this.fileController.getRemoteRootLogDir(),\n               this.fileController.getRemoteRootLogDirSuffix());\n     } catch(Exception ex) {\n       html.h1(\"Unable to locate any logs for container \"\n           + containerId.toString());\n       LOG.error(ex.getMessage());\n       return;\n     }\n \n     Map\u003cString, Long\u003e checkSumFiles;\n     try {\n       checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     List\u003cFileStatus\u003e fileToRead;\n     try {\n       fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n           nodeId.toString(), appId);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       for (FileStatus thisNodeFile : fileToRead) {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta indexedLogsMeta \u003d null;\n         try {\n           indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n               thisNodeFile.getPath(), endIndex);\n         } catch (Exception ex) {\n           // DO NOTHING\n           LOG.warn(\"Can not load log meta from the log file:\"\n               + thisNodeFile.getPath());\n           continue;\n         }\n         if (indexedLogsMeta \u003d\u003d null) {\n           continue;\n         }\n         Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n         String user \u003d indexedLogsMeta.getUser();\n         String remoteUser \u003d request().getRemoteUser();\n         if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n           html.h1().__(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity\n               + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n               .__();\n           LOG.error(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity);\n           continue;\n         }\n         String compressAlgo \u003d indexedLogsMeta.getCompressName();\n         List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n         for (IndexedPerAggregationLogMeta logMeta\n             : indexedLogsMeta.getLogMetas()) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n               : logMeta.getLogMetas().entrySet()) {\n             for (IndexedFileLogMeta log : meta.getValue()) {\n               if (!log.getContainerId().equals(containerId.toString())) {\n                 continue;\n               }\n               if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                   \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                 continue;\n               }\n               candidates.add(log);\n             }\n           }\n         }\n         if (candidates.isEmpty()) {\n           continue;\n         }\n \n         Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n             compressAlgo);\n         Decompressor decompressor \u003d compressName.getDecompressor();\n         FileContext fileContext \u003d FileContext.getFileContext(\n             thisNodeFile.getPath().toUri(), conf);\n         FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n         int bufferSize \u003d 65536;\n         for (IndexedFileLogMeta candidate : candidates) {\n+          if (candidate.getLastModificatedTime() \u003c startTime\n+              || candidate.getLastModificatedTime() \u003e endTime) {\n+            continue;\n+          }\n           byte[] cbuf \u003d new byte[bufferSize];\n           InputStream in \u003d null;\n           try {\n             in \u003d compressName.createDecompressionStream(\n                 new BoundedRangeFileInputStream(fsin,\n                     candidate.getStartIndex(),\n                     candidate.getFileCompressedSize()),\n                     decompressor,\n                     LogAggregationIndexedFileController.getFSInputBufferSize(\n                         conf));\n             long logLength \u003d candidate.getFileSize();\n             html.pre().__(\"\\n\\n\").__();\n             html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n             html.p().__(\"Log Upload Time: \" + Times.format(\n                 candidate.getLastModificatedTime())).__();\n             html.p().__(\"Log Length: \" + Long.toString(\n                 logLength)).__();\n             long startIndex \u003d start \u003c 0\n                 ? logLength + start : start;\n             startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n             startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n             long endLogIndex \u003d end \u003c 0\n                 ? logLength + end : end;\n             endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n             endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n             endLogIndex \u003d endLogIndex \u003c startIndex ?\n                 startIndex : endLogIndex;\n             long toRead \u003d endLogIndex - startIndex;\n             if (toRead \u003c logLength) {\n               html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n                   + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n                       $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n-                      candidate.getFileName(), \"?start\u003d0\"), \"here\").\n+                      candidate.getFileName(), \"?start\u003d0\u0026start.time\u003d\"\n+                      + startTime + \"\u0026end.time\u003d\" + endTime), \"here\").\n                       __(\" for the full log.\").__();\n             }\n             long totalSkipped \u003d 0;\n             while (totalSkipped \u003c startIndex) {\n               long ret \u003d in.skip(startIndex - totalSkipped);\n               if (ret \u003d\u003d 0) {\n                 //Read one byte\n                 int nextByte \u003d in.read();\n                 // Check if we have reached EOF\n                 if (nextByte \u003d\u003d -1) {\n                   throw new IOException(\"Premature EOF from container log\");\n                 }\n                 ret \u003d 1;\n               }\n               totalSkipped +\u003d ret;\n             }\n             int len \u003d 0;\n             int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n             PRE\u003cHamlet\u003e pre \u003d html.pre();\n \n             while (toRead \u003e 0\n                 \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n               pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n               toRead \u003d toRead - len;\n               currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n             }\n \n             pre.__();\n             foundLog \u003d true;\n           } catch (Exception ex) {\n             LOG.error(\"Error getting logs for \" + logEntity, ex);\n             continue;\n           } finally {\n             IOUtils.closeQuietly(in);\n           }\n         }\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \" + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (RuntimeException e) {\n       throw e;\n     } catch (Exception ex) {\n       html.h1().__(\"Error getting logs for \" + logEntity).__();\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    BlockParameters params \u003d verifyAndParseParameters(html);\n    if (params \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId appId \u003d params.getAppId();\n    ContainerId containerId \u003d params.getContainerId();\n    NodeId nodeId \u003d params.getNodeId();\n    String appOwner \u003d params.getAppOwner();\n    String logEntity \u003d params.getLogEntity();\n    long start \u003d params.getStartIndex();\n    long end \u003d params.getEndIndex();\n    long startTime \u003d params.getStartTime();\n    long endTime \u003d params.getEndTime();\n\n    List\u003cFileStatus\u003e nodeFiles \u003d null;\n    try {\n      nodeFiles \u003d LogAggregationUtils\n          .getRemoteNodeFileList(conf, appId, appOwner,\n              this.fileController.getRemoteRootLogDir(),\n              this.fileController.getRemoteRootLogDirSuffix());\n    } catch(Exception ex) {\n      html.h1(\"Unable to locate any logs for container \"\n          + containerId.toString());\n      LOG.error(ex.getMessage());\n      return;\n    }\n\n    Map\u003cString, Long\u003e checkSumFiles;\n    try {\n      checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    List\u003cFileStatus\u003e fileToRead;\n    try {\n      fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n          nodeId.toString(), appId);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      for (FileStatus thisNodeFile : fileToRead) {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta indexedLogsMeta \u003d null;\n        try {\n          indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n              thisNodeFile.getPath(), endIndex);\n        } catch (Exception ex) {\n          // DO NOTHING\n          LOG.warn(\"Can not load log meta from the log file:\"\n              + thisNodeFile.getPath());\n          continue;\n        }\n        if (indexedLogsMeta \u003d\u003d null) {\n          continue;\n        }\n        Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n        String user \u003d indexedLogsMeta.getUser();\n        String remoteUser \u003d request().getRemoteUser();\n        if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n          html.h1().__(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity\n              + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n              .__();\n          LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n          continue;\n        }\n        String compressAlgo \u003d indexedLogsMeta.getCompressName();\n        List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n        for (IndexedPerAggregationLogMeta logMeta\n            : indexedLogsMeta.getLogMetas()) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n              : logMeta.getLogMetas().entrySet()) {\n            for (IndexedFileLogMeta log : meta.getValue()) {\n              if (!log.getContainerId().equals(containerId.toString())) {\n                continue;\n              }\n              if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                  \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                continue;\n              }\n              candidates.add(log);\n            }\n          }\n        }\n        if (candidates.isEmpty()) {\n          continue;\n        }\n\n        Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n            compressAlgo);\n        Decompressor decompressor \u003d compressName.getDecompressor();\n        FileContext fileContext \u003d FileContext.getFileContext(\n            thisNodeFile.getPath().toUri(), conf);\n        FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n        int bufferSize \u003d 65536;\n        for (IndexedFileLogMeta candidate : candidates) {\n          if (candidate.getLastModificatedTime() \u003c startTime\n              || candidate.getLastModificatedTime() \u003e endTime) {\n            continue;\n          }\n          byte[] cbuf \u003d new byte[bufferSize];\n          InputStream in \u003d null;\n          try {\n            in \u003d compressName.createDecompressionStream(\n                new BoundedRangeFileInputStream(fsin,\n                    candidate.getStartIndex(),\n                    candidate.getFileCompressedSize()),\n                    decompressor,\n                    LogAggregationIndexedFileController.getFSInputBufferSize(\n                        conf));\n            long logLength \u003d candidate.getFileSize();\n            html.pre().__(\"\\n\\n\").__();\n            html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n            html.p().__(\"Log Upload Time: \" + Times.format(\n                candidate.getLastModificatedTime())).__();\n            html.p().__(\"Log Length: \" + Long.toString(\n                logLength)).__();\n            long startIndex \u003d start \u003c 0\n                ? logLength + start : start;\n            startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n            startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n            long endLogIndex \u003d end \u003c 0\n                ? logLength + end : end;\n            endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003c startIndex ?\n                startIndex : endLogIndex;\n            long toRead \u003d endLogIndex - startIndex;\n            if (toRead \u003c logLength) {\n              html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n                  + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n                      $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n                      candidate.getFileName(), \"?start\u003d0\u0026start.time\u003d\"\n                      + startTime + \"\u0026end.time\u003d\" + endTime), \"here\").\n                      __(\" for the full log.\").__();\n            }\n            long totalSkipped \u003d 0;\n            while (totalSkipped \u003c startIndex) {\n              long ret \u003d in.skip(startIndex - totalSkipped);\n              if (ret \u003d\u003d 0) {\n                //Read one byte\n                int nextByte \u003d in.read();\n                // Check if we have reached EOF\n                if (nextByte \u003d\u003d -1) {\n                  throw new IOException(\"Premature EOF from container log\");\n                }\n                ret \u003d 1;\n              }\n              totalSkipped +\u003d ret;\n            }\n            int len \u003d 0;\n            int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            PRE\u003cHamlet\u003e pre \u003d html.pre();\n\n            while (toRead \u003e 0\n                \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n              pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n              toRead \u003d toRead - len;\n              currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            }\n\n            pre.__();\n            foundLog \u003d true;\n          } catch (Exception ex) {\n            LOG.error(\"Error getting logs for \" + logEntity, ex);\n            continue;\n          } finally {\n            IOUtils.closeQuietly(in);\n          }\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception ex) {\n      html.h1().__(\"Error getting logs for \" + logEntity).__();\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/IndexedFileAggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "d57dba99428cbe3f3dfcec834d79f709e7529ef9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7400. Incorrect log preview displayed in jobhistory server ui. Contributed by Xuan Gong.\n",
      "commitDate": "01/11/17 2:48 PM",
      "commitName": "d57dba99428cbe3f3dfcec834d79f709e7529ef9",
      "commitAuthor": "Junping Du",
      "commitDateOld": "02/10/17 3:30 PM",
      "commitNameOld": "280080fad01304c85a9ede4d4f7b707eb36c0155",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 29.97,
      "commitsBetweenForRepo": 227,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,196 +1,196 @@\n   protected void render(Block html) {\n     BlockParameters params \u003d verifyAndParseParameters(html);\n     if (params \u003d\u003d null) {\n       return;\n     }\n \n     ApplicationId appId \u003d params.getAppId();\n     ContainerId containerId \u003d params.getContainerId();\n     NodeId nodeId \u003d params.getNodeId();\n     String appOwner \u003d params.getAppOwner();\n     String logEntity \u003d params.getLogEntity();\n     long start \u003d params.getStartIndex();\n     long end \u003d params.getEndIndex();\n \n     List\u003cFileStatus\u003e nodeFiles \u003d null;\n     try {\n       nodeFiles \u003d LogAggregationUtils\n           .getRemoteNodeFileList(conf, appId, appOwner,\n               this.fileController.getRemoteRootLogDir(),\n               this.fileController.getRemoteRootLogDirSuffix());\n     } catch(Exception ex) {\n       html.h1(\"Unable to locate any logs for container \"\n           + containerId.toString());\n       LOG.error(ex.getMessage());\n       return;\n     }\n \n     Map\u003cString, Long\u003e checkSumFiles;\n     try {\n       checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     List\u003cFileStatus\u003e fileToRead;\n     try {\n       fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n           nodeId.toString(), appId);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       for (FileStatus thisNodeFile : fileToRead) {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta indexedLogsMeta \u003d null;\n         try {\n           indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n               thisNodeFile.getPath(), endIndex);\n         } catch (Exception ex) {\n           // DO NOTHING\n           LOG.warn(\"Can not load log meta from the log file:\"\n               + thisNodeFile.getPath());\n           continue;\n         }\n         if (indexedLogsMeta \u003d\u003d null) {\n           continue;\n         }\n         Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n         String user \u003d indexedLogsMeta.getUser();\n         String remoteUser \u003d request().getRemoteUser();\n         if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n           html.h1().__(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity\n               + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n               .__();\n           LOG.error(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity);\n           continue;\n         }\n         String compressAlgo \u003d indexedLogsMeta.getCompressName();\n         List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n         for (IndexedPerAggregationLogMeta logMeta\n             : indexedLogsMeta.getLogMetas()) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n               : logMeta.getLogMetas().entrySet()) {\n             for (IndexedFileLogMeta log : meta.getValue()) {\n               if (!log.getContainerId().equals(containerId.toString())) {\n                 continue;\n               }\n               if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                   \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                 continue;\n               }\n               candidates.add(log);\n             }\n           }\n         }\n         if (candidates.isEmpty()) {\n           continue;\n         }\n \n         Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n             compressAlgo);\n         Decompressor decompressor \u003d compressName.getDecompressor();\n         FileContext fileContext \u003d FileContext.getFileContext(\n             thisNodeFile.getPath().toUri(), conf);\n         FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n         int bufferSize \u003d 65536;\n         for (IndexedFileLogMeta candidate : candidates) {\n           byte[] cbuf \u003d new byte[bufferSize];\n           InputStream in \u003d null;\n           try {\n             in \u003d compressName.createDecompressionStream(\n                 new BoundedRangeFileInputStream(fsin,\n                     candidate.getStartIndex(),\n                     candidate.getFileCompressedSize()),\n                     decompressor,\n                     LogAggregationIndexedFileController.getFSInputBufferSize(\n                         conf));\n             long logLength \u003d candidate.getFileSize();\n             html.pre().__(\"\\n\\n\").__();\n             html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n             html.p().__(\"Log Upload Time: \" + Times.format(\n                 candidate.getLastModificatedTime())).__();\n             html.p().__(\"Log Length: \" + Long.toString(\n                 logLength)).__();\n             long startIndex \u003d start \u003c 0\n                 ? logLength + start : start;\n             startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n             startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n             long endLogIndex \u003d end \u003c 0\n                 ? logLength + end : end;\n             endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n             endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n             endLogIndex \u003d endLogIndex \u003c startIndex ?\n                 startIndex : endLogIndex;\n             long toRead \u003d endLogIndex - startIndex;\n             if (toRead \u003c logLength) {\n               html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n                   + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n                       $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n                       candidate.getFileName(), \"?start\u003d0\"), \"here\").\n                       __(\" for the full log.\").__();\n             }\n             long totalSkipped \u003d 0;\n-            while (totalSkipped \u003c start) {\n-              long ret \u003d in.skip(start - totalSkipped);\n+            while (totalSkipped \u003c startIndex) {\n+              long ret \u003d in.skip(startIndex - totalSkipped);\n               if (ret \u003d\u003d 0) {\n                 //Read one byte\n                 int nextByte \u003d in.read();\n                 // Check if we have reached EOF\n                 if (nextByte \u003d\u003d -1) {\n                   throw new IOException(\"Premature EOF from container log\");\n                 }\n                 ret \u003d 1;\n               }\n               totalSkipped +\u003d ret;\n             }\n             int len \u003d 0;\n             int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n             PRE\u003cHamlet\u003e pre \u003d html.pre();\n \n             while (toRead \u003e 0\n                 \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n               pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n               toRead \u003d toRead - len;\n               currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n             }\n \n             pre.__();\n             foundLog \u003d true;\n           } catch (Exception ex) {\n             LOG.error(\"Error getting logs for \" + logEntity, ex);\n             continue;\n           } finally {\n             IOUtils.closeQuietly(in);\n           }\n         }\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \" + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (RuntimeException e) {\n       throw e;\n     } catch (Exception ex) {\n       html.h1().__(\"Error getting logs for \" + logEntity).__();\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    BlockParameters params \u003d verifyAndParseParameters(html);\n    if (params \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId appId \u003d params.getAppId();\n    ContainerId containerId \u003d params.getContainerId();\n    NodeId nodeId \u003d params.getNodeId();\n    String appOwner \u003d params.getAppOwner();\n    String logEntity \u003d params.getLogEntity();\n    long start \u003d params.getStartIndex();\n    long end \u003d params.getEndIndex();\n\n    List\u003cFileStatus\u003e nodeFiles \u003d null;\n    try {\n      nodeFiles \u003d LogAggregationUtils\n          .getRemoteNodeFileList(conf, appId, appOwner,\n              this.fileController.getRemoteRootLogDir(),\n              this.fileController.getRemoteRootLogDirSuffix());\n    } catch(Exception ex) {\n      html.h1(\"Unable to locate any logs for container \"\n          + containerId.toString());\n      LOG.error(ex.getMessage());\n      return;\n    }\n\n    Map\u003cString, Long\u003e checkSumFiles;\n    try {\n      checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    List\u003cFileStatus\u003e fileToRead;\n    try {\n      fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n          nodeId.toString(), appId);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      for (FileStatus thisNodeFile : fileToRead) {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta indexedLogsMeta \u003d null;\n        try {\n          indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n              thisNodeFile.getPath(), endIndex);\n        } catch (Exception ex) {\n          // DO NOTHING\n          LOG.warn(\"Can not load log meta from the log file:\"\n              + thisNodeFile.getPath());\n          continue;\n        }\n        if (indexedLogsMeta \u003d\u003d null) {\n          continue;\n        }\n        Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n        String user \u003d indexedLogsMeta.getUser();\n        String remoteUser \u003d request().getRemoteUser();\n        if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n          html.h1().__(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity\n              + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n              .__();\n          LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n          continue;\n        }\n        String compressAlgo \u003d indexedLogsMeta.getCompressName();\n        List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n        for (IndexedPerAggregationLogMeta logMeta\n            : indexedLogsMeta.getLogMetas()) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n              : logMeta.getLogMetas().entrySet()) {\n            for (IndexedFileLogMeta log : meta.getValue()) {\n              if (!log.getContainerId().equals(containerId.toString())) {\n                continue;\n              }\n              if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                  \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                continue;\n              }\n              candidates.add(log);\n            }\n          }\n        }\n        if (candidates.isEmpty()) {\n          continue;\n        }\n\n        Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n            compressAlgo);\n        Decompressor decompressor \u003d compressName.getDecompressor();\n        FileContext fileContext \u003d FileContext.getFileContext(\n            thisNodeFile.getPath().toUri(), conf);\n        FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n        int bufferSize \u003d 65536;\n        for (IndexedFileLogMeta candidate : candidates) {\n          byte[] cbuf \u003d new byte[bufferSize];\n          InputStream in \u003d null;\n          try {\n            in \u003d compressName.createDecompressionStream(\n                new BoundedRangeFileInputStream(fsin,\n                    candidate.getStartIndex(),\n                    candidate.getFileCompressedSize()),\n                    decompressor,\n                    LogAggregationIndexedFileController.getFSInputBufferSize(\n                        conf));\n            long logLength \u003d candidate.getFileSize();\n            html.pre().__(\"\\n\\n\").__();\n            html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n            html.p().__(\"Log Upload Time: \" + Times.format(\n                candidate.getLastModificatedTime())).__();\n            html.p().__(\"Log Length: \" + Long.toString(\n                logLength)).__();\n            long startIndex \u003d start \u003c 0\n                ? logLength + start : start;\n            startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n            startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n            long endLogIndex \u003d end \u003c 0\n                ? logLength + end : end;\n            endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003c startIndex ?\n                startIndex : endLogIndex;\n            long toRead \u003d endLogIndex - startIndex;\n            if (toRead \u003c logLength) {\n              html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n                  + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n                      $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n                      candidate.getFileName(), \"?start\u003d0\"), \"here\").\n                      __(\" for the full log.\").__();\n            }\n            long totalSkipped \u003d 0;\n            while (totalSkipped \u003c startIndex) {\n              long ret \u003d in.skip(startIndex - totalSkipped);\n              if (ret \u003d\u003d 0) {\n                //Read one byte\n                int nextByte \u003d in.read();\n                // Check if we have reached EOF\n                if (nextByte \u003d\u003d -1) {\n                  throw new IOException(\"Premature EOF from container log\");\n                }\n                ret \u003d 1;\n              }\n              totalSkipped +\u003d ret;\n            }\n            int len \u003d 0;\n            int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            PRE\u003cHamlet\u003e pre \u003d html.pre();\n\n            while (toRead \u003e 0\n                \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n              pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n              toRead \u003d toRead - len;\n              currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            }\n\n            pre.__();\n            foundLog \u003d true;\n          } catch (Exception ex) {\n            LOG.error(\"Error getting logs for \" + logEntity, ex);\n            continue;\n          } finally {\n            IOUtils.closeQuietly(in);\n          }\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception ex) {\n      html.h1().__(\"Error getting logs for \" + logEntity).__();\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/IndexedFileAggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "280080fad01304c85a9ede4d4f7b707eb36c0155": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7259. Add size-based rolling policy to LogAggregationIndexedFileController. (xgong via wangda)\n\nChange-Id: Ifaf82c0aee6b73b9b6ebf103aa72e131e3942f31\n",
      "commitDate": "02/10/17 3:30 PM",
      "commitName": "280080fad01304c85a9ede4d4f7b707eb36c0155",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/09/17 3:16 PM",
      "commitNameOld": "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 24.01,
      "commitsBetweenForRepo": 213,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,196 @@\n   protected void render(Block html) {\n     BlockParameters params \u003d verifyAndParseParameters(html);\n     if (params \u003d\u003d null) {\n       return;\n     }\n \n     ApplicationId appId \u003d params.getAppId();\n     ContainerId containerId \u003d params.getContainerId();\n     NodeId nodeId \u003d params.getNodeId();\n     String appOwner \u003d params.getAppOwner();\n     String logEntity \u003d params.getLogEntity();\n     long start \u003d params.getStartIndex();\n     long end \u003d params.getEndIndex();\n \n     List\u003cFileStatus\u003e nodeFiles \u003d null;\n     try {\n       nodeFiles \u003d LogAggregationUtils\n           .getRemoteNodeFileList(conf, appId, appOwner,\n               this.fileController.getRemoteRootLogDir(),\n               this.fileController.getRemoteRootLogDirSuffix());\n     } catch(Exception ex) {\n       html.h1(\"Unable to locate any logs for container \"\n           + containerId.toString());\n       LOG.error(ex.getMessage());\n       return;\n     }\n \n-    Map\u003cString, FileStatus\u003e checkSumFiles;\n+    Map\u003cString, Long\u003e checkSumFiles;\n     try {\n-      checkSumFiles \u003d fileController.filterFiles(nodeFiles,\n-          LogAggregationIndexedFileController.CHECK_SUM_FILE_SUFFIX);\n+      checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     List\u003cFileStatus\u003e fileToRead;\n     try {\n       fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n           nodeId.toString(), appId);\n     } catch (IOException ex) {\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n       html.h1(\"Error getting logs for \" + logEntity);\n       return;\n     }\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       for (FileStatus thisNodeFile : fileToRead) {\n-        FileStatus checkSum \u003d fileController.getAllChecksumFiles(\n-            checkSumFiles, thisNodeFile.getPath().getName());\n+        Long checkSumIndex \u003d checkSumFiles.get(\n+            thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n-        if (checkSum !\u003d null) {\n-          endIndex \u003d fileController.loadIndexedLogsCheckSum(\n-             checkSum.getPath());\n+        if (checkSumIndex !\u003d null) {\n+          endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta indexedLogsMeta \u003d null;\n         try {\n           indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n               thisNodeFile.getPath(), endIndex);\n         } catch (Exception ex) {\n           // DO NOTHING\n           LOG.warn(\"Can not load log meta from the log file:\"\n               + thisNodeFile.getPath());\n           continue;\n         }\n         if (indexedLogsMeta \u003d\u003d null) {\n           continue;\n         }\n         Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n         String user \u003d indexedLogsMeta.getUser();\n         String remoteUser \u003d request().getRemoteUser();\n         if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n           html.h1().__(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity\n               + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n               .__();\n           LOG.error(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity);\n           continue;\n         }\n         String compressAlgo \u003d indexedLogsMeta.getCompressName();\n         List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n         for (IndexedPerAggregationLogMeta logMeta\n             : indexedLogsMeta.getLogMetas()) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n               : logMeta.getLogMetas().entrySet()) {\n             for (IndexedFileLogMeta log : meta.getValue()) {\n               if (!log.getContainerId().equals(containerId.toString())) {\n                 continue;\n               }\n               if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                   \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                 continue;\n               }\n               candidates.add(log);\n             }\n           }\n         }\n         if (candidates.isEmpty()) {\n           continue;\n         }\n \n         Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n             compressAlgo);\n         Decompressor decompressor \u003d compressName.getDecompressor();\n         FileContext fileContext \u003d FileContext.getFileContext(\n             thisNodeFile.getPath().toUri(), conf);\n         FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n         int bufferSize \u003d 65536;\n         for (IndexedFileLogMeta candidate : candidates) {\n           byte[] cbuf \u003d new byte[bufferSize];\n           InputStream in \u003d null;\n           try {\n             in \u003d compressName.createDecompressionStream(\n                 new BoundedRangeFileInputStream(fsin,\n                     candidate.getStartIndex(),\n                     candidate.getFileCompressedSize()),\n                     decompressor,\n                     LogAggregationIndexedFileController.getFSInputBufferSize(\n                         conf));\n             long logLength \u003d candidate.getFileSize();\n             html.pre().__(\"\\n\\n\").__();\n             html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n             html.p().__(\"Log Upload Time: \" + Times.format(\n                 candidate.getLastModificatedTime())).__();\n             html.p().__(\"Log Length: \" + Long.toString(\n                 logLength)).__();\n             long startIndex \u003d start \u003c 0\n                 ? logLength + start : start;\n             startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n             startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n             long endLogIndex \u003d end \u003c 0\n                 ? logLength + end : end;\n             endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n             endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n             endLogIndex \u003d endLogIndex \u003c startIndex ?\n                 startIndex : endLogIndex;\n             long toRead \u003d endLogIndex - startIndex;\n             if (toRead \u003c logLength) {\n               html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n                   + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n                       $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n                       candidate.getFileName(), \"?start\u003d0\"), \"here\").\n                       __(\" for the full log.\").__();\n             }\n             long totalSkipped \u003d 0;\n             while (totalSkipped \u003c start) {\n               long ret \u003d in.skip(start - totalSkipped);\n               if (ret \u003d\u003d 0) {\n                 //Read one byte\n                 int nextByte \u003d in.read();\n                 // Check if we have reached EOF\n                 if (nextByte \u003d\u003d -1) {\n                   throw new IOException(\"Premature EOF from container log\");\n                 }\n                 ret \u003d 1;\n               }\n               totalSkipped +\u003d ret;\n             }\n             int len \u003d 0;\n             int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n             PRE\u003cHamlet\u003e pre \u003d html.pre();\n \n             while (toRead \u003e 0\n                 \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n               pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n               toRead \u003d toRead - len;\n               currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n             }\n \n             pre.__();\n             foundLog \u003d true;\n           } catch (Exception ex) {\n             LOG.error(\"Error getting logs for \" + logEntity, ex);\n             continue;\n           } finally {\n             IOUtils.closeQuietly(in);\n           }\n         }\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \" + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (RuntimeException e) {\n       throw e;\n     } catch (Exception ex) {\n       html.h1().__(\"Error getting logs for \" + logEntity).__();\n       LOG.error(\"Error getting logs for \" + logEntity, ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    BlockParameters params \u003d verifyAndParseParameters(html);\n    if (params \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId appId \u003d params.getAppId();\n    ContainerId containerId \u003d params.getContainerId();\n    NodeId nodeId \u003d params.getNodeId();\n    String appOwner \u003d params.getAppOwner();\n    String logEntity \u003d params.getLogEntity();\n    long start \u003d params.getStartIndex();\n    long end \u003d params.getEndIndex();\n\n    List\u003cFileStatus\u003e nodeFiles \u003d null;\n    try {\n      nodeFiles \u003d LogAggregationUtils\n          .getRemoteNodeFileList(conf, appId, appOwner,\n              this.fileController.getRemoteRootLogDir(),\n              this.fileController.getRemoteRootLogDirSuffix());\n    } catch(Exception ex) {\n      html.h1(\"Unable to locate any logs for container \"\n          + containerId.toString());\n      LOG.error(ex.getMessage());\n      return;\n    }\n\n    Map\u003cString, Long\u003e checkSumFiles;\n    try {\n      checkSumFiles \u003d fileController.parseCheckSumFiles(nodeFiles);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    List\u003cFileStatus\u003e fileToRead;\n    try {\n      fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n          nodeId.toString(), appId);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      for (FileStatus thisNodeFile : fileToRead) {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta indexedLogsMeta \u003d null;\n        try {\n          indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n              thisNodeFile.getPath(), endIndex);\n        } catch (Exception ex) {\n          // DO NOTHING\n          LOG.warn(\"Can not load log meta from the log file:\"\n              + thisNodeFile.getPath());\n          continue;\n        }\n        if (indexedLogsMeta \u003d\u003d null) {\n          continue;\n        }\n        Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n        String user \u003d indexedLogsMeta.getUser();\n        String remoteUser \u003d request().getRemoteUser();\n        if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n          html.h1().__(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity\n              + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n              .__();\n          LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n          continue;\n        }\n        String compressAlgo \u003d indexedLogsMeta.getCompressName();\n        List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n        for (IndexedPerAggregationLogMeta logMeta\n            : indexedLogsMeta.getLogMetas()) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n              : logMeta.getLogMetas().entrySet()) {\n            for (IndexedFileLogMeta log : meta.getValue()) {\n              if (!log.getContainerId().equals(containerId.toString())) {\n                continue;\n              }\n              if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                  \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                continue;\n              }\n              candidates.add(log);\n            }\n          }\n        }\n        if (candidates.isEmpty()) {\n          continue;\n        }\n\n        Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n            compressAlgo);\n        Decompressor decompressor \u003d compressName.getDecompressor();\n        FileContext fileContext \u003d FileContext.getFileContext(\n            thisNodeFile.getPath().toUri(), conf);\n        FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n        int bufferSize \u003d 65536;\n        for (IndexedFileLogMeta candidate : candidates) {\n          byte[] cbuf \u003d new byte[bufferSize];\n          InputStream in \u003d null;\n          try {\n            in \u003d compressName.createDecompressionStream(\n                new BoundedRangeFileInputStream(fsin,\n                    candidate.getStartIndex(),\n                    candidate.getFileCompressedSize()),\n                    decompressor,\n                    LogAggregationIndexedFileController.getFSInputBufferSize(\n                        conf));\n            long logLength \u003d candidate.getFileSize();\n            html.pre().__(\"\\n\\n\").__();\n            html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n            html.p().__(\"Log Upload Time: \" + Times.format(\n                candidate.getLastModificatedTime())).__();\n            html.p().__(\"Log Length: \" + Long.toString(\n                logLength)).__();\n            long startIndex \u003d start \u003c 0\n                ? logLength + start : start;\n            startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n            startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n            long endLogIndex \u003d end \u003c 0\n                ? logLength + end : end;\n            endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003c startIndex ?\n                startIndex : endLogIndex;\n            long toRead \u003d endLogIndex - startIndex;\n            if (toRead \u003c logLength) {\n              html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n                  + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n                      $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n                      candidate.getFileName(), \"?start\u003d0\"), \"here\").\n                      __(\" for the full log.\").__();\n            }\n            long totalSkipped \u003d 0;\n            while (totalSkipped \u003c start) {\n              long ret \u003d in.skip(start - totalSkipped);\n              if (ret \u003d\u003d 0) {\n                //Read one byte\n                int nextByte \u003d in.read();\n                // Check if we have reached EOF\n                if (nextByte \u003d\u003d -1) {\n                  throw new IOException(\"Premature EOF from container log\");\n                }\n                ret \u003d 1;\n              }\n              totalSkipped +\u003d ret;\n            }\n            int len \u003d 0;\n            int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            PRE\u003cHamlet\u003e pre \u003d html.pre();\n\n            while (toRead \u003e 0\n                \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n              pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n              toRead \u003d toRead - len;\n              currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            }\n\n            pre.__();\n            foundLog \u003d true;\n          } catch (Exception ex) {\n            LOG.error(\"Error getting logs for \" + logEntity, ex);\n            continue;\n          } finally {\n            IOUtils.closeQuietly(in);\n          }\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception ex) {\n      html.h1().__(\"Error getting logs for \" + logEntity).__();\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/IndexedFileAggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7072. Add a new log aggregation file format controller. Contributed by Xuan Gong.\n",
      "commitDate": "08/09/17 3:16 PM",
      "commitName": "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,198 @@\n+  protected void render(Block html) {\n+    BlockParameters params \u003d verifyAndParseParameters(html);\n+    if (params \u003d\u003d null) {\n+      return;\n+    }\n+\n+    ApplicationId appId \u003d params.getAppId();\n+    ContainerId containerId \u003d params.getContainerId();\n+    NodeId nodeId \u003d params.getNodeId();\n+    String appOwner \u003d params.getAppOwner();\n+    String logEntity \u003d params.getLogEntity();\n+    long start \u003d params.getStartIndex();\n+    long end \u003d params.getEndIndex();\n+\n+    List\u003cFileStatus\u003e nodeFiles \u003d null;\n+    try {\n+      nodeFiles \u003d LogAggregationUtils\n+          .getRemoteNodeFileList(conf, appId, appOwner,\n+              this.fileController.getRemoteRootLogDir(),\n+              this.fileController.getRemoteRootLogDirSuffix());\n+    } catch(Exception ex) {\n+      html.h1(\"Unable to locate any logs for container \"\n+          + containerId.toString());\n+      LOG.error(ex.getMessage());\n+      return;\n+    }\n+\n+    Map\u003cString, FileStatus\u003e checkSumFiles;\n+    try {\n+      checkSumFiles \u003d fileController.filterFiles(nodeFiles,\n+          LogAggregationIndexedFileController.CHECK_SUM_FILE_SUFFIX);\n+    } catch (IOException ex) {\n+      LOG.error(\"Error getting logs for \" + logEntity, ex);\n+      html.h1(\"Error getting logs for \" + logEntity);\n+      return;\n+    }\n+\n+    List\u003cFileStatus\u003e fileToRead;\n+    try {\n+      fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n+          nodeId.toString(), appId);\n+    } catch (IOException ex) {\n+      LOG.error(\"Error getting logs for \" + logEntity, ex);\n+      html.h1(\"Error getting logs for \" + logEntity);\n+      return;\n+    }\n+\n+    boolean foundLog \u003d false;\n+    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n+    try {\n+      for (FileStatus thisNodeFile : fileToRead) {\n+        FileStatus checkSum \u003d fileController.getAllChecksumFiles(\n+            checkSumFiles, thisNodeFile.getPath().getName());\n+        long endIndex \u003d -1;\n+        if (checkSum !\u003d null) {\n+          endIndex \u003d fileController.loadIndexedLogsCheckSum(\n+             checkSum.getPath());\n+        }\n+        IndexedLogsMeta indexedLogsMeta \u003d null;\n+        try {\n+          indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n+              thisNodeFile.getPath(), endIndex);\n+        } catch (Exception ex) {\n+          // DO NOTHING\n+          LOG.warn(\"Can not load log meta from the log file:\"\n+              + thisNodeFile.getPath());\n+          continue;\n+        }\n+        if (indexedLogsMeta \u003d\u003d null) {\n+          continue;\n+        }\n+        Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n+        String user \u003d indexedLogsMeta.getUser();\n+        String remoteUser \u003d request().getRemoteUser();\n+        if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n+          html.h1().__(\"User [\" + remoteUser\n+              + \"] is not authorized to view the logs for \" + logEntity\n+              + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n+              .__();\n+          LOG.error(\"User [\" + remoteUser\n+              + \"] is not authorized to view the logs for \" + logEntity);\n+          continue;\n+        }\n+        String compressAlgo \u003d indexedLogsMeta.getCompressName();\n+        List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n+        for (IndexedPerAggregationLogMeta logMeta\n+            : indexedLogsMeta.getLogMetas()) {\n+          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n+              : logMeta.getLogMetas().entrySet()) {\n+            for (IndexedFileLogMeta log : meta.getValue()) {\n+              if (!log.getContainerId().equals(containerId.toString())) {\n+                continue;\n+              }\n+              if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n+                  \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n+                continue;\n+              }\n+              candidates.add(log);\n+            }\n+          }\n+        }\n+        if (candidates.isEmpty()) {\n+          continue;\n+        }\n+\n+        Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n+            compressAlgo);\n+        Decompressor decompressor \u003d compressName.getDecompressor();\n+        FileContext fileContext \u003d FileContext.getFileContext(\n+            thisNodeFile.getPath().toUri(), conf);\n+        FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n+        int bufferSize \u003d 65536;\n+        for (IndexedFileLogMeta candidate : candidates) {\n+          byte[] cbuf \u003d new byte[bufferSize];\n+          InputStream in \u003d null;\n+          try {\n+            in \u003d compressName.createDecompressionStream(\n+                new BoundedRangeFileInputStream(fsin,\n+                    candidate.getStartIndex(),\n+                    candidate.getFileCompressedSize()),\n+                    decompressor,\n+                    LogAggregationIndexedFileController.getFSInputBufferSize(\n+                        conf));\n+            long logLength \u003d candidate.getFileSize();\n+            html.pre().__(\"\\n\\n\").__();\n+            html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n+            html.p().__(\"Log Upload Time: \" + Times.format(\n+                candidate.getLastModificatedTime())).__();\n+            html.p().__(\"Log Length: \" + Long.toString(\n+                logLength)).__();\n+            long startIndex \u003d start \u003c 0\n+                ? logLength + start : start;\n+            startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n+            startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n+            long endLogIndex \u003d end \u003c 0\n+                ? logLength + end : end;\n+            endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n+            endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n+            endLogIndex \u003d endLogIndex \u003c startIndex ?\n+                startIndex : endLogIndex;\n+            long toRead \u003d endLogIndex - startIndex;\n+            if (toRead \u003c logLength) {\n+              html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n+                  + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n+                      $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n+                      candidate.getFileName(), \"?start\u003d0\"), \"here\").\n+                      __(\" for the full log.\").__();\n+            }\n+            long totalSkipped \u003d 0;\n+            while (totalSkipped \u003c start) {\n+              long ret \u003d in.skip(start - totalSkipped);\n+              if (ret \u003d\u003d 0) {\n+                //Read one byte\n+                int nextByte \u003d in.read();\n+                // Check if we have reached EOF\n+                if (nextByte \u003d\u003d -1) {\n+                  throw new IOException(\"Premature EOF from container log\");\n+                }\n+                ret \u003d 1;\n+              }\n+              totalSkipped +\u003d ret;\n+            }\n+            int len \u003d 0;\n+            int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n+            PRE\u003cHamlet\u003e pre \u003d html.pre();\n+\n+            while (toRead \u003e 0\n+                \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n+              pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n+              toRead \u003d toRead - len;\n+              currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n+            }\n+\n+            pre.__();\n+            foundLog \u003d true;\n+          } catch (Exception ex) {\n+            LOG.error(\"Error getting logs for \" + logEntity, ex);\n+            continue;\n+          } finally {\n+            IOUtils.closeQuietly(in);\n+          }\n+        }\n+      }\n+      if (!foundLog) {\n+        if (desiredLogType.isEmpty()) {\n+          html.h1(\"No logs available for container \" + containerId.toString());\n+        } else {\n+          html.h1(\"Unable to locate \u0027\" + desiredLogType\n+              + \"\u0027 log for container \" + containerId.toString());\n+        }\n+      }\n+    } catch (RuntimeException e) {\n+      throw e;\n+    } catch (Exception ex) {\n+      html.h1().__(\"Error getting logs for \" + logEntity).__();\n+      LOG.error(\"Error getting logs for \" + logEntity, ex);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    BlockParameters params \u003d verifyAndParseParameters(html);\n    if (params \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId appId \u003d params.getAppId();\n    ContainerId containerId \u003d params.getContainerId();\n    NodeId nodeId \u003d params.getNodeId();\n    String appOwner \u003d params.getAppOwner();\n    String logEntity \u003d params.getLogEntity();\n    long start \u003d params.getStartIndex();\n    long end \u003d params.getEndIndex();\n\n    List\u003cFileStatus\u003e nodeFiles \u003d null;\n    try {\n      nodeFiles \u003d LogAggregationUtils\n          .getRemoteNodeFileList(conf, appId, appOwner,\n              this.fileController.getRemoteRootLogDir(),\n              this.fileController.getRemoteRootLogDirSuffix());\n    } catch(Exception ex) {\n      html.h1(\"Unable to locate any logs for container \"\n          + containerId.toString());\n      LOG.error(ex.getMessage());\n      return;\n    }\n\n    Map\u003cString, FileStatus\u003e checkSumFiles;\n    try {\n      checkSumFiles \u003d fileController.filterFiles(nodeFiles,\n          LogAggregationIndexedFileController.CHECK_SUM_FILE_SUFFIX);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    List\u003cFileStatus\u003e fileToRead;\n    try {\n      fileToRead \u003d fileController.getNodeLogFileToRead(nodeFiles,\n          nodeId.toString(), appId);\n    } catch (IOException ex) {\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n      html.h1(\"Error getting logs for \" + logEntity);\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      for (FileStatus thisNodeFile : fileToRead) {\n        FileStatus checkSum \u003d fileController.getAllChecksumFiles(\n            checkSumFiles, thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSum !\u003d null) {\n          endIndex \u003d fileController.loadIndexedLogsCheckSum(\n             checkSum.getPath());\n        }\n        IndexedLogsMeta indexedLogsMeta \u003d null;\n        try {\n          indexedLogsMeta \u003d fileController.loadIndexedLogsMeta(\n              thisNodeFile.getPath(), endIndex);\n        } catch (Exception ex) {\n          // DO NOTHING\n          LOG.warn(\"Can not load log meta from the log file:\"\n              + thisNodeFile.getPath());\n          continue;\n        }\n        if (indexedLogsMeta \u003d\u003d null) {\n          continue;\n        }\n        Map\u003cApplicationAccessType, String\u003e appAcls \u003d indexedLogsMeta.getAcls();\n        String user \u003d indexedLogsMeta.getUser();\n        String remoteUser \u003d request().getRemoteUser();\n        if (!checkAcls(conf, appId, user, appAcls, remoteUser)) {\n          html.h1().__(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity\n              + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n              .__();\n          LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n          continue;\n        }\n        String compressAlgo \u003d indexedLogsMeta.getCompressName();\n        List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n        for (IndexedPerAggregationLogMeta logMeta\n            : indexedLogsMeta.getLogMetas()) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n              : logMeta.getLogMetas().entrySet()) {\n            for (IndexedFileLogMeta log : meta.getValue()) {\n              if (!log.getContainerId().equals(containerId.toString())) {\n                continue;\n              }\n              if (desiredLogType !\u003d null \u0026\u0026 !desiredLogType.isEmpty()\n                  \u0026\u0026 !desiredLogType.equals(log.getFileName())) {\n                continue;\n              }\n              candidates.add(log);\n            }\n          }\n        }\n        if (candidates.isEmpty()) {\n          continue;\n        }\n\n        Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n            compressAlgo);\n        Decompressor decompressor \u003d compressName.getDecompressor();\n        FileContext fileContext \u003d FileContext.getFileContext(\n            thisNodeFile.getPath().toUri(), conf);\n        FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n        int bufferSize \u003d 65536;\n        for (IndexedFileLogMeta candidate : candidates) {\n          byte[] cbuf \u003d new byte[bufferSize];\n          InputStream in \u003d null;\n          try {\n            in \u003d compressName.createDecompressionStream(\n                new BoundedRangeFileInputStream(fsin,\n                    candidate.getStartIndex(),\n                    candidate.getFileCompressedSize()),\n                    decompressor,\n                    LogAggregationIndexedFileController.getFSInputBufferSize(\n                        conf));\n            long logLength \u003d candidate.getFileSize();\n            html.pre().__(\"\\n\\n\").__();\n            html.p().__(\"Log Type: \" + candidate.getFileName()).__();\n            html.p().__(\"Log Upload Time: \" + Times.format(\n                candidate.getLastModificatedTime())).__();\n            html.p().__(\"Log Length: \" + Long.toString(\n                logLength)).__();\n            long startIndex \u003d start \u003c 0\n                ? logLength + start : start;\n            startIndex \u003d startIndex \u003c 0 ? 0 : startIndex;\n            startIndex \u003d startIndex \u003e logLength ? logLength : startIndex;\n            long endLogIndex \u003d end \u003c 0\n                ? logLength + end : end;\n            endLogIndex \u003d endLogIndex \u003c 0 ? 0 : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003e logLength ? logLength : endLogIndex;\n            endLogIndex \u003d endLogIndex \u003c startIndex ?\n                startIndex : endLogIndex;\n            long toRead \u003d endLogIndex - startIndex;\n            if (toRead \u003c logLength) {\n              html.p().__(\"Showing \" + toRead + \" bytes of \" + logLength\n                  + \" total. Click \").a(url(\"logs\", $(NM_NODENAME),\n                      $(CONTAINER_ID), $(ENTITY_STRING), $(APP_OWNER),\n                      candidate.getFileName(), \"?start\u003d0\"), \"here\").\n                      __(\" for the full log.\").__();\n            }\n            long totalSkipped \u003d 0;\n            while (totalSkipped \u003c start) {\n              long ret \u003d in.skip(start - totalSkipped);\n              if (ret \u003d\u003d 0) {\n                //Read one byte\n                int nextByte \u003d in.read();\n                // Check if we have reached EOF\n                if (nextByte \u003d\u003d -1) {\n                  throw new IOException(\"Premature EOF from container log\");\n                }\n                ret \u003d 1;\n              }\n              totalSkipped +\u003d ret;\n            }\n            int len \u003d 0;\n            int currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            PRE\u003cHamlet\u003e pre \u003d html.pre();\n\n            while (toRead \u003e 0\n                \u0026\u0026 (len \u003d in.read(cbuf, 0, currentToRead)) \u003e 0) {\n              pre.__(new String(cbuf, 0, len, Charset.forName(\"UTF-8\")));\n              toRead \u003d toRead - len;\n              currentToRead \u003d toRead \u003e bufferSize ? bufferSize : (int) toRead;\n            }\n\n            pre.__();\n            foundLog \u003d true;\n          } catch (Exception ex) {\n            LOG.error(\"Error getting logs for \" + logEntity, ex);\n            continue;\n          } finally {\n            IOUtils.closeQuietly(in);\n          }\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception ex) {\n      html.h1().__(\"Error getting logs for \" + logEntity).__();\n      LOG.error(\"Error getting logs for \" + logEntity, ex);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/IndexedFileAggregatedLogsBlock.java"
    }
  }
}