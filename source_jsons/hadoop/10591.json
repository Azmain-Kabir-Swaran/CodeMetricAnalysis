{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockRecoveryWorker.java",
  "functionName": "syncBlock",
  "functionId": "syncBlock___syncList-List__BlockRecord__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockRecoveryWorker.java",
  "functionStartLine": 192,
  "functionEndLine": 336,
  "numCommitsSeen": 264,
  "timeTaken": 12966,
  "changeHistory": [
    "87eeb26e7200fa3be0ca62ebf163985b58ad309e",
    "451265a83d8798624ae2a144bc58fa41db826704",
    "21bc85558718490e558c5b3bdb44c9c64eada994",
    "61ab0440f7eaff0f631cbae0378403912f88d7ad",
    "b64242c0d2cabd225a8fb7d25fed449d252e4fa1",
    "e287e7d14b838a866ba03d895fa35819999d7c09",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f",
    "7e9358feb326d48b8c4f00249e7af5023cebd2e2",
    "6d4a0915676b8185a4727a10fcfeb40aa24cacc5",
    "6326605acb5a5bf48d994278c9d3a39733679e81",
    "978a8050e28b2afb193a3e00d82a8475fa4d2428",
    "c14912785d22734d735b5c4f8638b57dff009a97",
    "8134b1c8702d7d6b3994c73b34afc7f8ee33ac6e",
    "3cffe34177c72ea67194c3b0aaf0ddbf67ff3a0c",
    "1e346aa829519f8a2aa830e76d9856f914861805",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "87eeb26e7200fa3be0ca62ebf163985b58ad309e": "Ybodychange",
    "451265a83d8798624ae2a144bc58fa41db826704": "Ybodychange",
    "21bc85558718490e558c5b3bdb44c9c64eada994": "Ybodychange",
    "61ab0440f7eaff0f631cbae0378403912f88d7ad": "Ybodychange",
    "b64242c0d2cabd225a8fb7d25fed449d252e4fa1": "Ybodychange",
    "e287e7d14b838a866ba03d895fa35819999d7c09": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": "Ybodychange",
    "7e9358feb326d48b8c4f00249e7af5023cebd2e2": "Ybodychange",
    "6d4a0915676b8185a4727a10fcfeb40aa24cacc5": "Ybodychange",
    "6326605acb5a5bf48d994278c9d3a39733679e81": "Ybodychange",
    "978a8050e28b2afb193a3e00d82a8475fa4d2428": "Ybodychange",
    "c14912785d22734d735b5c4f8638b57dff009a97": "Ybodychange",
    "8134b1c8702d7d6b3994c73b34afc7f8ee33ac6e": "Ybodychange",
    "3cffe34177c72ea67194c3b0aaf0ddbf67ff3a0c": "Ybodychange",
    "1e346aa829519f8a2aa830e76d9856f914861805": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "87eeb26e7200fa3be0ca62ebf163985b58ad309e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13663. Should throw exception when incorrect block size is set. Contributed by Shweta.\n",
      "commitDate": "12/07/18 8:24 PM",
      "commitName": "87eeb26e7200fa3be0ca62ebf163985b58ad309e",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "26/02/18 8:28 AM",
      "commitNameOld": "451265a83d8798624ae2a144bc58fa41db826704",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 136.46,
      "commitsBetweenForRepo": 1608,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,145 @@\n     void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n       DatanodeProtocolClientSideTranslatorPB nn \u003d\n           getActiveNamenodeForBP(block.getBlockPoolId());\n \n       boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n       long blockId \u003d (isTruncateRecovery) ?\n           rBlock.getNewBlock().getBlockId() : block.getBlockId();\n \n       LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}),\"\n               + \" isTruncateRecovery\u003d{}, syncList\u003d{}\", block,\n           block.getNumBytes(), isTruncateRecovery, syncList);\n \n       // syncList.isEmpty() means that all data-nodes do not have the block\n       // or their replicas have 0 length.\n       // The block can be deleted.\n       if (syncList.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"syncBlock for block \" + block + \", all datanodes don\u0027t \" +\n               \"have the block or their replicas have 0 length. The block can \" +\n               \"be deleted.\");\n         }\n         nn.commitBlockSynchronization(block, recoveryId, 0,\n             true, true, DatanodeID.EMPTY_ARRAY, null);\n         return;\n       }\n \n       // Calculate the best available replica state.\n       ReplicaState bestState \u003d ReplicaState.RWR;\n       long finalizedLength \u003d -1;\n       for (BlockRecord r : syncList) {\n         assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if (rState.getValue() \u003c bestState.getValue()) {\n           bestState \u003d rState;\n         }\n         if(rState \u003d\u003d ReplicaState.FINALIZED) {\n           if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n             throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                 \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n           }\n           finalizedLength \u003d r.rInfo.getNumBytes();\n         }\n       }\n \n       // Calculate list of nodes that will participate in the recovery\n       // and the new block size\n       List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n       final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n           -1, recoveryId);\n       switch(bestState) {\n       case FINALIZED:\n         assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n         for(BlockRecord r : syncList) {\n           ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n           if (rState \u003d\u003d ReplicaState.FINALIZED ||\n               rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                   r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n             participatingList.add(r);\n           }\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                 \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                 \", receivedLength\u003d\" + r.rInfo.getNumBytes() +\n                 \", bestState\u003dFINALIZED, finalizedLength\u003d\" + finalizedLength);\n           }\n         }\n         newBlock.setNumBytes(finalizedLength);\n         break;\n       case RBW:\n       case RWR:\n         long minLength \u003d Long.MAX_VALUE;\n         for(BlockRecord r : syncList) {\n           ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n           if(rState \u003d\u003d bestState) {\n             minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n             participatingList.add(r);\n           }\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                 \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                 \", receivedLength\u003d\" + r.rInfo.getNumBytes() + \", bestState\u003d\" +\n                 bestState.name());\n           }\n         }\n         // recover() guarantees syncList will have at least one replica with RWR\n         // or better state.\n-        assert minLength !\u003d Long.MAX_VALUE : \"wrong minLength\";\n+        if (minLength \u003d\u003d Long.MAX_VALUE) {\n+          throw new IOException(\"Incorrect block size\");\n+        }\n         newBlock.setNumBytes(minLength);\n         break;\n       case RUR:\n       case TEMPORARY:\n         assert false : \"bad replica state: \" + bestState;\n       default:\n         break; // we have \u0027case\u0027 all enum values\n       }\n       if (isTruncateRecovery) {\n         newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n       }\n \n       LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}), bestState\u003d{},\"\n               + \" newBlock\u003d{} (length\u003d{}), participatingList\u003d{}\",\n           block, block.getNumBytes(), bestState.name(), newBlock,\n           newBlock.getNumBytes(), participatingList);\n \n       List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n       final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n       for (BlockRecord r : participatingList) {\n         try {\n           r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n               newBlock.getNumBytes());\n           successList.add(r);\n         } catch (IOException e) {\n           InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n               + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n           failedList.add(r.id);\n         }\n       }\n \n       // Abort if all failed.\n       if (successList.isEmpty()) {\n         throw new IOException(\"Cannot recover \" + block\n             + \", the following datanodes failed: \" + failedList);\n       }\n \n       // Notify the name-node about successfully recovered replicas.\n       final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n       final String[] storages \u003d new String[datanodes.length];\n       for (int i \u003d 0; i \u003c datanodes.length; i++) {\n         final BlockRecord r \u003d successList.get(i);\n         datanodes[i] \u003d r.id;\n         storages[i] \u003d r.storageID;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Datanode triggering commitBlockSynchronization, block\u003d\" +\n             block + \", newGs\u003d\" + newBlock.getGenerationStamp() +\n             \", newLength\u003d\" + newBlock.getNumBytes());\n       }\n \n       nn.commitBlockSynchronization(block,\n           newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n           datanodes, storages);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n      DatanodeProtocolClientSideTranslatorPB nn \u003d\n          getActiveNamenodeForBP(block.getBlockPoolId());\n\n      boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n      long blockId \u003d (isTruncateRecovery) ?\n          rBlock.getNewBlock().getBlockId() : block.getBlockId();\n\n      LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}),\"\n              + \" isTruncateRecovery\u003d{}, syncList\u003d{}\", block,\n          block.getNumBytes(), isTruncateRecovery, syncList);\n\n      // syncList.isEmpty() means that all data-nodes do not have the block\n      // or their replicas have 0 length.\n      // The block can be deleted.\n      if (syncList.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"syncBlock for block \" + block + \", all datanodes don\u0027t \" +\n              \"have the block or their replicas have 0 length. The block can \" +\n              \"be deleted.\");\n        }\n        nn.commitBlockSynchronization(block, recoveryId, 0,\n            true, true, DatanodeID.EMPTY_ARRAY, null);\n        return;\n      }\n\n      // Calculate the best available replica state.\n      ReplicaState bestState \u003d ReplicaState.RWR;\n      long finalizedLength \u003d -1;\n      for (BlockRecord r : syncList) {\n        assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if (rState.getValue() \u003c bestState.getValue()) {\n          bestState \u003d rState;\n        }\n        if(rState \u003d\u003d ReplicaState.FINALIZED) {\n          if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n            throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n          }\n          finalizedLength \u003d r.rInfo.getNumBytes();\n        }\n      }\n\n      // Calculate list of nodes that will participate in the recovery\n      // and the new block size\n      List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n      final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n          -1, recoveryId);\n      switch(bestState) {\n      case FINALIZED:\n        assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if (rState \u003d\u003d ReplicaState.FINALIZED ||\n              rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                  r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n            participatingList.add(r);\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                \", receivedLength\u003d\" + r.rInfo.getNumBytes() +\n                \", bestState\u003dFINALIZED, finalizedLength\u003d\" + finalizedLength);\n          }\n        }\n        newBlock.setNumBytes(finalizedLength);\n        break;\n      case RBW:\n      case RWR:\n        long minLength \u003d Long.MAX_VALUE;\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if(rState \u003d\u003d bestState) {\n            minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n            participatingList.add(r);\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                \", receivedLength\u003d\" + r.rInfo.getNumBytes() + \", bestState\u003d\" +\n                bestState.name());\n          }\n        }\n        // recover() guarantees syncList will have at least one replica with RWR\n        // or better state.\n        if (minLength \u003d\u003d Long.MAX_VALUE) {\n          throw new IOException(\"Incorrect block size\");\n        }\n        newBlock.setNumBytes(minLength);\n        break;\n      case RUR:\n      case TEMPORARY:\n        assert false : \"bad replica state: \" + bestState;\n      default:\n        break; // we have \u0027case\u0027 all enum values\n      }\n      if (isTruncateRecovery) {\n        newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n      }\n\n      LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}), bestState\u003d{},\"\n              + \" newBlock\u003d{} (length\u003d{}), participatingList\u003d{}\",\n          block, block.getNumBytes(), bestState.name(), newBlock,\n          newBlock.getNumBytes(), participatingList);\n\n      List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n      final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n      for (BlockRecord r : participatingList) {\n        try {\n          r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n              newBlock.getNumBytes());\n          successList.add(r);\n        } catch (IOException e) {\n          InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n              + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n          failedList.add(r.id);\n        }\n      }\n\n      // Abort if all failed.\n      if (successList.isEmpty()) {\n        throw new IOException(\"Cannot recover \" + block\n            + \", the following datanodes failed: \" + failedList);\n      }\n\n      // Notify the name-node about successfully recovered replicas.\n      final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n      final String[] storages \u003d new String[datanodes.length];\n      for (int i \u003d 0; i \u003c datanodes.length; i++) {\n        final BlockRecord r \u003d successList.get(i);\n        datanodes[i] \u003d r.id;\n        storages[i] \u003d r.storageID;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Datanode triggering commitBlockSynchronization, block\u003d\" +\n            block + \", newGs\u003d\" + newBlock.getGenerationStamp() +\n            \", newLength\u003d\" + newBlock.getNumBytes());\n      }\n\n      nn.commitBlockSynchronization(block,\n          newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n          datanodes, storages);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockRecoveryWorker.java",
      "extendedDetails": {}
    },
    "451265a83d8798624ae2a144bc58fa41db826704": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12070. Failed block recovery leaves files open indefinitely and at risk for data loss. Contributed by Kihwal Lee.\n",
      "commitDate": "26/02/18 8:28 AM",
      "commitName": "451265a83d8798624ae2a144bc58fa41db826704",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "16/10/17 10:34 AM",
      "commitNameOld": "21bc85558718490e558c5b3bdb44c9c64eada994",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 132.95,
      "commitsBetweenForRepo": 866,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,143 @@\n     void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n       DatanodeProtocolClientSideTranslatorPB nn \u003d\n           getActiveNamenodeForBP(block.getBlockPoolId());\n \n       boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n       long blockId \u003d (isTruncateRecovery) ?\n           rBlock.getNewBlock().getBlockId() : block.getBlockId();\n \n       LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}),\"\n               + \" isTruncateRecovery\u003d{}, syncList\u003d{}\", block,\n           block.getNumBytes(), isTruncateRecovery, syncList);\n \n       // syncList.isEmpty() means that all data-nodes do not have the block\n       // or their replicas have 0 length.\n       // The block can be deleted.\n       if (syncList.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"syncBlock for block \" + block + \", all datanodes don\u0027t \" +\n               \"have the block or their replicas have 0 length. The block can \" +\n               \"be deleted.\");\n         }\n         nn.commitBlockSynchronization(block, recoveryId, 0,\n             true, true, DatanodeID.EMPTY_ARRAY, null);\n         return;\n       }\n \n       // Calculate the best available replica state.\n       ReplicaState bestState \u003d ReplicaState.RWR;\n       long finalizedLength \u003d -1;\n       for (BlockRecord r : syncList) {\n         assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if (rState.getValue() \u003c bestState.getValue()) {\n           bestState \u003d rState;\n         }\n         if(rState \u003d\u003d ReplicaState.FINALIZED) {\n           if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n             throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                 \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n           }\n           finalizedLength \u003d r.rInfo.getNumBytes();\n         }\n       }\n \n       // Calculate list of nodes that will participate in the recovery\n       // and the new block size\n       List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n       final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n           -1, recoveryId);\n       switch(bestState) {\n       case FINALIZED:\n         assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n         for(BlockRecord r : syncList) {\n           ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n           if (rState \u003d\u003d ReplicaState.FINALIZED ||\n               rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                   r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n             participatingList.add(r);\n           }\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                 \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                 \", receivedLength\u003d\" + r.rInfo.getNumBytes() +\n                 \", bestState\u003dFINALIZED, finalizedLength\u003d\" + finalizedLength);\n           }\n         }\n         newBlock.setNumBytes(finalizedLength);\n         break;\n       case RBW:\n       case RWR:\n         long minLength \u003d Long.MAX_VALUE;\n         for(BlockRecord r : syncList) {\n           ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n           if(rState \u003d\u003d bestState) {\n             minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n             participatingList.add(r);\n           }\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                 \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                 \", receivedLength\u003d\" + r.rInfo.getNumBytes() + \", bestState\u003d\" +\n                 bestState.name());\n           }\n         }\n         // recover() guarantees syncList will have at least one replica with RWR\n         // or better state.\n         assert minLength !\u003d Long.MAX_VALUE : \"wrong minLength\";\n         newBlock.setNumBytes(minLength);\n         break;\n       case RUR:\n       case TEMPORARY:\n         assert false : \"bad replica state: \" + bestState;\n       default:\n         break; // we have \u0027case\u0027 all enum values\n       }\n       if (isTruncateRecovery) {\n         newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n       }\n \n       LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}), bestState\u003d{},\"\n               + \" newBlock\u003d{} (length\u003d{}), participatingList\u003d{}\",\n           block, block.getNumBytes(), bestState.name(), newBlock,\n           newBlock.getNumBytes(), participatingList);\n \n       List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n       final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n       for (BlockRecord r : participatingList) {\n         try {\n           r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n               newBlock.getNumBytes());\n           successList.add(r);\n         } catch (IOException e) {\n           InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n               + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n           failedList.add(r.id);\n         }\n       }\n \n-      // If any of the data-nodes failed, the recovery fails, because\n-      // we never know the actual state of the replica on failed data-nodes.\n-      // The recovery should be started over.\n-      if (!failedList.isEmpty()) {\n+      // Abort if all failed.\n+      if (successList.isEmpty()) {\n         throw new IOException(\"Cannot recover \" + block\n             + \", the following datanodes failed: \" + failedList);\n       }\n \n       // Notify the name-node about successfully recovered replicas.\n       final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n       final String[] storages \u003d new String[datanodes.length];\n       for (int i \u003d 0; i \u003c datanodes.length; i++) {\n         final BlockRecord r \u003d successList.get(i);\n         datanodes[i] \u003d r.id;\n         storages[i] \u003d r.storageID;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Datanode triggering commitBlockSynchronization, block\u003d\" +\n             block + \", newGs\u003d\" + newBlock.getGenerationStamp() +\n             \", newLength\u003d\" + newBlock.getNumBytes());\n       }\n \n       nn.commitBlockSynchronization(block,\n           newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n           datanodes, storages);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n      DatanodeProtocolClientSideTranslatorPB nn \u003d\n          getActiveNamenodeForBP(block.getBlockPoolId());\n\n      boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n      long blockId \u003d (isTruncateRecovery) ?\n          rBlock.getNewBlock().getBlockId() : block.getBlockId();\n\n      LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}),\"\n              + \" isTruncateRecovery\u003d{}, syncList\u003d{}\", block,\n          block.getNumBytes(), isTruncateRecovery, syncList);\n\n      // syncList.isEmpty() means that all data-nodes do not have the block\n      // or their replicas have 0 length.\n      // The block can be deleted.\n      if (syncList.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"syncBlock for block \" + block + \", all datanodes don\u0027t \" +\n              \"have the block or their replicas have 0 length. The block can \" +\n              \"be deleted.\");\n        }\n        nn.commitBlockSynchronization(block, recoveryId, 0,\n            true, true, DatanodeID.EMPTY_ARRAY, null);\n        return;\n      }\n\n      // Calculate the best available replica state.\n      ReplicaState bestState \u003d ReplicaState.RWR;\n      long finalizedLength \u003d -1;\n      for (BlockRecord r : syncList) {\n        assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if (rState.getValue() \u003c bestState.getValue()) {\n          bestState \u003d rState;\n        }\n        if(rState \u003d\u003d ReplicaState.FINALIZED) {\n          if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n            throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n          }\n          finalizedLength \u003d r.rInfo.getNumBytes();\n        }\n      }\n\n      // Calculate list of nodes that will participate in the recovery\n      // and the new block size\n      List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n      final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n          -1, recoveryId);\n      switch(bestState) {\n      case FINALIZED:\n        assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if (rState \u003d\u003d ReplicaState.FINALIZED ||\n              rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                  r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n            participatingList.add(r);\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                \", receivedLength\u003d\" + r.rInfo.getNumBytes() +\n                \", bestState\u003dFINALIZED, finalizedLength\u003d\" + finalizedLength);\n          }\n        }\n        newBlock.setNumBytes(finalizedLength);\n        break;\n      case RBW:\n      case RWR:\n        long minLength \u003d Long.MAX_VALUE;\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if(rState \u003d\u003d bestState) {\n            minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n            participatingList.add(r);\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                \", receivedLength\u003d\" + r.rInfo.getNumBytes() + \", bestState\u003d\" +\n                bestState.name());\n          }\n        }\n        // recover() guarantees syncList will have at least one replica with RWR\n        // or better state.\n        assert minLength !\u003d Long.MAX_VALUE : \"wrong minLength\";\n        newBlock.setNumBytes(minLength);\n        break;\n      case RUR:\n      case TEMPORARY:\n        assert false : \"bad replica state: \" + bestState;\n      default:\n        break; // we have \u0027case\u0027 all enum values\n      }\n      if (isTruncateRecovery) {\n        newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n      }\n\n      LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}), bestState\u003d{},\"\n              + \" newBlock\u003d{} (length\u003d{}), participatingList\u003d{}\",\n          block, block.getNumBytes(), bestState.name(), newBlock,\n          newBlock.getNumBytes(), participatingList);\n\n      List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n      final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n      for (BlockRecord r : participatingList) {\n        try {\n          r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n              newBlock.getNumBytes());\n          successList.add(r);\n        } catch (IOException e) {\n          InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n              + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n          failedList.add(r.id);\n        }\n      }\n\n      // Abort if all failed.\n      if (successList.isEmpty()) {\n        throw new IOException(\"Cannot recover \" + block\n            + \", the following datanodes failed: \" + failedList);\n      }\n\n      // Notify the name-node about successfully recovered replicas.\n      final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n      final String[] storages \u003d new String[datanodes.length];\n      for (int i \u003d 0; i \u003c datanodes.length; i++) {\n        final BlockRecord r \u003d successList.get(i);\n        datanodes[i] \u003d r.id;\n        storages[i] \u003d r.storageID;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Datanode triggering commitBlockSynchronization, block\u003d\" +\n            block + \", newGs\u003d\" + newBlock.getGenerationStamp() +\n            \", newLength\u003d\" + newBlock.getNumBytes());\n      }\n\n      nn.commitBlockSynchronization(block,\n          newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n          datanodes, storages);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockRecoveryWorker.java",
      "extendedDetails": {}
    },
    "21bc85558718490e558c5b3bdb44c9c64eada994": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12642. Log block and datanode details in BlockRecoveryWorker.\n",
      "commitDate": "16/10/17 10:34 AM",
      "commitName": "21bc85558718490e558c5b3bdb44c9c64eada994",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "19/06/17 8:03 PM",
      "commitNameOld": "099cbb427ad535c3369d9ac3fda6463502fc1c54",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 118.6,
      "commitsBetweenForRepo": 914,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,145 @@\n     void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n       DatanodeProtocolClientSideTranslatorPB nn \u003d\n           getActiveNamenodeForBP(block.getBlockPoolId());\n \n       boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n       long blockId \u003d (isTruncateRecovery) ?\n           rBlock.getNewBlock().getBlockId() : block.getBlockId();\n \n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n-            + \"), syncList\u003d\" + syncList);\n-      }\n+      LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}),\"\n+              + \" isTruncateRecovery\u003d{}, syncList\u003d{}\", block,\n+          block.getNumBytes(), isTruncateRecovery, syncList);\n \n       // syncList.isEmpty() means that all data-nodes do not have the block\n       // or their replicas have 0 length.\n       // The block can be deleted.\n       if (syncList.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"syncBlock for block \" + block + \", all datanodes don\u0027t \" +\n               \"have the block or their replicas have 0 length. The block can \" +\n               \"be deleted.\");\n         }\n         nn.commitBlockSynchronization(block, recoveryId, 0,\n             true, true, DatanodeID.EMPTY_ARRAY, null);\n         return;\n       }\n \n       // Calculate the best available replica state.\n       ReplicaState bestState \u003d ReplicaState.RWR;\n       long finalizedLength \u003d -1;\n       for (BlockRecord r : syncList) {\n         assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if (rState.getValue() \u003c bestState.getValue()) {\n           bestState \u003d rState;\n         }\n         if(rState \u003d\u003d ReplicaState.FINALIZED) {\n           if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n             throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                 \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n           }\n           finalizedLength \u003d r.rInfo.getNumBytes();\n         }\n       }\n \n       // Calculate list of nodes that will participate in the recovery\n       // and the new block size\n       List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n       final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n           -1, recoveryId);\n       switch(bestState) {\n       case FINALIZED:\n         assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n         for(BlockRecord r : syncList) {\n           ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n           if (rState \u003d\u003d ReplicaState.FINALIZED ||\n               rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                   r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n             participatingList.add(r);\n           }\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                 \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                 \", receivedLength\u003d\" + r.rInfo.getNumBytes() +\n                 \", bestState\u003dFINALIZED, finalizedLength\u003d\" + finalizedLength);\n           }\n         }\n         newBlock.setNumBytes(finalizedLength);\n         break;\n       case RBW:\n       case RWR:\n         long minLength \u003d Long.MAX_VALUE;\n         for(BlockRecord r : syncList) {\n           ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n           if(rState \u003d\u003d bestState) {\n             minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n             participatingList.add(r);\n           }\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                 \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                 \", receivedLength\u003d\" + r.rInfo.getNumBytes() + \", bestState\u003d\" +\n                 bestState.name());\n           }\n         }\n         // recover() guarantees syncList will have at least one replica with RWR\n         // or better state.\n         assert minLength !\u003d Long.MAX_VALUE : \"wrong minLength\";\n         newBlock.setNumBytes(minLength);\n         break;\n       case RUR:\n       case TEMPORARY:\n         assert false : \"bad replica state: \" + bestState;\n       default:\n         break; // we have \u0027case\u0027 all enum values\n       }\n       if (isTruncateRecovery) {\n         newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n       }\n \n+      LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}), bestState\u003d{},\"\n+              + \" newBlock\u003d{} (length\u003d{}), participatingList\u003d{}\",\n+          block, block.getNumBytes(), bestState.name(), newBlock,\n+          newBlock.getNumBytes(), participatingList);\n+\n       List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n       final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n       for (BlockRecord r : participatingList) {\n         try {\n           r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n               newBlock.getNumBytes());\n           successList.add(r);\n         } catch (IOException e) {\n           InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n               + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n           failedList.add(r.id);\n         }\n       }\n \n       // If any of the data-nodes failed, the recovery fails, because\n       // we never know the actual state of the replica on failed data-nodes.\n       // The recovery should be started over.\n       if (!failedList.isEmpty()) {\n         throw new IOException(\"Cannot recover \" + block\n             + \", the following datanodes failed: \" + failedList);\n       }\n \n       // Notify the name-node about successfully recovered replicas.\n       final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n       final String[] storages \u003d new String[datanodes.length];\n       for (int i \u003d 0; i \u003c datanodes.length; i++) {\n         final BlockRecord r \u003d successList.get(i);\n         datanodes[i] \u003d r.id;\n         storages[i] \u003d r.storageID;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Datanode triggering commitBlockSynchronization, block\u003d\" +\n             block + \", newGs\u003d\" + newBlock.getGenerationStamp() +\n             \", newLength\u003d\" + newBlock.getNumBytes());\n       }\n \n       nn.commitBlockSynchronization(block,\n           newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n           datanodes, storages);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n      DatanodeProtocolClientSideTranslatorPB nn \u003d\n          getActiveNamenodeForBP(block.getBlockPoolId());\n\n      boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n      long blockId \u003d (isTruncateRecovery) ?\n          rBlock.getNewBlock().getBlockId() : block.getBlockId();\n\n      LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}),\"\n              + \" isTruncateRecovery\u003d{}, syncList\u003d{}\", block,\n          block.getNumBytes(), isTruncateRecovery, syncList);\n\n      // syncList.isEmpty() means that all data-nodes do not have the block\n      // or their replicas have 0 length.\n      // The block can be deleted.\n      if (syncList.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"syncBlock for block \" + block + \", all datanodes don\u0027t \" +\n              \"have the block or their replicas have 0 length. The block can \" +\n              \"be deleted.\");\n        }\n        nn.commitBlockSynchronization(block, recoveryId, 0,\n            true, true, DatanodeID.EMPTY_ARRAY, null);\n        return;\n      }\n\n      // Calculate the best available replica state.\n      ReplicaState bestState \u003d ReplicaState.RWR;\n      long finalizedLength \u003d -1;\n      for (BlockRecord r : syncList) {\n        assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if (rState.getValue() \u003c bestState.getValue()) {\n          bestState \u003d rState;\n        }\n        if(rState \u003d\u003d ReplicaState.FINALIZED) {\n          if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n            throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n          }\n          finalizedLength \u003d r.rInfo.getNumBytes();\n        }\n      }\n\n      // Calculate list of nodes that will participate in the recovery\n      // and the new block size\n      List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n      final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n          -1, recoveryId);\n      switch(bestState) {\n      case FINALIZED:\n        assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if (rState \u003d\u003d ReplicaState.FINALIZED ||\n              rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                  r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n            participatingList.add(r);\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                \", receivedLength\u003d\" + r.rInfo.getNumBytes() +\n                \", bestState\u003dFINALIZED, finalizedLength\u003d\" + finalizedLength);\n          }\n        }\n        newBlock.setNumBytes(finalizedLength);\n        break;\n      case RBW:\n      case RWR:\n        long minLength \u003d Long.MAX_VALUE;\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if(rState \u003d\u003d bestState) {\n            minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n            participatingList.add(r);\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                \", receivedLength\u003d\" + r.rInfo.getNumBytes() + \", bestState\u003d\" +\n                bestState.name());\n          }\n        }\n        // recover() guarantees syncList will have at least one replica with RWR\n        // or better state.\n        assert minLength !\u003d Long.MAX_VALUE : \"wrong minLength\";\n        newBlock.setNumBytes(minLength);\n        break;\n      case RUR:\n      case TEMPORARY:\n        assert false : \"bad replica state: \" + bestState;\n      default:\n        break; // we have \u0027case\u0027 all enum values\n      }\n      if (isTruncateRecovery) {\n        newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n      }\n\n      LOG.info(\"BlockRecoveryWorker: block\u003d{} (length\u003d{}), bestState\u003d{},\"\n              + \" newBlock\u003d{} (length\u003d{}), participatingList\u003d{}\",\n          block, block.getNumBytes(), bestState.name(), newBlock,\n          newBlock.getNumBytes(), participatingList);\n\n      List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n      final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n      for (BlockRecord r : participatingList) {\n        try {\n          r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n              newBlock.getNumBytes());\n          successList.add(r);\n        } catch (IOException e) {\n          InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n              + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n          failedList.add(r.id);\n        }\n      }\n\n      // If any of the data-nodes failed, the recovery fails, because\n      // we never know the actual state of the replica on failed data-nodes.\n      // The recovery should be started over.\n      if (!failedList.isEmpty()) {\n        throw new IOException(\"Cannot recover \" + block\n            + \", the following datanodes failed: \" + failedList);\n      }\n\n      // Notify the name-node about successfully recovered replicas.\n      final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n      final String[] storages \u003d new String[datanodes.length];\n      for (int i \u003d 0; i \u003c datanodes.length; i++) {\n        final BlockRecord r \u003d successList.get(i);\n        datanodes[i] \u003d r.id;\n        storages[i] \u003d r.storageID;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Datanode triggering commitBlockSynchronization, block\u003d\" +\n            block + \", newGs\u003d\" + newBlock.getGenerationStamp() +\n            \", newLength\u003d\" + newBlock.getNumBytes());\n      }\n\n      nn.commitBlockSynchronization(block,\n          newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n          datanodes, storages);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockRecoveryWorker.java",
      "extendedDetails": {}
    },
    "61ab0440f7eaff0f631cbae0378403912f88d7ad": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9173. Erasure Coding: Lease recovery for striped file. Contributed by Walter Su and Jing Zhao.\n\nChange-Id: I51703a61c9d8454f883028f3f6acb5729fde1b15\n",
      "commitDate": "18/12/15 3:57 PM",
      "commitName": "61ab0440f7eaff0f631cbae0378403912f88d7ad",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "22/11/15 3:54 PM",
      "commitNameOld": "176ff5ce90f2cbcd8342016d0f5570337d2ff79f",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 26.0,
      "commitsBetweenForRepo": 196,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,141 @@\n     void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n       DatanodeProtocolClientSideTranslatorPB nn \u003d\n           getActiveNamenodeForBP(block.getBlockPoolId());\n \n       boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n       long blockId \u003d (isTruncateRecovery) ?\n           rBlock.getNewBlock().getBlockId() : block.getBlockId();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n             + \"), syncList\u003d\" + syncList);\n       }\n \n       // syncList.isEmpty() means that all data-nodes do not have the block\n       // or their replicas have 0 length.\n       // The block can be deleted.\n       if (syncList.isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"syncBlock for block \" + block + \", all datanodes don\u0027t \" +\n               \"have the block or their replicas have 0 length. The block can \" +\n               \"be deleted.\");\n         }\n         nn.commitBlockSynchronization(block, recoveryId, 0,\n             true, true, DatanodeID.EMPTY_ARRAY, null);\n         return;\n       }\n \n       // Calculate the best available replica state.\n       ReplicaState bestState \u003d ReplicaState.RWR;\n       long finalizedLength \u003d -1;\n       for (BlockRecord r : syncList) {\n         assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if (rState.getValue() \u003c bestState.getValue()) {\n           bestState \u003d rState;\n         }\n         if(rState \u003d\u003d ReplicaState.FINALIZED) {\n           if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n             throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                 \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n           }\n           finalizedLength \u003d r.rInfo.getNumBytes();\n         }\n       }\n \n       // Calculate list of nodes that will participate in the recovery\n       // and the new block size\n       List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n       final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n           -1, recoveryId);\n       switch(bestState) {\n       case FINALIZED:\n         assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n         for(BlockRecord r : syncList) {\n           ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n           if (rState \u003d\u003d ReplicaState.FINALIZED ||\n               rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                   r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n             participatingList.add(r);\n           }\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                 \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                 \", receivedLength\u003d\" + r.rInfo.getNumBytes() +\n                 \", bestState\u003dFINALIZED, finalizedLength\u003d\" + finalizedLength);\n           }\n         }\n         newBlock.setNumBytes(finalizedLength);\n         break;\n       case RBW:\n       case RWR:\n         long minLength \u003d Long.MAX_VALUE;\n         for(BlockRecord r : syncList) {\n           ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n           if(rState \u003d\u003d bestState) {\n             minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n             participatingList.add(r);\n           }\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                 \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                 \", receivedLength\u003d\" + r.rInfo.getNumBytes() + \", bestState\u003d\" +\n                 bestState.name());\n           }\n         }\n         // recover() guarantees syncList will have at least one replica with RWR\n         // or better state.\n         assert minLength !\u003d Long.MAX_VALUE : \"wrong minLength\";\n         newBlock.setNumBytes(minLength);\n         break;\n       case RUR:\n       case TEMPORARY:\n         assert false : \"bad replica state: \" + bestState;\n       default:\n         break; // we have \u0027case\u0027 all enum values\n       }\n       if (isTruncateRecovery) {\n         newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n       }\n \n       List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n       final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n       for (BlockRecord r : participatingList) {\n         try {\n           r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n               newBlock.getNumBytes());\n           successList.add(r);\n         } catch (IOException e) {\n           InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n               + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n           failedList.add(r.id);\n         }\n       }\n \n       // If any of the data-nodes failed, the recovery fails, because\n       // we never know the actual state of the replica on failed data-nodes.\n       // The recovery should be started over.\n       if (!failedList.isEmpty()) {\n-        StringBuilder b \u003d new StringBuilder();\n-        for(DatanodeID id : failedList) {\n-          b.append(\"\\n  \" + id);\n-        }\n-        throw new IOException(\"Cannot recover \" + block + \", the following \"\n-            + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n+        throw new IOException(\"Cannot recover \" + block\n+            + \", the following datanodes failed: \" + failedList);\n       }\n \n       // Notify the name-node about successfully recovered replicas.\n       final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n       final String[] storages \u003d new String[datanodes.length];\n       for (int i \u003d 0; i \u003c datanodes.length; i++) {\n         final BlockRecord r \u003d successList.get(i);\n         datanodes[i] \u003d r.id;\n         storages[i] \u003d r.storageID;\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Datanode triggering commitBlockSynchronization, block\u003d\" +\n             block + \", newGs\u003d\" + newBlock.getGenerationStamp() +\n             \", newLength\u003d\" + newBlock.getNumBytes());\n       }\n \n       nn.commitBlockSynchronization(block,\n           newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n           datanodes, storages);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n      DatanodeProtocolClientSideTranslatorPB nn \u003d\n          getActiveNamenodeForBP(block.getBlockPoolId());\n\n      boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n      long blockId \u003d (isTruncateRecovery) ?\n          rBlock.getNewBlock().getBlockId() : block.getBlockId();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n            + \"), syncList\u003d\" + syncList);\n      }\n\n      // syncList.isEmpty() means that all data-nodes do not have the block\n      // or their replicas have 0 length.\n      // The block can be deleted.\n      if (syncList.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"syncBlock for block \" + block + \", all datanodes don\u0027t \" +\n              \"have the block or their replicas have 0 length. The block can \" +\n              \"be deleted.\");\n        }\n        nn.commitBlockSynchronization(block, recoveryId, 0,\n            true, true, DatanodeID.EMPTY_ARRAY, null);\n        return;\n      }\n\n      // Calculate the best available replica state.\n      ReplicaState bestState \u003d ReplicaState.RWR;\n      long finalizedLength \u003d -1;\n      for (BlockRecord r : syncList) {\n        assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if (rState.getValue() \u003c bestState.getValue()) {\n          bestState \u003d rState;\n        }\n        if(rState \u003d\u003d ReplicaState.FINALIZED) {\n          if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n            throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n          }\n          finalizedLength \u003d r.rInfo.getNumBytes();\n        }\n      }\n\n      // Calculate list of nodes that will participate in the recovery\n      // and the new block size\n      List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n      final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n          -1, recoveryId);\n      switch(bestState) {\n      case FINALIZED:\n        assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if (rState \u003d\u003d ReplicaState.FINALIZED ||\n              rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                  r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n            participatingList.add(r);\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                \", receivedLength\u003d\" + r.rInfo.getNumBytes() +\n                \", bestState\u003dFINALIZED, finalizedLength\u003d\" + finalizedLength);\n          }\n        }\n        newBlock.setNumBytes(finalizedLength);\n        break;\n      case RBW:\n      case RWR:\n        long minLength \u003d Long.MAX_VALUE;\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if(rState \u003d\u003d bestState) {\n            minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n            participatingList.add(r);\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                \", receivedLength\u003d\" + r.rInfo.getNumBytes() + \", bestState\u003d\" +\n                bestState.name());\n          }\n        }\n        // recover() guarantees syncList will have at least one replica with RWR\n        // or better state.\n        assert minLength !\u003d Long.MAX_VALUE : \"wrong minLength\";\n        newBlock.setNumBytes(minLength);\n        break;\n      case RUR:\n      case TEMPORARY:\n        assert false : \"bad replica state: \" + bestState;\n      default:\n        break; // we have \u0027case\u0027 all enum values\n      }\n      if (isTruncateRecovery) {\n        newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n      }\n\n      List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n      final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n      for (BlockRecord r : participatingList) {\n        try {\n          r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n              newBlock.getNumBytes());\n          successList.add(r);\n        } catch (IOException e) {\n          InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n              + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n          failedList.add(r.id);\n        }\n      }\n\n      // If any of the data-nodes failed, the recovery fails, because\n      // we never know the actual state of the replica on failed data-nodes.\n      // The recovery should be started over.\n      if (!failedList.isEmpty()) {\n        throw new IOException(\"Cannot recover \" + block\n            + \", the following datanodes failed: \" + failedList);\n      }\n\n      // Notify the name-node about successfully recovered replicas.\n      final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n      final String[] storages \u003d new String[datanodes.length];\n      for (int i \u003d 0; i \u003c datanodes.length; i++) {\n        final BlockRecord r \u003d successList.get(i);\n        datanodes[i] \u003d r.id;\n        storages[i] \u003d r.storageID;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Datanode triggering commitBlockSynchronization, block\u003d\" +\n            block + \", newGs\u003d\" + newBlock.getGenerationStamp() +\n            \", newLength\u003d\" + newBlock.getNumBytes());\n      }\n\n      nn.commitBlockSynchronization(block,\n          newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n          datanodes, storages);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockRecoveryWorker.java",
      "extendedDetails": {}
    },
    "b64242c0d2cabd225a8fb7d25fed449d252e4fa1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9236. Missing sanity check for block size during block recovery. (Tony Wu via Yongjun Zhang)\n",
      "commitDate": "06/11/15 11:15 AM",
      "commitName": "b64242c0d2cabd225a8fb7d25fed449d252e4fa1",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "28/10/15 7:34 AM",
      "commitNameOld": "e287e7d14b838a866ba03d895fa35819999d7c09",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 9.2,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,145 @@\n     void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n       DatanodeProtocolClientSideTranslatorPB nn \u003d\n           getActiveNamenodeForBP(block.getBlockPoolId());\n \n       boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n       long blockId \u003d (isTruncateRecovery) ?\n           rBlock.getNewBlock().getBlockId() : block.getBlockId();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n             + \"), syncList\u003d\" + syncList);\n       }\n \n       // syncList.isEmpty() means that all data-nodes do not have the block\n       // or their replicas have 0 length.\n       // The block can be deleted.\n       if (syncList.isEmpty()) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"syncBlock for block \" + block + \", all datanodes don\u0027t \" +\n+              \"have the block or their replicas have 0 length. The block can \" +\n+              \"be deleted.\");\n+        }\n         nn.commitBlockSynchronization(block, recoveryId, 0,\n             true, true, DatanodeID.EMPTY_ARRAY, null);\n         return;\n       }\n \n       // Calculate the best available replica state.\n       ReplicaState bestState \u003d ReplicaState.RWR;\n       long finalizedLength \u003d -1;\n       for (BlockRecord r : syncList) {\n         assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if (rState.getValue() \u003c bestState.getValue()) {\n           bestState \u003d rState;\n         }\n         if(rState \u003d\u003d ReplicaState.FINALIZED) {\n           if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n             throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                 \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n           }\n           finalizedLength \u003d r.rInfo.getNumBytes();\n         }\n       }\n \n       // Calculate list of nodes that will participate in the recovery\n       // and the new block size\n       List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n       final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n           -1, recoveryId);\n       switch(bestState) {\n       case FINALIZED:\n         assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n         for(BlockRecord r : syncList) {\n           ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n           if (rState \u003d\u003d ReplicaState.FINALIZED ||\n               rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                   r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n             participatingList.add(r);\n           }\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n+                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n+                \", receivedLength\u003d\" + r.rInfo.getNumBytes() +\n+                \", bestState\u003dFINALIZED, finalizedLength\u003d\" + finalizedLength);\n+          }\n         }\n         newBlock.setNumBytes(finalizedLength);\n         break;\n       case RBW:\n       case RWR:\n         long minLength \u003d Long.MAX_VALUE;\n         for(BlockRecord r : syncList) {\n           ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n           if(rState \u003d\u003d bestState) {\n             minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n             participatingList.add(r);\n           }\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n+                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n+                \", receivedLength\u003d\" + r.rInfo.getNumBytes() + \", bestState\u003d\" +\n+                bestState.name());\n+          }\n         }\n+        // recover() guarantees syncList will have at least one replica with RWR\n+        // or better state.\n+        assert minLength !\u003d Long.MAX_VALUE : \"wrong minLength\";\n         newBlock.setNumBytes(minLength);\n         break;\n       case RUR:\n       case TEMPORARY:\n         assert false : \"bad replica state: \" + bestState;\n       default:\n         break; // we have \u0027case\u0027 all enum values\n       }\n       if (isTruncateRecovery) {\n         newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n       }\n \n       List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n       final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n       for (BlockRecord r : participatingList) {\n         try {\n           r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n               newBlock.getNumBytes());\n           successList.add(r);\n         } catch (IOException e) {\n           InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n               + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n           failedList.add(r.id);\n         }\n       }\n \n       // If any of the data-nodes failed, the recovery fails, because\n       // we never know the actual state of the replica on failed data-nodes.\n       // The recovery should be started over.\n       if (!failedList.isEmpty()) {\n         StringBuilder b \u003d new StringBuilder();\n         for(DatanodeID id : failedList) {\n           b.append(\"\\n  \" + id);\n         }\n         throw new IOException(\"Cannot recover \" + block + \", the following \"\n             + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n       }\n \n       // Notify the name-node about successfully recovered replicas.\n       final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n       final String[] storages \u003d new String[datanodes.length];\n       for (int i \u003d 0; i \u003c datanodes.length; i++) {\n         final BlockRecord r \u003d successList.get(i);\n         datanodes[i] \u003d r.id;\n         storages[i] \u003d r.storageID;\n       }\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Datanode triggering commitBlockSynchronization, block\u003d\" +\n+            block + \", newGs\u003d\" + newBlock.getGenerationStamp() +\n+            \", newLength\u003d\" + newBlock.getNumBytes());\n+      }\n+\n       nn.commitBlockSynchronization(block,\n           newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n           datanodes, storages);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n      DatanodeProtocolClientSideTranslatorPB nn \u003d\n          getActiveNamenodeForBP(block.getBlockPoolId());\n\n      boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n      long blockId \u003d (isTruncateRecovery) ?\n          rBlock.getNewBlock().getBlockId() : block.getBlockId();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n            + \"), syncList\u003d\" + syncList);\n      }\n\n      // syncList.isEmpty() means that all data-nodes do not have the block\n      // or their replicas have 0 length.\n      // The block can be deleted.\n      if (syncList.isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"syncBlock for block \" + block + \", all datanodes don\u0027t \" +\n              \"have the block or their replicas have 0 length. The block can \" +\n              \"be deleted.\");\n        }\n        nn.commitBlockSynchronization(block, recoveryId, 0,\n            true, true, DatanodeID.EMPTY_ARRAY, null);\n        return;\n      }\n\n      // Calculate the best available replica state.\n      ReplicaState bestState \u003d ReplicaState.RWR;\n      long finalizedLength \u003d -1;\n      for (BlockRecord r : syncList) {\n        assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if (rState.getValue() \u003c bestState.getValue()) {\n          bestState \u003d rState;\n        }\n        if(rState \u003d\u003d ReplicaState.FINALIZED) {\n          if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n            throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n          }\n          finalizedLength \u003d r.rInfo.getNumBytes();\n        }\n      }\n\n      // Calculate list of nodes that will participate in the recovery\n      // and the new block size\n      List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n      final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n          -1, recoveryId);\n      switch(bestState) {\n      case FINALIZED:\n        assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if (rState \u003d\u003d ReplicaState.FINALIZED ||\n              rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                  r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n            participatingList.add(r);\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                \", receivedLength\u003d\" + r.rInfo.getNumBytes() +\n                \", bestState\u003dFINALIZED, finalizedLength\u003d\" + finalizedLength);\n          }\n        }\n        newBlock.setNumBytes(finalizedLength);\n        break;\n      case RBW:\n      case RWR:\n        long minLength \u003d Long.MAX_VALUE;\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if(rState \u003d\u003d bestState) {\n            minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n            participatingList.add(r);\n          }\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"syncBlock replicaInfo: block\u003d\" + block +\n                \", from datanode \" + r.id + \", receivedState\u003d\" + rState.name() +\n                \", receivedLength\u003d\" + r.rInfo.getNumBytes() + \", bestState\u003d\" +\n                bestState.name());\n          }\n        }\n        // recover() guarantees syncList will have at least one replica with RWR\n        // or better state.\n        assert minLength !\u003d Long.MAX_VALUE : \"wrong minLength\";\n        newBlock.setNumBytes(minLength);\n        break;\n      case RUR:\n      case TEMPORARY:\n        assert false : \"bad replica state: \" + bestState;\n      default:\n        break; // we have \u0027case\u0027 all enum values\n      }\n      if (isTruncateRecovery) {\n        newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n      }\n\n      List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n      final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n      for (BlockRecord r : participatingList) {\n        try {\n          r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n              newBlock.getNumBytes());\n          successList.add(r);\n        } catch (IOException e) {\n          InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n              + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n          failedList.add(r.id);\n        }\n      }\n\n      // If any of the data-nodes failed, the recovery fails, because\n      // we never know the actual state of the replica on failed data-nodes.\n      // The recovery should be started over.\n      if (!failedList.isEmpty()) {\n        StringBuilder b \u003d new StringBuilder();\n        for(DatanodeID id : failedList) {\n          b.append(\"\\n  \" + id);\n        }\n        throw new IOException(\"Cannot recover \" + block + \", the following \"\n            + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n      }\n\n      // Notify the name-node about successfully recovered replicas.\n      final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n      final String[] storages \u003d new String[datanodes.length];\n      for (int i \u003d 0; i \u003c datanodes.length; i++) {\n        final BlockRecord r \u003d successList.get(i);\n        datanodes[i] \u003d r.id;\n        storages[i] \u003d r.storageID;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Datanode triggering commitBlockSynchronization, block\u003d\" +\n            block + \", newGs\u003d\" + newBlock.getGenerationStamp() +\n            \", newLength\u003d\" + newBlock.getNumBytes());\n      }\n\n      nn.commitBlockSynchronization(block,\n          newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n          datanodes, storages);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockRecoveryWorker.java",
      "extendedDetails": {}
    },
    "e287e7d14b838a866ba03d895fa35819999d7c09": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-9255. Consolidate block recovery related implementation into a single class. Contributed by Walter Su.\n\nChange-Id: I7a1c03f50123d79ac0a78c981d9721617e3229d1\n",
      "commitDate": "28/10/15 7:34 AM",
      "commitName": "e287e7d14b838a866ba03d895fa35819999d7c09",
      "commitAuthor": "Zhe Zhang",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-9255. Consolidate block recovery related implementation into a single class. Contributed by Walter Su.\n\nChange-Id: I7a1c03f50123d79ac0a78c981d9721617e3229d1\n",
          "commitDate": "28/10/15 7:34 AM",
          "commitName": "e287e7d14b838a866ba03d895fa35819999d7c09",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "28/10/15 3:36 AM",
          "commitNameOld": "a04b16970b0dbe903ac9a3a2a3080cf6de181bc2",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,116 +1,118 @@\n-  void syncBlock(RecoveringBlock rBlock,\n-                         List\u003cBlockRecord\u003e syncList) throws IOException {\n-    ExtendedBlock block \u003d rBlock.getBlock();\n-    final String bpid \u003d block.getBlockPoolId();\n-    DatanodeProtocolClientSideTranslatorPB nn \u003d\n-      getActiveNamenodeForBP(block.getBlockPoolId());\n+    void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n+      DatanodeProtocolClientSideTranslatorPB nn \u003d\n+          getActiveNamenodeForBP(block.getBlockPoolId());\n \n-    long recoveryId \u003d rBlock.getNewGenerationStamp();\n-    boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n-    long blockId \u003d (isTruncateRecovery) ?\n-        rBlock.getNewBlock().getBlockId() : block.getBlockId();\n+      boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n+      long blockId \u003d (isTruncateRecovery) ?\n+          rBlock.getNewBlock().getBlockId() : block.getBlockId();\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n-          + \"), syncList\u003d\" + syncList);\n-    }\n-\n-    // syncList.isEmpty() means that all data-nodes do not have the block\n-    // or their replicas have 0 length.\n-    // The block can be deleted.\n-    if (syncList.isEmpty()) {\n-      nn.commitBlockSynchronization(block, recoveryId, 0,\n-          true, true, DatanodeID.EMPTY_ARRAY, null);\n-      return;\n-    }\n-\n-    // Calculate the best available replica state.\n-    ReplicaState bestState \u003d ReplicaState.RWR;\n-    long finalizedLength \u003d -1;\n-    for(BlockRecord r : syncList) {\n-      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n-      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n-      if(rState.getValue() \u003c bestState.getValue())\n-        bestState \u003d rState;\n-      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n-        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n-          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n-              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n-        finalizedLength \u003d r.rInfo.getNumBytes();\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n+            + \"), syncList\u003d\" + syncList);\n       }\n-    }\n \n-    // Calculate list of nodes that will participate in the recovery\n-    // and the new block size\n-    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n-    final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n-        -1, recoveryId);\n-    switch(bestState) {\n-    case FINALIZED:\n-      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n-      for(BlockRecord r : syncList) {\n-        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n-        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n-           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n-                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n-          participatingList.add(r);\n+      // syncList.isEmpty() means that all data-nodes do not have the block\n+      // or their replicas have 0 length.\n+      // The block can be deleted.\n+      if (syncList.isEmpty()) {\n+        nn.commitBlockSynchronization(block, recoveryId, 0,\n+            true, true, DatanodeID.EMPTY_ARRAY, null);\n+        return;\n       }\n-      newBlock.setNumBytes(finalizedLength);\n-      break;\n-    case RBW:\n-    case RWR:\n-      long minLength \u003d Long.MAX_VALUE;\n-      for(BlockRecord r : syncList) {\n+\n+      // Calculate the best available replica state.\n+      ReplicaState bestState \u003d ReplicaState.RWR;\n+      long finalizedLength \u003d -1;\n+      for (BlockRecord r : syncList) {\n+        assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n-        if(rState \u003d\u003d bestState) {\n-          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n-          participatingList.add(r);\n+        if (rState.getValue() \u003c bestState.getValue()) {\n+          bestState \u003d rState;\n+        }\n+        if(rState \u003d\u003d ReplicaState.FINALIZED) {\n+          if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n+            throw new IOException(\"Inconsistent size of finalized replicas. \" +\n+                \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n+          }\n+          finalizedLength \u003d r.rInfo.getNumBytes();\n         }\n       }\n-      newBlock.setNumBytes(minLength);\n-      break;\n-    case RUR:\n-    case TEMPORARY:\n-      assert false : \"bad replica state: \" + bestState;\n-    }\n-    if(isTruncateRecovery)\n-      newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n \n-    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n-    final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003cBlockRecord\u003e();\n-    for(BlockRecord r : participatingList) {\n-      try {\n-        r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n-            newBlock.getNumBytes());\n-        successList.add(r);\n-      } catch (IOException e) {\n-        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n-            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n-        failedList.add(r.id);\n+      // Calculate list of nodes that will participate in the recovery\n+      // and the new block size\n+      List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n+      final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n+          -1, recoveryId);\n+      switch(bestState) {\n+      case FINALIZED:\n+        assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n+        for(BlockRecord r : syncList) {\n+          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n+          if (rState \u003d\u003d ReplicaState.FINALIZED ||\n+              rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n+                  r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n+            participatingList.add(r);\n+          }\n+        }\n+        newBlock.setNumBytes(finalizedLength);\n+        break;\n+      case RBW:\n+      case RWR:\n+        long minLength \u003d Long.MAX_VALUE;\n+        for(BlockRecord r : syncList) {\n+          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n+          if(rState \u003d\u003d bestState) {\n+            minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n+            participatingList.add(r);\n+          }\n+        }\n+        newBlock.setNumBytes(minLength);\n+        break;\n+      case RUR:\n+      case TEMPORARY:\n+        assert false : \"bad replica state: \" + bestState;\n+      default:\n+        break; // we have \u0027case\u0027 all enum values\n       }\n-    }\n-\n-    // If any of the data-nodes failed, the recovery fails, because\n-    // we never know the actual state of the replica on failed data-nodes.\n-    // The recovery should be started over.\n-    if(!failedList.isEmpty()) {\n-      StringBuilder b \u003d new StringBuilder();\n-      for(DatanodeID id : failedList) {\n-        b.append(\"\\n  \" + id);\n+      if (isTruncateRecovery) {\n+        newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n       }\n-      throw new IOException(\"Cannot recover \" + block + \", the following \"\n-          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n-    }\n \n-    // Notify the name-node about successfully recovered replicas.\n-    final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n-    final String[] storages \u003d new String[datanodes.length];\n-    for(int i \u003d 0; i \u003c datanodes.length; i++) {\n-      final BlockRecord r \u003d successList.get(i);\n-      datanodes[i] \u003d r.id;\n-      storages[i] \u003d r.storageID;\n-    }\n-    nn.commitBlockSynchronization(block,\n-        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n-        datanodes, storages);\n-  }\n\\ No newline at end of file\n+      List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n+      final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n+      for (BlockRecord r : participatingList) {\n+        try {\n+          r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n+              newBlock.getNumBytes());\n+          successList.add(r);\n+        } catch (IOException e) {\n+          InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n+              + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n+          failedList.add(r.id);\n+        }\n+      }\n+\n+      // If any of the data-nodes failed, the recovery fails, because\n+      // we never know the actual state of the replica on failed data-nodes.\n+      // The recovery should be started over.\n+      if (!failedList.isEmpty()) {\n+        StringBuilder b \u003d new StringBuilder();\n+        for(DatanodeID id : failedList) {\n+          b.append(\"\\n  \" + id);\n+        }\n+        throw new IOException(\"Cannot recover \" + block + \", the following \"\n+            + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n+      }\n+\n+      // Notify the name-node about successfully recovered replicas.\n+      final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n+      final String[] storages \u003d new String[datanodes.length];\n+      for (int i \u003d 0; i \u003c datanodes.length; i++) {\n+        final BlockRecord r \u003d successList.get(i);\n+        datanodes[i] \u003d r.id;\n+        storages[i] \u003d r.storageID;\n+      }\n+      nn.commitBlockSynchronization(block,\n+          newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n+          datanodes, storages);\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n      DatanodeProtocolClientSideTranslatorPB nn \u003d\n          getActiveNamenodeForBP(block.getBlockPoolId());\n\n      boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n      long blockId \u003d (isTruncateRecovery) ?\n          rBlock.getNewBlock().getBlockId() : block.getBlockId();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n            + \"), syncList\u003d\" + syncList);\n      }\n\n      // syncList.isEmpty() means that all data-nodes do not have the block\n      // or their replicas have 0 length.\n      // The block can be deleted.\n      if (syncList.isEmpty()) {\n        nn.commitBlockSynchronization(block, recoveryId, 0,\n            true, true, DatanodeID.EMPTY_ARRAY, null);\n        return;\n      }\n\n      // Calculate the best available replica state.\n      ReplicaState bestState \u003d ReplicaState.RWR;\n      long finalizedLength \u003d -1;\n      for (BlockRecord r : syncList) {\n        assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if (rState.getValue() \u003c bestState.getValue()) {\n          bestState \u003d rState;\n        }\n        if(rState \u003d\u003d ReplicaState.FINALIZED) {\n          if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n            throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n          }\n          finalizedLength \u003d r.rInfo.getNumBytes();\n        }\n      }\n\n      // Calculate list of nodes that will participate in the recovery\n      // and the new block size\n      List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n      final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n          -1, recoveryId);\n      switch(bestState) {\n      case FINALIZED:\n        assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if (rState \u003d\u003d ReplicaState.FINALIZED ||\n              rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                  r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n            participatingList.add(r);\n          }\n        }\n        newBlock.setNumBytes(finalizedLength);\n        break;\n      case RBW:\n      case RWR:\n        long minLength \u003d Long.MAX_VALUE;\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if(rState \u003d\u003d bestState) {\n            minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n            participatingList.add(r);\n          }\n        }\n        newBlock.setNumBytes(minLength);\n        break;\n      case RUR:\n      case TEMPORARY:\n        assert false : \"bad replica state: \" + bestState;\n      default:\n        break; // we have \u0027case\u0027 all enum values\n      }\n      if (isTruncateRecovery) {\n        newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n      }\n\n      List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n      final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n      for (BlockRecord r : participatingList) {\n        try {\n          r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n              newBlock.getNumBytes());\n          successList.add(r);\n        } catch (IOException e) {\n          InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n              + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n          failedList.add(r.id);\n        }\n      }\n\n      // If any of the data-nodes failed, the recovery fails, because\n      // we never know the actual state of the replica on failed data-nodes.\n      // The recovery should be started over.\n      if (!failedList.isEmpty()) {\n        StringBuilder b \u003d new StringBuilder();\n        for(DatanodeID id : failedList) {\n          b.append(\"\\n  \" + id);\n        }\n        throw new IOException(\"Cannot recover \" + block + \", the following \"\n            + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n      }\n\n      // Notify the name-node about successfully recovered replicas.\n      final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n      final String[] storages \u003d new String[datanodes.length];\n      for (int i \u003d 0; i \u003c datanodes.length; i++) {\n        final BlockRecord r \u003d successList.get(i);\n        datanodes[i] \u003d r.id;\n        storages[i] \u003d r.storageID;\n      }\n      nn.commitBlockSynchronization(block,\n          newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n          datanodes, storages);\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockRecoveryWorker.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockRecoveryWorker.java",
            "oldMethodName": "syncBlock",
            "newMethodName": "syncBlock"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9255. Consolidate block recovery related implementation into a single class. Contributed by Walter Su.\n\nChange-Id: I7a1c03f50123d79ac0a78c981d9721617e3229d1\n",
          "commitDate": "28/10/15 7:34 AM",
          "commitName": "e287e7d14b838a866ba03d895fa35819999d7c09",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "28/10/15 3:36 AM",
          "commitNameOld": "a04b16970b0dbe903ac9a3a2a3080cf6de181bc2",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,116 +1,118 @@\n-  void syncBlock(RecoveringBlock rBlock,\n-                         List\u003cBlockRecord\u003e syncList) throws IOException {\n-    ExtendedBlock block \u003d rBlock.getBlock();\n-    final String bpid \u003d block.getBlockPoolId();\n-    DatanodeProtocolClientSideTranslatorPB nn \u003d\n-      getActiveNamenodeForBP(block.getBlockPoolId());\n+    void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n+      DatanodeProtocolClientSideTranslatorPB nn \u003d\n+          getActiveNamenodeForBP(block.getBlockPoolId());\n \n-    long recoveryId \u003d rBlock.getNewGenerationStamp();\n-    boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n-    long blockId \u003d (isTruncateRecovery) ?\n-        rBlock.getNewBlock().getBlockId() : block.getBlockId();\n+      boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n+      long blockId \u003d (isTruncateRecovery) ?\n+          rBlock.getNewBlock().getBlockId() : block.getBlockId();\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n-          + \"), syncList\u003d\" + syncList);\n-    }\n-\n-    // syncList.isEmpty() means that all data-nodes do not have the block\n-    // or their replicas have 0 length.\n-    // The block can be deleted.\n-    if (syncList.isEmpty()) {\n-      nn.commitBlockSynchronization(block, recoveryId, 0,\n-          true, true, DatanodeID.EMPTY_ARRAY, null);\n-      return;\n-    }\n-\n-    // Calculate the best available replica state.\n-    ReplicaState bestState \u003d ReplicaState.RWR;\n-    long finalizedLength \u003d -1;\n-    for(BlockRecord r : syncList) {\n-      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n-      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n-      if(rState.getValue() \u003c bestState.getValue())\n-        bestState \u003d rState;\n-      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n-        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n-          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n-              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n-        finalizedLength \u003d r.rInfo.getNumBytes();\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n+            + \"), syncList\u003d\" + syncList);\n       }\n-    }\n \n-    // Calculate list of nodes that will participate in the recovery\n-    // and the new block size\n-    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n-    final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n-        -1, recoveryId);\n-    switch(bestState) {\n-    case FINALIZED:\n-      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n-      for(BlockRecord r : syncList) {\n-        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n-        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n-           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n-                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n-          participatingList.add(r);\n+      // syncList.isEmpty() means that all data-nodes do not have the block\n+      // or their replicas have 0 length.\n+      // The block can be deleted.\n+      if (syncList.isEmpty()) {\n+        nn.commitBlockSynchronization(block, recoveryId, 0,\n+            true, true, DatanodeID.EMPTY_ARRAY, null);\n+        return;\n       }\n-      newBlock.setNumBytes(finalizedLength);\n-      break;\n-    case RBW:\n-    case RWR:\n-      long minLength \u003d Long.MAX_VALUE;\n-      for(BlockRecord r : syncList) {\n+\n+      // Calculate the best available replica state.\n+      ReplicaState bestState \u003d ReplicaState.RWR;\n+      long finalizedLength \u003d -1;\n+      for (BlockRecord r : syncList) {\n+        assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n-        if(rState \u003d\u003d bestState) {\n-          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n-          participatingList.add(r);\n+        if (rState.getValue() \u003c bestState.getValue()) {\n+          bestState \u003d rState;\n+        }\n+        if(rState \u003d\u003d ReplicaState.FINALIZED) {\n+          if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n+            throw new IOException(\"Inconsistent size of finalized replicas. \" +\n+                \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n+          }\n+          finalizedLength \u003d r.rInfo.getNumBytes();\n         }\n       }\n-      newBlock.setNumBytes(minLength);\n-      break;\n-    case RUR:\n-    case TEMPORARY:\n-      assert false : \"bad replica state: \" + bestState;\n-    }\n-    if(isTruncateRecovery)\n-      newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n \n-    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n-    final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003cBlockRecord\u003e();\n-    for(BlockRecord r : participatingList) {\n-      try {\n-        r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n-            newBlock.getNumBytes());\n-        successList.add(r);\n-      } catch (IOException e) {\n-        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n-            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n-        failedList.add(r.id);\n+      // Calculate list of nodes that will participate in the recovery\n+      // and the new block size\n+      List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n+      final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n+          -1, recoveryId);\n+      switch(bestState) {\n+      case FINALIZED:\n+        assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n+        for(BlockRecord r : syncList) {\n+          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n+          if (rState \u003d\u003d ReplicaState.FINALIZED ||\n+              rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n+                  r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n+            participatingList.add(r);\n+          }\n+        }\n+        newBlock.setNumBytes(finalizedLength);\n+        break;\n+      case RBW:\n+      case RWR:\n+        long minLength \u003d Long.MAX_VALUE;\n+        for(BlockRecord r : syncList) {\n+          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n+          if(rState \u003d\u003d bestState) {\n+            minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n+            participatingList.add(r);\n+          }\n+        }\n+        newBlock.setNumBytes(minLength);\n+        break;\n+      case RUR:\n+      case TEMPORARY:\n+        assert false : \"bad replica state: \" + bestState;\n+      default:\n+        break; // we have \u0027case\u0027 all enum values\n       }\n-    }\n-\n-    // If any of the data-nodes failed, the recovery fails, because\n-    // we never know the actual state of the replica on failed data-nodes.\n-    // The recovery should be started over.\n-    if(!failedList.isEmpty()) {\n-      StringBuilder b \u003d new StringBuilder();\n-      for(DatanodeID id : failedList) {\n-        b.append(\"\\n  \" + id);\n+      if (isTruncateRecovery) {\n+        newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n       }\n-      throw new IOException(\"Cannot recover \" + block + \", the following \"\n-          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n-    }\n \n-    // Notify the name-node about successfully recovered replicas.\n-    final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n-    final String[] storages \u003d new String[datanodes.length];\n-    for(int i \u003d 0; i \u003c datanodes.length; i++) {\n-      final BlockRecord r \u003d successList.get(i);\n-      datanodes[i] \u003d r.id;\n-      storages[i] \u003d r.storageID;\n-    }\n-    nn.commitBlockSynchronization(block,\n-        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n-        datanodes, storages);\n-  }\n\\ No newline at end of file\n+      List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n+      final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n+      for (BlockRecord r : participatingList) {\n+        try {\n+          r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n+              newBlock.getNumBytes());\n+          successList.add(r);\n+        } catch (IOException e) {\n+          InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n+              + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n+          failedList.add(r.id);\n+        }\n+      }\n+\n+      // If any of the data-nodes failed, the recovery fails, because\n+      // we never know the actual state of the replica on failed data-nodes.\n+      // The recovery should be started over.\n+      if (!failedList.isEmpty()) {\n+        StringBuilder b \u003d new StringBuilder();\n+        for(DatanodeID id : failedList) {\n+          b.append(\"\\n  \" + id);\n+        }\n+        throw new IOException(\"Cannot recover \" + block + \", the following \"\n+            + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n+      }\n+\n+      // Notify the name-node about successfully recovered replicas.\n+      final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n+      final String[] storages \u003d new String[datanodes.length];\n+      for (int i \u003d 0; i \u003c datanodes.length; i++) {\n+        final BlockRecord r \u003d successList.get(i);\n+        datanodes[i] \u003d r.id;\n+        storages[i] \u003d r.storageID;\n+      }\n+      nn.commitBlockSynchronization(block,\n+          newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n+          datanodes, storages);\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n      DatanodeProtocolClientSideTranslatorPB nn \u003d\n          getActiveNamenodeForBP(block.getBlockPoolId());\n\n      boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n      long blockId \u003d (isTruncateRecovery) ?\n          rBlock.getNewBlock().getBlockId() : block.getBlockId();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n            + \"), syncList\u003d\" + syncList);\n      }\n\n      // syncList.isEmpty() means that all data-nodes do not have the block\n      // or their replicas have 0 length.\n      // The block can be deleted.\n      if (syncList.isEmpty()) {\n        nn.commitBlockSynchronization(block, recoveryId, 0,\n            true, true, DatanodeID.EMPTY_ARRAY, null);\n        return;\n      }\n\n      // Calculate the best available replica state.\n      ReplicaState bestState \u003d ReplicaState.RWR;\n      long finalizedLength \u003d -1;\n      for (BlockRecord r : syncList) {\n        assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if (rState.getValue() \u003c bestState.getValue()) {\n          bestState \u003d rState;\n        }\n        if(rState \u003d\u003d ReplicaState.FINALIZED) {\n          if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n            throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n          }\n          finalizedLength \u003d r.rInfo.getNumBytes();\n        }\n      }\n\n      // Calculate list of nodes that will participate in the recovery\n      // and the new block size\n      List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n      final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n          -1, recoveryId);\n      switch(bestState) {\n      case FINALIZED:\n        assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if (rState \u003d\u003d ReplicaState.FINALIZED ||\n              rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                  r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n            participatingList.add(r);\n          }\n        }\n        newBlock.setNumBytes(finalizedLength);\n        break;\n      case RBW:\n      case RWR:\n        long minLength \u003d Long.MAX_VALUE;\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if(rState \u003d\u003d bestState) {\n            minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n            participatingList.add(r);\n          }\n        }\n        newBlock.setNumBytes(minLength);\n        break;\n      case RUR:\n      case TEMPORARY:\n        assert false : \"bad replica state: \" + bestState;\n      default:\n        break; // we have \u0027case\u0027 all enum values\n      }\n      if (isTruncateRecovery) {\n        newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n      }\n\n      List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n      final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n      for (BlockRecord r : participatingList) {\n        try {\n          r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n              newBlock.getNumBytes());\n          successList.add(r);\n        } catch (IOException e) {\n          InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n              + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n          failedList.add(r.id);\n        }\n      }\n\n      // If any of the data-nodes failed, the recovery fails, because\n      // we never know the actual state of the replica on failed data-nodes.\n      // The recovery should be started over.\n      if (!failedList.isEmpty()) {\n        StringBuilder b \u003d new StringBuilder();\n        for(DatanodeID id : failedList) {\n          b.append(\"\\n  \" + id);\n        }\n        throw new IOException(\"Cannot recover \" + block + \", the following \"\n            + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n      }\n\n      // Notify the name-node about successfully recovered replicas.\n      final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n      final String[] storages \u003d new String[datanodes.length];\n      for (int i \u003d 0; i \u003c datanodes.length; i++) {\n        final BlockRecord r \u003d successList.get(i);\n        datanodes[i] \u003d r.id;\n        storages[i] \u003d r.storageID;\n      }\n      nn.commitBlockSynchronization(block,\n          newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n          datanodes, storages);\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockRecoveryWorker.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9255. Consolidate block recovery related implementation into a single class. Contributed by Walter Su.\n\nChange-Id: I7a1c03f50123d79ac0a78c981d9721617e3229d1\n",
          "commitDate": "28/10/15 7:34 AM",
          "commitName": "e287e7d14b838a866ba03d895fa35819999d7c09",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "28/10/15 3:36 AM",
          "commitNameOld": "a04b16970b0dbe903ac9a3a2a3080cf6de181bc2",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,116 +1,118 @@\n-  void syncBlock(RecoveringBlock rBlock,\n-                         List\u003cBlockRecord\u003e syncList) throws IOException {\n-    ExtendedBlock block \u003d rBlock.getBlock();\n-    final String bpid \u003d block.getBlockPoolId();\n-    DatanodeProtocolClientSideTranslatorPB nn \u003d\n-      getActiveNamenodeForBP(block.getBlockPoolId());\n+    void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n+      DatanodeProtocolClientSideTranslatorPB nn \u003d\n+          getActiveNamenodeForBP(block.getBlockPoolId());\n \n-    long recoveryId \u003d rBlock.getNewGenerationStamp();\n-    boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n-    long blockId \u003d (isTruncateRecovery) ?\n-        rBlock.getNewBlock().getBlockId() : block.getBlockId();\n+      boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n+      long blockId \u003d (isTruncateRecovery) ?\n+          rBlock.getNewBlock().getBlockId() : block.getBlockId();\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n-          + \"), syncList\u003d\" + syncList);\n-    }\n-\n-    // syncList.isEmpty() means that all data-nodes do not have the block\n-    // or their replicas have 0 length.\n-    // The block can be deleted.\n-    if (syncList.isEmpty()) {\n-      nn.commitBlockSynchronization(block, recoveryId, 0,\n-          true, true, DatanodeID.EMPTY_ARRAY, null);\n-      return;\n-    }\n-\n-    // Calculate the best available replica state.\n-    ReplicaState bestState \u003d ReplicaState.RWR;\n-    long finalizedLength \u003d -1;\n-    for(BlockRecord r : syncList) {\n-      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n-      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n-      if(rState.getValue() \u003c bestState.getValue())\n-        bestState \u003d rState;\n-      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n-        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n-          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n-              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n-        finalizedLength \u003d r.rInfo.getNumBytes();\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n+            + \"), syncList\u003d\" + syncList);\n       }\n-    }\n \n-    // Calculate list of nodes that will participate in the recovery\n-    // and the new block size\n-    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n-    final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n-        -1, recoveryId);\n-    switch(bestState) {\n-    case FINALIZED:\n-      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n-      for(BlockRecord r : syncList) {\n-        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n-        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n-           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n-                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n-          participatingList.add(r);\n+      // syncList.isEmpty() means that all data-nodes do not have the block\n+      // or their replicas have 0 length.\n+      // The block can be deleted.\n+      if (syncList.isEmpty()) {\n+        nn.commitBlockSynchronization(block, recoveryId, 0,\n+            true, true, DatanodeID.EMPTY_ARRAY, null);\n+        return;\n       }\n-      newBlock.setNumBytes(finalizedLength);\n-      break;\n-    case RBW:\n-    case RWR:\n-      long minLength \u003d Long.MAX_VALUE;\n-      for(BlockRecord r : syncList) {\n+\n+      // Calculate the best available replica state.\n+      ReplicaState bestState \u003d ReplicaState.RWR;\n+      long finalizedLength \u003d -1;\n+      for (BlockRecord r : syncList) {\n+        assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n-        if(rState \u003d\u003d bestState) {\n-          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n-          participatingList.add(r);\n+        if (rState.getValue() \u003c bestState.getValue()) {\n+          bestState \u003d rState;\n+        }\n+        if(rState \u003d\u003d ReplicaState.FINALIZED) {\n+          if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n+            throw new IOException(\"Inconsistent size of finalized replicas. \" +\n+                \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n+          }\n+          finalizedLength \u003d r.rInfo.getNumBytes();\n         }\n       }\n-      newBlock.setNumBytes(minLength);\n-      break;\n-    case RUR:\n-    case TEMPORARY:\n-      assert false : \"bad replica state: \" + bestState;\n-    }\n-    if(isTruncateRecovery)\n-      newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n \n-    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n-    final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003cBlockRecord\u003e();\n-    for(BlockRecord r : participatingList) {\n-      try {\n-        r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n-            newBlock.getNumBytes());\n-        successList.add(r);\n-      } catch (IOException e) {\n-        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n-            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n-        failedList.add(r.id);\n+      // Calculate list of nodes that will participate in the recovery\n+      // and the new block size\n+      List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n+      final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n+          -1, recoveryId);\n+      switch(bestState) {\n+      case FINALIZED:\n+        assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n+        for(BlockRecord r : syncList) {\n+          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n+          if (rState \u003d\u003d ReplicaState.FINALIZED ||\n+              rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n+                  r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n+            participatingList.add(r);\n+          }\n+        }\n+        newBlock.setNumBytes(finalizedLength);\n+        break;\n+      case RBW:\n+      case RWR:\n+        long minLength \u003d Long.MAX_VALUE;\n+        for(BlockRecord r : syncList) {\n+          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n+          if(rState \u003d\u003d bestState) {\n+            minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n+            participatingList.add(r);\n+          }\n+        }\n+        newBlock.setNumBytes(minLength);\n+        break;\n+      case RUR:\n+      case TEMPORARY:\n+        assert false : \"bad replica state: \" + bestState;\n+      default:\n+        break; // we have \u0027case\u0027 all enum values\n       }\n-    }\n-\n-    // If any of the data-nodes failed, the recovery fails, because\n-    // we never know the actual state of the replica on failed data-nodes.\n-    // The recovery should be started over.\n-    if(!failedList.isEmpty()) {\n-      StringBuilder b \u003d new StringBuilder();\n-      for(DatanodeID id : failedList) {\n-        b.append(\"\\n  \" + id);\n+      if (isTruncateRecovery) {\n+        newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n       }\n-      throw new IOException(\"Cannot recover \" + block + \", the following \"\n-          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n-    }\n \n-    // Notify the name-node about successfully recovered replicas.\n-    final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n-    final String[] storages \u003d new String[datanodes.length];\n-    for(int i \u003d 0; i \u003c datanodes.length; i++) {\n-      final BlockRecord r \u003d successList.get(i);\n-      datanodes[i] \u003d r.id;\n-      storages[i] \u003d r.storageID;\n-    }\n-    nn.commitBlockSynchronization(block,\n-        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n-        datanodes, storages);\n-  }\n\\ No newline at end of file\n+      List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n+      final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n+      for (BlockRecord r : participatingList) {\n+        try {\n+          r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n+              newBlock.getNumBytes());\n+          successList.add(r);\n+        } catch (IOException e) {\n+          InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n+              + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n+          failedList.add(r.id);\n+        }\n+      }\n+\n+      // If any of the data-nodes failed, the recovery fails, because\n+      // we never know the actual state of the replica on failed data-nodes.\n+      // The recovery should be started over.\n+      if (!failedList.isEmpty()) {\n+        StringBuilder b \u003d new StringBuilder();\n+        for(DatanodeID id : failedList) {\n+          b.append(\"\\n  \" + id);\n+        }\n+        throw new IOException(\"Cannot recover \" + block + \", the following \"\n+            + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n+      }\n+\n+      // Notify the name-node about successfully recovered replicas.\n+      final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n+      final String[] storages \u003d new String[datanodes.length];\n+      for (int i \u003d 0; i \u003c datanodes.length; i++) {\n+        final BlockRecord r \u003d successList.get(i);\n+        datanodes[i] \u003d r.id;\n+        storages[i] \u003d r.storageID;\n+      }\n+      nn.commitBlockSynchronization(block,\n+          newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n+          datanodes, storages);\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    void syncBlock(List\u003cBlockRecord\u003e syncList) throws IOException {\n      DatanodeProtocolClientSideTranslatorPB nn \u003d\n          getActiveNamenodeForBP(block.getBlockPoolId());\n\n      boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n      long blockId \u003d (isTruncateRecovery) ?\n          rBlock.getNewBlock().getBlockId() : block.getBlockId();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n            + \"), syncList\u003d\" + syncList);\n      }\n\n      // syncList.isEmpty() means that all data-nodes do not have the block\n      // or their replicas have 0 length.\n      // The block can be deleted.\n      if (syncList.isEmpty()) {\n        nn.commitBlockSynchronization(block, recoveryId, 0,\n            true, true, DatanodeID.EMPTY_ARRAY, null);\n        return;\n      }\n\n      // Calculate the best available replica state.\n      ReplicaState bestState \u003d ReplicaState.RWR;\n      long finalizedLength \u003d -1;\n      for (BlockRecord r : syncList) {\n        assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if (rState.getValue() \u003c bestState.getValue()) {\n          bestState \u003d rState;\n        }\n        if(rState \u003d\u003d ReplicaState.FINALIZED) {\n          if (finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes()) {\n            throw new IOException(\"Inconsistent size of finalized replicas. \" +\n                \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n          }\n          finalizedLength \u003d r.rInfo.getNumBytes();\n        }\n      }\n\n      // Calculate list of nodes that will participate in the recovery\n      // and the new block size\n      List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003c\u003e();\n      final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n          -1, recoveryId);\n      switch(bestState) {\n      case FINALIZED:\n        assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if (rState \u003d\u003d ReplicaState.FINALIZED ||\n              rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                  r.rInfo.getNumBytes() \u003d\u003d finalizedLength) {\n            participatingList.add(r);\n          }\n        }\n        newBlock.setNumBytes(finalizedLength);\n        break;\n      case RBW:\n      case RWR:\n        long minLength \u003d Long.MAX_VALUE;\n        for(BlockRecord r : syncList) {\n          ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n          if(rState \u003d\u003d bestState) {\n            minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n            participatingList.add(r);\n          }\n        }\n        newBlock.setNumBytes(minLength);\n        break;\n      case RUR:\n      case TEMPORARY:\n        assert false : \"bad replica state: \" + bestState;\n      default:\n        break; // we have \u0027case\u0027 all enum values\n      }\n      if (isTruncateRecovery) {\n        newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n      }\n\n      List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003c\u003e();\n      final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003c\u003e();\n      for (BlockRecord r : participatingList) {\n        try {\n          r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n              newBlock.getNumBytes());\n          successList.add(r);\n        } catch (IOException e) {\n          InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n              + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n          failedList.add(r.id);\n        }\n      }\n\n      // If any of the data-nodes failed, the recovery fails, because\n      // we never know the actual state of the replica on failed data-nodes.\n      // The recovery should be started over.\n      if (!failedList.isEmpty()) {\n        StringBuilder b \u003d new StringBuilder();\n        for(DatanodeID id : failedList) {\n          b.append(\"\\n  \" + id);\n        }\n        throw new IOException(\"Cannot recover \" + block + \", the following \"\n            + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n      }\n\n      // Notify the name-node about successfully recovered replicas.\n      final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n      final String[] storages \u003d new String[datanodes.length];\n      for (int i \u003d 0; i \u003c datanodes.length; i++) {\n        final BlockRecord r \u003d successList.get(i);\n        datanodes[i] \u003d r.id;\n        storages[i] \u003d r.storageID;\n      }\n      nn.commitBlockSynchronization(block,\n          newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n          datanodes, storages);\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockRecoveryWorker.java",
          "extendedDetails": {
            "oldValue": "[rBlock-RecoveringBlock, syncList-List\u003cBlockRecord\u003e]",
            "newValue": "[syncList-List\u003cBlockRecord\u003e]"
          }
        }
      ]
    },
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7056. Snapshot support for truncate. Contributed by Konstantin Shvachko and Plamen Jeliazkov.",
      "commitDate": "13/01/15 12:24 AM",
      "commitName": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "12/01/15 10:50 PM",
      "commitNameOld": "7e9358feb326d48b8c4f00249e7af5023cebd2e2",
      "commitAuthorOld": "Plamen Jeliazkov",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,116 @@\n   void syncBlock(RecoveringBlock rBlock,\n                          List\u003cBlockRecord\u003e syncList) throws IOException {\n     ExtendedBlock block \u003d rBlock.getBlock();\n     final String bpid \u003d block.getBlockPoolId();\n     DatanodeProtocolClientSideTranslatorPB nn \u003d\n       getActiveNamenodeForBP(block.getBlockPoolId());\n-    \n+\n     long recoveryId \u003d rBlock.getNewGenerationStamp();\n+    boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n+    long blockId \u003d (isTruncateRecovery) ?\n+        rBlock.getNewBlock().getBlockId() : block.getBlockId();\n+\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n           + \"), syncList\u003d\" + syncList);\n     }\n \n     // syncList.isEmpty() means that all data-nodes do not have the block\n     // or their replicas have 0 length.\n     // The block can be deleted.\n     if (syncList.isEmpty()) {\n       nn.commitBlockSynchronization(block, recoveryId, 0,\n           true, true, DatanodeID.EMPTY_ARRAY, null);\n       return;\n     }\n \n     // Calculate the best available replica state.\n     ReplicaState bestState \u003d ReplicaState.RWR;\n     long finalizedLength \u003d -1;\n     for(BlockRecord r : syncList) {\n       assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n       ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n       if(rState.getValue() \u003c bestState.getValue())\n         bestState \u003d rState;\n       if(rState \u003d\u003d ReplicaState.FINALIZED) {\n         if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n           throw new IOException(\"Inconsistent size of finalized replicas. \" +\n               \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n         finalizedLength \u003d r.rInfo.getNumBytes();\n       }\n     }\n \n     // Calculate list of nodes that will participate in the recovery\n     // and the new block size\n     List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n-    final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, block.getBlockId(),\n+    final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n         -1, recoveryId);\n     switch(bestState) {\n     case FINALIZED:\n       assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d ReplicaState.FINALIZED ||\n            rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                       r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n           participatingList.add(r);\n       }\n-      if(rBlock.getTruncateFlag())\n-        newBlock.setNumBytes(rBlock.getBlock().getNumBytes());\n-      else\n-        newBlock.setNumBytes(finalizedLength);\n+      newBlock.setNumBytes(finalizedLength);\n       break;\n     case RBW:\n     case RWR:\n       long minLength \u003d Long.MAX_VALUE;\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d bestState) {\n           minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n           participatingList.add(r);\n         }\n       }\n-      if(rBlock.getTruncateFlag())\n-        newBlock.setNumBytes(rBlock.getBlock().getNumBytes());\n-      else\n-        newBlock.setNumBytes(minLength);\n+      newBlock.setNumBytes(minLength);\n       break;\n     case RUR:\n     case TEMPORARY:\n       assert false : \"bad replica state: \" + bestState;\n     }\n+    if(isTruncateRecovery)\n+      newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n \n     List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n     final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003cBlockRecord\u003e();\n     for(BlockRecord r : participatingList) {\n       try {\n-        r.updateReplicaUnderRecovery(bpid, recoveryId, newBlock.getNumBytes());\n+        r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n+            newBlock.getNumBytes());\n         successList.add(r);\n       } catch (IOException e) {\n         InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n             + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n         failedList.add(r.id);\n       }\n     }\n \n     // If any of the data-nodes failed, the recovery fails, because\n     // we never know the actual state of the replica on failed data-nodes.\n     // The recovery should be started over.\n     if(!failedList.isEmpty()) {\n       StringBuilder b \u003d new StringBuilder();\n       for(DatanodeID id : failedList) {\n         b.append(\"\\n  \" + id);\n       }\n       throw new IOException(\"Cannot recover \" + block + \", the following \"\n           + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n     }\n \n     // Notify the name-node about successfully recovered replicas.\n     final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n     final String[] storages \u003d new String[datanodes.length];\n     for(int i \u003d 0; i \u003c datanodes.length; i++) {\n       final BlockRecord r \u003d successList.get(i);\n       datanodes[i] \u003d r.id;\n       storages[i] \u003d r.storageID;\n     }\n     nn.commitBlockSynchronization(block,\n         newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n         datanodes, storages);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    final String bpid \u003d block.getBlockPoolId();\n    DatanodeProtocolClientSideTranslatorPB nn \u003d\n      getActiveNamenodeForBP(block.getBlockPoolId());\n\n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    boolean isTruncateRecovery \u003d rBlock.getNewBlock() !\u003d null;\n    long blockId \u003d (isTruncateRecovery) ?\n        rBlock.getNewBlock().getBlockId() : block.getBlockId();\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY, null);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, blockId,\n        -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n    if(isTruncateRecovery)\n      newBlock.setNumBytes(rBlock.getNewBlock().getNumBytes());\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003cBlockRecord\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        r.updateReplicaUnderRecovery(bpid, recoveryId, blockId,\n            newBlock.getNumBytes());\n        successList.add(r);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n    final String[] storages \u003d new String[datanodes.length];\n    for(int i \u003d 0; i \u003c datanodes.length; i++) {\n      final BlockRecord r \u003d successList.get(i);\n      datanodes[i] \u003d r.id;\n      storages[i] \u003d r.storageID;\n    }\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        datanodes, storages);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "7e9358feb326d48b8c4f00249e7af5023cebd2e2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3107. Introduce truncate. Contributed by Plamen Jeliazkov.",
      "commitDate": "12/01/15 10:50 PM",
      "commitName": "7e9358feb326d48b8c4f00249e7af5023cebd2e2",
      "commitAuthor": "Plamen Jeliazkov",
      "commitDateOld": "12/01/15 1:36 PM",
      "commitNameOld": "6bbf9fdd041d2413dd78e2bce51abae15f3334c2",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.38,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,115 @@\n   void syncBlock(RecoveringBlock rBlock,\n                          List\u003cBlockRecord\u003e syncList) throws IOException {\n     ExtendedBlock block \u003d rBlock.getBlock();\n     final String bpid \u003d block.getBlockPoolId();\n     DatanodeProtocolClientSideTranslatorPB nn \u003d\n       getActiveNamenodeForBP(block.getBlockPoolId());\n     \n     long recoveryId \u003d rBlock.getNewGenerationStamp();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n           + \"), syncList\u003d\" + syncList);\n     }\n \n     // syncList.isEmpty() means that all data-nodes do not have the block\n     // or their replicas have 0 length.\n     // The block can be deleted.\n     if (syncList.isEmpty()) {\n       nn.commitBlockSynchronization(block, recoveryId, 0,\n           true, true, DatanodeID.EMPTY_ARRAY, null);\n       return;\n     }\n \n     // Calculate the best available replica state.\n     ReplicaState bestState \u003d ReplicaState.RWR;\n     long finalizedLength \u003d -1;\n     for(BlockRecord r : syncList) {\n       assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n       ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n       if(rState.getValue() \u003c bestState.getValue())\n         bestState \u003d rState;\n       if(rState \u003d\u003d ReplicaState.FINALIZED) {\n         if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n           throw new IOException(\"Inconsistent size of finalized replicas. \" +\n               \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n         finalizedLength \u003d r.rInfo.getNumBytes();\n       }\n     }\n \n     // Calculate list of nodes that will participate in the recovery\n     // and the new block size\n     List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n     final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, block.getBlockId(),\n         -1, recoveryId);\n     switch(bestState) {\n     case FINALIZED:\n       assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d ReplicaState.FINALIZED ||\n            rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                       r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n           participatingList.add(r);\n       }\n-      newBlock.setNumBytes(finalizedLength);\n+      if(rBlock.getTruncateFlag())\n+        newBlock.setNumBytes(rBlock.getBlock().getNumBytes());\n+      else\n+        newBlock.setNumBytes(finalizedLength);\n       break;\n     case RBW:\n     case RWR:\n       long minLength \u003d Long.MAX_VALUE;\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d bestState) {\n           minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n           participatingList.add(r);\n         }\n       }\n-      newBlock.setNumBytes(minLength);\n+      if(rBlock.getTruncateFlag())\n+        newBlock.setNumBytes(rBlock.getBlock().getNumBytes());\n+      else\n+        newBlock.setNumBytes(minLength);\n       break;\n     case RUR:\n     case TEMPORARY:\n       assert false : \"bad replica state: \" + bestState;\n     }\n \n     List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n     final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003cBlockRecord\u003e();\n     for(BlockRecord r : participatingList) {\n       try {\n         r.updateReplicaUnderRecovery(bpid, recoveryId, newBlock.getNumBytes());\n         successList.add(r);\n       } catch (IOException e) {\n         InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n             + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n         failedList.add(r.id);\n       }\n     }\n \n     // If any of the data-nodes failed, the recovery fails, because\n     // we never know the actual state of the replica on failed data-nodes.\n     // The recovery should be started over.\n     if(!failedList.isEmpty()) {\n       StringBuilder b \u003d new StringBuilder();\n       for(DatanodeID id : failedList) {\n         b.append(\"\\n  \" + id);\n       }\n       throw new IOException(\"Cannot recover \" + block + \", the following \"\n           + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n     }\n \n     // Notify the name-node about successfully recovered replicas.\n     final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n     final String[] storages \u003d new String[datanodes.length];\n     for(int i \u003d 0; i \u003c datanodes.length; i++) {\n       final BlockRecord r \u003d successList.get(i);\n       datanodes[i] \u003d r.id;\n       storages[i] \u003d r.storageID;\n     }\n     nn.commitBlockSynchronization(block,\n         newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n         datanodes, storages);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    final String bpid \u003d block.getBlockPoolId();\n    DatanodeProtocolClientSideTranslatorPB nn \u003d\n      getActiveNamenodeForBP(block.getBlockPoolId());\n    \n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY, null);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, block.getBlockId(),\n        -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      if(rBlock.getTruncateFlag())\n        newBlock.setNumBytes(rBlock.getBlock().getNumBytes());\n      else\n        newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      if(rBlock.getTruncateFlag())\n        newBlock.setNumBytes(rBlock.getBlock().getNumBytes());\n      else\n        newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003cBlockRecord\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        r.updateReplicaUnderRecovery(bpid, recoveryId, newBlock.getNumBytes());\n        successList.add(r);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n    final String[] storages \u003d new String[datanodes.length];\n    for(int i \u003d 0; i \u003c datanodes.length; i++) {\n      final BlockRecord r \u003d successList.get(i);\n      datanodes[i] \u003d r.id;\n      storages[i] \u003d r.storageID;\n    }\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        datanodes, storages);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "6d4a0915676b8185a4727a10fcfeb40aa24cacc5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4034. Remove redundant null checks. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 2:38 PM",
      "commitName": "6d4a0915676b8185a4727a10fcfeb40aa24cacc5",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "08/01/13 12:44 PM",
      "commitNameOld": "239b2742d0e80d13c970fd062af4930e672fe903",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,109 @@\n   void syncBlock(RecoveringBlock rBlock,\n                          List\u003cBlockRecord\u003e syncList) throws IOException {\n     ExtendedBlock block \u003d rBlock.getBlock();\n     final String bpid \u003d block.getBlockPoolId();\n     DatanodeProtocolClientSideTranslatorPB nn \u003d\n       getActiveNamenodeForBP(block.getBlockPoolId());\n-    if (nn \u003d\u003d null) {\n-      throw new IOException(\n-          \"Unable to synchronize block \" + rBlock + \", since this DN \"\n-          + \" has not acknowledged any NN as active.\");\n-    }\n     \n     long recoveryId \u003d rBlock.getNewGenerationStamp();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n           + \"), syncList\u003d\" + syncList);\n     }\n \n     // syncList.isEmpty() means that all data-nodes do not have the block\n     // or their replicas have 0 length.\n     // The block can be deleted.\n     if (syncList.isEmpty()) {\n       nn.commitBlockSynchronization(block, recoveryId, 0,\n           true, true, DatanodeID.EMPTY_ARRAY, null);\n       return;\n     }\n \n     // Calculate the best available replica state.\n     ReplicaState bestState \u003d ReplicaState.RWR;\n     long finalizedLength \u003d -1;\n     for(BlockRecord r : syncList) {\n       assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n       ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n       if(rState.getValue() \u003c bestState.getValue())\n         bestState \u003d rState;\n       if(rState \u003d\u003d ReplicaState.FINALIZED) {\n         if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n           throw new IOException(\"Inconsistent size of finalized replicas. \" +\n               \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n         finalizedLength \u003d r.rInfo.getNumBytes();\n       }\n     }\n \n     // Calculate list of nodes that will participate in the recovery\n     // and the new block size\n     List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n     final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, block.getBlockId(),\n         -1, recoveryId);\n     switch(bestState) {\n     case FINALIZED:\n       assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d ReplicaState.FINALIZED ||\n            rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                       r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n           participatingList.add(r);\n       }\n       newBlock.setNumBytes(finalizedLength);\n       break;\n     case RBW:\n     case RWR:\n       long minLength \u003d Long.MAX_VALUE;\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d bestState) {\n           minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n           participatingList.add(r);\n         }\n       }\n       newBlock.setNumBytes(minLength);\n       break;\n     case RUR:\n     case TEMPORARY:\n       assert false : \"bad replica state: \" + bestState;\n     }\n \n     List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n     final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003cBlockRecord\u003e();\n     for(BlockRecord r : participatingList) {\n       try {\n         r.updateReplicaUnderRecovery(bpid, recoveryId, newBlock.getNumBytes());\n         successList.add(r);\n       } catch (IOException e) {\n         InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n             + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n         failedList.add(r.id);\n       }\n     }\n \n     // If any of the data-nodes failed, the recovery fails, because\n     // we never know the actual state of the replica on failed data-nodes.\n     // The recovery should be started over.\n     if(!failedList.isEmpty()) {\n       StringBuilder b \u003d new StringBuilder();\n       for(DatanodeID id : failedList) {\n         b.append(\"\\n  \" + id);\n       }\n       throw new IOException(\"Cannot recover \" + block + \", the following \"\n           + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n     }\n \n     // Notify the name-node about successfully recovered replicas.\n     final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n     final String[] storages \u003d new String[datanodes.length];\n     for(int i \u003d 0; i \u003c datanodes.length; i++) {\n       final BlockRecord r \u003d successList.get(i);\n       datanodes[i] \u003d r.id;\n       storages[i] \u003d r.storageID;\n     }\n     nn.commitBlockSynchronization(block,\n         newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n         datanodes, storages);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    final String bpid \u003d block.getBlockPoolId();\n    DatanodeProtocolClientSideTranslatorPB nn \u003d\n      getActiveNamenodeForBP(block.getBlockPoolId());\n    \n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY, null);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, block.getBlockId(),\n        -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003cBlockRecord\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        r.updateReplicaUnderRecovery(bpid, recoveryId, newBlock.getNumBytes());\n        successList.add(r);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n    final String[] storages \u003d new String[datanodes.length];\n    for(int i \u003d 0; i \u003c datanodes.length; i++) {\n      final BlockRecord r \u003d successList.get(i);\n      datanodes[i] \u003d r.id;\n      storages[i] \u003d r.storageID;\n    }\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        datanodes, storages);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "6326605acb5a5bf48d994278c9d3a39733679e81": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3105.  Add DatanodeStorage information to block recovery.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1302683 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/03/12 3:09 PM",
      "commitName": "6326605acb5a5bf48d994278c9d3a39733679e81",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "16/03/12 10:32 AM",
      "commitNameOld": "662b1887af4e39f3eadd7dda4953c7f2529b43bc",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.19,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,114 @@\n   void syncBlock(RecoveringBlock rBlock,\n                          List\u003cBlockRecord\u003e syncList) throws IOException {\n     ExtendedBlock block \u003d rBlock.getBlock();\n+    final String bpid \u003d block.getBlockPoolId();\n     DatanodeProtocolClientSideTranslatorPB nn \u003d\n       getActiveNamenodeForBP(block.getBlockPoolId());\n     if (nn \u003d\u003d null) {\n       throw new IOException(\n           \"Unable to synchronize block \" + rBlock + \", since this DN \"\n           + \" has not acknowledged any NN as active.\");\n     }\n     \n     long recoveryId \u003d rBlock.getNewGenerationStamp();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n           + \"), syncList\u003d\" + syncList);\n     }\n \n     // syncList.isEmpty() means that all data-nodes do not have the block\n     // or their replicas have 0 length.\n     // The block can be deleted.\n     if (syncList.isEmpty()) {\n       nn.commitBlockSynchronization(block, recoveryId, 0,\n-          true, true, DatanodeID.EMPTY_ARRAY);\n+          true, true, DatanodeID.EMPTY_ARRAY, null);\n       return;\n     }\n \n     // Calculate the best available replica state.\n     ReplicaState bestState \u003d ReplicaState.RWR;\n     long finalizedLength \u003d -1;\n     for(BlockRecord r : syncList) {\n       assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n       ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n       if(rState.getValue() \u003c bestState.getValue())\n         bestState \u003d rState;\n       if(rState \u003d\u003d ReplicaState.FINALIZED) {\n         if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n           throw new IOException(\"Inconsistent size of finalized replicas. \" +\n               \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n         finalizedLength \u003d r.rInfo.getNumBytes();\n       }\n     }\n \n     // Calculate list of nodes that will participate in the recovery\n     // and the new block size\n     List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n-    final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n-        .getBlockId(), -1, recoveryId);\n+    final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, block.getBlockId(),\n+        -1, recoveryId);\n     switch(bestState) {\n     case FINALIZED:\n       assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d ReplicaState.FINALIZED ||\n            rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                       r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n           participatingList.add(r);\n       }\n       newBlock.setNumBytes(finalizedLength);\n       break;\n     case RBW:\n     case RWR:\n       long minLength \u003d Long.MAX_VALUE;\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d bestState) {\n           minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n           participatingList.add(r);\n         }\n       }\n       newBlock.setNumBytes(minLength);\n       break;\n     case RUR:\n     case TEMPORARY:\n       assert false : \"bad replica state: \" + bestState;\n     }\n \n     List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n-    List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n+    final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003cBlockRecord\u003e();\n     for(BlockRecord r : participatingList) {\n       try {\n-        ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n-            new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n-            newBlock.getNumBytes());\n-        assert reply.equals(newBlock) \u0026\u0026\n-               reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n-          \"Updated replica must be the same as the new block.\";\n-        successList.add(r.id);\n+        r.updateReplicaUnderRecovery(bpid, recoveryId, newBlock.getNumBytes());\n+        successList.add(r);\n       } catch (IOException e) {\n         InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n             + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n         failedList.add(r.id);\n       }\n     }\n \n     // If any of the data-nodes failed, the recovery fails, because\n     // we never know the actual state of the replica on failed data-nodes.\n     // The recovery should be started over.\n     if(!failedList.isEmpty()) {\n       StringBuilder b \u003d new StringBuilder();\n       for(DatanodeID id : failedList) {\n         b.append(\"\\n  \" + id);\n       }\n       throw new IOException(\"Cannot recover \" + block + \", the following \"\n           + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n     }\n \n     // Notify the name-node about successfully recovered replicas.\n-    DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n+    final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n+    final String[] storages \u003d new String[datanodes.length];\n+    for(int i \u003d 0; i \u003c datanodes.length; i++) {\n+      final BlockRecord r \u003d successList.get(i);\n+      datanodes[i] \u003d r.id;\n+      storages[i] \u003d r.storageID;\n+    }\n     nn.commitBlockSynchronization(block,\n         newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n-        nlist);\n+        datanodes, storages);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    final String bpid \u003d block.getBlockPoolId();\n    DatanodeProtocolClientSideTranslatorPB nn \u003d\n      getActiveNamenodeForBP(block.getBlockPoolId());\n    if (nn \u003d\u003d null) {\n      throw new IOException(\n          \"Unable to synchronize block \" + rBlock + \", since this DN \"\n          + \" has not acknowledged any NN as active.\");\n    }\n    \n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY, null);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(bpid, block.getBlockId(),\n        -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    final List\u003cBlockRecord\u003e successList \u003d new ArrayList\u003cBlockRecord\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        r.updateReplicaUnderRecovery(bpid, recoveryId, newBlock.getNumBytes());\n        successList.add(r);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    final DatanodeID[] datanodes \u003d new DatanodeID[successList.size()];\n    final String[] storages \u003d new String[datanodes.length];\n    for(int i \u003d 0; i \u003c datanodes.length; i++) {\n      final BlockRecord r \u003d successList.get(i);\n      datanodes[i] \u003d r.id;\n      storages[i] \u003d r.storageID;\n    }\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        datanodes, storages);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "978a8050e28b2afb193a3e00d82a8475fa4d2428": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2920. fix remaining TODO items. Contributed by Aaron T. Myers and Todd Lipcon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1294923 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/02/12 5:09 PM",
      "commitName": "978a8050e28b2afb193a3e00d82a8475fa4d2428",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "23/02/12 8:06 AM",
      "commitNameOld": "f3026e10852c8bd48396b589733d3dd409405734",
      "commitAuthorOld": "",
      "daysBetweenCommits": 5.38,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,112 @@\n   void syncBlock(RecoveringBlock rBlock,\n                          List\u003cBlockRecord\u003e syncList) throws IOException {\n     ExtendedBlock block \u003d rBlock.getBlock();\n-    DatanodeProtocolClientSideTranslatorPB nn \u003d getBPNamenode(block\n-        .getBlockPoolId());\n-    assert nn !\u003d null;\n+    DatanodeProtocolClientSideTranslatorPB nn \u003d\n+      getActiveNamenodeForBP(block.getBlockPoolId());\n+    if (nn \u003d\u003d null) {\n+      throw new IOException(\n+          \"Unable to synchronize block \" + rBlock + \", since this DN \"\n+          + \" has not acknowledged any NN as active.\");\n+    }\n     \n     long recoveryId \u003d rBlock.getNewGenerationStamp();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n           + \"), syncList\u003d\" + syncList);\n     }\n \n     // syncList.isEmpty() means that all data-nodes do not have the block\n     // or their replicas have 0 length.\n     // The block can be deleted.\n     if (syncList.isEmpty()) {\n       nn.commitBlockSynchronization(block, recoveryId, 0,\n           true, true, DatanodeID.EMPTY_ARRAY);\n       return;\n     }\n \n     // Calculate the best available replica state.\n     ReplicaState bestState \u003d ReplicaState.RWR;\n     long finalizedLength \u003d -1;\n     for(BlockRecord r : syncList) {\n       assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n       ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n       if(rState.getValue() \u003c bestState.getValue())\n         bestState \u003d rState;\n       if(rState \u003d\u003d ReplicaState.FINALIZED) {\n         if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n           throw new IOException(\"Inconsistent size of finalized replicas. \" +\n               \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n         finalizedLength \u003d r.rInfo.getNumBytes();\n       }\n     }\n \n     // Calculate list of nodes that will participate in the recovery\n     // and the new block size\n     List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n     final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n         .getBlockId(), -1, recoveryId);\n     switch(bestState) {\n     case FINALIZED:\n       assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d ReplicaState.FINALIZED ||\n            rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                       r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n           participatingList.add(r);\n       }\n       newBlock.setNumBytes(finalizedLength);\n       break;\n     case RBW:\n     case RWR:\n       long minLength \u003d Long.MAX_VALUE;\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d bestState) {\n           minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n           participatingList.add(r);\n         }\n       }\n       newBlock.setNumBytes(minLength);\n       break;\n     case RUR:\n     case TEMPORARY:\n       assert false : \"bad replica state: \" + bestState;\n     }\n \n     List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n     List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n     for(BlockRecord r : participatingList) {\n       try {\n         ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n             new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n             newBlock.getNumBytes());\n         assert reply.equals(newBlock) \u0026\u0026\n                reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n           \"Updated replica must be the same as the new block.\";\n         successList.add(r.id);\n       } catch (IOException e) {\n         InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n             + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n         failedList.add(r.id);\n       }\n     }\n \n     // If any of the data-nodes failed, the recovery fails, because\n     // we never know the actual state of the replica on failed data-nodes.\n     // The recovery should be started over.\n     if(!failedList.isEmpty()) {\n       StringBuilder b \u003d new StringBuilder();\n       for(DatanodeID id : failedList) {\n         b.append(\"\\n  \" + id);\n       }\n       throw new IOException(\"Cannot recover \" + block + \", the following \"\n           + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n     }\n \n     // Notify the name-node about successfully recovered replicas.\n     DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n     nn.commitBlockSynchronization(block,\n         newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n         nlist);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    DatanodeProtocolClientSideTranslatorPB nn \u003d\n      getActiveNamenodeForBP(block.getBlockPoolId());\n    if (nn \u003d\u003d null) {\n      throw new IOException(\n          \"Unable to synchronize block \" + rBlock + \", since this DN \"\n          + \" has not acknowledged any NN as active.\");\n    }\n    \n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n        .getBlockId(), -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n            new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n            newBlock.getNumBytes());\n        assert reply.equals(newBlock) \u0026\u0026\n               reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n          \"Updated replica must be the same as the new block.\";\n        successList.add(r.id);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        nlist);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "c14912785d22734d735b5c4f8638b57dff009a97": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2929. Stress test and fixes for block synchronization. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1292494 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/02/12 12:31 PM",
      "commitName": "c14912785d22734d735b5c4f8638b57dff009a97",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "13/02/12 1:00 PM",
      "commitNameOld": "db187cf40ee307524c48cededd58710a4dfb4812",
      "commitAuthorOld": "",
      "daysBetweenCommits": 8.98,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,108 @@\n   void syncBlock(RecoveringBlock rBlock,\n                          List\u003cBlockRecord\u003e syncList) throws IOException {\n     ExtendedBlock block \u003d rBlock.getBlock();\n     DatanodeProtocolClientSideTranslatorPB nn \u003d getBPNamenode(block\n         .getBlockPoolId());\n     assert nn !\u003d null;\n     \n     long recoveryId \u003d rBlock.getNewGenerationStamp();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n           + \"), syncList\u003d\" + syncList);\n     }\n \n     // syncList.isEmpty() means that all data-nodes do not have the block\n     // or their replicas have 0 length.\n     // The block can be deleted.\n     if (syncList.isEmpty()) {\n-      // TODO: how does this work in HA??\n       nn.commitBlockSynchronization(block, recoveryId, 0,\n           true, true, DatanodeID.EMPTY_ARRAY);\n       return;\n     }\n \n     // Calculate the best available replica state.\n     ReplicaState bestState \u003d ReplicaState.RWR;\n     long finalizedLength \u003d -1;\n     for(BlockRecord r : syncList) {\n       assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n       ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n       if(rState.getValue() \u003c bestState.getValue())\n         bestState \u003d rState;\n       if(rState \u003d\u003d ReplicaState.FINALIZED) {\n         if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n           throw new IOException(\"Inconsistent size of finalized replicas. \" +\n               \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n         finalizedLength \u003d r.rInfo.getNumBytes();\n       }\n     }\n \n     // Calculate list of nodes that will participate in the recovery\n     // and the new block size\n     List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n     final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n         .getBlockId(), -1, recoveryId);\n     switch(bestState) {\n     case FINALIZED:\n       assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d ReplicaState.FINALIZED ||\n            rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                       r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n           participatingList.add(r);\n       }\n       newBlock.setNumBytes(finalizedLength);\n       break;\n     case RBW:\n     case RWR:\n       long minLength \u003d Long.MAX_VALUE;\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d bestState) {\n           minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n           participatingList.add(r);\n         }\n       }\n       newBlock.setNumBytes(minLength);\n       break;\n     case RUR:\n     case TEMPORARY:\n       assert false : \"bad replica state: \" + bestState;\n     }\n \n     List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n     List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n     for(BlockRecord r : participatingList) {\n       try {\n         ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n             new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n             newBlock.getNumBytes());\n         assert reply.equals(newBlock) \u0026\u0026\n                reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n           \"Updated replica must be the same as the new block.\";\n         successList.add(r.id);\n       } catch (IOException e) {\n         InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n             + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n         failedList.add(r.id);\n       }\n     }\n \n     // If any of the data-nodes failed, the recovery fails, because\n     // we never know the actual state of the replica on failed data-nodes.\n     // The recovery should be started over.\n     if(!failedList.isEmpty()) {\n       StringBuilder b \u003d new StringBuilder();\n       for(DatanodeID id : failedList) {\n         b.append(\"\\n  \" + id);\n       }\n       throw new IOException(\"Cannot recover \" + block + \", the following \"\n           + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n     }\n \n     // Notify the name-node about successfully recovered replicas.\n     DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n     nn.commitBlockSynchronization(block,\n         newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n         nlist);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    DatanodeProtocolClientSideTranslatorPB nn \u003d getBPNamenode(block\n        .getBlockPoolId());\n    assert nn !\u003d null;\n    \n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n        .getBlockId(), -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n            new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n            newBlock.getNumBytes());\n        assert reply.equals(newBlock) \u0026\u0026\n               reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n          \"Updated replica must be the same as the new block.\";\n        successList.add(r.id);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        nlist);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "8134b1c8702d7d6b3994c73b34afc7f8ee33ac6e": {
      "type": "Ybodychange",
      "commitMessage": "Merge trunk into HA branch.\n\nSeveral conflicts around introduction of protobuf translator for DatanodeProtocol - mostly trivial resolutions.\n\nNB: this does not successfully pass any tests since the HAStatus field needs\nto be integrated into the HeartbeatResponse Protobuf implementation.\nThat will be a separate commit for clearer history.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1214518 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/12/11 2:47 PM",
      "commitName": "8134b1c8702d7d6b3994c73b34afc7f8ee33ac6e",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "13/12/11 11:02 AM",
      "commitNameOld": "a0fe4f476ae907c9c070af48a250739a4fb33362",
      "commitAuthorOld": "",
      "daysBetweenCommits": 1.16,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,108 @@\n   void syncBlock(RecoveringBlock rBlock,\n                          List\u003cBlockRecord\u003e syncList) throws IOException {\n     ExtendedBlock block \u003d rBlock.getBlock();\n-    DatanodeProtocol nn \u003d getBPNamenode(block.getBlockPoolId());\n+    DatanodeProtocolClientSideTranslatorPB nn \u003d getBPNamenode(block\n+        .getBlockPoolId());\n     \n     long recoveryId \u003d rBlock.getNewGenerationStamp();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n           + \"), syncList\u003d\" + syncList);\n     }\n \n     // syncList.isEmpty() means that all data-nodes do not have the block\n     // or their replicas have 0 length.\n     // The block can be deleted.\n     if (syncList.isEmpty()) {\n       // TODO: how does this work in HA??\n       nn.commitBlockSynchronization(block, recoveryId, 0,\n           true, true, DatanodeID.EMPTY_ARRAY);\n       return;\n     }\n \n     // Calculate the best available replica state.\n     ReplicaState bestState \u003d ReplicaState.RWR;\n     long finalizedLength \u003d -1;\n     for(BlockRecord r : syncList) {\n       assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n       ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n       if(rState.getValue() \u003c bestState.getValue())\n         bestState \u003d rState;\n       if(rState \u003d\u003d ReplicaState.FINALIZED) {\n         if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n           throw new IOException(\"Inconsistent size of finalized replicas. \" +\n               \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n         finalizedLength \u003d r.rInfo.getNumBytes();\n       }\n     }\n \n     // Calculate list of nodes that will participate in the recovery\n     // and the new block size\n     List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n     final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n         .getBlockId(), -1, recoveryId);\n     switch(bestState) {\n     case FINALIZED:\n       assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d ReplicaState.FINALIZED ||\n            rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                       r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n           participatingList.add(r);\n       }\n       newBlock.setNumBytes(finalizedLength);\n       break;\n     case RBW:\n     case RWR:\n       long minLength \u003d Long.MAX_VALUE;\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d bestState) {\n           minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n           participatingList.add(r);\n         }\n       }\n       newBlock.setNumBytes(minLength);\n       break;\n     case RUR:\n     case TEMPORARY:\n       assert false : \"bad replica state: \" + bestState;\n     }\n \n     List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n     List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n     for(BlockRecord r : participatingList) {\n       try {\n         ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n             new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n             newBlock.getNumBytes());\n         assert reply.equals(newBlock) \u0026\u0026\n                reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n           \"Updated replica must be the same as the new block.\";\n         successList.add(r.id);\n       } catch (IOException e) {\n         InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n             + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n         failedList.add(r.id);\n       }\n     }\n \n     // If any of the data-nodes failed, the recovery fails, because\n     // we never know the actual state of the replica on failed data-nodes.\n     // The recovery should be started over.\n     if(!failedList.isEmpty()) {\n       StringBuilder b \u003d new StringBuilder();\n       for(DatanodeID id : failedList) {\n         b.append(\"\\n  \" + id);\n       }\n       throw new IOException(\"Cannot recover \" + block + \", the following \"\n           + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n     }\n \n     // Notify the name-node about successfully recovered replicas.\n     DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n     nn.commitBlockSynchronization(block,\n         newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n         nlist);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    DatanodeProtocolClientSideTranslatorPB nn \u003d getBPNamenode(block\n        .getBlockPoolId());\n    \n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      // TODO: how does this work in HA??\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n        .getBlockId(), -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n            new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n            newBlock.getNumBytes());\n        assert reply.equals(newBlock) \u0026\u0026\n               reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n          \"Updated replica must be the same as the new block.\";\n        successList.add(r.id);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        nlist);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "3cffe34177c72ea67194c3b0aaf0ddbf67ff3a0c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2661. Enable protobuf RPC for DatanodeProtocol.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1214033 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 6:15 PM",
      "commitName": "3cffe34177c72ea67194c3b0aaf0ddbf67ff3a0c",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "13/12/11 10:07 AM",
      "commitNameOld": "f2f4e9341387199e04679ebc8de5e05c0fdbd437",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,107 @@\n   void syncBlock(RecoveringBlock rBlock,\n                          List\u003cBlockRecord\u003e syncList) throws IOException {\n     ExtendedBlock block \u003d rBlock.getBlock();\n-    DatanodeProtocol nn \u003d getBPNamenode(block.getBlockPoolId());\n+    DatanodeProtocolClientSideTranslatorPB nn \u003d getBPNamenode(block\n+        .getBlockPoolId());\n     \n     long recoveryId \u003d rBlock.getNewGenerationStamp();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n           + \"), syncList\u003d\" + syncList);\n     }\n \n     // syncList.isEmpty() means that all data-nodes do not have the block\n     // or their replicas have 0 length.\n     // The block can be deleted.\n     if (syncList.isEmpty()) {\n       nn.commitBlockSynchronization(block, recoveryId, 0,\n           true, true, DatanodeID.EMPTY_ARRAY);\n       return;\n     }\n \n     // Calculate the best available replica state.\n     ReplicaState bestState \u003d ReplicaState.RWR;\n     long finalizedLength \u003d -1;\n     for(BlockRecord r : syncList) {\n       assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n       ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n       if(rState.getValue() \u003c bestState.getValue())\n         bestState \u003d rState;\n       if(rState \u003d\u003d ReplicaState.FINALIZED) {\n         if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n           throw new IOException(\"Inconsistent size of finalized replicas. \" +\n               \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n         finalizedLength \u003d r.rInfo.getNumBytes();\n       }\n     }\n \n     // Calculate list of nodes that will participate in the recovery\n     // and the new block size\n     List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n     final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n         .getBlockId(), -1, recoveryId);\n     switch(bestState) {\n     case FINALIZED:\n       assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d ReplicaState.FINALIZED ||\n            rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                       r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n           participatingList.add(r);\n       }\n       newBlock.setNumBytes(finalizedLength);\n       break;\n     case RBW:\n     case RWR:\n       long minLength \u003d Long.MAX_VALUE;\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d bestState) {\n           minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n           participatingList.add(r);\n         }\n       }\n       newBlock.setNumBytes(minLength);\n       break;\n     case RUR:\n     case TEMPORARY:\n       assert false : \"bad replica state: \" + bestState;\n     }\n \n     List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n     List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n     for(BlockRecord r : participatingList) {\n       try {\n         ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n             new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n             newBlock.getNumBytes());\n         assert reply.equals(newBlock) \u0026\u0026\n                reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n           \"Updated replica must be the same as the new block.\";\n         successList.add(r.id);\n       } catch (IOException e) {\n         InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n             + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n         failedList.add(r.id);\n       }\n     }\n \n     // If any of the data-nodes failed, the recovery fails, because\n     // we never know the actual state of the replica on failed data-nodes.\n     // The recovery should be started over.\n     if(!failedList.isEmpty()) {\n       StringBuilder b \u003d new StringBuilder();\n       for(DatanodeID id : failedList) {\n         b.append(\"\\n  \" + id);\n       }\n       throw new IOException(\"Cannot recover \" + block + \", the following \"\n           + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n     }\n \n     // Notify the name-node about successfully recovered replicas.\n     DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n     nn.commitBlockSynchronization(block,\n         newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n         nlist);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    DatanodeProtocolClientSideTranslatorPB nn \u003d getBPNamenode(block\n        .getBlockPoolId());\n    \n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n        .getBlockId(), -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n            new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n            newBlock.getNumBytes());\n        assert reply.equals(newBlock) \u0026\u0026\n               reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n          \"Updated replica must be the same as the new block.\";\n        successList.add(r.id);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        nlist);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "1e346aa829519f8a2aa830e76d9856f914861805": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1971. Send block report from datanode to both active and standby namenodes. (sanjay, todd via suresh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208925 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/11 5:10 PM",
      "commitName": "1e346aa829519f8a2aa830e76d9856f914861805",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "30/11/11 10:27 AM",
      "commitNameOld": "0eec2218a16be6092e2d7ea49a97e7807e408499",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,107 @@\n   void syncBlock(RecoveringBlock rBlock,\n                          List\u003cBlockRecord\u003e syncList) throws IOException {\n     ExtendedBlock block \u003d rBlock.getBlock();\n     DatanodeProtocol nn \u003d getBPNamenode(block.getBlockPoolId());\n     \n     long recoveryId \u003d rBlock.getNewGenerationStamp();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n           + \"), syncList\u003d\" + syncList);\n     }\n \n     // syncList.isEmpty() means that all data-nodes do not have the block\n     // or their replicas have 0 length.\n     // The block can be deleted.\n     if (syncList.isEmpty()) {\n+      // TODO: how does this work in HA??\n       nn.commitBlockSynchronization(block, recoveryId, 0,\n           true, true, DatanodeID.EMPTY_ARRAY);\n       return;\n     }\n \n     // Calculate the best available replica state.\n     ReplicaState bestState \u003d ReplicaState.RWR;\n     long finalizedLength \u003d -1;\n     for(BlockRecord r : syncList) {\n       assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n       ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n       if(rState.getValue() \u003c bestState.getValue())\n         bestState \u003d rState;\n       if(rState \u003d\u003d ReplicaState.FINALIZED) {\n         if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n           throw new IOException(\"Inconsistent size of finalized replicas. \" +\n               \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n         finalizedLength \u003d r.rInfo.getNumBytes();\n       }\n     }\n \n     // Calculate list of nodes that will participate in the recovery\n     // and the new block size\n     List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n     final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n         .getBlockId(), -1, recoveryId);\n     switch(bestState) {\n     case FINALIZED:\n       assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d ReplicaState.FINALIZED ||\n            rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                       r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n           participatingList.add(r);\n       }\n       newBlock.setNumBytes(finalizedLength);\n       break;\n     case RBW:\n     case RWR:\n       long minLength \u003d Long.MAX_VALUE;\n       for(BlockRecord r : syncList) {\n         ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n         if(rState \u003d\u003d bestState) {\n           minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n           participatingList.add(r);\n         }\n       }\n       newBlock.setNumBytes(minLength);\n       break;\n     case RUR:\n     case TEMPORARY:\n       assert false : \"bad replica state: \" + bestState;\n     }\n \n     List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n     List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n     for(BlockRecord r : participatingList) {\n       try {\n         ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n             new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n             newBlock.getNumBytes());\n         assert reply.equals(newBlock) \u0026\u0026\n                reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n           \"Updated replica must be the same as the new block.\";\n         successList.add(r.id);\n       } catch (IOException e) {\n         InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n             + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n         failedList.add(r.id);\n       }\n     }\n \n     // If any of the data-nodes failed, the recovery fails, because\n     // we never know the actual state of the replica on failed data-nodes.\n     // The recovery should be started over.\n     if(!failedList.isEmpty()) {\n       StringBuilder b \u003d new StringBuilder();\n       for(DatanodeID id : failedList) {\n         b.append(\"\\n  \" + id);\n       }\n       throw new IOException(\"Cannot recover \" + block + \", the following \"\n           + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n     }\n \n     // Notify the name-node about successfully recovered replicas.\n     DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n     nn.commitBlockSynchronization(block,\n         newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n         nlist);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    DatanodeProtocol nn \u003d getBPNamenode(block.getBlockPoolId());\n    \n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      // TODO: how does this work in HA??\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n        .getBlockId(), -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n            new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n            newBlock.getNumBytes());\n        assert reply.equals(newBlock) \u0026\u0026\n               reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n          \"Updated replica must be the same as the new block.\";\n        successList.add(r.id);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        nlist);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    DatanodeProtocol nn \u003d getBPNamenode(block.getBlockPoolId());\n    \n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n        .getBlockId(), -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n            new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n            newBlock.getNumBytes());\n        assert reply.equals(newBlock) \u0026\u0026\n               reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n          \"Updated replica must be the same as the new block.\";\n        successList.add(r.id);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        nlist);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    DatanodeProtocol nn \u003d getBPNamenode(block.getBlockPoolId());\n    \n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n        .getBlockId(), -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n            new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n            newBlock.getNumBytes());\n        assert reply.equals(newBlock) \u0026\u0026\n               reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n          \"Updated replica must be the same as the new block.\";\n        successList.add(r.id);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        nlist);\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,106 @@\n+  void syncBlock(RecoveringBlock rBlock,\n+                         List\u003cBlockRecord\u003e syncList) throws IOException {\n+    ExtendedBlock block \u003d rBlock.getBlock();\n+    DatanodeProtocol nn \u003d getBPNamenode(block.getBlockPoolId());\n+    \n+    long recoveryId \u003d rBlock.getNewGenerationStamp();\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n+          + \"), syncList\u003d\" + syncList);\n+    }\n+\n+    // syncList.isEmpty() means that all data-nodes do not have the block\n+    // or their replicas have 0 length.\n+    // The block can be deleted.\n+    if (syncList.isEmpty()) {\n+      nn.commitBlockSynchronization(block, recoveryId, 0,\n+          true, true, DatanodeID.EMPTY_ARRAY);\n+      return;\n+    }\n+\n+    // Calculate the best available replica state.\n+    ReplicaState bestState \u003d ReplicaState.RWR;\n+    long finalizedLength \u003d -1;\n+    for(BlockRecord r : syncList) {\n+      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n+      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n+      if(rState.getValue() \u003c bestState.getValue())\n+        bestState \u003d rState;\n+      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n+        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n+          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n+              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n+        finalizedLength \u003d r.rInfo.getNumBytes();\n+      }\n+    }\n+\n+    // Calculate list of nodes that will participate in the recovery\n+    // and the new block size\n+    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n+    final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n+        .getBlockId(), -1, recoveryId);\n+    switch(bestState) {\n+    case FINALIZED:\n+      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n+      for(BlockRecord r : syncList) {\n+        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n+        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n+           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n+                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n+          participatingList.add(r);\n+      }\n+      newBlock.setNumBytes(finalizedLength);\n+      break;\n+    case RBW:\n+    case RWR:\n+      long minLength \u003d Long.MAX_VALUE;\n+      for(BlockRecord r : syncList) {\n+        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n+        if(rState \u003d\u003d bestState) {\n+          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n+          participatingList.add(r);\n+        }\n+      }\n+      newBlock.setNumBytes(minLength);\n+      break;\n+    case RUR:\n+    case TEMPORARY:\n+      assert false : \"bad replica state: \" + bestState;\n+    }\n+\n+    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n+    List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n+    for(BlockRecord r : participatingList) {\n+      try {\n+        ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n+            new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n+            newBlock.getNumBytes());\n+        assert reply.equals(newBlock) \u0026\u0026\n+               reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n+          \"Updated replica must be the same as the new block.\";\n+        successList.add(r.id);\n+      } catch (IOException e) {\n+        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n+            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n+        failedList.add(r.id);\n+      }\n+    }\n+\n+    // If any of the data-nodes failed, the recovery fails, because\n+    // we never know the actual state of the replica on failed data-nodes.\n+    // The recovery should be started over.\n+    if(!failedList.isEmpty()) {\n+      StringBuilder b \u003d new StringBuilder();\n+      for(DatanodeID id : failedList) {\n+        b.append(\"\\n  \" + id);\n+      }\n+      throw new IOException(\"Cannot recover \" + block + \", the following \"\n+          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n+    }\n+\n+    // Notify the name-node about successfully recovered replicas.\n+    DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n+    nn.commitBlockSynchronization(block,\n+        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n+        nlist);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void syncBlock(RecoveringBlock rBlock,\n                         List\u003cBlockRecord\u003e syncList) throws IOException {\n    ExtendedBlock block \u003d rBlock.getBlock();\n    DatanodeProtocol nn \u003d getBPNamenode(block.getBlockPoolId());\n    \n    long recoveryId \u003d rBlock.getNewGenerationStamp();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block\u003d\" + block + \", (length\u003d\" + block.getNumBytes()\n          + \"), syncList\u003d\" + syncList);\n    }\n\n    // syncList.isEmpty() means that all data-nodes do not have the block\n    // or their replicas have 0 length.\n    // The block can be deleted.\n    if (syncList.isEmpty()) {\n      nn.commitBlockSynchronization(block, recoveryId, 0,\n          true, true, DatanodeID.EMPTY_ARRAY);\n      return;\n    }\n\n    // Calculate the best available replica state.\n    ReplicaState bestState \u003d ReplicaState.RWR;\n    long finalizedLength \u003d -1;\n    for(BlockRecord r : syncList) {\n      assert r.rInfo.getNumBytes() \u003e 0 : \"zero length replica\";\n      ReplicaState rState \u003d r.rInfo.getOriginalReplicaState(); \n      if(rState.getValue() \u003c bestState.getValue())\n        bestState \u003d rState;\n      if(rState \u003d\u003d ReplicaState.FINALIZED) {\n        if(finalizedLength \u003e 0 \u0026\u0026 finalizedLength !\u003d r.rInfo.getNumBytes())\n          throw new IOException(\"Inconsistent size of finalized replicas. \" +\n              \"Replica \" + r.rInfo + \" expected size: \" + finalizedLength);\n        finalizedLength \u003d r.rInfo.getNumBytes();\n      }\n    }\n\n    // Calculate list of nodes that will participate in the recovery\n    // and the new block size\n    List\u003cBlockRecord\u003e participatingList \u003d new ArrayList\u003cBlockRecord\u003e();\n    final ExtendedBlock newBlock \u003d new ExtendedBlock(block.getBlockPoolId(), block\n        .getBlockId(), -1, recoveryId);\n    switch(bestState) {\n    case FINALIZED:\n      assert finalizedLength \u003e 0 : \"finalizedLength is not positive\";\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d ReplicaState.FINALIZED ||\n           rState \u003d\u003d ReplicaState.RBW \u0026\u0026\n                      r.rInfo.getNumBytes() \u003d\u003d finalizedLength)\n          participatingList.add(r);\n      }\n      newBlock.setNumBytes(finalizedLength);\n      break;\n    case RBW:\n    case RWR:\n      long minLength \u003d Long.MAX_VALUE;\n      for(BlockRecord r : syncList) {\n        ReplicaState rState \u003d r.rInfo.getOriginalReplicaState();\n        if(rState \u003d\u003d bestState) {\n          minLength \u003d Math.min(minLength, r.rInfo.getNumBytes());\n          participatingList.add(r);\n        }\n      }\n      newBlock.setNumBytes(minLength);\n      break;\n    case RUR:\n    case TEMPORARY:\n      assert false : \"bad replica state: \" + bestState;\n    }\n\n    List\u003cDatanodeID\u003e failedList \u003d new ArrayList\u003cDatanodeID\u003e();\n    List\u003cDatanodeID\u003e successList \u003d new ArrayList\u003cDatanodeID\u003e();\n    for(BlockRecord r : participatingList) {\n      try {\n        ExtendedBlock reply \u003d r.datanode.updateReplicaUnderRecovery(\n            new ExtendedBlock(newBlock.getBlockPoolId(), r.rInfo), recoveryId,\n            newBlock.getNumBytes());\n        assert reply.equals(newBlock) \u0026\u0026\n               reply.getNumBytes() \u003d\u003d newBlock.getNumBytes() :\n          \"Updated replica must be the same as the new block.\";\n        successList.add(r.id);\n      } catch (IOException e) {\n        InterDatanodeProtocol.LOG.warn(\"Failed to updateBlock (newblock\u003d\"\n            + newBlock + \", datanode\u003d\" + r.id + \")\", e);\n        failedList.add(r.id);\n      }\n    }\n\n    // If any of the data-nodes failed, the recovery fails, because\n    // we never know the actual state of the replica on failed data-nodes.\n    // The recovery should be started over.\n    if(!failedList.isEmpty()) {\n      StringBuilder b \u003d new StringBuilder();\n      for(DatanodeID id : failedList) {\n        b.append(\"\\n  \" + id);\n      }\n      throw new IOException(\"Cannot recover \" + block + \", the following \"\n          + failedList.size() + \" data-nodes failed {\" + b + \"\\n}\");\n    }\n\n    // Notify the name-node about successfully recovered replicas.\n    DatanodeID[] nlist \u003d successList.toArray(new DatanodeID[successList.size()]);\n    nn.commitBlockSynchronization(block,\n        newBlock.getGenerationStamp(), newBlock.getNumBytes(), true, false,\n        nlist);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
    }
  }
}