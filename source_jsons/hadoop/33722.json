{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RuncContainerRuntime.java",
  "functionName": "launchContainer",
  "functionId": "launchContainer___ctx-ContainerRuntimeContext",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/RuncContainerRuntime.java",
  "functionStartLine": 295,
  "functionEndLine": 445,
  "numCommitsSeen": 1,
  "timeTaken": 1375,
  "changeHistory": [
    "0e22e9ab83438af37d821cb2f96e31f9a19ace2c"
  ],
  "changeHistoryShort": {
    "0e22e9ab83438af37d821cb2f96e31f9a19ace2c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0e22e9ab83438af37d821cb2f96e31f9a19ace2c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-9562. Add Java changes for the new RuncContainerRuntime. Contributed by Eric Badger\n",
      "commitDate": "18/11/19 1:56 PM",
      "commitName": "0e22e9ab83438af37d821cb2f96e31f9a19ace2c",
      "commitAuthor": "Eric Badger",
      "diff": "@@ -0,0 +1,151 @@\n+  public void launchContainer(ContainerRuntimeContext ctx)\n+      throws ContainerExecutionException {\n+    List\u003cString\u003e env \u003d new ArrayList\u003c\u003e();\n+    Container container \u003d ctx.getContainer();\n+    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n+    String user \u003d ctx.getExecutionAttribute(USER);\n+    ContainerId containerId \u003d container.getContainerId();\n+    ApplicationId appId \u003d containerId.getApplicationAttemptId()\n+        .getApplicationId();\n+\n+    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n+        .getEnvironment();\n+    ArrayList\u003cOCIMount\u003e mounts \u003d new ArrayList\u003c\u003e();\n+    ArrayList\u003cOCILayer\u003e layers \u003d new ArrayList\u003c\u003e();\n+    String hostname \u003d environment.get(ENV_RUNC_CONTAINER_HOSTNAME);\n+\n+    validateHostname(hostname);\n+\n+    String containerIdStr \u003d containerId.toString();\n+    String applicationId \u003d appId.toString();\n+    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n+\n+    RuncRuntimeObject runcRuntimeObject \u003d\n+        container.getContainerRuntimeData(RuncRuntimeObject.class);\n+    List\u003cLocalResource\u003e layerResources \u003d runcRuntimeObject.getOCILayers();\n+\n+    ResourceLocalizationService localizationService \u003d\n+        nmContext.getContainerManager().getResourceLocalizationService();\n+\n+    List\u003cString\u003e args \u003d new ArrayList\u003c\u003e();\n+\n+    try {\n+      try {\n+        LocalResource rsrc \u003d runcRuntimeObject.getConfig();\n+        LocalResourceRequest req \u003d new LocalResourceRequest(rsrc);\n+        LocalizedResource localRsrc \u003d localizationService\n+            .getLocalizedResource(req, user, appId);\n+        if (localRsrc \u003d\u003d null) {\n+          throw new ContainerExecutionException(\"Could not successfully \" +\n+              \"localize layers. rsrc: \" + rsrc.getResource().getFile());\n+        }\n+\n+        File file \u003d new File(localRsrc.getLocalPath().toString());\n+        List\u003cString\u003e imageEnv \u003d extractImageEnv(file);\n+        if (imageEnv !\u003d null \u0026\u0026 !imageEnv.isEmpty()) {\n+          env.addAll(imageEnv);\n+        }\n+        List\u003cString\u003e entrypoint \u003d extractImageEntrypoint(file);\n+        if (entrypoint !\u003d null \u0026\u0026 !entrypoint.isEmpty()) {\n+          args.addAll(entrypoint);\n+        }\n+      } catch (IOException ioe) {\n+        throw new ContainerExecutionException(ioe);\n+      }\n+\n+      for (LocalResource rsrc : layerResources) {\n+        LocalResourceRequest req \u003d new LocalResourceRequest(rsrc);\n+        LocalizedResource localRsrc \u003d localizationService\n+            .getLocalizedResource(req, user, appId);\n+\n+        OCILayer layer \u003d new OCILayer(\"application/vnd.squashfs\",\n+            localRsrc.getLocalPath().toString());\n+        layers.add(layer);\n+      }\n+    } catch (URISyntaxException e) {\n+      throw new ContainerExecutionException(e);\n+    }\n+\n+    setContainerMounts(mounts, ctx, containerWorkDir, environment);\n+\n+    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n+\n+    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n+        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n+\n+    Path nmPrivateTokensPath \u003d\n+        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH);\n+\n+    int cpuShares \u003d container.getResource().getVirtualCores();\n+\n+    // Zero sets to default of 1024.  2 is the minimum value otherwise\n+    if (cpuShares \u003c 2) {\n+      cpuShares \u003d 2;\n+    }\n+\n+    Path launchDst \u003d\n+        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n+\n+    args.add(\"bash\");\n+    args.add(launchDst.toUri().getPath());\n+\n+    String cgroupPath \u003d getCgroupPath(resourcesOpts, \"runc-\" + containerIdStr);\n+\n+    String pidFile \u003d ctx.getExecutionAttribute(PID_FILE_PATH).toString();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n+    @SuppressWarnings(\"unchecked\")\n+    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n+\n+    Path keystorePath \u003d ctx.getExecutionAttribute(NM_PRIVATE_KEYSTORE_PATH);\n+    Path truststorePath \u003d ctx.getExecutionAttribute(NM_PRIVATE_TRUSTSTORE_PATH);\n+\n+    int https \u003d 0;\n+    String keystore \u003d null;\n+    String truststore \u003d null;\n+\n+    if (keystorePath !\u003d null \u0026\u0026 truststorePath !\u003d null) {\n+      https \u003d 1;\n+      keystore \u003d keystorePath.toUri().getPath();\n+      truststore \u003d truststorePath.toUri().getPath();\n+    }\n+\n+    OCIProcessConfig processConfig \u003d createOCIProcessConfig(\n+        containerWorkDir.toString(), env, args);\n+    OCILinuxConfig linuxConfig \u003d createOCILinuxConfig(cpuShares,\n+        cgroupPath, seccomp);\n+\n+    OCIRuntimeConfig ociRuntimeConfig \u003d new OCIRuntimeConfig(null, mounts,\n+        processConfig, hostname, null, null, linuxConfig);\n+\n+    RuncContainerExecutorConfig runcContainerExecutorConfig \u003d\n+        createRuncContainerExecutorConfig(runAsUser, user, containerIdStr,\n+        applicationId, pidFile, nmPrivateContainerScriptPath.toString(),\n+        nmPrivateTokensPath.toString(), https, keystore, truststore,\n+        localDirs, logDirs, layers,\n+        ociRuntimeConfig);\n+\n+    String commandFile \u003d writeCommandToFile(\n+        runcContainerExecutorConfig, container);\n+    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n+        PrivilegedOperation.OperationType.RUN_RUNC_CONTAINER);\n+\n+    launchOp.appendArgs(commandFile);\n+\n+    try {\n+      privilegedOperationExecutor.executePrivilegedOperation(null,\n+          launchOp, null, null, false, false);\n+    } catch (PrivilegedOperationException e) {\n+      LOG.info(\"Launch container failed: \", e);\n+      try {\n+        LOG.debug(\"config.json used: \" +\n+            mapper.writeValueAsString(runcContainerExecutorConfig));\n+      } catch (IOException ioe) {\n+        LOG.info(\"Json Generation Exception\", ioe);\n+      }\n+\n+      throw new ContainerExecutionException(\"Launch container failed\", e\n+          .getExitCode(), e.getOutput(), e.getErrorOutput());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    List\u003cString\u003e env \u003d new ArrayList\u003c\u003e();\n    Container container \u003d ctx.getContainer();\n    String runAsUser \u003d ctx.getExecutionAttribute(RUN_AS_USER);\n    String user \u003d ctx.getExecutionAttribute(USER);\n    ContainerId containerId \u003d container.getContainerId();\n    ApplicationId appId \u003d containerId.getApplicationAttemptId()\n        .getApplicationId();\n\n    Map\u003cString, String\u003e environment \u003d container.getLaunchContext()\n        .getEnvironment();\n    ArrayList\u003cOCIMount\u003e mounts \u003d new ArrayList\u003c\u003e();\n    ArrayList\u003cOCILayer\u003e layers \u003d new ArrayList\u003c\u003e();\n    String hostname \u003d environment.get(ENV_RUNC_CONTAINER_HOSTNAME);\n\n    validateHostname(hostname);\n\n    String containerIdStr \u003d containerId.toString();\n    String applicationId \u003d appId.toString();\n    Path containerWorkDir \u003d ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n\n    RuncRuntimeObject runcRuntimeObject \u003d\n        container.getContainerRuntimeData(RuncRuntimeObject.class);\n    List\u003cLocalResource\u003e layerResources \u003d runcRuntimeObject.getOCILayers();\n\n    ResourceLocalizationService localizationService \u003d\n        nmContext.getContainerManager().getResourceLocalizationService();\n\n    List\u003cString\u003e args \u003d new ArrayList\u003c\u003e();\n\n    try {\n      try {\n        LocalResource rsrc \u003d runcRuntimeObject.getConfig();\n        LocalResourceRequest req \u003d new LocalResourceRequest(rsrc);\n        LocalizedResource localRsrc \u003d localizationService\n            .getLocalizedResource(req, user, appId);\n        if (localRsrc \u003d\u003d null) {\n          throw new ContainerExecutionException(\"Could not successfully \" +\n              \"localize layers. rsrc: \" + rsrc.getResource().getFile());\n        }\n\n        File file \u003d new File(localRsrc.getLocalPath().toString());\n        List\u003cString\u003e imageEnv \u003d extractImageEnv(file);\n        if (imageEnv !\u003d null \u0026\u0026 !imageEnv.isEmpty()) {\n          env.addAll(imageEnv);\n        }\n        List\u003cString\u003e entrypoint \u003d extractImageEntrypoint(file);\n        if (entrypoint !\u003d null \u0026\u0026 !entrypoint.isEmpty()) {\n          args.addAll(entrypoint);\n        }\n      } catch (IOException ioe) {\n        throw new ContainerExecutionException(ioe);\n      }\n\n      for (LocalResource rsrc : layerResources) {\n        LocalResourceRequest req \u003d new LocalResourceRequest(rsrc);\n        LocalizedResource localRsrc \u003d localizationService\n            .getLocalizedResource(req, user, appId);\n\n        OCILayer layer \u003d new OCILayer(\"application/vnd.squashfs\",\n            localRsrc.getLocalPath().toString());\n        layers.add(layer);\n      }\n    } catch (URISyntaxException e) {\n      throw new ContainerExecutionException(e);\n    }\n\n    setContainerMounts(mounts, ctx, containerWorkDir, environment);\n\n    String resourcesOpts \u003d ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n\n    Path nmPrivateContainerScriptPath \u003d ctx.getExecutionAttribute(\n        NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n\n    Path nmPrivateTokensPath \u003d\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH);\n\n    int cpuShares \u003d container.getResource().getVirtualCores();\n\n    // Zero sets to default of 1024.  2 is the minimum value otherwise\n    if (cpuShares \u003c 2) {\n      cpuShares \u003d 2;\n    }\n\n    Path launchDst \u003d\n        new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n\n    args.add(\"bash\");\n    args.add(launchDst.toUri().getPath());\n\n    String cgroupPath \u003d getCgroupPath(resourcesOpts, \"runc-\" + containerIdStr);\n\n    String pidFile \u003d ctx.getExecutionAttribute(PID_FILE_PATH).toString();\n\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e localDirs \u003d ctx.getExecutionAttribute(LOCAL_DIRS);\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e logDirs \u003d ctx.getExecutionAttribute(LOG_DIRS);\n\n    Path keystorePath \u003d ctx.getExecutionAttribute(NM_PRIVATE_KEYSTORE_PATH);\n    Path truststorePath \u003d ctx.getExecutionAttribute(NM_PRIVATE_TRUSTSTORE_PATH);\n\n    int https \u003d 0;\n    String keystore \u003d null;\n    String truststore \u003d null;\n\n    if (keystorePath !\u003d null \u0026\u0026 truststorePath !\u003d null) {\n      https \u003d 1;\n      keystore \u003d keystorePath.toUri().getPath();\n      truststore \u003d truststorePath.toUri().getPath();\n    }\n\n    OCIProcessConfig processConfig \u003d createOCIProcessConfig(\n        containerWorkDir.toString(), env, args);\n    OCILinuxConfig linuxConfig \u003d createOCILinuxConfig(cpuShares,\n        cgroupPath, seccomp);\n\n    OCIRuntimeConfig ociRuntimeConfig \u003d new OCIRuntimeConfig(null, mounts,\n        processConfig, hostname, null, null, linuxConfig);\n\n    RuncContainerExecutorConfig runcContainerExecutorConfig \u003d\n        createRuncContainerExecutorConfig(runAsUser, user, containerIdStr,\n        applicationId, pidFile, nmPrivateContainerScriptPath.toString(),\n        nmPrivateTokensPath.toString(), https, keystore, truststore,\n        localDirs, logDirs, layers,\n        ociRuntimeConfig);\n\n    String commandFile \u003d writeCommandToFile(\n        runcContainerExecutorConfig, container);\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.RUN_RUNC_CONTAINER);\n\n    launchOp.appendArgs(commandFile);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.info(\"Launch container failed: \", e);\n      try {\n        LOG.debug(\"config.json used: \" +\n            mapper.writeValueAsString(runcContainerExecutorConfig));\n      } catch (IOException ioe) {\n        LOG.info(\"Json Generation Exception\", ioe);\n      }\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/RuncContainerRuntime.java"
    }
  }
}