{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NameNodeRpcServer.java",
  "functionName": "blockReport",
  "functionId": "blockReport___nodeReg-DatanodeRegistration(modifiers-final)__poolId-String__reports-StorageBlockReport[](modifiers-final)__context-BlockReportContext(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
  "functionStartLine": 1602,
  "functionEndLine": 1646,
  "numCommitsSeen": 465,
  "timeTaken": 14393,
  "changeHistory": [
    "6822193ee6d6ac8b08822fa76c89e1dd61c5ddca",
    "7314185c4a313842115e18b5f42d118392cee929",
    "ae4143a529d74d94f205ca627c31360abfa11bfa",
    "3a78e5ffd83dd96ef9bca72745f27efdda0c9e24",
    "c22cf004425daa9c350df5e365b0db85b1628b40",
    "391ce535a739dc92cb90017d759217265a4fd969",
    "c4463f2ef20d2cb634a1249246f83c451975f3dc",
    "85a20508bd04851d47c24b7562ec2927d5403446",
    "f741476146574550a1a208d58ef8be76639e5ddc",
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59",
    "50ee8f4e67a66aa77c5359182f61f3e951844db6",
    "d324164a51a43d72c02567248bd9f0f12b244a40",
    "db334bb8625da97c7e518cbcf477530c7ba7001e",
    "4ae8178c5626d188b137e3f806e56fd8661c4970",
    "45db4d204b796eee6dd0e39d3cc94b70c47028d4",
    "5ac06c8b381f1ab63aeb5117b26e90b28bef026a",
    "63fadf0abd9fd0ba1bcf9bfc108c46e34b88309e",
    "6cc92bf8fc9aa69ca9570945c6add932d586a0d9",
    "5beeb3016954a3ee0c1fb10a2083ffd540cd2c14",
    "282be1b38e5cd141ed7e2b2194bfb67a7c2f7f15",
    "5d9d702607913685eab0d8ad077040ddc82bf085",
    "db71de2e11cfa56a254ef4c92fea5ef4f8c19100",
    "be7dd8333a7e56e732171db0781786987de03195"
  ],
  "changeHistoryShort": {
    "6822193ee6d6ac8b08822fa76c89e1dd61c5ddca": "Ybodychange",
    "7314185c4a313842115e18b5f42d118392cee929": "Ybodychange",
    "ae4143a529d74d94f205ca627c31360abfa11bfa": "Ybodychange",
    "3a78e5ffd83dd96ef9bca72745f27efdda0c9e24": "Ybodychange",
    "c22cf004425daa9c350df5e365b0db85b1628b40": "Ybodychange",
    "391ce535a739dc92cb90017d759217265a4fd969": "Ybodychange",
    "c4463f2ef20d2cb634a1249246f83c451975f3dc": "Ybodychange",
    "85a20508bd04851d47c24b7562ec2927d5403446": "Ybodychange",
    "f741476146574550a1a208d58ef8be76639e5ddc": "Ymultichange(Ybodychange,Yparametermetachange)",
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59": "Ybodychange",
    "50ee8f4e67a66aa77c5359182f61f3e951844db6": "Ymultichange(Yparameterchange,Ybodychange)",
    "d324164a51a43d72c02567248bd9f0f12b244a40": "Ybodychange",
    "db334bb8625da97c7e518cbcf477530c7ba7001e": "Ybodychange",
    "4ae8178c5626d188b137e3f806e56fd8661c4970": "Ybodychange",
    "45db4d204b796eee6dd0e39d3cc94b70c47028d4": "Ybodychange",
    "5ac06c8b381f1ab63aeb5117b26e90b28bef026a": "Ybodychange",
    "63fadf0abd9fd0ba1bcf9bfc108c46e34b88309e": "Ybodychange",
    "6cc92bf8fc9aa69ca9570945c6add932d586a0d9": "Ybodychange",
    "5beeb3016954a3ee0c1fb10a2083ffd540cd2c14": "Ybodychange",
    "282be1b38e5cd141ed7e2b2194bfb67a7c2f7f15": "Ybodychange",
    "5d9d702607913685eab0d8ad077040ddc82bf085": "Ybodychange",
    "db71de2e11cfa56a254ef4c92fea5ef4f8c19100": "Ybodychange",
    "be7dd8333a7e56e732171db0781786987de03195": "Ybodychange"
  },
  "changeHistoryDetails": {
    "6822193ee6d6ac8b08822fa76c89e1dd61c5ddca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12914. Block report leases cause missing blocks until next report. Contributed by Santosh Marella, He Xiaoqiao.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\nCo-authored-by: He Xiaoqiao \u003chexiaoqiao@apache.org\u003e\n",
      "commitDate": "17/06/19 4:20 PM",
      "commitName": "6822193ee6d6ac8b08822fa76c89e1dd61c5ddca",
      "commitAuthor": "Santosh Marella",
      "commitDateOld": "17/06/19 4:18 PM",
      "commitNameOld": "7314185c4a313842115e18b5f42d118392cee929",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,45 @@\n   public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n         String poolId, final StorageBlockReport[] reports,\n         final BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n-    for (int r \u003d 0; r \u003c reports.length; r++) {\n-      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n-      //\n-      // BlockManager.processReport accumulates information of prior calls\n-      // for the same node and storage, so the value returned by the last\n-      // call of this loop is the final updated value for noStaleStorage.\n-      //\n-      final int index \u003d r;\n-      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n-        @Override\n-        public Boolean call() throws IOException {\n-          return bm.processReport(nodeReg, reports[index].getStorage(),\n-              blocks, context);\n+    try {\n+      if (bm.checkBlockReportLease(context, nodeReg)) {\n+        for (int r \u003d 0; r \u003c reports.length; r++) {\n+          final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n+          //\n+          // BlockManager.processReport accumulates information of prior calls\n+          // for the same node and storage, so the value returned by the last\n+          // call of this loop is the final updated value for noStaleStorage.\n+          //\n+          final int index \u003d r;\n+          noStaleStorages \u003d bm.runBlockOp(() -\u003e\n+            bm.processReport(nodeReg, reports[index].getStorage(),\n+                blocks, context));\n         }\n-      });\n+      }\n+    } catch (UnregisteredNodeException une) {\n+      LOG.debug(\"Datanode {} is attempting to report but not register yet.\",\n+          nodeReg);\n+      return RegisterCommand.REGISTER;\n     }\n     bm.removeBRLeaseIfNeeded(nodeReg, context);\n \n     BlockManagerFaultInjector.getInstance().\n         incomingBlockReportRpc(nodeReg, context);\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         nn.isActiveState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n        String poolId, final StorageBlockReport[] reports,\n        final BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    try {\n      if (bm.checkBlockReportLease(context, nodeReg)) {\n        for (int r \u003d 0; r \u003c reports.length; r++) {\n          final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n          //\n          // BlockManager.processReport accumulates information of prior calls\n          // for the same node and storage, so the value returned by the last\n          // call of this loop is the final updated value for noStaleStorage.\n          //\n          final int index \u003d r;\n          noStaleStorages \u003d bm.runBlockOp(() -\u003e\n            bm.processReport(nodeReg, reports[index].getStorage(),\n                blocks, context));\n        }\n      }\n    } catch (UnregisteredNodeException une) {\n      LOG.debug(\"Datanode {} is attempting to report but not register yet.\",\n          nodeReg);\n      return RegisterCommand.REGISTER;\n    }\n    bm.removeBRLeaseIfNeeded(nodeReg, context);\n\n    BlockManagerFaultInjector.getInstance().\n        incomingBlockReportRpc(nodeReg, context);\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        nn.isActiveState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "7314185c4a313842115e18b5f42d118392cee929": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-12914. Block report leases cause missing blocks until next report. Contributed by Santosh Marella, He Xiaoqiao.\"\n\nThis reverts commit ae4143a529d74d94f205ca627c31360abfa11bfa.\n",
      "commitDate": "17/06/19 4:18 PM",
      "commitName": "7314185c4a313842115e18b5f42d118392cee929",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "14/06/19 10:42 AM",
      "commitNameOld": "ae4143a529d74d94f205ca627c31360abfa11bfa",
      "commitAuthorOld": "Santosh Marella",
      "daysBetweenCommits": 3.23,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,41 @@\n   public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n         String poolId, final StorageBlockReport[] reports,\n         final BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n-    try {\n-      if (bm.checkBlockReportLease(context, nodeReg)) {\n-        for (int r \u003d 0; r \u003c reports.length; r++) {\n-          final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n-          //\n-          // BlockManager.processReport accumulates information of prior calls\n-          // for the same node and storage, so the value returned by the last\n-          // call of this loop is the final updated value for noStaleStorage.\n-          //\n-          final int index \u003d r;\n-          noStaleStorages \u003d bm.runBlockOp(() -\u003e\n-            bm.processReport(nodeReg, reports[index].getStorage(),\n-                blocks, context));\n+    for (int r \u003d 0; r \u003c reports.length; r++) {\n+      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n+      //\n+      // BlockManager.processReport accumulates information of prior calls\n+      // for the same node and storage, so the value returned by the last\n+      // call of this loop is the final updated value for noStaleStorage.\n+      //\n+      final int index \u003d r;\n+      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n+        @Override\n+        public Boolean call() throws IOException {\n+          return bm.processReport(nodeReg, reports[index].getStorage(),\n+              blocks, context);\n         }\n-      }\n-    } catch (UnregisteredNodeException une) {\n-      LOG.debug(\"Datanode {} is attempting to report but not register yet.\",\n-          nodeReg);\n-      return RegisterCommand.REGISTER;\n+      });\n     }\n     bm.removeBRLeaseIfNeeded(nodeReg, context);\n \n     BlockManagerFaultInjector.getInstance().\n         incomingBlockReportRpc(nodeReg, context);\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         nn.isActiveState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n        String poolId, final StorageBlockReport[] reports,\n        final BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for (int r \u003d 0; r \u003c reports.length; r++) {\n      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      final int index \u003d r;\n      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n        @Override\n        public Boolean call() throws IOException {\n          return bm.processReport(nodeReg, reports[index].getStorage(),\n              blocks, context);\n        }\n      });\n    }\n    bm.removeBRLeaseIfNeeded(nodeReg, context);\n\n    BlockManagerFaultInjector.getInstance().\n        incomingBlockReportRpc(nodeReg, context);\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        nn.isActiveState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "ae4143a529d74d94f205ca627c31360abfa11bfa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12914. Block report leases cause missing blocks until next report. Contributed by Santosh Marella, He Xiaoqiao.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\nCo-authored-by: He Xiaoqiao \u003chexiaoqiao@apache.org\u003e\n",
      "commitDate": "14/06/19 10:42 AM",
      "commitName": "ae4143a529d74d94f205ca627c31360abfa11bfa",
      "commitAuthor": "Santosh Marella",
      "commitDateOld": "16/04/19 10:34 AM",
      "commitNameOld": "be6c8014e66be919388269b70cb2966c35b8c578",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 59.01,
      "commitsBetweenForRepo": 347,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,45 @@\n   public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n         String poolId, final StorageBlockReport[] reports,\n         final BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n-    for (int r \u003d 0; r \u003c reports.length; r++) {\n-      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n-      //\n-      // BlockManager.processReport accumulates information of prior calls\n-      // for the same node and storage, so the value returned by the last\n-      // call of this loop is the final updated value for noStaleStorage.\n-      //\n-      final int index \u003d r;\n-      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n-        @Override\n-        public Boolean call() throws IOException {\n-          return bm.processReport(nodeReg, reports[index].getStorage(),\n-              blocks, context);\n+    try {\n+      if (bm.checkBlockReportLease(context, nodeReg)) {\n+        for (int r \u003d 0; r \u003c reports.length; r++) {\n+          final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n+          //\n+          // BlockManager.processReport accumulates information of prior calls\n+          // for the same node and storage, so the value returned by the last\n+          // call of this loop is the final updated value for noStaleStorage.\n+          //\n+          final int index \u003d r;\n+          noStaleStorages \u003d bm.runBlockOp(() -\u003e\n+            bm.processReport(nodeReg, reports[index].getStorage(),\n+                blocks, context));\n         }\n-      });\n+      }\n+    } catch (UnregisteredNodeException une) {\n+      LOG.debug(\"Datanode {} is attempting to report but not register yet.\",\n+          nodeReg);\n+      return RegisterCommand.REGISTER;\n     }\n     bm.removeBRLeaseIfNeeded(nodeReg, context);\n \n     BlockManagerFaultInjector.getInstance().\n         incomingBlockReportRpc(nodeReg, context);\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         nn.isActiveState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n        String poolId, final StorageBlockReport[] reports,\n        final BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    try {\n      if (bm.checkBlockReportLease(context, nodeReg)) {\n        for (int r \u003d 0; r \u003c reports.length; r++) {\n          final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n          //\n          // BlockManager.processReport accumulates information of prior calls\n          // for the same node and storage, so the value returned by the last\n          // call of this loop is the final updated value for noStaleStorage.\n          //\n          final int index \u003d r;\n          noStaleStorages \u003d bm.runBlockOp(() -\u003e\n            bm.processReport(nodeReg, reports[index].getStorage(),\n                blocks, context));\n        }\n      }\n    } catch (UnregisteredNodeException une) {\n      LOG.debug(\"Datanode {} is attempting to report but not register yet.\",\n          nodeReg);\n      return RegisterCommand.REGISTER;\n    }\n    bm.removeBRLeaseIfNeeded(nodeReg, context);\n\n    BlockManagerFaultInjector.getInstance().\n        incomingBlockReportRpc(nodeReg, context);\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        nn.isActiveState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "3a78e5ffd83dd96ef9bca72745f27efdda0c9e24": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12975. [SBN read] Changes to the NameNode to support reads from standby. Contributed by Chao Sun.",
      "commitDate": "24/12/18 9:33 AM",
      "commitName": "3a78e5ffd83dd96ef9bca72745f27efdda0c9e24",
      "commitAuthor": "Chao Sun",
      "commitDateOld": "08/11/18 10:01 AM",
      "commitNameOld": "8d99648c203004045a9339ad27258092969145d6",
      "commitAuthorOld": "Kitti Nanasi",
      "daysBetweenCommits": 45.98,
      "commitsBetweenForRepo": 285,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n         String poolId, final StorageBlockReport[] reports,\n         final BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for (int r \u003d 0; r \u003c reports.length; r++) {\n       final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n       final int index \u003d r;\n       noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n         @Override\n         public Boolean call() throws IOException {\n           return bm.processReport(nodeReg, reports[index].getStorage(),\n               blocks, context);\n         }\n       });\n     }\n     bm.removeBRLeaseIfNeeded(nodeReg, context);\n \n     BlockManagerFaultInjector.getInstance().\n         incomingBlockReportRpc(nodeReg, context);\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n-        !nn.isStandbyState() \u0026\u0026\n+        nn.isActiveState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n        String poolId, final StorageBlockReport[] reports,\n        final BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for (int r \u003d 0; r \u003c reports.length; r++) {\n      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      final int index \u003d r;\n      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n        @Override\n        public Boolean call() throws IOException {\n          return bm.processReport(nodeReg, reports[index].getStorage(),\n              blocks, context);\n        }\n      });\n    }\n    bm.removeBRLeaseIfNeeded(nodeReg, context);\n\n    BlockManagerFaultInjector.getInstance().\n        incomingBlockReportRpc(nodeReg, context);\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        nn.isActiveState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "c22cf004425daa9c350df5e365b0db85b1628b40": {
      "type": "Ybodychange",
      "commitMessage": "Confusion/name conflict between NameNodeActivity#BlockReportNumOps and RpcDetailedActivity#BlockReportNumOps. Contributed by Erik Krogen.\n",
      "commitDate": "21/06/17 4:34 PM",
      "commitName": "c22cf004425daa9c350df5e365b0db85b1628b40",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "20/06/17 11:01 PM",
      "commitNameOld": "5db3f9846882c51991d16853a5c431664f3f801f",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,41 @@\n   public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n         String poolId, final StorageBlockReport[] reports,\n         final BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for (int r \u003d 0; r \u003c reports.length; r++) {\n       final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n       final int index \u003d r;\n       noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n         @Override\n         public Boolean call() throws IOException {\n           return bm.processReport(nodeReg, reports[index].getStorage(),\n               blocks, context);\n         }\n       });\n-      metrics.incrStorageBlockReportOps();\n     }\n     bm.removeBRLeaseIfNeeded(nodeReg, context);\n \n     BlockManagerFaultInjector.getInstance().\n         incomingBlockReportRpc(nodeReg, context);\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n        String poolId, final StorageBlockReport[] reports,\n        final BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for (int r \u003d 0; r \u003c reports.length; r++) {\n      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      final int index \u003d r;\n      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n        @Override\n        public Boolean call() throws IOException {\n          return bm.processReport(nodeReg, reports[index].getStorage(),\n              blocks, context);\n        }\n      });\n    }\n    bm.removeBRLeaseIfNeeded(nodeReg, context);\n\n    BlockManagerFaultInjector.getInstance().\n        incomingBlockReportRpc(nodeReg, context);\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "391ce535a739dc92cb90017d759217265a4fd969": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10301. Remove FBR tracking state to fix false zombie storage detection for interleaving block reports. Contributed by Vinitha Gankidi.",
      "commitDate": "14/10/16 6:13 PM",
      "commitName": "391ce535a739dc92cb90017d759217265a4fd969",
      "commitAuthor": "Vinitha Reddy Gankidi",
      "commitDateOld": "12/10/16 1:11 PM",
      "commitNameOld": "85cd06f6636f295ad1f3bf2a90063f4714c9cca7",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 2.21,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,42 @@\n   public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n         String poolId, final StorageBlockReport[] reports,\n         final BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for (int r \u003d 0; r \u003c reports.length; r++) {\n       final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n       final int index \u003d r;\n       noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n         @Override\n         public Boolean call() throws IOException {\n           return bm.processReport(nodeReg, reports[index].getStorage(),\n-              blocks, context, (index \u003d\u003d reports.length - 1));\n+              blocks, context);\n         }\n       });\n       metrics.incrStorageBlockReportOps();\n     }\n+    bm.removeBRLeaseIfNeeded(nodeReg, context);\n+\n     BlockManagerFaultInjector.getInstance().\n         incomingBlockReportRpc(nodeReg, context);\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n        String poolId, final StorageBlockReport[] reports,\n        final BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for (int r \u003d 0; r \u003c reports.length; r++) {\n      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      final int index \u003d r;\n      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n        @Override\n        public Boolean call() throws IOException {\n          return bm.processReport(nodeReg, reports[index].getStorage(),\n              blocks, context);\n        }\n      });\n      metrics.incrStorageBlockReportOps();\n    }\n    bm.removeBRLeaseIfNeeded(nodeReg, context);\n\n    BlockManagerFaultInjector.getInstance().\n        incomingBlockReportRpc(nodeReg, context);\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "c4463f2ef20d2cb634a1249246f83c451975f3dc": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-10301. Interleaving processing of storages from repeated block reports causes false zombie storage detection, removes valid blocks. Contributed by Vinitha Gankidi.\"\n\nThis reverts commit 85a20508bd04851d47c24b7562ec2927d5403446.\n",
      "commitDate": "01/08/16 10:34 PM",
      "commitName": "c4463f2ef20d2cb634a1249246f83c451975f3dc",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "25/07/16 6:50 PM",
      "commitNameOld": "85a20508bd04851d47c24b7562ec2927d5403446",
      "commitAuthorOld": "Vinitha Reddy Gankidi",
      "daysBetweenCommits": 7.16,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,40 @@\n   public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n         String poolId, final StorageBlockReport[] reports,\n         final BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for (int r \u003d 0; r \u003c reports.length; r++) {\n       final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n-      if (!blocks.isStorageReport()) {\n-        //\n-        // BlockManager.processReport accumulates information of prior calls\n-        // for the same node and storage, so the value returned by the last\n-        // call of this loop is the final updated value for noStaleStorage.\n-        //\n-        final int index \u003d r;\n-        noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n-          @Override\n-          public Boolean call()\n-              throws IOException {\n-            return bm.processReport(nodeReg, reports[index].getStorage(),\n-                blocks, context);\n-          }\n-        });\n-        metrics.incrStorageBlockReportOps();\n-      }\n+      //\n+      // BlockManager.processReport accumulates information of prior calls\n+      // for the same node and storage, so the value returned by the last\n+      // call of this loop is the final updated value for noStaleStorage.\n+      //\n+      final int index \u003d r;\n+      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n+        @Override\n+        public Boolean call() throws IOException {\n+          return bm.processReport(nodeReg, reports[index].getStorage(),\n+              blocks, context, (index \u003d\u003d reports.length - 1));\n+        }\n+      });\n+      metrics.incrStorageBlockReportOps();\n     }\n     BlockManagerFaultInjector.getInstance().\n         incomingBlockReportRpc(nodeReg, context);\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n-        context.getTotalRpcs() \u003d\u003d context.getCurRpc() + 1) {\n-      Set\u003cString\u003e storageIDsInBlockReport \u003d new HashSet\u003c\u003e();\n-      for (StorageBlockReport report : reports) {\n-        storageIDsInBlockReport.add(report.getStorage().getStorageID());\n-      }\n-      bm.removeZombieStorages(nodeReg, context, storageIDsInBlockReport);\n-    }\n-\n-    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n        String poolId, final StorageBlockReport[] reports,\n        final BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for (int r \u003d 0; r \u003c reports.length; r++) {\n      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      final int index \u003d r;\n      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n        @Override\n        public Boolean call() throws IOException {\n          return bm.processReport(nodeReg, reports[index].getStorage(),\n              blocks, context, (index \u003d\u003d reports.length - 1));\n        }\n      });\n      metrics.incrStorageBlockReportOps();\n    }\n    BlockManagerFaultInjector.getInstance().\n        incomingBlockReportRpc(nodeReg, context);\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "85a20508bd04851d47c24b7562ec2927d5403446": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10301. Interleaving processing of storages from repeated block reports causes false zombie storage detection, removes valid blocks. Contributed by Vinitha Gankidi.",
      "commitDate": "25/07/16 6:50 PM",
      "commitName": "85a20508bd04851d47c24b7562ec2927d5403446",
      "commitAuthor": "Vinitha Reddy Gankidi",
      "commitDateOld": "31/05/16 5:41 PM",
      "commitNameOld": "93d8a7f2a2d72a1719d02b1ed90678397900b6ed",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 55.05,
      "commitsBetweenForRepo": 483,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,52 @@\n   public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n         String poolId, final StorageBlockReport[] reports,\n         final BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for (int r \u003d 0; r \u003c reports.length; r++) {\n       final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n-      //\n-      // BlockManager.processReport accumulates information of prior calls\n-      // for the same node and storage, so the value returned by the last\n-      // call of this loop is the final updated value for noStaleStorage.\n-      //\n-      final int index \u003d r;\n-      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n-        @Override\n-        public Boolean call() throws IOException {\n-          return bm.processReport(nodeReg, reports[index].getStorage(),\n-              blocks, context, (index \u003d\u003d reports.length - 1));\n-        }\n-      });\n-      metrics.incrStorageBlockReportOps();\n+      if (!blocks.isStorageReport()) {\n+        //\n+        // BlockManager.processReport accumulates information of prior calls\n+        // for the same node and storage, so the value returned by the last\n+        // call of this loop is the final updated value for noStaleStorage.\n+        //\n+        final int index \u003d r;\n+        noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n+          @Override\n+          public Boolean call()\n+              throws IOException {\n+            return bm.processReport(nodeReg, reports[index].getStorage(),\n+                blocks, context);\n+          }\n+        });\n+        metrics.incrStorageBlockReportOps();\n+      }\n     }\n     BlockManagerFaultInjector.getInstance().\n         incomingBlockReportRpc(nodeReg, context);\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n+        context.getTotalRpcs() \u003d\u003d context.getCurRpc() + 1) {\n+      Set\u003cString\u003e storageIDsInBlockReport \u003d new HashSet\u003c\u003e();\n+      for (StorageBlockReport report : reports) {\n+        storageIDsInBlockReport.add(report.getStorage().getStorageID());\n+      }\n+      bm.removeZombieStorages(nodeReg, context, storageIDsInBlockReport);\n+    }\n+\n+    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n        String poolId, final StorageBlockReport[] reports,\n        final BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for (int r \u003d 0; r \u003c reports.length; r++) {\n      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n      if (!blocks.isStorageReport()) {\n        //\n        // BlockManager.processReport accumulates information of prior calls\n        // for the same node and storage, so the value returned by the last\n        // call of this loop is the final updated value for noStaleStorage.\n        //\n        final int index \u003d r;\n        noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n          @Override\n          public Boolean call()\n              throws IOException {\n            return bm.processReport(nodeReg, reports[index].getStorage(),\n                blocks, context);\n          }\n        });\n        metrics.incrStorageBlockReportOps();\n      }\n    }\n    BlockManagerFaultInjector.getInstance().\n        incomingBlockReportRpc(nodeReg, context);\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        context.getTotalRpcs() \u003d\u003d context.getCurRpc() + 1) {\n      Set\u003cString\u003e storageIDsInBlockReport \u003d new HashSet\u003c\u003e();\n      for (StorageBlockReport report : reports) {\n        storageIDsInBlockReport.add(report.getStorage().getStorageID());\n      }\n      bm.removeZombieStorages(nodeReg, context, storageIDsInBlockReport);\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "f741476146574550a1a208d58ef8be76639e5ddc": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "HDFS-9198. Coalesce IBR processing in the NN. (Daryn Sharp via umamahesh)\n",
      "commitDate": "16/12/15 6:16 PM",
      "commitName": "f741476146574550a1a208d58ef8be76639e5ddc",
      "commitAuthor": "Uma Mahesh",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9198. Coalesce IBR processing in the NN. (Daryn Sharp via umamahesh)\n",
          "commitDate": "16/12/15 6:16 PM",
          "commitName": "f741476146574550a1a208d58ef8be76639e5ddc",
          "commitAuthor": "Uma Mahesh",
          "commitDateOld": "30/11/15 7:29 PM",
          "commitNameOld": "1c05393b51748033279bff31dbc5c5cae7fc3a86",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 15.95,
          "commitsBetweenForRepo": 95,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,40 @@\n-  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n-        String poolId, StorageBlockReport[] reports,\n-        BlockReportContext context) throws IOException {\n+  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n+        String poolId, final StorageBlockReport[] reports,\n+        final BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for (int r \u003d 0; r \u003c reports.length; r++) {\n       final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n-      noStaleStorages \u003d bm.processReport(nodeReg, reports[r].getStorage(),\n-          blocks, context, (r \u003d\u003d reports.length - 1));\n+      final int index \u003d r;\n+      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n+        @Override\n+        public Boolean call() throws IOException {\n+          return bm.processReport(nodeReg, reports[index].getStorage(),\n+              blocks, context, (index \u003d\u003d reports.length - 1));\n+        }\n+      });\n       metrics.incrStorageBlockReportOps();\n     }\n     BlockManagerFaultInjector.getInstance().\n         incomingBlockReportRpc(nodeReg, context);\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n        String poolId, final StorageBlockReport[] reports,\n        final BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for (int r \u003d 0; r \u003c reports.length; r++) {\n      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      final int index \u003d r;\n      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n        @Override\n        public Boolean call() throws IOException {\n          return bm.processReport(nodeReg, reports[index].getStorage(),\n              blocks, context, (index \u003d\u003d reports.length - 1));\n        }\n      });\n      metrics.incrStorageBlockReportOps();\n    }\n    BlockManagerFaultInjector.getInstance().\n        incomingBlockReportRpc(nodeReg, context);\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HDFS-9198. Coalesce IBR processing in the NN. (Daryn Sharp via umamahesh)\n",
          "commitDate": "16/12/15 6:16 PM",
          "commitName": "f741476146574550a1a208d58ef8be76639e5ddc",
          "commitAuthor": "Uma Mahesh",
          "commitDateOld": "30/11/15 7:29 PM",
          "commitNameOld": "1c05393b51748033279bff31dbc5c5cae7fc3a86",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 15.95,
          "commitsBetweenForRepo": 95,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,40 @@\n-  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n-        String poolId, StorageBlockReport[] reports,\n-        BlockReportContext context) throws IOException {\n+  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n+        String poolId, final StorageBlockReport[] reports,\n+        final BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for (int r \u003d 0; r \u003c reports.length; r++) {\n       final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n-      noStaleStorages \u003d bm.processReport(nodeReg, reports[r].getStorage(),\n-          blocks, context, (r \u003d\u003d reports.length - 1));\n+      final int index \u003d r;\n+      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n+        @Override\n+        public Boolean call() throws IOException {\n+          return bm.processReport(nodeReg, reports[index].getStorage(),\n+              blocks, context, (index \u003d\u003d reports.length - 1));\n+        }\n+      });\n       metrics.incrStorageBlockReportOps();\n     }\n     BlockManagerFaultInjector.getInstance().\n         incomingBlockReportRpc(nodeReg, context);\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DatanodeCommand blockReport(final DatanodeRegistration nodeReg,\n        String poolId, final StorageBlockReport[] reports,\n        final BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for (int r \u003d 0; r \u003c reports.length; r++) {\n      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      final int index \u003d r;\n      noStaleStorages \u003d bm.runBlockOp(new Callable\u003cBoolean\u003e() {\n        @Override\n        public Boolean call() throws IOException {\n          return bm.processReport(nodeReg, reports[index].getStorage(),\n              blocks, context, (index \u003d\u003d reports.length - 1));\n        }\n      });\n      metrics.incrStorageBlockReportOps();\n    }\n    BlockManagerFaultInjector.getInstance().\n        incomingBlockReportRpc(nodeReg, context);\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
          "extendedDetails": {
            "oldValue": "[nodeReg-DatanodeRegistration, poolId-String, reports-StorageBlockReport[], context-BlockReportContext]",
            "newValue": "[nodeReg-DatanodeRegistration(modifiers-final), poolId-String, reports-StorageBlockReport[](modifiers-final), context-BlockReportContext(modifiers-final)]"
          }
        }
      ]
    },
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7923. The DataNodes should rate-limit their full block reports by asking the NN on heartbeat messages (cmccabe)\n",
      "commitDate": "12/06/15 11:17 AM",
      "commitName": "12b5b06c063d93e6c683c9b6fac9a96912f59e59",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "09/06/15 8:58 PM",
      "commitNameOld": "3107434031e0da149ea2c09c5fc76f1a152435a0",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 2.6,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,34 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n         String poolId, StorageBlockReport[] reports,\n         BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for (int r \u003d 0; r \u003c reports.length; r++) {\n       final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n       noStaleStorages \u003d bm.processReport(nodeReg, reports[r].getStorage(),\n           blocks, context, (r \u003d\u003d reports.length - 1));\n       metrics.incrStorageBlockReportOps();\n     }\n+    BlockManagerFaultInjector.getInstance().\n+        incomingBlockReportRpc(nodeReg, context);\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n        String poolId, StorageBlockReport[] reports,\n        BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for (int r \u003d 0; r \u003c reports.length; r++) {\n      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      noStaleStorages \u003d bm.processReport(nodeReg, reports[r].getStorage(),\n          blocks, context, (r \u003d\u003d reports.length - 1));\n      metrics.incrStorageBlockReportOps();\n    }\n    BlockManagerFaultInjector.getInstance().\n        incomingBlockReportRpc(nodeReg, context);\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "50ee8f4e67a66aa77c5359182f61f3e951844db6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7960. The full block report should prune zombie storages even if they\u0027re not empty. Contributed by Colin McCabe and Eddy Xu.\n",
      "commitDate": "23/03/15 10:00 PM",
      "commitName": "50ee8f4e67a66aa77c5359182f61f3e951844db6",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7960. The full block report should prune zombie storages even if they\u0027re not empty. Contributed by Colin McCabe and Eddy Xu.\n",
          "commitDate": "23/03/15 10:00 PM",
          "commitName": "50ee8f4e67a66aa77c5359182f61f3e951844db6",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "13/03/15 12:23 PM",
          "commitNameOld": "d324164a51a43d72c02567248bd9f0f12b244a40",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 10.4,
          "commitsBetweenForRepo": 104,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,32 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n-      String poolId, StorageBlockReport[] reports) throws IOException {\n+        String poolId, StorageBlockReport[] reports,\n+        BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n-    for(StorageBlockReport r : reports) {\n-      final BlockListAsLongs blocks \u003d r.getBlocks();\n+    for (int r \u003d 0; r \u003c reports.length; r++) {\n+      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n-      noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), blocks);\n+      noStaleStorages \u003d bm.processReport(nodeReg, reports[r].getStorage(),\n+          blocks, context, (r \u003d\u003d reports.length - 1));\n       metrics.incrStorageBlockReportOps();\n     }\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n        String poolId, StorageBlockReport[] reports,\n        BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for (int r \u003d 0; r \u003c reports.length; r++) {\n      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      noStaleStorages \u003d bm.processReport(nodeReg, reports[r].getStorage(),\n          blocks, context, (r \u003d\u003d reports.length - 1));\n      metrics.incrStorageBlockReportOps();\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
          "extendedDetails": {
            "oldValue": "[nodeReg-DatanodeRegistration, poolId-String, reports-StorageBlockReport[]]",
            "newValue": "[nodeReg-DatanodeRegistration, poolId-String, reports-StorageBlockReport[], context-BlockReportContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7960. The full block report should prune zombie storages even if they\u0027re not empty. Contributed by Colin McCabe and Eddy Xu.\n",
          "commitDate": "23/03/15 10:00 PM",
          "commitName": "50ee8f4e67a66aa77c5359182f61f3e951844db6",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "13/03/15 12:23 PM",
          "commitNameOld": "d324164a51a43d72c02567248bd9f0f12b244a40",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 10.4,
          "commitsBetweenForRepo": 104,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,32 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n-      String poolId, StorageBlockReport[] reports) throws IOException {\n+        String poolId, StorageBlockReport[] reports,\n+        BlockReportContext context) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n-    for(StorageBlockReport r : reports) {\n-      final BlockListAsLongs blocks \u003d r.getBlocks();\n+    for (int r \u003d 0; r \u003c reports.length; r++) {\n+      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n-      noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), blocks);\n+      noStaleStorages \u003d bm.processReport(nodeReg, reports[r].getStorage(),\n+          blocks, context, (r \u003d\u003d reports.length - 1));\n       metrics.incrStorageBlockReportOps();\n     }\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n        String poolId, StorageBlockReport[] reports,\n        BlockReportContext context) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for (int r \u003d 0; r \u003c reports.length; r++) {\n      final BlockListAsLongs blocks \u003d reports[r].getBlocks();\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      noStaleStorages \u003d bm.processReport(nodeReg, reports[r].getStorage(),\n          blocks, context, (r \u003d\u003d reports.length - 1));\n      metrics.incrStorageBlockReportOps();\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
          "extendedDetails": {}
        }
      ]
    },
    "d324164a51a43d72c02567248bd9f0f12b244a40": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7435. PB encoding of block reports is very inefficient. Contributed by Daryn Sharp.\n",
      "commitDate": "13/03/15 12:23 PM",
      "commitName": "d324164a51a43d72c02567248bd9f0f12b244a40",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/03/15 1:08 AM",
      "commitNameOld": "3560180b6e9926aa3ee1357da59b28a4b4689a0d",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 9.43,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n     checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for(StorageBlockReport r : reports) {\n-      final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n+      final BlockListAsLongs blocks \u003d r.getBlocks();\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n       noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), blocks);\n       metrics.incrStorageBlockReportOps();\n     }\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for(StorageBlockReport r : reports) {\n      final BlockListAsLongs blocks \u003d r.getBlocks();\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), blocks);\n      metrics.incrStorageBlockReportOps();\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "db334bb8625da97c7e518cbcf477530c7ba7001e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3443. Fix NPE when namenode transition to active during startup by adding checkNNStartup() in NameNodeRpcServer.  Contributed by Vinayakumar B\n",
      "commitDate": "21/01/15 11:33 AM",
      "commitName": "db334bb8625da97c7e518cbcf477530c7ba7001e",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "12/01/15 10:50 PM",
      "commitNameOld": "7e9358feb326d48b8c4f00249e7af5023cebd2e2",
      "commitAuthorOld": "Plamen Jeliazkov",
      "daysBetweenCommits": 8.53,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,30 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n+    checkNNStartup();\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for(StorageBlockReport r : reports) {\n       final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n       noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), blocks);\n       metrics.incrStorageBlockReportOps();\n     }\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    checkNNStartup();\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for(StorageBlockReport r : reports) {\n      final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), blocks);\n      metrics.incrStorageBlockReportOps();\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "4ae8178c5626d188b137e3f806e56fd8661c4970": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6800. Support Datanode layout changes with rolling upgrade. (Contributed by James Thomas)\n",
      "commitDate": "29/08/14 12:26 AM",
      "commitName": "4ae8178c5626d188b137e3f806e56fd8661c4970",
      "commitAuthor": "arp",
      "commitDateOld": "14/08/14 12:11 PM",
      "commitNameOld": "20dcb841ce55b0d414885ceba530c30b5b528b0f",
      "commitAuthorOld": "Charles Lamb",
      "daysBetweenCommits": 14.51,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,29 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for(StorageBlockReport r : reports) {\n       final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n       noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), blocks);\n       metrics.incrStorageBlockReportOps();\n     }\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n+        !namesystem.isRollingUpgrade() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for(StorageBlockReport r : reports) {\n      final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), blocks);\n      metrics.incrStorageBlockReportOps();\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !namesystem.isRollingUpgrade() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "45db4d204b796eee6dd0e39d3cc94b70c47028d4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6794. Update BlockManager methods to use DatanodeStorageInfo where possible. (Arpit Agarwal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615169 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/08/14 9:58 AM",
      "commitName": "45db4d204b796eee6dd0e39d3cc94b70c47028d4",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "30/07/14 10:49 AM",
      "commitNameOld": "535fe14dedbf919442ec03ac573315c7a16a6dbe",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for(StorageBlockReport r : reports) {\n       final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n       //\n       // BlockManager.processReport accumulates information of prior calls\n       // for the same node and storage, so the value returned by the last\n       // call of this loop is the final updated value for noStaleStorage.\n       //\n-      noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n+      noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), blocks);\n       metrics.incrStorageBlockReportOps();\n     }\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for(StorageBlockReport r : reports) {\n      final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), blocks);\n      metrics.incrStorageBlockReportOps();\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "5ac06c8b381f1ab63aeb5117b26e90b28bef026a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6578. add toString method to DatanodeStorage for easier debugging. (Contributed by Yongjun Zhang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1604942 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/06/14 2:30 PM",
      "commitName": "5ac06c8b381f1ab63aeb5117b26e90b28bef026a",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "11/06/14 6:27 PM",
      "commitNameOld": "34e9173c00f7e1ae55dec365850849c793cde8e3",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 11.83,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,28 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean noStaleStorages \u003d false;\n     for(StorageBlockReport r : reports) {\n       final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n+      //\n+      // BlockManager.processReport accumulates information of prior calls\n+      // for the same node and storage, so the value returned by the last\n+      // call of this loop is the final updated value for noStaleStorage.\n+      //\n       noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n       metrics.incrStorageBlockReportOps();\n     }\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for(StorageBlockReport r : reports) {\n      final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n      //\n      // BlockManager.processReport accumulates information of prior calls\n      // for the same node and storage, so the value returned by the last\n      // call of this loop is the final updated value for noStaleStorage.\n      //\n      noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n      metrics.incrStorageBlockReportOps();\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "63fadf0abd9fd0ba1bcf9bfc108c46e34b88309e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6340.DN can\u0027t finalize upgrade. (Contributed by Rahul Singhal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593436 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/14 3:20 PM",
      "commitName": "63fadf0abd9fd0ba1bcf9bfc108c46e34b88309e",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "24/04/14 10:40 AM",
      "commitNameOld": "cf4bc7fdd49974324b177c99b820587cc5854adb",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 14.19,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n-    boolean hasStaleStorages \u003d true;\n+    boolean noStaleStorages \u003d false;\n     for(StorageBlockReport r : reports) {\n       final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n-      hasStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n+      noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n       metrics.incrStorageBlockReportOps();\n     }\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n-        !hasStaleStorages) {\n+        noStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean noStaleStorages \u003d false;\n    for(StorageBlockReport r : reports) {\n      final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n      noStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n      metrics.incrStorageBlockReportOps();\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        noStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "6cc92bf8fc9aa69ca9570945c6add932d586a0d9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6160. TestSafeMode occasionally fails. (Contributed by Arpit Agarwal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1586007 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/14 9:13 AM",
      "commitName": "6cc92bf8fc9aa69ca9570945c6add932d586a0d9",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "18/03/14 8:46 PM",
      "commitNameOld": "2b03ae94216a76a477f3d6250d076ebbf61e998a",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 21.52,
      "commitsBetweenForRepo": 138,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,23 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     boolean hasStaleStorages \u003d true;\n     for(StorageBlockReport r : reports) {\n       final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n       hasStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n+      metrics.incrStorageBlockReportOps();\n     }\n \n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n         !nn.isStandbyState() \u0026\u0026\n         !hasStaleStorages) {\n       return new FinalizeCommand(poolId);\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean hasStaleStorages \u003d true;\n    for(StorageBlockReport r : reports) {\n      final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n      hasStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n      metrics.incrStorageBlockReportOps();\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        !hasStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "5beeb3016954a3ee0c1fb10a2083ffd540cd2c14": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5153. Datanode should send block reports for each storage in a separate message. (Arpit Agarwal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1563254 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/01/14 1:00 PM",
      "commitName": "5beeb3016954a3ee0c1fb10a2083ffd540cd2c14",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "17/12/13 10:47 AM",
      "commitNameOld": "991c453ca3ac141a3f286f74af8401f83c38b230",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 45.09,
      "commitsBetweenForRepo": 229,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,22 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n+    boolean hasStaleStorages \u003d true;\n     for(StorageBlockReport r : reports) {\n       final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n-      bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n+      hasStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n     }\n \n-    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026 !nn.isStandbyState())\n+    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n+        !nn.isStandbyState() \u0026\u0026\n+        !hasStaleStorages) {\n       return new FinalizeCommand(poolId);\n+    }\n+\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    boolean hasStaleStorages \u003d true;\n    for(StorageBlockReport r : reports) {\n      final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n      hasStaleStorages \u003d bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026\n        !nn.isStandbyState() \u0026\u0026\n        !hasStaleStorages) {\n      return new FinalizeCommand(poolId);\n    }\n\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "282be1b38e5cd141ed7e2b2194bfb67a7c2f7f15": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5134. Move blockContentsStale, heartbeatedSinceFailover and firstBlockReport from DatanodeDescriptor to DatanodeStorageInfo; and fix a synchronization problem in DatanodeStorageInfo.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1520938 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/13 3:53 PM",
      "commitName": "282be1b38e5cd141ed7e2b2194bfb67a7c2f7f15",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "03/09/13 12:01 PM",
      "commitNameOld": "336c0344f5fbcbe1b230742af7a38c6b4735bc9e",
      "commitAuthorOld": "",
      "daysBetweenCommits": 5.16,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,17 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n     verifyRequest(nodeReg);\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n     }\n     final BlockManager bm \u003d namesystem.getBlockManager(); \n     for(StorageBlockReport r : reports) {\n       final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n       bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n     }\n \n-    DatanodeDescriptor datanode \u003d bm.getDatanodeManager().getDatanode(nodeReg);\n-    datanode.receivedBlockReport();\n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026 !nn.isStandbyState())\n       return new FinalizeCommand(poolId);\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    for(StorageBlockReport r : reports) {\n      final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n      bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n    }\n\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026 !nn.isStandbyState())\n      return new FinalizeCommand(poolId);\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "5d9d702607913685eab0d8ad077040ddc82bf085": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4987. Namenode changes to track multiple storages per datanode.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1518087 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/08/13 11:30 PM",
      "commitName": "5d9d702607913685eab0d8ad077040ddc82bf085",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "08/08/13 2:46 PM",
      "commitNameOld": "81f9786ae6e238c5cebfd2de856cfc9f02bf004a",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 19.36,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,19 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n     verifyRequest(nodeReg);\n-    BlockListAsLongs blist \u003d new BlockListAsLongs(reports[0].getBlocks());\n     if(blockStateChangeLog.isDebugEnabled()) {\n       blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n-           + \"from \" + nodeReg + \" \" + blist.getNumberOfBlocks()\n-           + \" blocks\");\n+           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n+    }\n+    final BlockManager bm \u003d namesystem.getBlockManager(); \n+    for(StorageBlockReport r : reports) {\n+      final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n+      bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n     }\n \n-    namesystem.getBlockManager().processReport(nodeReg, poolId, blist);\n+    DatanodeDescriptor datanode \u003d bm.getDatanodeManager().getDatanode(nodeReg);\n+    datanode.receivedBlockReport();\n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026 !nn.isStandbyState())\n       return new FinalizeCommand(poolId);\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    verifyRequest(nodeReg);\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \", reports.length\u003d\" + reports.length);\n    }\n    final BlockManager bm \u003d namesystem.getBlockManager(); \n    for(StorageBlockReport r : reports) {\n      final BlockListAsLongs blocks \u003d new BlockListAsLongs(r.getBlocks());\n      bm.processReport(nodeReg, r.getStorage(), poolId, blocks);\n    }\n\n    DatanodeDescriptor datanode \u003d bm.getDatanodeManager().getDatanode(nodeReg);\n    datanode.receivedBlockReport();\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026 !nn.isStandbyState())\n      return new FinalizeCommand(poolId);\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "db71de2e11cfa56a254ef4c92fea5ef4f8c19100": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4080. Add a separate logger for block state change logs to enable turning off those logs. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1407566 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/11/12 10:07 AM",
      "commitName": "db71de2e11cfa56a254ef4c92fea5ef4f8c19100",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "19/09/12 6:33 PM",
      "commitNameOld": "d26f05b7f578432b81bece195881f904bbcd3436",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 50.69,
      "commitsBetweenForRepo": 289,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,15 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n     verifyRequest(nodeReg);\n     BlockListAsLongs blist \u003d new BlockListAsLongs(reports[0].getBlocks());\n-    if(stateChangeLog.isDebugEnabled()) {\n-      stateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n+    if(blockStateChangeLog.isDebugEnabled()) {\n+      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n            + \"from \" + nodeReg + \" \" + blist.getNumberOfBlocks()\n            + \" blocks\");\n     }\n \n     namesystem.getBlockManager().processReport(nodeReg, poolId, blist);\n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026 !nn.isStandbyState())\n       return new FinalizeCommand(poolId);\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    verifyRequest(nodeReg);\n    BlockListAsLongs blist \u003d new BlockListAsLongs(reports[0].getBlocks());\n    if(blockStateChangeLog.isDebugEnabled()) {\n      blockStateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \" \" + blist.getNumberOfBlocks()\n           + \" blocks\");\n    }\n\n    namesystem.getBlockManager().processReport(nodeReg, poolId, blist);\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026 !nn.isStandbyState())\n      return new FinalizeCommand(poolId);\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    },
    "be7dd8333a7e56e732171db0781786987de03195": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3144. Refactor DatanodeID#getName by use. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308205 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/04/12 3:12 PM",
      "commitName": "be7dd8333a7e56e732171db0781786987de03195",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "22/03/12 11:29 PM",
      "commitNameOld": "b795c65f4929330972c07ec2d5d7ce987c5c2316",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 9.65,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,15 @@\n   public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n       String poolId, StorageBlockReport[] reports) throws IOException {\n     verifyRequest(nodeReg);\n     BlockListAsLongs blist \u003d new BlockListAsLongs(reports[0].getBlocks());\n     if(stateChangeLog.isDebugEnabled()) {\n       stateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n-           + \"from \" + nodeReg.getName() + \" \" + blist.getNumberOfBlocks()\n+           + \"from \" + nodeReg + \" \" + blist.getNumberOfBlocks()\n            + \" blocks\");\n     }\n \n     namesystem.getBlockManager().processReport(nodeReg, poolId, blist);\n     if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026 !nn.isStandbyState())\n       return new FinalizeCommand(poolId);\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeCommand blockReport(DatanodeRegistration nodeReg,\n      String poolId, StorageBlockReport[] reports) throws IOException {\n    verifyRequest(nodeReg);\n    BlockListAsLongs blist \u003d new BlockListAsLongs(reports[0].getBlocks());\n    if(stateChangeLog.isDebugEnabled()) {\n      stateChangeLog.debug(\"*BLOCK* NameNode.blockReport: \"\n           + \"from \" + nodeReg + \" \" + blist.getNumberOfBlocks()\n           + \" blocks\");\n    }\n\n    namesystem.getBlockManager().processReport(nodeReg, poolId, blist);\n    if (nn.getFSImage().isUpgradeFinalized() \u0026\u0026 !nn.isStandbyState())\n      return new FinalizeCommand(poolId);\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java",
      "extendedDetails": {}
    }
  }
}