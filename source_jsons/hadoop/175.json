{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RpcProgramNfs3.java",
  "functionName": "handleInternal",
  "functionId": "handleInternal___ctx-ChannelHandlerContext__info-RpcInfo",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
  "functionStartLine": 2159,
  "functionEndLine": 2303,
  "numCommitsSeen": 76,
  "timeTaken": 4016,
  "changeHistory": [
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
    "875aa797caee96572162ff59bc50cf97d1195348",
    "2ecab65e3e290a1ee192b39ec70868863853543a",
    "5c02d2f6225144772dcb975d3144b057b71d6476",
    "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
    "5e18410e06dd63113c49029894007e0878312903",
    "a56a4b6ef06602312144783b7507bf2b82821e4f",
    "613979c8fdacf25fd563395ecc399c4de94d3ee7",
    "15632cd76f12c2f7df50d0df4865fbe3d8261597",
    "58d75576c4d2a03d4954174bc223ed0334b34fee",
    "37f587563a943a827fbff865f5302bac6d202415"
  ],
  "changeHistoryShort": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015": "Ybodychange",
    "875aa797caee96572162ff59bc50cf97d1195348": "Ybodychange",
    "2ecab65e3e290a1ee192b39ec70868863853543a": "Ybodychange",
    "5c02d2f6225144772dcb975d3144b057b71d6476": "Ybodychange",
    "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "5e18410e06dd63113c49029894007e0878312903": "Ybodychange",
    "a56a4b6ef06602312144783b7507bf2b82821e4f": "Ybodychange",
    "613979c8fdacf25fd563395ecc399c4de94d3ee7": "Ybodychange",
    "15632cd76f12c2f7df50d0df4865fbe3d8261597": "Ybodychange",
    "58d75576c4d2a03d4954174bc223ed0334b34fee": "Ybodychange",
    "37f587563a943a827fbff865f5302bac6d202415": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "10/10/17 10:38 AM",
      "commitNameOld": "d6602b5f39833611b4afa4581552f6c4c37e23a8",
      "commitAuthorOld": "Jitendra Pandey",
      "daysBetweenCommits": 126.95,
      "commitsBetweenForRepo": 833,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,152 +1,145 @@\n   public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n     RpcCall rpcCall \u003d (RpcCall) info.header();\n     final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());    \n     int xid \u003d rpcCall.getXid();\n     byte[] data \u003d new byte[info.data().readableBytes()];\n     info.data().readBytes(data);\n     XDR xdr \u003d new XDR(data);\n     XDR out \u003d new XDR();\n     InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n         .getAddress();\n     Credentials credentials \u003d rpcCall.getCredential();\n \n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n       if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n           \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n-        LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n-            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n+        LOG.info(\"Wrong RPC AUTH flavor, {} is not AUTH_SYS or RPCSEC_GSS.\",\n+            credentials.getFlavor());\n         XDR reply \u003d new XDR();\n         RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n         rdr.write(reply);\n \n         ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n             .buffer());\n         RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n         RpcUtil.sendRpcResponse(ctx, rsp);\n         return;\n       }\n     }\n \n     if (!isIdempotent(rpcCall)) {\n       RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n           xid);\n       if (entry !\u003d null) { // in cache\n         if (entry.isCompleted()) {\n-          LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n+          LOG.info(\"Sending the cached reply to retransmitted request {}\",\n+              xid);\n           RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n           return;\n         } else { // else request is in progress\n-          LOG.info(\"Retransmitted request, transaction still in progress \"\n-              + xid);\n+          LOG.info(\"Retransmitted request, transaction still in progress {}\",\n+              xid);\n           // Ignore the request and do nothing\n           return;\n         }\n       }\n     }\n     \n     // Since write and commit could be async, they use their own startTime and\n     // only record success requests.\n     final long startTime \u003d System.nanoTime();\n     \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n       response \u003d getattr(xdr, info);\n       metrics.addGetattr(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n       response \u003d setattr(xdr, info);\n       metrics.addSetattr(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n       response \u003d lookup(xdr, info);\n       metrics.addLookup(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n       response \u003d access(xdr, info);\n       metrics.addAccess(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n       response \u003d readlink(xdr, info);\n       metrics.addReadlink(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n-      if (LOG.isDebugEnabled()) {\n-          LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n-      }\n+      LOG.debug(\"{}{}\", Nfs3Utils.READ_RPC_START, xid);\n       response \u003d read(xdr, info);\n-      if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n-        LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n-      }\n+      LOG.debug(\"{}{}\", Nfs3Utils.READ_RPC_END, xid);\n       metrics.addRead(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n-      if (LOG.isDebugEnabled()) {\n-          LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n-      }\n+      LOG.debug(\"{}{}\", Nfs3Utils.WRITE_RPC_START, xid);\n       response \u003d write(xdr, info);\n       // Write end debug trace is in Nfs3Utils.writeChannel\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n       response \u003d create(xdr, info);\n       metrics.addCreate(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {\n       response \u003d mkdir(xdr, info);\n       metrics.addMkdir(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n       response \u003d symlink(xdr, info);\n       metrics.addSymlink(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n       response \u003d mknod(xdr, info);\n       metrics.addMknod(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n       response \u003d remove(xdr, info);\n       metrics.addRemove(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n       response \u003d rmdir(xdr, info);\n       metrics.addRmdir(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n       response \u003d rename(xdr, info);\n       metrics.addRename(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n       response \u003d link(xdr, info);\n       metrics.addLink(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n       response \u003d readdir(xdr, info);\n       metrics.addReaddir(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n       response \u003d readdirplus(xdr, info);\n       metrics.addReaddirplus(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n       response \u003d fsstat(xdr, info);\n       metrics.addFsstat(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n       response \u003d fsinfo(xdr, info);\n       metrics.addFsinfo(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n       response \u003d pathconf(xdr, info);\n       metrics.addPathconf(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n       response \u003d commit(xdr, info);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }\n     if (response \u003d\u003d null) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n-            + rpcCall.getXid());\n-      }\n+      LOG.debug(\"No sync response, expect an async response for request XID\u003d{}\",\n+          rpcCall.getXid());\n       return;\n     }\n     // TODO: currently we just return VerifierNone\n     out \u003d response.serialize(out, xid, new VerifierNone());\n     ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n         .buffer());\n     RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n \n     if (!isIdempotent(rpcCall)) {\n       rpcCallCache.callCompleted(client, xid, rsp);\n     }\n \n     RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());    \n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n        .getAddress();\n    Credentials credentials \u003d rpcCall.getCredential();\n\n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n          \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n        LOG.info(\"Wrong RPC AUTH flavor, {} is not AUTH_SYS or RPCSEC_GSS.\",\n            credentials.getFlavor());\n        XDR reply \u003d new XDR();\n        RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n        rdr.write(reply);\n\n        ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n            .buffer());\n        RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n        RpcUtil.sendRpcResponse(ctx, rsp);\n        return;\n      }\n    }\n\n    if (!isIdempotent(rpcCall)) {\n      RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n          xid);\n      if (entry !\u003d null) { // in cache\n        if (entry.isCompleted()) {\n          LOG.info(\"Sending the cached reply to retransmitted request {}\",\n              xid);\n          RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n          return;\n        } else { // else request is in progress\n          LOG.info(\"Retransmitted request, transaction still in progress {}\",\n              xid);\n          // Ignore the request and do nothing\n          return;\n        }\n      }\n    }\n    \n    // Since write and commit could be async, they use their own startTime and\n    // only record success requests.\n    final long startTime \u003d System.nanoTime();\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, info);\n      metrics.addGetattr(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, info);\n      metrics.addSetattr(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, info);\n      metrics.addLookup(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, info);\n      metrics.addAccess(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, info);\n      metrics.addReadlink(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      LOG.debug(\"{}{}\", Nfs3Utils.READ_RPC_START, xid);\n      response \u003d read(xdr, info);\n      LOG.debug(\"{}{}\", Nfs3Utils.READ_RPC_END, xid);\n      metrics.addRead(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      LOG.debug(\"{}{}\", Nfs3Utils.WRITE_RPC_START, xid);\n      response \u003d write(xdr, info);\n      // Write end debug trace is in Nfs3Utils.writeChannel\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, info);\n      metrics.addCreate(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {\n      response \u003d mkdir(xdr, info);\n      metrics.addMkdir(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, info);\n      metrics.addSymlink(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, info);\n      metrics.addMknod(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, info);\n      metrics.addRemove(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, info);\n      metrics.addRmdir(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, info);\n      metrics.addRename(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, info);\n      metrics.addLink(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, info);\n      metrics.addReaddir(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, info);\n      metrics.addReaddirplus(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, info);\n      metrics.addFsstat(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, info);\n      metrics.addFsinfo(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr, info);\n      metrics.addPathconf(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, info);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }\n    if (response \u003d\u003d null) {\n      LOG.debug(\"No sync response, expect an async response for request XID\u003d{}\",\n          rpcCall.getXid());\n      return;\n    }\n    // TODO: currently we just return VerifierNone\n    out \u003d response.serialize(out, xid, new VerifierNone());\n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n        .buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n\n    if (!isIdempotent(rpcCall)) {\n      rpcCallCache.callCompleted(client, xid, rsp);\n    }\n\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
      "extendedDetails": {}
    },
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7449. Add metrics to NFS gateway. Contributed by Brandon Li\n",
      "commitDate": "11/12/14 3:40 PM",
      "commitName": "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "09/12/14 8:42 PM",
      "commitNameOld": "195f31a8ef6b15e1962ab945b2f83af98e0058c6",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.79,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,152 @@\n   public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n     RpcCall rpcCall \u003d (RpcCall) info.header();\n     final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());    \n     int xid \u003d rpcCall.getXid();\n     byte[] data \u003d new byte[info.data().readableBytes()];\n     info.data().readBytes(data);\n     XDR xdr \u003d new XDR(data);\n     XDR out \u003d new XDR();\n     InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n         .getAddress();\n     Credentials credentials \u003d rpcCall.getCredential();\n \n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n       if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n           \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n         LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n             + \" is not AUTH_SYS or RPCSEC_GSS.\");\n         XDR reply \u003d new XDR();\n         RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n         rdr.write(reply);\n \n         ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n             .buffer());\n         RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n         RpcUtil.sendRpcResponse(ctx, rsp);\n         return;\n       }\n     }\n \n     if (!isIdempotent(rpcCall)) {\n       RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n           xid);\n       if (entry !\u003d null) { // in cache\n         if (entry.isCompleted()) {\n           LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n           RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n           return;\n         } else { // else request is in progress\n           LOG.info(\"Retransmitted request, transaction still in progress \"\n               + xid);\n           // Ignore the request and do nothing\n           return;\n         }\n       }\n     }\n-\n+    \n+    // Since write and commit could be async, they use their own startTime and\n+    // only record success requests.\n+    final long startTime \u003d System.nanoTime();\n+    \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n       response \u003d getattr(xdr, info);\n+      metrics.addGetattr(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n       response \u003d setattr(xdr, info);\n+      metrics.addSetattr(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n       response \u003d lookup(xdr, info);\n+      metrics.addLookup(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n       response \u003d access(xdr, info);\n+      metrics.addAccess(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n       response \u003d readlink(xdr, info);\n+      metrics.addReadlink(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n       }\n       response \u003d read(xdr, info);\n       if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n         LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n       }\n+      metrics.addRead(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n       }\n       response \u003d write(xdr, info);\n       // Write end debug trace is in Nfs3Utils.writeChannel\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n       response \u003d create(xdr, info);\n+      metrics.addCreate(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {\n       response \u003d mkdir(xdr, info);\n+      metrics.addMkdir(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n       response \u003d symlink(xdr, info);\n+      metrics.addSymlink(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n       response \u003d mknod(xdr, info);\n+      metrics.addMknod(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n       response \u003d remove(xdr, info);\n+      metrics.addRemove(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n       response \u003d rmdir(xdr, info);\n+      metrics.addRmdir(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n       response \u003d rename(xdr, info);\n+      metrics.addRename(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n       response \u003d link(xdr, info);\n+      metrics.addLink(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n       response \u003d readdir(xdr, info);\n+      metrics.addReaddir(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n       response \u003d readdirplus(xdr, info);\n+      metrics.addReaddirplus(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n       response \u003d fsstat(xdr, info);\n+      metrics.addFsstat(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n       response \u003d fsinfo(xdr, info);\n+      metrics.addFsinfo(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n-      response \u003d pathconf(xdr,info);\n+      response \u003d pathconf(xdr, info);\n+      metrics.addPathconf(Nfs3Utils.getElapsedTime(startTime));\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n       response \u003d commit(xdr, info);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }\n     if (response \u003d\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n             + rpcCall.getXid());\n       }\n       return;\n     }\n     // TODO: currently we just return VerifierNone\n     out \u003d response.serialize(out, xid, new VerifierNone());\n     ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n         .buffer());\n     RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n \n     if (!isIdempotent(rpcCall)) {\n       rpcCallCache.callCompleted(client, xid, rsp);\n     }\n \n     RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());    \n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n        .getAddress();\n    Credentials credentials \u003d rpcCall.getCredential();\n\n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n          \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n        XDR reply \u003d new XDR();\n        RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n        rdr.write(reply);\n\n        ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n            .buffer());\n        RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n        RpcUtil.sendRpcResponse(ctx, rsp);\n        return;\n      }\n    }\n\n    if (!isIdempotent(rpcCall)) {\n      RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n          xid);\n      if (entry !\u003d null) { // in cache\n        if (entry.isCompleted()) {\n          LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n          RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n          return;\n        } else { // else request is in progress\n          LOG.info(\"Retransmitted request, transaction still in progress \"\n              + xid);\n          // Ignore the request and do nothing\n          return;\n        }\n      }\n    }\n    \n    // Since write and commit could be async, they use their own startTime and\n    // only record success requests.\n    final long startTime \u003d System.nanoTime();\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, info);\n      metrics.addGetattr(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, info);\n      metrics.addSetattr(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, info);\n      metrics.addLookup(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, info);\n      metrics.addAccess(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, info);\n      metrics.addReadlink(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n      }\n      response \u003d read(xdr, info);\n      if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n        LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n      }\n      metrics.addRead(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n      }\n      response \u003d write(xdr, info);\n      // Write end debug trace is in Nfs3Utils.writeChannel\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, info);\n      metrics.addCreate(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {\n      response \u003d mkdir(xdr, info);\n      metrics.addMkdir(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, info);\n      metrics.addSymlink(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, info);\n      metrics.addMknod(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, info);\n      metrics.addRemove(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, info);\n      metrics.addRmdir(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, info);\n      metrics.addRename(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, info);\n      metrics.addLink(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, info);\n      metrics.addReaddir(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, info);\n      metrics.addReaddirplus(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, info);\n      metrics.addFsstat(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, info);\n      metrics.addFsinfo(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr, info);\n      metrics.addPathconf(Nfs3Utils.getElapsedTime(startTime));\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, info);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }\n    if (response \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n            + rpcCall.getXid());\n      }\n      return;\n    }\n    // TODO: currently we just return VerifierNone\n    out \u003d response.serialize(out, xid, new VerifierNone());\n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n        .buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n\n    if (!isIdempotent(rpcCall)) {\n      rpcCallCache.callCompleted(client, xid, rsp);\n    }\n\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
      "extendedDetails": {}
    },
    "875aa797caee96572162ff59bc50cf97d1195348": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6894. Add XDR parser method for each NFS response. Contributed by Brandon Li.\n",
      "commitDate": "01/10/14 1:18 PM",
      "commitName": "875aa797caee96572162ff59bc50cf97d1195348",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "18/09/14 2:57 PM",
      "commitNameOld": "70be56d093022de9953e14a92dfa1a146bd9a290",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 12.93,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,129 @@\n   public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n     RpcCall rpcCall \u003d (RpcCall) info.header();\n     final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());    \n     int xid \u003d rpcCall.getXid();\n     byte[] data \u003d new byte[info.data().readableBytes()];\n     info.data().readBytes(data);\n     XDR xdr \u003d new XDR(data);\n     XDR out \u003d new XDR();\n     InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n         .getAddress();\n     Credentials credentials \u003d rpcCall.getCredential();\n \n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n       if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n           \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n         LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n             + \" is not AUTH_SYS or RPCSEC_GSS.\");\n         XDR reply \u003d new XDR();\n         RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n         rdr.write(reply);\n \n         ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n             .buffer());\n         RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n         RpcUtil.sendRpcResponse(ctx, rsp);\n         return;\n       }\n     }\n \n     if (!isIdempotent(rpcCall)) {\n       RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n           xid);\n       if (entry !\u003d null) { // in cache\n         if (entry.isCompleted()) {\n           LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n           RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n           return;\n         } else { // else request is in progress\n           LOG.info(\"Retransmitted request, transaction still in progress \"\n               + xid);\n           // Ignore the request and do nothing\n           return;\n         }\n       }\n     }\n \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n       response \u003d getattr(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n       response \u003d setattr(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n       response \u003d lookup(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n       response \u003d access(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n       response \u003d readlink(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n       }\n       response \u003d read(xdr, info);\n       if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n         LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n       }\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n       }\n       response \u003d write(xdr, info);\n       // Write end debug trace is in Nfs3Utils.writeChannel\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n       response \u003d create(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {\n       response \u003d mkdir(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n       response \u003d symlink(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n       response \u003d mknod(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n       response \u003d remove(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n       response \u003d rmdir(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n       response \u003d rename(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n       response \u003d link(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n       response \u003d readdir(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n       response \u003d readdirplus(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n       response \u003d fsstat(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n       response \u003d fsinfo(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n       response \u003d pathconf(xdr,info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n       response \u003d commit(xdr, info);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }\n     if (response \u003d\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n             + rpcCall.getXid());\n       }\n       return;\n     }\n     // TODO: currently we just return VerifierNone\n-    out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n+    out \u003d response.serialize(out, xid, new VerifierNone());\n     ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n         .buffer());\n     RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n \n     if (!isIdempotent(rpcCall)) {\n       rpcCallCache.callCompleted(client, xid, rsp);\n     }\n \n     RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());    \n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n        .getAddress();\n    Credentials credentials \u003d rpcCall.getCredential();\n\n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n          \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n        XDR reply \u003d new XDR();\n        RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n        rdr.write(reply);\n\n        ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n            .buffer());\n        RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n        RpcUtil.sendRpcResponse(ctx, rsp);\n        return;\n      }\n    }\n\n    if (!isIdempotent(rpcCall)) {\n      RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n          xid);\n      if (entry !\u003d null) { // in cache\n        if (entry.isCompleted()) {\n          LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n          RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n          return;\n        } else { // else request is in progress\n          LOG.info(\"Retransmitted request, transaction still in progress \"\n              + xid);\n          // Ignore the request and do nothing\n          return;\n        }\n      }\n    }\n\n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n      }\n      response \u003d read(xdr, info);\n      if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n        LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n      }\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n      }\n      response \u003d write(xdr, info);\n      // Write end debug trace is in Nfs3Utils.writeChannel\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {\n      response \u003d mkdir(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr,info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, info);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }\n    if (response \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n            + rpcCall.getXid());\n      }\n      return;\n    }\n    // TODO: currently we just return VerifierNone\n    out \u003d response.serialize(out, xid, new VerifierNone());\n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n        .buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n\n    if (!isIdempotent(rpcCall)) {\n      rpcCallCache.callCompleted(client, xid, rsp);\n    }\n\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
      "extendedDetails": {}
    },
    "2ecab65e3e290a1ee192b39ec70868863853543a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6439. NFS should not reject NFS requests to the NULL procedure whether port monitoring is enabled or not. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1603622 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/14 1:45 PM",
      "commitName": "2ecab65e3e290a1ee192b39ec70868863853543a",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "30/05/14 4:53 PM",
      "commitNameOld": "42391d260da400593812396c1ffd45d1a371d3cb",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 18.87,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,129 @@\n   public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n     RpcCall rpcCall \u003d (RpcCall) info.header();\n-    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n+    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());    \n     int xid \u003d rpcCall.getXid();\n     byte[] data \u003d new byte[info.data().readableBytes()];\n     info.data().readBytes(data);\n     XDR xdr \u003d new XDR(data);\n     XDR out \u003d new XDR();\n     InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n         .getAddress();\n-    Channel channel \u003d info.channel();\n-\n     Credentials credentials \u003d rpcCall.getCredential();\n+    \n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n       if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n           \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n         LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n             + \" is not AUTH_SYS or RPCSEC_GSS.\");\n         XDR reply \u003d new XDR();\n         RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n         rdr.write(reply);\n \n         ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n             .buffer());\n         RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n         RpcUtil.sendRpcResponse(ctx, rsp);\n         return;\n       }\n     }\n \n     if (!isIdempotent(rpcCall)) {\n       RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n           xid);\n       if (entry !\u003d null) { // in cache\n         if (entry.isCompleted()) {\n           LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n           RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n           return;\n         } else { // else request is in progress\n           LOG.info(\"Retransmitted request, transaction still in progress \"\n               + xid);\n           // Ignore the request and do nothing\n           return;\n         }\n       }\n     }\n     \n-    SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n-        rpcCall.getVerifier());\n-    \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n-      response \u003d getattr(xdr, securityHandler, client);\n+      response \u003d getattr(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n-      response \u003d setattr(xdr, securityHandler, client);\n+      response \u003d setattr(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n-      response \u003d lookup(xdr, securityHandler, client);\n+      response \u003d lookup(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n-      response \u003d access(xdr, securityHandler, client);\n+      response \u003d access(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n-      response \u003d readlink(xdr, securityHandler, client);\n+      response \u003d readlink(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n       }    \n-      response \u003d read(xdr, securityHandler, client);\n+      response \u003d read(xdr, info);\n       if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n         LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n       }\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n       }\n-      response \u003d write(xdr, channel, xid, securityHandler, client);\n+      response \u003d write(xdr, info);\n       // Write end debug trace is in Nfs3Utils.writeChannel\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n-      response \u003d create(xdr, securityHandler, client);\n+      response \u003d create(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n-      response \u003d mkdir(xdr, securityHandler, client);\n+      response \u003d mkdir(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n-      response \u003d symlink(xdr, securityHandler, client);\n+      response \u003d symlink(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n-      response \u003d mknod(xdr, securityHandler, client);\n+      response \u003d mknod(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n-      response \u003d remove(xdr, securityHandler, client);\n+      response \u003d remove(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n-      response \u003d rmdir(xdr, securityHandler, client);\n+      response \u003d rmdir(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n-      response \u003d rename(xdr, securityHandler, client);\n+      response \u003d rename(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n-      response \u003d link(xdr, securityHandler, client);\n+      response \u003d link(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n-      response \u003d readdir(xdr, securityHandler, client);\n+      response \u003d readdir(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n-      response \u003d readdirplus(xdr, securityHandler, client);\n+      response \u003d readdirplus(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n-      response \u003d fsstat(xdr, securityHandler, client);\n+      response \u003d fsstat(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n-      response \u003d fsinfo(xdr, securityHandler, client);\n+      response \u003d fsinfo(xdr, info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n-      response \u003d pathconf(xdr, securityHandler, client);\n+      response \u003d pathconf(xdr,info);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n-      response \u003d commit(xdr, channel, xid, securityHandler, client);\n+      response \u003d commit(xdr, info);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }\n     if (response \u003d\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n             + rpcCall.getXid());\n       }\n       return;\n     }\n     // TODO: currently we just return VerifierNone\n     out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n     ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n         .buffer());\n     RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n \n     if (!isIdempotent(rpcCall)) {\n       rpcCallCache.callCompleted(client, xid, rsp);\n     }\n \n     RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());    \n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n        .getAddress();\n    Credentials credentials \u003d rpcCall.getCredential();\n    \n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n          \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n        XDR reply \u003d new XDR();\n        RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n        rdr.write(reply);\n\n        ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n            .buffer());\n        RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n        RpcUtil.sendRpcResponse(ctx, rsp);\n        return;\n      }\n    }\n\n    if (!isIdempotent(rpcCall)) {\n      RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n          xid);\n      if (entry !\u003d null) { // in cache\n        if (entry.isCompleted()) {\n          LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n          RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n          return;\n        } else { // else request is in progress\n          LOG.info(\"Retransmitted request, transaction still in progress \"\n              + xid);\n          // Ignore the request and do nothing\n          return;\n        }\n      }\n    }\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n      }    \n      response \u003d read(xdr, info);\n      if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n        LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n      }\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n      }\n      response \u003d write(xdr, info);\n      // Write end debug trace is in Nfs3Utils.writeChannel\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n      response \u003d mkdir(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr,info);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, info);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }\n    if (response \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n            + rpcCall.getXid());\n      }\n      return;\n    }\n    // TODO: currently we just return VerifierNone\n    out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n        .buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n\n    if (!isIdempotent(rpcCall)) {\n      rpcCallCache.callCompleted(client, xid, rsp);\n    }\n\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
      "extendedDetails": {}
    },
    "5c02d2f6225144772dcb975d3144b057b71d6476": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5281. COMMIT request should not block. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530461 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/10/13 4:40 PM",
      "commitName": "5c02d2f6225144772dcb975d3144b057b71d6476",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "30/09/13 12:21 PM",
      "commitNameOld": "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 8.18,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,133 @@\n   public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n     RpcCall rpcCall \u003d (RpcCall) info.header();\n     final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n     byte[] data \u003d new byte[info.data().readableBytes()];\n     info.data().readBytes(data);\n     XDR xdr \u003d new XDR(data);\n     XDR out \u003d new XDR();\n     InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n         .getAddress();\n     Channel channel \u003d info.channel();\n \n     Credentials credentials \u003d rpcCall.getCredential();\n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n       if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n           \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n         LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n             + \" is not AUTH_SYS or RPCSEC_GSS.\");\n         XDR reply \u003d new XDR();\n         RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n         rdr.write(reply);\n \n         ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n             .buffer());\n         RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n         RpcUtil.sendRpcResponse(ctx, rsp);\n         return;\n       }\n     }\n \n     if (!isIdempotent(rpcCall)) {\n       RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n           xid);\n       if (entry !\u003d null) { // in cache\n         if (entry.isCompleted()) {\n           LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n           RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n           return;\n         } else { // else request is in progress\n           LOG.info(\"Retransmitted request, transaction still in progress \"\n               + xid);\n           // Ignore the request and do nothing\n           return;\n         }\n       }\n     }\n     \n     SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n         rpcCall.getVerifier());\n     \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n       response \u003d getattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n       response \u003d setattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n       response \u003d lookup(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n       response \u003d access(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n       response \u003d readlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n       }    \n       response \u003d read(xdr, securityHandler, client);\n       if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n         LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n       }\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n       }\n       response \u003d write(xdr, channel, xid, securityHandler, client);\n       // Write end debug trace is in Nfs3Utils.writeChannel\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n       response \u003d create(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n       response \u003d mkdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n       response \u003d symlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n       response \u003d mknod(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n       response \u003d remove(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n       response \u003d rmdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n       response \u003d rename(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n       response \u003d link(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n       response \u003d readdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n       response \u003d readdirplus(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n       response \u003d fsstat(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n       response \u003d fsinfo(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n       response \u003d pathconf(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n-      response \u003d commit(xdr, securityHandler, client);\n+      response \u003d commit(xdr, channel, xid, securityHandler, client);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }\n     if (response \u003d\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n             + rpcCall.getXid());\n       }\n       return;\n     }\n     // TODO: currently we just return VerifierNone\n     out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n     ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n         .buffer());\n     RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n \n     if (!isIdempotent(rpcCall)) {\n       rpcCallCache.callCompleted(client, xid, rsp);\n     }\n \n     RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n        .getAddress();\n    Channel channel \u003d info.channel();\n\n    Credentials credentials \u003d rpcCall.getCredential();\n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n          \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n        XDR reply \u003d new XDR();\n        RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n        rdr.write(reply);\n\n        ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n            .buffer());\n        RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n        RpcUtil.sendRpcResponse(ctx, rsp);\n        return;\n      }\n    }\n\n    if (!isIdempotent(rpcCall)) {\n      RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n          xid);\n      if (entry !\u003d null) { // in cache\n        if (entry.isCompleted()) {\n          LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n          RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n          return;\n        } else { // else request is in progress\n          LOG.info(\"Retransmitted request, transaction still in progress \"\n              + xid);\n          // Ignore the request and do nothing\n          return;\n        }\n      }\n    }\n    \n    SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n        rpcCall.getVerifier());\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n      }    \n      response \u003d read(xdr, securityHandler, client);\n      if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n        LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n      }\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n      }\n      response \u003d write(xdr, channel, xid, securityHandler, client);\n      // Write end debug trace is in Nfs3Utils.writeChannel\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n      response \u003d mkdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, channel, xid, securityHandler, client);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }\n    if (response \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n            + rpcCall.getXid());\n      }\n      return;\n    }\n    // TODO: currently we just return VerifierNone\n    out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n        .buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n\n    if (!isIdempotent(rpcCall)) {\n      rpcCallCache.callCompleted(client, xid, rsp);\n    }\n\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
      "extendedDetails": {}
    },
    "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5230. Introduce RpcInfo to decouple XDR classes from the RPC API. Contributed by Haohui Mai\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527726 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/09/13 12:21 PM",
      "commitName": "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
      "commitAuthor": "Brandon Li",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5230. Introduce RpcInfo to decouple XDR classes from the RPC API. Contributed by Haohui Mai\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527726 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/09/13 12:21 PM",
          "commitName": "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "17/09/13 11:08 PM",
          "commitNameOld": "5e18410e06dd63113c49029894007e0878312903",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 12.55,
          "commitsBetweenForRepo": 68,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,133 @@\n-  public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n-      InetAddress client, Channel channel) {\n+  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n+    RpcCall rpcCall \u003d (RpcCall) info.header();\n     final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n+    byte[] data \u003d new byte[info.data().readableBytes()];\n+    info.data().readBytes(data);\n+    XDR xdr \u003d new XDR(data);\n+    XDR out \u003d new XDR();\n+    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n+        .getAddress();\n+    Channel channel \u003d info.channel();\n \n     Credentials credentials \u003d rpcCall.getCredential();\n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n-      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS\n-          \u0026\u0026 rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n-        LOG.info(\"Wrong RPC AUTH flavor, \"\n-            + rpcCall.getCredential().getFlavor()\n+      if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n+          \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n+        LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n             + \" is not AUTH_SYS or RPCSEC_GSS.\");\n         XDR reply \u003d new XDR();\n         RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n         rdr.write(reply);\n-        return reply;\n+\n+        ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n+            .buffer());\n+        RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n+        RpcUtil.sendRpcResponse(ctx, rsp);\n+        return;\n+      }\n+    }\n+\n+    if (!isIdempotent(rpcCall)) {\n+      RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n+          xid);\n+      if (entry !\u003d null) { // in cache\n+        if (entry.isCompleted()) {\n+          LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n+          RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n+          return;\n+        } else { // else request is in progress\n+          LOG.info(\"Retransmitted request, transaction still in progress \"\n+              + xid);\n+          // Ignore the request and do nothing\n+          return;\n+        }\n       }\n     }\n     \n     SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n         rpcCall.getVerifier());\n     \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n       response \u003d getattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n       response \u003d setattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n       response \u003d lookup(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n       response \u003d access(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n       response \u003d readlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n       }    \n       response \u003d read(xdr, securityHandler, client);\n       if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n         LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n       }\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n       }\n       response \u003d write(xdr, channel, xid, securityHandler, client);\n       // Write end debug trace is in Nfs3Utils.writeChannel\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n       response \u003d create(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n       response \u003d mkdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n       response \u003d symlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n       response \u003d mknod(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n       response \u003d remove(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n       response \u003d rmdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n       response \u003d rename(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n       response \u003d link(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n       response \u003d readdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n       response \u003d readdirplus(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n       response \u003d fsstat(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n       response \u003d fsinfo(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n       response \u003d pathconf(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n       response \u003d commit(xdr, securityHandler, client);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }\n-    if (response !\u003d null) {\n-      // TODO: currently we just return VerifierNone\n-      out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n+    if (response \u003d\u003d null) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n+            + rpcCall.getXid());\n+      }\n+      return;\n+    }\n+    // TODO: currently we just return VerifierNone\n+    out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n+    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n+        .buffer());\n+    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n+\n+    if (!isIdempotent(rpcCall)) {\n+      rpcCallCache.callCompleted(client, xid, rsp);\n     }\n \n-    return out;\n+    RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n        .getAddress();\n    Channel channel \u003d info.channel();\n\n    Credentials credentials \u003d rpcCall.getCredential();\n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n          \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n        XDR reply \u003d new XDR();\n        RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n        rdr.write(reply);\n\n        ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n            .buffer());\n        RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n        RpcUtil.sendRpcResponse(ctx, rsp);\n        return;\n      }\n    }\n\n    if (!isIdempotent(rpcCall)) {\n      RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n          xid);\n      if (entry !\u003d null) { // in cache\n        if (entry.isCompleted()) {\n          LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n          RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n          return;\n        } else { // else request is in progress\n          LOG.info(\"Retransmitted request, transaction still in progress \"\n              + xid);\n          // Ignore the request and do nothing\n          return;\n        }\n      }\n    }\n    \n    SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n        rpcCall.getVerifier());\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n      }    \n      response \u003d read(xdr, securityHandler, client);\n      if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n        LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n      }\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n      }\n      response \u003d write(xdr, channel, xid, securityHandler, client);\n      // Write end debug trace is in Nfs3Utils.writeChannel\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n      response \u003d mkdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, securityHandler, client);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }\n    if (response \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n            + rpcCall.getXid());\n      }\n      return;\n    }\n    // TODO: currently we just return VerifierNone\n    out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n        .buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n\n    if (!isIdempotent(rpcCall)) {\n      rpcCallCache.callCompleted(client, xid, rsp);\n    }\n\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
          "extendedDetails": {
            "oldValue": "[rpcCall-RpcCall, xdr-XDR(modifiers-final), out-XDR, client-InetAddress, channel-Channel]",
            "newValue": "[ctx-ChannelHandlerContext, info-RpcInfo]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5230. Introduce RpcInfo to decouple XDR classes from the RPC API. Contributed by Haohui Mai\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527726 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/09/13 12:21 PM",
          "commitName": "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "17/09/13 11:08 PM",
          "commitNameOld": "5e18410e06dd63113c49029894007e0878312903",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 12.55,
          "commitsBetweenForRepo": 68,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,133 @@\n-  public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n-      InetAddress client, Channel channel) {\n+  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n+    RpcCall rpcCall \u003d (RpcCall) info.header();\n     final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n+    byte[] data \u003d new byte[info.data().readableBytes()];\n+    info.data().readBytes(data);\n+    XDR xdr \u003d new XDR(data);\n+    XDR out \u003d new XDR();\n+    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n+        .getAddress();\n+    Channel channel \u003d info.channel();\n \n     Credentials credentials \u003d rpcCall.getCredential();\n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n-      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS\n-          \u0026\u0026 rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n-        LOG.info(\"Wrong RPC AUTH flavor, \"\n-            + rpcCall.getCredential().getFlavor()\n+      if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n+          \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n+        LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n             + \" is not AUTH_SYS or RPCSEC_GSS.\");\n         XDR reply \u003d new XDR();\n         RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n         rdr.write(reply);\n-        return reply;\n+\n+        ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n+            .buffer());\n+        RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n+        RpcUtil.sendRpcResponse(ctx, rsp);\n+        return;\n+      }\n+    }\n+\n+    if (!isIdempotent(rpcCall)) {\n+      RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n+          xid);\n+      if (entry !\u003d null) { // in cache\n+        if (entry.isCompleted()) {\n+          LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n+          RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n+          return;\n+        } else { // else request is in progress\n+          LOG.info(\"Retransmitted request, transaction still in progress \"\n+              + xid);\n+          // Ignore the request and do nothing\n+          return;\n+        }\n       }\n     }\n     \n     SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n         rpcCall.getVerifier());\n     \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n       response \u003d getattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n       response \u003d setattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n       response \u003d lookup(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n       response \u003d access(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n       response \u003d readlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n       }    \n       response \u003d read(xdr, securityHandler, client);\n       if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n         LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n       }\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n       }\n       response \u003d write(xdr, channel, xid, securityHandler, client);\n       // Write end debug trace is in Nfs3Utils.writeChannel\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n       response \u003d create(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n       response \u003d mkdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n       response \u003d symlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n       response \u003d mknod(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n       response \u003d remove(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n       response \u003d rmdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n       response \u003d rename(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n       response \u003d link(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n       response \u003d readdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n       response \u003d readdirplus(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n       response \u003d fsstat(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n       response \u003d fsinfo(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n       response \u003d pathconf(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n       response \u003d commit(xdr, securityHandler, client);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }\n-    if (response !\u003d null) {\n-      // TODO: currently we just return VerifierNone\n-      out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n+    if (response \u003d\u003d null) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n+            + rpcCall.getXid());\n+      }\n+      return;\n+    }\n+    // TODO: currently we just return VerifierNone\n+    out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n+    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n+        .buffer());\n+    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n+\n+    if (!isIdempotent(rpcCall)) {\n+      rpcCallCache.callCompleted(client, xid, rsp);\n     }\n \n-    return out;\n+    RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n        .getAddress();\n    Channel channel \u003d info.channel();\n\n    Credentials credentials \u003d rpcCall.getCredential();\n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n          \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n        XDR reply \u003d new XDR();\n        RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n        rdr.write(reply);\n\n        ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n            .buffer());\n        RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n        RpcUtil.sendRpcResponse(ctx, rsp);\n        return;\n      }\n    }\n\n    if (!isIdempotent(rpcCall)) {\n      RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n          xid);\n      if (entry !\u003d null) { // in cache\n        if (entry.isCompleted()) {\n          LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n          RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n          return;\n        } else { // else request is in progress\n          LOG.info(\"Retransmitted request, transaction still in progress \"\n              + xid);\n          // Ignore the request and do nothing\n          return;\n        }\n      }\n    }\n    \n    SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n        rpcCall.getVerifier());\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n      }    \n      response \u003d read(xdr, securityHandler, client);\n      if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n        LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n      }\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n      }\n      response \u003d write(xdr, channel, xid, securityHandler, client);\n      // Write end debug trace is in Nfs3Utils.writeChannel\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n      response \u003d mkdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, securityHandler, client);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }\n    if (response \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n            + rpcCall.getXid());\n      }\n      return;\n    }\n    // TODO: currently we just return VerifierNone\n    out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n        .buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n\n    if (!isIdempotent(rpcCall)) {\n      rpcCallCache.callCompleted(client, xid, rsp);\n    }\n\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
          "extendedDetails": {
            "oldValue": "XDR",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5230. Introduce RpcInfo to decouple XDR classes from the RPC API. Contributed by Haohui Mai\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527726 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/09/13 12:21 PM",
          "commitName": "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "17/09/13 11:08 PM",
          "commitNameOld": "5e18410e06dd63113c49029894007e0878312903",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 12.55,
          "commitsBetweenForRepo": 68,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,133 @@\n-  public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n-      InetAddress client, Channel channel) {\n+  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n+    RpcCall rpcCall \u003d (RpcCall) info.header();\n     final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n+    byte[] data \u003d new byte[info.data().readableBytes()];\n+    info.data().readBytes(data);\n+    XDR xdr \u003d new XDR(data);\n+    XDR out \u003d new XDR();\n+    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n+        .getAddress();\n+    Channel channel \u003d info.channel();\n \n     Credentials credentials \u003d rpcCall.getCredential();\n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n-      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS\n-          \u0026\u0026 rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n-        LOG.info(\"Wrong RPC AUTH flavor, \"\n-            + rpcCall.getCredential().getFlavor()\n+      if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n+          \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n+        LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n             + \" is not AUTH_SYS or RPCSEC_GSS.\");\n         XDR reply \u003d new XDR();\n         RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n         rdr.write(reply);\n-        return reply;\n+\n+        ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n+            .buffer());\n+        RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n+        RpcUtil.sendRpcResponse(ctx, rsp);\n+        return;\n+      }\n+    }\n+\n+    if (!isIdempotent(rpcCall)) {\n+      RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n+          xid);\n+      if (entry !\u003d null) { // in cache\n+        if (entry.isCompleted()) {\n+          LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n+          RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n+          return;\n+        } else { // else request is in progress\n+          LOG.info(\"Retransmitted request, transaction still in progress \"\n+              + xid);\n+          // Ignore the request and do nothing\n+          return;\n+        }\n       }\n     }\n     \n     SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n         rpcCall.getVerifier());\n     \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n       response \u003d getattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n       response \u003d setattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n       response \u003d lookup(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n       response \u003d access(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n       response \u003d readlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n       }    \n       response \u003d read(xdr, securityHandler, client);\n       if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n         LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n       }\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n       }\n       response \u003d write(xdr, channel, xid, securityHandler, client);\n       // Write end debug trace is in Nfs3Utils.writeChannel\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n       response \u003d create(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n       response \u003d mkdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n       response \u003d symlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n       response \u003d mknod(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n       response \u003d remove(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n       response \u003d rmdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n       response \u003d rename(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n       response \u003d link(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n       response \u003d readdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n       response \u003d readdirplus(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n       response \u003d fsstat(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n       response \u003d fsinfo(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n       response \u003d pathconf(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n       response \u003d commit(xdr, securityHandler, client);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }\n-    if (response !\u003d null) {\n-      // TODO: currently we just return VerifierNone\n-      out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n+    if (response \u003d\u003d null) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n+            + rpcCall.getXid());\n+      }\n+      return;\n+    }\n+    // TODO: currently we just return VerifierNone\n+    out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n+    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n+        .buffer());\n+    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n+\n+    if (!isIdempotent(rpcCall)) {\n+      rpcCallCache.callCompleted(client, xid, rsp);\n     }\n \n-    return out;\n+    RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress())\n        .getAddress();\n    Channel channel \u003d info.channel();\n\n    Credentials credentials \u003d rpcCall.getCredential();\n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (credentials.getFlavor() !\u003d AuthFlavor.AUTH_SYS\n          \u0026\u0026 credentials.getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \" + credentials.getFlavor()\n            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n        XDR reply \u003d new XDR();\n        RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n        rdr.write(reply);\n\n        ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(reply.asReadOnlyWrap()\n            .buffer());\n        RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n        RpcUtil.sendRpcResponse(ctx, rsp);\n        return;\n      }\n    }\n\n    if (!isIdempotent(rpcCall)) {\n      RpcCallCache.CacheEntry entry \u003d rpcCallCache.checkOrAddToCache(client,\n          xid);\n      if (entry !\u003d null) { // in cache\n        if (entry.isCompleted()) {\n          LOG.info(\"Sending the cached reply to retransmitted request \" + xid);\n          RpcUtil.sendRpcResponse(ctx, entry.getResponse());\n          return;\n        } else { // else request is in progress\n          LOG.info(\"Retransmitted request, transaction still in progress \"\n              + xid);\n          // Ignore the request and do nothing\n          return;\n        }\n      }\n    }\n    \n    SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n        rpcCall.getVerifier());\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n      }    \n      response \u003d read(xdr, securityHandler, client);\n      if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n        LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n      }\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n      }\n      response \u003d write(xdr, channel, xid, securityHandler, client);\n      // Write end debug trace is in Nfs3Utils.writeChannel\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n      response \u003d mkdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, securityHandler, client);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }\n    if (response \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No sync response, expect an async response for request XID\u003d\"\n            + rpcCall.getXid());\n      }\n      return;\n    }\n    // TODO: currently we just return VerifierNone\n    out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap()\n        .buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n\n    if (!isIdempotent(rpcCall)) {\n      rpcCallCache.callCompleted(client, xid, rsp);\n    }\n\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
          "extendedDetails": {}
        }
      ]
    },
    "5e18410e06dd63113c49029894007e0878312903": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5212. Refactor RpcMessage and NFS3Response to support different types of authentication information. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1524298 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/09/13 11:08 PM",
      "commitName": "5e18410e06dd63113c49029894007e0878312903",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/09/13 4:14 PM",
      "commitNameOld": "a56a4b6ef06602312144783b7507bf2b82821e4f",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 4.29,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,93 @@\n   public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n       InetAddress client, Channel channel) {\n     final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n \n     Credentials credentials \u003d rpcCall.getCredential();\n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n       if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS\n           \u0026\u0026 rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n         LOG.info(\"Wrong RPC AUTH flavor, \"\n             + rpcCall.getCredential().getFlavor()\n             + \" is not AUTH_SYS or RPCSEC_GSS.\");\n         XDR reply \u003d new XDR();\n-        reply \u003d RpcDeniedReply.voidReply(reply, xid,\n+        RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n-            RpcDeniedReply.RejectState.AUTH_ERROR);\n+            RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n+        rdr.write(reply);\n         return reply;\n       }\n     }\n     \n     SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n         rpcCall.getVerifier());\n     \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n       response \u003d getattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n       response \u003d setattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n       response \u003d lookup(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n       response \u003d access(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n       response \u003d readlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n       }    \n       response \u003d read(xdr, securityHandler, client);\n       if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n         LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n       }\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n       if (LOG.isDebugEnabled()) {\n           LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n       }\n       response \u003d write(xdr, channel, xid, securityHandler, client);\n       // Write end debug trace is in Nfs3Utils.writeChannel\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n       response \u003d create(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n       response \u003d mkdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n       response \u003d symlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n       response \u003d mknod(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n       response \u003d remove(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n       response \u003d rmdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n       response \u003d rename(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n       response \u003d link(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n       response \u003d readdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n       response \u003d readdirplus(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n       response \u003d fsstat(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n       response \u003d fsinfo(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n       response \u003d pathconf(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n       response \u003d commit(xdr, securityHandler, client);\n     } else {\n       // Invalid procedure\n-      RpcAcceptedReply.voidReply(out, xid,\n-          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n+      RpcAcceptedReply.getInstance(xid,\n+          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n+          out);\n     }\n     if (response !\u003d null) {\n-      out \u003d response.send(out, xid);\n+      // TODO: currently we just return VerifierNone\n+      out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n     }\n \n     return out;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n      InetAddress client, Channel channel) {\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n\n    Credentials credentials \u003d rpcCall.getCredential();\n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS\n          \u0026\u0026 rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \"\n            + rpcCall.getCredential().getFlavor()\n            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n        XDR reply \u003d new XDR();\n        RpcDeniedReply rdr \u003d new RpcDeniedReply(xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());\n        rdr.write(reply);\n        return reply;\n      }\n    }\n    \n    SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n        rpcCall.getVerifier());\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n      }    \n      response \u003d read(xdr, securityHandler, client);\n      if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n        LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n      }\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n      }\n      response \u003d write(xdr, channel, xid, securityHandler, client);\n      // Write end debug trace is in Nfs3Utils.writeChannel\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n      response \u003d mkdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, securityHandler, client);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }\n    if (response !\u003d null) {\n      // TODO: currently we just return VerifierNone\n      out \u003d response.writeHeaderAndResponse(out, xid, new VerifierNone());\n    }\n\n    return out;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
      "extendedDetails": {}
    },
    "a56a4b6ef06602312144783b7507bf2b82821e4f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5199 Add more debug trace for NFS READ and WRITE. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1523140 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/09/13 4:14 PM",
      "commitName": "a56a4b6ef06602312144783b7507bf2b82821e4f",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "12/09/13 9:21 PM",
      "commitNameOld": "ede10b8a1f9a4d099c16469f827345cb359cef3d",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,90 @@\n   public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n       InetAddress client, Channel channel) {\n     final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n \n     Credentials credentials \u003d rpcCall.getCredential();\n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n       if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS\n           \u0026\u0026 rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n         LOG.info(\"Wrong RPC AUTH flavor, \"\n             + rpcCall.getCredential().getFlavor()\n             + \" is not AUTH_SYS or RPCSEC_GSS.\");\n         XDR reply \u003d new XDR();\n         reply \u003d RpcDeniedReply.voidReply(reply, xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR);\n         return reply;\n       }\n     }\n     \n     SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n         rpcCall.getVerifier());\n     \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n       response \u003d getattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n       response \u003d setattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n       response \u003d lookup(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n       response \u003d access(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n       response \u003d readlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n+      if (LOG.isDebugEnabled()) {\n+          LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n+      }    \n       response \u003d read(xdr, securityHandler, client);\n+      if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n+        LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n+      }\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n+      if (LOG.isDebugEnabled()) {\n+          LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n+      }\n       response \u003d write(xdr, channel, xid, securityHandler, client);\n+      // Write end debug trace is in Nfs3Utils.writeChannel\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n       response \u003d create(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n       response \u003d mkdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n       response \u003d symlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n       response \u003d mknod(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n       response \u003d remove(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n       response \u003d rmdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n       response \u003d rename(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n       response \u003d link(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n       response \u003d readdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n       response \u003d readdirplus(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n       response \u003d fsstat(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n       response \u003d fsinfo(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n       response \u003d pathconf(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n       response \u003d commit(xdr, securityHandler, client);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.voidReply(out, xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n     }\n     if (response !\u003d null) {\n       out \u003d response.send(out, xid);\n     }\n+\n     return out;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n      InetAddress client, Channel channel) {\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n\n    Credentials credentials \u003d rpcCall.getCredential();\n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS\n          \u0026\u0026 rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \"\n            + rpcCall.getCredential().getFlavor()\n            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n        XDR reply \u003d new XDR();\n        reply \u003d RpcDeniedReply.voidReply(reply, xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR);\n        return reply;\n      }\n    }\n    \n    SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n        rpcCall.getVerifier());\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.READ_RPC_START + xid);\n      }    \n      response \u003d read(xdr, securityHandler, client);\n      if (LOG.isDebugEnabled() \u0026\u0026 (nfsproc3 \u003d\u003d NFSPROC3.READ)) {\n        LOG.debug(Nfs3Utils.READ_RPC_END + xid);\n      }\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      if (LOG.isDebugEnabled()) {\n          LOG.debug(Nfs3Utils.WRITE_RPC_START + xid);\n      }\n      response \u003d write(xdr, channel, xid, securityHandler, client);\n      // Write end debug trace is in Nfs3Utils.writeChannel\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n      response \u003d mkdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, securityHandler, client);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.voidReply(out, xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n    }\n    if (response !\u003d null) {\n      out \u003d response.send(out, xid);\n    }\n\n    return out;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
      "extendedDetails": {}
    },
    "613979c8fdacf25fd563395ecc399c4de94d3ee7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5085. Refactor o.a.h.nfs to support different types of authentications. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1521601 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/09/13 12:29 PM",
      "commitName": "613979c8fdacf25fd563395ecc399c4de94d3ee7",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "31/08/13 2:12 PM",
      "commitNameOld": "cbca1668317f3f2d295eea53d7bd020bda4a810f",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 9.93,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,79 @@\n   public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n       InetAddress client, Channel channel) {\n     final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n-    RpcAuthSys authSys \u003d null;\n-    \n+\n+    Credentials credentials \u003d rpcCall.getCredential();\n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n-      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS) {\n+      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS\n+          \u0026\u0026 rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n         LOG.info(\"Wrong RPC AUTH flavor, \"\n-            + rpcCall.getCredential().getFlavor() + \" is not AUTH_SYS.\");\n+            + rpcCall.getCredential().getFlavor()\n+            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n         XDR reply \u003d new XDR();\n         reply \u003d RpcDeniedReply.voidReply(reply, xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR);\n         return reply;\n       }\n-      authSys \u003d RpcAuthSys.from(rpcCall.getCredential().getBody());\n     }\n     \n+    SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n+        rpcCall.getVerifier());\n+    \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n-      response \u003d getattr(xdr, authSys, client);\n+      response \u003d getattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n-      response \u003d setattr(xdr, authSys, client);\n+      response \u003d setattr(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n-      response \u003d lookup(xdr, authSys, client);\n+      response \u003d lookup(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n-      response \u003d access(xdr, authSys, client);\n+      response \u003d access(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n-      response \u003d readlink(xdr, authSys, client);\n+      response \u003d readlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n-      response \u003d read(xdr, authSys, client);\n+      response \u003d read(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n-      response \u003d write(xdr, channel, xid, authSys, client);\n+      response \u003d write(xdr, channel, xid, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n-      response \u003d create(xdr, authSys, client);\n+      response \u003d create(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n-      response \u003d mkdir(xdr, authSys, client);\n+      response \u003d mkdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n-      response \u003d symlink(xdr, authSys, client);\n+      response \u003d symlink(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n-      response \u003d mknod(xdr, authSys, client);\n+      response \u003d mknod(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n-      response \u003d remove(xdr, authSys, client);\n+      response \u003d remove(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n-      response \u003d rmdir(xdr, authSys, client);\n+      response \u003d rmdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n-      response \u003d rename(xdr, authSys, client);\n+      response \u003d rename(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n-      response \u003d link(xdr, authSys, client);\n+      response \u003d link(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n-      response \u003d readdir(xdr, authSys, client);\n+      response \u003d readdir(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n-      response \u003d readdirplus(xdr, authSys, client);\n+      response \u003d readdirplus(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n-      response \u003d fsstat(xdr, authSys, client);\n+      response \u003d fsstat(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n-      response \u003d fsinfo(xdr, authSys, client);\n+      response \u003d fsinfo(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n-      response \u003d pathconf(xdr, authSys, client);\n+      response \u003d pathconf(xdr, securityHandler, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n-      response \u003d commit(xdr, authSys, client);\n+      response \u003d commit(xdr, securityHandler, client);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.voidReply(out, xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n     }\n     if (response !\u003d null) {\n       out \u003d response.send(out, xid);\n     }\n     return out;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n      InetAddress client, Channel channel) {\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n\n    Credentials credentials \u003d rpcCall.getCredential();\n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS\n          \u0026\u0026 rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.RPCSEC_GSS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \"\n            + rpcCall.getCredential().getFlavor()\n            + \" is not AUTH_SYS or RPCSEC_GSS.\");\n        XDR reply \u003d new XDR();\n        reply \u003d RpcDeniedReply.voidReply(reply, xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR);\n        return reply;\n      }\n    }\n    \n    SecurityHandler securityHandler \u003d getSecurityHandler(credentials,\n        rpcCall.getVerifier());\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      response \u003d read(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      response \u003d write(xdr, channel, xid, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n      response \u003d mkdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr, securityHandler, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, securityHandler, client);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.voidReply(out, xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n    }\n    if (response !\u003d null) {\n      out \u003d response.send(out, xid);\n    }\n    return out;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
      "extendedDetails": {}
    },
    "15632cd76f12c2f7df50d0df4865fbe3d8261597": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4947 Add NFS server export table to control export by hostname or IP range. Contributed by Jing Zhao\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1517040 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/08/13 2:14 PM",
      "commitName": "15632cd76f12c2f7df50d0df4865fbe3d8261597",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "19/08/13 2:54 PM",
      "commitNameOld": "c9b89de0eacf15f21faa3a7ba30d4773f571c9a4",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 3.97,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n       InetAddress client, Channel channel) {\n     final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n     RpcAuthSys authSys \u003d null;\n     \n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n     if (nfsproc3 !\u003d NFSPROC3.NULL) {\n       if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS) {\n         LOG.info(\"Wrong RPC AUTH flavor, \"\n             + rpcCall.getCredential().getFlavor() + \" is not AUTH_SYS.\");\n         XDR reply \u003d new XDR();\n         reply \u003d RpcDeniedReply.voidReply(reply, xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR);\n         return reply;\n       }\n       authSys \u003d RpcAuthSys.from(rpcCall.getCredential().getBody());\n     }\n     \n     NFS3Response response \u003d null;\n     if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n-      response \u003d getattr(xdr, authSys);\n+      response \u003d getattr(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n-      response \u003d setattr(xdr, authSys);\n+      response \u003d setattr(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n-      response \u003d lookup(xdr, authSys);\n+      response \u003d lookup(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n-      response \u003d access(xdr, authSys);\n+      response \u003d access(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n-      response \u003d readlink(xdr, authSys);\n+      response \u003d readlink(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n-      response \u003d read(xdr, authSys);\n+      response \u003d read(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n-      response \u003d write(xdr, channel, xid, authSys);\n+      response \u003d write(xdr, channel, xid, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n-      response \u003d create(xdr, authSys);\n+      response \u003d create(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n-      response \u003d mkdir(xdr, authSys);\n+      response \u003d mkdir(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n-      response \u003d symlink(xdr, authSys);\n+      response \u003d symlink(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n-      response \u003d mknod(xdr, authSys);\n+      response \u003d mknod(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n-      response \u003d remove(xdr, authSys);\n+      response \u003d remove(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n-      response \u003d rmdir(xdr, authSys);\n+      response \u003d rmdir(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n-      response \u003d rename(xdr, authSys);\n+      response \u003d rename(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n-      response \u003d link(xdr, authSys);\n+      response \u003d link(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n-      response \u003d readdir(xdr, authSys);\n+      response \u003d readdir(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n-      response \u003d readdirplus(xdr, authSys);\n+      response \u003d readdirplus(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n-      response \u003d fsstat(xdr, authSys);\n+      response \u003d fsstat(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n-      response \u003d fsinfo(xdr, authSys);\n+      response \u003d fsinfo(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n-      response \u003d pathconf(xdr, authSys);\n+      response \u003d pathconf(xdr, authSys, client);\n     } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n-      response \u003d commit(xdr, authSys);\n+      response \u003d commit(xdr, authSys, client);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.voidReply(out, xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n     }\n     if (response !\u003d null) {\n       out \u003d response.send(out, xid);\n     }\n     return out;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n      InetAddress client, Channel channel) {\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    RpcAuthSys authSys \u003d null;\n    \n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \"\n            + rpcCall.getCredential().getFlavor() + \" is not AUTH_SYS.\");\n        XDR reply \u003d new XDR();\n        reply \u003d RpcDeniedReply.voidReply(reply, xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR);\n        return reply;\n      }\n      authSys \u003d RpcAuthSys.from(rpcCall.getCredential().getBody());\n    }\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      response \u003d read(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      response \u003d write(xdr, channel, xid, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n      response \u003d mkdir(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr, authSys, client);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, authSys, client);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.voidReply(out, xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n    }\n    if (response !\u003d null) {\n      out \u003d response.send(out, xid);\n    }\n    return out;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
      "extendedDetails": {}
    },
    "58d75576c4d2a03d4954174bc223ed0334b34fee": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4962. Use enum for nfs constants. Contributed by Tsz Wo (Nicholas) SZE.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1501851 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 10:01 AM",
      "commitName": "58d75576c4d2a03d4954174bc223ed0334b34fee",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "02/07/13 10:31 AM",
      "commitNameOld": "37f587563a943a827fbff865f5302bac6d202415",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 7.98,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n       InetAddress client, Channel channel) {\n-    int procedure \u003d rpcCall.getProcedure();\n+    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n     RpcAuthSys authSys \u003d null;\n     \n     // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n-    if (procedure !\u003d Nfs3Constant.NFSPROC3_NULL) {\n+    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n       if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS) {\n         LOG.info(\"Wrong RPC AUTH flavor, \"\n             + rpcCall.getCredential().getFlavor() + \" is not AUTH_SYS.\");\n         XDR reply \u003d new XDR();\n         reply \u003d RpcDeniedReply.voidReply(reply, xid,\n             RpcReply.ReplyState.MSG_ACCEPTED,\n             RpcDeniedReply.RejectState.AUTH_ERROR);\n         return reply;\n       }\n       authSys \u003d RpcAuthSys.from(rpcCall.getCredential().getBody());\n     }\n     \n     NFS3Response response \u003d null;\n-    if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_NULL) {\n+    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n       response \u003d nullProcedure();\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_GETATTR) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n       response \u003d getattr(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_SETATTR) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n       response \u003d setattr(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_LOOKUP) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n       response \u003d lookup(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_ACCESS) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n       response \u003d access(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READLINK) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n       response \u003d readlink(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READ) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n       response \u003d read(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_WRITE) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n       response \u003d write(xdr, channel, xid, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_CREATE) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n       response \u003d create(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_MKDIR) {      \n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n       response \u003d mkdir(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_SYMLINK) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n       response \u003d symlink(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_MKNOD) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n       response \u003d mknod(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_REMOVE) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n       response \u003d remove(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_RMDIR) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n       response \u003d rmdir(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_RENAME) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n       response \u003d rename(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_LINK) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n       response \u003d link(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READDIR) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n       response \u003d readdir(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READDIRPLUS) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n       response \u003d readdirplus(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_FSSTAT) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n       response \u003d fsstat(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_FSINFO) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n       response \u003d fsinfo(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_PATHCONF) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n       response \u003d pathconf(xdr, authSys);\n-    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_COMMIT) {\n+    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n       response \u003d commit(xdr, authSys);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.voidReply(out, xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n     }\n     if (response !\u003d null) {\n       out \u003d response.send(out, xid);\n     }\n     return out;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n      InetAddress client, Channel channel) {\n    final NFSPROC3 nfsproc3 \u003d NFSPROC3.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    RpcAuthSys authSys \u003d null;\n    \n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (nfsproc3 !\u003d NFSPROC3.NULL) {\n      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \"\n            + rpcCall.getCredential().getFlavor() + \" is not AUTH_SYS.\");\n        XDR reply \u003d new XDR();\n        reply \u003d RpcDeniedReply.voidReply(reply, xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR);\n        return reply;\n      }\n      authSys \u003d RpcAuthSys.from(rpcCall.getCredential().getBody());\n    }\n    \n    NFS3Response response \u003d null;\n    if (nfsproc3 \u003d\u003d NFSPROC3.NULL) {\n      response \u003d nullProcedure();\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.GETATTR) {\n      response \u003d getattr(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SETATTR) {\n      response \u003d setattr(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LOOKUP) {\n      response \u003d lookup(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.ACCESS) {\n      response \u003d access(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READLINK) {\n      response \u003d readlink(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READ) {\n      response \u003d read(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.WRITE) {\n      response \u003d write(xdr, channel, xid, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.CREATE) {\n      response \u003d create(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKDIR) {      \n      response \u003d mkdir(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.SYMLINK) {\n      response \u003d symlink(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.MKNOD) {\n      response \u003d mknod(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.REMOVE) {\n      response \u003d remove(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RMDIR) {\n      response \u003d rmdir(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.RENAME) {\n      response \u003d rename(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.LINK) {\n      response \u003d link(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIR) {\n      response \u003d readdir(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.READDIRPLUS) {\n      response \u003d readdirplus(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSSTAT) {\n      response \u003d fsstat(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.FSINFO) {\n      response \u003d fsinfo(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.PATHCONF) {\n      response \u003d pathconf(xdr, authSys);\n    } else if (nfsproc3 \u003d\u003d NFSPROC3.COMMIT) {\n      response \u003d commit(xdr, authSys);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.voidReply(out, xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n    }\n    if (response !\u003d null) {\n      out \u003d response.send(out, xid);\n    }\n    return out;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java",
      "extendedDetails": {}
    },
    "37f587563a943a827fbff865f5302bac6d202415": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-4762 Provide HDFS based NFSv3 and Mountd implementation. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1499029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/07/13 10:31 AM",
      "commitName": "37f587563a943a827fbff865f5302bac6d202415",
      "commitAuthor": "Brandon Li",
      "diff": "@@ -0,0 +1,75 @@\n+  public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n+      InetAddress client, Channel channel) {\n+    int procedure \u003d rpcCall.getProcedure();\n+    int xid \u003d rpcCall.getXid();\n+    RpcAuthSys authSys \u003d null;\n+    \n+    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n+    if (procedure !\u003d Nfs3Constant.NFSPROC3_NULL) {\n+      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS) {\n+        LOG.info(\"Wrong RPC AUTH flavor, \"\n+            + rpcCall.getCredential().getFlavor() + \" is not AUTH_SYS.\");\n+        XDR reply \u003d new XDR();\n+        reply \u003d RpcDeniedReply.voidReply(reply, xid,\n+            RpcReply.ReplyState.MSG_ACCEPTED,\n+            RpcDeniedReply.RejectState.AUTH_ERROR);\n+        return reply;\n+      }\n+      authSys \u003d RpcAuthSys.from(rpcCall.getCredential().getBody());\n+    }\n+    \n+    NFS3Response response \u003d null;\n+    if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_NULL) {\n+      response \u003d nullProcedure();\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_GETATTR) {\n+      response \u003d getattr(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_SETATTR) {\n+      response \u003d setattr(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_LOOKUP) {\n+      response \u003d lookup(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_ACCESS) {\n+      response \u003d access(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READLINK) {\n+      response \u003d readlink(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READ) {\n+      response \u003d read(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_WRITE) {\n+      response \u003d write(xdr, channel, xid, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_CREATE) {\n+      response \u003d create(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_MKDIR) {      \n+      response \u003d mkdir(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_SYMLINK) {\n+      response \u003d symlink(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_MKNOD) {\n+      response \u003d mknod(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_REMOVE) {\n+      response \u003d remove(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_RMDIR) {\n+      response \u003d rmdir(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_RENAME) {\n+      response \u003d rename(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_LINK) {\n+      response \u003d link(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READDIR) {\n+      response \u003d readdir(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READDIRPLUS) {\n+      response \u003d readdirplus(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_FSSTAT) {\n+      response \u003d fsstat(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_FSINFO) {\n+      response \u003d fsinfo(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_PATHCONF) {\n+      response \u003d pathconf(xdr, authSys);\n+    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_COMMIT) {\n+      response \u003d commit(xdr, authSys);\n+    } else {\n+      // Invalid procedure\n+      RpcAcceptedReply.voidReply(out, xid,\n+          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n+    }\n+    if (response !\u003d null) {\n+      out \u003d response.send(out, xid);\n+    }\n+    return out;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public XDR handleInternal(RpcCall rpcCall, final XDR xdr, XDR out,\n      InetAddress client, Channel channel) {\n    int procedure \u003d rpcCall.getProcedure();\n    int xid \u003d rpcCall.getXid();\n    RpcAuthSys authSys \u003d null;\n    \n    // Ignore auth only for NFSPROC3_NULL, especially for Linux clients.\n    if (procedure !\u003d Nfs3Constant.NFSPROC3_NULL) {\n      if (rpcCall.getCredential().getFlavor() !\u003d AuthFlavor.AUTH_SYS) {\n        LOG.info(\"Wrong RPC AUTH flavor, \"\n            + rpcCall.getCredential().getFlavor() + \" is not AUTH_SYS.\");\n        XDR reply \u003d new XDR();\n        reply \u003d RpcDeniedReply.voidReply(reply, xid,\n            RpcReply.ReplyState.MSG_ACCEPTED,\n            RpcDeniedReply.RejectState.AUTH_ERROR);\n        return reply;\n      }\n      authSys \u003d RpcAuthSys.from(rpcCall.getCredential().getBody());\n    }\n    \n    NFS3Response response \u003d null;\n    if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_NULL) {\n      response \u003d nullProcedure();\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_GETATTR) {\n      response \u003d getattr(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_SETATTR) {\n      response \u003d setattr(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_LOOKUP) {\n      response \u003d lookup(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_ACCESS) {\n      response \u003d access(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READLINK) {\n      response \u003d readlink(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READ) {\n      response \u003d read(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_WRITE) {\n      response \u003d write(xdr, channel, xid, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_CREATE) {\n      response \u003d create(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_MKDIR) {      \n      response \u003d mkdir(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_SYMLINK) {\n      response \u003d symlink(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_MKNOD) {\n      response \u003d mknod(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_REMOVE) {\n      response \u003d remove(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_RMDIR) {\n      response \u003d rmdir(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_RENAME) {\n      response \u003d rename(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_LINK) {\n      response \u003d link(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READDIR) {\n      response \u003d readdir(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_READDIRPLUS) {\n      response \u003d readdirplus(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_FSSTAT) {\n      response \u003d fsstat(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_FSINFO) {\n      response \u003d fsinfo(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_PATHCONF) {\n      response \u003d pathconf(xdr, authSys);\n    } else if (procedure \u003d\u003d Nfs3Constant.NFSPROC3_COMMIT) {\n      response \u003d commit(xdr, authSys);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.voidReply(out, xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n    }\n    if (response !\u003d null) {\n      out \u003d response.send(out, xid);\n    }\n    return out;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/RpcProgramNfs3.java"
    }
  }
}