{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "HttpServer2.java",
  "functionName": "start",
  "functionId": "start",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java",
  "functionStartLine": 1220,
  "functionEndLine": 1262,
  "numCommitsSeen": 116,
  "timeTaken": 3904,
  "changeHistory": [
    "8bda91d20ab248a0d262d396646861113195f3ed",
    "5877f20f9c3f6f0afa505715e9a2ee312475af17",
    "2860eeb14a958a8861b9ad3d6bd685df48da8cd3",
    "33a47743a5f4263bc21b345587370c5ecf43f5b4",
    "2214871d916fdcae62aa51afbb5fd571f2808745",
    "bdcbc2d1ef0fba999170ba748176ad0f496ccf2c",
    "097a001b3fd355558c971cd82a633177ace77b39",
    "229a3a23127e33f596d485dec580e31c48ba9057",
    "a83753b73562123e35b76fe91a173033a01e2bc2",
    "c5179b16ecc2c26f693eed692a6c556b6ac2e845",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "1035138b4c03ed26ce5be9fc4dd6f6c1e0af909b",
    "4e5bdc46bc717d365cce95dd7be0685ef8443dd7",
    "583c41bfac1d1ff911e798d55f8a2879a0fd3235",
    "d7fb2d3c859c852e303bb002d56e72813a1af7b2",
    "929e91a08c5387c692ed3257361190b83d72f2e9",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "8bda91d20ab248a0d262d396646861113195f3ed": "Ybodychange",
    "5877f20f9c3f6f0afa505715e9a2ee312475af17": "Ybodychange",
    "2860eeb14a958a8861b9ad3d6bd685df48da8cd3": "Ybodychange",
    "33a47743a5f4263bc21b345587370c5ecf43f5b4": "Yfilerename",
    "2214871d916fdcae62aa51afbb5fd571f2808745": "Ybodychange",
    "bdcbc2d1ef0fba999170ba748176ad0f496ccf2c": "Ybodychange",
    "097a001b3fd355558c971cd82a633177ace77b39": "Ybodychange",
    "229a3a23127e33f596d485dec580e31c48ba9057": "Ybodychange",
    "a83753b73562123e35b76fe91a173033a01e2bc2": "Ybodychange",
    "c5179b16ecc2c26f693eed692a6c556b6ac2e845": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "1035138b4c03ed26ce5be9fc4dd6f6c1e0af909b": "Ybodychange",
    "4e5bdc46bc717d365cce95dd7be0685ef8443dd7": "Ybodychange",
    "583c41bfac1d1ff911e798d55f8a2879a0fd3235": "Ybodychange",
    "d7fb2d3c859c852e303bb002d56e72813a1af7b2": "Ybodychange",
    "929e91a08c5387c692ed3257361190b83d72f2e9": "Ybodychange",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8bda91d20ab248a0d262d396646861113195f3ed": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16398. Exports Hadoop metrics to Prometheus (#1170)\n\n",
      "commitDate": "31/07/19 10:11 AM",
      "commitName": "8bda91d20ab248a0d262d396646861113195f3ed",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "05/06/19 3:55 PM",
      "commitNameOld": "294695dd57cb75f2756a31a54264bdd37b32bb01",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 55.76,
      "commitsBetweenForRepo": 456,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,43 @@\n   public void start() throws IOException {\n     try {\n       try {\n         openListeners();\n         webServer.start();\n+        if (prometheusSupport) {\n+          DefaultMetricsSystem.instance()\n+              .register(\"prometheus\", \"Hadoop metrics prometheus exporter\",\n+                  prometheusMetricsSink);\n+        }\n       } catch (IOException ex) {\n         LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n         throw ex;\n       } catch (MultiException ex) {\n         LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n         throw ex;\n       }\n       // Make sure there is no handler failures.\n       Handler[] hs \u003d webServer.getHandlers();\n       for (Handler handler : hs) {\n         if (handler.isFailed()) {\n           throw new IOException(\n               \"Problem in starting http server. Server handlers failed\");\n         }\n       }\n       // Make sure there are no errors initializing the context.\n       Throwable unavailableException \u003d webAppContext.getUnavailableException();\n       if (unavailableException !\u003d null) {\n         // Have to stop the webserver, or else its non-daemon threads\n         // will hang forever.\n         webServer.stop();\n         throw new IOException(\"Unable to initialize WebAppContext\",\n             unavailableException);\n       }\n     } catch (IOException e) {\n       throw e;\n     } catch (InterruptedException e) {\n       throw (IOException) new InterruptedIOException(\n           \"Interrupted while starting HTTP server\").initCause(e);\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      try {\n        openListeners();\n        webServer.start();\n        if (prometheusSupport) {\n          DefaultMetricsSystem.instance()\n              .register(\"prometheus\", \"Hadoop metrics prometheus exporter\",\n                  prometheusMetricsSink);\n        }\n      } catch (IOException ex) {\n        LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n        throw ex;\n      } catch (MultiException ex) {\n        LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n        throw ex;\n      }\n      // Make sure there is no handler failures.\n      Handler[] hs \u003d webServer.getHandlers();\n      for (Handler handler : hs) {\n        if (handler.isFailed()) {\n          throw new IOException(\n              \"Problem in starting http server. Server handlers failed\");\n        }\n      }\n      // Make sure there are no errors initializing the context.\n      Throwable unavailableException \u003d webAppContext.getUnavailableException();\n      if (unavailableException !\u003d null) {\n        // Have to stop the webserver, or else its non-daemon threads\n        // will hang forever.\n        webServer.stop();\n        throw new IOException(\"Unable to initialize WebAppContext\",\n            unavailableException);\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (InterruptedException e) {\n      throw (IOException) new InterruptedIOException(\n          \"Interrupted while starting HTTP server\").initCause(e);\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java",
      "extendedDetails": {}
    },
    "5877f20f9c3f6f0afa505715e9a2ee312475af17": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10075. Update jetty dependency to version 9 (rkanter)\n",
      "commitDate": "27/10/16 4:09 PM",
      "commitName": "5877f20f9c3f6f0afa505715e9a2ee312475af17",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "19/08/16 9:22 AM",
      "commitNameOld": "03a9343d5798384b66fbd21e1e028acaf55b00e9",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 69.28,
      "commitsBetweenForRepo": 490,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   public void start() throws IOException {\n     try {\n       try {\n         openListeners();\n         webServer.start();\n       } catch (IOException ex) {\n         LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n         throw ex;\n       } catch (MultiException ex) {\n         LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n         throw ex;\n       }\n       // Make sure there is no handler failures.\n-      Handler[] handlers \u003d webServer.getHandlers();\n-      for (Handler handler : handlers) {\n+      Handler[] hs \u003d webServer.getHandlers();\n+      for (Handler handler : hs) {\n         if (handler.isFailed()) {\n           throw new IOException(\n               \"Problem in starting http server. Server handlers failed\");\n         }\n       }\n       // Make sure there are no errors initializing the context.\n       Throwable unavailableException \u003d webAppContext.getUnavailableException();\n       if (unavailableException !\u003d null) {\n         // Have to stop the webserver, or else its non-daemon threads\n         // will hang forever.\n         webServer.stop();\n         throw new IOException(\"Unable to initialize WebAppContext\",\n             unavailableException);\n       }\n     } catch (IOException e) {\n       throw e;\n     } catch (InterruptedException e) {\n       throw (IOException) new InterruptedIOException(\n           \"Interrupted while starting HTTP server\").initCause(e);\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      try {\n        openListeners();\n        webServer.start();\n      } catch (IOException ex) {\n        LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n        throw ex;\n      } catch (MultiException ex) {\n        LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n        throw ex;\n      }\n      // Make sure there is no handler failures.\n      Handler[] hs \u003d webServer.getHandlers();\n      for (Handler handler : hs) {\n        if (handler.isFailed()) {\n          throw new IOException(\n              \"Problem in starting http server. Server handlers failed\");\n        }\n      }\n      // Make sure there are no errors initializing the context.\n      Throwable unavailableException \u003d webAppContext.getUnavailableException();\n      if (unavailableException !\u003d null) {\n        // Have to stop the webserver, or else its non-daemon threads\n        // will hang forever.\n        webServer.stop();\n        throw new IOException(\"Unable to initialize WebAppContext\",\n            unavailableException);\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (InterruptedException e) {\n      throw (IOException) new InterruptedIOException(\n          \"Interrupted while starting HTTP server\").initCause(e);\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java",
      "extendedDetails": {}
    },
    "2860eeb14a958a8861b9ad3d6bd685df48da8cd3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7555. Remove the support of unmanaged connectors in HttpServer2. Contributed by Haohui Mai.\n",
      "commitDate": "21/12/14 2:45 PM",
      "commitName": "2860eeb14a958a8861b9ad3d6bd685df48da8cd3",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "11/12/14 4:42 PM",
      "commitNameOld": "5b9fcedb4d116d91d70aaad6cbf59093eeee36df",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 9.92,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   public void start() throws IOException {\n     try {\n       try {\n         openListeners();\n         webServer.start();\n       } catch (IOException ex) {\n         LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n         throw ex;\n       } catch (MultiException ex) {\n         LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n         throw ex;\n       }\n       // Make sure there is no handler failures.\n       Handler[] handlers \u003d webServer.getHandlers();\n-      for (int i \u003d 0; i \u003c handlers.length; i++) {\n-        if (handlers[i].isFailed()) {\n+      for (Handler handler : handlers) {\n+        if (handler.isFailed()) {\n           throw new IOException(\n               \"Problem in starting http server. Server handlers failed\");\n         }\n       }\n       // Make sure there are no errors initializing the context.\n       Throwable unavailableException \u003d webAppContext.getUnavailableException();\n       if (unavailableException !\u003d null) {\n         // Have to stop the webserver, or else its non-daemon threads\n         // will hang forever.\n         webServer.stop();\n         throw new IOException(\"Unable to initialize WebAppContext\",\n             unavailableException);\n       }\n     } catch (IOException e) {\n       throw e;\n     } catch (InterruptedException e) {\n       throw (IOException) new InterruptedIOException(\n           \"Interrupted while starting HTTP server\").initCause(e);\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      try {\n        openListeners();\n        webServer.start();\n      } catch (IOException ex) {\n        LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n        throw ex;\n      } catch (MultiException ex) {\n        LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n        throw ex;\n      }\n      // Make sure there is no handler failures.\n      Handler[] handlers \u003d webServer.getHandlers();\n      for (Handler handler : handlers) {\n        if (handler.isFailed()) {\n          throw new IOException(\n              \"Problem in starting http server. Server handlers failed\");\n        }\n      }\n      // Make sure there are no errors initializing the context.\n      Throwable unavailableException \u003d webAppContext.getUnavailableException();\n      if (unavailableException !\u003d null) {\n        // Have to stop the webserver, or else its non-daemon threads\n        // will hang forever.\n        webServer.stop();\n        throw new IOException(\"Unable to initialize WebAppContext\",\n            unavailableException);\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (InterruptedException e) {\n      throw (IOException) new InterruptedIOException(\n          \"Interrupted while starting HTTP server\").initCause(e);\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java",
      "extendedDetails": {}
    },
    "33a47743a5f4263bc21b345587370c5ecf43f5b4": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-10255. Rename HttpServer to HttpServer2 to retain older HttpServer in branch-2 for compatibility. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561959 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/01/14 11:32 PM",
      "commitName": "33a47743a5f4263bc21b345587370c5ecf43f5b4",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "27/01/14 10:41 PM",
      "commitNameOld": "87166f1ee81dbad579508c2bdbc7dda96b1ef809",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void start() throws IOException {\n    try {\n      try {\n        openListeners();\n        webServer.start();\n      } catch (IOException ex) {\n        LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n        throw ex;\n      } catch (MultiException ex) {\n        LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n        throw ex;\n      }\n      // Make sure there is no handler failures.\n      Handler[] handlers \u003d webServer.getHandlers();\n      for (int i \u003d 0; i \u003c handlers.length; i++) {\n        if (handlers[i].isFailed()) {\n          throw new IOException(\n              \"Problem in starting http server. Server handlers failed\");\n        }\n      }\n      // Make sure there are no errors initializing the context.\n      Throwable unavailableException \u003d webAppContext.getUnavailableException();\n      if (unavailableException !\u003d null) {\n        // Have to stop the webserver, or else its non-daemon threads\n        // will hang forever.\n        webServer.stop();\n        throw new IOException(\"Unable to initialize WebAppContext\",\n            unavailableException);\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (InterruptedException e) {\n      throw (IOException) new InterruptedIOException(\n          \"Interrupted while starting HTTP server\").initCause(e);\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java",
      "extendedDetails": {
        "oldPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java"
      }
    },
    "2214871d916fdcae62aa51afbb5fd571f2808745": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5545. Allow specifying endpoints for listeners in HttpServer. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546151 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/13 10:20 AM",
      "commitName": "2214871d916fdcae62aa51afbb5fd571f2808745",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "20/11/13 1:51 PM",
      "commitNameOld": "3cae2ba63fe6f0765d860677a9bd9f1ea158c1c3",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 6.85,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,38 @@\n   public void start() throws IOException {\n     try {\n       try {\n-        openListener();\n-        LOG.info(\"Jetty bound to port \" + listener.getLocalPort());\n+        openListeners();\n         webServer.start();\n       } catch (IOException ex) {\n         LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n         throw ex;\n       } catch (MultiException ex) {\n         LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n         throw ex;\n       }\n       // Make sure there is no handler failures.\n       Handler[] handlers \u003d webServer.getHandlers();\n       for (int i \u003d 0; i \u003c handlers.length; i++) {\n         if (handlers[i].isFailed()) {\n           throw new IOException(\n               \"Problem in starting http server. Server handlers failed\");\n         }\n       }\n       // Make sure there are no errors initializing the context.\n       Throwable unavailableException \u003d webAppContext.getUnavailableException();\n       if (unavailableException !\u003d null) {\n         // Have to stop the webserver, or else its non-daemon threads\n         // will hang forever.\n         webServer.stop();\n         throw new IOException(\"Unable to initialize WebAppContext\",\n             unavailableException);\n       }\n     } catch (IOException e) {\n       throw e;\n     } catch (InterruptedException e) {\n       throw (IOException) new InterruptedIOException(\n           \"Interrupted while starting HTTP server\").initCause(e);\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      try {\n        openListeners();\n        webServer.start();\n      } catch (IOException ex) {\n        LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n        throw ex;\n      } catch (MultiException ex) {\n        LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n        throw ex;\n      }\n      // Make sure there is no handler failures.\n      Handler[] handlers \u003d webServer.getHandlers();\n      for (int i \u003d 0; i \u003c handlers.length; i++) {\n        if (handlers[i].isFailed()) {\n          throw new IOException(\n              \"Problem in starting http server. Server handlers failed\");\n        }\n      }\n      // Make sure there are no errors initializing the context.\n      Throwable unavailableException \u003d webAppContext.getUnavailableException();\n      if (unavailableException !\u003d null) {\n        // Have to stop the webserver, or else its non-daemon threads\n        // will hang forever.\n        webServer.stop();\n        throw new IOException(\"Unable to initialize WebAppContext\",\n            unavailableException);\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (InterruptedException e) {\n      throw (IOException) new InterruptedIOException(\n          \"Interrupted while starting HTTP server\").initCause(e);\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {}
    },
    "bdcbc2d1ef0fba999170ba748176ad0f496ccf2c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8786. HttpServer continues to start even if AuthenticationFilter fails to init. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1383254 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/09/12 11:37 PM",
      "commitName": "bdcbc2d1ef0fba999170ba748176ad0f496ccf2c",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "24/08/12 6:03 PM",
      "commitNameOld": "deead78e35b0cb81af875b5a8032cbd06c9a2dae",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 17.23,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,39 @@\n   public void start() throws IOException {\n     try {\n       try {\n         openListener();\n         LOG.info(\"Jetty bound to port \" + listener.getLocalPort());\n         webServer.start();\n       } catch (IOException ex) {\n         LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n         throw ex;\n       } catch (MultiException ex) {\n         LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n         throw ex;\n       }\n       // Make sure there is no handler failures.\n       Handler[] handlers \u003d webServer.getHandlers();\n       for (int i \u003d 0; i \u003c handlers.length; i++) {\n         if (handlers[i].isFailed()) {\n           throw new IOException(\n               \"Problem in starting http server. Server handlers failed\");\n         }\n       }\n+      // Make sure there are no errors initializing the context.\n+      Throwable unavailableException \u003d webAppContext.getUnavailableException();\n+      if (unavailableException !\u003d null) {\n+        // Have to stop the webserver, or else its non-daemon threads\n+        // will hang forever.\n+        webServer.stop();\n+        throw new IOException(\"Unable to initialize WebAppContext\",\n+            unavailableException);\n+      }\n     } catch (IOException e) {\n       throw e;\n     } catch (InterruptedException e) {\n       throw (IOException) new InterruptedIOException(\n           \"Interrupted while starting HTTP server\").initCause(e);\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      try {\n        openListener();\n        LOG.info(\"Jetty bound to port \" + listener.getLocalPort());\n        webServer.start();\n      } catch (IOException ex) {\n        LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n        throw ex;\n      } catch (MultiException ex) {\n        LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n        throw ex;\n      }\n      // Make sure there is no handler failures.\n      Handler[] handlers \u003d webServer.getHandlers();\n      for (int i \u003d 0; i \u003c handlers.length; i++) {\n        if (handlers[i].isFailed()) {\n          throw new IOException(\n              \"Problem in starting http server. Server handlers failed\");\n        }\n      }\n      // Make sure there are no errors initializing the context.\n      Throwable unavailableException \u003d webAppContext.getUnavailableException();\n      if (unavailableException !\u003d null) {\n        // Have to stop the webserver, or else its non-daemon threads\n        // will hang forever.\n        webServer.stop();\n        throw new IOException(\"Unable to initialize WebAppContext\",\n            unavailableException);\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (InterruptedException e) {\n      throw (IOException) new InterruptedIOException(\n          \"Interrupted while starting HTTP server\").initCause(e);\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {}
    },
    "097a001b3fd355558c971cd82a633177ace77b39": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8334. HttpServer sometimes returns incorrect port (Daryn Sharp via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1332336 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/04/12 11:56 AM",
      "commitName": "097a001b3fd355558c971cd82a633177ace77b39",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "24/04/12 8:20 PM",
      "commitNameOld": "e29ede3f729784f0eb770f0a1570bea199ff6902",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,30 @@\n   public void start() throws IOException {\n     try {\n-      if(listenerStartedExternally) { // Expect that listener was started securely\n-        if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n-          throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n-             \"previously but wasn\u0027t\");\n-        // And skip all the port rolling issues.\n+      try {\n+        openListener();\n+        LOG.info(\"Jetty bound to port \" + listener.getLocalPort());\n         webServer.start();\n-      } else {\n-        int port \u003d 0;\n-        int oriPort \u003d listener.getPort(); // The original requested port\n-        while (true) {\n-          try {\n-            port \u003d webServer.getConnectors()[0].getLocalPort();\n-            LOG.debug(\"Port returned by webServer.getConnectors()[0].\" +\n-            \t\t\"getLocalPort() before open() is \"+ port + \n-            \t\t\". Opening the listener on \" + oriPort);\n-            listener.open();\n-            port \u003d listener.getLocalPort();\n-            LOG.debug(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n-                  \" webServer.getConnectors()[0].getLocalPort() returned \" +\n-                  webServer.getConnectors()[0].getLocalPort());\n-            //Workaround to handle the problem reported in HADOOP-4744\n-            if (port \u003c 0) {\n-              Thread.sleep(100);\n-              int numRetries \u003d 1;\n-              while (port \u003c 0) {\n-                LOG.warn(\"listener.getLocalPort returned \" + port);\n-                if (numRetries++ \u003e MAX_RETRIES) {\n-                  throw new Exception(\" listener.getLocalPort is returning \" +\n-                  \t\t\"less than 0 even after \" +numRetries+\" resets\");\n-                }\n-                for (int i \u003d 0; i \u003c 2; i++) {\n-                  LOG.info(\"Retrying listener.getLocalPort()\");\n-                  port \u003d listener.getLocalPort();\n-                  if (port \u003e 0) {\n-                    break;\n-                  }\n-                  Thread.sleep(200);\n-                }\n-                if (port \u003e 0) {\n-                  break;\n-                }\n-                LOG.info(\"Bouncing the listener\");\n-                listener.close();\n-                Thread.sleep(1000);\n-                listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n-                listener.open();\n-                Thread.sleep(100);\n-                port \u003d listener.getLocalPort();\n-              }\n-            } //Workaround end\n-            LOG.info(\"Jetty bound to port \" + port);\n-            webServer.start();\n-            break;\n-          } catch (IOException ex) {\n-            // if this is a bind exception,\n-            // then try the next port number.\n-            if (ex instanceof BindException) {\n-              if (!findPort) {\n-                BindException be \u003d new BindException(\n-                        \"Port in use: \" + listener.getHost()\n-                                + \":\" + listener.getPort());\n-                be.initCause(ex);\n-                throw be;\n-              }\n-            } else {\n-              LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n-              throw ex;\n-            }\n-          } catch (MultiException ex) {\n-            LOG.info(\"HttpServer.start() threw a MultiException\"); \n-            throw ex;\n-          }\n-          listener.setPort((oriPort +\u003d 1));\n-        }\n+      } catch (IOException ex) {\n+        LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n+        throw ex;\n+      } catch (MultiException ex) {\n+        LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n+        throw ex;\n       }\n       // Make sure there is no handler failures.\n       Handler[] handlers \u003d webServer.getHandlers();\n       for (int i \u003d 0; i \u003c handlers.length; i++) {\n         if (handlers[i].isFailed()) {\n           throw new IOException(\n               \"Problem in starting http server. Server handlers failed\");\n         }\n       }\n     } catch (IOException e) {\n       throw e;\n     } catch (InterruptedException e) {\n       throw (IOException) new InterruptedIOException(\n           \"Interrupted while starting HTTP server\").initCause(e);\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      try {\n        openListener();\n        LOG.info(\"Jetty bound to port \" + listener.getLocalPort());\n        webServer.start();\n      } catch (IOException ex) {\n        LOG.info(\"HttpServer.start() threw a non Bind IOException\", ex);\n        throw ex;\n      } catch (MultiException ex) {\n        LOG.info(\"HttpServer.start() threw a MultiException\", ex);\n        throw ex;\n      }\n      // Make sure there is no handler failures.\n      Handler[] handlers \u003d webServer.getHandlers();\n      for (int i \u003d 0; i \u003c handlers.length; i++) {\n        if (handlers[i].isFailed()) {\n          throw new IOException(\n              \"Problem in starting http server. Server handlers failed\");\n        }\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (InterruptedException e) {\n      throw (IOException) new InterruptedIOException(\n          \"Interrupted while starting HTTP server\").initCause(e);\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {}
    },
    "229a3a23127e33f596d485dec580e31c48ba9057": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7858. Drop some info logging to DEBUG level in IPC, metrics, and HTTP. Contributed by Todd Lipcon\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1206830 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/11 12:27 PM",
      "commitName": "229a3a23127e33f596d485dec580e31c48ba9057",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "07/11/11 12:51 PM",
      "commitNameOld": "a83753b73562123e35b76fe91a173033a01e2bc2",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 19.98,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,94 @@\n   public void start() throws IOException {\n     try {\n       if(listenerStartedExternally) { // Expect that listener was started securely\n         if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n           throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n              \"previously but wasn\u0027t\");\n         // And skip all the port rolling issues.\n         webServer.start();\n       } else {\n         int port \u003d 0;\n         int oriPort \u003d listener.getPort(); // The original requested port\n         while (true) {\n           try {\n             port \u003d webServer.getConnectors()[0].getLocalPort();\n-            LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n+            LOG.debug(\"Port returned by webServer.getConnectors()[0].\" +\n             \t\t\"getLocalPort() before open() is \"+ port + \n             \t\t\". Opening the listener on \" + oriPort);\n             listener.open();\n             port \u003d listener.getLocalPort();\n-            LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n+            LOG.debug(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                   \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                   webServer.getConnectors()[0].getLocalPort());\n             //Workaround to handle the problem reported in HADOOP-4744\n             if (port \u003c 0) {\n               Thread.sleep(100);\n               int numRetries \u003d 1;\n               while (port \u003c 0) {\n                 LOG.warn(\"listener.getLocalPort returned \" + port);\n                 if (numRetries++ \u003e MAX_RETRIES) {\n                   throw new Exception(\" listener.getLocalPort is returning \" +\n                   \t\t\"less than 0 even after \" +numRetries+\" resets\");\n                 }\n                 for (int i \u003d 0; i \u003c 2; i++) {\n                   LOG.info(\"Retrying listener.getLocalPort()\");\n                   port \u003d listener.getLocalPort();\n                   if (port \u003e 0) {\n                     break;\n                   }\n                   Thread.sleep(200);\n                 }\n                 if (port \u003e 0) {\n                   break;\n                 }\n                 LOG.info(\"Bouncing the listener\");\n                 listener.close();\n                 Thread.sleep(1000);\n                 listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n                 listener.open();\n                 Thread.sleep(100);\n                 port \u003d listener.getLocalPort();\n               }\n             } //Workaround end\n             LOG.info(\"Jetty bound to port \" + port);\n             webServer.start();\n             break;\n           } catch (IOException ex) {\n             // if this is a bind exception,\n             // then try the next port number.\n             if (ex instanceof BindException) {\n               if (!findPort) {\n                 BindException be \u003d new BindException(\n                         \"Port in use: \" + listener.getHost()\n                                 + \":\" + listener.getPort());\n                 be.initCause(ex);\n                 throw be;\n               }\n             } else {\n               LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n               throw ex;\n             }\n           } catch (MultiException ex) {\n             LOG.info(\"HttpServer.start() threw a MultiException\"); \n             throw ex;\n           }\n           listener.setPort((oriPort +\u003d 1));\n         }\n       }\n       // Make sure there is no handler failures.\n       Handler[] handlers \u003d webServer.getHandlers();\n       for (int i \u003d 0; i \u003c handlers.length; i++) {\n         if (handlers[i].isFailed()) {\n           throw new IOException(\n               \"Problem in starting http server. Server handlers failed\");\n         }\n       }\n     } catch (IOException e) {\n       throw e;\n     } catch (InterruptedException e) {\n       throw (IOException) new InterruptedIOException(\n           \"Interrupted while starting HTTP server\").initCause(e);\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      if(listenerStartedExternally) { // Expect that listener was started securely\n        if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n          throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n             \"previously but wasn\u0027t\");\n        // And skip all the port rolling issues.\n        webServer.start();\n      } else {\n        int port \u003d 0;\n        int oriPort \u003d listener.getPort(); // The original requested port\n        while (true) {\n          try {\n            port \u003d webServer.getConnectors()[0].getLocalPort();\n            LOG.debug(\"Port returned by webServer.getConnectors()[0].\" +\n            \t\t\"getLocalPort() before open() is \"+ port + \n            \t\t\". Opening the listener on \" + oriPort);\n            listener.open();\n            port \u003d listener.getLocalPort();\n            LOG.debug(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                  \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                  webServer.getConnectors()[0].getLocalPort());\n            //Workaround to handle the problem reported in HADOOP-4744\n            if (port \u003c 0) {\n              Thread.sleep(100);\n              int numRetries \u003d 1;\n              while (port \u003c 0) {\n                LOG.warn(\"listener.getLocalPort returned \" + port);\n                if (numRetries++ \u003e MAX_RETRIES) {\n                  throw new Exception(\" listener.getLocalPort is returning \" +\n                  \t\t\"less than 0 even after \" +numRetries+\" resets\");\n                }\n                for (int i \u003d 0; i \u003c 2; i++) {\n                  LOG.info(\"Retrying listener.getLocalPort()\");\n                  port \u003d listener.getLocalPort();\n                  if (port \u003e 0) {\n                    break;\n                  }\n                  Thread.sleep(200);\n                }\n                if (port \u003e 0) {\n                  break;\n                }\n                LOG.info(\"Bouncing the listener\");\n                listener.close();\n                Thread.sleep(1000);\n                listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n                listener.open();\n                Thread.sleep(100);\n                port \u003d listener.getLocalPort();\n              }\n            } //Workaround end\n            LOG.info(\"Jetty bound to port \" + port);\n            webServer.start();\n            break;\n          } catch (IOException ex) {\n            // if this is a bind exception,\n            // then try the next port number.\n            if (ex instanceof BindException) {\n              if (!findPort) {\n                BindException be \u003d new BindException(\n                        \"Port in use: \" + listener.getHost()\n                                + \":\" + listener.getPort());\n                be.initCause(ex);\n                throw be;\n              }\n            } else {\n              LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n              throw ex;\n            }\n          } catch (MultiException ex) {\n            LOG.info(\"HttpServer.start() threw a MultiException\"); \n            throw ex;\n          }\n          listener.setPort((oriPort +\u003d 1));\n        }\n      }\n      // Make sure there is no handler failures.\n      Handler[] handlers \u003d webServer.getHandlers();\n      for (int i \u003d 0; i \u003c handlers.length; i++) {\n        if (handlers[i].isFailed()) {\n          throw new IOException(\n              \"Problem in starting http server. Server handlers failed\");\n        }\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (InterruptedException e) {\n      throw (IOException) new InterruptedIOException(\n          \"Interrupted while starting HTTP server\").initCause(e);\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {}
    },
    "a83753b73562123e35b76fe91a173033a01e2bc2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7688. Add servlet handler check in HttpServer.start().  Contributed by Uma Maheswara Rao G\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1198924 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/11/11 12:51 PM",
      "commitName": "a83753b73562123e35b76fe91a173033a01e2bc2",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "26/10/11 10:04 AM",
      "commitNameOld": "46676b322b2ae461ee19aaebc6664f9e92220a50",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 12.16,
      "commitsBetweenForRepo": 128,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,94 @@\n   public void start() throws IOException {\n     try {\n       if(listenerStartedExternally) { // Expect that listener was started securely\n         if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n           throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n              \"previously but wasn\u0027t\");\n         // And skip all the port rolling issues.\n         webServer.start();\n       } else {\n         int port \u003d 0;\n         int oriPort \u003d listener.getPort(); // The original requested port\n         while (true) {\n           try {\n             port \u003d webServer.getConnectors()[0].getLocalPort();\n             LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n             \t\t\"getLocalPort() before open() is \"+ port + \n             \t\t\". Opening the listener on \" + oriPort);\n             listener.open();\n             port \u003d listener.getLocalPort();\n             LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                   \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                   webServer.getConnectors()[0].getLocalPort());\n             //Workaround to handle the problem reported in HADOOP-4744\n             if (port \u003c 0) {\n               Thread.sleep(100);\n               int numRetries \u003d 1;\n               while (port \u003c 0) {\n                 LOG.warn(\"listener.getLocalPort returned \" + port);\n                 if (numRetries++ \u003e MAX_RETRIES) {\n                   throw new Exception(\" listener.getLocalPort is returning \" +\n                   \t\t\"less than 0 even after \" +numRetries+\" resets\");\n                 }\n                 for (int i \u003d 0; i \u003c 2; i++) {\n                   LOG.info(\"Retrying listener.getLocalPort()\");\n                   port \u003d listener.getLocalPort();\n                   if (port \u003e 0) {\n                     break;\n                   }\n                   Thread.sleep(200);\n                 }\n                 if (port \u003e 0) {\n                   break;\n                 }\n                 LOG.info(\"Bouncing the listener\");\n                 listener.close();\n                 Thread.sleep(1000);\n                 listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n                 listener.open();\n                 Thread.sleep(100);\n                 port \u003d listener.getLocalPort();\n               }\n             } //Workaround end\n             LOG.info(\"Jetty bound to port \" + port);\n             webServer.start();\n             break;\n           } catch (IOException ex) {\n             // if this is a bind exception,\n             // then try the next port number.\n             if (ex instanceof BindException) {\n               if (!findPort) {\n                 BindException be \u003d new BindException(\n                         \"Port in use: \" + listener.getHost()\n                                 + \":\" + listener.getPort());\n                 be.initCause(ex);\n                 throw be;\n               }\n             } else {\n               LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n               throw ex;\n             }\n           } catch (MultiException ex) {\n             LOG.info(\"HttpServer.start() threw a MultiException\"); \n             throw ex;\n           }\n           listener.setPort((oriPort +\u003d 1));\n         }\n       }\n+      // Make sure there is no handler failures.\n+      Handler[] handlers \u003d webServer.getHandlers();\n+      for (int i \u003d 0; i \u003c handlers.length; i++) {\n+        if (handlers[i].isFailed()) {\n+          throw new IOException(\n+              \"Problem in starting http server. Server handlers failed\");\n+        }\n+      }\n     } catch (IOException e) {\n       throw e;\n     } catch (InterruptedException e) {\n       throw (IOException) new InterruptedIOException(\n           \"Interrupted while starting HTTP server\").initCause(e);\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      if(listenerStartedExternally) { // Expect that listener was started securely\n        if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n          throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n             \"previously but wasn\u0027t\");\n        // And skip all the port rolling issues.\n        webServer.start();\n      } else {\n        int port \u003d 0;\n        int oriPort \u003d listener.getPort(); // The original requested port\n        while (true) {\n          try {\n            port \u003d webServer.getConnectors()[0].getLocalPort();\n            LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n            \t\t\"getLocalPort() before open() is \"+ port + \n            \t\t\". Opening the listener on \" + oriPort);\n            listener.open();\n            port \u003d listener.getLocalPort();\n            LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                  \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                  webServer.getConnectors()[0].getLocalPort());\n            //Workaround to handle the problem reported in HADOOP-4744\n            if (port \u003c 0) {\n              Thread.sleep(100);\n              int numRetries \u003d 1;\n              while (port \u003c 0) {\n                LOG.warn(\"listener.getLocalPort returned \" + port);\n                if (numRetries++ \u003e MAX_RETRIES) {\n                  throw new Exception(\" listener.getLocalPort is returning \" +\n                  \t\t\"less than 0 even after \" +numRetries+\" resets\");\n                }\n                for (int i \u003d 0; i \u003c 2; i++) {\n                  LOG.info(\"Retrying listener.getLocalPort()\");\n                  port \u003d listener.getLocalPort();\n                  if (port \u003e 0) {\n                    break;\n                  }\n                  Thread.sleep(200);\n                }\n                if (port \u003e 0) {\n                  break;\n                }\n                LOG.info(\"Bouncing the listener\");\n                listener.close();\n                Thread.sleep(1000);\n                listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n                listener.open();\n                Thread.sleep(100);\n                port \u003d listener.getLocalPort();\n              }\n            } //Workaround end\n            LOG.info(\"Jetty bound to port \" + port);\n            webServer.start();\n            break;\n          } catch (IOException ex) {\n            // if this is a bind exception,\n            // then try the next port number.\n            if (ex instanceof BindException) {\n              if (!findPort) {\n                BindException be \u003d new BindException(\n                        \"Port in use: \" + listener.getHost()\n                                + \":\" + listener.getPort());\n                be.initCause(ex);\n                throw be;\n              }\n            } else {\n              LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n              throw ex;\n            }\n          } catch (MultiException ex) {\n            LOG.info(\"HttpServer.start() threw a MultiException\"); \n            throw ex;\n          }\n          listener.setPort((oriPort +\u003d 1));\n        }\n      }\n      // Make sure there is no handler failures.\n      Handler[] handlers \u003d webServer.getHandlers();\n      for (int i \u003d 0; i \u003c handlers.length; i++) {\n        if (handlers[i].isFailed()) {\n          throw new IOException(\n              \"Problem in starting http server. Server handlers failed\");\n        }\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (InterruptedException e) {\n      throw (IOException) new InterruptedIOException(\n          \"Interrupted while starting HTTP server\").initCause(e);\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {}
    },
    "c5179b16ecc2c26f693eed692a6c556b6ac2e845": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6220\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1177051 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/09/11 1:37 PM",
      "commitName": "c5179b16ecc2c26f693eed692a6c556b6ac2e845",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "28/09/11 5:36 AM",
      "commitNameOld": "59586d801543a4209f2daf277c07a4f4e55414ba",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,86 @@\n   public void start() throws IOException {\n     try {\n       if(listenerStartedExternally) { // Expect that listener was started securely\n         if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n           throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n              \"previously but wasn\u0027t\");\n         // And skip all the port rolling issues.\n         webServer.start();\n       } else {\n         int port \u003d 0;\n         int oriPort \u003d listener.getPort(); // The original requested port\n         while (true) {\n           try {\n             port \u003d webServer.getConnectors()[0].getLocalPort();\n             LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n             \t\t\"getLocalPort() before open() is \"+ port + \n             \t\t\". Opening the listener on \" + oriPort);\n             listener.open();\n             port \u003d listener.getLocalPort();\n             LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                   \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                   webServer.getConnectors()[0].getLocalPort());\n             //Workaround to handle the problem reported in HADOOP-4744\n             if (port \u003c 0) {\n               Thread.sleep(100);\n               int numRetries \u003d 1;\n               while (port \u003c 0) {\n                 LOG.warn(\"listener.getLocalPort returned \" + port);\n                 if (numRetries++ \u003e MAX_RETRIES) {\n                   throw new Exception(\" listener.getLocalPort is returning \" +\n                   \t\t\"less than 0 even after \" +numRetries+\" resets\");\n                 }\n                 for (int i \u003d 0; i \u003c 2; i++) {\n                   LOG.info(\"Retrying listener.getLocalPort()\");\n                   port \u003d listener.getLocalPort();\n                   if (port \u003e 0) {\n                     break;\n                   }\n                   Thread.sleep(200);\n                 }\n                 if (port \u003e 0) {\n                   break;\n                 }\n                 LOG.info(\"Bouncing the listener\");\n                 listener.close();\n                 Thread.sleep(1000);\n                 listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n                 listener.open();\n                 Thread.sleep(100);\n                 port \u003d listener.getLocalPort();\n               }\n             } //Workaround end\n             LOG.info(\"Jetty bound to port \" + port);\n             webServer.start();\n             break;\n           } catch (IOException ex) {\n             // if this is a bind exception,\n             // then try the next port number.\n             if (ex instanceof BindException) {\n               if (!findPort) {\n                 BindException be \u003d new BindException(\n                         \"Port in use: \" + listener.getHost()\n                                 + \":\" + listener.getPort());\n                 be.initCause(ex);\n                 throw be;\n               }\n             } else {\n               LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n               throw ex;\n             }\n           } catch (MultiException ex) {\n             LOG.info(\"HttpServer.start() threw a MultiException\"); \n             throw ex;\n           }\n           listener.setPort((oriPort +\u003d 1));\n         }\n       }\n     } catch (IOException e) {\n       throw e;\n+    } catch (InterruptedException e) {\n+      throw (IOException) new InterruptedIOException(\n+          \"Interrupted while starting HTTP server\").initCause(e);\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      if(listenerStartedExternally) { // Expect that listener was started securely\n        if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n          throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n             \"previously but wasn\u0027t\");\n        // And skip all the port rolling issues.\n        webServer.start();\n      } else {\n        int port \u003d 0;\n        int oriPort \u003d listener.getPort(); // The original requested port\n        while (true) {\n          try {\n            port \u003d webServer.getConnectors()[0].getLocalPort();\n            LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n            \t\t\"getLocalPort() before open() is \"+ port + \n            \t\t\". Opening the listener on \" + oriPort);\n            listener.open();\n            port \u003d listener.getLocalPort();\n            LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                  \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                  webServer.getConnectors()[0].getLocalPort());\n            //Workaround to handle the problem reported in HADOOP-4744\n            if (port \u003c 0) {\n              Thread.sleep(100);\n              int numRetries \u003d 1;\n              while (port \u003c 0) {\n                LOG.warn(\"listener.getLocalPort returned \" + port);\n                if (numRetries++ \u003e MAX_RETRIES) {\n                  throw new Exception(\" listener.getLocalPort is returning \" +\n                  \t\t\"less than 0 even after \" +numRetries+\" resets\");\n                }\n                for (int i \u003d 0; i \u003c 2; i++) {\n                  LOG.info(\"Retrying listener.getLocalPort()\");\n                  port \u003d listener.getLocalPort();\n                  if (port \u003e 0) {\n                    break;\n                  }\n                  Thread.sleep(200);\n                }\n                if (port \u003e 0) {\n                  break;\n                }\n                LOG.info(\"Bouncing the listener\");\n                listener.close();\n                Thread.sleep(1000);\n                listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n                listener.open();\n                Thread.sleep(100);\n                port \u003d listener.getLocalPort();\n              }\n            } //Workaround end\n            LOG.info(\"Jetty bound to port \" + port);\n            webServer.start();\n            break;\n          } catch (IOException ex) {\n            // if this is a bind exception,\n            // then try the next port number.\n            if (ex instanceof BindException) {\n              if (!findPort) {\n                BindException be \u003d new BindException(\n                        \"Port in use: \" + listener.getHost()\n                                + \":\" + listener.getPort());\n                be.initCause(ex);\n                throw be;\n              }\n            } else {\n              LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n              throw ex;\n            }\n          } catch (MultiException ex) {\n            LOG.info(\"HttpServer.start() threw a MultiException\"); \n            throw ex;\n          }\n          listener.setPort((oriPort +\u003d 1));\n        }\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (InterruptedException e) {\n      throw (IOException) new InterruptedIOException(\n          \"Interrupted while starting HTTP server\").initCause(e);\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void start() throws IOException {\n    try {\n      if(listenerStartedExternally) { // Expect that listener was started securely\n        if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n          throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n             \"previously but wasn\u0027t\");\n        // And skip all the port rolling issues.\n        webServer.start();\n      } else {\n        int port \u003d 0;\n        int oriPort \u003d listener.getPort(); // The original requested port\n        while (true) {\n          try {\n            port \u003d webServer.getConnectors()[0].getLocalPort();\n            LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n            \t\t\"getLocalPort() before open() is \"+ port + \n            \t\t\". Opening the listener on \" + oriPort);\n            listener.open();\n            port \u003d listener.getLocalPort();\n            LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                  \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                  webServer.getConnectors()[0].getLocalPort());\n            //Workaround to handle the problem reported in HADOOP-4744\n            if (port \u003c 0) {\n              Thread.sleep(100);\n              int numRetries \u003d 1;\n              while (port \u003c 0) {\n                LOG.warn(\"listener.getLocalPort returned \" + port);\n                if (numRetries++ \u003e MAX_RETRIES) {\n                  throw new Exception(\" listener.getLocalPort is returning \" +\n                  \t\t\"less than 0 even after \" +numRetries+\" resets\");\n                }\n                for (int i \u003d 0; i \u003c 2; i++) {\n                  LOG.info(\"Retrying listener.getLocalPort()\");\n                  port \u003d listener.getLocalPort();\n                  if (port \u003e 0) {\n                    break;\n                  }\n                  Thread.sleep(200);\n                }\n                if (port \u003e 0) {\n                  break;\n                }\n                LOG.info(\"Bouncing the listener\");\n                listener.close();\n                Thread.sleep(1000);\n                listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n                listener.open();\n                Thread.sleep(100);\n                port \u003d listener.getLocalPort();\n              }\n            } //Workaround end\n            LOG.info(\"Jetty bound to port \" + port);\n            webServer.start();\n            break;\n          } catch (IOException ex) {\n            // if this is a bind exception,\n            // then try the next port number.\n            if (ex instanceof BindException) {\n              if (!findPort) {\n                BindException be \u003d new BindException(\n                        \"Port in use: \" + listener.getHost()\n                                + \":\" + listener.getPort());\n                be.initCause(ex);\n                throw be;\n              }\n            } else {\n              LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n              throw ex;\n            }\n          } catch (MultiException ex) {\n            LOG.info(\"HttpServer.start() threw a MultiException\"); \n            throw ex;\n          }\n          listener.setPort((oriPort +\u003d 1));\n        }\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void start() throws IOException {\n    try {\n      if(listenerStartedExternally) { // Expect that listener was started securely\n        if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n          throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n             \"previously but wasn\u0027t\");\n        // And skip all the port rolling issues.\n        webServer.start();\n      } else {\n        int port \u003d 0;\n        int oriPort \u003d listener.getPort(); // The original requested port\n        while (true) {\n          try {\n            port \u003d webServer.getConnectors()[0].getLocalPort();\n            LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n            \t\t\"getLocalPort() before open() is \"+ port + \n            \t\t\". Opening the listener on \" + oriPort);\n            listener.open();\n            port \u003d listener.getLocalPort();\n            LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                  \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                  webServer.getConnectors()[0].getLocalPort());\n            //Workaround to handle the problem reported in HADOOP-4744\n            if (port \u003c 0) {\n              Thread.sleep(100);\n              int numRetries \u003d 1;\n              while (port \u003c 0) {\n                LOG.warn(\"listener.getLocalPort returned \" + port);\n                if (numRetries++ \u003e MAX_RETRIES) {\n                  throw new Exception(\" listener.getLocalPort is returning \" +\n                  \t\t\"less than 0 even after \" +numRetries+\" resets\");\n                }\n                for (int i \u003d 0; i \u003c 2; i++) {\n                  LOG.info(\"Retrying listener.getLocalPort()\");\n                  port \u003d listener.getLocalPort();\n                  if (port \u003e 0) {\n                    break;\n                  }\n                  Thread.sleep(200);\n                }\n                if (port \u003e 0) {\n                  break;\n                }\n                LOG.info(\"Bouncing the listener\");\n                listener.close();\n                Thread.sleep(1000);\n                listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n                listener.open();\n                Thread.sleep(100);\n                port \u003d listener.getLocalPort();\n              }\n            } //Workaround end\n            LOG.info(\"Jetty bound to port \" + port);\n            webServer.start();\n            break;\n          } catch (IOException ex) {\n            // if this is a bind exception,\n            // then try the next port number.\n            if (ex instanceof BindException) {\n              if (!findPort) {\n                BindException be \u003d new BindException(\n                        \"Port in use: \" + listener.getHost()\n                                + \":\" + listener.getPort());\n                be.initCause(ex);\n                throw be;\n              }\n            } else {\n              LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n              throw ex;\n            }\n          } catch (MultiException ex) {\n            LOG.info(\"HttpServer.start() threw a MultiException\"); \n            throw ex;\n          }\n          listener.setPort((oriPort +\u003d 1));\n        }\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/http/HttpServer.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void start() throws IOException {\n    try {\n      if(listenerStartedExternally) { // Expect that listener was started securely\n        if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n          throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n             \"previously but wasn\u0027t\");\n        // And skip all the port rolling issues.\n        webServer.start();\n      } else {\n        int port \u003d 0;\n        int oriPort \u003d listener.getPort(); // The original requested port\n        while (true) {\n          try {\n            port \u003d webServer.getConnectors()[0].getLocalPort();\n            LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n            \t\t\"getLocalPort() before open() is \"+ port + \n            \t\t\". Opening the listener on \" + oriPort);\n            listener.open();\n            port \u003d listener.getLocalPort();\n            LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                  \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                  webServer.getConnectors()[0].getLocalPort());\n            //Workaround to handle the problem reported in HADOOP-4744\n            if (port \u003c 0) {\n              Thread.sleep(100);\n              int numRetries \u003d 1;\n              while (port \u003c 0) {\n                LOG.warn(\"listener.getLocalPort returned \" + port);\n                if (numRetries++ \u003e MAX_RETRIES) {\n                  throw new Exception(\" listener.getLocalPort is returning \" +\n                  \t\t\"less than 0 even after \" +numRetries+\" resets\");\n                }\n                for (int i \u003d 0; i \u003c 2; i++) {\n                  LOG.info(\"Retrying listener.getLocalPort()\");\n                  port \u003d listener.getLocalPort();\n                  if (port \u003e 0) {\n                    break;\n                  }\n                  Thread.sleep(200);\n                }\n                if (port \u003e 0) {\n                  break;\n                }\n                LOG.info(\"Bouncing the listener\");\n                listener.close();\n                Thread.sleep(1000);\n                listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n                listener.open();\n                Thread.sleep(100);\n                port \u003d listener.getLocalPort();\n              }\n            } //Workaround end\n            LOG.info(\"Jetty bound to port \" + port);\n            webServer.start();\n            break;\n          } catch (IOException ex) {\n            // if this is a bind exception,\n            // then try the next port number.\n            if (ex instanceof BindException) {\n              if (!findPort) {\n                BindException be \u003d new BindException(\n                        \"Port in use: \" + listener.getHost()\n                                + \":\" + listener.getPort());\n                be.initCause(ex);\n                throw be;\n              }\n            } else {\n              LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n              throw ex;\n            }\n          } catch (MultiException ex) {\n            LOG.info(\"HttpServer.start() threw a MultiException\"); \n            throw ex;\n          }\n          listener.setPort((oriPort +\u003d 1));\n        }\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "common/src/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/http/HttpServer.java",
        "newPath": "common/src/java/org/apache/hadoop/http/HttpServer.java"
      }
    },
    "1035138b4c03ed26ce5be9fc4dd6f6c1e0af909b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6892. Common component of HDFS-1150 (Verify datanodes\u0027 identities to clients in secure clusters).\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@981688 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/10 2:10 PM",
      "commitName": "1035138b4c03ed26ce5be9fc4dd6f6c1e0af909b",
      "commitAuthor": "Jakob Homan",
      "commitDateOld": "02/07/10 5:02 PM",
      "commitNameOld": "4b34109a727ab585574bea5fed61e25d4a25c077",
      "commitAuthorOld": "Jakob Homan",
      "daysBetweenCommits": 30.88,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,83 @@\n   public void start() throws IOException {\n     try {\n-      int port \u003d 0;\n-      int oriPort \u003d listener.getPort(); // The original requested port\n-      while (true) {\n-        try {\n-          port \u003d webServer.getConnectors()[0].getLocalPort();\n-          LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n-          \t\t\"getLocalPort() before open() is \"+ port + \n-          \t\t\". Opening the listener on \" + oriPort);\n-          listener.open();\n-          port \u003d listener.getLocalPort();\n-          LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n-                \" webServer.getConnectors()[0].getLocalPort() returned \" +\n-                webServer.getConnectors()[0].getLocalPort());\n-          //Workaround to handle the problem reported in HADOOP-4744\n-          if (port \u003c 0) {\n-            Thread.sleep(100);\n-            int numRetries \u003d 1;\n-            while (port \u003c 0) {\n-              LOG.warn(\"listener.getLocalPort returned \" + port);\n-              if (numRetries++ \u003e MAX_RETRIES) {\n-                throw new Exception(\" listener.getLocalPort is returning \" +\n-                \t\t\"less than 0 even after \" +numRetries+\" resets\");\n-              }\n-              for (int i \u003d 0; i \u003c 2; i++) {\n-                LOG.info(\"Retrying listener.getLocalPort()\");\n-                port \u003d listener.getLocalPort();\n+      if(listenerStartedExternally) { // Expect that listener was started securely\n+        if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n+          throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n+             \"previously but wasn\u0027t\");\n+        // And skip all the port rolling issues.\n+        webServer.start();\n+      } else {\n+        int port \u003d 0;\n+        int oriPort \u003d listener.getPort(); // The original requested port\n+        while (true) {\n+          try {\n+            port \u003d webServer.getConnectors()[0].getLocalPort();\n+            LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n+            \t\t\"getLocalPort() before open() is \"+ port + \n+            \t\t\". Opening the listener on \" + oriPort);\n+            listener.open();\n+            port \u003d listener.getLocalPort();\n+            LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n+                  \" webServer.getConnectors()[0].getLocalPort() returned \" +\n+                  webServer.getConnectors()[0].getLocalPort());\n+            //Workaround to handle the problem reported in HADOOP-4744\n+            if (port \u003c 0) {\n+              Thread.sleep(100);\n+              int numRetries \u003d 1;\n+              while (port \u003c 0) {\n+                LOG.warn(\"listener.getLocalPort returned \" + port);\n+                if (numRetries++ \u003e MAX_RETRIES) {\n+                  throw new Exception(\" listener.getLocalPort is returning \" +\n+                  \t\t\"less than 0 even after \" +numRetries+\" resets\");\n+                }\n+                for (int i \u003d 0; i \u003c 2; i++) {\n+                  LOG.info(\"Retrying listener.getLocalPort()\");\n+                  port \u003d listener.getLocalPort();\n+                  if (port \u003e 0) {\n+                    break;\n+                  }\n+                  Thread.sleep(200);\n+                }\n                 if (port \u003e 0) {\n                   break;\n                 }\n-                Thread.sleep(200);\n+                LOG.info(\"Bouncing the listener\");\n+                listener.close();\n+                Thread.sleep(1000);\n+                listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n+                listener.open();\n+                Thread.sleep(100);\n+                port \u003d listener.getLocalPort();\n               }\n-              if (port \u003e 0) {\n-                break;\n+            } //Workaround end\n+            LOG.info(\"Jetty bound to port \" + port);\n+            webServer.start();\n+            break;\n+          } catch (IOException ex) {\n+            // if this is a bind exception,\n+            // then try the next port number.\n+            if (ex instanceof BindException) {\n+              if (!findPort) {\n+                BindException be \u003d new BindException(\n+                        \"Port in use: \" + listener.getHost()\n+                                + \":\" + listener.getPort());\n+                be.initCause(ex);\n+                throw be;\n               }\n-              LOG.info(\"Bouncing the listener\");\n-              listener.close();\n-              Thread.sleep(1000);\n-              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n-              listener.open();\n-              Thread.sleep(100);\n-              port \u003d listener.getLocalPort();\n+            } else {\n+              LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n+              throw ex;\n             }\n-          } //Workaround end\n-          LOG.info(\"Jetty bound to port \" + port);\n-          webServer.start();\n-          break;\n-        } catch (IOException ex) {\n-          // if this is a bind exception,\n-          // then try the next port number.\n-          if (ex instanceof BindException) {\n-            if (!findPort) {\n-              BindException be \u003d new BindException(\n-                      \"Port in use: \" + listener.getHost()\n-                              + \":\" + listener.getPort());\n-              be.initCause(ex);\n-              throw be;\n-            }\n-          } else {\n-            LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n+          } catch (MultiException ex) {\n+            LOG.info(\"HttpServer.start() threw a MultiException\"); \n             throw ex;\n           }\n-        } catch (MultiException ex) {\n-          LOG.info(\"HttpServer.start() threw a MultiException\"); \n-          throw ex;\n+          listener.setPort((oriPort +\u003d 1));\n         }\n-        listener.setPort((oriPort +\u003d 1));\n       }\n     } catch (IOException e) {\n       throw e;\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      if(listenerStartedExternally) { // Expect that listener was started securely\n        if(listener.getLocalPort() \u003d\u003d -1) // ... and verify\n          throw new Exception(\"Exepected webserver\u0027s listener to be started \" +\n             \"previously but wasn\u0027t\");\n        // And skip all the port rolling issues.\n        webServer.start();\n      } else {\n        int port \u003d 0;\n        int oriPort \u003d listener.getPort(); // The original requested port\n        while (true) {\n          try {\n            port \u003d webServer.getConnectors()[0].getLocalPort();\n            LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n            \t\t\"getLocalPort() before open() is \"+ port + \n            \t\t\". Opening the listener on \" + oriPort);\n            listener.open();\n            port \u003d listener.getLocalPort();\n            LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                  \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                  webServer.getConnectors()[0].getLocalPort());\n            //Workaround to handle the problem reported in HADOOP-4744\n            if (port \u003c 0) {\n              Thread.sleep(100);\n              int numRetries \u003d 1;\n              while (port \u003c 0) {\n                LOG.warn(\"listener.getLocalPort returned \" + port);\n                if (numRetries++ \u003e MAX_RETRIES) {\n                  throw new Exception(\" listener.getLocalPort is returning \" +\n                  \t\t\"less than 0 even after \" +numRetries+\" resets\");\n                }\n                for (int i \u003d 0; i \u003c 2; i++) {\n                  LOG.info(\"Retrying listener.getLocalPort()\");\n                  port \u003d listener.getLocalPort();\n                  if (port \u003e 0) {\n                    break;\n                  }\n                  Thread.sleep(200);\n                }\n                if (port \u003e 0) {\n                  break;\n                }\n                LOG.info(\"Bouncing the listener\");\n                listener.close();\n                Thread.sleep(1000);\n                listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n                listener.open();\n                Thread.sleep(100);\n                port \u003d listener.getLocalPort();\n              }\n            } //Workaround end\n            LOG.info(\"Jetty bound to port \" + port);\n            webServer.start();\n            break;\n          } catch (IOException ex) {\n            // if this is a bind exception,\n            // then try the next port number.\n            if (ex instanceof BindException) {\n              if (!findPort) {\n                BindException be \u003d new BindException(\n                        \"Port in use: \" + listener.getHost()\n                                + \":\" + listener.getPort());\n                be.initCause(ex);\n                throw be;\n              }\n            } else {\n              LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n              throw ex;\n            }\n          } catch (MultiException ex) {\n            LOG.info(\"HttpServer.start() threw a MultiException\"); \n            throw ex;\n          }\n          listener.setPort((oriPort +\u003d 1));\n        }\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "src/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {}
    },
    "4e5bdc46bc717d365cce95dd7be0685ef8443dd7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6760. WebServer shouldn\u0027t increase port number in case of\nnegative port setting caused by Jetty\u0027s race. Contributed by Konstantin\nBoudnik.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@947218 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/10 5:27 PM",
      "commitName": "4e5bdc46bc717d365cce95dd7be0685ef8443dd7",
      "commitAuthor": "Konstantin Boudnik",
      "commitDateOld": "29/04/10 2:32 PM",
      "commitNameOld": "f6acb32e068a3f1611767c92f728f1c92b9a9fad",
      "commitAuthorOld": "Zheng Shao",
      "daysBetweenCommits": 22.12,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,75 @@\n   public void start() throws IOException {\n     try {\n       int port \u003d 0;\n       int oriPort \u003d listener.getPort(); // The original requested port\n       while (true) {\n         try {\n           port \u003d webServer.getConnectors()[0].getLocalPort();\n           LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n           \t\t\"getLocalPort() before open() is \"+ port + \n           \t\t\". Opening the listener on \" + oriPort);\n           listener.open();\n           port \u003d listener.getLocalPort();\n           LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                 \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                 webServer.getConnectors()[0].getLocalPort());\n           //Workaround to handle the problem reported in HADOOP-4744\n           if (port \u003c 0) {\n             Thread.sleep(100);\n             int numRetries \u003d 1;\n             while (port \u003c 0) {\n               LOG.warn(\"listener.getLocalPort returned \" + port);\n               if (numRetries++ \u003e MAX_RETRIES) {\n                 throw new Exception(\" listener.getLocalPort is returning \" +\n                 \t\t\"less than 0 even after \" +numRetries+\" resets\");\n               }\n               for (int i \u003d 0; i \u003c 2; i++) {\n                 LOG.info(\"Retrying listener.getLocalPort()\");\n                 port \u003d listener.getLocalPort();\n                 if (port \u003e 0) {\n                   break;\n                 }\n                 Thread.sleep(200);\n               }\n               if (port \u003e 0) {\n                 break;\n               }\n               LOG.info(\"Bouncing the listener\");\n               listener.close();\n               Thread.sleep(1000);\n               listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n               listener.open();\n               Thread.sleep(100);\n               port \u003d listener.getLocalPort();\n             }\n           } //Workaround end\n           LOG.info(\"Jetty bound to port \" + port);\n           webServer.start();\n-          // Workaround for HADOOP-6386\n-          port \u003d listener.getLocalPort();\n-          if (port \u003c 0) {\n-            LOG.warn(\"Bounds port is \" + port + \" after webserver start\");\n-            for (int i \u003d 0; i \u003c MAX_RETRIES/2; i++) {\n-              try {\n-                webServer.stop();\n-              } catch (Exception e) {\n-                LOG.warn(\"Can\u0027t stop  web-server\", e);\n-              }\n-              Thread.sleep(1000);\n-              \n-              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n-              listener.open();\n-              Thread.sleep(100);\n-              webServer.start();\n-              LOG.info(i + \"attempts to restart webserver\");\n-              port \u003d listener.getLocalPort();\n-              if (port \u003e 0)\n-                break;\n-            }\n-            if (port \u003c 0)\n-              throw new Exception(\"listener.getLocalPort() is returning \" +\n-                \t\t\"less than 0 even after \" +MAX_RETRIES+\" resets\");\n-          }\n-          // End of HADOOP-6386 workaround\n           break;\n         } catch (IOException ex) {\n           // if this is a bind exception,\n           // then try the next port number.\n           if (ex instanceof BindException) {\n             if (!findPort) {\n               BindException be \u003d new BindException(\n                       \"Port in use: \" + listener.getHost()\n                               + \":\" + listener.getPort());\n               be.initCause(ex);\n               throw be;\n             }\n           } else {\n             LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n             throw ex;\n           }\n         } catch (MultiException ex) {\n           LOG.info(\"HttpServer.start() threw a MultiException\"); \n           throw ex;\n         }\n         listener.setPort((oriPort +\u003d 1));\n       }\n     } catch (IOException e) {\n       throw e;\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      int port \u003d 0;\n      int oriPort \u003d listener.getPort(); // The original requested port\n      while (true) {\n        try {\n          port \u003d webServer.getConnectors()[0].getLocalPort();\n          LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n          \t\t\"getLocalPort() before open() is \"+ port + \n          \t\t\". Opening the listener on \" + oriPort);\n          listener.open();\n          port \u003d listener.getLocalPort();\n          LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                webServer.getConnectors()[0].getLocalPort());\n          //Workaround to handle the problem reported in HADOOP-4744\n          if (port \u003c 0) {\n            Thread.sleep(100);\n            int numRetries \u003d 1;\n            while (port \u003c 0) {\n              LOG.warn(\"listener.getLocalPort returned \" + port);\n              if (numRetries++ \u003e MAX_RETRIES) {\n                throw new Exception(\" listener.getLocalPort is returning \" +\n                \t\t\"less than 0 even after \" +numRetries+\" resets\");\n              }\n              for (int i \u003d 0; i \u003c 2; i++) {\n                LOG.info(\"Retrying listener.getLocalPort()\");\n                port \u003d listener.getLocalPort();\n                if (port \u003e 0) {\n                  break;\n                }\n                Thread.sleep(200);\n              }\n              if (port \u003e 0) {\n                break;\n              }\n              LOG.info(\"Bouncing the listener\");\n              listener.close();\n              Thread.sleep(1000);\n              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n              listener.open();\n              Thread.sleep(100);\n              port \u003d listener.getLocalPort();\n            }\n          } //Workaround end\n          LOG.info(\"Jetty bound to port \" + port);\n          webServer.start();\n          break;\n        } catch (IOException ex) {\n          // if this is a bind exception,\n          // then try the next port number.\n          if (ex instanceof BindException) {\n            if (!findPort) {\n              BindException be \u003d new BindException(\n                      \"Port in use: \" + listener.getHost()\n                              + \":\" + listener.getPort());\n              be.initCause(ex);\n              throw be;\n            }\n          } else {\n            LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n            throw ex;\n          }\n        } catch (MultiException ex) {\n          LOG.info(\"HttpServer.start() threw a MultiException\"); \n          throw ex;\n        }\n        listener.setPort((oriPort +\u003d 1));\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "src/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {}
    },
    "583c41bfac1d1ff911e798d55f8a2879a0fd3235": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6434 Make HttpServer slightly easier to manage/diagnose faults with\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@893485 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/12/09 4:02 AM",
      "commitName": "583c41bfac1d1ff911e798d55f8a2879a0fd3235",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "15/12/09 10:31 PM",
      "commitNameOld": "875c9d62c6db32aca16201c369d972bcf4a38dbd",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 7.23,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,101 @@\n   public void start() throws IOException {\n     try {\n       int port \u003d 0;\n       int oriPort \u003d listener.getPort(); // The original requested port\n       while (true) {\n         try {\n           port \u003d webServer.getConnectors()[0].getLocalPort();\n           LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n           \t\t\"getLocalPort() before open() is \"+ port + \n           \t\t\". Opening the listener on \" + oriPort);\n           listener.open();\n           port \u003d listener.getLocalPort();\n           LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                 \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                 webServer.getConnectors()[0].getLocalPort());\n           //Workaround to handle the problem reported in HADOOP-4744\n           if (port \u003c 0) {\n             Thread.sleep(100);\n             int numRetries \u003d 1;\n             while (port \u003c 0) {\n               LOG.warn(\"listener.getLocalPort returned \" + port);\n               if (numRetries++ \u003e MAX_RETRIES) {\n                 throw new Exception(\" listener.getLocalPort is returning \" +\n                 \t\t\"less than 0 even after \" +numRetries+\" resets\");\n               }\n               for (int i \u003d 0; i \u003c 2; i++) {\n                 LOG.info(\"Retrying listener.getLocalPort()\");\n                 port \u003d listener.getLocalPort();\n                 if (port \u003e 0) {\n                   break;\n                 }\n                 Thread.sleep(200);\n               }\n               if (port \u003e 0) {\n                 break;\n               }\n               LOG.info(\"Bouncing the listener\");\n               listener.close();\n               Thread.sleep(1000);\n               listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n               listener.open();\n               Thread.sleep(100);\n               port \u003d listener.getLocalPort();\n             }\n           } //Workaround end\n           LOG.info(\"Jetty bound to port \" + port);\n           webServer.start();\n           // Workaround for HADOOP-6386\n           port \u003d listener.getLocalPort();\n           if (port \u003c 0) {\n             LOG.warn(\"Bounds port is \" + port + \" after webserver start\");\n             for (int i \u003d 0; i \u003c MAX_RETRIES/2; i++) {\n               try {\n                 webServer.stop();\n               } catch (Exception e) {\n                 LOG.warn(\"Can\u0027t stop  web-server\", e);\n               }\n               Thread.sleep(1000);\n               \n               listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n               listener.open();\n               Thread.sleep(100);\n               webServer.start();\n               LOG.info(i + \"attempts to restart webserver\");\n               port \u003d listener.getLocalPort();\n               if (port \u003e 0)\n                 break;\n             }\n             if (port \u003c 0)\n               throw new Exception(\"listener.getLocalPort() is returning \" +\n                 \t\t\"less than 0 even after \" +MAX_RETRIES+\" resets\");\n           }\n           // End of HADOOP-6386 workaround\n           break;\n         } catch (IOException ex) {\n           // if this is a bind exception,\n           // then try the next port number.\n           if (ex instanceof BindException) {\n             if (!findPort) {\n-              throw (BindException) ex;\n+              BindException be \u003d new BindException(\n+                      \"Port in use: \" + listener.getHost()\n+                              + \":\" + listener.getPort());\n+              be.initCause(ex);\n+              throw be;\n             }\n           } else {\n             LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n             throw ex;\n           }\n         } catch (MultiException ex) {\n           LOG.info(\"HttpServer.start() threw a MultiException\"); \n           throw ex;\n         }\n         listener.setPort((oriPort +\u003d 1));\n       }\n     } catch (IOException e) {\n       throw e;\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      int port \u003d 0;\n      int oriPort \u003d listener.getPort(); // The original requested port\n      while (true) {\n        try {\n          port \u003d webServer.getConnectors()[0].getLocalPort();\n          LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n          \t\t\"getLocalPort() before open() is \"+ port + \n          \t\t\". Opening the listener on \" + oriPort);\n          listener.open();\n          port \u003d listener.getLocalPort();\n          LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                webServer.getConnectors()[0].getLocalPort());\n          //Workaround to handle the problem reported in HADOOP-4744\n          if (port \u003c 0) {\n            Thread.sleep(100);\n            int numRetries \u003d 1;\n            while (port \u003c 0) {\n              LOG.warn(\"listener.getLocalPort returned \" + port);\n              if (numRetries++ \u003e MAX_RETRIES) {\n                throw new Exception(\" listener.getLocalPort is returning \" +\n                \t\t\"less than 0 even after \" +numRetries+\" resets\");\n              }\n              for (int i \u003d 0; i \u003c 2; i++) {\n                LOG.info(\"Retrying listener.getLocalPort()\");\n                port \u003d listener.getLocalPort();\n                if (port \u003e 0) {\n                  break;\n                }\n                Thread.sleep(200);\n              }\n              if (port \u003e 0) {\n                break;\n              }\n              LOG.info(\"Bouncing the listener\");\n              listener.close();\n              Thread.sleep(1000);\n              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n              listener.open();\n              Thread.sleep(100);\n              port \u003d listener.getLocalPort();\n            }\n          } //Workaround end\n          LOG.info(\"Jetty bound to port \" + port);\n          webServer.start();\n          // Workaround for HADOOP-6386\n          port \u003d listener.getLocalPort();\n          if (port \u003c 0) {\n            LOG.warn(\"Bounds port is \" + port + \" after webserver start\");\n            for (int i \u003d 0; i \u003c MAX_RETRIES/2; i++) {\n              try {\n                webServer.stop();\n              } catch (Exception e) {\n                LOG.warn(\"Can\u0027t stop  web-server\", e);\n              }\n              Thread.sleep(1000);\n              \n              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n              listener.open();\n              Thread.sleep(100);\n              webServer.start();\n              LOG.info(i + \"attempts to restart webserver\");\n              port \u003d listener.getLocalPort();\n              if (port \u003e 0)\n                break;\n            }\n            if (port \u003c 0)\n              throw new Exception(\"listener.getLocalPort() is returning \" +\n                \t\t\"less than 0 even after \" +MAX_RETRIES+\" resets\");\n          }\n          // End of HADOOP-6386 workaround\n          break;\n        } catch (IOException ex) {\n          // if this is a bind exception,\n          // then try the next port number.\n          if (ex instanceof BindException) {\n            if (!findPort) {\n              BindException be \u003d new BindException(\n                      \"Port in use: \" + listener.getHost()\n                              + \":\" + listener.getPort());\n              be.initCause(ex);\n              throw be;\n            }\n          } else {\n            LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n            throw ex;\n          }\n        } catch (MultiException ex) {\n          LOG.info(\"HttpServer.start() threw a MultiException\"); \n          throw ex;\n        }\n        listener.setPort((oriPort +\u003d 1));\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "src/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {}
    },
    "d7fb2d3c859c852e303bb002d56e72813a1af7b2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6428. HttpServer sleeps with negative values. Contributed by Konstantin Boudnik\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@889378 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/12/09 11:26 AM",
      "commitName": "d7fb2d3c859c852e303bb002d56e72813a1af7b2",
      "commitAuthor": "Konstantin Boudnik",
      "commitDateOld": "08/12/09 12:50 PM",
      "commitNameOld": "929e91a08c5387c692ed3257361190b83d72f2e9",
      "commitAuthorOld": "Konstantin Boudnik",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,97 @@\n   public void start() throws IOException {\n     try {\n       int port \u003d 0;\n       int oriPort \u003d listener.getPort(); // The original requested port\n       while (true) {\n         try {\n           port \u003d webServer.getConnectors()[0].getLocalPort();\n           LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n           \t\t\"getLocalPort() before open() is \"+ port + \n           \t\t\". Opening the listener on \" + oriPort);\n           listener.open();\n           port \u003d listener.getLocalPort();\n           LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                 \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                 webServer.getConnectors()[0].getLocalPort());\n           //Workaround to handle the problem reported in HADOOP-4744\n           if (port \u003c 0) {\n             Thread.sleep(100);\n             int numRetries \u003d 1;\n             while (port \u003c 0) {\n               LOG.warn(\"listener.getLocalPort returned \" + port);\n               if (numRetries++ \u003e MAX_RETRIES) {\n                 throw new Exception(\" listener.getLocalPort is returning \" +\n                 \t\t\"less than 0 even after \" +numRetries+\" resets\");\n               }\n               for (int i \u003d 0; i \u003c 2; i++) {\n                 LOG.info(\"Retrying listener.getLocalPort()\");\n                 port \u003d listener.getLocalPort();\n                 if (port \u003e 0) {\n                   break;\n                 }\n                 Thread.sleep(200);\n               }\n               if (port \u003e 0) {\n                 break;\n               }\n               LOG.info(\"Bouncing the listener\");\n               listener.close();\n               Thread.sleep(1000);\n               listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n               listener.open();\n               Thread.sleep(100);\n               port \u003d listener.getLocalPort();\n             }\n           } //Workaround end\n           LOG.info(\"Jetty bound to port \" + port);\n           webServer.start();\n           // Workaround for HADOOP-6386\n           port \u003d listener.getLocalPort();\n           if (port \u003c 0) {\n             LOG.warn(\"Bounds port is \" + port + \" after webserver start\");\n-            Random r \u003d new Random(1000);\n             for (int i \u003d 0; i \u003c MAX_RETRIES/2; i++) {\n               try {\n                 webServer.stop();\n               } catch (Exception e) {\n                 LOG.warn(\"Can\u0027t stop  web-server\", e);\n               }\n-              Thread.sleep(r.nextInt());\n+              Thread.sleep(1000);\n               \n               listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n               listener.open();\n               Thread.sleep(100);\n               webServer.start();\n               LOG.info(i + \"attempts to restart webserver\");\n               port \u003d listener.getLocalPort();\n               if (port \u003e 0)\n                 break;\n             }\n             if (port \u003c 0)\n               throw new Exception(\"listener.getLocalPort() is returning \" +\n                 \t\t\"less than 0 even after \" +MAX_RETRIES+\" resets\");\n           }\n           // End of HADOOP-6386 workaround\n           break;\n         } catch (IOException ex) {\n           // if this is a bind exception,\n           // then try the next port number.\n           if (ex instanceof BindException) {\n             if (!findPort) {\n               throw (BindException) ex;\n             }\n           } else {\n             LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n             throw ex;\n           }\n         } catch (MultiException ex) {\n           LOG.info(\"HttpServer.start() threw a MultiException\"); \n           throw ex;\n         }\n         listener.setPort((oriPort +\u003d 1));\n       }\n     } catch (IOException e) {\n       throw e;\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      int port \u003d 0;\n      int oriPort \u003d listener.getPort(); // The original requested port\n      while (true) {\n        try {\n          port \u003d webServer.getConnectors()[0].getLocalPort();\n          LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n          \t\t\"getLocalPort() before open() is \"+ port + \n          \t\t\". Opening the listener on \" + oriPort);\n          listener.open();\n          port \u003d listener.getLocalPort();\n          LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                webServer.getConnectors()[0].getLocalPort());\n          //Workaround to handle the problem reported in HADOOP-4744\n          if (port \u003c 0) {\n            Thread.sleep(100);\n            int numRetries \u003d 1;\n            while (port \u003c 0) {\n              LOG.warn(\"listener.getLocalPort returned \" + port);\n              if (numRetries++ \u003e MAX_RETRIES) {\n                throw new Exception(\" listener.getLocalPort is returning \" +\n                \t\t\"less than 0 even after \" +numRetries+\" resets\");\n              }\n              for (int i \u003d 0; i \u003c 2; i++) {\n                LOG.info(\"Retrying listener.getLocalPort()\");\n                port \u003d listener.getLocalPort();\n                if (port \u003e 0) {\n                  break;\n                }\n                Thread.sleep(200);\n              }\n              if (port \u003e 0) {\n                break;\n              }\n              LOG.info(\"Bouncing the listener\");\n              listener.close();\n              Thread.sleep(1000);\n              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n              listener.open();\n              Thread.sleep(100);\n              port \u003d listener.getLocalPort();\n            }\n          } //Workaround end\n          LOG.info(\"Jetty bound to port \" + port);\n          webServer.start();\n          // Workaround for HADOOP-6386\n          port \u003d listener.getLocalPort();\n          if (port \u003c 0) {\n            LOG.warn(\"Bounds port is \" + port + \" after webserver start\");\n            for (int i \u003d 0; i \u003c MAX_RETRIES/2; i++) {\n              try {\n                webServer.stop();\n              } catch (Exception e) {\n                LOG.warn(\"Can\u0027t stop  web-server\", e);\n              }\n              Thread.sleep(1000);\n              \n              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n              listener.open();\n              Thread.sleep(100);\n              webServer.start();\n              LOG.info(i + \"attempts to restart webserver\");\n              port \u003d listener.getLocalPort();\n              if (port \u003e 0)\n                break;\n            }\n            if (port \u003c 0)\n              throw new Exception(\"listener.getLocalPort() is returning \" +\n                \t\t\"less than 0 even after \" +MAX_RETRIES+\" resets\");\n          }\n          // End of HADOOP-6386 workaround\n          break;\n        } catch (IOException ex) {\n          // if this is a bind exception,\n          // then try the next port number.\n          if (ex instanceof BindException) {\n            if (!findPort) {\n              throw (BindException) ex;\n            }\n          } else {\n            LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n            throw ex;\n          }\n        } catch (MultiException ex) {\n          LOG.info(\"HttpServer.start() threw a MultiException\"); \n          throw ex;\n        }\n        listener.setPort((oriPort +\u003d 1));\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "src/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {}
    },
    "929e91a08c5387c692ed3257361190b83d72f2e9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6386. NameNode\u0027s HttpServer can\u0027t instantiate InetSocketAddress: IllegalArgumentException is thrown. Contributed by Konstantin Boudnik.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@888565 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/12/09 12:50 PM",
      "commitName": "929e91a08c5387c692ed3257361190b83d72f2e9",
      "commitAuthor": "Konstantin Boudnik",
      "commitDateOld": "06/11/09 12:54 PM",
      "commitNameOld": "ad884406518e3b45e26eab51930548138fe47020",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 32.0,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,98 @@\n   public void start() throws IOException {\n     try {\n       int port \u003d 0;\n       int oriPort \u003d listener.getPort(); // The original requested port\n       while (true) {\n         try {\n           port \u003d webServer.getConnectors()[0].getLocalPort();\n           LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n           \t\t\"getLocalPort() before open() is \"+ port + \n           \t\t\". Opening the listener on \" + oriPort);\n           listener.open();\n           port \u003d listener.getLocalPort();\n           LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                 \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                 webServer.getConnectors()[0].getLocalPort());\n           //Workaround to handle the problem reported in HADOOP-4744\n           if (port \u003c 0) {\n             Thread.sleep(100);\n             int numRetries \u003d 1;\n             while (port \u003c 0) {\n               LOG.warn(\"listener.getLocalPort returned \" + port);\n               if (numRetries++ \u003e MAX_RETRIES) {\n                 throw new Exception(\" listener.getLocalPort is returning \" +\n                 \t\t\"less than 0 even after \" +numRetries+\" resets\");\n               }\n               for (int i \u003d 0; i \u003c 2; i++) {\n                 LOG.info(\"Retrying listener.getLocalPort()\");\n                 port \u003d listener.getLocalPort();\n                 if (port \u003e 0) {\n                   break;\n                 }\n                 Thread.sleep(200);\n               }\n               if (port \u003e 0) {\n                 break;\n               }\n               LOG.info(\"Bouncing the listener\");\n               listener.close();\n               Thread.sleep(1000);\n               listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n               listener.open();\n               Thread.sleep(100);\n               port \u003d listener.getLocalPort();\n             }\n           } //Workaround end\n           LOG.info(\"Jetty bound to port \" + port);\n           webServer.start();\n+          // Workaround for HADOOP-6386\n+          port \u003d listener.getLocalPort();\n+          if (port \u003c 0) {\n+            LOG.warn(\"Bounds port is \" + port + \" after webserver start\");\n+            Random r \u003d new Random(1000);\n+            for (int i \u003d 0; i \u003c MAX_RETRIES/2; i++) {\n+              try {\n+                webServer.stop();\n+              } catch (Exception e) {\n+                LOG.warn(\"Can\u0027t stop  web-server\", e);\n+              }\n+              Thread.sleep(r.nextInt());\n+              \n+              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n+              listener.open();\n+              Thread.sleep(100);\n+              webServer.start();\n+              LOG.info(i + \"attempts to restart webserver\");\n+              port \u003d listener.getLocalPort();\n+              if (port \u003e 0)\n+                break;\n+            }\n+            if (port \u003c 0)\n+              throw new Exception(\"listener.getLocalPort() is returning \" +\n+                \t\t\"less than 0 even after \" +MAX_RETRIES+\" resets\");\n+          }\n+          // End of HADOOP-6386 workaround\n           break;\n         } catch (IOException ex) {\n           // if this is a bind exception,\n           // then try the next port number.\n           if (ex instanceof BindException) {\n             if (!findPort) {\n               throw (BindException) ex;\n             }\n           } else {\n             LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n             throw ex;\n           }\n         } catch (MultiException ex) {\n           LOG.info(\"HttpServer.start() threw a MultiException\"); \n           throw ex;\n         }\n         listener.setPort((oriPort +\u003d 1));\n       }\n     } catch (IOException e) {\n       throw e;\n     } catch (Exception e) {\n       throw new IOException(\"Problem starting http server\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      int port \u003d 0;\n      int oriPort \u003d listener.getPort(); // The original requested port\n      while (true) {\n        try {\n          port \u003d webServer.getConnectors()[0].getLocalPort();\n          LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n          \t\t\"getLocalPort() before open() is \"+ port + \n          \t\t\". Opening the listener on \" + oriPort);\n          listener.open();\n          port \u003d listener.getLocalPort();\n          LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                webServer.getConnectors()[0].getLocalPort());\n          //Workaround to handle the problem reported in HADOOP-4744\n          if (port \u003c 0) {\n            Thread.sleep(100);\n            int numRetries \u003d 1;\n            while (port \u003c 0) {\n              LOG.warn(\"listener.getLocalPort returned \" + port);\n              if (numRetries++ \u003e MAX_RETRIES) {\n                throw new Exception(\" listener.getLocalPort is returning \" +\n                \t\t\"less than 0 even after \" +numRetries+\" resets\");\n              }\n              for (int i \u003d 0; i \u003c 2; i++) {\n                LOG.info(\"Retrying listener.getLocalPort()\");\n                port \u003d listener.getLocalPort();\n                if (port \u003e 0) {\n                  break;\n                }\n                Thread.sleep(200);\n              }\n              if (port \u003e 0) {\n                break;\n              }\n              LOG.info(\"Bouncing the listener\");\n              listener.close();\n              Thread.sleep(1000);\n              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n              listener.open();\n              Thread.sleep(100);\n              port \u003d listener.getLocalPort();\n            }\n          } //Workaround end\n          LOG.info(\"Jetty bound to port \" + port);\n          webServer.start();\n          // Workaround for HADOOP-6386\n          port \u003d listener.getLocalPort();\n          if (port \u003c 0) {\n            LOG.warn(\"Bounds port is \" + port + \" after webserver start\");\n            Random r \u003d new Random(1000);\n            for (int i \u003d 0; i \u003c MAX_RETRIES/2; i++) {\n              try {\n                webServer.stop();\n              } catch (Exception e) {\n                LOG.warn(\"Can\u0027t stop  web-server\", e);\n              }\n              Thread.sleep(r.nextInt());\n              \n              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n              listener.open();\n              Thread.sleep(100);\n              webServer.start();\n              LOG.info(i + \"attempts to restart webserver\");\n              port \u003d listener.getLocalPort();\n              if (port \u003e 0)\n                break;\n            }\n            if (port \u003c 0)\n              throw new Exception(\"listener.getLocalPort() is returning \" +\n                \t\t\"less than 0 even after \" +MAX_RETRIES+\" resets\");\n          }\n          // End of HADOOP-6386 workaround\n          break;\n        } catch (IOException ex) {\n          // if this is a bind exception,\n          // then try the next port number.\n          if (ex instanceof BindException) {\n            if (!findPort) {\n              throw (BindException) ex;\n            }\n          } else {\n            LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n            throw ex;\n          }\n        } catch (MultiException ex) {\n          LOG.info(\"HttpServer.start() threw a MultiException\"); \n          throw ex;\n        }\n        listener.setPort((oriPort +\u003d 1));\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "src/java/org/apache/hadoop/http/HttpServer.java",
      "extendedDetails": {}
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,71 @@\n+  public void start() throws IOException {\n+    try {\n+      int port \u003d 0;\n+      int oriPort \u003d listener.getPort(); // The original requested port\n+      while (true) {\n+        try {\n+          port \u003d webServer.getConnectors()[0].getLocalPort();\n+          LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n+          \t\t\"getLocalPort() before open() is \"+ port + \n+          \t\t\". Opening the listener on \" + oriPort);\n+          listener.open();\n+          port \u003d listener.getLocalPort();\n+          LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n+                \" webServer.getConnectors()[0].getLocalPort() returned \" +\n+                webServer.getConnectors()[0].getLocalPort());\n+          //Workaround to handle the problem reported in HADOOP-4744\n+          if (port \u003c 0) {\n+            Thread.sleep(100);\n+            int numRetries \u003d 1;\n+            while (port \u003c 0) {\n+              LOG.warn(\"listener.getLocalPort returned \" + port);\n+              if (numRetries++ \u003e MAX_RETRIES) {\n+                throw new Exception(\" listener.getLocalPort is returning \" +\n+                \t\t\"less than 0 even after \" +numRetries+\" resets\");\n+              }\n+              for (int i \u003d 0; i \u003c 2; i++) {\n+                LOG.info(\"Retrying listener.getLocalPort()\");\n+                port \u003d listener.getLocalPort();\n+                if (port \u003e 0) {\n+                  break;\n+                }\n+                Thread.sleep(200);\n+              }\n+              if (port \u003e 0) {\n+                break;\n+              }\n+              LOG.info(\"Bouncing the listener\");\n+              listener.close();\n+              Thread.sleep(1000);\n+              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n+              listener.open();\n+              Thread.sleep(100);\n+              port \u003d listener.getLocalPort();\n+            }\n+          } //Workaround end\n+          LOG.info(\"Jetty bound to port \" + port);\n+          webServer.start();\n+          break;\n+        } catch (IOException ex) {\n+          // if this is a bind exception,\n+          // then try the next port number.\n+          if (ex instanceof BindException) {\n+            if (!findPort) {\n+              throw (BindException) ex;\n+            }\n+          } else {\n+            LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n+            throw ex;\n+          }\n+        } catch (MultiException ex) {\n+          LOG.info(\"HttpServer.start() threw a MultiException\"); \n+          throw ex;\n+        }\n+        listener.setPort((oriPort +\u003d 1));\n+      }\n+    } catch (IOException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      throw new IOException(\"Problem starting http server\", e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    try {\n      int port \u003d 0;\n      int oriPort \u003d listener.getPort(); // The original requested port\n      while (true) {\n        try {\n          port \u003d webServer.getConnectors()[0].getLocalPort();\n          LOG.info(\"Port returned by webServer.getConnectors()[0].\" +\n          \t\t\"getLocalPort() before open() is \"+ port + \n          \t\t\". Opening the listener on \" + oriPort);\n          listener.open();\n          port \u003d listener.getLocalPort();\n          LOG.info(\"listener.getLocalPort() returned \" + listener.getLocalPort() + \n                \" webServer.getConnectors()[0].getLocalPort() returned \" +\n                webServer.getConnectors()[0].getLocalPort());\n          //Workaround to handle the problem reported in HADOOP-4744\n          if (port \u003c 0) {\n            Thread.sleep(100);\n            int numRetries \u003d 1;\n            while (port \u003c 0) {\n              LOG.warn(\"listener.getLocalPort returned \" + port);\n              if (numRetries++ \u003e MAX_RETRIES) {\n                throw new Exception(\" listener.getLocalPort is returning \" +\n                \t\t\"less than 0 even after \" +numRetries+\" resets\");\n              }\n              for (int i \u003d 0; i \u003c 2; i++) {\n                LOG.info(\"Retrying listener.getLocalPort()\");\n                port \u003d listener.getLocalPort();\n                if (port \u003e 0) {\n                  break;\n                }\n                Thread.sleep(200);\n              }\n              if (port \u003e 0) {\n                break;\n              }\n              LOG.info(\"Bouncing the listener\");\n              listener.close();\n              Thread.sleep(1000);\n              listener.setPort(oriPort \u003d\u003d 0 ? 0 : (oriPort +\u003d 1));\n              listener.open();\n              Thread.sleep(100);\n              port \u003d listener.getLocalPort();\n            }\n          } //Workaround end\n          LOG.info(\"Jetty bound to port \" + port);\n          webServer.start();\n          break;\n        } catch (IOException ex) {\n          // if this is a bind exception,\n          // then try the next port number.\n          if (ex instanceof BindException) {\n            if (!findPort) {\n              throw (BindException) ex;\n            }\n          } else {\n            LOG.info(\"HttpServer.start() threw a non Bind IOException\"); \n            throw ex;\n          }\n        } catch (MultiException ex) {\n          LOG.info(\"HttpServer.start() threw a MultiException\"); \n          throw ex;\n        }\n        listener.setPort((oriPort +\u003d 1));\n      }\n    } catch (IOException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new IOException(\"Problem starting http server\", e);\n    }\n  }",
      "path": "src/java/org/apache/hadoop/http/HttpServer.java"
    }
  }
}