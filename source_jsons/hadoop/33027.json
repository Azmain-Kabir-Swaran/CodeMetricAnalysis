{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AppLogAggregatorImpl.java",
  "functionName": "doContainerLogAggregation",
  "functionId": "doContainerLogAggregation___logAggregationFileController-LogAggregationFileController__appFinished-boolean__containerFinished-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
  "functionStartLine": 643,
  "functionEndLine": 680,
  "numCommitsSeen": 143,
  "timeTaken": 5431,
  "changeHistory": [
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
    "5dfc38ff57669cba9078146e91ed990a1d25a3f0",
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa",
    "40b256949ad6f6e0dbdd248f2d257b05899f4332",
    "863079bb874ba77918ca1c0741eae10e245995c8",
    "f56c65bb3eb9436b67de2df63098e26589e70e56",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc"
  ],
  "changeHistoryShort": {
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": "Ybodychange",
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f": "Ymultichange(Yparameterchange,Ybodychange)",
    "5dfc38ff57669cba9078146e91ed990a1d25a3f0": "Ymultichange(Yparameterchange,Ybodychange)",
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa": "Ybodychange",
    "40b256949ad6f6e0dbdd248f2d257b05899f4332": "Ybodychange",
    "863079bb874ba77918ca1c0741eae10e245995c8": "Ymultichange(Yparameterchange,Ybodychange)",
    "f56c65bb3eb9436b67de2df63098e26589e70e56": "Ybodychange",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8584. Several typos in Log Aggregation related classes. Contributed by Szilard Nemeth.\n",
      "commitDate": "30/07/18 10:55 AM",
      "commitName": "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "22/05/18 2:24 PM",
      "commitNameOld": "b22f56c4719e63bd4f6edc2a075e0bcdb9442255",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 68.85,
      "commitsBetweenForRepo": 474,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n     public Set\u003cPath\u003e doContainerLogAggregation(\n         LogAggregationFileController logAggregationFileController,\n         boolean appFinished, boolean containerFinished) {\n       LOG.info(\"Uploading logs for container \" + containerId\n           + \". Current good log dirs are \"\n           + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n       final LogKey logKey \u003d new LogKey(containerId);\n       final LogValue logValue \u003d\n           new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n             userUgi.getShortUserName(), logAggregationContext,\n             this.uploadedFileMeta,  retentionContext, appFinished,\n             containerFinished);\n       try {\n         logAggregationFileController.write(logKey, logValue);\n       } catch (Exception e) {\n         LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n             + \". Skipping this container.\", e);\n         return new HashSet\u003cPath\u003e();\n       }\n       this.uploadedFileMeta.addAll(logValue\n         .getCurrentUpLoadedFileMeta());\n       // if any of the previous uploaded logs have been deleted,\n       // we need to remove them from alreadyUploadedLogs\n       Iterable\u003cString\u003e mask \u003d\n           Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n             @Override\n             public boolean apply(String next) {\n               return logValue.getAllExistingFilesMeta().contains(next);\n             }\n           });\n \n       this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n \n       // need to return files uploaded or older-than-retention clean up.\n       return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n-          logValue.getObseleteRetentionLogFiles());\n+          logValue.getObsoleteRetentionLogFiles());\n \n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Set\u003cPath\u003e doContainerLogAggregation(\n        LogAggregationFileController logAggregationFileController,\n        boolean appFinished, boolean containerFinished) {\n      LOG.info(\"Uploading logs for container \" + containerId\n          + \". Current good log dirs are \"\n          + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n      final LogKey logKey \u003d new LogKey(containerId);\n      final LogValue logValue \u003d\n          new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n            userUgi.getShortUserName(), logAggregationContext,\n            this.uploadedFileMeta,  retentionContext, appFinished,\n            containerFinished);\n      try {\n        logAggregationFileController.write(logKey, logValue);\n      } catch (Exception e) {\n        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n            + \". Skipping this container.\", e);\n        return new HashSet\u003cPath\u003e();\n      }\n      this.uploadedFileMeta.addAll(logValue\n        .getCurrentUpLoadedFileMeta());\n      // if any of the previous uploaded logs have been deleted,\n      // we need to remove them from alreadyUploadedLogs\n      Iterable\u003cString\u003e mask \u003d\n          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n            @Override\n            public boolean apply(String next) {\n              return logValue.getAllExistingFilesMeta().contains(next);\n            }\n          });\n\n      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n\n      // need to return files uploaded or older-than-retention clean up.\n      return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n          logValue.getObsoleteRetentionLogFiles());\n\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6876. Create an abstract log writer for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "24/08/17 1:36 PM",
      "commitName": "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6876. Create an abstract log writer for extendability. Contributed by Xuan Gong.\n",
          "commitDate": "24/08/17 1:36 PM",
          "commitName": "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
          "commitAuthor": "Junping Du",
          "commitDateOld": "22/08/17 1:14 AM",
          "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 2.52,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,38 @@\n-    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n+    public Set\u003cPath\u003e doContainerLogAggregation(\n+        LogAggregationFileController logAggregationFileController,\n         boolean appFinished, boolean containerFinished) {\n       LOG.info(\"Uploading logs for container \" + containerId\n           + \". Current good log dirs are \"\n           + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n       final LogKey logKey \u003d new LogKey(containerId);\n       final LogValue logValue \u003d\n           new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n             userUgi.getShortUserName(), logAggregationContext,\n             this.uploadedFileMeta,  retentionContext, appFinished,\n             containerFinished);\n       try {\n-        writer.append(logKey, logValue);\n+        logAggregationFileController.write(logKey, logValue);\n       } catch (Exception e) {\n         LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n             + \". Skipping this container.\", e);\n         return new HashSet\u003cPath\u003e();\n       }\n       this.uploadedFileMeta.addAll(logValue\n         .getCurrentUpLoadedFileMeta());\n       // if any of the previous uploaded logs have been deleted,\n       // we need to remove them from alreadyUploadedLogs\n       Iterable\u003cString\u003e mask \u003d\n           Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n             @Override\n             public boolean apply(String next) {\n               return logValue.getAllExistingFilesMeta().contains(next);\n             }\n           });\n \n       this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n \n       // need to return files uploaded or older-than-retention clean up.\n       return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n           logValue.getObseleteRetentionLogFiles());\n \n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Set\u003cPath\u003e doContainerLogAggregation(\n        LogAggregationFileController logAggregationFileController,\n        boolean appFinished, boolean containerFinished) {\n      LOG.info(\"Uploading logs for container \" + containerId\n          + \". Current good log dirs are \"\n          + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n      final LogKey logKey \u003d new LogKey(containerId);\n      final LogValue logValue \u003d\n          new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n            userUgi.getShortUserName(), logAggregationContext,\n            this.uploadedFileMeta,  retentionContext, appFinished,\n            containerFinished);\n      try {\n        logAggregationFileController.write(logKey, logValue);\n      } catch (Exception e) {\n        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n            + \". Skipping this container.\", e);\n        return new HashSet\u003cPath\u003e();\n      }\n      this.uploadedFileMeta.addAll(logValue\n        .getCurrentUpLoadedFileMeta());\n      // if any of the previous uploaded logs have been deleted,\n      // we need to remove them from alreadyUploadedLogs\n      Iterable\u003cString\u003e mask \u003d\n          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n            @Override\n            public boolean apply(String next) {\n              return logValue.getAllExistingFilesMeta().contains(next);\n            }\n          });\n\n      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n\n      // need to return files uploaded or older-than-retention clean up.\n      return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n          logValue.getObseleteRetentionLogFiles());\n\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "[writer-LogWriter, appFinished-boolean, containerFinished-boolean]",
            "newValue": "[logAggregationFileController-LogAggregationFileController, appFinished-boolean, containerFinished-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6876. Create an abstract log writer for extendability. Contributed by Xuan Gong.\n",
          "commitDate": "24/08/17 1:36 PM",
          "commitName": "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
          "commitAuthor": "Junping Du",
          "commitDateOld": "22/08/17 1:14 AM",
          "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 2.52,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,38 @@\n-    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n+    public Set\u003cPath\u003e doContainerLogAggregation(\n+        LogAggregationFileController logAggregationFileController,\n         boolean appFinished, boolean containerFinished) {\n       LOG.info(\"Uploading logs for container \" + containerId\n           + \". Current good log dirs are \"\n           + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n       final LogKey logKey \u003d new LogKey(containerId);\n       final LogValue logValue \u003d\n           new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n             userUgi.getShortUserName(), logAggregationContext,\n             this.uploadedFileMeta,  retentionContext, appFinished,\n             containerFinished);\n       try {\n-        writer.append(logKey, logValue);\n+        logAggregationFileController.write(logKey, logValue);\n       } catch (Exception e) {\n         LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n             + \". Skipping this container.\", e);\n         return new HashSet\u003cPath\u003e();\n       }\n       this.uploadedFileMeta.addAll(logValue\n         .getCurrentUpLoadedFileMeta());\n       // if any of the previous uploaded logs have been deleted,\n       // we need to remove them from alreadyUploadedLogs\n       Iterable\u003cString\u003e mask \u003d\n           Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n             @Override\n             public boolean apply(String next) {\n               return logValue.getAllExistingFilesMeta().contains(next);\n             }\n           });\n \n       this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n \n       // need to return files uploaded or older-than-retention clean up.\n       return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n           logValue.getObseleteRetentionLogFiles());\n \n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Set\u003cPath\u003e doContainerLogAggregation(\n        LogAggregationFileController logAggregationFileController,\n        boolean appFinished, boolean containerFinished) {\n      LOG.info(\"Uploading logs for container \" + containerId\n          + \". Current good log dirs are \"\n          + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n      final LogKey logKey \u003d new LogKey(containerId);\n      final LogValue logValue \u003d\n          new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n            userUgi.getShortUserName(), logAggregationContext,\n            this.uploadedFileMeta,  retentionContext, appFinished,\n            containerFinished);\n      try {\n        logAggregationFileController.write(logKey, logValue);\n      } catch (Exception e) {\n        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n            + \". Skipping this container.\", e);\n        return new HashSet\u003cPath\u003e();\n      }\n      this.uploadedFileMeta.addAll(logValue\n        .getCurrentUpLoadedFileMeta());\n      // if any of the previous uploaded logs have been deleted,\n      // we need to remove them from alreadyUploadedLogs\n      Iterable\u003cString\u003e mask \u003d\n          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n            @Override\n            public boolean apply(String next) {\n              return logValue.getAllExistingFilesMeta().contains(next);\n            }\n          });\n\n      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n\n      // need to return files uploaded or older-than-retention clean up.\n      return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n          logValue.getObseleteRetentionLogFiles());\n\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "5dfc38ff57669cba9078146e91ed990a1d25a3f0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5237. Fix missing log files issue in rolling log aggregation. Contributed by Xuan Gong.\n",
      "commitDate": "15/06/16 4:17 PM",
      "commitName": "5dfc38ff57669cba9078146e91ed990a1d25a3f0",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5237. Fix missing log files issue in rolling log aggregation. Contributed by Xuan Gong.\n",
          "commitDate": "15/06/16 4:17 PM",
          "commitName": "5dfc38ff57669cba9078146e91ed990a1d25a3f0",
          "commitAuthor": "Junping Du",
          "commitDateOld": "14/06/16 3:06 PM",
          "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 1.05,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,37 @@\n     public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n-        boolean appFinished) {\n+        boolean appFinished, boolean containerFinished) {\n       LOG.info(\"Uploading logs for container \" + containerId\n           + \". Current good log dirs are \"\n           + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n       final LogKey logKey \u003d new LogKey(containerId);\n       final LogValue logValue \u003d\n           new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n             userUgi.getShortUserName(), logAggregationContext,\n-            this.uploadedFileMeta,  retentionContext, appFinished);\n+            this.uploadedFileMeta,  retentionContext, appFinished,\n+            containerFinished);\n       try {\n         writer.append(logKey, logValue);\n       } catch (Exception e) {\n         LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n             + \". Skipping this container.\", e);\n         return new HashSet\u003cPath\u003e();\n       }\n       this.uploadedFileMeta.addAll(logValue\n         .getCurrentUpLoadedFileMeta());\n       // if any of the previous uploaded logs have been deleted,\n       // we need to remove them from alreadyUploadedLogs\n       Iterable\u003cString\u003e mask \u003d\n           Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n             @Override\n             public boolean apply(String next) {\n               return logValue.getAllExistingFilesMeta().contains(next);\n             }\n           });\n \n       this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n \n       // need to return files uploaded or older-than-retention clean up.\n       return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n           logValue.getObseleteRetentionLogFiles());\n \n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n        boolean appFinished, boolean containerFinished) {\n      LOG.info(\"Uploading logs for container \" + containerId\n          + \". Current good log dirs are \"\n          + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n      final LogKey logKey \u003d new LogKey(containerId);\n      final LogValue logValue \u003d\n          new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n            userUgi.getShortUserName(), logAggregationContext,\n            this.uploadedFileMeta,  retentionContext, appFinished,\n            containerFinished);\n      try {\n        writer.append(logKey, logValue);\n      } catch (Exception e) {\n        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n            + \". Skipping this container.\", e);\n        return new HashSet\u003cPath\u003e();\n      }\n      this.uploadedFileMeta.addAll(logValue\n        .getCurrentUpLoadedFileMeta());\n      // if any of the previous uploaded logs have been deleted,\n      // we need to remove them from alreadyUploadedLogs\n      Iterable\u003cString\u003e mask \u003d\n          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n            @Override\n            public boolean apply(String next) {\n              return logValue.getAllExistingFilesMeta().contains(next);\n            }\n          });\n\n      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n\n      // need to return files uploaded or older-than-retention clean up.\n      return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n          logValue.getObseleteRetentionLogFiles());\n\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "[writer-LogWriter, appFinished-boolean]",
            "newValue": "[writer-LogWriter, appFinished-boolean, containerFinished-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5237. Fix missing log files issue in rolling log aggregation. Contributed by Xuan Gong.\n",
          "commitDate": "15/06/16 4:17 PM",
          "commitName": "5dfc38ff57669cba9078146e91ed990a1d25a3f0",
          "commitAuthor": "Junping Du",
          "commitDateOld": "14/06/16 3:06 PM",
          "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 1.05,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,37 @@\n     public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n-        boolean appFinished) {\n+        boolean appFinished, boolean containerFinished) {\n       LOG.info(\"Uploading logs for container \" + containerId\n           + \". Current good log dirs are \"\n           + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n       final LogKey logKey \u003d new LogKey(containerId);\n       final LogValue logValue \u003d\n           new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n             userUgi.getShortUserName(), logAggregationContext,\n-            this.uploadedFileMeta,  retentionContext, appFinished);\n+            this.uploadedFileMeta,  retentionContext, appFinished,\n+            containerFinished);\n       try {\n         writer.append(logKey, logValue);\n       } catch (Exception e) {\n         LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n             + \". Skipping this container.\", e);\n         return new HashSet\u003cPath\u003e();\n       }\n       this.uploadedFileMeta.addAll(logValue\n         .getCurrentUpLoadedFileMeta());\n       // if any of the previous uploaded logs have been deleted,\n       // we need to remove them from alreadyUploadedLogs\n       Iterable\u003cString\u003e mask \u003d\n           Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n             @Override\n             public boolean apply(String next) {\n               return logValue.getAllExistingFilesMeta().contains(next);\n             }\n           });\n \n       this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n \n       // need to return files uploaded or older-than-retention clean up.\n       return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n           logValue.getObseleteRetentionLogFiles());\n \n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n        boolean appFinished, boolean containerFinished) {\n      LOG.info(\"Uploading logs for container \" + containerId\n          + \". Current good log dirs are \"\n          + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n      final LogKey logKey \u003d new LogKey(containerId);\n      final LogValue logValue \u003d\n          new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n            userUgi.getShortUserName(), logAggregationContext,\n            this.uploadedFileMeta,  retentionContext, appFinished,\n            containerFinished);\n      try {\n        writer.append(logKey, logValue);\n      } catch (Exception e) {\n        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n            + \". Skipping this container.\", e);\n        return new HashSet\u003cPath\u003e();\n      }\n      this.uploadedFileMeta.addAll(logValue\n        .getCurrentUpLoadedFileMeta());\n      // if any of the previous uploaded logs have been deleted,\n      // we need to remove them from alreadyUploadedLogs\n      Iterable\u003cString\u003e mask \u003d\n          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n            @Override\n            public boolean apply(String next) {\n              return logValue.getAllExistingFilesMeta().contains(next);\n            }\n          });\n\n      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n\n      // need to return files uploaded or older-than-retention clean up.\n      return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n          logValue.getObseleteRetentionLogFiles());\n\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4766. NM should not aggregate logs older than the retention policy (haibochen via rkanter)\n",
      "commitDate": "25/05/16 10:25 AM",
      "commitName": "e07519b8dbb96d73c48e910a4de12563c5c2f8aa",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "22/05/16 4:04 PM",
      "commitNameOld": "6161d9ba5230f553db5f5490dce67e2afd1e29ca",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,36 @@\n     public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n         boolean appFinished) {\n       LOG.info(\"Uploading logs for container \" + containerId\n           + \". Current good log dirs are \"\n           + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n       final LogKey logKey \u003d new LogKey(containerId);\n       final LogValue logValue \u003d\n           new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n             userUgi.getShortUserName(), logAggregationContext,\n-            this.uploadedFileMeta, appFinished);\n+            this.uploadedFileMeta,  retentionContext, appFinished);\n       try {\n         writer.append(logKey, logValue);\n       } catch (Exception e) {\n         LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n             + \". Skipping this container.\", e);\n         return new HashSet\u003cPath\u003e();\n       }\n       this.uploadedFileMeta.addAll(logValue\n         .getCurrentUpLoadedFileMeta());\n       // if any of the previous uploaded logs have been deleted,\n       // we need to remove them from alreadyUploadedLogs\n       Iterable\u003cString\u003e mask \u003d\n           Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n             @Override\n             public boolean apply(String next) {\n               return logValue.getAllExistingFilesMeta().contains(next);\n             }\n           });\n \n       this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n-      return logValue.getCurrentUpLoadedFilesPath();\n+\n+      // need to return files uploaded or older-than-retention clean up.\n+      return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n+          logValue.getObseleteRetentionLogFiles());\n+\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n        boolean appFinished) {\n      LOG.info(\"Uploading logs for container \" + containerId\n          + \". Current good log dirs are \"\n          + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n      final LogKey logKey \u003d new LogKey(containerId);\n      final LogValue logValue \u003d\n          new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n            userUgi.getShortUserName(), logAggregationContext,\n            this.uploadedFileMeta,  retentionContext, appFinished);\n      try {\n        writer.append(logKey, logValue);\n      } catch (Exception e) {\n        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n            + \". Skipping this container.\", e);\n        return new HashSet\u003cPath\u003e();\n      }\n      this.uploadedFileMeta.addAll(logValue\n        .getCurrentUpLoadedFileMeta());\n      // if any of the previous uploaded logs have been deleted,\n      // we need to remove them from alreadyUploadedLogs\n      Iterable\u003cString\u003e mask \u003d\n          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n            @Override\n            public boolean apply(String next) {\n              return logValue.getAllExistingFilesMeta().contains(next);\n            }\n          });\n\n      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n\n      // need to return files uploaded or older-than-retention clean up.\n      return Sets.union(logValue.getCurrentUpLoadedFilesPath(),\n          logValue.getObseleteRetentionLogFiles());\n\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "40b256949ad6f6e0dbdd248f2d257b05899f4332": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3850. NM fails to read files from full disks which can lead to container logs being lost and other issues. Contributed by Varun Saxena\n",
      "commitDate": "26/06/15 8:47 AM",
      "commitName": "40b256949ad6f6e0dbdd248f2d257b05899f4332",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "15/05/15 6:39 AM",
      "commitNameOld": "03a293aed6de101b0cae1a294f506903addcaa75",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 42.09,
      "commitsBetweenForRepo": 291,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n     public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n         boolean appFinished) {\n       LOG.info(\"Uploading logs for container \" + containerId\n           + \". Current good log dirs are \"\n-          + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n+          + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n       final LogKey logKey \u003d new LogKey(containerId);\n       final LogValue logValue \u003d\n-          new LogValue(dirsHandler.getLogDirs(), containerId,\n+          new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n             userUgi.getShortUserName(), logAggregationContext,\n             this.uploadedFileMeta, appFinished);\n       try {\n         writer.append(logKey, logValue);\n       } catch (Exception e) {\n         LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n             + \". Skipping this container.\", e);\n         return new HashSet\u003cPath\u003e();\n       }\n       this.uploadedFileMeta.addAll(logValue\n         .getCurrentUpLoadedFileMeta());\n       // if any of the previous uploaded logs have been deleted,\n       // we need to remove them from alreadyUploadedLogs\n       Iterable\u003cString\u003e mask \u003d\n           Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n             @Override\n             public boolean apply(String next) {\n               return logValue.getAllExistingFilesMeta().contains(next);\n             }\n           });\n \n       this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n       return logValue.getCurrentUpLoadedFilesPath();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n        boolean appFinished) {\n      LOG.info(\"Uploading logs for container \" + containerId\n          + \". Current good log dirs are \"\n          + StringUtils.join(\",\", dirsHandler.getLogDirsForRead()));\n      final LogKey logKey \u003d new LogKey(containerId);\n      final LogValue logValue \u003d\n          new LogValue(dirsHandler.getLogDirsForRead(), containerId,\n            userUgi.getShortUserName(), logAggregationContext,\n            this.uploadedFileMeta, appFinished);\n      try {\n        writer.append(logKey, logValue);\n      } catch (Exception e) {\n        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n            + \". Skipping this container.\", e);\n        return new HashSet\u003cPath\u003e();\n      }\n      this.uploadedFileMeta.addAll(logValue\n        .getCurrentUpLoadedFileMeta());\n      // if any of the previous uploaded logs have been deleted,\n      // we need to remove them from alreadyUploadedLogs\n      Iterable\u003cString\u003e mask \u003d\n          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n            @Override\n            public boolean apply(String next) {\n              return logValue.getAllExistingFilesMeta().contains(next);\n            }\n          });\n\n      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n      return logValue.getCurrentUpLoadedFilesPath();\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "863079bb874ba77918ca1c0741eae10e245995c8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3154. Added additional APIs in LogAggregationContext to avoid aggregating running logs of application when rolling is enabled. Contributed by Xuan Gong.\n",
      "commitDate": "12/03/15 1:32 PM",
      "commitName": "863079bb874ba77918ca1c0741eae10e245995c8",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3154. Added additional APIs in LogAggregationContext to avoid aggregating running logs of application when rolling is enabled. Contributed by Xuan Gong.\n",
          "commitDate": "12/03/15 1:32 PM",
          "commitName": "863079bb874ba77918ca1c0741eae10e245995c8",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "20/02/15 2:02 PM",
          "commitNameOld": "f56c65bb3eb9436b67de2df63098e26589e70e56",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 19.94,
          "commitsBetweenForRepo": 149,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,32 @@\n-    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer) {\n+    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n+        boolean appFinished) {\n       LOG.info(\"Uploading logs for container \" + containerId\n           + \". Current good log dirs are \"\n           + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n       final LogKey logKey \u003d new LogKey(containerId);\n       final LogValue logValue \u003d\n           new LogValue(dirsHandler.getLogDirs(), containerId,\n             userUgi.getShortUserName(), logAggregationContext,\n-            this.uploadedFileMeta);\n+            this.uploadedFileMeta, appFinished);\n       try {\n         writer.append(logKey, logValue);\n       } catch (Exception e) {\n         LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n             + \". Skipping this container.\", e);\n         return new HashSet\u003cPath\u003e();\n       }\n       this.uploadedFileMeta.addAll(logValue\n         .getCurrentUpLoadedFileMeta());\n       // if any of the previous uploaded logs have been deleted,\n       // we need to remove them from alreadyUploadedLogs\n       Iterable\u003cString\u003e mask \u003d\n           Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n             @Override\n             public boolean apply(String next) {\n               return logValue.getAllExistingFilesMeta().contains(next);\n             }\n           });\n \n       this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n       return logValue.getCurrentUpLoadedFilesPath();\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n        boolean appFinished) {\n      LOG.info(\"Uploading logs for container \" + containerId\n          + \". Current good log dirs are \"\n          + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n      final LogKey logKey \u003d new LogKey(containerId);\n      final LogValue logValue \u003d\n          new LogValue(dirsHandler.getLogDirs(), containerId,\n            userUgi.getShortUserName(), logAggregationContext,\n            this.uploadedFileMeta, appFinished);\n      try {\n        writer.append(logKey, logValue);\n      } catch (Exception e) {\n        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n            + \". Skipping this container.\", e);\n        return new HashSet\u003cPath\u003e();\n      }\n      this.uploadedFileMeta.addAll(logValue\n        .getCurrentUpLoadedFileMeta());\n      // if any of the previous uploaded logs have been deleted,\n      // we need to remove them from alreadyUploadedLogs\n      Iterable\u003cString\u003e mask \u003d\n          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n            @Override\n            public boolean apply(String next) {\n              return logValue.getAllExistingFilesMeta().contains(next);\n            }\n          });\n\n      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n      return logValue.getCurrentUpLoadedFilesPath();\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "[writer-LogWriter]",
            "newValue": "[writer-LogWriter, appFinished-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3154. Added additional APIs in LogAggregationContext to avoid aggregating running logs of application when rolling is enabled. Contributed by Xuan Gong.\n",
          "commitDate": "12/03/15 1:32 PM",
          "commitName": "863079bb874ba77918ca1c0741eae10e245995c8",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "20/02/15 2:02 PM",
          "commitNameOld": "f56c65bb3eb9436b67de2df63098e26589e70e56",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 19.94,
          "commitsBetweenForRepo": 149,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,32 @@\n-    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer) {\n+    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n+        boolean appFinished) {\n       LOG.info(\"Uploading logs for container \" + containerId\n           + \". Current good log dirs are \"\n           + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n       final LogKey logKey \u003d new LogKey(containerId);\n       final LogValue logValue \u003d\n           new LogValue(dirsHandler.getLogDirs(), containerId,\n             userUgi.getShortUserName(), logAggregationContext,\n-            this.uploadedFileMeta);\n+            this.uploadedFileMeta, appFinished);\n       try {\n         writer.append(logKey, logValue);\n       } catch (Exception e) {\n         LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n             + \". Skipping this container.\", e);\n         return new HashSet\u003cPath\u003e();\n       }\n       this.uploadedFileMeta.addAll(logValue\n         .getCurrentUpLoadedFileMeta());\n       // if any of the previous uploaded logs have been deleted,\n       // we need to remove them from alreadyUploadedLogs\n       Iterable\u003cString\u003e mask \u003d\n           Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n             @Override\n             public boolean apply(String next) {\n               return logValue.getAllExistingFilesMeta().contains(next);\n             }\n           });\n \n       this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n       return logValue.getCurrentUpLoadedFilesPath();\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer,\n        boolean appFinished) {\n      LOG.info(\"Uploading logs for container \" + containerId\n          + \". Current good log dirs are \"\n          + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n      final LogKey logKey \u003d new LogKey(containerId);\n      final LogValue logValue \u003d\n          new LogValue(dirsHandler.getLogDirs(), containerId,\n            userUgi.getShortUserName(), logAggregationContext,\n            this.uploadedFileMeta, appFinished);\n      try {\n        writer.append(logKey, logValue);\n      } catch (Exception e) {\n        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n            + \". Skipping this container.\", e);\n        return new HashSet\u003cPath\u003e();\n      }\n      this.uploadedFileMeta.addAll(logValue\n        .getCurrentUpLoadedFileMeta());\n      // if any of the previous uploaded logs have been deleted,\n      // we need to remove them from alreadyUploadedLogs\n      Iterable\u003cString\u003e mask \u003d\n          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n            @Override\n            public boolean apply(String next) {\n              return logValue.getAllExistingFilesMeta().contains(next);\n            }\n          });\n\n      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n      return logValue.getCurrentUpLoadedFilesPath();\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "f56c65bb3eb9436b67de2df63098e26589e70e56": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3237. AppLogAggregatorImpl fails to log error cause. Contributed by\nRushabh S Shah\n",
      "commitDate": "20/02/15 2:02 PM",
      "commitName": "f56c65bb3eb9436b67de2df63098e26589e70e56",
      "commitAuthor": "Xuan",
      "commitDateOld": "15/02/15 6:46 AM",
      "commitNameOld": "ab0b958a522d502426b91b6e4ab6dd29caccc372",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 5.3,
      "commitsBetweenForRepo": 54,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n     public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer) {\n       LOG.info(\"Uploading logs for container \" + containerId\n           + \". Current good log dirs are \"\n           + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n       final LogKey logKey \u003d new LogKey(containerId);\n       final LogValue logValue \u003d\n           new LogValue(dirsHandler.getLogDirs(), containerId,\n             userUgi.getShortUserName(), logAggregationContext,\n             this.uploadedFileMeta);\n       try {\n         writer.append(logKey, logValue);\n       } catch (Exception e) {\n         LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n-            + \". Skipping this container.\");\n+            + \". Skipping this container.\", e);\n         return new HashSet\u003cPath\u003e();\n       }\n       this.uploadedFileMeta.addAll(logValue\n         .getCurrentUpLoadedFileMeta());\n       // if any of the previous uploaded logs have been deleted,\n       // we need to remove them from alreadyUploadedLogs\n       Iterable\u003cString\u003e mask \u003d\n           Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n             @Override\n             public boolean apply(String next) {\n               return logValue.getAllExistingFilesMeta().contains(next);\n             }\n           });\n \n       this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n       return logValue.getCurrentUpLoadedFilesPath();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer) {\n      LOG.info(\"Uploading logs for container \" + containerId\n          + \". Current good log dirs are \"\n          + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n      final LogKey logKey \u003d new LogKey(containerId);\n      final LogValue logValue \u003d\n          new LogValue(dirsHandler.getLogDirs(), containerId,\n            userUgi.getShortUserName(), logAggregationContext,\n            this.uploadedFileMeta);\n      try {\n        writer.append(logKey, logValue);\n      } catch (Exception e) {\n        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n            + \". Skipping this container.\", e);\n        return new HashSet\u003cPath\u003e();\n      }\n      this.uploadedFileMeta.addAll(logValue\n        .getCurrentUpLoadedFileMeta());\n      // if any of the previous uploaded logs have been deleted,\n      // we need to remove them from alreadyUploadedLogs\n      Iterable\u003cString\u003e mask \u003d\n          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n            @Override\n            public boolean apply(String next) {\n              return logValue.getAllExistingFilesMeta().contains(next);\n            }\n          });\n\n      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n      return logValue.getCurrentUpLoadedFilesPath();\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
      "commitDate": "03/10/14 12:15 PM",
      "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,31 @@\n+    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer) {\n+      LOG.info(\"Uploading logs for container \" + containerId\n+          + \". Current good log dirs are \"\n+          + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n+      final LogKey logKey \u003d new LogKey(containerId);\n+      final LogValue logValue \u003d\n+          new LogValue(dirsHandler.getLogDirs(), containerId,\n+            userUgi.getShortUserName(), logAggregationContext,\n+            this.uploadedFileMeta);\n+      try {\n+        writer.append(logKey, logValue);\n+      } catch (Exception e) {\n+        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n+            + \". Skipping this container.\");\n+        return new HashSet\u003cPath\u003e();\n+      }\n+      this.uploadedFileMeta.addAll(logValue\n+        .getCurrentUpLoadedFileMeta());\n+      // if any of the previous uploaded logs have been deleted,\n+      // we need to remove them from alreadyUploadedLogs\n+      Iterable\u003cString\u003e mask \u003d\n+          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n+            @Override\n+            public boolean apply(String next) {\n+              return logValue.getAllExistingFilesMeta().contains(next);\n+            }\n+          });\n+\n+      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n+      return logValue.getCurrentUpLoadedFilesPath();\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public Set\u003cPath\u003e doContainerLogAggregation(LogWriter writer) {\n      LOG.info(\"Uploading logs for container \" + containerId\n          + \". Current good log dirs are \"\n          + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n      final LogKey logKey \u003d new LogKey(containerId);\n      final LogValue logValue \u003d\n          new LogValue(dirsHandler.getLogDirs(), containerId,\n            userUgi.getShortUserName(), logAggregationContext,\n            this.uploadedFileMeta);\n      try {\n        writer.append(logKey, logValue);\n      } catch (Exception e) {\n        LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n            + \". Skipping this container.\");\n        return new HashSet\u003cPath\u003e();\n      }\n      this.uploadedFileMeta.addAll(logValue\n        .getCurrentUpLoadedFileMeta());\n      // if any of the previous uploaded logs have been deleted,\n      // we need to remove them from alreadyUploadedLogs\n      Iterable\u003cString\u003e mask \u003d\n          Iterables.filter(uploadedFileMeta, new Predicate\u003cString\u003e() {\n            @Override\n            public boolean apply(String next) {\n              return logValue.getAllExistingFilesMeta().contains(next);\n            }\n          });\n\n      this.uploadedFileMeta \u003d Sets.newHashSet(mask);\n      return logValue.getCurrentUpLoadedFilesPath();\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java"
    }
  }
}