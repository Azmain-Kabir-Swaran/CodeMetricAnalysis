{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OfflineEditsXmlLoader.java",
  "functionName": "endElement",
  "functionId": "endElement___uri-String__name-String__qName-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineEditsViewer/OfflineEditsXmlLoader.java",
  "functionStartLine": 179,
  "functionEndLine": 257,
  "numCommitsSeen": 8,
  "timeTaken": 1485,
  "changeHistory": [
    "c7f81dad30c391822eed7273278cf5885fa59264",
    "7e2d98da4080d40f3f772c87ef6619628c90a922",
    "706394d03992b394e9f907aff2155df493e4ea4e",
    "4f6e0a5a659064e0af3bec315e7c25d5e43b47f5"
  ],
  "changeHistoryShort": {
    "c7f81dad30c391822eed7273278cf5885fa59264": "Ybodychange",
    "7e2d98da4080d40f3f772c87ef6619628c90a922": "Ybodychange",
    "706394d03992b394e9f907aff2155df493e4ea4e": "Ybodychange",
    "4f6e0a5a659064e0af3bec315e7c25d5e43b47f5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c7f81dad30c391822eed7273278cf5885fa59264": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7309. XMLUtils.mangleXmlString doesn\u0027t seem to handle less than sign. (Colin Patrick McCabe via raviprak)\n",
      "commitDate": "31/10/14 11:22 AM",
      "commitName": "c7f81dad30c391822eed7273278cf5885fa59264",
      "commitAuthor": "Ravi Prakash",
      "commitDateOld": "25/02/13 4:44 PM",
      "commitNameOld": "7e2d98da4080d40f3f772c87ef6619628c90a922",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 612.73,
      "commitsBetweenForRepo": 4387,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   public void endElement (String uri, String name, String qName) {\n-    String str \u003d XMLUtils.unmangleXmlString(cbuf.toString()).trim();\n+    String str \u003d XMLUtils.unmangleXmlString(cbuf.toString(), false).trim();\n     cbuf \u003d new StringBuffer();\n     switch (state) {\n     case EXPECT_EDITS_TAG:\n       throw new InvalidXmlException(\"expected \u003cEDITS/\u003e\");\n     case EXPECT_VERSION:\n       if (!name.equals(\"EDITS_VERSION\")) {\n         throw new InvalidXmlException(\"expected \u003c/EDITS_VERSION\u003e\");\n       }\n       try {\n         int version \u003d Integer.parseInt(str);\n         visitor.start(version);\n       } catch (IOException e) {\n         // Can\u0027t throw IOException from a SAX method, sigh.\n         throw new RuntimeException(e);\n       }\n       state \u003d ParseState.EXPECT_RECORD;\n       break;\n     case EXPECT_RECORD:\n       if (name.equals(\"EDITS\")) {\n         state \u003d ParseState.EXPECT_END;\n       } else if (!name.equals(\"RECORD\")) {\n         throw new InvalidXmlException(\"expected \u003c/EDITS\u003e or \u003c/RECORD\u003e\");\n       }\n       break;\n     case EXPECT_OPCODE:\n       if (!name.equals(\"OPCODE\")) {\n         throw new InvalidXmlException(\"expected \u003c/OPCODE\u003e\");\n       }\n       opCode \u003d FSEditLogOpCodes.valueOf(str);\n       state \u003d ParseState.EXPECT_DATA;\n       break;\n     case EXPECT_DATA:\n       throw new InvalidXmlException(\"expected \u003cDATA/\u003e\");\n     case HANDLE_DATA:\n       stanza.setValue(str);\n       if (stanzaStack.empty()) {\n         if (!name.equals(\"DATA\")) {\n           throw new InvalidXmlException(\"expected \u003c/DATA\u003e\");\n         }\n         state \u003d ParseState.EXPECT_RECORD;\n         FSEditLogOp op \u003d opCache.get(opCode);\n         opCode \u003d null;\n         try {\n           op.decodeXml(stanza);\n           stanza \u003d null;\n         } finally {\n           if (stanza !\u003d null) {\n             System.err.println(\"fromXml error decoding opcode \" + opCode +\n                 \"\\n\" + stanza.toString());\n             stanza \u003d null;\n           }\n         }\n         if (fixTxIds) {\n           if (nextTxId \u003c\u003d 0) {\n             nextTxId \u003d op.getTransactionId();\n             if (nextTxId \u003c\u003d 0) {\n               nextTxId \u003d 1;\n             }\n           }\n           op.setTransactionId(nextTxId);\n           nextTxId++;\n         }\n         try {\n           visitor.visitOp(op);\n         } catch (IOException e) {\n           // Can\u0027t throw IOException from a SAX method, sigh.\n           throw new RuntimeException(e);\n         }\n         state \u003d ParseState.EXPECT_RECORD;\n       } else {\n         stanza \u003d stanzaStack.pop();\n       }\n       break;\n     case EXPECT_END:\n       throw new InvalidXmlException(\"not expecting anything after \u003c/EDITS\u003e\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void endElement (String uri, String name, String qName) {\n    String str \u003d XMLUtils.unmangleXmlString(cbuf.toString(), false).trim();\n    cbuf \u003d new StringBuffer();\n    switch (state) {\n    case EXPECT_EDITS_TAG:\n      throw new InvalidXmlException(\"expected \u003cEDITS/\u003e\");\n    case EXPECT_VERSION:\n      if (!name.equals(\"EDITS_VERSION\")) {\n        throw new InvalidXmlException(\"expected \u003c/EDITS_VERSION\u003e\");\n      }\n      try {\n        int version \u003d Integer.parseInt(str);\n        visitor.start(version);\n      } catch (IOException e) {\n        // Can\u0027t throw IOException from a SAX method, sigh.\n        throw new RuntimeException(e);\n      }\n      state \u003d ParseState.EXPECT_RECORD;\n      break;\n    case EXPECT_RECORD:\n      if (name.equals(\"EDITS\")) {\n        state \u003d ParseState.EXPECT_END;\n      } else if (!name.equals(\"RECORD\")) {\n        throw new InvalidXmlException(\"expected \u003c/EDITS\u003e or \u003c/RECORD\u003e\");\n      }\n      break;\n    case EXPECT_OPCODE:\n      if (!name.equals(\"OPCODE\")) {\n        throw new InvalidXmlException(\"expected \u003c/OPCODE\u003e\");\n      }\n      opCode \u003d FSEditLogOpCodes.valueOf(str);\n      state \u003d ParseState.EXPECT_DATA;\n      break;\n    case EXPECT_DATA:\n      throw new InvalidXmlException(\"expected \u003cDATA/\u003e\");\n    case HANDLE_DATA:\n      stanza.setValue(str);\n      if (stanzaStack.empty()) {\n        if (!name.equals(\"DATA\")) {\n          throw new InvalidXmlException(\"expected \u003c/DATA\u003e\");\n        }\n        state \u003d ParseState.EXPECT_RECORD;\n        FSEditLogOp op \u003d opCache.get(opCode);\n        opCode \u003d null;\n        try {\n          op.decodeXml(stanza);\n          stanza \u003d null;\n        } finally {\n          if (stanza !\u003d null) {\n            System.err.println(\"fromXml error decoding opcode \" + opCode +\n                \"\\n\" + stanza.toString());\n            stanza \u003d null;\n          }\n        }\n        if (fixTxIds) {\n          if (nextTxId \u003c\u003d 0) {\n            nextTxId \u003d op.getTransactionId();\n            if (nextTxId \u003c\u003d 0) {\n              nextTxId \u003d 1;\n            }\n          }\n          op.setTransactionId(nextTxId);\n          nextTxId++;\n        }\n        try {\n          visitor.visitOp(op);\n        } catch (IOException e) {\n          // Can\u0027t throw IOException from a SAX method, sigh.\n          throw new RuntimeException(e);\n        }\n        state \u003d ParseState.EXPECT_RECORD;\n      } else {\n        stanza \u003d stanzaStack.pop();\n      }\n      break;\n    case EXPECT_END:\n      throw new InvalidXmlException(\"not expecting anything after \u003c/EDITS\u003e\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineEditsViewer/OfflineEditsXmlLoader.java",
      "extendedDetails": {}
    },
    "7e2d98da4080d40f3f772c87ef6619628c90a922": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4235. When outputting XML, OfflineEditsViewer can\u0027t handle some edits containing non-ASCII strings. Contributed by Colin Patrick McCabe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1449984 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/13 4:44 PM",
      "commitName": "7e2d98da4080d40f3f772c87ef6619628c90a922",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "09/01/13 6:30 PM",
      "commitNameOld": "6449f524552f8c24d20b314ad21f6c579fa08e85",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 46.93,
      "commitsBetweenForRepo": 194,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   public void endElement (String uri, String name, String qName) {\n-    String str \u003d cbuf.toString().trim();\n+    String str \u003d XMLUtils.unmangleXmlString(cbuf.toString()).trim();\n     cbuf \u003d new StringBuffer();\n     switch (state) {\n     case EXPECT_EDITS_TAG:\n       throw new InvalidXmlException(\"expected \u003cEDITS/\u003e\");\n     case EXPECT_VERSION:\n       if (!name.equals(\"EDITS_VERSION\")) {\n         throw new InvalidXmlException(\"expected \u003c/EDITS_VERSION\u003e\");\n       }\n       try {\n         int version \u003d Integer.parseInt(str);\n         visitor.start(version);\n       } catch (IOException e) {\n         // Can\u0027t throw IOException from a SAX method, sigh.\n         throw new RuntimeException(e);\n       }\n       state \u003d ParseState.EXPECT_RECORD;\n       break;\n     case EXPECT_RECORD:\n       if (name.equals(\"EDITS\")) {\n         state \u003d ParseState.EXPECT_END;\n       } else if (!name.equals(\"RECORD\")) {\n         throw new InvalidXmlException(\"expected \u003c/EDITS\u003e or \u003c/RECORD\u003e\");\n       }\n       break;\n     case EXPECT_OPCODE:\n       if (!name.equals(\"OPCODE\")) {\n         throw new InvalidXmlException(\"expected \u003c/OPCODE\u003e\");\n       }\n       opCode \u003d FSEditLogOpCodes.valueOf(str);\n       state \u003d ParseState.EXPECT_DATA;\n       break;\n     case EXPECT_DATA:\n       throw new InvalidXmlException(\"expected \u003cDATA/\u003e\");\n     case HANDLE_DATA:\n       stanza.setValue(str);\n       if (stanzaStack.empty()) {\n         if (!name.equals(\"DATA\")) {\n           throw new InvalidXmlException(\"expected \u003c/DATA\u003e\");\n         }\n         state \u003d ParseState.EXPECT_RECORD;\n         FSEditLogOp op \u003d opCache.get(opCode);\n         opCode \u003d null;\n         try {\n           op.decodeXml(stanza);\n           stanza \u003d null;\n         } finally {\n           if (stanza !\u003d null) {\n             System.err.println(\"fromXml error decoding opcode \" + opCode +\n                 \"\\n\" + stanza.toString());\n             stanza \u003d null;\n           }\n         }\n         if (fixTxIds) {\n           if (nextTxId \u003c\u003d 0) {\n             nextTxId \u003d op.getTransactionId();\n             if (nextTxId \u003c\u003d 0) {\n               nextTxId \u003d 1;\n             }\n           }\n           op.setTransactionId(nextTxId);\n           nextTxId++;\n         }\n         try {\n           visitor.visitOp(op);\n         } catch (IOException e) {\n           // Can\u0027t throw IOException from a SAX method, sigh.\n           throw new RuntimeException(e);\n         }\n         state \u003d ParseState.EXPECT_RECORD;\n       } else {\n         stanza \u003d stanzaStack.pop();\n       }\n       break;\n     case EXPECT_END:\n       throw new InvalidXmlException(\"not expecting anything after \u003c/EDITS\u003e\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void endElement (String uri, String name, String qName) {\n    String str \u003d XMLUtils.unmangleXmlString(cbuf.toString()).trim();\n    cbuf \u003d new StringBuffer();\n    switch (state) {\n    case EXPECT_EDITS_TAG:\n      throw new InvalidXmlException(\"expected \u003cEDITS/\u003e\");\n    case EXPECT_VERSION:\n      if (!name.equals(\"EDITS_VERSION\")) {\n        throw new InvalidXmlException(\"expected \u003c/EDITS_VERSION\u003e\");\n      }\n      try {\n        int version \u003d Integer.parseInt(str);\n        visitor.start(version);\n      } catch (IOException e) {\n        // Can\u0027t throw IOException from a SAX method, sigh.\n        throw new RuntimeException(e);\n      }\n      state \u003d ParseState.EXPECT_RECORD;\n      break;\n    case EXPECT_RECORD:\n      if (name.equals(\"EDITS\")) {\n        state \u003d ParseState.EXPECT_END;\n      } else if (!name.equals(\"RECORD\")) {\n        throw new InvalidXmlException(\"expected \u003c/EDITS\u003e or \u003c/RECORD\u003e\");\n      }\n      break;\n    case EXPECT_OPCODE:\n      if (!name.equals(\"OPCODE\")) {\n        throw new InvalidXmlException(\"expected \u003c/OPCODE\u003e\");\n      }\n      opCode \u003d FSEditLogOpCodes.valueOf(str);\n      state \u003d ParseState.EXPECT_DATA;\n      break;\n    case EXPECT_DATA:\n      throw new InvalidXmlException(\"expected \u003cDATA/\u003e\");\n    case HANDLE_DATA:\n      stanza.setValue(str);\n      if (stanzaStack.empty()) {\n        if (!name.equals(\"DATA\")) {\n          throw new InvalidXmlException(\"expected \u003c/DATA\u003e\");\n        }\n        state \u003d ParseState.EXPECT_RECORD;\n        FSEditLogOp op \u003d opCache.get(opCode);\n        opCode \u003d null;\n        try {\n          op.decodeXml(stanza);\n          stanza \u003d null;\n        } finally {\n          if (stanza !\u003d null) {\n            System.err.println(\"fromXml error decoding opcode \" + opCode +\n                \"\\n\" + stanza.toString());\n            stanza \u003d null;\n          }\n        }\n        if (fixTxIds) {\n          if (nextTxId \u003c\u003d 0) {\n            nextTxId \u003d op.getTransactionId();\n            if (nextTxId \u003c\u003d 0) {\n              nextTxId \u003d 1;\n            }\n          }\n          op.setTransactionId(nextTxId);\n          nextTxId++;\n        }\n        try {\n          visitor.visitOp(op);\n        } catch (IOException e) {\n          // Can\u0027t throw IOException from a SAX method, sigh.\n          throw new RuntimeException(e);\n        }\n        state \u003d ParseState.EXPECT_RECORD;\n      } else {\n        stanza \u003d stanzaStack.pop();\n      }\n      break;\n    case EXPECT_END:\n      throw new InvalidXmlException(\"not expecting anything after \u003c/EDITS\u003e\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineEditsViewer/OfflineEditsXmlLoader.java",
      "extendedDetails": {}
    },
    "706394d03992b394e9f907aff2155df493e4ea4e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3004. Implement Recovery Mode. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1311394 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/12 12:39 PM",
      "commitName": "706394d03992b394e9f907aff2155df493e4ea4e",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "04/04/12 5:02 PM",
      "commitNameOld": "4f6e0a5a659064e0af3bec315e7c25d5e43b47f5",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 4.82,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   public void endElement (String uri, String name, String qName) {\n     String str \u003d cbuf.toString().trim();\n     cbuf \u003d new StringBuffer();\n     switch (state) {\n     case EXPECT_EDITS_TAG:\n       throw new InvalidXmlException(\"expected \u003cEDITS/\u003e\");\n     case EXPECT_VERSION:\n       if (!name.equals(\"EDITS_VERSION\")) {\n         throw new InvalidXmlException(\"expected \u003c/EDITS_VERSION\u003e\");\n       }\n       try {\n         int version \u003d Integer.parseInt(str);\n         visitor.start(version);\n       } catch (IOException e) {\n         // Can\u0027t throw IOException from a SAX method, sigh.\n         throw new RuntimeException(e);\n       }\n       state \u003d ParseState.EXPECT_RECORD;\n       break;\n     case EXPECT_RECORD:\n       if (name.equals(\"EDITS\")) {\n         state \u003d ParseState.EXPECT_END;\n       } else if (!name.equals(\"RECORD\")) {\n         throw new InvalidXmlException(\"expected \u003c/EDITS\u003e or \u003c/RECORD\u003e\");\n       }\n       break;\n     case EXPECT_OPCODE:\n       if (!name.equals(\"OPCODE\")) {\n         throw new InvalidXmlException(\"expected \u003c/OPCODE\u003e\");\n       }\n       opCode \u003d FSEditLogOpCodes.valueOf(str);\n       state \u003d ParseState.EXPECT_DATA;\n       break;\n     case EXPECT_DATA:\n       throw new InvalidXmlException(\"expected \u003cDATA/\u003e\");\n     case HANDLE_DATA:\n       stanza.setValue(str);\n       if (stanzaStack.empty()) {\n         if (!name.equals(\"DATA\")) {\n           throw new InvalidXmlException(\"expected \u003c/DATA\u003e\");\n         }\n         state \u003d ParseState.EXPECT_RECORD;\n-        FSEditLogOp op \u003d FSEditLogOp.getOpInstance(opCode);\n+        FSEditLogOp op \u003d opCache.get(opCode);\n         opCode \u003d null;\n         try {\n           op.decodeXml(stanza);\n           stanza \u003d null;\n         } finally {\n           if (stanza !\u003d null) {\n             System.err.println(\"fromXml error decoding opcode \" + opCode +\n                 \"\\n\" + stanza.toString());\n             stanza \u003d null;\n           }\n         }\n         if (fixTxIds) {\n           if (nextTxId \u003c\u003d 0) {\n             nextTxId \u003d op.getTransactionId();\n             if (nextTxId \u003c\u003d 0) {\n               nextTxId \u003d 1;\n             }\n           }\n           op.setTransactionId(nextTxId);\n           nextTxId++;\n         }\n         try {\n           visitor.visitOp(op);\n         } catch (IOException e) {\n           // Can\u0027t throw IOException from a SAX method, sigh.\n           throw new RuntimeException(e);\n         }\n         state \u003d ParseState.EXPECT_RECORD;\n       } else {\n         stanza \u003d stanzaStack.pop();\n       }\n       break;\n     case EXPECT_END:\n       throw new InvalidXmlException(\"not expecting anything after \u003c/EDITS\u003e\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void endElement (String uri, String name, String qName) {\n    String str \u003d cbuf.toString().trim();\n    cbuf \u003d new StringBuffer();\n    switch (state) {\n    case EXPECT_EDITS_TAG:\n      throw new InvalidXmlException(\"expected \u003cEDITS/\u003e\");\n    case EXPECT_VERSION:\n      if (!name.equals(\"EDITS_VERSION\")) {\n        throw new InvalidXmlException(\"expected \u003c/EDITS_VERSION\u003e\");\n      }\n      try {\n        int version \u003d Integer.parseInt(str);\n        visitor.start(version);\n      } catch (IOException e) {\n        // Can\u0027t throw IOException from a SAX method, sigh.\n        throw new RuntimeException(e);\n      }\n      state \u003d ParseState.EXPECT_RECORD;\n      break;\n    case EXPECT_RECORD:\n      if (name.equals(\"EDITS\")) {\n        state \u003d ParseState.EXPECT_END;\n      } else if (!name.equals(\"RECORD\")) {\n        throw new InvalidXmlException(\"expected \u003c/EDITS\u003e or \u003c/RECORD\u003e\");\n      }\n      break;\n    case EXPECT_OPCODE:\n      if (!name.equals(\"OPCODE\")) {\n        throw new InvalidXmlException(\"expected \u003c/OPCODE\u003e\");\n      }\n      opCode \u003d FSEditLogOpCodes.valueOf(str);\n      state \u003d ParseState.EXPECT_DATA;\n      break;\n    case EXPECT_DATA:\n      throw new InvalidXmlException(\"expected \u003cDATA/\u003e\");\n    case HANDLE_DATA:\n      stanza.setValue(str);\n      if (stanzaStack.empty()) {\n        if (!name.equals(\"DATA\")) {\n          throw new InvalidXmlException(\"expected \u003c/DATA\u003e\");\n        }\n        state \u003d ParseState.EXPECT_RECORD;\n        FSEditLogOp op \u003d opCache.get(opCode);\n        opCode \u003d null;\n        try {\n          op.decodeXml(stanza);\n          stanza \u003d null;\n        } finally {\n          if (stanza !\u003d null) {\n            System.err.println(\"fromXml error decoding opcode \" + opCode +\n                \"\\n\" + stanza.toString());\n            stanza \u003d null;\n          }\n        }\n        if (fixTxIds) {\n          if (nextTxId \u003c\u003d 0) {\n            nextTxId \u003d op.getTransactionId();\n            if (nextTxId \u003c\u003d 0) {\n              nextTxId \u003d 1;\n            }\n          }\n          op.setTransactionId(nextTxId);\n          nextTxId++;\n        }\n        try {\n          visitor.visitOp(op);\n        } catch (IOException e) {\n          // Can\u0027t throw IOException from a SAX method, sigh.\n          throw new RuntimeException(e);\n        }\n        state \u003d ParseState.EXPECT_RECORD;\n      } else {\n        stanza \u003d stanzaStack.pop();\n      }\n      break;\n    case EXPECT_END:\n      throw new InvalidXmlException(\"not expecting anything after \u003c/EDITS\u003e\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineEditsViewer/OfflineEditsXmlLoader.java",
      "extendedDetails": {}
    },
    "4f6e0a5a659064e0af3bec315e7c25d5e43b47f5": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3050. rework OEV to share more code with the NameNode. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1309629 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/04/12 5:02 PM",
      "commitName": "4f6e0a5a659064e0af3bec315e7c25d5e43b47f5",
      "commitAuthor": "Eli Collins",
      "diff": "@@ -0,0 +1,79 @@\n+  public void endElement (String uri, String name, String qName) {\n+    String str \u003d cbuf.toString().trim();\n+    cbuf \u003d new StringBuffer();\n+    switch (state) {\n+    case EXPECT_EDITS_TAG:\n+      throw new InvalidXmlException(\"expected \u003cEDITS/\u003e\");\n+    case EXPECT_VERSION:\n+      if (!name.equals(\"EDITS_VERSION\")) {\n+        throw new InvalidXmlException(\"expected \u003c/EDITS_VERSION\u003e\");\n+      }\n+      try {\n+        int version \u003d Integer.parseInt(str);\n+        visitor.start(version);\n+      } catch (IOException e) {\n+        // Can\u0027t throw IOException from a SAX method, sigh.\n+        throw new RuntimeException(e);\n+      }\n+      state \u003d ParseState.EXPECT_RECORD;\n+      break;\n+    case EXPECT_RECORD:\n+      if (name.equals(\"EDITS\")) {\n+        state \u003d ParseState.EXPECT_END;\n+      } else if (!name.equals(\"RECORD\")) {\n+        throw new InvalidXmlException(\"expected \u003c/EDITS\u003e or \u003c/RECORD\u003e\");\n+      }\n+      break;\n+    case EXPECT_OPCODE:\n+      if (!name.equals(\"OPCODE\")) {\n+        throw new InvalidXmlException(\"expected \u003c/OPCODE\u003e\");\n+      }\n+      opCode \u003d FSEditLogOpCodes.valueOf(str);\n+      state \u003d ParseState.EXPECT_DATA;\n+      break;\n+    case EXPECT_DATA:\n+      throw new InvalidXmlException(\"expected \u003cDATA/\u003e\");\n+    case HANDLE_DATA:\n+      stanza.setValue(str);\n+      if (stanzaStack.empty()) {\n+        if (!name.equals(\"DATA\")) {\n+          throw new InvalidXmlException(\"expected \u003c/DATA\u003e\");\n+        }\n+        state \u003d ParseState.EXPECT_RECORD;\n+        FSEditLogOp op \u003d FSEditLogOp.getOpInstance(opCode);\n+        opCode \u003d null;\n+        try {\n+          op.decodeXml(stanza);\n+          stanza \u003d null;\n+        } finally {\n+          if (stanza !\u003d null) {\n+            System.err.println(\"fromXml error decoding opcode \" + opCode +\n+                \"\\n\" + stanza.toString());\n+            stanza \u003d null;\n+          }\n+        }\n+        if (fixTxIds) {\n+          if (nextTxId \u003c\u003d 0) {\n+            nextTxId \u003d op.getTransactionId();\n+            if (nextTxId \u003c\u003d 0) {\n+              nextTxId \u003d 1;\n+            }\n+          }\n+          op.setTransactionId(nextTxId);\n+          nextTxId++;\n+        }\n+        try {\n+          visitor.visitOp(op);\n+        } catch (IOException e) {\n+          // Can\u0027t throw IOException from a SAX method, sigh.\n+          throw new RuntimeException(e);\n+        }\n+        state \u003d ParseState.EXPECT_RECORD;\n+      } else {\n+        stanza \u003d stanzaStack.pop();\n+      }\n+      break;\n+    case EXPECT_END:\n+      throw new InvalidXmlException(\"not expecting anything after \u003c/EDITS\u003e\");\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void endElement (String uri, String name, String qName) {\n    String str \u003d cbuf.toString().trim();\n    cbuf \u003d new StringBuffer();\n    switch (state) {\n    case EXPECT_EDITS_TAG:\n      throw new InvalidXmlException(\"expected \u003cEDITS/\u003e\");\n    case EXPECT_VERSION:\n      if (!name.equals(\"EDITS_VERSION\")) {\n        throw new InvalidXmlException(\"expected \u003c/EDITS_VERSION\u003e\");\n      }\n      try {\n        int version \u003d Integer.parseInt(str);\n        visitor.start(version);\n      } catch (IOException e) {\n        // Can\u0027t throw IOException from a SAX method, sigh.\n        throw new RuntimeException(e);\n      }\n      state \u003d ParseState.EXPECT_RECORD;\n      break;\n    case EXPECT_RECORD:\n      if (name.equals(\"EDITS\")) {\n        state \u003d ParseState.EXPECT_END;\n      } else if (!name.equals(\"RECORD\")) {\n        throw new InvalidXmlException(\"expected \u003c/EDITS\u003e or \u003c/RECORD\u003e\");\n      }\n      break;\n    case EXPECT_OPCODE:\n      if (!name.equals(\"OPCODE\")) {\n        throw new InvalidXmlException(\"expected \u003c/OPCODE\u003e\");\n      }\n      opCode \u003d FSEditLogOpCodes.valueOf(str);\n      state \u003d ParseState.EXPECT_DATA;\n      break;\n    case EXPECT_DATA:\n      throw new InvalidXmlException(\"expected \u003cDATA/\u003e\");\n    case HANDLE_DATA:\n      stanza.setValue(str);\n      if (stanzaStack.empty()) {\n        if (!name.equals(\"DATA\")) {\n          throw new InvalidXmlException(\"expected \u003c/DATA\u003e\");\n        }\n        state \u003d ParseState.EXPECT_RECORD;\n        FSEditLogOp op \u003d FSEditLogOp.getOpInstance(opCode);\n        opCode \u003d null;\n        try {\n          op.decodeXml(stanza);\n          stanza \u003d null;\n        } finally {\n          if (stanza !\u003d null) {\n            System.err.println(\"fromXml error decoding opcode \" + opCode +\n                \"\\n\" + stanza.toString());\n            stanza \u003d null;\n          }\n        }\n        if (fixTxIds) {\n          if (nextTxId \u003c\u003d 0) {\n            nextTxId \u003d op.getTransactionId();\n            if (nextTxId \u003c\u003d 0) {\n              nextTxId \u003d 1;\n            }\n          }\n          op.setTransactionId(nextTxId);\n          nextTxId++;\n        }\n        try {\n          visitor.visitOp(op);\n        } catch (IOException e) {\n          // Can\u0027t throw IOException from a SAX method, sigh.\n          throw new RuntimeException(e);\n        }\n        state \u003d ParseState.EXPECT_RECORD;\n      } else {\n        stanza \u003d stanzaStack.pop();\n      }\n      break;\n    case EXPECT_END:\n      throw new InvalidXmlException(\"not expecting anything after \u003c/EDITS\u003e\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineEditsViewer/OfflineEditsXmlLoader.java"
    }
  }
}