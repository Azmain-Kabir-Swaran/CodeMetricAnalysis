{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AzureNativeFileSystemStore.java",
  "functionName": "checkContainer",
  "functionId": "checkContainer___accessType-ContainerAccessType",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
  "functionStartLine": 1317,
  "functionEndLine": 1393,
  "numCommitsSeen": 53,
  "timeTaken": 2865,
  "changeHistory": [
    "ba9efe06fadb9631763f3e623d8748bbe59ff748",
    "990aa34de23c625163745ebc338483065d955bbe",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82"
  ],
  "changeHistoryShort": {
    "ba9efe06fadb9631763f3e623d8748bbe59ff748": "Ybodychange",
    "990aa34de23c625163745ebc338483065d955bbe": "Ybodychange",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ba9efe06fadb9631763f3e623d8748bbe59ff748": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16074. WASB: Update container not found error code.\n\nContributed by Da Zhou.\n",
      "commitDate": "05/02/19 6:39 AM",
      "commitName": "ba9efe06fadb9631763f3e623d8748bbe59ff748",
      "commitAuthor": "Da Zhou",
      "commitDateOld": "10/01/19 4:07 AM",
      "commitNameOld": "852701f7935eb94eda6f44b74a2ce060e7c159a7",
      "commitAuthorOld": "Da Zhou",
      "daysBetweenCommits": 26.11,
      "commitsBetweenForRepo": 182,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n   private ContainerState checkContainer(ContainerAccessType accessType)\n       throws StorageException, AzureException {\n     synchronized (containerStateLock) {\n       if (isOkContainerState(accessType)) {\n         return currentKnownContainerState;\n       }\n       if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtWrongVersion) {\n         String containerVersion \u003d retrieveVersionAttribute(container);\n         throw wrongVersionException(containerVersion);\n       }\n       // This means I didn\u0027t check it before or it didn\u0027t exist or\n       // we need to stamp the version. Since things may have changed by\n       // other machines since then, do the check again and don\u0027t depend\n       // on past information.\n \n       // Sanity check: we don\u0027t expect this at this point.\n       if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtRightVersion) {\n         throw new AssertionError(\"Unexpected state: \"\n             + currentKnownContainerState);\n       }\n \n       // Download the attributes - doubles as an existence check with just\n       // one service call\n       try {\n         container.downloadAttributes(getInstrumentedContext());\n         currentKnownContainerState \u003d ContainerState.Unknown;\n       } catch (StorageException ex) {\n-        if (StorageErrorCode.RESOURCE_NOT_FOUND.toString()\n+        if (StorageErrorCodeStrings.CONTAINER_NOT_FOUND.toString()\n             .equals(ex.getErrorCode())) {\n           currentKnownContainerState \u003d ContainerState.DoesntExist;\n         } else {\n           throw ex;\n         }\n       }\n \n       if (currentKnownContainerState \u003d\u003d ContainerState.DoesntExist) {\n         // If the container doesn\u0027t exist and we intend to write to it,\n         // create it now.\n         if (needToCreateContainer(accessType)) {\n           storeVersionAttribute(container);\n           container.create(getInstrumentedContext());\n           currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n         }\n       } else {\n         // The container exists, check the version.\n         String containerVersion \u003d retrieveVersionAttribute(container);\n         if (containerVersion !\u003d null) {\n           if (containerVersion.equals(FIRST_WASB_VERSION)) {\n             // It\u0027s the version from when WASB was called ASV, just\n             // fix the version attribute if needed and proceed.\n             // We should be good otherwise.\n             if (needToStampVersion(accessType)) {\n               storeVersionAttribute(container);\n               container.uploadMetadata(getInstrumentedContext());\n             }\n           } else if (!containerVersion.equals(CURRENT_WASB_VERSION)) {\n             // Don\u0027t know this version - throw.\n             currentKnownContainerState \u003d ContainerState.ExistsAtWrongVersion;\n             throw wrongVersionException(containerVersion);\n           } else {\n             // It\u0027s our correct version.\n             currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n           }\n         } else {\n           // No version info exists.\n           currentKnownContainerState \u003d ContainerState.ExistsNoVersion;\n           if (needToStampVersion(accessType)) {\n             // Need to stamp the version\n             storeVersionAttribute(container);\n             container.uploadMetadata(getInstrumentedContext());\n             currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n           }\n         }\n       }\n       return currentKnownContainerState;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerState checkContainer(ContainerAccessType accessType)\n      throws StorageException, AzureException {\n    synchronized (containerStateLock) {\n      if (isOkContainerState(accessType)) {\n        return currentKnownContainerState;\n      }\n      if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtWrongVersion) {\n        String containerVersion \u003d retrieveVersionAttribute(container);\n        throw wrongVersionException(containerVersion);\n      }\n      // This means I didn\u0027t check it before or it didn\u0027t exist or\n      // we need to stamp the version. Since things may have changed by\n      // other machines since then, do the check again and don\u0027t depend\n      // on past information.\n\n      // Sanity check: we don\u0027t expect this at this point.\n      if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtRightVersion) {\n        throw new AssertionError(\"Unexpected state: \"\n            + currentKnownContainerState);\n      }\n\n      // Download the attributes - doubles as an existence check with just\n      // one service call\n      try {\n        container.downloadAttributes(getInstrumentedContext());\n        currentKnownContainerState \u003d ContainerState.Unknown;\n      } catch (StorageException ex) {\n        if (StorageErrorCodeStrings.CONTAINER_NOT_FOUND.toString()\n            .equals(ex.getErrorCode())) {\n          currentKnownContainerState \u003d ContainerState.DoesntExist;\n        } else {\n          throw ex;\n        }\n      }\n\n      if (currentKnownContainerState \u003d\u003d ContainerState.DoesntExist) {\n        // If the container doesn\u0027t exist and we intend to write to it,\n        // create it now.\n        if (needToCreateContainer(accessType)) {\n          storeVersionAttribute(container);\n          container.create(getInstrumentedContext());\n          currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n        }\n      } else {\n        // The container exists, check the version.\n        String containerVersion \u003d retrieveVersionAttribute(container);\n        if (containerVersion !\u003d null) {\n          if (containerVersion.equals(FIRST_WASB_VERSION)) {\n            // It\u0027s the version from when WASB was called ASV, just\n            // fix the version attribute if needed and proceed.\n            // We should be good otherwise.\n            if (needToStampVersion(accessType)) {\n              storeVersionAttribute(container);\n              container.uploadMetadata(getInstrumentedContext());\n            }\n          } else if (!containerVersion.equals(CURRENT_WASB_VERSION)) {\n            // Don\u0027t know this version - throw.\n            currentKnownContainerState \u003d ContainerState.ExistsAtWrongVersion;\n            throw wrongVersionException(containerVersion);\n          } else {\n            // It\u0027s our correct version.\n            currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n          }\n        } else {\n          // No version info exists.\n          currentKnownContainerState \u003d ContainerState.ExistsNoVersion;\n          if (needToStampVersion(accessType)) {\n            // Need to stamp the version\n            storeVersionAttribute(container);\n            container.uploadMetadata(getInstrumentedContext());\n            currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n          }\n        }\n      }\n      return currentKnownContainerState;\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "990aa34de23c625163745ebc338483065d955bbe": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14609. NPE in AzureNativeFileSystemStore.checkContainer() if StorageException lacks an error code. Contributed by Steve Loughran\n",
      "commitDate": "28/06/17 2:18 PM",
      "commitName": "990aa34de23c625163745ebc338483065d955bbe",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "27/06/17 5:32 PM",
      "commitNameOld": "7e031c2c18b8812ec9f843ed3b4abe9e6d12bb28",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n   private ContainerState checkContainer(ContainerAccessType accessType)\n       throws StorageException, AzureException {\n     synchronized (containerStateLock) {\n       if (isOkContainerState(accessType)) {\n         return currentKnownContainerState;\n       }\n       if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtWrongVersion) {\n         String containerVersion \u003d retrieveVersionAttribute(container);\n         throw wrongVersionException(containerVersion);\n       }\n       // This means I didn\u0027t check it before or it didn\u0027t exist or\n       // we need to stamp the version. Since things may have changed by\n       // other machines since then, do the check again and don\u0027t depend\n       // on past information.\n \n       // Sanity check: we don\u0027t expect this at this point.\n       if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtRightVersion) {\n         throw new AssertionError(\"Unexpected state: \"\n             + currentKnownContainerState);\n       }\n \n       // Download the attributes - doubles as an existence check with just\n       // one service call\n       try {\n         container.downloadAttributes(getInstrumentedContext());\n         currentKnownContainerState \u003d ContainerState.Unknown;\n       } catch (StorageException ex) {\n-        if (ex.getErrorCode().equals(\n-            StorageErrorCode.RESOURCE_NOT_FOUND.toString())) {\n+        if (StorageErrorCode.RESOURCE_NOT_FOUND.toString()\n+            .equals(ex.getErrorCode())) {\n           currentKnownContainerState \u003d ContainerState.DoesntExist;\n         } else {\n           throw ex;\n         }\n       }\n \n       if (currentKnownContainerState \u003d\u003d ContainerState.DoesntExist) {\n         // If the container doesn\u0027t exist and we intend to write to it,\n         // create it now.\n         if (needToCreateContainer(accessType)) {\n           storeVersionAttribute(container);\n           container.create(getInstrumentedContext());\n           currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n         }\n       } else {\n         // The container exists, check the version.\n         String containerVersion \u003d retrieveVersionAttribute(container);\n         if (containerVersion !\u003d null) {\n           if (containerVersion.equals(FIRST_WASB_VERSION)) {\n             // It\u0027s the version from when WASB was called ASV, just\n             // fix the version attribute if needed and proceed.\n             // We should be good otherwise.\n             if (needToStampVersion(accessType)) {\n               storeVersionAttribute(container);\n               container.uploadMetadata(getInstrumentedContext());\n             }\n           } else if (!containerVersion.equals(CURRENT_WASB_VERSION)) {\n             // Don\u0027t know this version - throw.\n             currentKnownContainerState \u003d ContainerState.ExistsAtWrongVersion;\n             throw wrongVersionException(containerVersion);\n           } else {\n             // It\u0027s our correct version.\n             currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n           }\n         } else {\n           // No version info exists.\n           currentKnownContainerState \u003d ContainerState.ExistsNoVersion;\n           if (needToStampVersion(accessType)) {\n             // Need to stamp the version\n             storeVersionAttribute(container);\n             container.uploadMetadata(getInstrumentedContext());\n             currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n           }\n         }\n       }\n       return currentKnownContainerState;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerState checkContainer(ContainerAccessType accessType)\n      throws StorageException, AzureException {\n    synchronized (containerStateLock) {\n      if (isOkContainerState(accessType)) {\n        return currentKnownContainerState;\n      }\n      if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtWrongVersion) {\n        String containerVersion \u003d retrieveVersionAttribute(container);\n        throw wrongVersionException(containerVersion);\n      }\n      // This means I didn\u0027t check it before or it didn\u0027t exist or\n      // we need to stamp the version. Since things may have changed by\n      // other machines since then, do the check again and don\u0027t depend\n      // on past information.\n\n      // Sanity check: we don\u0027t expect this at this point.\n      if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtRightVersion) {\n        throw new AssertionError(\"Unexpected state: \"\n            + currentKnownContainerState);\n      }\n\n      // Download the attributes - doubles as an existence check with just\n      // one service call\n      try {\n        container.downloadAttributes(getInstrumentedContext());\n        currentKnownContainerState \u003d ContainerState.Unknown;\n      } catch (StorageException ex) {\n        if (StorageErrorCode.RESOURCE_NOT_FOUND.toString()\n            .equals(ex.getErrorCode())) {\n          currentKnownContainerState \u003d ContainerState.DoesntExist;\n        } else {\n          throw ex;\n        }\n      }\n\n      if (currentKnownContainerState \u003d\u003d ContainerState.DoesntExist) {\n        // If the container doesn\u0027t exist and we intend to write to it,\n        // create it now.\n        if (needToCreateContainer(accessType)) {\n          storeVersionAttribute(container);\n          container.create(getInstrumentedContext());\n          currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n        }\n      } else {\n        // The container exists, check the version.\n        String containerVersion \u003d retrieveVersionAttribute(container);\n        if (containerVersion !\u003d null) {\n          if (containerVersion.equals(FIRST_WASB_VERSION)) {\n            // It\u0027s the version from when WASB was called ASV, just\n            // fix the version attribute if needed and proceed.\n            // We should be good otherwise.\n            if (needToStampVersion(accessType)) {\n              storeVersionAttribute(container);\n              container.uploadMetadata(getInstrumentedContext());\n            }\n          } else if (!containerVersion.equals(CURRENT_WASB_VERSION)) {\n            // Don\u0027t know this version - throw.\n            currentKnownContainerState \u003d ContainerState.ExistsAtWrongVersion;\n            throw wrongVersionException(containerVersion);\n          } else {\n            // It\u0027s our correct version.\n            currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n          }\n        } else {\n          // No version info exists.\n          currentKnownContainerState \u003d ContainerState.ExistsNoVersion;\n          if (needToStampVersion(accessType)) {\n            // Need to stamp the version\n            storeVersionAttribute(container);\n            container.uploadMetadata(getInstrumentedContext());\n            currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n          }\n        }\n      }\n      return currentKnownContainerState;\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9629. Support Windows Azure Storage - Blob as a file system in Hadoop. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601781 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/06/14 3:26 PM",
      "commitName": "81bc395deb3ba00567dc067d6ca71bacf9e3bc82",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,77 @@\n+  private ContainerState checkContainer(ContainerAccessType accessType)\n+      throws StorageException, AzureException {\n+    synchronized (containerStateLock) {\n+      if (isOkContainerState(accessType)) {\n+        return currentKnownContainerState;\n+      }\n+      if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtWrongVersion) {\n+        String containerVersion \u003d retrieveVersionAttribute(container);\n+        throw wrongVersionException(containerVersion);\n+      }\n+      // This means I didn\u0027t check it before or it didn\u0027t exist or\n+      // we need to stamp the version. Since things may have changed by\n+      // other machines since then, do the check again and don\u0027t depend\n+      // on past information.\n+\n+      // Sanity check: we don\u0027t expect this at this point.\n+      if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtRightVersion) {\n+        throw new AssertionError(\"Unexpected state: \"\n+            + currentKnownContainerState);\n+      }\n+\n+      // Download the attributes - doubles as an existence check with just\n+      // one service call\n+      try {\n+        container.downloadAttributes(getInstrumentedContext());\n+        currentKnownContainerState \u003d ContainerState.Unknown;\n+      } catch (StorageException ex) {\n+        if (ex.getErrorCode().equals(\n+            StorageErrorCode.RESOURCE_NOT_FOUND.toString())) {\n+          currentKnownContainerState \u003d ContainerState.DoesntExist;\n+        } else {\n+          throw ex;\n+        }\n+      }\n+\n+      if (currentKnownContainerState \u003d\u003d ContainerState.DoesntExist) {\n+        // If the container doesn\u0027t exist and we intend to write to it,\n+        // create it now.\n+        if (needToCreateContainer(accessType)) {\n+          storeVersionAttribute(container);\n+          container.create(getInstrumentedContext());\n+          currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n+        }\n+      } else {\n+        // The container exists, check the version.\n+        String containerVersion \u003d retrieveVersionAttribute(container);\n+        if (containerVersion !\u003d null) {\n+          if (containerVersion.equals(FIRST_WASB_VERSION)) {\n+            // It\u0027s the version from when WASB was called ASV, just\n+            // fix the version attribute if needed and proceed.\n+            // We should be good otherwise.\n+            if (needToStampVersion(accessType)) {\n+              storeVersionAttribute(container);\n+              container.uploadMetadata(getInstrumentedContext());\n+            }\n+          } else if (!containerVersion.equals(CURRENT_WASB_VERSION)) {\n+            // Don\u0027t know this version - throw.\n+            currentKnownContainerState \u003d ContainerState.ExistsAtWrongVersion;\n+            throw wrongVersionException(containerVersion);\n+          } else {\n+            // It\u0027s our correct version.\n+            currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n+          }\n+        } else {\n+          // No version info exists.\n+          currentKnownContainerState \u003d ContainerState.ExistsNoVersion;\n+          if (needToStampVersion(accessType)) {\n+            // Need to stamp the version\n+            storeVersionAttribute(container);\n+            container.uploadMetadata(getInstrumentedContext());\n+            currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n+          }\n+        }\n+      }\n+      return currentKnownContainerState;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerState checkContainer(ContainerAccessType accessType)\n      throws StorageException, AzureException {\n    synchronized (containerStateLock) {\n      if (isOkContainerState(accessType)) {\n        return currentKnownContainerState;\n      }\n      if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtWrongVersion) {\n        String containerVersion \u003d retrieveVersionAttribute(container);\n        throw wrongVersionException(containerVersion);\n      }\n      // This means I didn\u0027t check it before or it didn\u0027t exist or\n      // we need to stamp the version. Since things may have changed by\n      // other machines since then, do the check again and don\u0027t depend\n      // on past information.\n\n      // Sanity check: we don\u0027t expect this at this point.\n      if (currentKnownContainerState \u003d\u003d ContainerState.ExistsAtRightVersion) {\n        throw new AssertionError(\"Unexpected state: \"\n            + currentKnownContainerState);\n      }\n\n      // Download the attributes - doubles as an existence check with just\n      // one service call\n      try {\n        container.downloadAttributes(getInstrumentedContext());\n        currentKnownContainerState \u003d ContainerState.Unknown;\n      } catch (StorageException ex) {\n        if (ex.getErrorCode().equals(\n            StorageErrorCode.RESOURCE_NOT_FOUND.toString())) {\n          currentKnownContainerState \u003d ContainerState.DoesntExist;\n        } else {\n          throw ex;\n        }\n      }\n\n      if (currentKnownContainerState \u003d\u003d ContainerState.DoesntExist) {\n        // If the container doesn\u0027t exist and we intend to write to it,\n        // create it now.\n        if (needToCreateContainer(accessType)) {\n          storeVersionAttribute(container);\n          container.create(getInstrumentedContext());\n          currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n        }\n      } else {\n        // The container exists, check the version.\n        String containerVersion \u003d retrieveVersionAttribute(container);\n        if (containerVersion !\u003d null) {\n          if (containerVersion.equals(FIRST_WASB_VERSION)) {\n            // It\u0027s the version from when WASB was called ASV, just\n            // fix the version attribute if needed and proceed.\n            // We should be good otherwise.\n            if (needToStampVersion(accessType)) {\n              storeVersionAttribute(container);\n              container.uploadMetadata(getInstrumentedContext());\n            }\n          } else if (!containerVersion.equals(CURRENT_WASB_VERSION)) {\n            // Don\u0027t know this version - throw.\n            currentKnownContainerState \u003d ContainerState.ExistsAtWrongVersion;\n            throw wrongVersionException(containerVersion);\n          } else {\n            // It\u0027s our correct version.\n            currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n          }\n        } else {\n          // No version info exists.\n          currentKnownContainerState \u003d ContainerState.ExistsNoVersion;\n          if (needToStampVersion(accessType)) {\n            // Need to stamp the version\n            storeVersionAttribute(container);\n            container.uploadMetadata(getInstrumentedContext());\n            currentKnownContainerState \u003d ContainerState.ExistsAtRightVersion;\n          }\n        }\n      }\n      return currentKnownContainerState;\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java"
    }
  }
}