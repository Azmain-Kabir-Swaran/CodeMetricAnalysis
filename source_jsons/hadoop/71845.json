{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "KMS.java",
  "functionName": "reencryptEncryptedKeys",
  "functionId": "reencryptEncryptedKeys___name-String(annotations-@PathParam(\"name\")__modifiers-final)__jsonPayload-List__Map__(modifiers-final)",
  "sourceFilePath": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMS.java",
  "functionStartLine": 552,
  "functionEndLine": 602,
  "numCommitsSeen": 18,
  "timeTaken": 1381,
  "changeHistory": [
    "996796f1048369e0f307f935ba01af64cc751a85",
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99"
  ],
  "changeHistoryShort": {
    "996796f1048369e0f307f935ba01af64cc751a85": "Ybodychange",
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99": "Yintroduced"
  },
  "changeHistoryDetails": {
    "996796f1048369e0f307f935ba01af64cc751a85": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15214. Make Hadoop compatible with Guava 21.0.\nContributed by Igor Dvorzhak\n",
      "commitDate": "08/02/18 10:55 AM",
      "commitName": "996796f1048369e0f307f935ba01af64cc751a85",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "22/08/17 7:47 AM",
      "commitNameOld": "4ec5acc70418a3f2327cf83ecae1789a057fdd99",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 170.17,
      "commitsBetweenForRepo": 1290,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   public Response reencryptEncryptedKeys(\n       @PathParam(\"name\") final String name,\n       final List\u003cMap\u003e jsonPayload)\n       throws Exception {\n     LOG.trace(\"Entering reencryptEncryptedKeys method.\");\n     try {\n-      final Stopwatch sw \u003d new Stopwatch().start();\n+      final StopWatch sw \u003d new StopWatch().start();\n       checkNotEmpty(name, \"name\");\n       checkNotNull(jsonPayload, \"jsonPayload\");\n       final UserGroupInformation user \u003d HttpUserGroupInformation.get();\n       KMSWebApp.getReencryptEEKBatchCallsMeter().mark();\n       if (jsonPayload.size() \u003e MAX_NUM_PER_BATCH) {\n         LOG.warn(\"Payload size {} too big for reencryptEncryptedKeys from\"\n             + \" user {}.\", jsonPayload.size(), user);\n       }\n       assertAccess(KMSACLs.Type.GENERATE_EEK, user, KMSOp.REENCRYPT_EEK_BATCH,\n           name);\n       LOG.debug(\"Batch reencrypting {} Encrypted Keys for key name {}\",\n           jsonPayload.size(), name);\n       final List\u003cEncryptedKeyVersion\u003e ekvs \u003d\n           KMSUtil.parseJSONEncKeyVersions(name, jsonPayload);\n       Preconditions.checkArgument(ekvs.size() \u003d\u003d jsonPayload.size(),\n           \"EncryptedKey size mismatch after parsing from json\");\n       for (EncryptedKeyVersion ekv : ekvs) {\n         Preconditions.checkArgument(name.equals(ekv.getEncryptionKeyName()),\n             \"All EncryptedKeys must be under the given key name \" + name);\n       }\n \n       user.doAs(new PrivilegedExceptionAction\u003cVoid\u003e() {\n         @Override\n         public Void run() throws Exception {\n           provider.reencryptEncryptedKeys(ekvs);\n           return null;\n         }\n       });\n       List retJSON \u003d new ArrayList\u003c\u003e(ekvs.size());\n       for (EncryptedKeyVersion ekv: ekvs) {\n         retJSON.add(KMSUtil.toJSON(ekv));\n       }\n       kmsAudit.ok(user, KMSOp.REENCRYPT_EEK_BATCH, name,\n           \"reencrypted \" + ekvs.size() + \" keys\");\n       LOG.info(\"reencryptEncryptedKeys {} keys for key {} took {}\",\n           jsonPayload.size(), name, sw.stop());\n       LOG.trace(\"Exiting reencryptEncryptedKeys method.\");\n       return Response.ok().type(MediaType.APPLICATION_JSON).entity(retJSON)\n           .build();\n     } catch (Exception e) {\n       LOG.debug(\"Exception in reencryptEncryptedKeys.\", e);\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response reencryptEncryptedKeys(\n      @PathParam(\"name\") final String name,\n      final List\u003cMap\u003e jsonPayload)\n      throws Exception {\n    LOG.trace(\"Entering reencryptEncryptedKeys method.\");\n    try {\n      final StopWatch sw \u003d new StopWatch().start();\n      checkNotEmpty(name, \"name\");\n      checkNotNull(jsonPayload, \"jsonPayload\");\n      final UserGroupInformation user \u003d HttpUserGroupInformation.get();\n      KMSWebApp.getReencryptEEKBatchCallsMeter().mark();\n      if (jsonPayload.size() \u003e MAX_NUM_PER_BATCH) {\n        LOG.warn(\"Payload size {} too big for reencryptEncryptedKeys from\"\n            + \" user {}.\", jsonPayload.size(), user);\n      }\n      assertAccess(KMSACLs.Type.GENERATE_EEK, user, KMSOp.REENCRYPT_EEK_BATCH,\n          name);\n      LOG.debug(\"Batch reencrypting {} Encrypted Keys for key name {}\",\n          jsonPayload.size(), name);\n      final List\u003cEncryptedKeyVersion\u003e ekvs \u003d\n          KMSUtil.parseJSONEncKeyVersions(name, jsonPayload);\n      Preconditions.checkArgument(ekvs.size() \u003d\u003d jsonPayload.size(),\n          \"EncryptedKey size mismatch after parsing from json\");\n      for (EncryptedKeyVersion ekv : ekvs) {\n        Preconditions.checkArgument(name.equals(ekv.getEncryptionKeyName()),\n            \"All EncryptedKeys must be under the given key name \" + name);\n      }\n\n      user.doAs(new PrivilegedExceptionAction\u003cVoid\u003e() {\n        @Override\n        public Void run() throws Exception {\n          provider.reencryptEncryptedKeys(ekvs);\n          return null;\n        }\n      });\n      List retJSON \u003d new ArrayList\u003c\u003e(ekvs.size());\n      for (EncryptedKeyVersion ekv: ekvs) {\n        retJSON.add(KMSUtil.toJSON(ekv));\n      }\n      kmsAudit.ok(user, KMSOp.REENCRYPT_EEK_BATCH, name,\n          \"reencrypted \" + ekvs.size() + \" keys\");\n      LOG.info(\"reencryptEncryptedKeys {} keys for key {} took {}\",\n          jsonPayload.size(), name, sw.stop());\n      LOG.trace(\"Exiting reencryptEncryptedKeys method.\");\n      return Response.ok().type(MediaType.APPLICATION_JSON).entity(retJSON)\n          .build();\n    } catch (Exception e) {\n      LOG.debug(\"Exception in reencryptEncryptedKeys.\", e);\n      throw e;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMS.java",
      "extendedDetails": {}
    },
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-14705. Add batched interface reencryptEncryptedKeys to KMS.\n",
      "commitDate": "22/08/17 7:47 AM",
      "commitName": "4ec5acc70418a3f2327cf83ecae1789a057fdd99",
      "commitAuthor": "Xiao Chen",
      "diff": "@@ -0,0 +1,51 @@\n+  public Response reencryptEncryptedKeys(\n+      @PathParam(\"name\") final String name,\n+      final List\u003cMap\u003e jsonPayload)\n+      throws Exception {\n+    LOG.trace(\"Entering reencryptEncryptedKeys method.\");\n+    try {\n+      final Stopwatch sw \u003d new Stopwatch().start();\n+      checkNotEmpty(name, \"name\");\n+      checkNotNull(jsonPayload, \"jsonPayload\");\n+      final UserGroupInformation user \u003d HttpUserGroupInformation.get();\n+      KMSWebApp.getReencryptEEKBatchCallsMeter().mark();\n+      if (jsonPayload.size() \u003e MAX_NUM_PER_BATCH) {\n+        LOG.warn(\"Payload size {} too big for reencryptEncryptedKeys from\"\n+            + \" user {}.\", jsonPayload.size(), user);\n+      }\n+      assertAccess(KMSACLs.Type.GENERATE_EEK, user, KMSOp.REENCRYPT_EEK_BATCH,\n+          name);\n+      LOG.debug(\"Batch reencrypting {} Encrypted Keys for key name {}\",\n+          jsonPayload.size(), name);\n+      final List\u003cEncryptedKeyVersion\u003e ekvs \u003d\n+          KMSUtil.parseJSONEncKeyVersions(name, jsonPayload);\n+      Preconditions.checkArgument(ekvs.size() \u003d\u003d jsonPayload.size(),\n+          \"EncryptedKey size mismatch after parsing from json\");\n+      for (EncryptedKeyVersion ekv : ekvs) {\n+        Preconditions.checkArgument(name.equals(ekv.getEncryptionKeyName()),\n+            \"All EncryptedKeys must be under the given key name \" + name);\n+      }\n+\n+      user.doAs(new PrivilegedExceptionAction\u003cVoid\u003e() {\n+        @Override\n+        public Void run() throws Exception {\n+          provider.reencryptEncryptedKeys(ekvs);\n+          return null;\n+        }\n+      });\n+      List retJSON \u003d new ArrayList\u003c\u003e(ekvs.size());\n+      for (EncryptedKeyVersion ekv: ekvs) {\n+        retJSON.add(KMSUtil.toJSON(ekv));\n+      }\n+      kmsAudit.ok(user, KMSOp.REENCRYPT_EEK_BATCH, name,\n+          \"reencrypted \" + ekvs.size() + \" keys\");\n+      LOG.info(\"reencryptEncryptedKeys {} keys for key {} took {}\",\n+          jsonPayload.size(), name, sw.stop());\n+      LOG.trace(\"Exiting reencryptEncryptedKeys method.\");\n+      return Response.ok().type(MediaType.APPLICATION_JSON).entity(retJSON)\n+          .build();\n+    } catch (Exception e) {\n+      LOG.debug(\"Exception in reencryptEncryptedKeys.\", e);\n+      throw e;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Response reencryptEncryptedKeys(\n      @PathParam(\"name\") final String name,\n      final List\u003cMap\u003e jsonPayload)\n      throws Exception {\n    LOG.trace(\"Entering reencryptEncryptedKeys method.\");\n    try {\n      final Stopwatch sw \u003d new Stopwatch().start();\n      checkNotEmpty(name, \"name\");\n      checkNotNull(jsonPayload, \"jsonPayload\");\n      final UserGroupInformation user \u003d HttpUserGroupInformation.get();\n      KMSWebApp.getReencryptEEKBatchCallsMeter().mark();\n      if (jsonPayload.size() \u003e MAX_NUM_PER_BATCH) {\n        LOG.warn(\"Payload size {} too big for reencryptEncryptedKeys from\"\n            + \" user {}.\", jsonPayload.size(), user);\n      }\n      assertAccess(KMSACLs.Type.GENERATE_EEK, user, KMSOp.REENCRYPT_EEK_BATCH,\n          name);\n      LOG.debug(\"Batch reencrypting {} Encrypted Keys for key name {}\",\n          jsonPayload.size(), name);\n      final List\u003cEncryptedKeyVersion\u003e ekvs \u003d\n          KMSUtil.parseJSONEncKeyVersions(name, jsonPayload);\n      Preconditions.checkArgument(ekvs.size() \u003d\u003d jsonPayload.size(),\n          \"EncryptedKey size mismatch after parsing from json\");\n      for (EncryptedKeyVersion ekv : ekvs) {\n        Preconditions.checkArgument(name.equals(ekv.getEncryptionKeyName()),\n            \"All EncryptedKeys must be under the given key name \" + name);\n      }\n\n      user.doAs(new PrivilegedExceptionAction\u003cVoid\u003e() {\n        @Override\n        public Void run() throws Exception {\n          provider.reencryptEncryptedKeys(ekvs);\n          return null;\n        }\n      });\n      List retJSON \u003d new ArrayList\u003c\u003e(ekvs.size());\n      for (EncryptedKeyVersion ekv: ekvs) {\n        retJSON.add(KMSUtil.toJSON(ekv));\n      }\n      kmsAudit.ok(user, KMSOp.REENCRYPT_EEK_BATCH, name,\n          \"reencrypted \" + ekvs.size() + \" keys\");\n      LOG.info(\"reencryptEncryptedKeys {} keys for key {} took {}\",\n          jsonPayload.size(), name, sw.stop());\n      LOG.trace(\"Exiting reencryptEncryptedKeys method.\");\n      return Response.ok().type(MediaType.APPLICATION_JSON).entity(retJSON)\n          .build();\n    } catch (Exception e) {\n      LOG.debug(\"Exception in reencryptEncryptedKeys.\", e);\n      throw e;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMS.java"
    }
  }
}