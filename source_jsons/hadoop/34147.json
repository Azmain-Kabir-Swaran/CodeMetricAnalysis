{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerScheduler.java",
  "functionName": "onResourcesReclaimed",
  "functionId": "onResourcesReclaimed___container-Container",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
  "functionStartLine": 342,
  "functionEndLine": 379,
  "numCommitsSeen": 31,
  "timeTaken": 4379,
  "changeHistory": [
    "489411579c5e30c1dc855c4fd3d5f7f68a58b27e",
    "df800f6cf3ea663daf4081ebe784808b08d9366d",
    "4f8194430fc6a69d9cc99b78828fd7045d5683e8",
    "2ae72692fc370267141a1ee55ef372ff62302b54",
    "5b007921cdf01ecc8ed97c164b7d327b8304c529",
    "b0aace21b1ef3436ba9d516186208fee9a9ceef2",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6"
  ],
  "changeHistoryShort": {
    "489411579c5e30c1dc855c4fd3d5f7f68a58b27e": "Ybodychange",
    "df800f6cf3ea663daf4081ebe784808b08d9366d": "Ybodychange",
    "4f8194430fc6a69d9cc99b78828fd7045d5683e8": "Yrename",
    "2ae72692fc370267141a1ee55ef372ff62302b54": "Ybodychange",
    "5b007921cdf01ecc8ed97c164b7d327b8304c529": "Ybodychange",
    "b0aace21b1ef3436ba9d516186208fee9a9ceef2": "Ybodychange",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "489411579c5e30c1dc855c4fd3d5f7f68a58b27e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9169. Add metrics for queued opportunistic and guaranteed containers. Contributed by Abhishek Modi.\n",
      "commitDate": "07/01/19 3:16 PM",
      "commitName": "489411579c5e30c1dc855c4fd3d5f7f68a58b27e",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "04/01/19 11:16 AM",
      "commitNameOld": "6e35f7130fb3fb17665e818f838ed750425348c0",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 3.17,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,38 @@\n   private void onResourcesReclaimed(Container container) {\n     oppContainersToKill.remove(container.getContainerId());\n \n     // This could be killed externally for eg. by the ContainerManager,\n     // in which case, the container might still be queued.\n     Container queued \u003d\n         queuedOpportunisticContainers.remove(container.getContainerId());\n     if (queued \u003d\u003d null) {\n       queuedGuaranteedContainers.remove(container.getContainerId());\n     }\n \n     // Requeue PAUSED containers\n     if (container.getContainerState() \u003d\u003d ContainerState.PAUSED) {\n       if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n           ExecutionType.GUARANTEED) {\n         queuedGuaranteedContainers.put(container.getContainerId(), container);\n       } else {\n         queuedOpportunisticContainers.put(\n             container.getContainerId(), container);\n       }\n     }\n     // decrement only if it was a running container\n     Container completedContainer \u003d runningContainers.remove(container\n         .getContainerId());\n     // only a running container releases resources upon completion\n     boolean resourceReleased \u003d completedContainer !\u003d null;\n     if (resourceReleased) {\n       this.utilizationTracker.subtractContainerResource(container);\n       if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n           ExecutionType.OPPORTUNISTIC) {\n         this.metrics.completeOpportunisticContainer(container.getResource());\n       }\n       boolean forceStartGuaranteedContainers \u003d (maxOppQueueLength \u003c\u003d 0);\n       startPendingContainers(forceStartGuaranteedContainers);\n     }\n+    this.metrics.setQueuedContainers(queuedOpportunisticContainers.size(),\n+        queuedGuaranteedContainers.size());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void onResourcesReclaimed(Container container) {\n    oppContainersToKill.remove(container.getContainerId());\n\n    // This could be killed externally for eg. by the ContainerManager,\n    // in which case, the container might still be queued.\n    Container queued \u003d\n        queuedOpportunisticContainers.remove(container.getContainerId());\n    if (queued \u003d\u003d null) {\n      queuedGuaranteedContainers.remove(container.getContainerId());\n    }\n\n    // Requeue PAUSED containers\n    if (container.getContainerState() \u003d\u003d ContainerState.PAUSED) {\n      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n          ExecutionType.GUARANTEED) {\n        queuedGuaranteedContainers.put(container.getContainerId(), container);\n      } else {\n        queuedOpportunisticContainers.put(\n            container.getContainerId(), container);\n      }\n    }\n    // decrement only if it was a running container\n    Container completedContainer \u003d runningContainers.remove(container\n        .getContainerId());\n    // only a running container releases resources upon completion\n    boolean resourceReleased \u003d completedContainer !\u003d null;\n    if (resourceReleased) {\n      this.utilizationTracker.subtractContainerResource(container);\n      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n          ExecutionType.OPPORTUNISTIC) {\n        this.metrics.completeOpportunisticContainer(container.getResource());\n      }\n      boolean forceStartGuaranteedContainers \u003d (maxOppQueueLength \u003c\u003d 0);\n      startPendingContainers(forceStartGuaranteedContainers);\n    }\n    this.metrics.setQueuedContainers(queuedOpportunisticContainers.size(),\n        queuedGuaranteedContainers.size());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "df800f6cf3ea663daf4081ebe784808b08d9366d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7240. Add more states and transitions to stabilize the NM Container state machine. (Kartheek Muthyala via asuresh)\n",
      "commitDate": "25/09/17 4:02 PM",
      "commitName": "df800f6cf3ea663daf4081ebe784808b08d9366d",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "14/09/17 8:51 AM",
      "commitNameOld": "4f8194430fc6a69d9cc99b78828fd7045d5683e8",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 11.3,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,36 @@\n   private void onResourcesReclaimed(Container container) {\n     oppContainersToKill.remove(container.getContainerId());\n \n     // This could be killed externally for eg. by the ContainerManager,\n     // in which case, the container might still be queued.\n     Container queued \u003d\n         queuedOpportunisticContainers.remove(container.getContainerId());\n     if (queued \u003d\u003d null) {\n       queuedGuaranteedContainers.remove(container.getContainerId());\n     }\n \n+    // Requeue PAUSED containers\n+    if (container.getContainerState() \u003d\u003d ContainerState.PAUSED) {\n+      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n+          ExecutionType.GUARANTEED) {\n+        queuedGuaranteedContainers.put(container.getContainerId(), container);\n+      } else {\n+        queuedOpportunisticContainers.put(\n+            container.getContainerId(), container);\n+      }\n+    }\n     // decrement only if it was a running container\n     Container completedContainer \u003d runningContainers.remove(container\n         .getContainerId());\n     // only a running container releases resources upon completion\n     boolean resourceReleased \u003d completedContainer !\u003d null;\n     if (resourceReleased) {\n       this.utilizationTracker.subtractContainerResource(container);\n       if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n           ExecutionType.OPPORTUNISTIC) {\n         this.metrics.completeOpportunisticContainer(container.getResource());\n       }\n-      startPendingContainers(false);\n+      boolean forceStartGuaranteedContainers \u003d (maxOppQueueLength \u003c\u003d 0);\n+      startPendingContainers(forceStartGuaranteedContainers);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void onResourcesReclaimed(Container container) {\n    oppContainersToKill.remove(container.getContainerId());\n\n    // This could be killed externally for eg. by the ContainerManager,\n    // in which case, the container might still be queued.\n    Container queued \u003d\n        queuedOpportunisticContainers.remove(container.getContainerId());\n    if (queued \u003d\u003d null) {\n      queuedGuaranteedContainers.remove(container.getContainerId());\n    }\n\n    // Requeue PAUSED containers\n    if (container.getContainerState() \u003d\u003d ContainerState.PAUSED) {\n      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n          ExecutionType.GUARANTEED) {\n        queuedGuaranteedContainers.put(container.getContainerId(), container);\n      } else {\n        queuedOpportunisticContainers.put(\n            container.getContainerId(), container);\n      }\n    }\n    // decrement only if it was a running container\n    Container completedContainer \u003d runningContainers.remove(container\n        .getContainerId());\n    // only a running container releases resources upon completion\n    boolean resourceReleased \u003d completedContainer !\u003d null;\n    if (resourceReleased) {\n      this.utilizationTracker.subtractContainerResource(container);\n      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n          ExecutionType.OPPORTUNISTIC) {\n        this.metrics.completeOpportunisticContainer(container.getResource());\n      }\n      boolean forceStartGuaranteedContainers \u003d (maxOppQueueLength \u003c\u003d 0);\n      startPendingContainers(forceStartGuaranteedContainers);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "4f8194430fc6a69d9cc99b78828fd7045d5683e8": {
      "type": "Yrename",
      "commitMessage": "YARN-5216. Expose configurable preemption policy for OPPORTUNISTIC containers running on the NM. (Hitesh Sharma via asuresh)\n",
      "commitDate": "14/09/17 8:51 AM",
      "commitName": "4f8194430fc6a69d9cc99b78828fd7045d5683e8",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "12/09/17 4:10 PM",
      "commitNameOld": "2ae72692fc370267141a1ee55ef372ff62302b54",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 1.7,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n-  private void onContainerCompleted(Container container) {\n+  private void onResourcesReclaimed(Container container) {\n     oppContainersToKill.remove(container.getContainerId());\n \n     // This could be killed externally for eg. by the ContainerManager,\n     // in which case, the container might still be queued.\n     Container queued \u003d\n         queuedOpportunisticContainers.remove(container.getContainerId());\n     if (queued \u003d\u003d null) {\n       queuedGuaranteedContainers.remove(container.getContainerId());\n     }\n \n     // decrement only if it was a running container\n     Container completedContainer \u003d runningContainers.remove(container\n         .getContainerId());\n     // only a running container releases resources upon completion\n     boolean resourceReleased \u003d completedContainer !\u003d null;\n     if (resourceReleased) {\n       this.utilizationTracker.subtractContainerResource(container);\n       if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n           ExecutionType.OPPORTUNISTIC) {\n         this.metrics.completeOpportunisticContainer(container.getResource());\n       }\n       startPendingContainers(false);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void onResourcesReclaimed(Container container) {\n    oppContainersToKill.remove(container.getContainerId());\n\n    // This could be killed externally for eg. by the ContainerManager,\n    // in which case, the container might still be queued.\n    Container queued \u003d\n        queuedOpportunisticContainers.remove(container.getContainerId());\n    if (queued \u003d\u003d null) {\n      queuedGuaranteedContainers.remove(container.getContainerId());\n    }\n\n    // decrement only if it was a running container\n    Container completedContainer \u003d runningContainers.remove(container\n        .getContainerId());\n    // only a running container releases resources upon completion\n    boolean resourceReleased \u003d completedContainer !\u003d null;\n    if (resourceReleased) {\n      this.utilizationTracker.subtractContainerResource(container);\n      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n          ExecutionType.OPPORTUNISTIC) {\n        this.metrics.completeOpportunisticContainer(container.getResource());\n      }\n      startPendingContainers(false);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {
        "oldValue": "onContainerCompleted",
        "newValue": "onResourcesReclaimed"
      }
    },
    "2ae72692fc370267141a1ee55ef372ff62302b54": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7185. ContainerScheduler should only look at availableResource for GUARANTEED containers when OPPORTUNISTIC container queuing is enabled. (Wangda Tan via asuresh)\n",
      "commitDate": "12/09/17 4:10 PM",
      "commitName": "2ae72692fc370267141a1ee55ef372ff62302b54",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "20/08/17 7:54 AM",
      "commitNameOld": "8410d862d3a72740f461ef91dddb5325955e1ca5",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 23.34,
      "commitsBetweenForRepo": 250,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n   private void onContainerCompleted(Container container) {\n     oppContainersToKill.remove(container.getContainerId());\n \n     // This could be killed externally for eg. by the ContainerManager,\n     // in which case, the container might still be queued.\n     Container queued \u003d\n         queuedOpportunisticContainers.remove(container.getContainerId());\n     if (queued \u003d\u003d null) {\n       queuedGuaranteedContainers.remove(container.getContainerId());\n     }\n \n     // decrement only if it was a running container\n     Container completedContainer \u003d runningContainers.remove(container\n         .getContainerId());\n     // only a running container releases resources upon completion\n     boolean resourceReleased \u003d completedContainer !\u003d null;\n     if (resourceReleased) {\n       this.utilizationTracker.subtractContainerResource(container);\n       if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n           ExecutionType.OPPORTUNISTIC) {\n         this.metrics.completeOpportunisticContainer(container.getResource());\n       }\n-      startPendingContainers();\n+      startPendingContainers(false);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void onContainerCompleted(Container container) {\n    oppContainersToKill.remove(container.getContainerId());\n\n    // This could be killed externally for eg. by the ContainerManager,\n    // in which case, the container might still be queued.\n    Container queued \u003d\n        queuedOpportunisticContainers.remove(container.getContainerId());\n    if (queued \u003d\u003d null) {\n      queuedGuaranteedContainers.remove(container.getContainerId());\n    }\n\n    // decrement only if it was a running container\n    Container completedContainer \u003d runningContainers.remove(container\n        .getContainerId());\n    // only a running container releases resources upon completion\n    boolean resourceReleased \u003d completedContainer !\u003d null;\n    if (resourceReleased) {\n      this.utilizationTracker.subtractContainerResource(container);\n      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n          ExecutionType.OPPORTUNISTIC) {\n        this.metrics.completeOpportunisticContainer(container.getResource());\n      }\n      startPendingContainers(false);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "5b007921cdf01ecc8ed97c164b7d327b8304c529": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6706. Refactor ContainerScheduler to make oversubscription change easier. (Haibo Chen via asuresh)\n",
      "commitDate": "17/07/17 2:11 PM",
      "commitName": "5b007921cdf01ecc8ed97c164b7d327b8304c529",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "16/12/16 8:14 AM",
      "commitNameOld": "2273a74c1f3895163046cca09ff5e983df301d22",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 213.21,
      "commitsBetweenForRepo": 1093,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,25 @@\n   private void onContainerCompleted(Container container) {\n     oppContainersToKill.remove(container.getContainerId());\n \n     // This could be killed externally for eg. by the ContainerManager,\n     // in which case, the container might still be queued.\n     Container queued \u003d\n         queuedOpportunisticContainers.remove(container.getContainerId());\n     if (queued \u003d\u003d null) {\n       queuedGuaranteedContainers.remove(container.getContainerId());\n     }\n \n     // decrement only if it was a running container\n     Container completedContainer \u003d runningContainers.remove(container\n         .getContainerId());\n-    if (completedContainer !\u003d null) {\n+    // only a running container releases resources upon completion\n+    boolean resourceReleased \u003d completedContainer !\u003d null;\n+    if (resourceReleased) {\n       this.utilizationTracker.subtractContainerResource(container);\n       if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n           ExecutionType.OPPORTUNISTIC) {\n         this.metrics.completeOpportunisticContainer(container.getResource());\n       }\n       startPendingContainers();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void onContainerCompleted(Container container) {\n    oppContainersToKill.remove(container.getContainerId());\n\n    // This could be killed externally for eg. by the ContainerManager,\n    // in which case, the container might still be queued.\n    Container queued \u003d\n        queuedOpportunisticContainers.remove(container.getContainerId());\n    if (queued \u003d\u003d null) {\n      queuedGuaranteedContainers.remove(container.getContainerId());\n    }\n\n    // decrement only if it was a running container\n    Container completedContainer \u003d runningContainers.remove(container\n        .getContainerId());\n    // only a running container releases resources upon completion\n    boolean resourceReleased \u003d completedContainer !\u003d null;\n    if (resourceReleased) {\n      this.utilizationTracker.subtractContainerResource(container);\n      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n          ExecutionType.OPPORTUNISTIC) {\n        this.metrics.completeOpportunisticContainer(container.getResource());\n      }\n      startPendingContainers();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "b0aace21b1ef3436ba9d516186208fee9a9ceef2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5982. Simplify opportunistic container parameters and metrics. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "09/12/16 4:41 PM",
      "commitName": "b0aace21b1ef3436ba9d516186208fee9a9ceef2",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "15/11/16 7:56 AM",
      "commitNameOld": "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 24.36,
      "commitsBetweenForRepo": 162,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   private void onContainerCompleted(Container container) {\n     oppContainersToKill.remove(container.getContainerId());\n \n     // This could be killed externally for eg. by the ContainerManager,\n     // in which case, the container might still be queued.\n     Container queued \u003d\n         queuedOpportunisticContainers.remove(container.getContainerId());\n     if (queued \u003d\u003d null) {\n       queuedGuaranteedContainers.remove(container.getContainerId());\n     }\n \n     // decrement only if it was a running container\n     Container completedContainer \u003d runningContainers.remove(container\n         .getContainerId());\n     if (completedContainer !\u003d null) {\n       this.utilizationTracker.subtractContainerResource(container);\n       if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n           ExecutionType.OPPORTUNISTIC) {\n-        this.metrics.opportunisticContainerCompleted(container);\n+        this.metrics.completeOpportunisticContainer(container.getResource());\n       }\n       startPendingContainers();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void onContainerCompleted(Container container) {\n    oppContainersToKill.remove(container.getContainerId());\n\n    // This could be killed externally for eg. by the ContainerManager,\n    // in which case, the container might still be queued.\n    Container queued \u003d\n        queuedOpportunisticContainers.remove(container.getContainerId());\n    if (queued \u003d\u003d null) {\n      queuedGuaranteedContainers.remove(container.getContainerId());\n    }\n\n    // decrement only if it was a running container\n    Container completedContainer \u003d runningContainers.remove(container\n        .getContainerId());\n    if (completedContainer !\u003d null) {\n      this.utilizationTracker.subtractContainerResource(container);\n      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n          ExecutionType.OPPORTUNISTIC) {\n        this.metrics.completeOpportunisticContainer(container.getResource());\n      }\n      startPendingContainers();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4597. Introduce ContainerScheduler and a SCHEDULED state to NodeManager container lifecycle. (asuresh)\n",
      "commitDate": "15/11/16 7:56 AM",
      "commitName": "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,23 @@\n+  private void onContainerCompleted(Container container) {\n+    oppContainersToKill.remove(container.getContainerId());\n+\n+    // This could be killed externally for eg. by the ContainerManager,\n+    // in which case, the container might still be queued.\n+    Container queued \u003d\n+        queuedOpportunisticContainers.remove(container.getContainerId());\n+    if (queued \u003d\u003d null) {\n+      queuedGuaranteedContainers.remove(container.getContainerId());\n+    }\n+\n+    // decrement only if it was a running container\n+    Container completedContainer \u003d runningContainers.remove(container\n+        .getContainerId());\n+    if (completedContainer !\u003d null) {\n+      this.utilizationTracker.subtractContainerResource(container);\n+      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n+          ExecutionType.OPPORTUNISTIC) {\n+        this.metrics.opportunisticContainerCompleted(container);\n+      }\n+      startPendingContainers();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void onContainerCompleted(Container container) {\n    oppContainersToKill.remove(container.getContainerId());\n\n    // This could be killed externally for eg. by the ContainerManager,\n    // in which case, the container might still be queued.\n    Container queued \u003d\n        queuedOpportunisticContainers.remove(container.getContainerId());\n    if (queued \u003d\u003d null) {\n      queuedGuaranteedContainers.remove(container.getContainerId());\n    }\n\n    // decrement only if it was a running container\n    Container completedContainer \u003d runningContainers.remove(container\n        .getContainerId());\n    if (completedContainer !\u003d null) {\n      this.utilizationTracker.subtractContainerResource(container);\n      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n          ExecutionType.OPPORTUNISTIC) {\n        this.metrics.opportunisticContainerCompleted(container);\n      }\n      startPendingContainers();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java"
    }
  }
}