{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FederationInterceptor.java",
  "functionName": "reAttachUAMAndMergeRegisterResponse",
  "functionId": "reAttachUAMAndMergeRegisterResponse___homeResponse-RegisterApplicationMasterResponse__appId-ApplicationId(modifiers-final)",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
  "functionStartLine": 962,
  "functionEndLine": 1050,
  "numCommitsSeen": 21,
  "timeTaken": 3491,
  "changeHistory": [
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
    "3090922805699b8374a359e92323884a4177dc4e",
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f",
    "d5f66888b8d767ee6706fab9950c194a1bf26d32"
  ],
  "changeHistoryShort": {
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": "Ybodychange",
    "3090922805699b8374a359e92323884a4177dc4e": "Ybodychange",
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": "Ybodychange",
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f": "Ybodychange",
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8933. [AMRMProxy] Fix potential empty fields in allocation response, move SubClusterTimeout to FederationInterceptor. Contributed by Botong Huang.\n",
      "commitDate": "11/11/18 11:12 AM",
      "commitName": "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
      "commitAuthor": "Botong Huang",
      "commitDateOld": "02/11/18 3:30 PM",
      "commitNameOld": "989715ec5066c6ac7868e25ad9234dc64723e61e",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 8.86,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,89 @@\n   protected void reAttachUAMAndMergeRegisterResponse(\n       RegisterApplicationMasterResponse homeResponse,\n       final ApplicationId appId) {\n \n     if (this.registryClient \u003d\u003d null) {\n       // Both AMRMProxy HA and NM work preserving restart is not enabled\n       LOG.warn(\"registryClient is null, skip attaching existing UAM if any\");\n       return;\n     }\n \n     // Load existing running UAMs from the previous attempts from\n     // registry, if any\n     Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap \u003d\n         this.registryClient.loadStateFromRegistry(appId);\n     if (uamMap.size() \u003d\u003d 0) {\n       LOG.info(\"No existing UAM for application {} found in Yarn Registry\",\n           appId);\n       return;\n     }\n     LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry. \"\n         + \"Reattaching in parallel\", uamMap.size(), appId);\n \n     ExecutorCompletionService\u003cRegisterApplicationMasterResponse\u003e\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(this.threadpool);\n \n     for (Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap.entrySet()) {\n       final SubClusterId subClusterId \u003d\n           SubClusterId.newInstance(entry.getKey());\n       final Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d entry.getValue();\n \n       completionService\n           .submit(new Callable\u003cRegisterApplicationMasterResponse\u003e() {\n             @Override\n             public RegisterApplicationMasterResponse call() throws Exception {\n               RegisterApplicationMasterResponse response \u003d null;\n               try {\n                 // Create a config loaded with federation on and subclusterId\n                 // for each UAM\n                 YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                 FederationProxyProviderUtil.updateConfForFederation(config,\n                     subClusterId.getId());\n \n                 uamPool.reAttachUAM(subClusterId.getId(), config, appId,\n                     amRegistrationResponse.getQueue(),\n                     getApplicationContext().getUser(), homeSubClusterId.getId(),\n                     amrmToken, subClusterId.toString());\n \n                 secondaryRelayers.put(subClusterId.getId(),\n                     uamPool.getAMRMClientRelayer(subClusterId.getId()));\n \n                 response \u003d uamPool.registerApplicationMaster(\n                     subClusterId.getId(), amRegistrationRequest);\n \n+                // Set sub-cluster to be timed out initially\n+                lastSCResponseTime.put(subClusterId,\n+                    clock.getTime() - subClusterTimeOut);\n+\n                 if (response !\u003d null\n                     \u0026\u0026 response.getContainersFromPreviousAttempts() !\u003d null) {\n                   cacheAllocatedContainers(\n                       response.getContainersFromPreviousAttempts(),\n                       subClusterId);\n                 }\n                 LOG.info(\"UAM {} reattached for {}\", subClusterId, appId);\n               } catch (Throwable e) {\n                 LOG.error(\n                     \"Reattaching UAM \" + subClusterId + \" failed for \" + appId,\n                     e);\n               }\n               return response;\n             }\n           });\n     }\n \n     // Wait for the re-attach responses\n     for (int i \u003d 0; i \u003c uamMap.size(); i++) {\n       try {\n         Future\u003cRegisterApplicationMasterResponse\u003e future \u003d\n             completionService.take();\n         RegisterApplicationMasterResponse registerResponse \u003d future.get();\n         if (registerResponse !\u003d null) {\n           LOG.info(\"Merging register response for {}\", appId);\n           mergeRegisterResponse(homeResponse, registerResponse);\n         }\n       } catch (Exception e) {\n         LOG.warn(\"Reattaching UAM failed for ApplicationId: \" + appId, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void reAttachUAMAndMergeRegisterResponse(\n      RegisterApplicationMasterResponse homeResponse,\n      final ApplicationId appId) {\n\n    if (this.registryClient \u003d\u003d null) {\n      // Both AMRMProxy HA and NM work preserving restart is not enabled\n      LOG.warn(\"registryClient is null, skip attaching existing UAM if any\");\n      return;\n    }\n\n    // Load existing running UAMs from the previous attempts from\n    // registry, if any\n    Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap \u003d\n        this.registryClient.loadStateFromRegistry(appId);\n    if (uamMap.size() \u003d\u003d 0) {\n      LOG.info(\"No existing UAM for application {} found in Yarn Registry\",\n          appId);\n      return;\n    }\n    LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry. \"\n        + \"Reattaching in parallel\", uamMap.size(), appId);\n\n    ExecutorCompletionService\u003cRegisterApplicationMasterResponse\u003e\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(this.threadpool);\n\n    for (Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap.entrySet()) {\n      final SubClusterId subClusterId \u003d\n          SubClusterId.newInstance(entry.getKey());\n      final Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d entry.getValue();\n\n      completionService\n          .submit(new Callable\u003cRegisterApplicationMasterResponse\u003e() {\n            @Override\n            public RegisterApplicationMasterResponse call() throws Exception {\n              RegisterApplicationMasterResponse response \u003d null;\n              try {\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId.getId());\n\n                uamPool.reAttachUAM(subClusterId.getId(), config, appId,\n                    amRegistrationResponse.getQueue(),\n                    getApplicationContext().getUser(), homeSubClusterId.getId(),\n                    amrmToken, subClusterId.toString());\n\n                secondaryRelayers.put(subClusterId.getId(),\n                    uamPool.getAMRMClientRelayer(subClusterId.getId()));\n\n                response \u003d uamPool.registerApplicationMaster(\n                    subClusterId.getId(), amRegistrationRequest);\n\n                // Set sub-cluster to be timed out initially\n                lastSCResponseTime.put(subClusterId,\n                    clock.getTime() - subClusterTimeOut);\n\n                if (response !\u003d null\n                    \u0026\u0026 response.getContainersFromPreviousAttempts() !\u003d null) {\n                  cacheAllocatedContainers(\n                      response.getContainersFromPreviousAttempts(),\n                      subClusterId);\n                }\n                LOG.info(\"UAM {} reattached for {}\", subClusterId, appId);\n              } catch (Throwable e) {\n                LOG.error(\n                    \"Reattaching UAM \" + subClusterId + \" failed for \" + appId,\n                    e);\n              }\n              return response;\n            }\n          });\n    }\n\n    // Wait for the re-attach responses\n    for (int i \u003d 0; i \u003c uamMap.size(); i++) {\n      try {\n        Future\u003cRegisterApplicationMasterResponse\u003e future \u003d\n            completionService.take();\n        RegisterApplicationMasterResponse registerResponse \u003d future.get();\n        if (registerResponse !\u003d null) {\n          LOG.info(\"Merging register response for {}\", appId);\n          mergeRegisterResponse(homeResponse, registerResponse);\n        }\n      } catch (Exception e) {\n        LOG.warn(\"Reattaching UAM failed for ApplicationId: \" + appId, e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "3090922805699b8374a359e92323884a4177dc4e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8696. [AMRMProxy] FederationInterceptor upgrade: home sub-cluster heartbeat async. Contributed by Botong Huang.\n",
      "commitDate": "24/09/18 11:37 AM",
      "commitName": "3090922805699b8374a359e92323884a4177dc4e",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "12/09/18 11:46 AM",
      "commitNameOld": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 11.99,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n   protected void reAttachUAMAndMergeRegisterResponse(\n       RegisterApplicationMasterResponse homeResponse,\n       final ApplicationId appId) {\n \n     if (this.registryClient \u003d\u003d null) {\n       // Both AMRMProxy HA and NM work preserving restart is not enabled\n       LOG.warn(\"registryClient is null, skip attaching existing UAM if any\");\n       return;\n     }\n \n     // Load existing running UAMs from the previous attempts from\n     // registry, if any\n     Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap \u003d\n         this.registryClient.loadStateFromRegistry(appId);\n     if (uamMap.size() \u003d\u003d 0) {\n       LOG.info(\"No existing UAM for application {} found in Yarn Registry\",\n           appId);\n       return;\n     }\n     LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry. \"\n         + \"Reattaching in parallel\", uamMap.size(), appId);\n \n     ExecutorCompletionService\u003cRegisterApplicationMasterResponse\u003e\n-        completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n+        completionService \u003d new ExecutorCompletionService\u003c\u003e(this.threadpool);\n \n     for (Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap.entrySet()) {\n       final SubClusterId subClusterId \u003d\n           SubClusterId.newInstance(entry.getKey());\n       final Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d entry.getValue();\n \n       completionService\n           .submit(new Callable\u003cRegisterApplicationMasterResponse\u003e() {\n             @Override\n             public RegisterApplicationMasterResponse call() throws Exception {\n               RegisterApplicationMasterResponse response \u003d null;\n               try {\n                 // Create a config loaded with federation on and subclusterId\n                 // for each UAM\n                 YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                 FederationProxyProviderUtil.updateConfForFederation(config,\n                     subClusterId.getId());\n \n                 uamPool.reAttachUAM(subClusterId.getId(), config, appId,\n                     amRegistrationResponse.getQueue(),\n                     getApplicationContext().getUser(), homeSubClusterId.getId(),\n                     amrmToken, subClusterId.toString());\n \n                 secondaryRelayers.put(subClusterId.getId(),\n                     uamPool.getAMRMClientRelayer(subClusterId.getId()));\n \n                 response \u003d uamPool.registerApplicationMaster(\n                     subClusterId.getId(), amRegistrationRequest);\n \n                 if (response !\u003d null\n                     \u0026\u0026 response.getContainersFromPreviousAttempts() !\u003d null) {\n                   cacheAllocatedContainers(\n                       response.getContainersFromPreviousAttempts(),\n                       subClusterId);\n                 }\n                 LOG.info(\"UAM {} reattached for {}\", subClusterId, appId);\n               } catch (Throwable e) {\n                 LOG.error(\n                     \"Reattaching UAM \" + subClusterId + \" failed for \" + appId,\n                     e);\n               }\n               return response;\n             }\n           });\n     }\n \n     // Wait for the re-attach responses\n     for (int i \u003d 0; i \u003c uamMap.size(); i++) {\n       try {\n         Future\u003cRegisterApplicationMasterResponse\u003e future \u003d\n             completionService.take();\n         RegisterApplicationMasterResponse registerResponse \u003d future.get();\n         if (registerResponse !\u003d null) {\n           LOG.info(\"Merging register response for {}\", appId);\n           mergeRegisterResponse(homeResponse, registerResponse);\n         }\n       } catch (Exception e) {\n         LOG.warn(\"Reattaching UAM failed for ApplicationId: \" + appId, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void reAttachUAMAndMergeRegisterResponse(\n      RegisterApplicationMasterResponse homeResponse,\n      final ApplicationId appId) {\n\n    if (this.registryClient \u003d\u003d null) {\n      // Both AMRMProxy HA and NM work preserving restart is not enabled\n      LOG.warn(\"registryClient is null, skip attaching existing UAM if any\");\n      return;\n    }\n\n    // Load existing running UAMs from the previous attempts from\n    // registry, if any\n    Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap \u003d\n        this.registryClient.loadStateFromRegistry(appId);\n    if (uamMap.size() \u003d\u003d 0) {\n      LOG.info(\"No existing UAM for application {} found in Yarn Registry\",\n          appId);\n      return;\n    }\n    LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry. \"\n        + \"Reattaching in parallel\", uamMap.size(), appId);\n\n    ExecutorCompletionService\u003cRegisterApplicationMasterResponse\u003e\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(this.threadpool);\n\n    for (Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap.entrySet()) {\n      final SubClusterId subClusterId \u003d\n          SubClusterId.newInstance(entry.getKey());\n      final Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d entry.getValue();\n\n      completionService\n          .submit(new Callable\u003cRegisterApplicationMasterResponse\u003e() {\n            @Override\n            public RegisterApplicationMasterResponse call() throws Exception {\n              RegisterApplicationMasterResponse response \u003d null;\n              try {\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId.getId());\n\n                uamPool.reAttachUAM(subClusterId.getId(), config, appId,\n                    amRegistrationResponse.getQueue(),\n                    getApplicationContext().getUser(), homeSubClusterId.getId(),\n                    amrmToken, subClusterId.toString());\n\n                secondaryRelayers.put(subClusterId.getId(),\n                    uamPool.getAMRMClientRelayer(subClusterId.getId()));\n\n                response \u003d uamPool.registerApplicationMaster(\n                    subClusterId.getId(), amRegistrationRequest);\n\n                if (response !\u003d null\n                    \u0026\u0026 response.getContainersFromPreviousAttempts() !\u003d null) {\n                  cacheAllocatedContainers(\n                      response.getContainersFromPreviousAttempts(),\n                      subClusterId);\n                }\n                LOG.info(\"UAM {} reattached for {}\", subClusterId, appId);\n              } catch (Throwable e) {\n                LOG.error(\n                    \"Reattaching UAM \" + subClusterId + \" failed for \" + appId,\n                    e);\n              }\n              return response;\n            }\n          });\n    }\n\n    // Wait for the re-attach responses\n    for (int i \u003d 0; i \u003c uamMap.size(); i++) {\n      try {\n        Future\u003cRegisterApplicationMasterResponse\u003e future \u003d\n            completionService.take();\n        RegisterApplicationMasterResponse registerResponse \u003d future.get();\n        if (registerResponse !\u003d null) {\n          LOG.info(\"Merging register response for {}\", appId);\n          mergeRegisterResponse(homeResponse, registerResponse);\n        }\n      } catch (Exception e) {\n        LOG.warn(\"Reattaching UAM failed for ApplicationId: \" + appId, e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8658. [AMRMProxy] Metrics for AMRMClientRelayer inside FederationInterceptor. Contributed by Young Chen.\n",
      "commitDate": "12/09/18 11:46 AM",
      "commitName": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "27/08/18 10:32 AM",
      "commitNameOld": "f1525825623a1307b5aa55c456b6afa3e0c61135",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 16.05,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n   protected void reAttachUAMAndMergeRegisterResponse(\n       RegisterApplicationMasterResponse homeResponse,\n       final ApplicationId appId) {\n \n     if (this.registryClient \u003d\u003d null) {\n       // Both AMRMProxy HA and NM work preserving restart is not enabled\n       LOG.warn(\"registryClient is null, skip attaching existing UAM if any\");\n       return;\n     }\n \n     // Load existing running UAMs from the previous attempts from\n     // registry, if any\n     Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap \u003d\n         this.registryClient.loadStateFromRegistry(appId);\n     if (uamMap.size() \u003d\u003d 0) {\n       LOG.info(\"No existing UAM for application {} found in Yarn Registry\",\n           appId);\n       return;\n     }\n     LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry. \"\n         + \"Reattaching in parallel\", uamMap.size(), appId);\n \n     ExecutorCompletionService\u003cRegisterApplicationMasterResponse\u003e\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n \n     for (Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap.entrySet()) {\n       final SubClusterId subClusterId \u003d\n           SubClusterId.newInstance(entry.getKey());\n       final Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d entry.getValue();\n \n       completionService\n           .submit(new Callable\u003cRegisterApplicationMasterResponse\u003e() {\n             @Override\n             public RegisterApplicationMasterResponse call() throws Exception {\n               RegisterApplicationMasterResponse response \u003d null;\n               try {\n                 // Create a config loaded with federation on and subclusterId\n                 // for each UAM\n                 YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                 FederationProxyProviderUtil.updateConfForFederation(config,\n                     subClusterId.getId());\n \n                 uamPool.reAttachUAM(subClusterId.getId(), config, appId,\n                     amRegistrationResponse.getQueue(),\n                     getApplicationContext().getUser(), homeSubClusterId.getId(),\n-                    amrmToken);\n+                    amrmToken, subClusterId.toString());\n \n                 secondaryRelayers.put(subClusterId.getId(),\n                     uamPool.getAMRMClientRelayer(subClusterId.getId()));\n \n                 response \u003d uamPool.registerApplicationMaster(\n                     subClusterId.getId(), amRegistrationRequest);\n \n                 if (response !\u003d null\n                     \u0026\u0026 response.getContainersFromPreviousAttempts() !\u003d null) {\n                   cacheAllocatedContainers(\n                       response.getContainersFromPreviousAttempts(),\n                       subClusterId);\n                 }\n                 LOG.info(\"UAM {} reattached for {}\", subClusterId, appId);\n               } catch (Throwable e) {\n                 LOG.error(\n                     \"Reattaching UAM \" + subClusterId + \" failed for \" + appId,\n                     e);\n               }\n               return response;\n             }\n           });\n     }\n \n     // Wait for the re-attach responses\n     for (int i \u003d 0; i \u003c uamMap.size(); i++) {\n       try {\n         Future\u003cRegisterApplicationMasterResponse\u003e future \u003d\n             completionService.take();\n         RegisterApplicationMasterResponse registerResponse \u003d future.get();\n         if (registerResponse !\u003d null) {\n           LOG.info(\"Merging register response for {}\", appId);\n           mergeRegisterResponse(homeResponse, registerResponse);\n         }\n       } catch (Exception e) {\n         LOG.warn(\"Reattaching UAM failed for ApplicationId: \" + appId, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void reAttachUAMAndMergeRegisterResponse(\n      RegisterApplicationMasterResponse homeResponse,\n      final ApplicationId appId) {\n\n    if (this.registryClient \u003d\u003d null) {\n      // Both AMRMProxy HA and NM work preserving restart is not enabled\n      LOG.warn(\"registryClient is null, skip attaching existing UAM if any\");\n      return;\n    }\n\n    // Load existing running UAMs from the previous attempts from\n    // registry, if any\n    Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap \u003d\n        this.registryClient.loadStateFromRegistry(appId);\n    if (uamMap.size() \u003d\u003d 0) {\n      LOG.info(\"No existing UAM for application {} found in Yarn Registry\",\n          appId);\n      return;\n    }\n    LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry. \"\n        + \"Reattaching in parallel\", uamMap.size(), appId);\n\n    ExecutorCompletionService\u003cRegisterApplicationMasterResponse\u003e\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n\n    for (Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap.entrySet()) {\n      final SubClusterId subClusterId \u003d\n          SubClusterId.newInstance(entry.getKey());\n      final Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d entry.getValue();\n\n      completionService\n          .submit(new Callable\u003cRegisterApplicationMasterResponse\u003e() {\n            @Override\n            public RegisterApplicationMasterResponse call() throws Exception {\n              RegisterApplicationMasterResponse response \u003d null;\n              try {\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId.getId());\n\n                uamPool.reAttachUAM(subClusterId.getId(), config, appId,\n                    amRegistrationResponse.getQueue(),\n                    getApplicationContext().getUser(), homeSubClusterId.getId(),\n                    amrmToken, subClusterId.toString());\n\n                secondaryRelayers.put(subClusterId.getId(),\n                    uamPool.getAMRMClientRelayer(subClusterId.getId()));\n\n                response \u003d uamPool.registerApplicationMaster(\n                    subClusterId.getId(), amRegistrationRequest);\n\n                if (response !\u003d null\n                    \u0026\u0026 response.getContainersFromPreviousAttempts() !\u003d null) {\n                  cacheAllocatedContainers(\n                      response.getContainersFromPreviousAttempts(),\n                      subClusterId);\n                }\n                LOG.info(\"UAM {} reattached for {}\", subClusterId, appId);\n              } catch (Throwable e) {\n                LOG.error(\n                    \"Reattaching UAM \" + subClusterId + \" failed for \" + appId,\n                    e);\n              }\n              return response;\n            }\n          });\n    }\n\n    // Wait for the re-attach responses\n    for (int i \u003d 0; i \u003c uamMap.size(); i++) {\n      try {\n        Future\u003cRegisterApplicationMasterResponse\u003e future \u003d\n            completionService.take();\n        RegisterApplicationMasterResponse registerResponse \u003d future.get();\n        if (registerResponse !\u003d null) {\n          LOG.info(\"Merging register response for {}\", appId);\n          mergeRegisterResponse(homeResponse, registerResponse);\n        }\n      } catch (Exception e) {\n        LOG.warn(\"Reattaching UAM failed for ApplicationId: \" + appId, e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7899. [AMRMProxy] Stateful FederationInterceptor for pending requests. Contributed by Botong Huang.\n",
      "commitDate": "09/07/18 12:27 PM",
      "commitName": "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "17/05/18 8:00 PM",
      "commitNameOld": "3159bffce23abf35754da2d7d51de7d8c2631ae3",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 52.69,
      "commitsBetweenForRepo": 338,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,85 @@\n   protected void reAttachUAMAndMergeRegisterResponse(\n       RegisterApplicationMasterResponse homeResponse,\n       final ApplicationId appId) {\n \n     if (this.registryClient \u003d\u003d null) {\n       // Both AMRMProxy HA and NM work preserving restart is not enabled\n       LOG.warn(\"registryClient is null, skip attaching existing UAM if any\");\n       return;\n     }\n \n     // Load existing running UAMs from the previous attempts from\n     // registry, if any\n     Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap \u003d\n         this.registryClient.loadStateFromRegistry(appId);\n     if (uamMap.size() \u003d\u003d 0) {\n       LOG.info(\"No existing UAM for application {} found in Yarn Registry\",\n           appId);\n       return;\n     }\n     LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry. \"\n         + \"Reattaching in parallel\", uamMap.size(), appId);\n \n     ExecutorCompletionService\u003cRegisterApplicationMasterResponse\u003e\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n \n     for (Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap.entrySet()) {\n       final SubClusterId subClusterId \u003d\n           SubClusterId.newInstance(entry.getKey());\n       final Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d entry.getValue();\n \n       completionService\n           .submit(new Callable\u003cRegisterApplicationMasterResponse\u003e() {\n             @Override\n             public RegisterApplicationMasterResponse call() throws Exception {\n               RegisterApplicationMasterResponse response \u003d null;\n               try {\n                 // Create a config loaded with federation on and subclusterId\n                 // for each UAM\n                 YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                 FederationProxyProviderUtil.updateConfForFederation(config,\n                     subClusterId.getId());\n \n                 uamPool.reAttachUAM(subClusterId.getId(), config, appId,\n                     amRegistrationResponse.getQueue(),\n                     getApplicationContext().getUser(), homeSubClusterId.getId(),\n                     amrmToken);\n \n+                secondaryRelayers.put(subClusterId.getId(),\n+                    uamPool.getAMRMClientRelayer(subClusterId.getId()));\n+\n                 response \u003d uamPool.registerApplicationMaster(\n                     subClusterId.getId(), amRegistrationRequest);\n \n                 if (response !\u003d null\n                     \u0026\u0026 response.getContainersFromPreviousAttempts() !\u003d null) {\n                   cacheAllocatedContainers(\n                       response.getContainersFromPreviousAttempts(),\n                       subClusterId);\n                 }\n                 LOG.info(\"UAM {} reattached for {}\", subClusterId, appId);\n               } catch (Throwable e) {\n                 LOG.error(\n                     \"Reattaching UAM \" + subClusterId + \" failed for \" + appId,\n                     e);\n               }\n               return response;\n             }\n           });\n     }\n \n     // Wait for the re-attach responses\n     for (int i \u003d 0; i \u003c uamMap.size(); i++) {\n       try {\n         Future\u003cRegisterApplicationMasterResponse\u003e future \u003d\n             completionService.take();\n         RegisterApplicationMasterResponse registerResponse \u003d future.get();\n         if (registerResponse !\u003d null) {\n           LOG.info(\"Merging register response for {}\", appId);\n           mergeRegisterResponse(homeResponse, registerResponse);\n         }\n       } catch (Exception e) {\n         LOG.warn(\"Reattaching UAM failed for ApplicationId: \" + appId, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void reAttachUAMAndMergeRegisterResponse(\n      RegisterApplicationMasterResponse homeResponse,\n      final ApplicationId appId) {\n\n    if (this.registryClient \u003d\u003d null) {\n      // Both AMRMProxy HA and NM work preserving restart is not enabled\n      LOG.warn(\"registryClient is null, skip attaching existing UAM if any\");\n      return;\n    }\n\n    // Load existing running UAMs from the previous attempts from\n    // registry, if any\n    Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap \u003d\n        this.registryClient.loadStateFromRegistry(appId);\n    if (uamMap.size() \u003d\u003d 0) {\n      LOG.info(\"No existing UAM for application {} found in Yarn Registry\",\n          appId);\n      return;\n    }\n    LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry. \"\n        + \"Reattaching in parallel\", uamMap.size(), appId);\n\n    ExecutorCompletionService\u003cRegisterApplicationMasterResponse\u003e\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n\n    for (Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap.entrySet()) {\n      final SubClusterId subClusterId \u003d\n          SubClusterId.newInstance(entry.getKey());\n      final Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d entry.getValue();\n\n      completionService\n          .submit(new Callable\u003cRegisterApplicationMasterResponse\u003e() {\n            @Override\n            public RegisterApplicationMasterResponse call() throws Exception {\n              RegisterApplicationMasterResponse response \u003d null;\n              try {\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId.getId());\n\n                uamPool.reAttachUAM(subClusterId.getId(), config, appId,\n                    amRegistrationResponse.getQueue(),\n                    getApplicationContext().getUser(), homeSubClusterId.getId(),\n                    amrmToken);\n\n                secondaryRelayers.put(subClusterId.getId(),\n                    uamPool.getAMRMClientRelayer(subClusterId.getId()));\n\n                response \u003d uamPool.registerApplicationMaster(\n                    subClusterId.getId(), amRegistrationRequest);\n\n                if (response !\u003d null\n                    \u0026\u0026 response.getContainersFromPreviousAttempts() !\u003d null) {\n                  cacheAllocatedContainers(\n                      response.getContainersFromPreviousAttempts(),\n                      subClusterId);\n                }\n                LOG.info(\"UAM {} reattached for {}\", subClusterId, appId);\n              } catch (Throwable e) {\n                LOG.error(\n                    \"Reattaching UAM \" + subClusterId + \" failed for \" + appId,\n                    e);\n              }\n              return response;\n            }\n          });\n    }\n\n    // Wait for the re-attach responses\n    for (int i \u003d 0; i \u003c uamMap.size(); i++) {\n      try {\n        Future\u003cRegisterApplicationMasterResponse\u003e future \u003d\n            completionService.take();\n        RegisterApplicationMasterResponse registerResponse \u003d future.get();\n        if (registerResponse !\u003d null) {\n          LOG.info(\"Merging register response for {}\", appId);\n          mergeRegisterResponse(homeResponse, registerResponse);\n        }\n      } catch (Exception e) {\n        LOG.warn(\"Reattaching UAM failed for ApplicationId: \" + appId, e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6128. Add support for AMRMProxy HA. (Botong Huang via Subru).\n",
      "commitDate": "17/11/17 5:39 PM",
      "commitName": "d5f66888b8d767ee6706fab9950c194a1bf26d32",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,82 @@\n+  protected void reAttachUAMAndMergeRegisterResponse(\n+      RegisterApplicationMasterResponse homeResponse,\n+      final ApplicationId appId) {\n+\n+    if (this.registryClient \u003d\u003d null) {\n+      // Both AMRMProxy HA and NM work preserving restart is not enabled\n+      LOG.warn(\"registryClient is null, skip attaching existing UAM if any\");\n+      return;\n+    }\n+\n+    // Load existing running UAMs from the previous attempts from\n+    // registry, if any\n+    Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap \u003d\n+        this.registryClient.loadStateFromRegistry(appId);\n+    if (uamMap.size() \u003d\u003d 0) {\n+      LOG.info(\"No existing UAM for application {} found in Yarn Registry\",\n+          appId);\n+      return;\n+    }\n+    LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry. \"\n+        + \"Reattaching in parallel\", uamMap.size(), appId);\n+\n+    ExecutorCompletionService\u003cRegisterApplicationMasterResponse\u003e\n+        completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n+\n+    for (Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap.entrySet()) {\n+      final SubClusterId subClusterId \u003d\n+          SubClusterId.newInstance(entry.getKey());\n+      final Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d entry.getValue();\n+\n+      completionService\n+          .submit(new Callable\u003cRegisterApplicationMasterResponse\u003e() {\n+            @Override\n+            public RegisterApplicationMasterResponse call() throws Exception {\n+              RegisterApplicationMasterResponse response \u003d null;\n+              try {\n+                // Create a config loaded with federation on and subclusterId\n+                // for each UAM\n+                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n+                FederationProxyProviderUtil.updateConfForFederation(config,\n+                    subClusterId.getId());\n+\n+                uamPool.reAttachUAM(subClusterId.getId(), config, appId,\n+                    amRegistrationResponse.getQueue(),\n+                    getApplicationContext().getUser(), homeSubClusterId.getId(),\n+                    amrmToken);\n+\n+                response \u003d uamPool.registerApplicationMaster(\n+                    subClusterId.getId(), amRegistrationRequest);\n+\n+                if (response !\u003d null\n+                    \u0026\u0026 response.getContainersFromPreviousAttempts() !\u003d null) {\n+                  cacheAllocatedContainers(\n+                      response.getContainersFromPreviousAttempts(),\n+                      subClusterId);\n+                }\n+                LOG.info(\"UAM {} reattached for {}\", subClusterId, appId);\n+              } catch (Throwable e) {\n+                LOG.error(\n+                    \"Reattaching UAM \" + subClusterId + \" failed for \" + appId,\n+                    e);\n+              }\n+              return response;\n+            }\n+          });\n+    }\n+\n+    // Wait for the re-attach responses\n+    for (int i \u003d 0; i \u003c uamMap.size(); i++) {\n+      try {\n+        Future\u003cRegisterApplicationMasterResponse\u003e future \u003d\n+            completionService.take();\n+        RegisterApplicationMasterResponse registerResponse \u003d future.get();\n+        if (registerResponse !\u003d null) {\n+          LOG.info(\"Merging register response for {}\", appId);\n+          mergeRegisterResponse(homeResponse, registerResponse);\n+        }\n+      } catch (Exception e) {\n+        LOG.warn(\"Reattaching UAM failed for ApplicationId: \" + appId, e);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void reAttachUAMAndMergeRegisterResponse(\n      RegisterApplicationMasterResponse homeResponse,\n      final ApplicationId appId) {\n\n    if (this.registryClient \u003d\u003d null) {\n      // Both AMRMProxy HA and NM work preserving restart is not enabled\n      LOG.warn(\"registryClient is null, skip attaching existing UAM if any\");\n      return;\n    }\n\n    // Load existing running UAMs from the previous attempts from\n    // registry, if any\n    Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap \u003d\n        this.registryClient.loadStateFromRegistry(appId);\n    if (uamMap.size() \u003d\u003d 0) {\n      LOG.info(\"No existing UAM for application {} found in Yarn Registry\",\n          appId);\n      return;\n    }\n    LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry. \"\n        + \"Reattaching in parallel\", uamMap.size(), appId);\n\n    ExecutorCompletionService\u003cRegisterApplicationMasterResponse\u003e\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(threadpool);\n\n    for (Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap.entrySet()) {\n      final SubClusterId subClusterId \u003d\n          SubClusterId.newInstance(entry.getKey());\n      final Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d entry.getValue();\n\n      completionService\n          .submit(new Callable\u003cRegisterApplicationMasterResponse\u003e() {\n            @Override\n            public RegisterApplicationMasterResponse call() throws Exception {\n              RegisterApplicationMasterResponse response \u003d null;\n              try {\n                // Create a config loaded with federation on and subclusterId\n                // for each UAM\n                YarnConfiguration config \u003d new YarnConfiguration(getConf());\n                FederationProxyProviderUtil.updateConfForFederation(config,\n                    subClusterId.getId());\n\n                uamPool.reAttachUAM(subClusterId.getId(), config, appId,\n                    amRegistrationResponse.getQueue(),\n                    getApplicationContext().getUser(), homeSubClusterId.getId(),\n                    amrmToken);\n\n                response \u003d uamPool.registerApplicationMaster(\n                    subClusterId.getId(), amRegistrationRequest);\n\n                if (response !\u003d null\n                    \u0026\u0026 response.getContainersFromPreviousAttempts() !\u003d null) {\n                  cacheAllocatedContainers(\n                      response.getContainersFromPreviousAttempts(),\n                      subClusterId);\n                }\n                LOG.info(\"UAM {} reattached for {}\", subClusterId, appId);\n              } catch (Throwable e) {\n                LOG.error(\n                    \"Reattaching UAM \" + subClusterId + \" failed for \" + appId,\n                    e);\n              }\n              return response;\n            }\n          });\n    }\n\n    // Wait for the re-attach responses\n    for (int i \u003d 0; i \u003c uamMap.size(); i++) {\n      try {\n        Future\u003cRegisterApplicationMasterResponse\u003e future \u003d\n            completionService.take();\n        RegisterApplicationMasterResponse registerResponse \u003d future.get();\n        if (registerResponse !\u003d null) {\n          LOG.info(\"Merging register response for {}\", appId);\n          mergeRegisterResponse(homeResponse, registerResponse);\n        }\n      } catch (Exception e) {\n        LOG.warn(\"Reattaching UAM failed for ApplicationId: \" + appId, e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java"
    }
  }
}