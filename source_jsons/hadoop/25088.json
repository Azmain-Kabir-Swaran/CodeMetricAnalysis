{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ClientServiceDelegate.java",
  "functionName": "getProxy",
  "functionId": "getProxy",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
  "functionStartLine": 147,
  "functionEndLine": 285,
  "numCommitsSeen": 52,
  "timeTaken": 9507,
  "changeHistory": [
    "a3f945fb8466d461d42ce60f0bc12c96fbb2db23",
    "951847ba94442b8d928435decfbea9ea20882912",
    "acc0d3eb521e3c1d1b2f4be9b46c685ee921504b",
    "5d1b453b8591d87ffb564857015c26c99fb7437c",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "a2c42330047bf955a6a585dcddf798920d4c8640",
    "7359dc32d3781d5318efee4cf6185616c7c00c18",
    "0727ecaf50481fa7a529398bc2a12ce18c9a6b43",
    "9e650d36b76c530f171ee66ea3bca5c1765e642c",
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
    "ae6cc14611a5898ed637a2e0f9df559f6c29093e",
    "aa60da6c2ec049cc70897afee6c368cb70493773",
    "ad3d3f54d5f9d2b3648da43481c72bc3f6748ace",
    "fab57a144de0cd515e1de9107e4d3ac58037d846",
    "27c56b02b3015f631962992bd9193d26b85a5496",
    "7712e700900623e527438bb7b7a429d322cf573b",
    "beec374542da88416c4b3cb339c3680e9a844463",
    "102541b12b075bf190bdeb43e077f179a2a413fa",
    "f17ed541c76ce08b43713f06ecafd1685e16dff2",
    "2adc51c61863c613730a3b51538035fce5fa1fb4",
    "45b2bce8714ecbcb17c6b487208a48d26eed7824",
    "12743d2169f5a24a9b3be07c9e9dcc3f2f1001f0",
    "063e33a862f99ce93b8399924c35d39ccd880f01",
    "0b3c654d83c5e73fe946de194f3aea0a9fe06f5a",
    "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72",
    "29552eeb36dd8a9246fb648d65b5cfb94ae46d77",
    "71e05154330c084310b6e32bfd6397c29b4e0534",
    "1f46b991da9b91585608a0babd3eda39485dce09",
    "6bdf5746d5d677f9c17598768c4ae86384c000c6",
    "f2b91a8367a762091482074505618b570a520b19",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "a3f945fb8466d461d42ce60f0bc12c96fbb2db23": "Ybodychange",
    "951847ba94442b8d928435decfbea9ea20882912": "Ybodychange",
    "acc0d3eb521e3c1d1b2f4be9b46c685ee921504b": "Ybodychange",
    "5d1b453b8591d87ffb564857015c26c99fb7437c": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Ybodychange",
    "a2c42330047bf955a6a585dcddf798920d4c8640": "Ybodychange",
    "7359dc32d3781d5318efee4cf6185616c7c00c18": "Ymultichange(Yexceptionschange,Ybodychange)",
    "0727ecaf50481fa7a529398bc2a12ce18c9a6b43": "Yexceptionschange",
    "9e650d36b76c530f171ee66ea3bca5c1765e642c": "Ybodychange",
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5": "Ybodychange",
    "ae6cc14611a5898ed637a2e0f9df559f6c29093e": "Ybodychange",
    "aa60da6c2ec049cc70897afee6c368cb70493773": "Ybodychange",
    "ad3d3f54d5f9d2b3648da43481c72bc3f6748ace": "Ybodychange",
    "fab57a144de0cd515e1de9107e4d3ac58037d846": "Ybodychange",
    "27c56b02b3015f631962992bd9193d26b85a5496": "Ybodychange",
    "7712e700900623e527438bb7b7a429d322cf573b": "Ybodychange",
    "beec374542da88416c4b3cb339c3680e9a844463": "Ybodychange",
    "102541b12b075bf190bdeb43e077f179a2a413fa": "Ybodychange",
    "f17ed541c76ce08b43713f06ecafd1685e16dff2": "Ybodychange",
    "2adc51c61863c613730a3b51538035fce5fa1fb4": "Ybodychange",
    "45b2bce8714ecbcb17c6b487208a48d26eed7824": "Ybodychange",
    "12743d2169f5a24a9b3be07c9e9dcc3f2f1001f0": "Ybodychange",
    "063e33a862f99ce93b8399924c35d39ccd880f01": "Ybodychange",
    "0b3c654d83c5e73fe946de194f3aea0a9fe06f5a": "Ybodychange",
    "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72": "Ybodychange",
    "29552eeb36dd8a9246fb648d65b5cfb94ae46d77": "Ybodychange",
    "71e05154330c084310b6e32bfd6397c29b4e0534": "Ybodychange",
    "1f46b991da9b91585608a0babd3eda39485dce09": "Ybodychange",
    "6bdf5746d5d677f9c17598768c4ae86384c000c6": "Ybodychange",
    "f2b91a8367a762091482074505618b570a520b19": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a3f945fb8466d461d42ce60f0bc12c96fbb2db23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-17035. fixed typos (timeout, interruped) (#2007)\n\nCo-authored-by: Sungpeo Kook \u003celixir.kook@kakaocorp.com\u003e",
      "commitDate": "12/05/20 8:50 AM",
      "commitName": "a3f945fb8466d461d42ce60f0bc12c96fbb2db23",
      "commitAuthor": "Elixir Kook",
      "commitDateOld": "31/05/18 2:31 AM",
      "commitNameOld": "d1e2b8098078af4af31392ed7f2fa350a7d1c3b2",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 712.26,
      "commitsBetweenForRepo": 4607,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,139 +1,139 @@\n   private MRClientProtocol getProxy() throws IOException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d null;\n     try {\n       application \u003d rm.getApplicationReport(appId);\n     } catch (ApplicationNotFoundException e) {\n       application \u003d null;\n     } catch (YarnException e2) {\n       throw new IOException(e2);\n     }\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n             org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d\n                 application.getClientToAMToken();\n             Token\u003cClientToAMTokenIdentifier\u003e token \u003d\n                 ConverterUtils.convertFromYarn(clientToAMToken, serviceAddr);\n             newUgi.addToken(token);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n-          LOG.warn(\"getProxy() call interruped\", e1);\n+          LOG.warn(\"getProxy() call interrupted\", e1);\n           throw new YarnRuntimeException(e1);\n         }\n         try {\n           application \u003d rm.getApplicationReport(appId);\n         } catch (YarnException e1) {\n           throw new IOException(e1);\n         }\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n-        LOG.warn(\"getProxy() call interruped\", e);\n+        LOG.warn(\"getProxy() call interrupted\", e);\n         throw new YarnRuntimeException(e);\n       } catch (YarnException e) {\n         throw new IOException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw new IOException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n         || application.getYarnApplicationState() \u003d\u003d\n             YarnApplicationState.NEW_SAVING\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws IOException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d null;\n    try {\n      application \u003d rm.getApplicationReport(appId);\n    } catch (ApplicationNotFoundException e) {\n      application \u003d null;\n    } catch (YarnException e2) {\n      throw new IOException(e2);\n    }\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d\n                application.getClientToAMToken();\n            Token\u003cClientToAMTokenIdentifier\u003e token \u003d\n                ConverterUtils.convertFromYarn(clientToAMToken, serviceAddr);\n            newUgi.addToken(token);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interrupted\", e1);\n          throw new YarnRuntimeException(e1);\n        }\n        try {\n          application \u003d rm.getApplicationReport(appId);\n        } catch (YarnException e1) {\n          throw new IOException(e1);\n        }\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interrupted\", e);\n        throw new YarnRuntimeException(e);\n      } catch (YarnException e) {\n        throw new IOException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw new IOException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d\n            YarnApplicationState.NEW_SAVING\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "951847ba94442b8d928435decfbea9ea20882912": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6091. YARNRunner.getJobStatus() fails with ApplicationNotFoundException if the job rolled off the RM view. Contributed by Sangjin Lee\n",
      "commitDate": "19/09/14 1:15 PM",
      "commitName": "951847ba94442b8d928435decfbea9ea20882912",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "14/11/13 10:09 AM",
      "commitNameOld": "88c4d4a7140b29a409e2ee707f41db5900046843",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 309.09,
      "commitsBetweenForRepo": 2277,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,139 @@\n   private MRClientProtocol getProxy() throws IOException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d null;\n     try {\n       application \u003d rm.getApplicationReport(appId);\n+    } catch (ApplicationNotFoundException e) {\n+      application \u003d null;\n     } catch (YarnException e2) {\n       throw new IOException(e2);\n     }\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n             org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d\n                 application.getClientToAMToken();\n             Token\u003cClientToAMTokenIdentifier\u003e token \u003d\n                 ConverterUtils.convertFromYarn(clientToAMToken, serviceAddr);\n             newUgi.addToken(token);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnRuntimeException(e1);\n         }\n         try {\n           application \u003d rm.getApplicationReport(appId);\n         } catch (YarnException e1) {\n           throw new IOException(e1);\n         }\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnRuntimeException(e);\n       } catch (YarnException e) {\n         throw new IOException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw new IOException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n         || application.getYarnApplicationState() \u003d\u003d\n             YarnApplicationState.NEW_SAVING\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws IOException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d null;\n    try {\n      application \u003d rm.getApplicationReport(appId);\n    } catch (ApplicationNotFoundException e) {\n      application \u003d null;\n    } catch (YarnException e2) {\n      throw new IOException(e2);\n    }\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d\n                application.getClientToAMToken();\n            Token\u003cClientToAMTokenIdentifier\u003e token \u003d\n                ConverterUtils.convertFromYarn(clientToAMToken, serviceAddr);\n            newUgi.addToken(token);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnRuntimeException(e1);\n        }\n        try {\n          application \u003d rm.getApplicationReport(appId);\n        } catch (YarnException e1) {\n          throw new IOException(e1);\n        }\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnRuntimeException(e);\n      } catch (YarnException e) {\n        throw new IOException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw new IOException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d\n            YarnApplicationState.NEW_SAVING\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "acc0d3eb521e3c1d1b2f4be9b46c685ee921504b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-840. Moved ProtoUtils to yarn.api.records.pb.impl. Contributed by Jian He.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494027 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 10:47 PM",
      "commitName": "acc0d3eb521e3c1d1b2f4be9b46c685ee921504b",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "17/06/13 4:13 PM",
      "commitNameOld": "5d1b453b8591d87ffb564857015c26c99fb7437c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.27,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,137 @@\n   private MRClientProtocol getProxy() throws IOException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d null;\n     try {\n       application \u003d rm.getApplicationReport(appId);\n     } catch (YarnException e2) {\n       throw new IOException(e2);\n     }\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n             org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d\n                 application.getClientToAMToken();\n             Token\u003cClientToAMTokenIdentifier\u003e token \u003d\n-                ProtoUtils.convertFromProtoFormat(clientToAMToken, serviceAddr);\n+                ConverterUtils.convertFromYarn(clientToAMToken, serviceAddr);\n             newUgi.addToken(token);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnRuntimeException(e1);\n         }\n         try {\n           application \u003d rm.getApplicationReport(appId);\n         } catch (YarnException e1) {\n           throw new IOException(e1);\n         }\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnRuntimeException(e);\n       } catch (YarnException e) {\n         throw new IOException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw new IOException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n         || application.getYarnApplicationState() \u003d\u003d\n             YarnApplicationState.NEW_SAVING\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws IOException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d null;\n    try {\n      application \u003d rm.getApplicationReport(appId);\n    } catch (YarnException e2) {\n      throw new IOException(e2);\n    }\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d\n                application.getClientToAMToken();\n            Token\u003cClientToAMTokenIdentifier\u003e token \u003d\n                ConverterUtils.convertFromYarn(clientToAMToken, serviceAddr);\n            newUgi.addToken(token);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnRuntimeException(e1);\n        }\n        try {\n          application \u003d rm.getApplicationReport(appId);\n        } catch (YarnException e1) {\n          throw new IOException(e1);\n        }\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnRuntimeException(e);\n      } catch (YarnException e) {\n        throw new IOException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw new IOException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d\n            YarnApplicationState.NEW_SAVING\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "5d1b453b8591d87ffb564857015c26c99fb7437c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-610. ClientToken is no longer set in the environment of the Containers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493968 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 4:13 PM",
      "commitName": "5d1b453b8591d87ffb564857015c26c99fb7437c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/06/13 4:25 PM",
      "commitNameOld": "c0cd68d8fbf5c8cafa6d563c7d0401e7a87a2d9e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.99,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,137 @@\n   private MRClientProtocol getProxy() throws IOException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d null;\n     try {\n       application \u003d rm.getApplicationReport(appId);\n     } catch (YarnException e2) {\n       throw new IOException(e2);\n     }\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n-            org.apache.hadoop.yarn.api.records.Token clientToken \u003d application.getClientToken();\n-            Token\u003cClientTokenIdentifier\u003e token \u003d\n-                ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n+            org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d\n+                application.getClientToAMToken();\n+            Token\u003cClientToAMTokenIdentifier\u003e token \u003d\n+                ProtoUtils.convertFromProtoFormat(clientToAMToken, serviceAddr);\n             newUgi.addToken(token);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnRuntimeException(e1);\n         }\n         try {\n           application \u003d rm.getApplicationReport(appId);\n         } catch (YarnException e1) {\n           throw new IOException(e1);\n         }\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnRuntimeException(e);\n       } catch (YarnException e) {\n         throw new IOException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw new IOException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n         || application.getYarnApplicationState() \u003d\u003d\n             YarnApplicationState.NEW_SAVING\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws IOException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d null;\n    try {\n      application \u003d rm.getApplicationReport(appId);\n    } catch (YarnException e2) {\n      throw new IOException(e2);\n    }\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            org.apache.hadoop.yarn.api.records.Token clientToAMToken \u003d\n                application.getClientToAMToken();\n            Token\u003cClientToAMTokenIdentifier\u003e token \u003d\n                ProtoUtils.convertFromProtoFormat(clientToAMToken, serviceAddr);\n            newUgi.addToken(token);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnRuntimeException(e1);\n        }\n        try {\n          application \u003d rm.getApplicationReport(appId);\n        } catch (YarnException e1) {\n          throw new IOException(e1);\n        }\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnRuntimeException(e);\n      } catch (YarnException e) {\n        throw new IOException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw new IOException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d\n            YarnApplicationState.NEW_SAVING\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "01/06/13 2:43 PM",
      "commitNameOld": "a2c42330047bf955a6a585dcddf798920d4c8640",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.27,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,136 @@\n   private MRClientProtocol getProxy() throws IOException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d null;\n     try {\n       application \u003d rm.getApplicationReport(appId);\n-    } catch (YarnRemoteException e2) {\n+    } catch (YarnException e2) {\n       throw new IOException(e2);\n     }\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n             org.apache.hadoop.yarn.api.records.Token clientToken \u003d application.getClientToken();\n             Token\u003cClientTokenIdentifier\u003e token \u003d\n                 ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n             newUgi.addToken(token);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n-          throw new YarnException(e1);\n+          throw new YarnRuntimeException(e1);\n         }\n         try {\n           application \u003d rm.getApplicationReport(appId);\n-        } catch (YarnRemoteException e1) {\n+        } catch (YarnException e1) {\n           throw new IOException(e1);\n         }\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n-        throw new YarnException(e);\n-      } catch (YarnRemoteException e) {\n+        throw new YarnRuntimeException(e);\n+      } catch (YarnException e) {\n         throw new IOException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw new IOException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n         || application.getYarnApplicationState() \u003d\u003d\n             YarnApplicationState.NEW_SAVING\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws IOException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d null;\n    try {\n      application \u003d rm.getApplicationReport(appId);\n    } catch (YarnException e2) {\n      throw new IOException(e2);\n    }\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            org.apache.hadoop.yarn.api.records.Token clientToken \u003d application.getClientToken();\n            Token\u003cClientTokenIdentifier\u003e token \u003d\n                ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n            newUgi.addToken(token);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnRuntimeException(e1);\n        }\n        try {\n          application \u003d rm.getApplicationReport(appId);\n        } catch (YarnException e1) {\n          throw new IOException(e1);\n        }\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnRuntimeException(e);\n      } catch (YarnException e) {\n        throw new IOException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw new IOException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d\n            YarnApplicationState.NEW_SAVING\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "a2c42330047bf955a6a585dcddf798920d4c8640": {
      "type": "Ybodychange",
      "commitMessage": "YARN-717. Put object creation factories for Token in the class itself and remove useless derivations for specific tokens. Contributed by Jian He.\nMAPREDUCE-5289. Updated MR App to use Token directly after YARN-717. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488616 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/06/13 2:43 PM",
      "commitName": "a2c42330047bf955a6a585dcddf798920d4c8640",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/05/13 6:46 PM",
      "commitNameOld": "643155cbee54809e1a7febd96cbb7d8111689b38",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.83,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,136 @@\n   private MRClientProtocol getProxy() throws IOException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d null;\n     try {\n       application \u003d rm.getApplicationReport(appId);\n     } catch (YarnRemoteException e2) {\n       throw new IOException(e2);\n     }\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n-            ClientToken clientToken \u003d application.getClientToken();\n+            org.apache.hadoop.yarn.api.records.Token clientToken \u003d application.getClientToken();\n             Token\u003cClientTokenIdentifier\u003e token \u003d\n                 ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n             newUgi.addToken(token);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         try {\n           application \u003d rm.getApplicationReport(appId);\n         } catch (YarnRemoteException e1) {\n           throw new IOException(e1);\n         }\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       } catch (YarnRemoteException e) {\n         throw new IOException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw new IOException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n         || application.getYarnApplicationState() \u003d\u003d\n             YarnApplicationState.NEW_SAVING\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws IOException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d null;\n    try {\n      application \u003d rm.getApplicationReport(appId);\n    } catch (YarnRemoteException e2) {\n      throw new IOException(e2);\n    }\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            org.apache.hadoop.yarn.api.records.Token clientToken \u003d application.getClientToken();\n            Token\u003cClientTokenIdentifier\u003e token \u003d\n                ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n            newUgi.addToken(token);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        try {\n          application \u003d rm.getApplicationReport(appId);\n        } catch (YarnRemoteException e1) {\n          throw new IOException(e1);\n        }\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      } catch (YarnRemoteException e) {\n        throw new IOException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw new IOException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d\n            YarnApplicationState.NEW_SAVING\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "7359dc32d3781d5318efee4cf6185616c7c00c18": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "MAPREDUCE-4067. Changed MRClientProtocol api to throw IOException only (Xuan Gong via vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481695 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/05/13 8:34 PM",
      "commitName": "7359dc32d3781d5318efee4cf6185616c7c00c18",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "MAPREDUCE-4067. Changed MRClientProtocol api to throw IOException only (Xuan Gong via vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481695 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/05/13 8:34 PM",
          "commitName": "7359dc32d3781d5318efee4cf6185616c7c00c18",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "08/05/13 3:53 PM",
          "commitNameOld": "0727ecaf50481fa7a529398bc2a12ce18c9a6b43",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 4.2,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,125 +1,136 @@\n-  private MRClientProtocol getProxy() throws YarnRemoteException, IOException {\n+  private MRClientProtocol getProxy() throws IOException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n-    ApplicationReport application \u003d rm.getApplicationReport(appId);\n+    ApplicationReport application \u003d null;\n+    try {\n+      application \u003d rm.getApplicationReport(appId);\n+    } catch (YarnRemoteException e2) {\n+      throw new IOException(e2);\n+    }\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n             ClientToken clientToken \u003d application.getClientToken();\n             Token\u003cClientTokenIdentifier\u003e token \u003d\n                 ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n             newUgi.addToken(token);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n-        application \u003d rm.getApplicationReport(appId);\n+        try {\n+          application \u003d rm.getApplicationReport(appId);\n+        } catch (YarnRemoteException e1) {\n+          throw new IOException(e1);\n+        }\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n+      } catch (YarnRemoteException e) {\n+        throw new IOException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n-      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n+      throw new IOException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n         || application.getYarnApplicationState() \u003d\u003d\n             YarnApplicationState.NEW_SAVING\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private MRClientProtocol getProxy() throws IOException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d null;\n    try {\n      application \u003d rm.getApplicationReport(appId);\n    } catch (YarnRemoteException e2) {\n      throw new IOException(e2);\n    }\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            ClientToken clientToken \u003d application.getClientToken();\n            Token\u003cClientTokenIdentifier\u003e token \u003d\n                ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n            newUgi.addToken(token);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        try {\n          application \u003d rm.getApplicationReport(appId);\n        } catch (YarnRemoteException e1) {\n          throw new IOException(e1);\n        }\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      } catch (YarnRemoteException e) {\n        throw new IOException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw new IOException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d\n            YarnApplicationState.NEW_SAVING\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
          "extendedDetails": {
            "oldValue": "[YarnRemoteException, IOException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-4067. Changed MRClientProtocol api to throw IOException only (Xuan Gong via vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481695 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/05/13 8:34 PM",
          "commitName": "7359dc32d3781d5318efee4cf6185616c7c00c18",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "08/05/13 3:53 PM",
          "commitNameOld": "0727ecaf50481fa7a529398bc2a12ce18c9a6b43",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 4.2,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,125 +1,136 @@\n-  private MRClientProtocol getProxy() throws YarnRemoteException, IOException {\n+  private MRClientProtocol getProxy() throws IOException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n-    ApplicationReport application \u003d rm.getApplicationReport(appId);\n+    ApplicationReport application \u003d null;\n+    try {\n+      application \u003d rm.getApplicationReport(appId);\n+    } catch (YarnRemoteException e2) {\n+      throw new IOException(e2);\n+    }\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n             ClientToken clientToken \u003d application.getClientToken();\n             Token\u003cClientTokenIdentifier\u003e token \u003d\n                 ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n             newUgi.addToken(token);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n-        application \u003d rm.getApplicationReport(appId);\n+        try {\n+          application \u003d rm.getApplicationReport(appId);\n+        } catch (YarnRemoteException e1) {\n+          throw new IOException(e1);\n+        }\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n+      } catch (YarnRemoteException e) {\n+        throw new IOException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n-      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n+      throw new IOException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n         || application.getYarnApplicationState() \u003d\u003d\n             YarnApplicationState.NEW_SAVING\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private MRClientProtocol getProxy() throws IOException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d null;\n    try {\n      application \u003d rm.getApplicationReport(appId);\n    } catch (YarnRemoteException e2) {\n      throw new IOException(e2);\n    }\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            ClientToken clientToken \u003d application.getClientToken();\n            Token\u003cClientTokenIdentifier\u003e token \u003d\n                ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n            newUgi.addToken(token);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        try {\n          application \u003d rm.getApplicationReport(appId);\n        } catch (YarnRemoteException e1) {\n          throw new IOException(e1);\n        }\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      } catch (YarnRemoteException e) {\n        throw new IOException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw new IOException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d\n            YarnApplicationState.NEW_SAVING\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
          "extendedDetails": {}
        }
      ]
    },
    "0727ecaf50481fa7a529398bc2a12ce18c9a6b43": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-631. Changed ClientRMProtocol api to throw IOException and YarnRemoteException. Contributed by Xuan Gong.\nMAPREDUCE-5212. Handling YarnRemoteException separately from IOException in MR App after YARN-631. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480494 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/13 3:53 PM",
      "commitName": "0727ecaf50481fa7a529398bc2a12ce18c9a6b43",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "06/05/13 12:04 PM",
      "commitNameOld": "92b7165a71656468f17ce8b760ce11e648932f0e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.16,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n-  private MRClientProtocol getProxy() throws YarnRemoteException {\n+  private MRClientProtocol getProxy() throws YarnRemoteException, IOException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n             ClientToken clientToken \u003d application.getClientToken();\n             Token\u003cClientTokenIdentifier\u003e token \u003d\n                 ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n             newUgi.addToken(token);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n         || application.getYarnApplicationState() \u003d\u003d\n             YarnApplicationState.NEW_SAVING\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException, IOException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            ClientToken clientToken \u003d application.getClientToken();\n            Token\u003cClientTokenIdentifier\u003e token \u003d\n                ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n            newUgi.addToken(token);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d\n            YarnApplicationState.NEW_SAVING\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException]",
        "newValue": "[YarnRemoteException, IOException]"
      }
    },
    "9e650d36b76c530f171ee66ea3bca5c1765e642c": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5140. MR part of YARN-514 (Zhijie Shen via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469060 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/04/13 1:25 PM",
      "commitName": "9e650d36b76c530f171ee66ea3bca5c1765e642c",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "15/01/13 10:33 AM",
      "commitNameOld": "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 92.08,
      "commitsBetweenForRepo": 445,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,125 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n             ClientToken clientToken \u003d application.getClientToken();\n             Token\u003cClientTokenIdentifier\u003e token \u003d\n                 ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n             newUgi.addToken(token);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n+        || application.getYarnApplicationState() \u003d\u003d\n+            YarnApplicationState.NEW_SAVING\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            ClientToken clientToken \u003d application.getClientToken();\n            Token\u003cClientTokenIdentifier\u003e token \u003d\n                ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n            newUgi.addToken(token);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d\n            YarnApplicationState.NEW_SAVING\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-135. Client tokens should be per app-attempt, and should be unregistered on App-finish. Contributed by Vinod Kumar Vavilapalli\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1433570 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/01/13 10:33 AM",
      "commitName": "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "09/08/12 3:52 PM",
      "commitNameOld": "4bca22005f48f426b9bc7cf36d435ead470a2590",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 158.82,
      "commitsBetweenForRepo": 852,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,123 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n-            String clientTokenEncoded \u003d application.getClientToken();\n-            Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n-              new Token\u003cApplicationTokenIdentifier\u003e();\n-            clientToken.decodeFromUrlString(clientTokenEncoded);\n-            // RPC layer client expects ip:port as service for tokens\n-            SecurityUtil.setTokenService(clientToken, serviceAddr);\n-            newUgi.addToken(clientToken);\n+            ClientToken clientToken \u003d application.getClientToken();\n+            Token\u003cClientTokenIdentifier\u003e token \u003d\n+                ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n+            newUgi.addToken(token);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n         || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            ClientToken clientToken \u003d application.getClientToken();\n            Token\u003cClientTokenIdentifier\u003e token \u003d\n                ProtoUtils.convertFromProtoFormat(clientToken, serviceAddr);\n            newUgi.addToken(token);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "ae6cc14611a5898ed637a2e0f9df559f6c29093e": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4427. Added an \u0027unmanaged\u0027 mode for AMs so as to ease development of new applications. Contributed by Bikas Saha.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361813 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/12 2:46 PM",
      "commitName": "ae6cc14611a5898ed637a2e0f9df559f6c29093e",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "08/05/12 8:07 AM",
      "commitNameOld": "aa60da6c2ec049cc70897afee6c368cb70493773",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 68.28,
      "commitsBetweenForRepo": 357,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,126 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d NetUtils.createSocketAddrForHost(\n               application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n             String clientTokenEncoded \u003d application.getClientToken();\n             Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n               new Token\u003cApplicationTokenIdentifier\u003e();\n             clientToken.decodeFromUrlString(clientTokenEncoded);\n             // RPC layer client expects ip:port as service for tokens\n             SecurityUtil.setTokenService(clientToken, serviceAddr);\n             newUgi.addToken(clientToken);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n-    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n-        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n+    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n+        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n+        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            String clientTokenEncoded \u003d application.getClientToken();\n            Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n              new Token\u003cApplicationTokenIdentifier\u003e();\n            clientToken.decodeFromUrlString(clientTokenEncoded);\n            // RPC layer client expects ip:port as service for tokens\n            SecurityUtil.setTokenService(clientToken, serviceAddr);\n            newUgi.addToken(clientToken);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED\n        || application.getYarnApplicationState() \u003d\u003d YarnApplicationState.ACCEPTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "aa60da6c2ec049cc70897afee6c368cb70493773": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4162. Correctly set token service (Daryn Sharp via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1335567 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/12 8:07 AM",
      "commitName": "aa60da6c2ec049cc70897afee6c368cb70493773",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "19/04/12 7:44 AM",
      "commitNameOld": "97ae5b675ff675224fdc7dcf45cd06a26d79218d",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 19.02,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,125 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n-    String serviceAddr \u003d null;\n+    InetSocketAddress serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n-          serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n+          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n+              application.getHost(), application.getRpcPort());\n           if (UserGroupInformation.isSecurityEnabled()) {\n             String clientTokenEncoded \u003d application.getClientToken();\n             Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n               new Token\u003cApplicationTokenIdentifier\u003e();\n             clientToken.decodeFromUrlString(clientTokenEncoded);\n             // RPC layer client expects ip:port as service for tokens\n-            InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n-                .getHost(), application.getRpcPort());\n-            clientToken.setService(new Text(addr.getAddress().getHostAddress()\n-                + \":\" + addr.getPort()));\n+            SecurityUtil.setTokenService(clientToken, serviceAddr);\n             newUgi.addToken(clientToken);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n-          final String tempStr \u003d serviceAddr;\n+          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n-              return instantiateAMProxy(tempStr);\n+              return instantiateAMProxy(finalServiceAddr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n         application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    InetSocketAddress serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d NetUtils.createSocketAddrForHost(\n              application.getHost(), application.getRpcPort());\n          if (UserGroupInformation.isSecurityEnabled()) {\n            String clientTokenEncoded \u003d application.getClientToken();\n            Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n              new Token\u003cApplicationTokenIdentifier\u003e();\n            clientToken.decodeFromUrlString(clientTokenEncoded);\n            // RPC layer client expects ip:port as service for tokens\n            SecurityUtil.setTokenService(clientToken, serviceAddr);\n            newUgi.addToken(clientToken);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final InetSocketAddress finalServiceAddr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(finalServiceAddr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "ad3d3f54d5f9d2b3648da43481c72bc3f6748ace": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3348. Fixed a bug in MR client to redirect to JobHistoryServer correctly when RM forgets the app. Contributed by Devaraj K.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1298978 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/03/12 10:53 AM",
      "commitName": "ad3d3f54d5f9d2b3648da43481c72bc3f6748ace",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/03/12 3:40 PM",
      "commitNameOld": "fab57a144de0cd515e1de9107e4d3ac58037d846",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.8,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,127 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     String serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n-        LOG.debug(\"Could not get Job info from RM for job \" + jobId\n+        LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         } else if (UNAVAILABLE.equals(application.getHost())) {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                 + \" Verify user has VIEW_JOB access.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             String clientTokenEncoded \u003d application.getClientToken();\n             Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n               new Token\u003cApplicationTokenIdentifier\u003e();\n             clientToken.decodeFromUrlString(clientTokenEncoded);\n             // RPC layer client expects ip:port as service for tokens\n             InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n                 .getHost(), application.getRpcPort());\n             clientToken.setService(new Text(addr.getAddress().getHostAddress()\n                 + \":\" + addr.getPort()));\n             newUgi.addToken(clientToken);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final String tempStr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(tempStr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n-          LOG.debug(\"Could not get Job info from RM for job \" + jobId\n+          LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n         application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            String clientTokenEncoded \u003d application.getClientToken();\n            Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n              new Token\u003cApplicationTokenIdentifier\u003e();\n            clientToken.decodeFromUrlString(clientTokenEncoded);\n            // RPC layer client expects ip:port as service for tokens\n            InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n                .getHost(), application.getRpcPort());\n            clientToken.setService(new Text(addr.getAddress().getHostAddress()\n                + \":\" + addr.getPort()));\n            newUgi.addToken(clientToken);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final String tempStr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(tempStr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "fab57a144de0cd515e1de9107e4d3ac58037d846": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3792. Fix \"bin/mapred job -list\" to display all jobs instead of only the jobs owned by the user. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296721 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/03/12 3:40 PM",
      "commitName": "fab57a144de0cd515e1de9107e4d3ac58037d846",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/02/12 4:54 PM",
      "commitNameOld": "a64046d16fb1569c5454f52f6ecc466eb28e084a",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 15.95,
      "commitsBetweenForRepo": 125,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,127 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     String serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.debug(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n+        } else if (UNAVAILABLE.equals(application.getHost())) {\n+          if (!amAclDisabledStatusLogged) {\n+            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n+                + \" Verify user has VIEW_JOB access.\");\n+            amAclDisabledStatusLogged \u003d true;\n+          }\n+          return getNotRunningJob(application, JobState.RUNNING);\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             String clientTokenEncoded \u003d application.getClientToken();\n             Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n               new Token\u003cApplicationTokenIdentifier\u003e();\n             clientToken.decodeFromUrlString(clientTokenEncoded);\n             // RPC layer client expects ip:port as service for tokens\n             InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n                 .getHost(), application.getRpcPort());\n             clientToken.setService(new Text(addr.getAddress().getHostAddress()\n                 + \":\" + addr.getPort()));\n             newUgi.addToken(clientToken);\n           }\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final String tempStr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(tempStr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.debug(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n         application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.debug(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        } else if (UNAVAILABLE.equals(application.getHost())) {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Job \" + jobId + \" is running, but the host is unknown.\"\n                + \" Verify user has VIEW_JOB access.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(application, JobState.RUNNING);\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            String clientTokenEncoded \u003d application.getClientToken();\n            Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n              new Token\u003cApplicationTokenIdentifier\u003e();\n            clientToken.decodeFromUrlString(clientTokenEncoded);\n            // RPC layer client expects ip:port as service for tokens\n            InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n                .getHost(), application.getRpcPort());\n            clientToken.setService(new Text(addr.getAddress().getHostAddress()\n                + \":\" + addr.getPort()));\n            newUgi.addToken(clientToken);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final String tempStr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(tempStr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.debug(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "27c56b02b3015f631962992bd9193d26b85a5496": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3646. Remove redundant URL info from \"mapred job\" output. (Jonathan Eagles via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1235034 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/01/12 2:22 PM",
      "commitName": "27c56b02b3015f631962992bd9193d26b85a5496",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "10/01/12 3:07 PM",
      "commitNameOld": "7712e700900623e527438bb7b7a429d322cf573b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 12.97,
      "commitsBetweenForRepo": 54,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,120 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     String serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.debug(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             String clientTokenEncoded \u003d application.getClientToken();\n             Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n               new Token\u003cApplicationTokenIdentifier\u003e();\n             clientToken.decodeFromUrlString(clientTokenEncoded);\n             // RPC layer client expects ip:port as service for tokens\n             InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n                 .getHost(), application.getRpcPort());\n             clientToken.setService(new Text(addr.getAddress().getHostAddress()\n                 + \":\" + addr.getPort()));\n             newUgi.addToken(clientToken);\n           }\n-          LOG.info(\"The url to track the job: \" + application.getTrackingUrl());\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final String tempStr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(tempStr);\n             }\n           });\n         } else {\n           if (!amAclDisabledStatusLogged) {\n             LOG.info(\"Network ACL closed to AM for job \" + jobId\n                 + \". Not going to try to reach the AM.\");\n             amAclDisabledStatusLogged \u003d true;\n           }\n           return getNotRunningJob(null, JobState.RUNNING);\n         }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.debug(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n         application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.debug(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            String clientTokenEncoded \u003d application.getClientToken();\n            Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n              new Token\u003cApplicationTokenIdentifier\u003e();\n            clientToken.decodeFromUrlString(clientTokenEncoded);\n            // RPC layer client expects ip:port as service for tokens\n            InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n                .getHost(), application.getRpcPort());\n            clientToken.setService(new Text(addr.getAddress().getHostAddress()\n                + \":\" + addr.getPort()));\n            newUgi.addToken(clientToken);\n          }\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final String tempStr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(tempStr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.debug(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "7712e700900623e527438bb7b7a429d322cf573b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3251. Network ACLs can prevent some clients to talk to MR AM. Improved the earlier patch to not to JobHistoryServer repeatedly. Contributed by Anupam Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1229787 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/12 3:07 PM",
      "commitName": "7712e700900623e527438bb7b7a429d322cf573b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "15/12/11 12:58 AM",
      "commitNameOld": "beec374542da88416c4b3cb339c3680e9a844463",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 26.59,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,121 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     String serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.debug(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n-        if(!conf.getBoolean(YarnConfiguration.RM_AM_NETWORK_ACL_CLOSED, false)) {\n+        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n           UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n               UserGroupInformation.getCurrentUser().getUserName());\n           serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n           if (UserGroupInformation.isSecurityEnabled()) {\n             String clientTokenEncoded \u003d application.getClientToken();\n             Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n               new Token\u003cApplicationTokenIdentifier\u003e();\n             clientToken.decodeFromUrlString(clientTokenEncoded);\n             // RPC layer client expects ip:port as service for tokens\n             InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n                 .getHost(), application.getRpcPort());\n             clientToken.setService(new Text(addr.getAddress().getHostAddress()\n                 + \":\" + addr.getPort()));\n             newUgi.addToken(clientToken);\n           }\n           LOG.info(\"The url to track the job: \" + application.getTrackingUrl());\n           LOG.debug(\"Connecting to \" + serviceAddr);\n           final String tempStr \u003d serviceAddr;\n           realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n             @Override\n             public MRClientProtocol run() throws IOException {\n               return instantiateAMProxy(tempStr);\n             }\n           });\n-\t} else {\n-           logApplicationReportInfo(application); \n-           LOG.info(\"Network ACL closed to AM for job \" + jobId\n-             + \". Redirecting to job history server.\");\n-           return checkAndGetHSProxy(null, JobState.RUNNING);\n-        }  \n+        } else {\n+          if (!amAclDisabledStatusLogged) {\n+            LOG.info(\"Network ACL closed to AM for job \" + jobId\n+                + \". Not going to try to reach the AM.\");\n+            amAclDisabledStatusLogged \u003d true;\n+          }\n+          return getNotRunningJob(null, JobState.RUNNING);\n+        }\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.debug(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n         application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.debug(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        if(!conf.getBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            String clientTokenEncoded \u003d application.getClientToken();\n            Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n              new Token\u003cApplicationTokenIdentifier\u003e();\n            clientToken.decodeFromUrlString(clientTokenEncoded);\n            // RPC layer client expects ip:port as service for tokens\n            InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n                .getHost(), application.getRpcPort());\n            clientToken.setService(new Text(addr.getAddress().getHostAddress()\n                + \":\" + addr.getPort()));\n            newUgi.addToken(clientToken);\n          }\n          LOG.info(\"The url to track the job: \" + application.getTrackingUrl());\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final String tempStr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(tempStr);\n            }\n          });\n        } else {\n          if (!amAclDisabledStatusLogged) {\n            LOG.info(\"Network ACL closed to AM for job \" + jobId\n                + \". Not going to try to reach the AM.\");\n            amAclDisabledStatusLogged \u003d true;\n          }\n          return getNotRunningJob(null, JobState.RUNNING);\n        }\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.debug(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "beec374542da88416c4b3cb339c3680e9a844463": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3251. Network ACLs can prevent some clients to talk to MR ApplicationMaster (Anupam Seth via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1214662 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/12/11 12:58 AM",
      "commitName": "beec374542da88416c4b3cb339c3680e9a844463",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "01/12/11 12:39 PM",
      "commitNameOld": "102541b12b075bf190bdeb43e077f179a2a413fa",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 13.51,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,119 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     String serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.debug(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n-        UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n-            UserGroupInformation.getCurrentUser().getUserName());\n-        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n-        if (UserGroupInformation.isSecurityEnabled()) {\n-          String clientTokenEncoded \u003d application.getClientToken();\n-          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n-            new Token\u003cApplicationTokenIdentifier\u003e();\n-          clientToken.decodeFromUrlString(clientTokenEncoded);\n-          // RPC layer client expects ip:port as service for tokens\n-          InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n-              .getHost(), application.getRpcPort());\n-          clientToken.setService(new Text(addr.getAddress().getHostAddress()\n-              + \":\" + addr.getPort()));\n-          newUgi.addToken(clientToken);\n-        }\n-        LOG.info(\"The url to track the job: \" + application.getTrackingUrl());\n-        LOG.debug(\"Connecting to \" + serviceAddr);\n-        final String tempStr \u003d serviceAddr;\n-        realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n-          @Override\n-          public MRClientProtocol run() throws IOException {\n-            return instantiateAMProxy(tempStr);\n+        if(!conf.getBoolean(YarnConfiguration.RM_AM_NETWORK_ACL_CLOSED, false)) {\n+          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n+              UserGroupInformation.getCurrentUser().getUserName());\n+          serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n+          if (UserGroupInformation.isSecurityEnabled()) {\n+            String clientTokenEncoded \u003d application.getClientToken();\n+            Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n+              new Token\u003cApplicationTokenIdentifier\u003e();\n+            clientToken.decodeFromUrlString(clientTokenEncoded);\n+            // RPC layer client expects ip:port as service for tokens\n+            InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n+                .getHost(), application.getRpcPort());\n+            clientToken.setService(new Text(addr.getAddress().getHostAddress()\n+                + \":\" + addr.getPort()));\n+            newUgi.addToken(clientToken);\n           }\n-        });\n+          LOG.info(\"The url to track the job: \" + application.getTrackingUrl());\n+          LOG.debug(\"Connecting to \" + serviceAddr);\n+          final String tempStr \u003d serviceAddr;\n+          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n+            @Override\n+            public MRClientProtocol run() throws IOException {\n+              return instantiateAMProxy(tempStr);\n+            }\n+          });\n+\t} else {\n+           logApplicationReportInfo(application); \n+           LOG.info(\"Network ACL closed to AM for job \" + jobId\n+             + \". Redirecting to job history server.\");\n+           return checkAndGetHSProxy(null, JobState.RUNNING);\n+        }  \n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.debug(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n         application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.debug(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        if(!conf.getBoolean(YarnConfiguration.RM_AM_NETWORK_ACL_CLOSED, false)) {\n          UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n              UserGroupInformation.getCurrentUser().getUserName());\n          serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n          if (UserGroupInformation.isSecurityEnabled()) {\n            String clientTokenEncoded \u003d application.getClientToken();\n            Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n              new Token\u003cApplicationTokenIdentifier\u003e();\n            clientToken.decodeFromUrlString(clientTokenEncoded);\n            // RPC layer client expects ip:port as service for tokens\n            InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n                .getHost(), application.getRpcPort());\n            clientToken.setService(new Text(addr.getAddress().getHostAddress()\n                + \":\" + addr.getPort()));\n            newUgi.addToken(clientToken);\n          }\n          LOG.info(\"The url to track the job: \" + application.getTrackingUrl());\n          LOG.debug(\"Connecting to \" + serviceAddr);\n          final String tempStr \u003d serviceAddr;\n          realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n            @Override\n            public MRClientProtocol run() throws IOException {\n              return instantiateAMProxy(tempStr);\n            }\n          });\n\t} else {\n           logApplicationReportInfo(application); \n           LOG.info(\"Network ACL closed to AM for job \" + jobId\n             + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n        }  \n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.debug(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "102541b12b075bf190bdeb43e077f179a2a413fa": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3443. JobClient and Job should function in the context of the UGI which created them. (Contributed by Mahadev Konar)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1209231 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/12/11 12:39 PM",
      "commitName": "102541b12b075bf190bdeb43e077f179a2a413fa",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "23/11/11 2:04 PM",
      "commitNameOld": "f17ed541c76ce08b43713f06ecafd1685e16dff2",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 7.94,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,112 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     String serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.debug(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n+        UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n+            UserGroupInformation.getCurrentUser().getUserName());\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           // RPC layer client expects ip:port as service for tokens\n           InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n               .getHost(), application.getRpcPort());\n           clientToken.setService(new Text(addr.getAddress().getHostAddress()\n               + \":\" + addr.getPort()));\n-          UserGroupInformation.getCurrentUser().addToken(clientToken);\n+          newUgi.addToken(clientToken);\n         }\n         LOG.info(\"The url to track the job: \" + application.getTrackingUrl());\n         LOG.debug(\"Connecting to \" + serviceAddr);\n-        realProxy \u003d instantiateAMProxy(serviceAddr);\n+        final String tempStr \u003d serviceAddr;\n+        realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n+          @Override\n+          public MRClientProtocol run() throws IOException {\n+            return instantiateAMProxy(tempStr);\n+          }\n+        });\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.debug(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n         application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.debug(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        UserGroupInformation newUgi \u003d UserGroupInformation.createRemoteUser(\n            UserGroupInformation.getCurrentUser().getUserName());\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          // RPC layer client expects ip:port as service for tokens\n          InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n              .getHost(), application.getRpcPort());\n          clientToken.setService(new Text(addr.getAddress().getHostAddress()\n              + \":\" + addr.getPort()));\n          newUgi.addToken(clientToken);\n        }\n        LOG.info(\"The url to track the job: \" + application.getTrackingUrl());\n        LOG.debug(\"Connecting to \" + serviceAddr);\n        final String tempStr \u003d serviceAddr;\n        realProxy \u003d newUgi.doAs(new PrivilegedExceptionAction\u003cMRClientProtocol\u003e() {\n          @Override\n          public MRClientProtocol run() throws IOException {\n            return instantiateAMProxy(tempStr);\n          }\n        });\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.debug(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "f17ed541c76ce08b43713f06ecafd1685e16dff2": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3265. Removed debug logs during job submission to LOG.debug to cut down noise. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1205628 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/11/11 2:04 PM",
      "commitName": "f17ed541c76ce08b43713f06ecafd1685e16dff2",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "30/10/11 11:42 PM",
      "commitNameOld": "47a381e306877750b5a3ce5d76e0a5ff652ec188",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 23.64,
      "commitsBetweenForRepo": 138,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,104 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     String serviceAddr \u003d null;\n     while (application \u003d\u003d null\n         || YarnApplicationState.RUNNING \u003d\u003d application\n             .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n-        LOG.info(\"Could not get Job info from RM for job \" + jobId\n+        LOG.debug(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           // RPC layer client expects ip:port as service for tokens\n           InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n               .getHost(), application.getRpcPort());\n           clientToken.setService(new Text(addr.getAddress().getHostAddress()\n               + \":\" + addr.getPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n-        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n-        LOG.info(\"Connecting to \" + serviceAddr);\n+        LOG.info(\"The url to track the job: \" + application.getTrackingUrl());\n+        LOG.debug(\"Connecting to \" + serviceAddr);\n         realProxy \u003d instantiateAMProxy(serviceAddr);\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n-          LOG.info(\"Could not get Job info from RM for job \" + jobId\n+          LOG.debug(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n         application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.debug(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          // RPC layer client expects ip:port as service for tokens\n          InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n              .getHost(), application.getRpcPort());\n          clientToken.setService(new Text(addr.getAddress().getHostAddress()\n              + \":\" + addr.getPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"The url to track the job: \" + application.getTrackingUrl());\n        LOG.debug(\"Connecting to \" + serviceAddr);\n        realProxy \u003d instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.debug(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "2adc51c61863c613730a3b51538035fce5fa1fb4": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3250. When AM restarts, client keeps reconnecting to the new AM and prints a lots of logs. (vinodkv via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189023 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/10/11 9:31 PM",
      "commitName": "2adc51c61863c613730a3b51538035fce5fa1fb4",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "21/10/11 11:35 AM",
      "commitNameOld": "45b2bce8714ecbcb17c6b487208a48d26eed7824",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 4.41,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,104 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n-    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n+    if (realProxy !\u003d null) {\n       return realProxy;\n     }\n     \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     String serviceAddr \u003d null;\n-    while (application \u003d\u003d null || YarnApplicationState.RUNNING \u003d\u003d application.getYarnApplicationState()) {\n+    while (application \u003d\u003d null\n+        || YarnApplicationState.RUNNING \u003d\u003d application\n+            .getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           // RPC layer client expects ip:port as service for tokens\n           InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n               .getHost(), application.getRpcPort());\n           clientToken.setService(new Text(addr.getAddress().getHostAddress()\n               + \":\" + addr.getPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n         LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n-        instantiateAMProxy(serviceAddr);\n+        realProxy \u003d instantiateAMProxy(serviceAddr);\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n         application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null\n        || YarnApplicationState.RUNNING \u003d\u003d application\n            .getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          // RPC layer client expects ip:port as service for tokens\n          InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n              .getHost(), application.getRpcPort());\n          clientToken.setService(new Text(addr.getAddress().getHostAddress()\n              + \":\" + addr.getPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        realProxy \u003d instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "45b2bce8714ecbcb17c6b487208a48d26eed7824": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3163. JobClient spews errors when killing MR2 job. (mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1187491 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/10/11 11:35 AM",
      "commitName": "45b2bce8714ecbcb17c6b487208a48d26eed7824",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "05/10/11 4:43 AM",
      "commitNameOld": "66137cf17cb4abccd6065819d97edc63c6510477",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 16.29,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,102 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n       return realProxy;\n     }\n-      //TODO RM NPEs for unknown jobs. History may still be aware.\n+    \n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     String serviceAddr \u003d null;\n-    while (application \u003d\u003d null || YarnApplicationState.RUNNING.equals(application.getYarnApplicationState())) {\n+    while (application \u003d\u003d null || YarnApplicationState.RUNNING \u003d\u003d application.getYarnApplicationState()) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           // RPC layer client expects ip:port as service for tokens\n           InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n               .getHost(), application.getRpcPort());\n           clientToken.setService(new Text(addr.getAddress().getHostAddress()\n               + \":\" + addr.getPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n         LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n-\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n         application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n    \n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null || YarnApplicationState.RUNNING \u003d\u003d application.getYarnApplicationState()) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          // RPC layer client expects ip:port as service for tokens\n          InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n              .getHost(), application.getRpcPort());\n          clientToken.setService(new Text(addr.getAddress().getHostAddress()\n              + \":\" + addr.getPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "12743d2169f5a24a9b3be07c9e9dcc3f2f1001f0": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2792. Replace usage of node ip-addresses with hostnames. Contributed by Vinod K V.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1178631 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/10/11 4:21 PM",
      "commitName": "12743d2169f5a24a9b3be07c9e9dcc3f2f1001f0",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "30/09/11 5:46 AM",
      "commitNameOld": "063e33a862f99ce93b8399924c35d39ccd880f01",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.44,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,103 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n       return realProxy;\n     }\n       //TODO RM NPEs for unknown jobs. History may still be aware.\n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     String serviceAddr \u003d null;\n     while (application \u003d\u003d null || YarnApplicationState.RUNNING.equals(application.getYarnApplicationState())) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n \n           LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n-          clientToken.setService(new Text(application.getHost() + \":\"\n-              + application.getRpcPort()));\n+          // RPC layer client expects ip:port as service for tokens\n+          InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n+              .getHost(), application.getRpcPort());\n+          clientToken.setService(new Text(addr.getAddress().getHostAddress()\n+              + \":\" + addr.getPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n         LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n \n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n         application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n \n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n \n     //History server can serve a job only if application\n     //succeeded.\n     if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n       LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n           + application.getFinalApplicationStatus().toString()\n           + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n      //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null || YarnApplicationState.RUNNING.equals(application.getYarnApplicationState())) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          // RPC layer client expects ip:port as service for tokens\n          InetSocketAddress addr \u003d NetUtils.createSocketAddr(application\n              .getHost(), application.getRpcPort());\n          clientToken.setService(new Text(addr.getAddress().getHostAddress()\n              + \":\" + addr.getPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "063e33a862f99ce93b8399924c35d39ccd880f01": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3098. Fixed RM and MR AM to report YarnApplicationState and application\u0027s FinalStatus separately. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1177633 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/09/11 5:46 AM",
      "commitName": "063e33a862f99ce93b8399924c35d39ccd880f01",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "29/09/11 8:08 PM",
      "commitNameOld": "0b3c654d83c5e73fe946de194f3aea0a9fe06f5a",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.4,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,100 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n       return realProxy;\n     }\n       //TODO RM NPEs for unknown jobs. History may still be aware.\n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     if (application !\u003d null) {\n       trackingUrl \u003d application.getTrackingUrl();\n     }\n     String serviceAddr \u003d null;\n-    while (application \u003d\u003d null || ApplicationState.RUNNING.equals(application.getState())) {\n+    while (application \u003d\u003d null || YarnApplicationState.RUNNING.equals(application.getYarnApplicationState())) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n-   \n-          LOG.debug(\"Application state is \" + application.getState());\n+\n+          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           clientToken.setService(new Text(application.getHost() + \":\"\n               + application.getRpcPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n         LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n-        LOG.info(\"Could not connect to \" + serviceAddr + \n+        LOG.info(\"Could not connect to \" + serviceAddr +\n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n-     * block on it. This is to be able to return job status \n+     * block on it. This is to be able to return job status\n      * on an allocating Application.\n      */\n-    \n+\n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n-    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n-        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n+    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n+        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n-    \n-    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n+\n+    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n-    \n-    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n+\n+    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n-    \n-    //History server can serve a job only if application \n+\n+    //History server can serve a job only if application\n     //succeeded.\n-    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n-      LOG.info(\"Application state is completed. \" +\n-          \"Redirecting to job history server\");\n+    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n+      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n+          + application.getFinalApplicationStatus().toString()\n+          + \". Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n      //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null || YarnApplicationState.RUNNING.equals(application.getYarnApplicationState())) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n\n          LOG.debug(\"Application state is \" + application.getYarnApplicationState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr +\n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status\n     * on an allocating Application.\n     */\n\n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.NEW ||\n        application.getYarnApplicationState() \u003d\u003d YarnApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n\n    //History server can serve a job only if application\n    //succeeded.\n    if (application.getYarnApplicationState() \u003d\u003d YarnApplicationState.FINISHED) {\n      LOG.info(\"Application state is completed. FinalApplicationStatus\u003d\"\n          + application.getFinalApplicationStatus().toString()\n          + \". Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "0b3c654d83c5e73fe946de194f3aea0a9fe06f5a": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2791. Added missing info on \u0027job -status\u0027 output. Contributed by Devaraj K.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1177487 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/09/11 8:08 PM",
      "commitName": "0b3c654d83c5e73fe946de194f3aea0a9fe06f5a",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "27/09/11 1:30 PM",
      "commitNameOld": "0d2bb0623696c2cc822cb44e431345b2c773dbff",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 2.28,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,99 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n       return realProxy;\n     }\n       //TODO RM NPEs for unknown jobs. History may still be aware.\n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n+    if (application !\u003d null) {\n+      trackingUrl \u003d application.getTrackingUrl();\n+    }\n     String serviceAddr \u003d null;\n     while (application \u003d\u003d null || ApplicationState.RUNNING.equals(application.getState())) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n         return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n    \n           LOG.debug(\"Application state is \" + application.getState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           clientToken.setService(new Text(application.getHost() + \":\"\n               + application.getRpcPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n         LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr + \n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n           return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status \n      * on an allocating Application.\n      */\n     \n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getState() \u003d\u003d ApplicationState.NEW ||\n         application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.NEW);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.FAILED);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(application, JobState.KILLED);\n     }\n     \n     //History server can serve a job only if application \n     //succeeded.\n     if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n       LOG.info(\"Application state is completed. \" +\n           \"Redirecting to job history server\");\n       realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n      //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    if (application !\u003d null) {\n      trackingUrl \u003d application.getTrackingUrl();\n    }\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null || ApplicationState.RUNNING.equals(application.getState())) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n   \n          LOG.debug(\"Application state is \" + application.getState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr + \n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status \n     * on an allocating Application.\n     */\n    \n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n    \n    //History server can serve a job only if application \n    //succeeded.\n    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n      LOG.info(\"Application state is completed. \" +\n          \"Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2952. Fixed ResourceManager/MR-client to consume diagnostics for AM failures in a couple of corner cases. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1175403 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/09/11 7:46 AM",
      "commitName": "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "19/09/11 5:26 AM",
      "commitNameOld": "29552eeb36dd8a9246fb648d65b5cfb94ae46d77",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.1,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,96 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n       return realProxy;\n     }\n       //TODO RM NPEs for unknown jobs. History may still be aware.\n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     String serviceAddr \u003d null;\n     while (application \u003d\u003d null || ApplicationState.RUNNING.equals(application.getState())) {\n       if (application \u003d\u003d null) {\n         LOG.info(\"Could not get Job info from RM for job \" + jobId\n             + \". Redirecting to job history server.\");\n-        return checkAndGetHSProxy(UNKNOWN_USER, JobState.NEW);\n+        return checkAndGetHSProxy(null, JobState.NEW);\n       }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n    \n           LOG.debug(\"Application state is \" + application.getState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           clientToken.setService(new Text(application.getHost() + \":\"\n               + application.getRpcPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n         LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr + \n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n         if (application \u003d\u003d null) {\n           LOG.info(\"Could not get Job info from RM for job \" + jobId\n               + \". Redirecting to job history server.\");\n-          return checkAndGetHSProxy(UNKNOWN_USER, JobState.RUNNING);\n+          return checkAndGetHSProxy(null, JobState.RUNNING);\n         }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status \n      * on an allocating Application.\n      */\n     \n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getState() \u003d\u003d ApplicationState.NEW ||\n         application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n-      return getNotRunningJob(user, JobState.NEW);\n+      return getNotRunningJob(application, JobState.NEW);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n       realProxy \u003d null;\n-      return getNotRunningJob(user, JobState.FAILED);\n+      return getNotRunningJob(application, JobState.FAILED);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n       realProxy \u003d null;\n-      return getNotRunningJob(user, JobState.KILLED);\n+      return getNotRunningJob(application, JobState.KILLED);\n     }\n     \n     //History server can serve a job only if application \n     //succeeded.\n     if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n       LOG.info(\"Application state is completed. \" +\n           \"Redirecting to job history server\");\n-      realProxy \u003d checkAndGetHSProxy(user, JobState.SUCCEEDED);\n+      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n      //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null || ApplicationState.RUNNING.equals(application.getState())) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(null, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n   \n          LOG.debug(\"Application state is \" + application.getState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr + \n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(null, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status \n     * on an allocating Application.\n     */\n    \n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.NEW);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.FAILED);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(application, JobState.KILLED);\n    }\n    \n    //History server can serve a job only if application \n    //succeeded.\n    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n      LOG.info(\"Application state is completed. \" +\n          \"Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(application, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "29552eeb36dd8a9246fb648d65b5cfb94ae46d77": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2925. Fixed Yarn+MR client code to behave saner with completed jobs. Contributed by Devaraj K.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1172587 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/09/11 5:26 AM",
      "commitName": "29552eeb36dd8a9246fb648d65b5cfb94ae46d77",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "08/09/11 8:01 PM",
      "commitNameOld": "71e05154330c084310b6e32bfd6397c29b4e0534",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 10.39,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,96 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n       return realProxy;\n     }\n       //TODO RM NPEs for unknown jobs. History may still be aware.\n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     String serviceAddr \u003d null;\n-    while (ApplicationState.RUNNING.equals(application.getState())) {\n+    while (application \u003d\u003d null || ApplicationState.RUNNING.equals(application.getState())) {\n+      if (application \u003d\u003d null) {\n+        LOG.info(\"Could not get Job info from RM for job \" + jobId\n+            + \". Redirecting to job history server.\");\n+        return checkAndGetHSProxy(UNKNOWN_USER, JobState.NEW);\n+      }\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n    \n           LOG.debug(\"Application state is \" + application.getState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           clientToken.setService(new Text(application.getHost() + \":\"\n               + application.getRpcPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n         LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr + \n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n+        if (application \u003d\u003d null) {\n+          LOG.info(\"Could not get Job info from RM for job \" + jobId\n+              + \". Redirecting to job history server.\");\n+          return checkAndGetHSProxy(UNKNOWN_USER, JobState.RUNNING);\n+        }\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status \n      * on an allocating Application.\n      */\n     \n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n-      throw new YarnRemoteExceptionPBImpl(\"User is not set in the application report\");\n+      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n     }\n     if (application.getState() \u003d\u003d ApplicationState.NEW ||\n         application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(user, JobState.NEW);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(user, JobState.FAILED);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(user, JobState.KILLED);\n     }\n     \n     //History server can serve a job only if application \n     //succeeded.\n     if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n       LOG.info(\"Application state is completed. \" +\n           \"Redirecting to job history server\");\n-      realProxy \u003d historyServerProxy;\n+      realProxy \u003d checkAndGetHSProxy(user, JobState.SUCCEEDED);\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n      //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    String serviceAddr \u003d null;\n    while (application \u003d\u003d null || ApplicationState.RUNNING.equals(application.getState())) {\n      if (application \u003d\u003d null) {\n        LOG.info(\"Could not get Job info from RM for job \" + jobId\n            + \". Redirecting to job history server.\");\n        return checkAndGetHSProxy(UNKNOWN_USER, JobState.NEW);\n      }\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n   \n          LOG.debug(\"Application state is \" + application.getState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr + \n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n        if (application \u003d\u003d null) {\n          LOG.info(\"Could not get Job info from RM for job \" + jobId\n              + \". Redirecting to job history server.\");\n          return checkAndGetHSProxy(UNKNOWN_USER, JobState.RUNNING);\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status \n     * on an allocating Application.\n     */\n    \n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw RPCUtil.getRemoteException(\"User is not set in the application report\");\n    }\n    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.NEW);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.FAILED);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.KILLED);\n    }\n    \n    //History server can serve a job only if application \n    //succeeded.\n    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n      LOG.info(\"Application state is completed. \" +\n          \"Redirecting to job history server\");\n      realProxy \u003d checkAndGetHSProxy(user, JobState.SUCCEEDED);\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "71e05154330c084310b6e32bfd6397c29b4e0534": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2963. Fix hang in TestMRJobs. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166975 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 8:01 PM",
      "commitName": "71e05154330c084310b6e32bfd6397c29b4e0534",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "08/09/11 11:26 AM",
      "commitNameOld": "1f46b991da9b91585608a0babd3eda39485dce09",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.36,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,86 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n       return realProxy;\n     }\n       //TODO RM NPEs for unknown jobs. History may still be aware.\n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     String serviceAddr \u003d null;\n     while (ApplicationState.RUNNING.equals(application.getState())) {\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n    \n           LOG.debug(\"Application state is \" + application.getState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           clientToken.setService(new Text(application.getHost() + \":\"\n               + application.getRpcPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n         LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n         return realProxy;\n       } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr + \n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n           LOG.warn(\"getProxy() call interruped\", e1);\n           throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n       } catch (InterruptedException e) {\n         LOG.warn(\"getProxy() call interruped\", e);\n         throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status \n      * on an allocating Application.\n      */\n     \n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw new YarnRemoteExceptionPBImpl(\"User is not set in the application report\");\n     }\n     if (application.getState() \u003d\u003d ApplicationState.NEW ||\n         application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(user, JobState.NEW);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(user, JobState.FAILED);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(user, JobState.KILLED);\n     }\n     \n     //History server can serve a job only if application \n     //succeeded.\n     if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n       LOG.info(\"Application state is completed. \" +\n-          \"Redirecting to job history server \" + serviceAddr);\n+          \"Redirecting to job history server\");\n       realProxy \u003d historyServerProxy;\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n      //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    String serviceAddr \u003d null;\n    while (ApplicationState.RUNNING.equals(application.getState())) {\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n   \n          LOG.debug(\"Application state is \" + application.getState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr + \n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status \n     * on an allocating Application.\n     */\n    \n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw new YarnRemoteExceptionPBImpl(\"User is not set in the application report\");\n    }\n    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.NEW);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.FAILED);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.KILLED);\n    }\n    \n    //History server can serve a job only if application \n    //succeeded.\n    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n      LOG.info(\"Application state is completed. \" +\n          \"Redirecting to job history server\");\n      realProxy \u003d historyServerProxy;\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "1f46b991da9b91585608a0babd3eda39485dce09": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2908. Fix all findbugs warnings. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166838 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 11:26 AM",
      "commitName": "1f46b991da9b91585608a0babd3eda39485dce09",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "02/09/11 11:22 PM",
      "commitNameOld": "6bdf5746d5d677f9c17598768c4ae86384c000c6",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.5,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,86 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n       return realProxy;\n     }\n       //TODO RM NPEs for unknown jobs. History may still be aware.\n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     String serviceAddr \u003d null;\n     while (ApplicationState.RUNNING.equals(application.getState())) {\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n    \n           LOG.debug(\"Application state is \" + application.getState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           clientToken.setService(new Text(application.getHost() + \":\"\n               + application.getRpcPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n         LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n         return realProxy;\n-      } catch (Exception e) {\n-        //possibly\n+      } catch (IOException e) {\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr + \n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n+          LOG.warn(\"getProxy() call interruped\", e1);\n+          throw new YarnException(e1);\n         }\n         application \u003d rm.getApplicationReport(appId);\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"getProxy() call interruped\", e);\n+        throw new YarnException(e);\n       }\n     }\n \n     /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status \n      * on an allocating Application.\n      */\n     \n     String user \u003d application.getUser();\n     if (user \u003d\u003d null) {\n       throw new YarnRemoteExceptionPBImpl(\"User is not set in the application report\");\n     }\n     if (application.getState() \u003d\u003d ApplicationState.NEW ||\n         application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n       return getNotRunningJob(user, JobState.NEW);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n       realProxy \u003d null;\n       return getNotRunningJob(user, JobState.FAILED);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n       realProxy \u003d null;\n       return getNotRunningJob(user, JobState.KILLED);\n     }\n     \n     //History server can serve a job only if application \n     //succeeded.\n     if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n       LOG.info(\"Application state is completed. \" +\n           \"Redirecting to job history server \" + serviceAddr);\n       realProxy \u003d historyServerProxy;\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n      //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    String serviceAddr \u003d null;\n    while (ApplicationState.RUNNING.equals(application.getState())) {\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n   \n          LOG.debug(\"Application state is \" + application.getState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (IOException e) {\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr + \n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          LOG.warn(\"getProxy() call interruped\", e1);\n          throw new YarnException(e1);\n        }\n        application \u003d rm.getApplicationReport(appId);\n      } catch (InterruptedException e) {\n        LOG.warn(\"getProxy() call interruped\", e);\n        throw new YarnException(e);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status \n     * on an allocating Application.\n     */\n    \n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw new YarnRemoteExceptionPBImpl(\"User is not set in the application report\");\n    }\n    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.NEW);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.FAILED);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.KILLED);\n    }\n    \n    //History server can serve a job only if application \n    //succeeded.\n    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n      LOG.info(\"Application state is completed. \" +\n          \"Redirecting to job history server \" + serviceAddr);\n      realProxy \u003d historyServerProxy;\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "6bdf5746d5d677f9c17598768c4ae86384c000c6": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2716. MRReliabilityTest job fails because of missing job-file. Contributed by Jeffrey Naisbitt.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1164805 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/09/11 11:22 PM",
      "commitName": "6bdf5746d5d677f9c17598768c4ae86384c000c6",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/11 11:35 PM",
      "commitNameOld": "f2b91a8367a762091482074505618b570a520b19",
      "commitAuthorOld": "Sharad Agarwal",
      "daysBetweenCommits": 8.99,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,82 @@\n   private MRClientProtocol getProxy() throws YarnRemoteException {\n     if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n       return realProxy;\n     }\n       //TODO RM NPEs for unknown jobs. History may still be aware.\n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n     ApplicationReport application \u003d rm.getApplicationReport(appId);\n     String serviceAddr \u003d null;\n     while (ApplicationState.RUNNING.equals(application.getState())) {\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n    \n           LOG.debug(\"Application state is \" + application.getState());\n           application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           clientToken.setService(new Text(application.getHost() + \":\"\n               + application.getRpcPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n         LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n         return realProxy;\n       } catch (Exception e) {\n         //possibly\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr + \n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n         }\n         application \u003d rm.getApplicationReport(appId);\n       }\n     }\n \n-    /** we just want to return if its allocating, so that we dont \n+    /** we just want to return if its allocating, so that we don\u0027t\n      * block on it. This is to be able to return job status \n-     * on a allocating Application.\n+     * on an allocating Application.\n      */\n     \n+    String user \u003d application.getUser();\n+    if (user \u003d\u003d null) {\n+      throw new YarnRemoteExceptionPBImpl(\"User is not set in the application report\");\n+    }\n     if (application.getState() \u003d\u003d ApplicationState.NEW ||\n         application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n-      return NOTSTARTEDJOB;\n+      return getNotRunningJob(user, JobState.NEW);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n       realProxy \u003d null;\n-      return FAILEDJOB;\n+      return getNotRunningJob(user, JobState.FAILED);\n     }\n     \n     if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n-        realProxy \u003d null;\n-        return KILLEDJOB;\n-      }\n+      realProxy \u003d null;\n+      return getNotRunningJob(user, JobState.KILLED);\n+    }\n     \n     //History server can serve a job only if application \n     //succeeded.\n     if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n       LOG.info(\"Application state is completed. \" +\n           \"Redirecting to job history server \" + serviceAddr);\n       realProxy \u003d historyServerProxy;\n     }\n     return realProxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n      //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    String serviceAddr \u003d null;\n    while (ApplicationState.RUNNING.equals(application.getState())) {\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n   \n          LOG.debug(\"Application state is \" + application.getState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (Exception e) {\n        //possibly\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr + \n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n        }\n        application \u003d rm.getApplicationReport(appId);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we don\u0027t\n     * block on it. This is to be able to return job status \n     * on an allocating Application.\n     */\n    \n    String user \u003d application.getUser();\n    if (user \u003d\u003d null) {\n      throw new YarnRemoteExceptionPBImpl(\"User is not set in the application report\");\n    }\n    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.NEW);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.FAILED);\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n      realProxy \u003d null;\n      return getNotRunningJob(user, JobState.KILLED);\n    }\n    \n    //History server can serve a job only if application \n    //succeeded.\n    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n      LOG.info(\"Application state is completed. \" +\n          \"Redirecting to job history server \" + serviceAddr);\n      realProxy \u003d historyServerProxy;\n    }\n    return realProxy;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {}
    },
    "f2b91a8367a762091482074505618b570a520b19": {
      "type": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
      "commitMessage": " MAPREDUCE-2807. Fix AM restart and client redirection. Contributed by Sharad Agarwal.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161408 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 11:35 PM",
      "commitName": "f2b91a8367a762091482074505618b570a520b19",
      "commitAuthor": "Sharad Agarwal",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": " MAPREDUCE-2807. Fix AM restart and client redirection. Contributed by Sharad Agarwal.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161408 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "24/08/11 11:35 PM",
          "commitName": "f2b91a8367a762091482074505618b570a520b19",
          "commitAuthor": "Sharad Agarwal",
          "commitDateOld": "24/08/11 5:14 PM",
          "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 0.26,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,77 +1,78 @@\n-  private void refreshProxy() throws YarnRemoteException {\n-    //TODO RM NPEs for unknown jobs. History may still be aware.\n+  private MRClientProtocol getProxy() throws YarnRemoteException {\n+    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n+      return realProxy;\n+    }\n+      //TODO RM NPEs for unknown jobs. History may still be aware.\n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n-    ApplicationReport application \u003d rm.getApplicationReport(currentAppId);\n+    ApplicationReport application \u003d rm.getApplicationReport(appId);\n+    String serviceAddr \u003d null;\n     while (ApplicationState.RUNNING.equals(application.getState())) {\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n    \n           LOG.debug(\"Application state is \" + application.getState());\n-          application \u003d rm.getApplicationReport(currentAppId);\n+          application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n-        serviceHttpAddr \u003d application.getTrackingUrl();\n-        currentAppState \u003d application.getState();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           clientToken.setService(new Text(application.getHost() + \":\"\n               + application.getRpcPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n+        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n-        return;\n+        return realProxy;\n       } catch (Exception e) {\n         //possibly\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr + \n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n         }\n-        application \u003d rm.getApplicationReport(currentAppId);\n+        application \u003d rm.getApplicationReport(appId);\n       }\n     }\n \n-    currentAppState \u003d application.getState();\n     /** we just want to return if its allocating, so that we dont \n      * block on it. This is to be able to return job status \n      * on a allocating Application.\n      */\n     \n-    if (currentAppState \u003d\u003d ApplicationState.NEW) {\n+    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n+        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n-      return;\n+      return NOTSTARTEDJOB;\n     }\n     \n-    if (currentAppState \u003d\u003d ApplicationState.SUCCEEDED\n-        || currentAppState \u003d\u003d ApplicationState.FAILED\n-        || currentAppState \u003d\u003d ApplicationState.KILLED) {\n-      serviceAddr \u003d conf.get(JHConfig.HS_BIND_ADDRESS,\n-          JHConfig.DEFAULT_HS_BIND_ADDRESS);\n+    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n+      realProxy \u003d null;\n+      return FAILEDJOB;\n+    }\n+    \n+    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n+        realProxy \u003d null;\n+        return KILLEDJOB;\n+      }\n+    \n+    //History server can serve a job only if application \n+    //succeeded.\n+    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n       LOG.info(\"Application state is completed. \" +\n           \"Redirecting to job history server \" + serviceAddr);\n-      try {\n-        serviceHttpAddr \u003d JobHistoryUtils.getHistoryUrl(conf, currentAppId);\n-      } catch (UnknownHostException e) {\n-        LOG.warn(\"Unable to get history url\", e);\n-        serviceHttpAddr \u003d \"UNKNOWN\";\n-      }\n-      try {\n-        instantiateHistoryProxy(serviceAddr);\n-        return;\n-      } catch (IOException e) {\n-        throw new YarnException(e);\n-      }\n+      realProxy \u003d historyServerProxy;\n     }\n+    return realProxy;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n      //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    String serviceAddr \u003d null;\n    while (ApplicationState.RUNNING.equals(application.getState())) {\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n   \n          LOG.debug(\"Application state is \" + application.getState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (Exception e) {\n        //possibly\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr + \n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n        }\n        application \u003d rm.getApplicationReport(appId);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we dont \n     * block on it. This is to be able to return job status \n     * on a allocating Application.\n     */\n    \n    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return NOTSTARTEDJOB;\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n      realProxy \u003d null;\n      return FAILEDJOB;\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n        realProxy \u003d null;\n        return KILLEDJOB;\n      }\n    \n    //History server can serve a job only if application \n    //succeeded.\n    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n      LOG.info(\"Application state is completed. \" +\n          \"Redirecting to job history server \" + serviceAddr);\n      realProxy \u003d historyServerProxy;\n    }\n    return realProxy;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
          "extendedDetails": {
            "oldValue": "refreshProxy",
            "newValue": "getProxy"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": " MAPREDUCE-2807. Fix AM restart and client redirection. Contributed by Sharad Agarwal.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161408 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "24/08/11 11:35 PM",
          "commitName": "f2b91a8367a762091482074505618b570a520b19",
          "commitAuthor": "Sharad Agarwal",
          "commitDateOld": "24/08/11 5:14 PM",
          "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 0.26,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,77 +1,78 @@\n-  private void refreshProxy() throws YarnRemoteException {\n-    //TODO RM NPEs for unknown jobs. History may still be aware.\n+  private MRClientProtocol getProxy() throws YarnRemoteException {\n+    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n+      return realProxy;\n+    }\n+      //TODO RM NPEs for unknown jobs. History may still be aware.\n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n-    ApplicationReport application \u003d rm.getApplicationReport(currentAppId);\n+    ApplicationReport application \u003d rm.getApplicationReport(appId);\n+    String serviceAddr \u003d null;\n     while (ApplicationState.RUNNING.equals(application.getState())) {\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n    \n           LOG.debug(\"Application state is \" + application.getState());\n-          application \u003d rm.getApplicationReport(currentAppId);\n+          application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n-        serviceHttpAddr \u003d application.getTrackingUrl();\n-        currentAppState \u003d application.getState();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           clientToken.setService(new Text(application.getHost() + \":\"\n               + application.getRpcPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n+        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n-        return;\n+        return realProxy;\n       } catch (Exception e) {\n         //possibly\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr + \n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n         }\n-        application \u003d rm.getApplicationReport(currentAppId);\n+        application \u003d rm.getApplicationReport(appId);\n       }\n     }\n \n-    currentAppState \u003d application.getState();\n     /** we just want to return if its allocating, so that we dont \n      * block on it. This is to be able to return job status \n      * on a allocating Application.\n      */\n     \n-    if (currentAppState \u003d\u003d ApplicationState.NEW) {\n+    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n+        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n-      return;\n+      return NOTSTARTEDJOB;\n     }\n     \n-    if (currentAppState \u003d\u003d ApplicationState.SUCCEEDED\n-        || currentAppState \u003d\u003d ApplicationState.FAILED\n-        || currentAppState \u003d\u003d ApplicationState.KILLED) {\n-      serviceAddr \u003d conf.get(JHConfig.HS_BIND_ADDRESS,\n-          JHConfig.DEFAULT_HS_BIND_ADDRESS);\n+    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n+      realProxy \u003d null;\n+      return FAILEDJOB;\n+    }\n+    \n+    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n+        realProxy \u003d null;\n+        return KILLEDJOB;\n+      }\n+    \n+    //History server can serve a job only if application \n+    //succeeded.\n+    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n       LOG.info(\"Application state is completed. \" +\n           \"Redirecting to job history server \" + serviceAddr);\n-      try {\n-        serviceHttpAddr \u003d JobHistoryUtils.getHistoryUrl(conf, currentAppId);\n-      } catch (UnknownHostException e) {\n-        LOG.warn(\"Unable to get history url\", e);\n-        serviceHttpAddr \u003d \"UNKNOWN\";\n-      }\n-      try {\n-        instantiateHistoryProxy(serviceAddr);\n-        return;\n-      } catch (IOException e) {\n-        throw new YarnException(e);\n-      }\n+      realProxy \u003d historyServerProxy;\n     }\n+    return realProxy;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n      //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    String serviceAddr \u003d null;\n    while (ApplicationState.RUNNING.equals(application.getState())) {\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n   \n          LOG.debug(\"Application state is \" + application.getState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (Exception e) {\n        //possibly\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr + \n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n        }\n        application \u003d rm.getApplicationReport(appId);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we dont \n     * block on it. This is to be able to return job status \n     * on a allocating Application.\n     */\n    \n    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return NOTSTARTEDJOB;\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n      realProxy \u003d null;\n      return FAILEDJOB;\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n        realProxy \u003d null;\n        return KILLEDJOB;\n      }\n    \n    //History server can serve a job only if application \n    //succeeded.\n    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n      LOG.info(\"Application state is completed. \" +\n          \"Redirecting to job history server \" + serviceAddr);\n      realProxy \u003d historyServerProxy;\n    }\n    return realProxy;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "MRClientProtocol"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": " MAPREDUCE-2807. Fix AM restart and client redirection. Contributed by Sharad Agarwal.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161408 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "24/08/11 11:35 PM",
          "commitName": "f2b91a8367a762091482074505618b570a520b19",
          "commitAuthor": "Sharad Agarwal",
          "commitDateOld": "24/08/11 5:14 PM",
          "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 0.26,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,77 +1,78 @@\n-  private void refreshProxy() throws YarnRemoteException {\n-    //TODO RM NPEs for unknown jobs. History may still be aware.\n+  private MRClientProtocol getProxy() throws YarnRemoteException {\n+    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n+      return realProxy;\n+    }\n+      //TODO RM NPEs for unknown jobs. History may still be aware.\n     // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n     // and redirect to the history server.\n-    ApplicationReport application \u003d rm.getApplicationReport(currentAppId);\n+    ApplicationReport application \u003d rm.getApplicationReport(appId);\n+    String serviceAddr \u003d null;\n     while (ApplicationState.RUNNING.equals(application.getState())) {\n       try {\n         if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n           LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n           Thread.sleep(2000);\n    \n           LOG.debug(\"Application state is \" + application.getState());\n-          application \u003d rm.getApplicationReport(currentAppId);\n+          application \u003d rm.getApplicationReport(appId);\n           continue;\n         }\n         serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n-        serviceHttpAddr \u003d application.getTrackingUrl();\n-        currentAppState \u003d application.getState();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           String clientTokenEncoded \u003d application.getClientToken();\n           Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n             new Token\u003cApplicationTokenIdentifier\u003e();\n           clientToken.decodeFromUrlString(clientTokenEncoded);\n           clientToken.setService(new Text(application.getHost() + \":\"\n               + application.getRpcPort()));\n           UserGroupInformation.getCurrentUser().addToken(clientToken);\n         }\n+        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n         LOG.info(\"Connecting to \" + serviceAddr);\n         instantiateAMProxy(serviceAddr);\n-        return;\n+        return realProxy;\n       } catch (Exception e) {\n         //possibly\n         //possibly the AM has crashed\n         //there may be some time before AM is restarted\n         //keep retrying by getting the address from RM\n         LOG.info(\"Could not connect to \" + serviceAddr + \n         \". Waiting for getting the latest AM address...\");\n         try {\n           Thread.sleep(2000);\n         } catch (InterruptedException e1) {\n         }\n-        application \u003d rm.getApplicationReport(currentAppId);\n+        application \u003d rm.getApplicationReport(appId);\n       }\n     }\n \n-    currentAppState \u003d application.getState();\n     /** we just want to return if its allocating, so that we dont \n      * block on it. This is to be able to return job status \n      * on a allocating Application.\n      */\n     \n-    if (currentAppState \u003d\u003d ApplicationState.NEW) {\n+    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n+        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n       realProxy \u003d null;\n-      return;\n+      return NOTSTARTEDJOB;\n     }\n     \n-    if (currentAppState \u003d\u003d ApplicationState.SUCCEEDED\n-        || currentAppState \u003d\u003d ApplicationState.FAILED\n-        || currentAppState \u003d\u003d ApplicationState.KILLED) {\n-      serviceAddr \u003d conf.get(JHConfig.HS_BIND_ADDRESS,\n-          JHConfig.DEFAULT_HS_BIND_ADDRESS);\n+    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n+      realProxy \u003d null;\n+      return FAILEDJOB;\n+    }\n+    \n+    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n+        realProxy \u003d null;\n+        return KILLEDJOB;\n+      }\n+    \n+    //History server can serve a job only if application \n+    //succeeded.\n+    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n       LOG.info(\"Application state is completed. \" +\n           \"Redirecting to job history server \" + serviceAddr);\n-      try {\n-        serviceHttpAddr \u003d JobHistoryUtils.getHistoryUrl(conf, currentAppId);\n-      } catch (UnknownHostException e) {\n-        LOG.warn(\"Unable to get history url\", e);\n-        serviceHttpAddr \u003d \"UNKNOWN\";\n-      }\n-      try {\n-        instantiateHistoryProxy(serviceAddr);\n-        return;\n-      } catch (IOException e) {\n-        throw new YarnException(e);\n-      }\n+      realProxy \u003d historyServerProxy;\n     }\n+    return realProxy;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private MRClientProtocol getProxy() throws YarnRemoteException {\n    if (!forceRefresh \u0026\u0026 realProxy !\u003d null) {\n      return realProxy;\n    }\n      //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(appId);\n    String serviceAddr \u003d null;\n    while (ApplicationState.RUNNING.equals(application.getState())) {\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n   \n          LOG.debug(\"Application state is \" + application.getState());\n          application \u003d rm.getApplicationReport(appId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Tracking Url of JOB is \" + application.getTrackingUrl());\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return realProxy;\n      } catch (Exception e) {\n        //possibly\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr + \n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n        }\n        application \u003d rm.getApplicationReport(appId);\n      }\n    }\n\n    /** we just want to return if its allocating, so that we dont \n     * block on it. This is to be able to return job status \n     * on a allocating Application.\n     */\n    \n    if (application.getState() \u003d\u003d ApplicationState.NEW ||\n        application.getState() \u003d\u003d ApplicationState.SUBMITTED) {\n      realProxy \u003d null;\n      return NOTSTARTEDJOB;\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.FAILED) {\n      realProxy \u003d null;\n      return FAILEDJOB;\n    }\n    \n    if (application.getState() \u003d\u003d ApplicationState.KILLED) {\n        realProxy \u003d null;\n        return KILLEDJOB;\n      }\n    \n    //History server can serve a job only if application \n    //succeeded.\n    if (application.getState() \u003d\u003d ApplicationState.SUCCEEDED) {\n      LOG.info(\"Application state is completed. \" +\n          \"Redirecting to job history server \" + serviceAddr);\n      realProxy \u003d historyServerProxy;\n    }\n    return realProxy;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
          "extendedDetails": {}
        }
      ]
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void refreshProxy() throws YarnRemoteException {\n    //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(currentAppId);\n    while (ApplicationState.RUNNING.equals(application.getState())) {\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n   \n          LOG.debug(\"Application state is \" + application.getState());\n          application \u003d rm.getApplicationReport(currentAppId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        serviceHttpAddr \u003d application.getTrackingUrl();\n        currentAppState \u003d application.getState();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return;\n      } catch (Exception e) {\n        //possibly\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr + \n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n        }\n        application \u003d rm.getApplicationReport(currentAppId);\n      }\n    }\n\n    currentAppState \u003d application.getState();\n    /** we just want to return if its allocating, so that we dont \n     * block on it. This is to be able to return job status \n     * on a allocating Application.\n     */\n    \n    if (currentAppState \u003d\u003d ApplicationState.NEW) {\n      realProxy \u003d null;\n      return;\n    }\n    \n    if (currentAppState \u003d\u003d ApplicationState.SUCCEEDED\n        || currentAppState \u003d\u003d ApplicationState.FAILED\n        || currentAppState \u003d\u003d ApplicationState.KILLED) {\n      serviceAddr \u003d conf.get(JHConfig.HS_BIND_ADDRESS,\n          JHConfig.DEFAULT_HS_BIND_ADDRESS);\n      LOG.info(\"Application state is completed. \" +\n          \"Redirecting to job history server \" + serviceAddr);\n      try {\n        serviceHttpAddr \u003d JobHistoryUtils.getHistoryUrl(conf, currentAppId);\n      } catch (UnknownHostException e) {\n        LOG.warn(\"Unable to get history url\", e);\n        serviceHttpAddr \u003d \"UNKNOWN\";\n      }\n      try {\n        instantiateHistoryProxy(serviceAddr);\n        return;\n      } catch (IOException e) {\n        throw new YarnException(e);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,77 @@\n+  private void refreshProxy() throws YarnRemoteException {\n+    //TODO RM NPEs for unknown jobs. History may still be aware.\n+    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n+    // and redirect to the history server.\n+    ApplicationReport application \u003d rm.getApplicationReport(currentAppId);\n+    while (ApplicationState.RUNNING.equals(application.getState())) {\n+      try {\n+        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n+          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n+          Thread.sleep(2000);\n+   \n+          LOG.debug(\"Application state is \" + application.getState());\n+          application \u003d rm.getApplicationReport(currentAppId);\n+          continue;\n+        }\n+        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n+        serviceHttpAddr \u003d application.getTrackingUrl();\n+        currentAppState \u003d application.getState();\n+        if (UserGroupInformation.isSecurityEnabled()) {\n+          String clientTokenEncoded \u003d application.getClientToken();\n+          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n+            new Token\u003cApplicationTokenIdentifier\u003e();\n+          clientToken.decodeFromUrlString(clientTokenEncoded);\n+          clientToken.setService(new Text(application.getHost() + \":\"\n+              + application.getRpcPort()));\n+          UserGroupInformation.getCurrentUser().addToken(clientToken);\n+        }\n+        LOG.info(\"Connecting to \" + serviceAddr);\n+        instantiateAMProxy(serviceAddr);\n+        return;\n+      } catch (Exception e) {\n+        //possibly\n+        //possibly the AM has crashed\n+        //there may be some time before AM is restarted\n+        //keep retrying by getting the address from RM\n+        LOG.info(\"Could not connect to \" + serviceAddr + \n+        \". Waiting for getting the latest AM address...\");\n+        try {\n+          Thread.sleep(2000);\n+        } catch (InterruptedException e1) {\n+        }\n+        application \u003d rm.getApplicationReport(currentAppId);\n+      }\n+    }\n+\n+    currentAppState \u003d application.getState();\n+    /** we just want to return if its allocating, so that we dont \n+     * block on it. This is to be able to return job status \n+     * on a allocating Application.\n+     */\n+    \n+    if (currentAppState \u003d\u003d ApplicationState.NEW) {\n+      realProxy \u003d null;\n+      return;\n+    }\n+    \n+    if (currentAppState \u003d\u003d ApplicationState.SUCCEEDED\n+        || currentAppState \u003d\u003d ApplicationState.FAILED\n+        || currentAppState \u003d\u003d ApplicationState.KILLED) {\n+      serviceAddr \u003d conf.get(JHConfig.HS_BIND_ADDRESS,\n+          JHConfig.DEFAULT_HS_BIND_ADDRESS);\n+      LOG.info(\"Application state is completed. \" +\n+          \"Redirecting to job history server \" + serviceAddr);\n+      try {\n+        serviceHttpAddr \u003d JobHistoryUtils.getHistoryUrl(conf, currentAppId);\n+      } catch (UnknownHostException e) {\n+        LOG.warn(\"Unable to get history url\", e);\n+        serviceHttpAddr \u003d \"UNKNOWN\";\n+      }\n+      try {\n+        instantiateHistoryProxy(serviceAddr);\n+        return;\n+      } catch (IOException e) {\n+        throw new YarnException(e);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void refreshProxy() throws YarnRemoteException {\n    //TODO RM NPEs for unknown jobs. History may still be aware.\n    // Possibly allow nulls through the PB tunnel, otherwise deal with an exception\n    // and redirect to the history server.\n    ApplicationReport application \u003d rm.getApplicationReport(currentAppId);\n    while (ApplicationState.RUNNING.equals(application.getState())) {\n      try {\n        if (application.getHost() \u003d\u003d null || \"\".equals(application.getHost())) {\n          LOG.debug(\"AM not assigned to Job. Waiting to get the AM ...\");\n          Thread.sleep(2000);\n   \n          LOG.debug(\"Application state is \" + application.getState());\n          application \u003d rm.getApplicationReport(currentAppId);\n          continue;\n        }\n        serviceAddr \u003d application.getHost() + \":\" + application.getRpcPort();\n        serviceHttpAddr \u003d application.getTrackingUrl();\n        currentAppState \u003d application.getState();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          String clientTokenEncoded \u003d application.getClientToken();\n          Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d\n            new Token\u003cApplicationTokenIdentifier\u003e();\n          clientToken.decodeFromUrlString(clientTokenEncoded);\n          clientToken.setService(new Text(application.getHost() + \":\"\n              + application.getRpcPort()));\n          UserGroupInformation.getCurrentUser().addToken(clientToken);\n        }\n        LOG.info(\"Connecting to \" + serviceAddr);\n        instantiateAMProxy(serviceAddr);\n        return;\n      } catch (Exception e) {\n        //possibly\n        //possibly the AM has crashed\n        //there may be some time before AM is restarted\n        //keep retrying by getting the address from RM\n        LOG.info(\"Could not connect to \" + serviceAddr + \n        \". Waiting for getting the latest AM address...\");\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n        }\n        application \u003d rm.getApplicationReport(currentAppId);\n      }\n    }\n\n    currentAppState \u003d application.getState();\n    /** we just want to return if its allocating, so that we dont \n     * block on it. This is to be able to return job status \n     * on a allocating Application.\n     */\n    \n    if (currentAppState \u003d\u003d ApplicationState.NEW) {\n      realProxy \u003d null;\n      return;\n    }\n    \n    if (currentAppState \u003d\u003d ApplicationState.SUCCEEDED\n        || currentAppState \u003d\u003d ApplicationState.FAILED\n        || currentAppState \u003d\u003d ApplicationState.KILLED) {\n      serviceAddr \u003d conf.get(JHConfig.HS_BIND_ADDRESS,\n          JHConfig.DEFAULT_HS_BIND_ADDRESS);\n      LOG.info(\"Application state is completed. \" +\n          \"Redirecting to job history server \" + serviceAddr);\n      try {\n        serviceHttpAddr \u003d JobHistoryUtils.getHistoryUrl(conf, currentAppId);\n      } catch (UnknownHostException e) {\n        LOG.warn(\"Unable to get history url\", e);\n        serviceHttpAddr \u003d \"UNKNOWN\";\n      }\n      try {\n        instantiateHistoryProxy(serviceAddr);\n        return;\n      } catch (IOException e) {\n        throw new YarnException(e);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/ClientServiceDelegate.java"
    }
  }
}