{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineCollector.java",
  "functionName": "aggregateTo",
  "functionId": "aggregateTo___metric-TimelineMetric__e-TimelineEntity__aggregationGroupId-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/TimelineCollector.java",
  "functionStartLine": 374,
  "functionEndLine": 406,
  "numCommitsSeen": 18,
  "timeTaken": 955,
  "changeHistory": [
    "54e2b9e876fd91712c14ffbc4c49cd946f305aeb",
    "39cce4e629aadb7fadf1fb14a23108f55b59eb21"
  ],
  "changeHistoryShort": {
    "54e2b9e876fd91712c14ffbc4c49cd946f305aeb": "Ybodychange",
    "39cce4e629aadb7fadf1fb14a23108f55b59eb21": "Yintroduced"
  },
  "changeHistoryDetails": {
    "54e2b9e876fd91712c14ffbc4c49cd946f305aeb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6375 App level aggregation should not consider metric values reported in the previous aggregation cycle (Varun Saxena via Vrushali C)\n",
      "commitDate": "04/05/17 3:25 PM",
      "commitName": "54e2b9e876fd91712c14ffbc4c49cd946f305aeb",
      "commitAuthor": "Vrushali Channapattan",
      "commitDateOld": "27/04/17 2:31 AM",
      "commitNameOld": "793bbf216dc6d44ea57c778037bd461513fa6078",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 7.54,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,33 @@\n     public TimelineEntity aggregateTo(TimelineMetric metric, TimelineEntity e,\n         String aggregationGroupId) {\n       if (metric.getRealtimeAggregationOp() \u003d\u003d TimelineMetricOperation.NOP) {\n         return e;\n       }\n       Map\u003cString, TimelineMetric\u003e aggrRow \u003d aggregateTable.get(metric);\n       if (aggrRow !\u003d null) {\n         TimelineMetric aggrMetric \u003d new TimelineMetric();\n         if (aggregationGroupId.length() \u003e 0) {\n           aggrMetric.setId(metric.getId() + SEPARATOR + aggregationGroupId);\n         } else {\n           aggrMetric.setId(metric.getId());\n         }\n         aggrMetric.setRealtimeAggregationOp(TimelineMetricOperation.NOP);\n         Map\u003cObject, Object\u003e status \u003d new HashMap\u003c\u003e();\n-        for (TimelineMetric m : aggrRow.values()) {\n-          TimelineMetric.aggregateTo(m, aggrMetric, status);\n-          // getRealtimeAggregationOp returns an enum so we can directly\n-          // compare with \"!\u003d\".\n-          if (m.getRealtimeAggregationOp()\n-              !\u003d aggrMetric.getRealtimeAggregationOp()) {\n-            aggrMetric.setRealtimeAggregationOp(m.getRealtimeAggregationOp());\n+        synchronized (aggrRow) {\n+          for (TimelineMetric m : aggrRow.values()) {\n+            TimelineMetric.aggregateTo(m, aggrMetric, status);\n+            // getRealtimeAggregationOp returns an enum so we can directly\n+            // compare with \"!\u003d\".\n+            if (m.getRealtimeAggregationOp()\n+                !\u003d aggrMetric.getRealtimeAggregationOp()) {\n+              aggrMetric.setRealtimeAggregationOp(m.getRealtimeAggregationOp());\n+            }\n           }\n+          aggrRow.clear();\n         }\n         Set\u003cTimelineMetric\u003e metrics \u003d e.getMetrics();\n         metrics.remove(aggrMetric);\n         metrics.add(aggrMetric);\n       }\n       return e;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public TimelineEntity aggregateTo(TimelineMetric metric, TimelineEntity e,\n        String aggregationGroupId) {\n      if (metric.getRealtimeAggregationOp() \u003d\u003d TimelineMetricOperation.NOP) {\n        return e;\n      }\n      Map\u003cString, TimelineMetric\u003e aggrRow \u003d aggregateTable.get(metric);\n      if (aggrRow !\u003d null) {\n        TimelineMetric aggrMetric \u003d new TimelineMetric();\n        if (aggregationGroupId.length() \u003e 0) {\n          aggrMetric.setId(metric.getId() + SEPARATOR + aggregationGroupId);\n        } else {\n          aggrMetric.setId(metric.getId());\n        }\n        aggrMetric.setRealtimeAggregationOp(TimelineMetricOperation.NOP);\n        Map\u003cObject, Object\u003e status \u003d new HashMap\u003c\u003e();\n        synchronized (aggrRow) {\n          for (TimelineMetric m : aggrRow.values()) {\n            TimelineMetric.aggregateTo(m, aggrMetric, status);\n            // getRealtimeAggregationOp returns an enum so we can directly\n            // compare with \"!\u003d\".\n            if (m.getRealtimeAggregationOp()\n                !\u003d aggrMetric.getRealtimeAggregationOp()) {\n              aggrMetric.setRealtimeAggregationOp(m.getRealtimeAggregationOp());\n            }\n          }\n          aggrRow.clear();\n        }\n        Set\u003cTimelineMetric\u003e metrics \u003d e.getMetrics();\n        metrics.remove(aggrMetric);\n        metrics.add(aggrMetric);\n      }\n      return e;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/TimelineCollector.java",
      "extendedDetails": {}
    },
    "39cce4e629aadb7fadf1fb14a23108f55b59eb21": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3816. [Aggregation] App-level aggregation and accumulation for YARN system metrics (Li Lu via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "39cce4e629aadb7fadf1fb14a23108f55b59eb21",
      "commitAuthor": "Sangjin Lee",
      "diff": "@@ -0,0 +1,30 @@\n+    public TimelineEntity aggregateTo(TimelineMetric metric, TimelineEntity e,\n+        String aggregationGroupId) {\n+      if (metric.getRealtimeAggregationOp() \u003d\u003d TimelineMetricOperation.NOP) {\n+        return e;\n+      }\n+      Map\u003cString, TimelineMetric\u003e aggrRow \u003d aggregateTable.get(metric);\n+      if (aggrRow !\u003d null) {\n+        TimelineMetric aggrMetric \u003d new TimelineMetric();\n+        if (aggregationGroupId.length() \u003e 0) {\n+          aggrMetric.setId(metric.getId() + SEPARATOR + aggregationGroupId);\n+        } else {\n+          aggrMetric.setId(metric.getId());\n+        }\n+        aggrMetric.setRealtimeAggregationOp(TimelineMetricOperation.NOP);\n+        Map\u003cObject, Object\u003e status \u003d new HashMap\u003c\u003e();\n+        for (TimelineMetric m : aggrRow.values()) {\n+          TimelineMetric.aggregateTo(m, aggrMetric, status);\n+          // getRealtimeAggregationOp returns an enum so we can directly\n+          // compare with \"!\u003d\".\n+          if (m.getRealtimeAggregationOp()\n+              !\u003d aggrMetric.getRealtimeAggregationOp()) {\n+            aggrMetric.setRealtimeAggregationOp(m.getRealtimeAggregationOp());\n+          }\n+        }\n+        Set\u003cTimelineMetric\u003e metrics \u003d e.getMetrics();\n+        metrics.remove(aggrMetric);\n+        metrics.add(aggrMetric);\n+      }\n+      return e;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public TimelineEntity aggregateTo(TimelineMetric metric, TimelineEntity e,\n        String aggregationGroupId) {\n      if (metric.getRealtimeAggregationOp() \u003d\u003d TimelineMetricOperation.NOP) {\n        return e;\n      }\n      Map\u003cString, TimelineMetric\u003e aggrRow \u003d aggregateTable.get(metric);\n      if (aggrRow !\u003d null) {\n        TimelineMetric aggrMetric \u003d new TimelineMetric();\n        if (aggregationGroupId.length() \u003e 0) {\n          aggrMetric.setId(metric.getId() + SEPARATOR + aggregationGroupId);\n        } else {\n          aggrMetric.setId(metric.getId());\n        }\n        aggrMetric.setRealtimeAggregationOp(TimelineMetricOperation.NOP);\n        Map\u003cObject, Object\u003e status \u003d new HashMap\u003c\u003e();\n        for (TimelineMetric m : aggrRow.values()) {\n          TimelineMetric.aggregateTo(m, aggrMetric, status);\n          // getRealtimeAggregationOp returns an enum so we can directly\n          // compare with \"!\u003d\".\n          if (m.getRealtimeAggregationOp()\n              !\u003d aggrMetric.getRealtimeAggregationOp()) {\n            aggrMetric.setRealtimeAggregationOp(m.getRealtimeAggregationOp());\n          }\n        }\n        Set\u003cTimelineMetric\u003e metrics \u003d e.getMetrics();\n        metrics.remove(aggrMetric);\n        metrics.add(aggrMetric);\n      }\n      return e;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/collector/TimelineCollector.java"
    }
  }
}