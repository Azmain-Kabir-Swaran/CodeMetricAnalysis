{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DatanodeAdminManager.java",
  "functionName": "stopMaintenance",
  "functionId": "stopMaintenance___node-DatanodeDescriptor",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DatanodeAdminManager.java",
  "functionStartLine": 253,
  "functionEndLine": 293,
  "numCommitsSeen": 41,
  "timeTaken": 4833,
  "changeHistory": [
    "c93cb6790e0f1c64efd03d859f907a0522010894",
    "6f81cc0beea00843b44424417f09d8ee12cd7bae",
    "79df1e750ef558afed6d166ce225a23061b36aed",
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
    "9dcbdbdb5a34d85910707f81ebc1bb1f81c99978"
  ],
  "changeHistoryShort": {
    "c93cb6790e0f1c64efd03d859f907a0522010894": "Ybodychange",
    "6f81cc0beea00843b44424417f09d8ee12cd7bae": "Ybodychange",
    "79df1e750ef558afed6d166ce225a23061b36aed": "Ymultichange(Yfilerename,Ybodychange)",
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9": "Ybodychange",
    "9dcbdbdb5a34d85910707f81ebc1bb1f81c99978": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c93cb6790e0f1c64efd03d859f907a0522010894": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14854. Create improved decommission monitor implementation. Contributed by Stephen O\u0027Donnell.\n\nReviewed-by: Inigo Goiri \u003cinigoiri@apache.org\u003e\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "10/12/19 5:16 PM",
      "commitName": "c93cb6790e0f1c64efd03d859f907a0522010894",
      "commitAuthor": "Stephen O\u0027Donnell",
      "commitDateOld": "19/10/19 5:40 PM",
      "commitNameOld": "447f46d9628db54e77f88e2d109587cc7dfd6154",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 52.02,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,41 @@\n   public void stopMaintenance(DatanodeDescriptor node) {\n     if (node.isMaintenance()) {\n       // Update DN stats maintained by HeartbeatManager\n       hbManager.stopMaintenance(node);\n \n       // extra redundancy blocks will be detected and processed when\n       // the dead node comes back and send in its full block report.\n       if (!node.isAlive()) {\n         // The node became dead when it was in maintenance, at which point\n         // the replicas weren\u0027t removed from block maps.\n         // When the node leaves maintenance, the replicas should be removed\n         // from the block maps to trigger the necessary replication to\n         // maintain the safety property of \"# of live replicas + maintenance\n         // replicas\" \u003e\u003d the expected redundancy.\n         blockManager.removeBlocksAssociatedTo(node);\n       } else {\n         // Even though putting nodes in maintenance node doesn\u0027t cause live\n         // replicas to match expected replication factor, it is still possible\n         // to have over replicated when the node leaves maintenance node.\n         // First scenario:\n         // a. Node became dead when it is at AdminStates.NORMAL, thus\n         //    block is replicated so that 3 replicas exist on other nodes.\n         // b. Admins put the dead node into maintenance mode and then\n         //    have the node rejoin the cluster.\n         // c. Take the node out of maintenance mode.\n         // Second scenario:\n         // a. With replication factor 3, set one replica to maintenance node,\n         //    thus block has 1 maintenance replica and 2 live replicas.\n         // b. Change the replication factor to 2. The block will still have\n         //    1 maintenance replica and 2 live replicas.\n         // c. Take the node out of maintenance mode.\n         blockManager.processExtraRedundancyBlocksOnInService(node);\n       }\n \n       // Remove from tracking in DatanodeAdminManager\n-      pendingNodes.remove(node);\n-      outOfServiceNodeBlocks.remove(node);\n+      monitor.stopTrackingNode(node);\n     } else {\n       LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\",\n           node, node.getAdminState());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void stopMaintenance(DatanodeDescriptor node) {\n    if (node.isMaintenance()) {\n      // Update DN stats maintained by HeartbeatManager\n      hbManager.stopMaintenance(node);\n\n      // extra redundancy blocks will be detected and processed when\n      // the dead node comes back and send in its full block report.\n      if (!node.isAlive()) {\n        // The node became dead when it was in maintenance, at which point\n        // the replicas weren\u0027t removed from block maps.\n        // When the node leaves maintenance, the replicas should be removed\n        // from the block maps to trigger the necessary replication to\n        // maintain the safety property of \"# of live replicas + maintenance\n        // replicas\" \u003e\u003d the expected redundancy.\n        blockManager.removeBlocksAssociatedTo(node);\n      } else {\n        // Even though putting nodes in maintenance node doesn\u0027t cause live\n        // replicas to match expected replication factor, it is still possible\n        // to have over replicated when the node leaves maintenance node.\n        // First scenario:\n        // a. Node became dead when it is at AdminStates.NORMAL, thus\n        //    block is replicated so that 3 replicas exist on other nodes.\n        // b. Admins put the dead node into maintenance mode and then\n        //    have the node rejoin the cluster.\n        // c. Take the node out of maintenance mode.\n        // Second scenario:\n        // a. With replication factor 3, set one replica to maintenance node,\n        //    thus block has 1 maintenance replica and 2 live replicas.\n        // b. Change the replication factor to 2. The block will still have\n        //    1 maintenance replica and 2 live replicas.\n        // c. Take the node out of maintenance mode.\n        blockManager.processExtraRedundancyBlocksOnInService(node);\n      }\n\n      // Remove from tracking in DatanodeAdminManager\n      monitor.stopTrackingNode(node);\n    } else {\n      LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\",\n          node, node.getAdminState());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DatanodeAdminManager.java",
      "extendedDetails": {}
    },
    "6f81cc0beea00843b44424417f09d8ee12cd7bae": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13167. DatanodeAdminManager Improvements. Contributed by BELUGA BEHR.\n",
      "commitDate": "20/02/18 3:18 PM",
      "commitName": "6f81cc0beea00843b44424417f09d8ee12cd7bae",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "02/01/18 2:59 PM",
      "commitNameOld": "42a1c98597e6dba2e371510a6b2b6b1fb94e4090",
      "commitAuthorOld": "Manoj Govindassamy",
      "daysBetweenCommits": 49.01,
      "commitsBetweenForRepo": 297,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public void stopMaintenance(DatanodeDescriptor node) {\n     if (node.isMaintenance()) {\n       // Update DN stats maintained by HeartbeatManager\n       hbManager.stopMaintenance(node);\n \n       // extra redundancy blocks will be detected and processed when\n       // the dead node comes back and send in its full block report.\n       if (!node.isAlive()) {\n         // The node became dead when it was in maintenance, at which point\n         // the replicas weren\u0027t removed from block maps.\n         // When the node leaves maintenance, the replicas should be removed\n         // from the block maps to trigger the necessary replication to\n         // maintain the safety property of \"# of live replicas + maintenance\n         // replicas\" \u003e\u003d the expected redundancy.\n         blockManager.removeBlocksAssociatedTo(node);\n       } else {\n         // Even though putting nodes in maintenance node doesn\u0027t cause live\n         // replicas to match expected replication factor, it is still possible\n         // to have over replicated when the node leaves maintenance node.\n         // First scenario:\n         // a. Node became dead when it is at AdminStates.NORMAL, thus\n         //    block is replicated so that 3 replicas exist on other nodes.\n         // b. Admins put the dead node into maintenance mode and then\n         //    have the node rejoin the cluster.\n         // c. Take the node out of maintenance mode.\n         // Second scenario:\n         // a. With replication factor 3, set one replica to maintenance node,\n         //    thus block has 1 maintenance replica and 2 live replicas.\n         // b. Change the replication factor to 2. The block will still have\n         //    1 maintenance replica and 2 live replicas.\n         // c. Take the node out of maintenance mode.\n         blockManager.processExtraRedundancyBlocksOnInService(node);\n       }\n \n       // Remove from tracking in DatanodeAdminManager\n       pendingNodes.remove(node);\n       outOfServiceNodeBlocks.remove(node);\n     } else {\n-      LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\" +\n+      LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\",\n           node, node.getAdminState());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void stopMaintenance(DatanodeDescriptor node) {\n    if (node.isMaintenance()) {\n      // Update DN stats maintained by HeartbeatManager\n      hbManager.stopMaintenance(node);\n\n      // extra redundancy blocks will be detected and processed when\n      // the dead node comes back and send in its full block report.\n      if (!node.isAlive()) {\n        // The node became dead when it was in maintenance, at which point\n        // the replicas weren\u0027t removed from block maps.\n        // When the node leaves maintenance, the replicas should be removed\n        // from the block maps to trigger the necessary replication to\n        // maintain the safety property of \"# of live replicas + maintenance\n        // replicas\" \u003e\u003d the expected redundancy.\n        blockManager.removeBlocksAssociatedTo(node);\n      } else {\n        // Even though putting nodes in maintenance node doesn\u0027t cause live\n        // replicas to match expected replication factor, it is still possible\n        // to have over replicated when the node leaves maintenance node.\n        // First scenario:\n        // a. Node became dead when it is at AdminStates.NORMAL, thus\n        //    block is replicated so that 3 replicas exist on other nodes.\n        // b. Admins put the dead node into maintenance mode and then\n        //    have the node rejoin the cluster.\n        // c. Take the node out of maintenance mode.\n        // Second scenario:\n        // a. With replication factor 3, set one replica to maintenance node,\n        //    thus block has 1 maintenance replica and 2 live replicas.\n        // b. Change the replication factor to 2. The block will still have\n        //    1 maintenance replica and 2 live replicas.\n        // c. Take the node out of maintenance mode.\n        blockManager.processExtraRedundancyBlocksOnInService(node);\n      }\n\n      // Remove from tracking in DatanodeAdminManager\n      pendingNodes.remove(node);\n      outOfServiceNodeBlocks.remove(node);\n    } else {\n      LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\",\n          node, node.getAdminState());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DatanodeAdminManager.java",
      "extendedDetails": {}
    },
    "79df1e750ef558afed6d166ce225a23061b36aed": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "HDFS-9388. Decommission related code to support Maintenance State for datanodes.\n",
      "commitDate": "02/08/17 2:22 PM",
      "commitName": "79df1e750ef558afed6d166ce225a23061b36aed",
      "commitAuthor": "Manoj Govindassamy",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "HDFS-9388. Decommission related code to support Maintenance State for datanodes.\n",
          "commitDate": "02/08/17 2:22 PM",
          "commitName": "79df1e750ef558afed6d166ce225a23061b36aed",
          "commitAuthor": "Manoj Govindassamy",
          "commitDateOld": "02/08/17 12:12 PM",
          "commitNameOld": "12e44e7bdaf53d3720a89d32f0cc2717241bd6b2",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 0.09,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,42 @@\n   public void stopMaintenance(DatanodeDescriptor node) {\n     if (node.isMaintenance()) {\n       // Update DN stats maintained by HeartbeatManager\n       hbManager.stopMaintenance(node);\n \n       // extra redundancy blocks will be detected and processed when\n       // the dead node comes back and send in its full block report.\n       if (!node.isAlive()) {\n         // The node became dead when it was in maintenance, at which point\n         // the replicas weren\u0027t removed from block maps.\n         // When the node leaves maintenance, the replicas should be removed\n         // from the block maps to trigger the necessary replication to\n         // maintain the safety property of \"# of live replicas + maintenance\n         // replicas\" \u003e\u003d the expected redundancy.\n         blockManager.removeBlocksAssociatedTo(node);\n       } else {\n         // Even though putting nodes in maintenance node doesn\u0027t cause live\n         // replicas to match expected replication factor, it is still possible\n         // to have over replicated when the node leaves maintenance node.\n         // First scenario:\n         // a. Node became dead when it is at AdminStates.NORMAL, thus\n         //    block is replicated so that 3 replicas exist on other nodes.\n         // b. Admins put the dead node into maintenance mode and then\n         //    have the node rejoin the cluster.\n         // c. Take the node out of maintenance mode.\n         // Second scenario:\n         // a. With replication factor 3, set one replica to maintenance node,\n         //    thus block has 1 maintenance replica and 2 live replicas.\n         // b. Change the replication factor to 2. The block will still have\n         //    1 maintenance replica and 2 live replicas.\n         // c. Take the node out of maintenance mode.\n         blockManager.processExtraRedundancyBlocksOnInService(node);\n       }\n \n-      // Remove from tracking in DecommissionManager\n+      // Remove from tracking in DatanodeAdminManager\n       pendingNodes.remove(node);\n       outOfServiceNodeBlocks.remove(node);\n     } else {\n       LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\" +\n           node, node.getAdminState());\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void stopMaintenance(DatanodeDescriptor node) {\n    if (node.isMaintenance()) {\n      // Update DN stats maintained by HeartbeatManager\n      hbManager.stopMaintenance(node);\n\n      // extra redundancy blocks will be detected and processed when\n      // the dead node comes back and send in its full block report.\n      if (!node.isAlive()) {\n        // The node became dead when it was in maintenance, at which point\n        // the replicas weren\u0027t removed from block maps.\n        // When the node leaves maintenance, the replicas should be removed\n        // from the block maps to trigger the necessary replication to\n        // maintain the safety property of \"# of live replicas + maintenance\n        // replicas\" \u003e\u003d the expected redundancy.\n        blockManager.removeBlocksAssociatedTo(node);\n      } else {\n        // Even though putting nodes in maintenance node doesn\u0027t cause live\n        // replicas to match expected replication factor, it is still possible\n        // to have over replicated when the node leaves maintenance node.\n        // First scenario:\n        // a. Node became dead when it is at AdminStates.NORMAL, thus\n        //    block is replicated so that 3 replicas exist on other nodes.\n        // b. Admins put the dead node into maintenance mode and then\n        //    have the node rejoin the cluster.\n        // c. Take the node out of maintenance mode.\n        // Second scenario:\n        // a. With replication factor 3, set one replica to maintenance node,\n        //    thus block has 1 maintenance replica and 2 live replicas.\n        // b. Change the replication factor to 2. The block will still have\n        //    1 maintenance replica and 2 live replicas.\n        // c. Take the node out of maintenance mode.\n        blockManager.processExtraRedundancyBlocksOnInService(node);\n      }\n\n      // Remove from tracking in DatanodeAdminManager\n      pendingNodes.remove(node);\n      outOfServiceNodeBlocks.remove(node);\n    } else {\n      LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\" +\n          node, node.getAdminState());\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DatanodeAdminManager.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DecommissionManager.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DatanodeAdminManager.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9388. Decommission related code to support Maintenance State for datanodes.\n",
          "commitDate": "02/08/17 2:22 PM",
          "commitName": "79df1e750ef558afed6d166ce225a23061b36aed",
          "commitAuthor": "Manoj Govindassamy",
          "commitDateOld": "02/08/17 12:12 PM",
          "commitNameOld": "12e44e7bdaf53d3720a89d32f0cc2717241bd6b2",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 0.09,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,42 @@\n   public void stopMaintenance(DatanodeDescriptor node) {\n     if (node.isMaintenance()) {\n       // Update DN stats maintained by HeartbeatManager\n       hbManager.stopMaintenance(node);\n \n       // extra redundancy blocks will be detected and processed when\n       // the dead node comes back and send in its full block report.\n       if (!node.isAlive()) {\n         // The node became dead when it was in maintenance, at which point\n         // the replicas weren\u0027t removed from block maps.\n         // When the node leaves maintenance, the replicas should be removed\n         // from the block maps to trigger the necessary replication to\n         // maintain the safety property of \"# of live replicas + maintenance\n         // replicas\" \u003e\u003d the expected redundancy.\n         blockManager.removeBlocksAssociatedTo(node);\n       } else {\n         // Even though putting nodes in maintenance node doesn\u0027t cause live\n         // replicas to match expected replication factor, it is still possible\n         // to have over replicated when the node leaves maintenance node.\n         // First scenario:\n         // a. Node became dead when it is at AdminStates.NORMAL, thus\n         //    block is replicated so that 3 replicas exist on other nodes.\n         // b. Admins put the dead node into maintenance mode and then\n         //    have the node rejoin the cluster.\n         // c. Take the node out of maintenance mode.\n         // Second scenario:\n         // a. With replication factor 3, set one replica to maintenance node,\n         //    thus block has 1 maintenance replica and 2 live replicas.\n         // b. Change the replication factor to 2. The block will still have\n         //    1 maintenance replica and 2 live replicas.\n         // c. Take the node out of maintenance mode.\n         blockManager.processExtraRedundancyBlocksOnInService(node);\n       }\n \n-      // Remove from tracking in DecommissionManager\n+      // Remove from tracking in DatanodeAdminManager\n       pendingNodes.remove(node);\n       outOfServiceNodeBlocks.remove(node);\n     } else {\n       LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\" +\n           node, node.getAdminState());\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void stopMaintenance(DatanodeDescriptor node) {\n    if (node.isMaintenance()) {\n      // Update DN stats maintained by HeartbeatManager\n      hbManager.stopMaintenance(node);\n\n      // extra redundancy blocks will be detected and processed when\n      // the dead node comes back and send in its full block report.\n      if (!node.isAlive()) {\n        // The node became dead when it was in maintenance, at which point\n        // the replicas weren\u0027t removed from block maps.\n        // When the node leaves maintenance, the replicas should be removed\n        // from the block maps to trigger the necessary replication to\n        // maintain the safety property of \"# of live replicas + maintenance\n        // replicas\" \u003e\u003d the expected redundancy.\n        blockManager.removeBlocksAssociatedTo(node);\n      } else {\n        // Even though putting nodes in maintenance node doesn\u0027t cause live\n        // replicas to match expected replication factor, it is still possible\n        // to have over replicated when the node leaves maintenance node.\n        // First scenario:\n        // a. Node became dead when it is at AdminStates.NORMAL, thus\n        //    block is replicated so that 3 replicas exist on other nodes.\n        // b. Admins put the dead node into maintenance mode and then\n        //    have the node rejoin the cluster.\n        // c. Take the node out of maintenance mode.\n        // Second scenario:\n        // a. With replication factor 3, set one replica to maintenance node,\n        //    thus block has 1 maintenance replica and 2 live replicas.\n        // b. Change the replication factor to 2. The block will still have\n        //    1 maintenance replica and 2 live replicas.\n        // c. Take the node out of maintenance mode.\n        blockManager.processExtraRedundancyBlocksOnInService(node);\n      }\n\n      // Remove from tracking in DatanodeAdminManager\n      pendingNodes.remove(node);\n      outOfServiceNodeBlocks.remove(node);\n    } else {\n      LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\" +\n          node, node.getAdminState());\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DatanodeAdminManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9390. Block management for maintenance states.\n",
      "commitDate": "17/10/16 5:45 PM",
      "commitName": "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "13/10/16 11:52 AM",
      "commitNameOld": "332a61fd74fd2a9874319232c583ab5d2c53ff03",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 4.25,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,16 +1,42 @@\n   public void stopMaintenance(DatanodeDescriptor node) {\n     if (node.isMaintenance()) {\n       // Update DN stats maintained by HeartbeatManager\n       hbManager.stopMaintenance(node);\n \n-      // TODO HDFS-9390 remove replicas from block maps\n-      // or handle over replicated blocks.\n+      // extra redundancy blocks will be detected and processed when\n+      // the dead node comes back and send in its full block report.\n+      if (!node.isAlive()) {\n+        // The node became dead when it was in maintenance, at which point\n+        // the replicas weren\u0027t removed from block maps.\n+        // When the node leaves maintenance, the replicas should be removed\n+        // from the block maps to trigger the necessary replication to\n+        // maintain the safety property of \"# of live replicas + maintenance\n+        // replicas\" \u003e\u003d the expected redundancy.\n+        blockManager.removeBlocksAssociatedTo(node);\n+      } else {\n+        // Even though putting nodes in maintenance node doesn\u0027t cause live\n+        // replicas to match expected replication factor, it is still possible\n+        // to have over replicated when the node leaves maintenance node.\n+        // First scenario:\n+        // a. Node became dead when it is at AdminStates.NORMAL, thus\n+        //    block is replicated so that 3 replicas exist on other nodes.\n+        // b. Admins put the dead node into maintenance mode and then\n+        //    have the node rejoin the cluster.\n+        // c. Take the node out of maintenance mode.\n+        // Second scenario:\n+        // a. With replication factor 3, set one replica to maintenance node,\n+        //    thus block has 1 maintenance replica and 2 live replicas.\n+        // b. Change the replication factor to 2. The block will still have\n+        //    1 maintenance replica and 2 live replicas.\n+        // c. Take the node out of maintenance mode.\n+        blockManager.processExtraRedundancyBlocksOnInService(node);\n+      }\n \n       // Remove from tracking in DecommissionManager\n       pendingNodes.remove(node);\n       outOfServiceNodeBlocks.remove(node);\n     } else {\n       LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\" +\n           node, node.getAdminState());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void stopMaintenance(DatanodeDescriptor node) {\n    if (node.isMaintenance()) {\n      // Update DN stats maintained by HeartbeatManager\n      hbManager.stopMaintenance(node);\n\n      // extra redundancy blocks will be detected and processed when\n      // the dead node comes back and send in its full block report.\n      if (!node.isAlive()) {\n        // The node became dead when it was in maintenance, at which point\n        // the replicas weren\u0027t removed from block maps.\n        // When the node leaves maintenance, the replicas should be removed\n        // from the block maps to trigger the necessary replication to\n        // maintain the safety property of \"# of live replicas + maintenance\n        // replicas\" \u003e\u003d the expected redundancy.\n        blockManager.removeBlocksAssociatedTo(node);\n      } else {\n        // Even though putting nodes in maintenance node doesn\u0027t cause live\n        // replicas to match expected replication factor, it is still possible\n        // to have over replicated when the node leaves maintenance node.\n        // First scenario:\n        // a. Node became dead when it is at AdminStates.NORMAL, thus\n        //    block is replicated so that 3 replicas exist on other nodes.\n        // b. Admins put the dead node into maintenance mode and then\n        //    have the node rejoin the cluster.\n        // c. Take the node out of maintenance mode.\n        // Second scenario:\n        // a. With replication factor 3, set one replica to maintenance node,\n        //    thus block has 1 maintenance replica and 2 live replicas.\n        // b. Change the replication factor to 2. The block will still have\n        //    1 maintenance replica and 2 live replicas.\n        // c. Take the node out of maintenance mode.\n        blockManager.processExtraRedundancyBlocksOnInService(node);\n      }\n\n      // Remove from tracking in DecommissionManager\n      pendingNodes.remove(node);\n      outOfServiceNodeBlocks.remove(node);\n    } else {\n      LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\" +\n          node, node.getAdminState());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DecommissionManager.java",
      "extendedDetails": {}
    },
    "9dcbdbdb5a34d85910707f81ebc1bb1f81c99978": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9392. Admins support for maintenance state. Contributed by Ming Ma.\n",
      "commitDate": "30/08/16 2:00 PM",
      "commitName": "9dcbdbdb5a34d85910707f81ebc1bb1f81c99978",
      "commitAuthor": "Ming Ma",
      "diff": "@@ -0,0 +1,16 @@\n+  public void stopMaintenance(DatanodeDescriptor node) {\n+    if (node.isMaintenance()) {\n+      // Update DN stats maintained by HeartbeatManager\n+      hbManager.stopMaintenance(node);\n+\n+      // TODO HDFS-9390 remove replicas from block maps\n+      // or handle over replicated blocks.\n+\n+      // Remove from tracking in DecommissionManager\n+      pendingNodes.remove(node);\n+      outOfServiceNodeBlocks.remove(node);\n+    } else {\n+      LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\" +\n+          node, node.getAdminState());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void stopMaintenance(DatanodeDescriptor node) {\n    if (node.isMaintenance()) {\n      // Update DN stats maintained by HeartbeatManager\n      hbManager.stopMaintenance(node);\n\n      // TODO HDFS-9390 remove replicas from block maps\n      // or handle over replicated blocks.\n\n      // Remove from tracking in DecommissionManager\n      pendingNodes.remove(node);\n      outOfServiceNodeBlocks.remove(node);\n    } else {\n      LOG.trace(\"stopMaintenance: Node {} in {}, nothing to do.\" +\n          node, node.getAdminState());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DecommissionManager.java"
    }
  }
}