{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "QueuePlacementPolicy.java",
  "functionName": "fromXml",
  "functionId": "fromXml___confElement-Element__fs-FairScheduler",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueuePlacementPolicy.java",
  "functionStartLine": 148,
  "functionEndLine": 193,
  "numCommitsSeen": 18,
  "timeTaken": 6176,
  "changeHistory": [
    "5257f50abb71905ef3068fd45541d00ce9e8f355",
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
    "1a7e1588443071e497c6fea0224a78ca8de1cf3e",
    "6ac4ac05f75480ebfe1adfcceabc4f1674619eae"
  ],
  "changeHistoryShort": {
    "5257f50abb71905ef3068fd45541d00ce9e8f355": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d": "Ymultichange(Yparameterchange,Ybodychange)",
    "1a7e1588443071e497c6fea0224a78ca8de1cf3e": "Ybodychange",
    "6ac4ac05f75480ebfe1adfcceabc4f1674619eae": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5257f50abb71905ef3068fd45541d00ce9e8f355": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.\n",
      "commitDate": "25/03/19 10:47 PM",
      "commitName": "5257f50abb71905ef3068fd45541d00ce9e8f355",
      "commitAuthor": "yufei",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.\n",
          "commitDate": "25/03/19 10:47 PM",
          "commitName": "5257f50abb71905ef3068fd45541d00ce9e8f355",
          "commitAuthor": "yufei",
          "commitDateOld": "21/05/14 11:13 PM",
          "commitNameOld": "619ec833fc75e596576e35fee8437aeb1639099d",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1768.98,
          "commitsBetweenForRepo": 13695,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,46 @@\n-  public static QueuePlacementPolicy fromXml(Element el,\n-      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues, Configuration conf)\n+  static void fromXml(Element confElement, FairScheduler fs)\n       throws AllocationConfigurationException {\n-    List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n-    NodeList elements \u003d el.getChildNodes();\n+    LOG.debug(\"Reloading placement policy from allocation config\");\n+    if (confElement \u003d\u003d null || !confElement.hasChildNodes()) {\n+      throw new AllocationConfigurationException(\n+          \"Empty configuration for QueuePlacementPolicy is not allowed\");\n+    }\n+    List\u003cPlacementRule\u003e newRules \u003d new ArrayList\u003c\u003e();\n+    List\u003cBoolean\u003e newTerminalState \u003d new ArrayList\u003c\u003e();\n+    NodeList elements \u003d confElement.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n-      if (node instanceof Element) {\n-        QueuePlacementRule rule \u003d createAndInitializeRule(node);\n-        rules.add(rule);\n+      if (node instanceof Element \u0026\u0026\n+          node.getNodeName().equalsIgnoreCase(\"rule\")) {\n+        String name \u003d ((Element) node).getAttribute(\"name\");\n+        LOG.debug(\"Creating new rule: {}\", name);\n+        PlacementRule rule \u003d createRule((Element)node);\n+\n+        // The only child node that we currently know is a parent rule\n+        PlacementRule parentRule \u003d null;\n+        String parentName \u003d null;\n+        Element child \u003d getParentRuleElement(node);\n+        if (child !\u003d null) {\n+          parentName \u003d child.getAttribute(\"name\");\n+          parentRule \u003d getParentRule(child, fs);\n+        }\n+        // Need to make sure that the nestedUserQueue has a parent for\n+        // backwards compatibility\n+        if (name.equalsIgnoreCase(\"nestedUserQueue\") \u0026\u0026 parentRule \u003d\u003d null) {\n+          throw new AllocationConfigurationException(\"Rule \u0027\" + name\n+              + \"\u0027 must have a parent rule set\");\n+        }\n+        newRules.add(rule);\n+        if (parentRule \u003d\u003d null) {\n+          newTerminalState.add(\n+              getTerminal(RULES.get(name).terminal, rule));\n+        } else {\n+          ((FSPlacementRule)rule).setParentRule(parentRule);\n+          newTerminalState.add(\n+              getTerminal(RULES.get(name).terminal, rule) \u0026\u0026\n+              getTerminal(RULES.get(parentName).terminal, parentRule));\n+        }\n       }\n     }\n-    return new QueuePlacementPolicy(rules, configuredQueues, conf);\n+    updateRuleSet(newRules, newTerminalState, fs);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static void fromXml(Element confElement, FairScheduler fs)\n      throws AllocationConfigurationException {\n    LOG.debug(\"Reloading placement policy from allocation config\");\n    if (confElement \u003d\u003d null || !confElement.hasChildNodes()) {\n      throw new AllocationConfigurationException(\n          \"Empty configuration for QueuePlacementPolicy is not allowed\");\n    }\n    List\u003cPlacementRule\u003e newRules \u003d new ArrayList\u003c\u003e();\n    List\u003cBoolean\u003e newTerminalState \u003d new ArrayList\u003c\u003e();\n    NodeList elements \u003d confElement.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element \u0026\u0026\n          node.getNodeName().equalsIgnoreCase(\"rule\")) {\n        String name \u003d ((Element) node).getAttribute(\"name\");\n        LOG.debug(\"Creating new rule: {}\", name);\n        PlacementRule rule \u003d createRule((Element)node);\n\n        // The only child node that we currently know is a parent rule\n        PlacementRule parentRule \u003d null;\n        String parentName \u003d null;\n        Element child \u003d getParentRuleElement(node);\n        if (child !\u003d null) {\n          parentName \u003d child.getAttribute(\"name\");\n          parentRule \u003d getParentRule(child, fs);\n        }\n        // Need to make sure that the nestedUserQueue has a parent for\n        // backwards compatibility\n        if (name.equalsIgnoreCase(\"nestedUserQueue\") \u0026\u0026 parentRule \u003d\u003d null) {\n          throw new AllocationConfigurationException(\"Rule \u0027\" + name\n              + \"\u0027 must have a parent rule set\");\n        }\n        newRules.add(rule);\n        if (parentRule \u003d\u003d null) {\n          newTerminalState.add(\n              getTerminal(RULES.get(name).terminal, rule));\n        } else {\n          ((FSPlacementRule)rule).setParentRule(parentRule);\n          newTerminalState.add(\n              getTerminal(RULES.get(name).terminal, rule) \u0026\u0026\n              getTerminal(RULES.get(parentName).terminal, parentRule));\n        }\n      }\n    }\n    updateRuleSet(newRules, newTerminalState, fs);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueuePlacementPolicy.java",
          "extendedDetails": {
            "oldValue": "[el-Element, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, conf-Configuration]",
            "newValue": "[confElement-Element, fs-FairScheduler]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.\n",
          "commitDate": "25/03/19 10:47 PM",
          "commitName": "5257f50abb71905ef3068fd45541d00ce9e8f355",
          "commitAuthor": "yufei",
          "commitDateOld": "21/05/14 11:13 PM",
          "commitNameOld": "619ec833fc75e596576e35fee8437aeb1639099d",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1768.98,
          "commitsBetweenForRepo": 13695,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,46 @@\n-  public static QueuePlacementPolicy fromXml(Element el,\n-      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues, Configuration conf)\n+  static void fromXml(Element confElement, FairScheduler fs)\n       throws AllocationConfigurationException {\n-    List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n-    NodeList elements \u003d el.getChildNodes();\n+    LOG.debug(\"Reloading placement policy from allocation config\");\n+    if (confElement \u003d\u003d null || !confElement.hasChildNodes()) {\n+      throw new AllocationConfigurationException(\n+          \"Empty configuration for QueuePlacementPolicy is not allowed\");\n+    }\n+    List\u003cPlacementRule\u003e newRules \u003d new ArrayList\u003c\u003e();\n+    List\u003cBoolean\u003e newTerminalState \u003d new ArrayList\u003c\u003e();\n+    NodeList elements \u003d confElement.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n-      if (node instanceof Element) {\n-        QueuePlacementRule rule \u003d createAndInitializeRule(node);\n-        rules.add(rule);\n+      if (node instanceof Element \u0026\u0026\n+          node.getNodeName().equalsIgnoreCase(\"rule\")) {\n+        String name \u003d ((Element) node).getAttribute(\"name\");\n+        LOG.debug(\"Creating new rule: {}\", name);\n+        PlacementRule rule \u003d createRule((Element)node);\n+\n+        // The only child node that we currently know is a parent rule\n+        PlacementRule parentRule \u003d null;\n+        String parentName \u003d null;\n+        Element child \u003d getParentRuleElement(node);\n+        if (child !\u003d null) {\n+          parentName \u003d child.getAttribute(\"name\");\n+          parentRule \u003d getParentRule(child, fs);\n+        }\n+        // Need to make sure that the nestedUserQueue has a parent for\n+        // backwards compatibility\n+        if (name.equalsIgnoreCase(\"nestedUserQueue\") \u0026\u0026 parentRule \u003d\u003d null) {\n+          throw new AllocationConfigurationException(\"Rule \u0027\" + name\n+              + \"\u0027 must have a parent rule set\");\n+        }\n+        newRules.add(rule);\n+        if (parentRule \u003d\u003d null) {\n+          newTerminalState.add(\n+              getTerminal(RULES.get(name).terminal, rule));\n+        } else {\n+          ((FSPlacementRule)rule).setParentRule(parentRule);\n+          newTerminalState.add(\n+              getTerminal(RULES.get(name).terminal, rule) \u0026\u0026\n+              getTerminal(RULES.get(parentName).terminal, parentRule));\n+        }\n       }\n     }\n-    return new QueuePlacementPolicy(rules, configuredQueues, conf);\n+    updateRuleSet(newRules, newTerminalState, fs);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static void fromXml(Element confElement, FairScheduler fs)\n      throws AllocationConfigurationException {\n    LOG.debug(\"Reloading placement policy from allocation config\");\n    if (confElement \u003d\u003d null || !confElement.hasChildNodes()) {\n      throw new AllocationConfigurationException(\n          \"Empty configuration for QueuePlacementPolicy is not allowed\");\n    }\n    List\u003cPlacementRule\u003e newRules \u003d new ArrayList\u003c\u003e();\n    List\u003cBoolean\u003e newTerminalState \u003d new ArrayList\u003c\u003e();\n    NodeList elements \u003d confElement.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element \u0026\u0026\n          node.getNodeName().equalsIgnoreCase(\"rule\")) {\n        String name \u003d ((Element) node).getAttribute(\"name\");\n        LOG.debug(\"Creating new rule: {}\", name);\n        PlacementRule rule \u003d createRule((Element)node);\n\n        // The only child node that we currently know is a parent rule\n        PlacementRule parentRule \u003d null;\n        String parentName \u003d null;\n        Element child \u003d getParentRuleElement(node);\n        if (child !\u003d null) {\n          parentName \u003d child.getAttribute(\"name\");\n          parentRule \u003d getParentRule(child, fs);\n        }\n        // Need to make sure that the nestedUserQueue has a parent for\n        // backwards compatibility\n        if (name.equalsIgnoreCase(\"nestedUserQueue\") \u0026\u0026 parentRule \u003d\u003d null) {\n          throw new AllocationConfigurationException(\"Rule \u0027\" + name\n              + \"\u0027 must have a parent rule set\");\n        }\n        newRules.add(rule);\n        if (parentRule \u003d\u003d null) {\n          newTerminalState.add(\n              getTerminal(RULES.get(name).terminal, rule));\n        } else {\n          ((FSPlacementRule)rule).setParentRule(parentRule);\n          newTerminalState.add(\n              getTerminal(RULES.get(name).terminal, rule) \u0026\u0026\n              getTerminal(RULES.get(parentName).terminal, parentRule));\n        }\n      }\n    }\n    updateRuleSet(newRules, newTerminalState, fs);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueuePlacementPolicy.java",
          "extendedDetails": {
            "oldValue": "QueuePlacementPolicy",
            "newValue": "void"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.\n",
          "commitDate": "25/03/19 10:47 PM",
          "commitName": "5257f50abb71905ef3068fd45541d00ce9e8f355",
          "commitAuthor": "yufei",
          "commitDateOld": "21/05/14 11:13 PM",
          "commitNameOld": "619ec833fc75e596576e35fee8437aeb1639099d",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1768.98,
          "commitsBetweenForRepo": 13695,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,46 @@\n-  public static QueuePlacementPolicy fromXml(Element el,\n-      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues, Configuration conf)\n+  static void fromXml(Element confElement, FairScheduler fs)\n       throws AllocationConfigurationException {\n-    List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n-    NodeList elements \u003d el.getChildNodes();\n+    LOG.debug(\"Reloading placement policy from allocation config\");\n+    if (confElement \u003d\u003d null || !confElement.hasChildNodes()) {\n+      throw new AllocationConfigurationException(\n+          \"Empty configuration for QueuePlacementPolicy is not allowed\");\n+    }\n+    List\u003cPlacementRule\u003e newRules \u003d new ArrayList\u003c\u003e();\n+    List\u003cBoolean\u003e newTerminalState \u003d new ArrayList\u003c\u003e();\n+    NodeList elements \u003d confElement.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n-      if (node instanceof Element) {\n-        QueuePlacementRule rule \u003d createAndInitializeRule(node);\n-        rules.add(rule);\n+      if (node instanceof Element \u0026\u0026\n+          node.getNodeName().equalsIgnoreCase(\"rule\")) {\n+        String name \u003d ((Element) node).getAttribute(\"name\");\n+        LOG.debug(\"Creating new rule: {}\", name);\n+        PlacementRule rule \u003d createRule((Element)node);\n+\n+        // The only child node that we currently know is a parent rule\n+        PlacementRule parentRule \u003d null;\n+        String parentName \u003d null;\n+        Element child \u003d getParentRuleElement(node);\n+        if (child !\u003d null) {\n+          parentName \u003d child.getAttribute(\"name\");\n+          parentRule \u003d getParentRule(child, fs);\n+        }\n+        // Need to make sure that the nestedUserQueue has a parent for\n+        // backwards compatibility\n+        if (name.equalsIgnoreCase(\"nestedUserQueue\") \u0026\u0026 parentRule \u003d\u003d null) {\n+          throw new AllocationConfigurationException(\"Rule \u0027\" + name\n+              + \"\u0027 must have a parent rule set\");\n+        }\n+        newRules.add(rule);\n+        if (parentRule \u003d\u003d null) {\n+          newTerminalState.add(\n+              getTerminal(RULES.get(name).terminal, rule));\n+        } else {\n+          ((FSPlacementRule)rule).setParentRule(parentRule);\n+          newTerminalState.add(\n+              getTerminal(RULES.get(name).terminal, rule) \u0026\u0026\n+              getTerminal(RULES.get(parentName).terminal, parentRule));\n+        }\n       }\n     }\n-    return new QueuePlacementPolicy(rules, configuredQueues, conf);\n+    updateRuleSet(newRules, newTerminalState, fs);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static void fromXml(Element confElement, FairScheduler fs)\n      throws AllocationConfigurationException {\n    LOG.debug(\"Reloading placement policy from allocation config\");\n    if (confElement \u003d\u003d null || !confElement.hasChildNodes()) {\n      throw new AllocationConfigurationException(\n          \"Empty configuration for QueuePlacementPolicy is not allowed\");\n    }\n    List\u003cPlacementRule\u003e newRules \u003d new ArrayList\u003c\u003e();\n    List\u003cBoolean\u003e newTerminalState \u003d new ArrayList\u003c\u003e();\n    NodeList elements \u003d confElement.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element \u0026\u0026\n          node.getNodeName().equalsIgnoreCase(\"rule\")) {\n        String name \u003d ((Element) node).getAttribute(\"name\");\n        LOG.debug(\"Creating new rule: {}\", name);\n        PlacementRule rule \u003d createRule((Element)node);\n\n        // The only child node that we currently know is a parent rule\n        PlacementRule parentRule \u003d null;\n        String parentName \u003d null;\n        Element child \u003d getParentRuleElement(node);\n        if (child !\u003d null) {\n          parentName \u003d child.getAttribute(\"name\");\n          parentRule \u003d getParentRule(child, fs);\n        }\n        // Need to make sure that the nestedUserQueue has a parent for\n        // backwards compatibility\n        if (name.equalsIgnoreCase(\"nestedUserQueue\") \u0026\u0026 parentRule \u003d\u003d null) {\n          throw new AllocationConfigurationException(\"Rule \u0027\" + name\n              + \"\u0027 must have a parent rule set\");\n        }\n        newRules.add(rule);\n        if (parentRule \u003d\u003d null) {\n          newTerminalState.add(\n              getTerminal(RULES.get(name).terminal, rule));\n        } else {\n          ((FSPlacementRule)rule).setParentRule(parentRule);\n          newTerminalState.add(\n              getTerminal(RULES.get(name).terminal, rule) \u0026\u0026\n              getTerminal(RULES.get(parentName).terminal, parentRule));\n        }\n      }\n    }\n    updateRuleSet(newRules, newTerminalState, fs);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueuePlacementPolicy.java",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.\n",
          "commitDate": "25/03/19 10:47 PM",
          "commitName": "5257f50abb71905ef3068fd45541d00ce9e8f355",
          "commitAuthor": "yufei",
          "commitDateOld": "21/05/14 11:13 PM",
          "commitNameOld": "619ec833fc75e596576e35fee8437aeb1639099d",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1768.98,
          "commitsBetweenForRepo": 13695,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,46 @@\n-  public static QueuePlacementPolicy fromXml(Element el,\n-      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues, Configuration conf)\n+  static void fromXml(Element confElement, FairScheduler fs)\n       throws AllocationConfigurationException {\n-    List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n-    NodeList elements \u003d el.getChildNodes();\n+    LOG.debug(\"Reloading placement policy from allocation config\");\n+    if (confElement \u003d\u003d null || !confElement.hasChildNodes()) {\n+      throw new AllocationConfigurationException(\n+          \"Empty configuration for QueuePlacementPolicy is not allowed\");\n+    }\n+    List\u003cPlacementRule\u003e newRules \u003d new ArrayList\u003c\u003e();\n+    List\u003cBoolean\u003e newTerminalState \u003d new ArrayList\u003c\u003e();\n+    NodeList elements \u003d confElement.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n-      if (node instanceof Element) {\n-        QueuePlacementRule rule \u003d createAndInitializeRule(node);\n-        rules.add(rule);\n+      if (node instanceof Element \u0026\u0026\n+          node.getNodeName().equalsIgnoreCase(\"rule\")) {\n+        String name \u003d ((Element) node).getAttribute(\"name\");\n+        LOG.debug(\"Creating new rule: {}\", name);\n+        PlacementRule rule \u003d createRule((Element)node);\n+\n+        // The only child node that we currently know is a parent rule\n+        PlacementRule parentRule \u003d null;\n+        String parentName \u003d null;\n+        Element child \u003d getParentRuleElement(node);\n+        if (child !\u003d null) {\n+          parentName \u003d child.getAttribute(\"name\");\n+          parentRule \u003d getParentRule(child, fs);\n+        }\n+        // Need to make sure that the nestedUserQueue has a parent for\n+        // backwards compatibility\n+        if (name.equalsIgnoreCase(\"nestedUserQueue\") \u0026\u0026 parentRule \u003d\u003d null) {\n+          throw new AllocationConfigurationException(\"Rule \u0027\" + name\n+              + \"\u0027 must have a parent rule set\");\n+        }\n+        newRules.add(rule);\n+        if (parentRule \u003d\u003d null) {\n+          newTerminalState.add(\n+              getTerminal(RULES.get(name).terminal, rule));\n+        } else {\n+          ((FSPlacementRule)rule).setParentRule(parentRule);\n+          newTerminalState.add(\n+              getTerminal(RULES.get(name).terminal, rule) \u0026\u0026\n+              getTerminal(RULES.get(parentName).terminal, parentRule));\n+        }\n       }\n     }\n-    return new QueuePlacementPolicy(rules, configuredQueues, conf);\n+    updateRuleSet(newRules, newTerminalState, fs);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static void fromXml(Element confElement, FairScheduler fs)\n      throws AllocationConfigurationException {\n    LOG.debug(\"Reloading placement policy from allocation config\");\n    if (confElement \u003d\u003d null || !confElement.hasChildNodes()) {\n      throw new AllocationConfigurationException(\n          \"Empty configuration for QueuePlacementPolicy is not allowed\");\n    }\n    List\u003cPlacementRule\u003e newRules \u003d new ArrayList\u003c\u003e();\n    List\u003cBoolean\u003e newTerminalState \u003d new ArrayList\u003c\u003e();\n    NodeList elements \u003d confElement.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element \u0026\u0026\n          node.getNodeName().equalsIgnoreCase(\"rule\")) {\n        String name \u003d ((Element) node).getAttribute(\"name\");\n        LOG.debug(\"Creating new rule: {}\", name);\n        PlacementRule rule \u003d createRule((Element)node);\n\n        // The only child node that we currently know is a parent rule\n        PlacementRule parentRule \u003d null;\n        String parentName \u003d null;\n        Element child \u003d getParentRuleElement(node);\n        if (child !\u003d null) {\n          parentName \u003d child.getAttribute(\"name\");\n          parentRule \u003d getParentRule(child, fs);\n        }\n        // Need to make sure that the nestedUserQueue has a parent for\n        // backwards compatibility\n        if (name.equalsIgnoreCase(\"nestedUserQueue\") \u0026\u0026 parentRule \u003d\u003d null) {\n          throw new AllocationConfigurationException(\"Rule \u0027\" + name\n              + \"\u0027 must have a parent rule set\");\n        }\n        newRules.add(rule);\n        if (parentRule \u003d\u003d null) {\n          newTerminalState.add(\n              getTerminal(RULES.get(name).terminal, rule));\n        } else {\n          ((FSPlacementRule)rule).setParentRule(parentRule);\n          newTerminalState.add(\n              getTerminal(RULES.get(name).terminal, rule) \u0026\u0026\n              getTerminal(RULES.get(parentName).terminal, parentRule));\n        }\n      }\n    }\n    updateRuleSet(newRules, newTerminalState, fs);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueuePlacementPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1864. Fair Scheduler Dynamic Hierarchical User Queues (Ashwin Shankar via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593190 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/14 12:21 AM",
      "commitName": "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
      "commitAuthor": "Sanford Ryza",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1864. Fair Scheduler Dynamic Hierarchical User Queues (Ashwin Shankar via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593190 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/05/14 12:21 AM",
          "commitName": "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "22/01/14 10:51 AM",
          "commitNameOld": "1a7e1588443071e497c6fea0224a78ca8de1cf3e",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 105.52,
          "commitsBetweenForRepo": 807,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,14 @@\n-  public static QueuePlacementPolicy fromXml(Element el, Set\u003cString\u003e configuredQueues,\n-      Configuration conf) throws AllocationConfigurationException {\n+  public static QueuePlacementPolicy fromXml(Element el,\n+      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues, Configuration conf)\n+      throws AllocationConfigurationException {\n     List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n     NodeList elements \u003d el.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n-        Element element \u003d (Element)node;\n-\n-        String ruleName \u003d element.getAttribute(\"name\");\n-        if (\"\".equals(ruleName)) {\n-          throw new AllocationConfigurationException(\"No name provided for a \" +\n-            \"rule element\");\n-        }\n-\n-        Class\u003c? extends QueuePlacementRule\u003e clazz \u003d ruleClasses.get(ruleName);\n-        if (clazz \u003d\u003d null) {\n-          throw new AllocationConfigurationException(\"No rule class found for \"\n-              + ruleName);\n-        }\n-        QueuePlacementRule rule \u003d ReflectionUtils.newInstance(clazz, null);\n-        rule.initializeFromXml(element);\n+        QueuePlacementRule rule \u003d createAndInitializeRule(node);\n         rules.add(rule);\n       }\n     }\n     return new QueuePlacementPolicy(rules, configuredQueues, conf);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static QueuePlacementPolicy fromXml(Element el,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues, Configuration conf)\n      throws AllocationConfigurationException {\n    List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n    NodeList elements \u003d el.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        QueuePlacementRule rule \u003d createAndInitializeRule(node);\n        rules.add(rule);\n      }\n    }\n    return new QueuePlacementPolicy(rules, configuredQueues, conf);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueuePlacementPolicy.java",
          "extendedDetails": {
            "oldValue": "[el-Element, configuredQueues-Set\u003cString\u003e, conf-Configuration]",
            "newValue": "[el-Element, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, conf-Configuration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1864. Fair Scheduler Dynamic Hierarchical User Queues (Ashwin Shankar via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593190 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/05/14 12:21 AM",
          "commitName": "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "22/01/14 10:51 AM",
          "commitNameOld": "1a7e1588443071e497c6fea0224a78ca8de1cf3e",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 105.52,
          "commitsBetweenForRepo": 807,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,14 @@\n-  public static QueuePlacementPolicy fromXml(Element el, Set\u003cString\u003e configuredQueues,\n-      Configuration conf) throws AllocationConfigurationException {\n+  public static QueuePlacementPolicy fromXml(Element el,\n+      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues, Configuration conf)\n+      throws AllocationConfigurationException {\n     List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n     NodeList elements \u003d el.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n-        Element element \u003d (Element)node;\n-\n-        String ruleName \u003d element.getAttribute(\"name\");\n-        if (\"\".equals(ruleName)) {\n-          throw new AllocationConfigurationException(\"No name provided for a \" +\n-            \"rule element\");\n-        }\n-\n-        Class\u003c? extends QueuePlacementRule\u003e clazz \u003d ruleClasses.get(ruleName);\n-        if (clazz \u003d\u003d null) {\n-          throw new AllocationConfigurationException(\"No rule class found for \"\n-              + ruleName);\n-        }\n-        QueuePlacementRule rule \u003d ReflectionUtils.newInstance(clazz, null);\n-        rule.initializeFromXml(element);\n+        QueuePlacementRule rule \u003d createAndInitializeRule(node);\n         rules.add(rule);\n       }\n     }\n     return new QueuePlacementPolicy(rules, configuredQueues, conf);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static QueuePlacementPolicy fromXml(Element el,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues, Configuration conf)\n      throws AllocationConfigurationException {\n    List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n    NodeList elements \u003d el.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        QueuePlacementRule rule \u003d createAndInitializeRule(node);\n        rules.add(rule);\n      }\n    }\n    return new QueuePlacementPolicy(rules, configuredQueues, conf);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueuePlacementPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "1a7e1588443071e497c6fea0224a78ca8de1cf3e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1624. QueuePlacementPolicy format is not easily readable via a JAXB parser (Aditya Acharya via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1560470 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/01/14 10:51 AM",
      "commitName": "1a7e1588443071e497c6fea0224a78ca8de1cf3e",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "04/12/13 7:26 PM",
      "commitNameOld": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 48.64,
      "commitsBetweenForRepo": 230,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,27 @@\n   public static QueuePlacementPolicy fromXml(Element el, Set\u003cString\u003e configuredQueues,\n       Configuration conf) throws AllocationConfigurationException {\n     List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n     NodeList elements \u003d el.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n-        String ruleName \u003d element.getTagName();\n+\n+        String ruleName \u003d element.getAttribute(\"name\");\n+        if (\"\".equals(ruleName)) {\n+          throw new AllocationConfigurationException(\"No name provided for a \" +\n+            \"rule element\");\n+        }\n+\n         Class\u003c? extends QueuePlacementRule\u003e clazz \u003d ruleClasses.get(ruleName);\n         if (clazz \u003d\u003d null) {\n           throw new AllocationConfigurationException(\"No rule class found for \"\n               + ruleName);\n         }\n         QueuePlacementRule rule \u003d ReflectionUtils.newInstance(clazz, null);\n         rule.initializeFromXml(element);\n         rules.add(rule);\n       }\n     }\n     return new QueuePlacementPolicy(rules, configuredQueues, conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static QueuePlacementPolicy fromXml(Element el, Set\u003cString\u003e configuredQueues,\n      Configuration conf) throws AllocationConfigurationException {\n    List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n    NodeList elements \u003d el.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n\n        String ruleName \u003d element.getAttribute(\"name\");\n        if (\"\".equals(ruleName)) {\n          throw new AllocationConfigurationException(\"No name provided for a \" +\n            \"rule element\");\n        }\n\n        Class\u003c? extends QueuePlacementRule\u003e clazz \u003d ruleClasses.get(ruleName);\n        if (clazz \u003d\u003d null) {\n          throw new AllocationConfigurationException(\"No rule class found for \"\n              + ruleName);\n        }\n        QueuePlacementRule rule \u003d ReflectionUtils.newInstance(clazz, null);\n        rule.initializeFromXml(element);\n        rules.add(rule);\n      }\n    }\n    return new QueuePlacementPolicy(rules, configuredQueues, conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueuePlacementPolicy.java",
      "extendedDetails": {}
    },
    "6ac4ac05f75480ebfe1adfcceabc4f1674619eae": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1392: Add new files\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1542106 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/13 2:13 PM",
      "commitName": "6ac4ac05f75480ebfe1adfcceabc4f1674619eae",
      "commitAuthor": "Sanford Ryza",
      "diff": "@@ -0,0 +1,21 @@\n+  public static QueuePlacementPolicy fromXml(Element el, Set\u003cString\u003e configuredQueues,\n+      Configuration conf) throws AllocationConfigurationException {\n+    List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n+    NodeList elements \u003d el.getChildNodes();\n+    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n+      Node node \u003d elements.item(i);\n+      if (node instanceof Element) {\n+        Element element \u003d (Element)node;\n+        String ruleName \u003d element.getTagName();\n+        Class\u003c? extends QueuePlacementRule\u003e clazz \u003d ruleClasses.get(ruleName);\n+        if (clazz \u003d\u003d null) {\n+          throw new AllocationConfigurationException(\"No rule class found for \"\n+              + ruleName);\n+        }\n+        QueuePlacementRule rule \u003d ReflectionUtils.newInstance(clazz, null);\n+        rule.initializeFromXml(element);\n+        rules.add(rule);\n+      }\n+    }\n+    return new QueuePlacementPolicy(rules, configuredQueues, conf);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static QueuePlacementPolicy fromXml(Element el, Set\u003cString\u003e configuredQueues,\n      Configuration conf) throws AllocationConfigurationException {\n    List\u003cQueuePlacementRule\u003e rules \u003d new ArrayList\u003cQueuePlacementRule\u003e();\n    NodeList elements \u003d el.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        String ruleName \u003d element.getTagName();\n        Class\u003c? extends QueuePlacementRule\u003e clazz \u003d ruleClasses.get(ruleName);\n        if (clazz \u003d\u003d null) {\n          throw new AllocationConfigurationException(\"No rule class found for \"\n              + ruleName);\n        }\n        QueuePlacementRule rule \u003d ReflectionUtils.newInstance(clazz, null);\n        rule.initializeFromXml(element);\n        rules.add(rule);\n      }\n    }\n    return new QueuePlacementPolicy(rules, configuredQueues, conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueuePlacementPolicy.java"
    }
  }
}