{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Dispatcher.java",
  "functionName": "chooseProxySource",
  "functionId": "chooseProxySource",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
  "functionStartLine": 310,
  "functionEndLine": 338,
  "numCommitsSeen": 110,
  "timeTaken": 8833,
  "changeHistory": [
    "673280df24f0228bf01777035ceeab8807da8c40",
    "058af60c56207907f2bedf76df4284e86d923e0c",
    "8ea20b53a861a2771c206afaacf8e7783568c4b1",
    "5d5aae0694bc27df5b9fa50819854cd3050a8658",
    "e60673697d5046c29c52bbabdfe80506f99773e4",
    "c3cf331dc91e2beef2afeed11105084843b02858",
    "b8597e6a10b2e8df1bee4e8ce0c8be345f7e007d",
    "327a995561270bc01c024e38ddd1063c42ff2e3c",
    "1634e980af422c0af2f7c9c7280a77f2fbddc9c0",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "673280df24f0228bf01777035ceeab8807da8c40": "Ybodychange",
    "058af60c56207907f2bedf76df4284e86d923e0c": "Ybodychange",
    "8ea20b53a861a2771c206afaacf8e7783568c4b1": "Ymodifierchange",
    "5d5aae0694bc27df5b9fa50819854cd3050a8658": "Ymodifierchange",
    "e60673697d5046c29c52bbabdfe80506f99773e4": "Ybodychange",
    "c3cf331dc91e2beef2afeed11105084843b02858": "Ymovefromfile",
    "b8597e6a10b2e8df1bee4e8ce0c8be345f7e007d": "Ybodychange",
    "327a995561270bc01c024e38ddd1063c42ff2e3c": "Ybodychange",
    "1634e980af422c0af2f7c9c7280a77f2fbddc9c0": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "673280df24f0228bf01777035ceeab8807da8c40": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7621. Erasure Coding: update the Balancer/Mover data migration logic. Contributed by Walter Su.\n",
      "commitDate": "03/06/15 11:51 AM",
      "commitName": "673280df24f0228bf01777035ceeab8807da8c40",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "05/05/15 3:41 PM",
      "commitNameOld": "4da8490b512a33a255ed27309860859388d7c168",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 28.84,
      "commitsBetweenForRepo": 380,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n     private boolean chooseProxySource() {\n       final DatanodeInfo targetDN \u003d target.getDatanodeInfo();\n       // if source and target are same nodes then no need of proxy\n       if (source.getDatanodeInfo().equals(targetDN) \u0026\u0026 addTo(source)) {\n         return true;\n       }\n       // if node group is supported, first try add nodes in the same node group\n       if (cluster.isNodeGroupAware()) {\n-        for (StorageGroup loc : block.getLocations()) {\n+        for (StorageGroup loc : reportedBlock.getLocations()) {\n           if (cluster.isOnSameNodeGroup(loc.getDatanodeInfo(), targetDN)\n               \u0026\u0026 addTo(loc)) {\n             return true;\n           }\n         }\n       }\n       // check if there is replica which is on the same rack with the target\n-      for (StorageGroup loc : block.getLocations()) {\n+      for (StorageGroup loc : reportedBlock.getLocations()) {\n         if (cluster.isOnSameRack(loc.getDatanodeInfo(), targetDN) \u0026\u0026 addTo(loc)) {\n           return true;\n         }\n       }\n       // find out a non-busy replica\n-      for (StorageGroup loc : block.getLocations()) {\n+      for (StorageGroup loc : reportedBlock.getLocations()) {\n         if (addTo(loc)) {\n           return true;\n         }\n       }\n       return false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private boolean chooseProxySource() {\n      final DatanodeInfo targetDN \u003d target.getDatanodeInfo();\n      // if source and target are same nodes then no need of proxy\n      if (source.getDatanodeInfo().equals(targetDN) \u0026\u0026 addTo(source)) {\n        return true;\n      }\n      // if node group is supported, first try add nodes in the same node group\n      if (cluster.isNodeGroupAware()) {\n        for (StorageGroup loc : reportedBlock.getLocations()) {\n          if (cluster.isOnSameNodeGroup(loc.getDatanodeInfo(), targetDN)\n              \u0026\u0026 addTo(loc)) {\n            return true;\n          }\n        }\n      }\n      // check if there is replica which is on the same rack with the target\n      for (StorageGroup loc : reportedBlock.getLocations()) {\n        if (cluster.isOnSameRack(loc.getDatanodeInfo(), targetDN) \u0026\u0026 addTo(loc)) {\n          return true;\n        }\n      }\n      // find out a non-busy replica\n      for (StorageGroup loc : reportedBlock.getLocations()) {\n        if (addTo(loc)) {\n          return true;\n        }\n      }\n      return false;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "058af60c56207907f2bedf76df4284e86d923e0c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7310. Mover can give first priority to local DN if it has target storage type available in local DN. (Vinayakumar B via umamahesh)\n",
      "commitDate": "26/11/14 9:57 AM",
      "commitName": "058af60c56207907f2bedf76df4284e86d923e0c",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "06/11/14 5:48 PM",
      "commitNameOld": "ae71a671a3b4b454aa393c2974b6f1f16dd61405",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 19.67,
      "commitsBetweenForRepo": 149,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,29 @@\n     private boolean chooseProxySource() {\n       final DatanodeInfo targetDN \u003d target.getDatanodeInfo();\n+      // if source and target are same nodes then no need of proxy\n+      if (source.getDatanodeInfo().equals(targetDN) \u0026\u0026 addTo(source)) {\n+        return true;\n+      }\n       // if node group is supported, first try add nodes in the same node group\n       if (cluster.isNodeGroupAware()) {\n         for (StorageGroup loc : block.getLocations()) {\n           if (cluster.isOnSameNodeGroup(loc.getDatanodeInfo(), targetDN)\n               \u0026\u0026 addTo(loc)) {\n             return true;\n           }\n         }\n       }\n       // check if there is replica which is on the same rack with the target\n       for (StorageGroup loc : block.getLocations()) {\n         if (cluster.isOnSameRack(loc.getDatanodeInfo(), targetDN) \u0026\u0026 addTo(loc)) {\n           return true;\n         }\n       }\n       // find out a non-busy replica\n       for (StorageGroup loc : block.getLocations()) {\n         if (addTo(loc)) {\n           return true;\n         }\n       }\n       return false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private boolean chooseProxySource() {\n      final DatanodeInfo targetDN \u003d target.getDatanodeInfo();\n      // if source and target are same nodes then no need of proxy\n      if (source.getDatanodeInfo().equals(targetDN) \u0026\u0026 addTo(source)) {\n        return true;\n      }\n      // if node group is supported, first try add nodes in the same node group\n      if (cluster.isNodeGroupAware()) {\n        for (StorageGroup loc : block.getLocations()) {\n          if (cluster.isOnSameNodeGroup(loc.getDatanodeInfo(), targetDN)\n              \u0026\u0026 addTo(loc)) {\n            return true;\n          }\n        }\n      }\n      // check if there is replica which is on the same rack with the target\n      for (StorageGroup loc : block.getLocations()) {\n        if (cluster.isOnSameRack(loc.getDatanodeInfo(), targetDN) \u0026\u0026 addTo(loc)) {\n          return true;\n        }\n      }\n      // find out a non-busy replica\n      for (StorageGroup loc : block.getLocations()) {\n        if (addTo(loc)) {\n          return true;\n        }\n      }\n      return false;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "8ea20b53a861a2771c206afaacf8e7783568c4b1": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-6911. Archival Storage: check if a block is already scheduled in Mover. Contributed by Tsz Wo Nicholas Sze.\n",
      "commitDate": "27/08/14 10:38 AM",
      "commitName": "8ea20b53a861a2771c206afaacf8e7783568c4b1",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "18/08/14 10:51 AM",
      "commitNameOld": "5d5aae0694bc27df5b9fa50819854cd3050a8658",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 8.99,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n-    public boolean chooseProxySource() {\n+    private boolean chooseProxySource() {\n       final DatanodeInfo targetDN \u003d target.getDatanodeInfo();\n       // if node group is supported, first try add nodes in the same node group\n       if (cluster.isNodeGroupAware()) {\n         for (StorageGroup loc : block.getLocations()) {\n           if (cluster.isOnSameNodeGroup(loc.getDatanodeInfo(), targetDN)\n               \u0026\u0026 addTo(loc)) {\n             return true;\n           }\n         }\n       }\n       // check if there is replica which is on the same rack with the target\n       for (StorageGroup loc : block.getLocations()) {\n         if (cluster.isOnSameRack(loc.getDatanodeInfo(), targetDN) \u0026\u0026 addTo(loc)) {\n           return true;\n         }\n       }\n       // find out a non-busy replica\n       for (StorageGroup loc : block.getLocations()) {\n         if (addTo(loc)) {\n           return true;\n         }\n       }\n       return false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private boolean chooseProxySource() {\n      final DatanodeInfo targetDN \u003d target.getDatanodeInfo();\n      // if node group is supported, first try add nodes in the same node group\n      if (cluster.isNodeGroupAware()) {\n        for (StorageGroup loc : block.getLocations()) {\n          if (cluster.isOnSameNodeGroup(loc.getDatanodeInfo(), targetDN)\n              \u0026\u0026 addTo(loc)) {\n            return true;\n          }\n        }\n      }\n      // check if there is replica which is on the same rack with the target\n      for (StorageGroup loc : block.getLocations()) {\n        if (cluster.isOnSameRack(loc.getDatanodeInfo(), targetDN) \u0026\u0026 addTo(loc)) {\n          return true;\n        }\n      }\n      // find out a non-busy replica\n      for (StorageGroup loc : block.getLocations()) {\n        if (addTo(loc)) {\n          return true;\n        }\n      }\n      return false;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[private]"
      }
    },
    "5d5aae0694bc27df5b9fa50819854cd3050a8658": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-6801. Archival Storage: Add a new data migration tool. Contributed by Tsz Wo Nicholas Sze.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-6584@1618675 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/14 10:51 AM",
      "commitName": "5d5aae0694bc27df5b9fa50819854cd3050a8658",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/08/14 11:43 AM",
      "commitNameOld": "195961a7c1da86421761162836766b1de07930fd",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 4.96,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n-    private boolean chooseProxySource() {\n+    public boolean chooseProxySource() {\n       final DatanodeInfo targetDN \u003d target.getDatanodeInfo();\n       // if node group is supported, first try add nodes in the same node group\n       if (cluster.isNodeGroupAware()) {\n         for (StorageGroup loc : block.getLocations()) {\n           if (cluster.isOnSameNodeGroup(loc.getDatanodeInfo(), targetDN)\n               \u0026\u0026 addTo(loc)) {\n             return true;\n           }\n         }\n       }\n       // check if there is replica which is on the same rack with the target\n       for (StorageGroup loc : block.getLocations()) {\n         if (cluster.isOnSameRack(loc.getDatanodeInfo(), targetDN) \u0026\u0026 addTo(loc)) {\n           return true;\n         }\n       }\n       // find out a non-busy replica\n       for (StorageGroup loc : block.getLocations()) {\n         if (addTo(loc)) {\n           return true;\n         }\n       }\n       return false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public boolean chooseProxySource() {\n      final DatanodeInfo targetDN \u003d target.getDatanodeInfo();\n      // if node group is supported, first try add nodes in the same node group\n      if (cluster.isNodeGroupAware()) {\n        for (StorageGroup loc : block.getLocations()) {\n          if (cluster.isOnSameNodeGroup(loc.getDatanodeInfo(), targetDN)\n              \u0026\u0026 addTo(loc)) {\n            return true;\n          }\n        }\n      }\n      // check if there is replica which is on the same rack with the target\n      for (StorageGroup loc : block.getLocations()) {\n        if (cluster.isOnSameRack(loc.getDatanodeInfo(), targetDN) \u0026\u0026 addTo(loc)) {\n          return true;\n        }\n      }\n      // find out a non-busy replica\n      for (StorageGroup loc : block.getLocations()) {\n        if (addTo(loc)) {\n          return true;\n        }\n      }\n      return false;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[public]"
      }
    },
    "e60673697d5046c29c52bbabdfe80506f99773e4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6837. Code cleanup for Balancer and Dispatcher. Contributed by Tsz Wo Nicholas Sze.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617337 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/08/14 11:01 AM",
      "commitName": "e60673697d5046c29c52bbabdfe80506f99773e4",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "08/08/14 2:33 PM",
      "commitNameOld": "c3cf331dc91e2beef2afeed11105084843b02858",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.85,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n     private boolean chooseProxySource() {\n-      final DatanodeInfo targetDN \u003d target.getDatanode();\n+      final DatanodeInfo targetDN \u003d target.getDatanodeInfo();\n       // if node group is supported, first try add nodes in the same node group\n       if (cluster.isNodeGroupAware()) {\n-        for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n-          if (cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN)\n+        for (StorageGroup loc : block.getLocations()) {\n+          if (cluster.isOnSameNodeGroup(loc.getDatanodeInfo(), targetDN)\n               \u0026\u0026 addTo(loc)) {\n             return true;\n           }\n         }\n       }\n       // check if there is replica which is on the same rack with the target\n-      for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n-        if (cluster.isOnSameRack(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n+      for (StorageGroup loc : block.getLocations()) {\n+        if (cluster.isOnSameRack(loc.getDatanodeInfo(), targetDN) \u0026\u0026 addTo(loc)) {\n           return true;\n         }\n       }\n       // find out a non-busy replica\n-      for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n+      for (StorageGroup loc : block.getLocations()) {\n         if (addTo(loc)) {\n           return true;\n         }\n       }\n       return false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private boolean chooseProxySource() {\n      final DatanodeInfo targetDN \u003d target.getDatanodeInfo();\n      // if node group is supported, first try add nodes in the same node group\n      if (cluster.isNodeGroupAware()) {\n        for (StorageGroup loc : block.getLocations()) {\n          if (cluster.isOnSameNodeGroup(loc.getDatanodeInfo(), targetDN)\n              \u0026\u0026 addTo(loc)) {\n            return true;\n          }\n        }\n      }\n      // check if there is replica which is on the same rack with the target\n      for (StorageGroup loc : block.getLocations()) {\n        if (cluster.isOnSameRack(loc.getDatanodeInfo(), targetDN) \u0026\u0026 addTo(loc)) {\n          return true;\n        }\n      }\n      // find out a non-busy replica\n      for (StorageGroup loc : block.getLocations()) {\n        if (addTo(loc)) {\n          return true;\n        }\n      }\n      return false;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "c3cf331dc91e2beef2afeed11105084843b02858": {
      "type": "Ymovefromfile",
      "commitMessage": "HDFS-6828. Separate block replica dispatching from Balancer. Contributed by Tsz Wo Nicholas Sze.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616889 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/14 2:33 PM",
      "commitName": "c3cf331dc91e2beef2afeed11105084843b02858",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "08/08/14 2:22 PM",
      "commitNameOld": "05d1bf4157e6660610f11951845e59899260596e",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,25 @@\n     private boolean chooseProxySource() {\n       final DatanodeInfo targetDN \u003d target.getDatanode();\n       // if node group is supported, first try add nodes in the same node group\n       if (cluster.isNodeGroupAware()) {\n         for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n-          if (cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n+          if (cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN)\n+              \u0026\u0026 addTo(loc)) {\n             return true;\n           }\n         }\n       }\n       // check if there is replica which is on the same rack with the target\n       for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n         if (cluster.isOnSameRack(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n           return true;\n         }\n       }\n       // find out a non-busy replica\n       for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n         if (addTo(loc)) {\n           return true;\n         }\n       }\n       return false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private boolean chooseProxySource() {\n      final DatanodeInfo targetDN \u003d target.getDatanode();\n      // if node group is supported, first try add nodes in the same node group\n      if (cluster.isNodeGroupAware()) {\n        for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n          if (cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN)\n              \u0026\u0026 addTo(loc)) {\n            return true;\n          }\n        }\n      }\n      // check if there is replica which is on the same rack with the target\n      for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n        if (cluster.isOnSameRack(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n          return true;\n        }\n      }\n      // find out a non-busy replica\n      for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n        if (addTo(loc)) {\n          return true;\n        }\n      }\n      return false;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
        "oldMethodName": "chooseProxySource",
        "newMethodName": "chooseProxySource"
      }
    },
    "b8597e6a10b2e8df1bee4e8ce0c8be345f7e007d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6685. Balancer should preserve storage type of replicas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615015 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/07/14 6:05 PM",
      "commitName": "b8597e6a10b2e8df1bee4e8ce0c8be345f7e007d",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "30/07/14 11:02 PM",
      "commitNameOld": "b8b8f3f5e7214d6fcfc30e1b94ff097e52868f4f",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,24 @@\n     private boolean chooseProxySource() {\n       final DatanodeInfo targetDN \u003d target.getDatanode();\n       // if node group is supported, first try add nodes in the same node group\n       if (cluster.isNodeGroupAware()) {\n-        for (BalancerDatanode loc : block.getLocations()) {\n+        for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n           if (cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n             return true;\n           }\n         }\n       }\n       // check if there is replica which is on the same rack with the target\n-      for (BalancerDatanode loc : block.getLocations()) {\n+      for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n         if (cluster.isOnSameRack(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n           return true;\n         }\n       }\n       // find out a non-busy replica\n-      for (BalancerDatanode loc : block.getLocations()) {\n+      for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n         if (addTo(loc)) {\n           return true;\n         }\n       }\n       return false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private boolean chooseProxySource() {\n      final DatanodeInfo targetDN \u003d target.getDatanode();\n      // if node group is supported, first try add nodes in the same node group\n      if (cluster.isNodeGroupAware()) {\n        for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n          if (cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n            return true;\n          }\n        }\n      }\n      // check if there is replica which is on the same rack with the target\n      for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n        if (cluster.isOnSameRack(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n          return true;\n        }\n      }\n      // find out a non-busy replica\n      for (BalancerDatanode.StorageGroup loc : block.getLocations()) {\n        if (addTo(loc)) {\n          return true;\n        }\n      }\n      return false;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "327a995561270bc01c024e38ddd1063c42ff2e3c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5580. Fix infinite loop in Balancer.waitForMoveCompletion. (Binglin Chang via junping_du)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550074 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/12/13 12:51 AM",
      "commitName": "327a995561270bc01c024e38ddd1063c42ff2e3c",
      "commitAuthor": "Junping Du",
      "commitDateOld": "16/10/13 4:06 PM",
      "commitNameOld": "1ba58e2e2c7778d7c44ba6cd72ac4aa0f288ded8",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 55.41,
      "commitsBetweenForRepo": 291,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,24 @@\n     private boolean chooseProxySource() {\n       final DatanodeInfo targetDN \u003d target.getDatanode();\n-      boolean find \u003d false;\n-      for (BalancerDatanode loc : block.getLocations()) {\n-        // check if there is replica which is on the same rack with the target\n-        if (cluster.isOnSameRack(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n-          find \u003d true;\n-          // if cluster is not nodegroup aware or the proxy is on the same \n-          // nodegroup with target, then we already find the nearest proxy\n-          if (!cluster.isNodeGroupAware() \n-              || cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN)) {\n+      // if node group is supported, first try add nodes in the same node group\n+      if (cluster.isNodeGroupAware()) {\n+        for (BalancerDatanode loc : block.getLocations()) {\n+          if (cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n             return true;\n           }\n         }\n-        \n-        if (!find) {\n-          // find out a non-busy replica out of rack of target\n-          find \u003d addTo(loc);\n+      }\n+      // check if there is replica which is on the same rack with the target\n+      for (BalancerDatanode loc : block.getLocations()) {\n+        if (cluster.isOnSameRack(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n+          return true;\n         }\n       }\n-      \n-      return find;\n+      // find out a non-busy replica\n+      for (BalancerDatanode loc : block.getLocations()) {\n+        if (addTo(loc)) {\n+          return true;\n+        }\n+      }\n+      return false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private boolean chooseProxySource() {\n      final DatanodeInfo targetDN \u003d target.getDatanode();\n      // if node group is supported, first try add nodes in the same node group\n      if (cluster.isNodeGroupAware()) {\n        for (BalancerDatanode loc : block.getLocations()) {\n          if (cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n            return true;\n          }\n        }\n      }\n      // check if there is replica which is on the same rack with the target\n      for (BalancerDatanode loc : block.getLocations()) {\n        if (cluster.isOnSameRack(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n          return true;\n        }\n      }\n      // find out a non-busy replica\n      for (BalancerDatanode loc : block.getLocations()) {\n        if (addTo(loc)) {\n          return true;\n        }\n      }\n      return false;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "1634e980af422c0af2f7c9c7280a77f2fbddc9c0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3495. Update Balancer to support new NetworkTopology with NodeGroup.  Contributed by Junping Du\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1414874 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/11/12 11:19 AM",
      "commitName": "1634e980af422c0af2f7c9c7280a77f2fbddc9c0",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "14/08/12 5:28 PM",
      "commitNameOld": "28e87740c5797e87a9038d7f151c8b21a5b04592",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 105.79,
      "commitsBetweenForRepo": 628,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,23 @@\n     private boolean chooseProxySource() {\n-      // check if there is replica which is on the same rack with the target\n+      final DatanodeInfo targetDN \u003d target.getDatanode();\n+      boolean find \u003d false;\n       for (BalancerDatanode loc : block.getLocations()) {\n-        if (cluster.isOnSameRack(loc.getDatanode(), target.getDatanode())) {\n-          if (loc.addPendingBlock(this)) {\n-            proxySource \u003d loc;\n+        // check if there is replica which is on the same rack with the target\n+        if (cluster.isOnSameRack(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n+          find \u003d true;\n+          // if cluster is not nodegroup aware or the proxy is on the same \n+          // nodegroup with target, then we already find the nearest proxy\n+          if (!cluster.isNodeGroupAware() \n+              || cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN)) {\n             return true;\n           }\n         }\n-      }\n-      // find out a non-busy replica\n-      for (BalancerDatanode loc : block.getLocations()) {\n-        if (loc.addPendingBlock(this)) {\n-          proxySource \u003d loc;\n-          return true;\n+        \n+        if (!find) {\n+          // find out a non-busy replica out of rack of target\n+          find \u003d addTo(loc);\n         }\n       }\n-      return false;\n+      \n+      return find;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private boolean chooseProxySource() {\n      final DatanodeInfo targetDN \u003d target.getDatanode();\n      boolean find \u003d false;\n      for (BalancerDatanode loc : block.getLocations()) {\n        // check if there is replica which is on the same rack with the target\n        if (cluster.isOnSameRack(loc.getDatanode(), targetDN) \u0026\u0026 addTo(loc)) {\n          find \u003d true;\n          // if cluster is not nodegroup aware or the proxy is on the same \n          // nodegroup with target, then we already find the nearest proxy\n          if (!cluster.isNodeGroupAware() \n              || cluster.isOnSameNodeGroup(loc.getDatanode(), targetDN)) {\n            return true;\n          }\n        }\n        \n        if (!find) {\n          // find out a non-busy replica out of rack of target\n          find \u003d addTo(loc);\n        }\n      }\n      \n      return find;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private boolean chooseProxySource() {\n      // check if there is replica which is on the same rack with the target\n      for (BalancerDatanode loc : block.getLocations()) {\n        if (cluster.isOnSameRack(loc.getDatanode(), target.getDatanode())) {\n          if (loc.addPendingBlock(this)) {\n            proxySource \u003d loc;\n            return true;\n          }\n        }\n      }\n      // find out a non-busy replica\n      for (BalancerDatanode loc : block.getLocations()) {\n        if (loc.addPendingBlock(this)) {\n          proxySource \u003d loc;\n          return true;\n        }\n      }\n      return false;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private boolean chooseProxySource() {\n      // check if there is replica which is on the same rack with the target\n      for (BalancerDatanode loc : block.getLocations()) {\n        if (cluster.isOnSameRack(loc.getDatanode(), target.getDatanode())) {\n          if (loc.addPendingBlock(this)) {\n            proxySource \u003d loc;\n            return true;\n          }\n        }\n      }\n      // find out a non-busy replica\n      for (BalancerDatanode loc : block.getLocations()) {\n        if (loc.addPendingBlock(this)) {\n          proxySource \u003d loc;\n          return true;\n        }\n      }\n      return false;\n    }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,19 @@\n+    private boolean chooseProxySource() {\n+      // check if there is replica which is on the same rack with the target\n+      for (BalancerDatanode loc : block.getLocations()) {\n+        if (cluster.isOnSameRack(loc.getDatanode(), target.getDatanode())) {\n+          if (loc.addPendingBlock(this)) {\n+            proxySource \u003d loc;\n+            return true;\n+          }\n+        }\n+      }\n+      // find out a non-busy replica\n+      for (BalancerDatanode loc : block.getLocations()) {\n+        if (loc.addPendingBlock(this)) {\n+          proxySource \u003d loc;\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private boolean chooseProxySource() {\n      // check if there is replica which is on the same rack with the target\n      for (BalancerDatanode loc : block.getLocations()) {\n        if (cluster.isOnSameRack(loc.getDatanode(), target.getDatanode())) {\n          if (loc.addPendingBlock(this)) {\n            proxySource \u003d loc;\n            return true;\n          }\n        }\n      }\n      // find out a non-busy replica\n      for (BalancerDatanode loc : block.getLocations()) {\n        if (loc.addPendingBlock(this)) {\n          proxySource \u003d loc;\n          return true;\n        }\n      }\n      return false;\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java"
    }
  }
}