{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AzureNativeFileSystemStore.java",
  "functionName": "storefile",
  "functionId": "storefile___keyEncoded-String__permissionStatus-PermissionStatus__key-String",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
  "functionStartLine": 1466,
  "functionEndLine": 1556,
  "numCommitsSeen": 95,
  "timeTaken": 3329,
  "changeHistory": [
    "13eda5000304099d1145631f9be13ce8a00b600d",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82"
  ],
  "changeHistoryShort": {
    "13eda5000304099d1145631f9be13ce8a00b600d": "Ymultichange(Yparameterchange,Ybodychange)",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Ybodychange",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": "Yintroduced"
  },
  "changeHistoryDetails": {
    "13eda5000304099d1145631f9be13ce8a00b600d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-14520. WASB: Block compaction for Azure Block Blobs.\nContributed by Georgi Chalakov\n",
      "commitDate": "07/09/17 10:35 AM",
      "commitName": "13eda5000304099d1145631f9be13ce8a00b600d",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-14520. WASB: Block compaction for Azure Block Blobs.\nContributed by Georgi Chalakov\n",
          "commitDate": "07/09/17 10:35 AM",
          "commitName": "13eda5000304099d1145631f9be13ce8a00b600d",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "29/08/17 11:03 AM",
          "commitNameOld": "9374f3882044b552b7dbde788ce569452072c6dc",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.98,
          "commitsBetweenForRepo": 121,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,75 +1,91 @@\n-  public DataOutputStream storefile(String key, PermissionStatus permissionStatus)\n+  public DataOutputStream storefile(String keyEncoded,\n+                                    PermissionStatus permissionStatus,\n+                                    String key)\n       throws AzureException {\n     try {\n \n       // Check if a session exists, if not create a session with the\n       // Azure storage server.\n       if (null \u003d\u003d storageInteractionLayer) {\n         final String errMsg \u003d String.format(\n             \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n             sessionUri);\n         throw new AzureException(errMsg);\n       }\n \n       // Check if there is an authenticated account associated with the\n       // file this instance of the WASB file system. If not the file system\n       // has not been authenticated and all access is anonymous.\n       if (!isAuthenticatedAccess()) {\n         // Preemptively raise an exception indicating no uploads are\n         // allowed to anonymous accounts.\n         throw new AzureException(new IOException(\n             \"Uploads to public accounts using anonymous \"\n                 + \"access is prohibited.\"));\n       }\n \n       checkContainer(ContainerAccessType.PureWrite);\n \n       /**\n        * Note: Windows Azure Blob Storage does not allow the creation of arbitrary directory\n        *      paths under the default $root directory.  This is by design to eliminate\n        *      ambiguity in specifying a implicit blob address. A blob in the $root conatiner\n        *      cannot include a / in its name and must be careful not to include a trailing\n        *      \u0027/\u0027 when referencing  blobs in the $root container.\n        *      A \u0027/; in the $root container permits ambiguous blob names as in the following\n        *      example involving two containers $root and mycontainer:\n        *                http://myaccount.blob.core.windows.net/$root\n        *                http://myaccount.blob.core.windows.net/mycontainer\n        *      If the URL \"mycontainer/somefile.txt were allowed in $root then the URL:\n        *                http://myaccount.blob.core.windows.net/mycontainer/myblob.txt\n        *      could mean either:\n        *        (1) container\u003dmycontainer; blob\u003dmyblob.txt\n        *        (2) container\u003d$root; blob\u003dmycontainer/myblob.txt\n        *\n        * To avoid this type of ambiguity the Azure blob storage prevents\n        * arbitrary path under $root. For a simple and more consistent user\n        * experience it was decided to eliminate the opportunity for creating\n        * such paths by making the $root container read-only under WASB.\n        */\n \n       // Check that no attempt is made to write to blobs on default\n       // $root containers.\n       if (AZURE_ROOT_CONTAINER.equals(getContainerFromAuthority(sessionUri))) {\n         // Azure containers are restricted to non-root containers.\n         final String errMsg \u003d String.format(\n             \"Writes to \u0027%s\u0027 container for URI \u0027%s\u0027 are prohibited, \"\n                 + \"only updates on non-root containers permitted.\",\n             AZURE_ROOT_CONTAINER, sessionUri.toString());\n         throw new AzureException(errMsg);\n       }\n \n       // Get the blob reference from the store\u0027s container and\n       // return it.\n-      CloudBlobWrapper blob \u003d getBlobReference(key);\n+      CloudBlobWrapper blob \u003d getBlobReference(keyEncoded);\n       storePermissionStatus(blob, permissionStatus);\n \n       // Create the output stream for the Azure blob.\n       //\n-      OutputStream outputStream \u003d openOutputStream(blob);\n+      OutputStream outputStream;\n+\n+      if (isBlockBlobWithCompactionKey(key)) {\n+        BlockBlobAppendStream blockBlobOutputStream \u003d new BlockBlobAppendStream(\n+            (CloudBlockBlobWrapper) blob,\n+            keyEncoded,\n+            this.uploadBlockSizeBytes,\n+            true,\n+            getInstrumentedContext());\n+\n+        outputStream \u003d blockBlobOutputStream;\n+      } else {\n+        outputStream \u003d openOutputStream(blob);\n+      }\n+\n       DataOutputStream dataOutStream \u003d new SyncableDataOutputStream(outputStream);\n       return dataOutStream;\n     } catch (Exception e) {\n       // Caught exception while attempting to open the blob output stream.\n       // Re-throw as an Azure storage exception.\n       throw new AzureException(e);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DataOutputStream storefile(String keyEncoded,\n                                    PermissionStatus permissionStatus,\n                                    String key)\n      throws AzureException {\n    try {\n\n      // Check if a session exists, if not create a session with the\n      // Azure storage server.\n      if (null \u003d\u003d storageInteractionLayer) {\n        final String errMsg \u003d String.format(\n            \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n            sessionUri);\n        throw new AzureException(errMsg);\n      }\n\n      // Check if there is an authenticated account associated with the\n      // file this instance of the WASB file system. If not the file system\n      // has not been authenticated and all access is anonymous.\n      if (!isAuthenticatedAccess()) {\n        // Preemptively raise an exception indicating no uploads are\n        // allowed to anonymous accounts.\n        throw new AzureException(new IOException(\n            \"Uploads to public accounts using anonymous \"\n                + \"access is prohibited.\"));\n      }\n\n      checkContainer(ContainerAccessType.PureWrite);\n\n      /**\n       * Note: Windows Azure Blob Storage does not allow the creation of arbitrary directory\n       *      paths under the default $root directory.  This is by design to eliminate\n       *      ambiguity in specifying a implicit blob address. A blob in the $root conatiner\n       *      cannot include a / in its name and must be careful not to include a trailing\n       *      \u0027/\u0027 when referencing  blobs in the $root container.\n       *      A \u0027/; in the $root container permits ambiguous blob names as in the following\n       *      example involving two containers $root and mycontainer:\n       *                http://myaccount.blob.core.windows.net/$root\n       *                http://myaccount.blob.core.windows.net/mycontainer\n       *      If the URL \"mycontainer/somefile.txt were allowed in $root then the URL:\n       *                http://myaccount.blob.core.windows.net/mycontainer/myblob.txt\n       *      could mean either:\n       *        (1) container\u003dmycontainer; blob\u003dmyblob.txt\n       *        (2) container\u003d$root; blob\u003dmycontainer/myblob.txt\n       *\n       * To avoid this type of ambiguity the Azure blob storage prevents\n       * arbitrary path under $root. For a simple and more consistent user\n       * experience it was decided to eliminate the opportunity for creating\n       * such paths by making the $root container read-only under WASB.\n       */\n\n      // Check that no attempt is made to write to blobs on default\n      // $root containers.\n      if (AZURE_ROOT_CONTAINER.equals(getContainerFromAuthority(sessionUri))) {\n        // Azure containers are restricted to non-root containers.\n        final String errMsg \u003d String.format(\n            \"Writes to \u0027%s\u0027 container for URI \u0027%s\u0027 are prohibited, \"\n                + \"only updates on non-root containers permitted.\",\n            AZURE_ROOT_CONTAINER, sessionUri.toString());\n        throw new AzureException(errMsg);\n      }\n\n      // Get the blob reference from the store\u0027s container and\n      // return it.\n      CloudBlobWrapper blob \u003d getBlobReference(keyEncoded);\n      storePermissionStatus(blob, permissionStatus);\n\n      // Create the output stream for the Azure blob.\n      //\n      OutputStream outputStream;\n\n      if (isBlockBlobWithCompactionKey(key)) {\n        BlockBlobAppendStream blockBlobOutputStream \u003d new BlockBlobAppendStream(\n            (CloudBlockBlobWrapper) blob,\n            keyEncoded,\n            this.uploadBlockSizeBytes,\n            true,\n            getInstrumentedContext());\n\n        outputStream \u003d blockBlobOutputStream;\n      } else {\n        outputStream \u003d openOutputStream(blob);\n      }\n\n      DataOutputStream dataOutStream \u003d new SyncableDataOutputStream(outputStream);\n      return dataOutStream;\n    } catch (Exception e) {\n      // Caught exception while attempting to open the blob output stream.\n      // Re-throw as an Azure storage exception.\n      throw new AzureException(e);\n    }\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
          "extendedDetails": {
            "oldValue": "[key-String, permissionStatus-PermissionStatus]",
            "newValue": "[keyEncoded-String, permissionStatus-PermissionStatus, key-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14520. WASB: Block compaction for Azure Block Blobs.\nContributed by Georgi Chalakov\n",
          "commitDate": "07/09/17 10:35 AM",
          "commitName": "13eda5000304099d1145631f9be13ce8a00b600d",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "29/08/17 11:03 AM",
          "commitNameOld": "9374f3882044b552b7dbde788ce569452072c6dc",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.98,
          "commitsBetweenForRepo": 121,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,75 +1,91 @@\n-  public DataOutputStream storefile(String key, PermissionStatus permissionStatus)\n+  public DataOutputStream storefile(String keyEncoded,\n+                                    PermissionStatus permissionStatus,\n+                                    String key)\n       throws AzureException {\n     try {\n \n       // Check if a session exists, if not create a session with the\n       // Azure storage server.\n       if (null \u003d\u003d storageInteractionLayer) {\n         final String errMsg \u003d String.format(\n             \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n             sessionUri);\n         throw new AzureException(errMsg);\n       }\n \n       // Check if there is an authenticated account associated with the\n       // file this instance of the WASB file system. If not the file system\n       // has not been authenticated and all access is anonymous.\n       if (!isAuthenticatedAccess()) {\n         // Preemptively raise an exception indicating no uploads are\n         // allowed to anonymous accounts.\n         throw new AzureException(new IOException(\n             \"Uploads to public accounts using anonymous \"\n                 + \"access is prohibited.\"));\n       }\n \n       checkContainer(ContainerAccessType.PureWrite);\n \n       /**\n        * Note: Windows Azure Blob Storage does not allow the creation of arbitrary directory\n        *      paths under the default $root directory.  This is by design to eliminate\n        *      ambiguity in specifying a implicit blob address. A blob in the $root conatiner\n        *      cannot include a / in its name and must be careful not to include a trailing\n        *      \u0027/\u0027 when referencing  blobs in the $root container.\n        *      A \u0027/; in the $root container permits ambiguous blob names as in the following\n        *      example involving two containers $root and mycontainer:\n        *                http://myaccount.blob.core.windows.net/$root\n        *                http://myaccount.blob.core.windows.net/mycontainer\n        *      If the URL \"mycontainer/somefile.txt were allowed in $root then the URL:\n        *                http://myaccount.blob.core.windows.net/mycontainer/myblob.txt\n        *      could mean either:\n        *        (1) container\u003dmycontainer; blob\u003dmyblob.txt\n        *        (2) container\u003d$root; blob\u003dmycontainer/myblob.txt\n        *\n        * To avoid this type of ambiguity the Azure blob storage prevents\n        * arbitrary path under $root. For a simple and more consistent user\n        * experience it was decided to eliminate the opportunity for creating\n        * such paths by making the $root container read-only under WASB.\n        */\n \n       // Check that no attempt is made to write to blobs on default\n       // $root containers.\n       if (AZURE_ROOT_CONTAINER.equals(getContainerFromAuthority(sessionUri))) {\n         // Azure containers are restricted to non-root containers.\n         final String errMsg \u003d String.format(\n             \"Writes to \u0027%s\u0027 container for URI \u0027%s\u0027 are prohibited, \"\n                 + \"only updates on non-root containers permitted.\",\n             AZURE_ROOT_CONTAINER, sessionUri.toString());\n         throw new AzureException(errMsg);\n       }\n \n       // Get the blob reference from the store\u0027s container and\n       // return it.\n-      CloudBlobWrapper blob \u003d getBlobReference(key);\n+      CloudBlobWrapper blob \u003d getBlobReference(keyEncoded);\n       storePermissionStatus(blob, permissionStatus);\n \n       // Create the output stream for the Azure blob.\n       //\n-      OutputStream outputStream \u003d openOutputStream(blob);\n+      OutputStream outputStream;\n+\n+      if (isBlockBlobWithCompactionKey(key)) {\n+        BlockBlobAppendStream blockBlobOutputStream \u003d new BlockBlobAppendStream(\n+            (CloudBlockBlobWrapper) blob,\n+            keyEncoded,\n+            this.uploadBlockSizeBytes,\n+            true,\n+            getInstrumentedContext());\n+\n+        outputStream \u003d blockBlobOutputStream;\n+      } else {\n+        outputStream \u003d openOutputStream(blob);\n+      }\n+\n       DataOutputStream dataOutStream \u003d new SyncableDataOutputStream(outputStream);\n       return dataOutStream;\n     } catch (Exception e) {\n       // Caught exception while attempting to open the blob output stream.\n       // Re-throw as an Azure storage exception.\n       throw new AzureException(e);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DataOutputStream storefile(String keyEncoded,\n                                    PermissionStatus permissionStatus,\n                                    String key)\n      throws AzureException {\n    try {\n\n      // Check if a session exists, if not create a session with the\n      // Azure storage server.\n      if (null \u003d\u003d storageInteractionLayer) {\n        final String errMsg \u003d String.format(\n            \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n            sessionUri);\n        throw new AzureException(errMsg);\n      }\n\n      // Check if there is an authenticated account associated with the\n      // file this instance of the WASB file system. If not the file system\n      // has not been authenticated and all access is anonymous.\n      if (!isAuthenticatedAccess()) {\n        // Preemptively raise an exception indicating no uploads are\n        // allowed to anonymous accounts.\n        throw new AzureException(new IOException(\n            \"Uploads to public accounts using anonymous \"\n                + \"access is prohibited.\"));\n      }\n\n      checkContainer(ContainerAccessType.PureWrite);\n\n      /**\n       * Note: Windows Azure Blob Storage does not allow the creation of arbitrary directory\n       *      paths under the default $root directory.  This is by design to eliminate\n       *      ambiguity in specifying a implicit blob address. A blob in the $root conatiner\n       *      cannot include a / in its name and must be careful not to include a trailing\n       *      \u0027/\u0027 when referencing  blobs in the $root container.\n       *      A \u0027/; in the $root container permits ambiguous blob names as in the following\n       *      example involving two containers $root and mycontainer:\n       *                http://myaccount.blob.core.windows.net/$root\n       *                http://myaccount.blob.core.windows.net/mycontainer\n       *      If the URL \"mycontainer/somefile.txt were allowed in $root then the URL:\n       *                http://myaccount.blob.core.windows.net/mycontainer/myblob.txt\n       *      could mean either:\n       *        (1) container\u003dmycontainer; blob\u003dmyblob.txt\n       *        (2) container\u003d$root; blob\u003dmycontainer/myblob.txt\n       *\n       * To avoid this type of ambiguity the Azure blob storage prevents\n       * arbitrary path under $root. For a simple and more consistent user\n       * experience it was decided to eliminate the opportunity for creating\n       * such paths by making the $root container read-only under WASB.\n       */\n\n      // Check that no attempt is made to write to blobs on default\n      // $root containers.\n      if (AZURE_ROOT_CONTAINER.equals(getContainerFromAuthority(sessionUri))) {\n        // Azure containers are restricted to non-root containers.\n        final String errMsg \u003d String.format(\n            \"Writes to \u0027%s\u0027 container for URI \u0027%s\u0027 are prohibited, \"\n                + \"only updates on non-root containers permitted.\",\n            AZURE_ROOT_CONTAINER, sessionUri.toString());\n        throw new AzureException(errMsg);\n      }\n\n      // Get the blob reference from the store\u0027s container and\n      // return it.\n      CloudBlobWrapper blob \u003d getBlobReference(keyEncoded);\n      storePermissionStatus(blob, permissionStatus);\n\n      // Create the output stream for the Azure blob.\n      //\n      OutputStream outputStream;\n\n      if (isBlockBlobWithCompactionKey(key)) {\n        BlockBlobAppendStream blockBlobOutputStream \u003d new BlockBlobAppendStream(\n            (CloudBlockBlobWrapper) blob,\n            keyEncoded,\n            this.uploadBlockSizeBytes,\n            true,\n            getInstrumentedContext());\n\n        outputStream \u003d blockBlobOutputStream;\n      } else {\n        outputStream \u003d openOutputStream(blob);\n      }\n\n      DataOutputStream dataOutStream \u003d new SyncableDataOutputStream(outputStream);\n      return dataOutStream;\n    } catch (Exception e) {\n      // Caught exception while attempting to open the blob output stream.\n      // Re-throw as an Azure storage exception.\n      throw new AzureException(e);\n    }\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "commitDateOld": "24/06/14 1:52 PM",
      "commitNameOld": "0d91576ec31f63402f2db6107a04155368e2632d",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 106.02,
      "commitsBetweenForRepo": 1005,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,75 @@\n-  public DataOutputStream storefile(String key,\n-      PermissionStatus permissionStatus) throws AzureException {\n+  public DataOutputStream storefile(String key, PermissionStatus permissionStatus)\n+      throws AzureException {\n     try {\n \n       // Check if a session exists, if not create a session with the\n       // Azure storage server.\n       if (null \u003d\u003d storageInteractionLayer) {\n         final String errMsg \u003d String.format(\n             \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n             sessionUri);\n         throw new AzureException(errMsg);\n       }\n \n       // Check if there is an authenticated account associated with the\n       // file this instance of the WASB file system. If not the file system\n       // has not been authenticated and all access is anonymous.\n       if (!isAuthenticatedAccess()) {\n         // Preemptively raise an exception indicating no uploads are\n         // allowed to anonymous accounts.\n         throw new AzureException(new IOException(\n             \"Uploads to public accounts using anonymous \"\n                 + \"access is prohibited.\"));\n       }\n \n       checkContainer(ContainerAccessType.PureWrite);\n \n       /**\n-       * Note: Windows Azure Blob Storage does not allow the creation of\n-       * arbitrary directory paths under the default $root directory. This is by\n-       * design to eliminate ambiguity in specifying a implicit blob address. A\n-       * blob in the $root container cannot include a / in its name and must be\n-       * careful not to include a trailing \u0027/\u0027 when referencing blobs in the\n-       * $root container. A \u0027/; in the $root container permits ambiguous blob\n-       * names as in the following example involving two containers $root and\n-       * mycontainer: http://myaccount.blob.core.windows.net/$root\n-       * http://myaccount.blob.core.windows.net/mycontainer If the URL\n-       * \"mycontainer/somefile.txt were allowed in $root then the URL:\n-       * http://myaccount.blob.core.windows.net/mycontainer/myblob.txt could\n-       * mean either: (1) container\u003dmycontainer; blob\u003dmyblob.txt (2)\n-       * container\u003d$root; blob\u003dmycontainer/myblob.txt\n+       * Note: Windows Azure Blob Storage does not allow the creation of arbitrary directory\n+       *      paths under the default $root directory.  This is by design to eliminate\n+       *      ambiguity in specifying a implicit blob address. A blob in the $root conatiner\n+       *      cannot include a / in its name and must be careful not to include a trailing\n+       *      \u0027/\u0027 when referencing  blobs in the $root container.\n+       *      A \u0027/; in the $root container permits ambiguous blob names as in the following\n+       *      example involving two containers $root and mycontainer:\n+       *                http://myaccount.blob.core.windows.net/$root\n+       *                http://myaccount.blob.core.windows.net/mycontainer\n+       *      If the URL \"mycontainer/somefile.txt were allowed in $root then the URL:\n+       *                http://myaccount.blob.core.windows.net/mycontainer/myblob.txt\n+       *      could mean either:\n+       *        (1) container\u003dmycontainer; blob\u003dmyblob.txt\n+       *        (2) container\u003d$root; blob\u003dmycontainer/myblob.txt\n        * \n        * To avoid this type of ambiguity the Azure blob storage prevents\n        * arbitrary path under $root. For a simple and more consistent user\n        * experience it was decided to eliminate the opportunity for creating\n        * such paths by making the $root container read-only under WASB. \n        */\n \n       // Check that no attempt is made to write to blobs on default\n       // $root containers.\n       if (AZURE_ROOT_CONTAINER.equals(getContainerFromAuthority(sessionUri))) {\n         // Azure containers are restricted to non-root containers.\n         final String errMsg \u003d String.format(\n             \"Writes to \u0027%s\u0027 container for URI \u0027%s\u0027 are prohibited, \"\n                 + \"only updates on non-root containers permitted.\",\n             AZURE_ROOT_CONTAINER, sessionUri.toString());\n         throw new AzureException(errMsg);\n       }\n \n-      // Get the block blob reference from the store\u0027s container and\n+      // Get the blob reference from the store\u0027s container and\n       // return it.\n-      CloudBlockBlobWrapper blob \u003d getBlobReference(key);\n+      CloudBlobWrapper blob \u003d getBlobReference(key);\n       storePermissionStatus(blob, permissionStatus);\n \n       // Create the output stream for the Azure blob.\n-      OutputStream outputStream \u003d blob.openOutputStream(getUploadOptions(),\n-          getInstrumentedContext());\n-\n-      // Return to caller with DataOutput stream.\n-      DataOutputStream dataOutStream \u003d new DataOutputStream(outputStream);\n+      //\n+      OutputStream outputStream \u003d openOutputStream(blob);\n+      DataOutputStream dataOutStream \u003d new SyncableDataOutputStream(outputStream);\n       return dataOutStream;\n     } catch (Exception e) {\n       // Caught exception while attempting to open the blob output stream.\n       // Re-throw as an Azure storage exception.\n       throw new AzureException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DataOutputStream storefile(String key, PermissionStatus permissionStatus)\n      throws AzureException {\n    try {\n\n      // Check if a session exists, if not create a session with the\n      // Azure storage server.\n      if (null \u003d\u003d storageInteractionLayer) {\n        final String errMsg \u003d String.format(\n            \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n            sessionUri);\n        throw new AzureException(errMsg);\n      }\n\n      // Check if there is an authenticated account associated with the\n      // file this instance of the WASB file system. If not the file system\n      // has not been authenticated and all access is anonymous.\n      if (!isAuthenticatedAccess()) {\n        // Preemptively raise an exception indicating no uploads are\n        // allowed to anonymous accounts.\n        throw new AzureException(new IOException(\n            \"Uploads to public accounts using anonymous \"\n                + \"access is prohibited.\"));\n      }\n\n      checkContainer(ContainerAccessType.PureWrite);\n\n      /**\n       * Note: Windows Azure Blob Storage does not allow the creation of arbitrary directory\n       *      paths under the default $root directory.  This is by design to eliminate\n       *      ambiguity in specifying a implicit blob address. A blob in the $root conatiner\n       *      cannot include a / in its name and must be careful not to include a trailing\n       *      \u0027/\u0027 when referencing  blobs in the $root container.\n       *      A \u0027/; in the $root container permits ambiguous blob names as in the following\n       *      example involving two containers $root and mycontainer:\n       *                http://myaccount.blob.core.windows.net/$root\n       *                http://myaccount.blob.core.windows.net/mycontainer\n       *      If the URL \"mycontainer/somefile.txt were allowed in $root then the URL:\n       *                http://myaccount.blob.core.windows.net/mycontainer/myblob.txt\n       *      could mean either:\n       *        (1) container\u003dmycontainer; blob\u003dmyblob.txt\n       *        (2) container\u003d$root; blob\u003dmycontainer/myblob.txt\n       * \n       * To avoid this type of ambiguity the Azure blob storage prevents\n       * arbitrary path under $root. For a simple and more consistent user\n       * experience it was decided to eliminate the opportunity for creating\n       * such paths by making the $root container read-only under WASB. \n       */\n\n      // Check that no attempt is made to write to blobs on default\n      // $root containers.\n      if (AZURE_ROOT_CONTAINER.equals(getContainerFromAuthority(sessionUri))) {\n        // Azure containers are restricted to non-root containers.\n        final String errMsg \u003d String.format(\n            \"Writes to \u0027%s\u0027 container for URI \u0027%s\u0027 are prohibited, \"\n                + \"only updates on non-root containers permitted.\",\n            AZURE_ROOT_CONTAINER, sessionUri.toString());\n        throw new AzureException(errMsg);\n      }\n\n      // Get the blob reference from the store\u0027s container and\n      // return it.\n      CloudBlobWrapper blob \u003d getBlobReference(key);\n      storePermissionStatus(blob, permissionStatus);\n\n      // Create the output stream for the Azure blob.\n      //\n      OutputStream outputStream \u003d openOutputStream(blob);\n      DataOutputStream dataOutStream \u003d new SyncableDataOutputStream(outputStream);\n      return dataOutStream;\n    } catch (Exception e) {\n      // Caught exception while attempting to open the blob output stream.\n      // Re-throw as an Azure storage exception.\n      throw new AzureException(e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9629. Support Windows Azure Storage - Blob as a file system in Hadoop. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601781 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/06/14 3:26 PM",
      "commitName": "81bc395deb3ba00567dc067d6ca71bacf9e3bc82",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,76 @@\n+  public DataOutputStream storefile(String key,\n+      PermissionStatus permissionStatus) throws AzureException {\n+    try {\n+\n+      // Check if a session exists, if not create a session with the\n+      // Azure storage server.\n+      if (null \u003d\u003d storageInteractionLayer) {\n+        final String errMsg \u003d String.format(\n+            \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n+            sessionUri);\n+        throw new AzureException(errMsg);\n+      }\n+\n+      // Check if there is an authenticated account associated with the\n+      // file this instance of the WASB file system. If not the file system\n+      // has not been authenticated and all access is anonymous.\n+      if (!isAuthenticatedAccess()) {\n+        // Preemptively raise an exception indicating no uploads are\n+        // allowed to anonymous accounts.\n+        throw new AzureException(new IOException(\n+            \"Uploads to public accounts using anonymous \"\n+                + \"access is prohibited.\"));\n+      }\n+\n+      checkContainer(ContainerAccessType.PureWrite);\n+\n+      /**\n+       * Note: Windows Azure Blob Storage does not allow the creation of\n+       * arbitrary directory paths under the default $root directory. This is by\n+       * design to eliminate ambiguity in specifying a implicit blob address. A\n+       * blob in the $root container cannot include a / in its name and must be\n+       * careful not to include a trailing \u0027/\u0027 when referencing blobs in the\n+       * $root container. A \u0027/; in the $root container permits ambiguous blob\n+       * names as in the following example involving two containers $root and\n+       * mycontainer: http://myaccount.blob.core.windows.net/$root\n+       * http://myaccount.blob.core.windows.net/mycontainer If the URL\n+       * \"mycontainer/somefile.txt were allowed in $root then the URL:\n+       * http://myaccount.blob.core.windows.net/mycontainer/myblob.txt could\n+       * mean either: (1) container\u003dmycontainer; blob\u003dmyblob.txt (2)\n+       * container\u003d$root; blob\u003dmycontainer/myblob.txt\n+       * \n+       * To avoid this type of ambiguity the Azure blob storage prevents\n+       * arbitrary path under $root. For a simple and more consistent user\n+       * experience it was decided to eliminate the opportunity for creating\n+       * such paths by making the $root container read-only under WASB. \n+       */\n+\n+      // Check that no attempt is made to write to blobs on default\n+      // $root containers.\n+      if (AZURE_ROOT_CONTAINER.equals(getContainerFromAuthority(sessionUri))) {\n+        // Azure containers are restricted to non-root containers.\n+        final String errMsg \u003d String.format(\n+            \"Writes to \u0027%s\u0027 container for URI \u0027%s\u0027 are prohibited, \"\n+                + \"only updates on non-root containers permitted.\",\n+            AZURE_ROOT_CONTAINER, sessionUri.toString());\n+        throw new AzureException(errMsg);\n+      }\n+\n+      // Get the block blob reference from the store\u0027s container and\n+      // return it.\n+      CloudBlockBlobWrapper blob \u003d getBlobReference(key);\n+      storePermissionStatus(blob, permissionStatus);\n+\n+      // Create the output stream for the Azure blob.\n+      OutputStream outputStream \u003d blob.openOutputStream(getUploadOptions(),\n+          getInstrumentedContext());\n+\n+      // Return to caller with DataOutput stream.\n+      DataOutputStream dataOutStream \u003d new DataOutputStream(outputStream);\n+      return dataOutStream;\n+    } catch (Exception e) {\n+      // Caught exception while attempting to open the blob output stream.\n+      // Re-throw as an Azure storage exception.\n+      throw new AzureException(e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public DataOutputStream storefile(String key,\n      PermissionStatus permissionStatus) throws AzureException {\n    try {\n\n      // Check if a session exists, if not create a session with the\n      // Azure storage server.\n      if (null \u003d\u003d storageInteractionLayer) {\n        final String errMsg \u003d String.format(\n            \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n            sessionUri);\n        throw new AzureException(errMsg);\n      }\n\n      // Check if there is an authenticated account associated with the\n      // file this instance of the WASB file system. If not the file system\n      // has not been authenticated and all access is anonymous.\n      if (!isAuthenticatedAccess()) {\n        // Preemptively raise an exception indicating no uploads are\n        // allowed to anonymous accounts.\n        throw new AzureException(new IOException(\n            \"Uploads to public accounts using anonymous \"\n                + \"access is prohibited.\"));\n      }\n\n      checkContainer(ContainerAccessType.PureWrite);\n\n      /**\n       * Note: Windows Azure Blob Storage does not allow the creation of\n       * arbitrary directory paths under the default $root directory. This is by\n       * design to eliminate ambiguity in specifying a implicit blob address. A\n       * blob in the $root container cannot include a / in its name and must be\n       * careful not to include a trailing \u0027/\u0027 when referencing blobs in the\n       * $root container. A \u0027/; in the $root container permits ambiguous blob\n       * names as in the following example involving two containers $root and\n       * mycontainer: http://myaccount.blob.core.windows.net/$root\n       * http://myaccount.blob.core.windows.net/mycontainer If the URL\n       * \"mycontainer/somefile.txt were allowed in $root then the URL:\n       * http://myaccount.blob.core.windows.net/mycontainer/myblob.txt could\n       * mean either: (1) container\u003dmycontainer; blob\u003dmyblob.txt (2)\n       * container\u003d$root; blob\u003dmycontainer/myblob.txt\n       * \n       * To avoid this type of ambiguity the Azure blob storage prevents\n       * arbitrary path under $root. For a simple and more consistent user\n       * experience it was decided to eliminate the opportunity for creating\n       * such paths by making the $root container read-only under WASB. \n       */\n\n      // Check that no attempt is made to write to blobs on default\n      // $root containers.\n      if (AZURE_ROOT_CONTAINER.equals(getContainerFromAuthority(sessionUri))) {\n        // Azure containers are restricted to non-root containers.\n        final String errMsg \u003d String.format(\n            \"Writes to \u0027%s\u0027 container for URI \u0027%s\u0027 are prohibited, \"\n                + \"only updates on non-root containers permitted.\",\n            AZURE_ROOT_CONTAINER, sessionUri.toString());\n        throw new AzureException(errMsg);\n      }\n\n      // Get the block blob reference from the store\u0027s container and\n      // return it.\n      CloudBlockBlobWrapper blob \u003d getBlobReference(key);\n      storePermissionStatus(blob, permissionStatus);\n\n      // Create the output stream for the Azure blob.\n      OutputStream outputStream \u003d blob.openOutputStream(getUploadOptions(),\n          getInstrumentedContext());\n\n      // Return to caller with DataOutput stream.\n      DataOutputStream dataOutStream \u003d new DataOutputStream(outputStream);\n      return dataOutStream;\n    } catch (Exception e) {\n      // Caught exception while attempting to open the blob output stream.\n      // Re-throw as an Azure storage exception.\n      throw new AzureException(e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java"
    }
  }
}