{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AFileSystem.java",
  "functionName": "innerListStatus",
  "functionId": "innerListStatus___f-Path",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
  "functionStartLine": 2551,
  "functionEndLine": 2595,
  "numCommitsSeen": 141,
  "timeTaken": 8054,
  "changeHistory": [
    "ea25f4de236611d388e14a710ebe5d6872c421b6",
    "511df1e837b19ccb9271520589452d82d50ac69d",
    "de6b7bc67ace7744adb0320ee7de79cf28259d2d",
    "34747c373f40a33d36a2e21ecb33fa791ccd939f",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "a36274d69947648dbe82721220cc5240ec5d396d",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
    "ef450df443f1dea1c52082cf281f25db7141972f",
    "5bbca80428ffbe776650652de86a3bba885edb31",
    "621b43e254afaff708cd6fc4698b29628f6abc33",
    "822d661b8fcc42bec6eea958d9fd02ef1aaa4b6c",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
    "39ec1515a205952eda7e171408a8b83eceb4abde"
  ],
  "changeHistoryShort": {
    "ea25f4de236611d388e14a710ebe5d6872c421b6": "Ybodychange",
    "511df1e837b19ccb9271520589452d82d50ac69d": "Ybodychange",
    "de6b7bc67ace7744adb0320ee7de79cf28259d2d": "Ybodychange",
    "34747c373f40a33d36a2e21ecb33fa791ccd939f": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ybodychange",
    "a36274d69947648dbe82721220cc5240ec5d396d": "Ybodychange",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": "Ybodychange",
    "ef450df443f1dea1c52082cf281f25db7141972f": "Ybodychange",
    "5bbca80428ffbe776650652de86a3bba885edb31": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Ybodychange",
    "822d661b8fcc42bec6eea958d9fd02ef1aaa4b6c": "Ybodychange",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": "Ybodychange",
    "39ec1515a205952eda7e171408a8b83eceb4abde": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ea25f4de236611d388e14a710ebe5d6872c421b6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16709. S3Guard: Make authoritative mode exclusive for metadata - don\u0027t check for expiry for authoritative paths (#1721). Contributed by Gabor Bota.\n\n",
      "commitDate": "26/11/19 7:36 AM",
      "commitName": "ea25f4de236611d388e14a710ebe5d6872c421b6",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "12/11/19 10:17 AM",
      "commitNameOld": "990063d2af0a37e9474949f33128805e34c3f016",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 13.89,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,45 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n     Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"List status for path: {}\", path);\n     entryPoint(INVOCATION_LIST_STATUS);\n \n     List\u003cS3AFileStatus\u003e result;\n     final FileStatus fileStatus \u003d  getFileStatus(path);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \u0027/\u0027;\n       }\n \n-      DirListingMetadata dirMeta \u003d\n-          S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n       boolean allowAuthoritative \u003d allowAuthoritative(f);\n+      DirListingMetadata dirMeta \u003d\n+          S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider,\n+              allowAuthoritative);\n       if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n         return S3Guard.dirMetaToStatuses(dirMeta);\n       }\n \n       S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n       Listing.FileStatusListingIterator files \u003d\n           listing.createFileStatusListingIterator(path,\n               request,\n               ACCEPT_ALL,\n               new Listing.AcceptAllButSelfAndS3nDirs(path));\n       result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n       while (files.hasNext()) {\n         result.add(files.next());\n       }\n       // merge the results. This will update the store as needed\n       return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n           allowAuthoritative, ttlTimeProvider);\n     } else {\n       LOG.debug(\"Adding: rd (not a dir): {}\", path);\n       FileStatus[] stats \u003d new FileStatus[1];\n       stats[0]\u003d fileStatus;\n       return stats;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"List status for path: {}\", path);\n    entryPoint(INVOCATION_LIST_STATUS);\n\n    List\u003cS3AFileStatus\u003e result;\n    final FileStatus fileStatus \u003d  getFileStatus(path);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \u0027/\u0027;\n      }\n\n      boolean allowAuthoritative \u003d allowAuthoritative(f);\n      DirListingMetadata dirMeta \u003d\n          S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider,\n              allowAuthoritative);\n      if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n        return S3Guard.dirMetaToStatuses(dirMeta);\n      }\n\n      S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      Listing.FileStatusListingIterator files \u003d\n          listing.createFileStatusListingIterator(path,\n              request,\n              ACCEPT_ALL,\n              new Listing.AcceptAllButSelfAndS3nDirs(path));\n      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n      while (files.hasNext()) {\n        result.add(files.next());\n      }\n      // merge the results. This will update the store as needed\n      return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n          allowAuthoritative, ttlTimeProvider);\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n      FileStatus[] stats \u003d new FileStatus[1];\n      stats[0]\u003d fileStatus;\n      return stats;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "511df1e837b19ccb9271520589452d82d50ac69d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16430. S3AFilesystem.delete to incrementally update s3guard with deletions\n\nContributed by Steve Loughran.\n\nThis overlaps the scanning for directory entries with batched calls to S3 DELETE and updates of the S3Guard tables.\nIt also uses S3Guard to list the files to delete, so find newly created files even when S3 listings are not use consistent.\n\nFor path which the client considers S3Guard to be authoritative, we also do a recursive LIST of the store and delete files; this is to find unindexed files and do guarantee that the delete(path, true) call really does delete everything underneath.\n\nChange-Id: Ice2f6e940c506e0b3a78fa534a99721b1698708e\n",
      "commitDate": "05/09/19 6:25 AM",
      "commitName": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "23/07/19 6:52 AM",
      "commitNameOld": "4317d332321778269a583e2223d433107fab82eb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 43.98,
      "commitsBetweenForRepo": 415,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,44 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n     Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"List status for path: {}\", path);\n     entryPoint(INVOCATION_LIST_STATUS);\n \n     List\u003cS3AFileStatus\u003e result;\n     final FileStatus fileStatus \u003d  getFileStatus(path);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \u0027/\u0027;\n       }\n \n       DirListingMetadata dirMeta \u003d\n           S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n-      boolean allowAuthoritative \u003d S3Guard.allowAuthoritative(f, this,\n-          allowAuthoritativeMetadataStore, allowAuthoritativePaths);\n+      boolean allowAuthoritative \u003d allowAuthoritative(f);\n       if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n         return S3Guard.dirMetaToStatuses(dirMeta);\n       }\n \n       S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n       Listing.FileStatusListingIterator files \u003d\n           listing.createFileStatusListingIterator(path,\n               request,\n               ACCEPT_ALL,\n               new Listing.AcceptAllButSelfAndS3nDirs(path));\n       result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n       while (files.hasNext()) {\n         result.add(files.next());\n       }\n       // merge the results. This will update the store as needed\n       return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n           allowAuthoritative, ttlTimeProvider);\n     } else {\n       LOG.debug(\"Adding: rd (not a dir): {}\", path);\n       FileStatus[] stats \u003d new FileStatus[1];\n       stats[0]\u003d fileStatus;\n       return stats;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"List status for path: {}\", path);\n    entryPoint(INVOCATION_LIST_STATUS);\n\n    List\u003cS3AFileStatus\u003e result;\n    final FileStatus fileStatus \u003d  getFileStatus(path);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \u0027/\u0027;\n      }\n\n      DirListingMetadata dirMeta \u003d\n          S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n      boolean allowAuthoritative \u003d allowAuthoritative(f);\n      if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n        return S3Guard.dirMetaToStatuses(dirMeta);\n      }\n\n      S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      Listing.FileStatusListingIterator files \u003d\n          listing.createFileStatusListingIterator(path,\n              request,\n              ACCEPT_ALL,\n              new Listing.AcceptAllButSelfAndS3nDirs(path));\n      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n      while (files.hasNext()) {\n        result.add(files.next());\n      }\n      // merge the results. This will update the store as needed\n      return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n          allowAuthoritative, ttlTimeProvider);\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n      FileStatus[] stats \u003d new FileStatus[1];\n      stats[0]\u003d fileStatus;\n      return stats;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "de6b7bc67ace7744adb0320ee7de79cf28259d2d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16409. Allow authoritative mode on non-qualified paths. Contributed by Sean Mackrory\n\n",
      "commitDate": "08/07/19 10:27 AM",
      "commitName": "de6b7bc67ace7744adb0320ee7de79cf28259d2d",
      "commitAuthor": "Sean Mackrory",
      "commitDateOld": "03/07/19 11:04 AM",
      "commitNameOld": "34747c373f40a33d36a2e21ecb33fa791ccd939f",
      "commitAuthorOld": "Sean Mackrory",
      "daysBetweenCommits": 4.97,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,45 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n     Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"List status for path: {}\", path);\n     entryPoint(INVOCATION_LIST_STATUS);\n \n     List\u003cS3AFileStatus\u003e result;\n     final FileStatus fileStatus \u003d  getFileStatus(path);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \u0027/\u0027;\n       }\n \n       DirListingMetadata dirMeta \u003d\n           S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n       boolean allowAuthoritative \u003d S3Guard.allowAuthoritative(f, this,\n           allowAuthoritativeMetadataStore, allowAuthoritativePaths);\n       if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n         return S3Guard.dirMetaToStatuses(dirMeta);\n       }\n \n       S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n       Listing.FileStatusListingIterator files \u003d\n           listing.createFileStatusListingIterator(path,\n               request,\n               ACCEPT_ALL,\n               new Listing.AcceptAllButSelfAndS3nDirs(path));\n       result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n       while (files.hasNext()) {\n         result.add(files.next());\n       }\n       // merge the results. This will update the store as needed\n-\n       return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n           allowAuthoritative, ttlTimeProvider);\n     } else {\n       LOG.debug(\"Adding: rd (not a dir): {}\", path);\n       FileStatus[] stats \u003d new FileStatus[1];\n       stats[0]\u003d fileStatus;\n       return stats;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"List status for path: {}\", path);\n    entryPoint(INVOCATION_LIST_STATUS);\n\n    List\u003cS3AFileStatus\u003e result;\n    final FileStatus fileStatus \u003d  getFileStatus(path);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \u0027/\u0027;\n      }\n\n      DirListingMetadata dirMeta \u003d\n          S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n      boolean allowAuthoritative \u003d S3Guard.allowAuthoritative(f, this,\n          allowAuthoritativeMetadataStore, allowAuthoritativePaths);\n      if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n        return S3Guard.dirMetaToStatuses(dirMeta);\n      }\n\n      S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      Listing.FileStatusListingIterator files \u003d\n          listing.createFileStatusListingIterator(path,\n              request,\n              ACCEPT_ALL,\n              new Listing.AcceptAllButSelfAndS3nDirs(path));\n      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n      while (files.hasNext()) {\n        result.add(files.next());\n      }\n      // merge the results. This will update the store as needed\n      return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n          allowAuthoritative, ttlTimeProvider);\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n      FileStatus[] stats \u003d new FileStatus[1];\n      stats[0]\u003d fileStatus;\n      return stats;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "34747c373f40a33d36a2e21ecb33fa791ccd939f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16396. Allow authoritative mode on a subdirectory. (#1043)\n\n",
      "commitDate": "03/07/19 11:04 AM",
      "commitName": "34747c373f40a33d36a2e21ecb33fa791ccd939f",
      "commitAuthor": "Sean Mackrory",
      "commitDateOld": "20/06/19 1:56 AM",
      "commitNameOld": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 13.38,
      "commitsBetweenForRepo": 143,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,46 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n     Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"List status for path: {}\", path);\n     entryPoint(INVOCATION_LIST_STATUS);\n \n     List\u003cS3AFileStatus\u003e result;\n     final FileStatus fileStatus \u003d  getFileStatus(path);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \u0027/\u0027;\n       }\n \n       DirListingMetadata dirMeta \u003d\n           S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n+      boolean allowAuthoritative \u003d S3Guard.allowAuthoritative(f, this,\n+          allowAuthoritativeMetadataStore, allowAuthoritativePaths);\n       if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n         return S3Guard.dirMetaToStatuses(dirMeta);\n       }\n \n       S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n       Listing.FileStatusListingIterator files \u003d\n           listing.createFileStatusListingIterator(path,\n               request,\n               ACCEPT_ALL,\n               new Listing.AcceptAllButSelfAndS3nDirs(path));\n       result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n       while (files.hasNext()) {\n         result.add(files.next());\n       }\n       // merge the results. This will update the store as needed\n+\n       return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n           allowAuthoritative, ttlTimeProvider);\n     } else {\n       LOG.debug(\"Adding: rd (not a dir): {}\", path);\n       FileStatus[] stats \u003d new FileStatus[1];\n       stats[0]\u003d fileStatus;\n       return stats;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"List status for path: {}\", path);\n    entryPoint(INVOCATION_LIST_STATUS);\n\n    List\u003cS3AFileStatus\u003e result;\n    final FileStatus fileStatus \u003d  getFileStatus(path);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \u0027/\u0027;\n      }\n\n      DirListingMetadata dirMeta \u003d\n          S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n      boolean allowAuthoritative \u003d S3Guard.allowAuthoritative(f, this,\n          allowAuthoritativeMetadataStore, allowAuthoritativePaths);\n      if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n        return S3Guard.dirMetaToStatuses(dirMeta);\n      }\n\n      S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      Listing.FileStatusListingIterator files \u003d\n          listing.createFileStatusListingIterator(path,\n              request,\n              ACCEPT_ALL,\n              new Listing.AcceptAllButSelfAndS3nDirs(path));\n      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n      while (files.hasNext()) {\n        result.add(files.next());\n      }\n      // merge the results. This will update the store as needed\n\n      return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n          allowAuthoritative, ttlTimeProvider);\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n      FileStatus[] stats \u003d new FileStatus[1];\n      stats[0]\u003d fileStatus;\n      return stats;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "16/06/19 9:05 AM",
      "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,43 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n     Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"List status for path: {}\", path);\n     entryPoint(INVOCATION_LIST_STATUS);\n \n     List\u003cS3AFileStatus\u003e result;\n     final FileStatus fileStatus \u003d  getFileStatus(path);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \u0027/\u0027;\n       }\n \n       DirListingMetadata dirMeta \u003d\n           S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n       if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n         return S3Guard.dirMetaToStatuses(dirMeta);\n       }\n \n       S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n       Listing.FileStatusListingIterator files \u003d\n           listing.createFileStatusListingIterator(path,\n               request,\n               ACCEPT_ALL,\n               new Listing.AcceptAllButSelfAndS3nDirs(path));\n       result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n       while (files.hasNext()) {\n         result.add(files.next());\n       }\n+      // merge the results. This will update the store as needed\n       return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n           allowAuthoritative, ttlTimeProvider);\n     } else {\n       LOG.debug(\"Adding: rd (not a dir): {}\", path);\n       FileStatus[] stats \u003d new FileStatus[1];\n       stats[0]\u003d fileStatus;\n       return stats;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"List status for path: {}\", path);\n    entryPoint(INVOCATION_LIST_STATUS);\n\n    List\u003cS3AFileStatus\u003e result;\n    final FileStatus fileStatus \u003d  getFileStatus(path);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \u0027/\u0027;\n      }\n\n      DirListingMetadata dirMeta \u003d\n          S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n      if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n        return S3Guard.dirMetaToStatuses(dirMeta);\n      }\n\n      S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      Listing.FileStatusListingIterator files \u003d\n          listing.createFileStatusListingIterator(path,\n              request,\n              ACCEPT_ALL,\n              new Listing.AcceptAllButSelfAndS3nDirs(path));\n      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n      while (files.hasNext()) {\n        result.add(files.next());\n      }\n      // merge the results. This will update the store as needed\n      return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n          allowAuthoritative, ttlTimeProvider);\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n      FileStatus[] stats \u003d new FileStatus[1];\n      stats[0]\u003d fileStatus;\n      return stats;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "a36274d69947648dbe82721220cc5240ec5d396d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
      "commitDate": "19/05/19 2:29 PM",
      "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthor": "Ben Roling",
      "commitDateOld": "30/04/19 3:53 AM",
      "commitNameOld": "0af4011580878566213016af0c32633eabd15100",
      "commitAuthorOld": "Ben Roling",
      "daysBetweenCommits": 19.44,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n     Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"List status for path: {}\", path);\n     entryPoint(INVOCATION_LIST_STATUS);\n \n-    List\u003cFileStatus\u003e result;\n+    List\u003cS3AFileStatus\u003e result;\n     final FileStatus fileStatus \u003d  getFileStatus(path);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \u0027/\u0027;\n       }\n \n       DirListingMetadata dirMeta \u003d\n           S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n       if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n         return S3Guard.dirMetaToStatuses(dirMeta);\n       }\n \n       S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n       Listing.FileStatusListingIterator files \u003d\n           listing.createFileStatusListingIterator(path,\n               request,\n               ACCEPT_ALL,\n               new Listing.AcceptAllButSelfAndS3nDirs(path));\n       result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n       while (files.hasNext()) {\n         result.add(files.next());\n       }\n       return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n           allowAuthoritative, ttlTimeProvider);\n     } else {\n       LOG.debug(\"Adding: rd (not a dir): {}\", path);\n       FileStatus[] stats \u003d new FileStatus[1];\n       stats[0]\u003d fileStatus;\n       return stats;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"List status for path: {}\", path);\n    entryPoint(INVOCATION_LIST_STATUS);\n\n    List\u003cS3AFileStatus\u003e result;\n    final FileStatus fileStatus \u003d  getFileStatus(path);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \u0027/\u0027;\n      }\n\n      DirListingMetadata dirMeta \u003d\n          S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n      if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n        return S3Guard.dirMetaToStatuses(dirMeta);\n      }\n\n      S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      Listing.FileStatusListingIterator files \u003d\n          listing.createFileStatusListingIterator(path,\n              request,\n              ACCEPT_ALL,\n              new Listing.AcceptAllButSelfAndS3nDirs(path));\n      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n      while (files.hasNext()) {\n        result.add(files.next());\n      }\n      return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n          allowAuthoritative, ttlTimeProvider);\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n      FileStatus[] stats \u003d new FileStatus[1];\n      stats[0]\u003d fileStatus;\n      return stats;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15621 S3Guard: Implement time-based (TTL) expiry for Authoritative Directory Listing. Contributed by Gabor Bota\n",
      "commitDate": "02/10/18 9:22 PM",
      "commitName": "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "12/09/18 9:04 PM",
      "commitNameOld": "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 20.01,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,42 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n     Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"List status for path: {}\", path);\n     entryPoint(INVOCATION_LIST_STATUS);\n \n     List\u003cFileStatus\u003e result;\n     final FileStatus fileStatus \u003d  getFileStatus(path);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \u0027/\u0027;\n       }\n \n-      DirListingMetadata dirMeta \u003d metadataStore.listChildren(path);\n+      DirListingMetadata dirMeta \u003d\n+          S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n       if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n         return S3Guard.dirMetaToStatuses(dirMeta);\n       }\n \n       S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n       Listing.FileStatusListingIterator files \u003d\n           listing.createFileStatusListingIterator(path,\n               request,\n               ACCEPT_ALL,\n               new Listing.AcceptAllButSelfAndS3nDirs(path));\n       result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n       while (files.hasNext()) {\n         result.add(files.next());\n       }\n       return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n-          allowAuthoritative);\n+          allowAuthoritative, ttlTimeProvider);\n     } else {\n       LOG.debug(\"Adding: rd (not a dir): {}\", path);\n       FileStatus[] stats \u003d new FileStatus[1];\n       stats[0]\u003d fileStatus;\n       return stats;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"List status for path: {}\", path);\n    entryPoint(INVOCATION_LIST_STATUS);\n\n    List\u003cFileStatus\u003e result;\n    final FileStatus fileStatus \u003d  getFileStatus(path);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \u0027/\u0027;\n      }\n\n      DirListingMetadata dirMeta \u003d\n          S3Guard.listChildrenWithTtl(metadataStore, path, ttlTimeProvider);\n      if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n        return S3Guard.dirMetaToStatuses(dirMeta);\n      }\n\n      S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      Listing.FileStatusListingIterator files \u003d\n          listing.createFileStatusListingIterator(path,\n              request,\n              ACCEPT_ALL,\n              new Listing.AcceptAllButSelfAndS3nDirs(path));\n      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n      while (files.hasNext()) {\n        result.add(files.next());\n      }\n      return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n          allowAuthoritative, ttlTimeProvider);\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n      FileStatus[] stats \u003d new FileStatus[1];\n      stats[0]\u003d fileStatus;\n      return stats;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "ef450df443f1dea1c52082cf281f25db7141972f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15113. NPE in S3A getFileStatus: null instrumentation on using closed instance.\nContributed by Steve Loughran.\n",
      "commitDate": "21/12/17 6:15 AM",
      "commitName": "ef450df443f1dea1c52082cf281f25db7141972f",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/12/17 1:19 PM",
      "commitNameOld": "35ad9b1dd279b769381ea1625d9bf776c309c5cb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 2.71,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n     Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"List status for path: {}\", path);\n-    incrementStatistic(INVOCATION_LIST_STATUS);\n+    entryPoint(INVOCATION_LIST_STATUS);\n \n     List\u003cFileStatus\u003e result;\n     final FileStatus fileStatus \u003d  getFileStatus(path);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \u0027/\u0027;\n       }\n \n       DirListingMetadata dirMeta \u003d metadataStore.listChildren(path);\n       if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n         return S3Guard.dirMetaToStatuses(dirMeta);\n       }\n \n       S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n       Listing.FileStatusListingIterator files \u003d\n           listing.createFileStatusListingIterator(path,\n               request,\n               ACCEPT_ALL,\n               new Listing.AcceptAllButSelfAndS3nDirs(path));\n       result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n       while (files.hasNext()) {\n         result.add(files.next());\n       }\n       return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n           allowAuthoritative);\n     } else {\n       LOG.debug(\"Adding: rd (not a dir): {}\", path);\n       FileStatus[] stats \u003d new FileStatus[1];\n       stats[0]\u003d fileStatus;\n       return stats;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"List status for path: {}\", path);\n    entryPoint(INVOCATION_LIST_STATUS);\n\n    List\u003cFileStatus\u003e result;\n    final FileStatus fileStatus \u003d  getFileStatus(path);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \u0027/\u0027;\n      }\n\n      DirListingMetadata dirMeta \u003d metadataStore.listChildren(path);\n      if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n        return S3Guard.dirMetaToStatuses(dirMeta);\n      }\n\n      S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      Listing.FileStatusListingIterator files \u003d\n          listing.createFileStatusListingIterator(path,\n              request,\n              ACCEPT_ALL,\n              new Listing.AcceptAllButSelfAndS3nDirs(path));\n      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n      while (files.hasNext()) {\n        result.add(files.next());\n      }\n      return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n          allowAuthoritative);\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n      FileStatus[] stats \u003d new FileStatus[1];\n      stats[0]\u003d fileStatus;\n      return stats;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "5bbca80428ffbe776650652de86a3bba885edb31": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13421. Switch to v2 of the S3 List Objects API in S3A.\nContributed by Aaron Fabbri\n",
      "commitDate": "08/09/17 4:07 AM",
      "commitName": "5bbca80428ffbe776650652de86a3bba885edb31",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "01/09/17 6:13 AM",
      "commitNameOld": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 6.91,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n     Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"List status for path: {}\", path);\n     incrementStatistic(INVOCATION_LIST_STATUS);\n \n     List\u003cFileStatus\u003e result;\n     final FileStatus fileStatus \u003d  getFileStatus(path);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \u0027/\u0027;\n       }\n \n       DirListingMetadata dirMeta \u003d metadataStore.listChildren(path);\n       if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n         return S3Guard.dirMetaToStatuses(dirMeta);\n       }\n \n-      ListObjectsRequest request \u003d createListObjectsRequest(key, \"/\");\n+      S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n       Listing.FileStatusListingIterator files \u003d\n           listing.createFileStatusListingIterator(path,\n               request,\n               ACCEPT_ALL,\n               new Listing.AcceptAllButSelfAndS3nDirs(path));\n       result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n       while (files.hasNext()) {\n         result.add(files.next());\n       }\n       return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n           allowAuthoritative);\n     } else {\n       LOG.debug(\"Adding: rd (not a dir): {}\", path);\n       FileStatus[] stats \u003d new FileStatus[1];\n       stats[0]\u003d fileStatus;\n       return stats;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"List status for path: {}\", path);\n    incrementStatistic(INVOCATION_LIST_STATUS);\n\n    List\u003cFileStatus\u003e result;\n    final FileStatus fileStatus \u003d  getFileStatus(path);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \u0027/\u0027;\n      }\n\n      DirListingMetadata dirMeta \u003d metadataStore.listChildren(path);\n      if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n        return S3Guard.dirMetaToStatuses(dirMeta);\n      }\n\n      S3ListRequest request \u003d createListObjectsRequest(key, \"/\");\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      Listing.FileStatusListingIterator files \u003d\n          listing.createFileStatusListingIterator(path,\n              request,\n              ACCEPT_ALL,\n              new Listing.AcceptAllButSelfAndS3nDirs(path));\n      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n      while (files.hasNext()) {\n        result.add(files.next());\n      }\n      return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n          allowAuthoritative);\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n      FileStatus[] stats \u003d new FileStatus[1];\n      stats[0]\u003d fileStatus;\n      return stats;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/06/17 11:26 AM",
      "commitNameOld": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 87.78,
      "commitsBetweenForRepo": 591,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,41 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n     Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     LOG.debug(\"List status for path: {}\", path);\n     incrementStatistic(INVOCATION_LIST_STATUS);\n \n     List\u003cFileStatus\u003e result;\n     final FileStatus fileStatus \u003d  getFileStatus(path);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \u0027/\u0027;\n       }\n \n+      DirListingMetadata dirMeta \u003d metadataStore.listChildren(path);\n+      if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n+        return S3Guard.dirMetaToStatuses(dirMeta);\n+      }\n+\n       ListObjectsRequest request \u003d createListObjectsRequest(key, \"/\");\n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n       Listing.FileStatusListingIterator files \u003d\n           listing.createFileStatusListingIterator(path,\n               request,\n               ACCEPT_ALL,\n               new Listing.AcceptAllButSelfAndS3nDirs(path));\n       result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n       while (files.hasNext()) {\n         result.add(files.next());\n       }\n-      return result.toArray(new FileStatus[result.size()]);\n+      return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n+          allowAuthoritative);\n     } else {\n       LOG.debug(\"Adding: rd (not a dir): {}\", path);\n       FileStatus[] stats \u003d new FileStatus[1];\n       stats[0]\u003d fileStatus;\n       return stats;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"List status for path: {}\", path);\n    incrementStatistic(INVOCATION_LIST_STATUS);\n\n    List\u003cFileStatus\u003e result;\n    final FileStatus fileStatus \u003d  getFileStatus(path);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \u0027/\u0027;\n      }\n\n      DirListingMetadata dirMeta \u003d metadataStore.listChildren(path);\n      if (allowAuthoritative \u0026\u0026 dirMeta !\u003d null \u0026\u0026 dirMeta.isAuthoritative()) {\n        return S3Guard.dirMetaToStatuses(dirMeta);\n      }\n\n      ListObjectsRequest request \u003d createListObjectsRequest(key, \"/\");\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      Listing.FileStatusListingIterator files \u003d\n          listing.createFileStatusListingIterator(path,\n              request,\n              ACCEPT_ALL,\n              new Listing.AcceptAllButSelfAndS3nDirs(path));\n      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n      while (files.hasNext()) {\n        result.add(files.next());\n      }\n      return S3Guard.dirListingUnion(metadataStore, path, result, dirMeta,\n          allowAuthoritative);\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n      FileStatus[] stats \u003d new FileStatus[1];\n      stats[0]\u003d fileStatus;\n      return stats;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "822d661b8fcc42bec6eea958d9fd02ef1aaa4b6c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13208. S3A listFiles(recursive\u003dtrue) to do a bulk listObjects instead of walking the pseudo-tree of directories. Contributed by Steve Loughran.\n",
      "commitDate": "17/08/16 2:54 PM",
      "commitName": "822d661b8fcc42bec6eea958d9fd02ef1aaa4b6c",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "25/07/16 7:50 AM",
      "commitNameOld": "86ae218893d018638e937c2528c8e84336254da7",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 23.29,
      "commitsBetweenForRepo": 177,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,35 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n-    String key \u003d pathToKey(f);\n-    LOG.debug(\"List status for path: {}\", f);\n+    Path path \u003d qualify(f);\n+    String key \u003d pathToKey(path);\n+    LOG.debug(\"List status for path: {}\", path);\n     incrementStatistic(INVOCATION_LIST_STATUS);\n \n-    final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n-    final FileStatus fileStatus \u003d  getFileStatus(f);\n+    List\u003cFileStatus\u003e result;\n+    final FileStatus fileStatus \u003d  getFileStatus(path);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n-        key \u003d key + \"/\";\n+        key \u003d key + \u0027/\u0027;\n       }\n \n-      ListObjectsRequest request \u003d new ListObjectsRequest();\n-      request.setBucketName(bucket);\n-      request.setPrefix(key);\n-      request.setDelimiter(\"/\");\n-      request.setMaxKeys(maxKeys);\n-\n+      ListObjectsRequest request \u003d createListObjectsRequest(key, \"/\");\n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n-      ObjectListing objects \u003d listObjects(request);\n-\n-      Path fQualified \u003d f.makeQualified(uri, workingDir);\n-\n-      while (true) {\n-        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n-          Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n-          // Skip over keys that are ourselves and old S3N _$folder$ files\n-          if (keyPath.equals(fQualified) ||\n-              summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n-            LOG.debug(\"Ignoring: {}\", keyPath);\n-          } else {\n-            S3AFileStatus status \u003d createFileStatus(keyPath, summary,\n-                getDefaultBlockSize(keyPath));\n-            result.add(status);\n-            LOG.debug(\"Adding: {}\", status);\n-          }\n-        }\n-\n-        for (String prefix : objects.getCommonPrefixes()) {\n-          Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n-          if (!keyPath.equals(f)) {\n-            result.add(new S3AFileStatus(true, false, keyPath));\n-            LOG.debug(\"Adding: rd: {}\", keyPath);\n-          }\n-        }\n-\n-        if (objects.isTruncated()) {\n-          LOG.debug(\"listStatus: list truncated - getting next batch\");\n-          objects \u003d continueListObjects(objects);\n-        } else {\n-          break;\n-        }\n+      Listing.FileStatusListingIterator files \u003d\n+          listing.createFileStatusListingIterator(path,\n+              request,\n+              ACCEPT_ALL,\n+              new Listing.AcceptAllButSelfAndS3nDirs(path));\n+      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n+      while (files.hasNext()) {\n+        result.add(files.next());\n       }\n+      return result.toArray(new FileStatus[result.size()]);\n     } else {\n-      LOG.debug(\"Adding: rd (not a dir): {}\", f);\n-      result.add(fileStatus);\n+      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n+      FileStatus[] stats \u003d new FileStatus[1];\n+      stats[0]\u003d fileStatus;\n+      return stats;\n     }\n-\n-    return result.toArray(new FileStatus[result.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    LOG.debug(\"List status for path: {}\", path);\n    incrementStatistic(INVOCATION_LIST_STATUS);\n\n    List\u003cFileStatus\u003e result;\n    final FileStatus fileStatus \u003d  getFileStatus(path);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \u0027/\u0027;\n      }\n\n      ListObjectsRequest request \u003d createListObjectsRequest(key, \"/\");\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      Listing.FileStatusListingIterator files \u003d\n          listing.createFileStatusListingIterator(path,\n              request,\n              ACCEPT_ALL,\n              new Listing.AcceptAllButSelfAndS3nDirs(path));\n      result \u003d new ArrayList\u003c\u003e(files.getBatchSize());\n      while (files.hasNext()) {\n        result.add(files.next());\n      }\n      return result.toArray(new FileStatus[result.size()]);\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", path);\n      FileStatus[] stats \u003d new FileStatus[1];\n      stats[0]\u003d fileStatus;\n      return stats;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13171. Add StorageStatistics to S3A; instrument some more operations. Contributed by Steve Loughran.\n",
      "commitDate": "03/06/16 8:55 AM",
      "commitName": "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "01/06/16 2:49 PM",
      "commitNameOld": "16b1cc7af9bd63b65ef50e1056f275a7baf111a2",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 1.75,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,63 @@\n   public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n       IOException, AmazonClientException {\n     String key \u003d pathToKey(f);\n     LOG.debug(\"List status for path: {}\", f);\n+    incrementStatistic(INVOCATION_LIST_STATUS);\n \n     final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n     final FileStatus fileStatus \u003d  getFileStatus(f);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \"/\";\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(maxKeys);\n \n       LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n-      ObjectListing objects \u003d s3.listObjects(request);\n-      statistics.incrementReadOps(1);\n+      ObjectListing objects \u003d listObjects(request);\n \n       Path fQualified \u003d f.makeQualified(uri, workingDir);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n           // Skip over keys that are ourselves and old S3N _$folder$ files\n           if (keyPath.equals(fQualified) ||\n               summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n             LOG.debug(\"Ignoring: {}\", keyPath);\n-            continue;\n-          }\n-\n-          if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n-            result.add(new S3AFileStatus(true, true, keyPath));\n-            LOG.debug(\"Adding: fd: {}\", keyPath);\n           } else {\n-            result.add(new S3AFileStatus(summary.getSize(),\n-                dateToLong(summary.getLastModified()), keyPath,\n-                getDefaultBlockSize(fQualified)));\n-            LOG.debug(\"Adding: fi: {}\", keyPath);\n+            S3AFileStatus status \u003d createFileStatus(keyPath, summary,\n+                getDefaultBlockSize(keyPath));\n+            result.add(status);\n+            LOG.debug(\"Adding: {}\", status);\n           }\n         }\n \n         for (String prefix : objects.getCommonPrefixes()) {\n           Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n-          if (keyPath.equals(f)) {\n-            continue;\n+          if (!keyPath.equals(f)) {\n+            result.add(new S3AFileStatus(true, false, keyPath));\n+            LOG.debug(\"Adding: rd: {}\", keyPath);\n           }\n-          result.add(new S3AFileStatus(true, false, keyPath));\n-          LOG.debug(\"Adding: rd: {}\", keyPath);\n         }\n \n         if (objects.isTruncated()) {\n           LOG.debug(\"listStatus: list truncated - getting next batch\");\n-          objects \u003d s3.listNextBatchOfObjects(objects);\n-          statistics.incrementReadOps(1);\n+          objects \u003d continueListObjects(objects);\n         } else {\n           break;\n         }\n       }\n     } else {\n       LOG.debug(\"Adding: rd (not a dir): {}\", f);\n       result.add(fileStatus);\n     }\n \n     return result.toArray(new FileStatus[result.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    String key \u003d pathToKey(f);\n    LOG.debug(\"List status for path: {}\", f);\n    incrementStatistic(INVOCATION_LIST_STATUS);\n\n    final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n    final FileStatus fileStatus \u003d  getFileStatus(f);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \"/\";\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(maxKeys);\n\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      ObjectListing objects \u003d listObjects(request);\n\n      Path fQualified \u003d f.makeQualified(uri, workingDir);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n          // Skip over keys that are ourselves and old S3N _$folder$ files\n          if (keyPath.equals(fQualified) ||\n              summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n            LOG.debug(\"Ignoring: {}\", keyPath);\n          } else {\n            S3AFileStatus status \u003d createFileStatus(keyPath, summary,\n                getDefaultBlockSize(keyPath));\n            result.add(status);\n            LOG.debug(\"Adding: {}\", status);\n          }\n        }\n\n        for (String prefix : objects.getCommonPrefixes()) {\n          Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n          if (!keyPath.equals(f)) {\n            result.add(new S3AFileStatus(true, false, keyPath));\n            LOG.debug(\"Adding: rd: {}\", keyPath);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          LOG.debug(\"listStatus: list truncated - getting next batch\");\n          objects \u003d continueListObjects(objects);\n        } else {\n          break;\n        }\n      }\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", f);\n      result.add(fileStatus);\n    }\n\n    return result.toArray(new FileStatus[result.size()]);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "39ec1515a205952eda7e171408a8b83eceb4abde": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
      "commitDate": "21/05/16 8:39 AM",
      "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,71 @@\n+  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n+      IOException, AmazonClientException {\n+    String key \u003d pathToKey(f);\n+    LOG.debug(\"List status for path: {}\", f);\n+\n+    final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n+    final FileStatus fileStatus \u003d  getFileStatus(f);\n+\n+    if (fileStatus.isDirectory()) {\n+      if (!key.isEmpty()) {\n+        key \u003d key + \"/\";\n+      }\n+\n+      ListObjectsRequest request \u003d new ListObjectsRequest();\n+      request.setBucketName(bucket);\n+      request.setPrefix(key);\n+      request.setDelimiter(\"/\");\n+      request.setMaxKeys(maxKeys);\n+\n+      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n+\n+      ObjectListing objects \u003d s3.listObjects(request);\n+      statistics.incrementReadOps(1);\n+\n+      Path fQualified \u003d f.makeQualified(uri, workingDir);\n+\n+      while (true) {\n+        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n+          Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n+          // Skip over keys that are ourselves and old S3N _$folder$ files\n+          if (keyPath.equals(fQualified) ||\n+              summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n+            LOG.debug(\"Ignoring: {}\", keyPath);\n+            continue;\n+          }\n+\n+          if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n+            result.add(new S3AFileStatus(true, true, keyPath));\n+            LOG.debug(\"Adding: fd: {}\", keyPath);\n+          } else {\n+            result.add(new S3AFileStatus(summary.getSize(),\n+                dateToLong(summary.getLastModified()), keyPath,\n+                getDefaultBlockSize(fQualified)));\n+            LOG.debug(\"Adding: fi: {}\", keyPath);\n+          }\n+        }\n+\n+        for (String prefix : objects.getCommonPrefixes()) {\n+          Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n+          if (keyPath.equals(f)) {\n+            continue;\n+          }\n+          result.add(new S3AFileStatus(true, false, keyPath));\n+          LOG.debug(\"Adding: rd: {}\", keyPath);\n+        }\n+\n+        if (objects.isTruncated()) {\n+          LOG.debug(\"listStatus: list truncated - getting next batch\");\n+          objects \u003d s3.listNextBatchOfObjects(objects);\n+          statistics.incrementReadOps(1);\n+        } else {\n+          break;\n+        }\n+      }\n+    } else {\n+      LOG.debug(\"Adding: rd (not a dir): {}\", f);\n+      result.add(fileStatus);\n+    }\n+\n+    return result.toArray(new FileStatus[result.size()]);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] innerListStatus(Path f) throws FileNotFoundException,\n      IOException, AmazonClientException {\n    String key \u003d pathToKey(f);\n    LOG.debug(\"List status for path: {}\", f);\n\n    final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n    final FileStatus fileStatus \u003d  getFileStatus(f);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \"/\";\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(maxKeys);\n\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      Path fQualified \u003d f.makeQualified(uri, workingDir);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n          // Skip over keys that are ourselves and old S3N _$folder$ files\n          if (keyPath.equals(fQualified) ||\n              summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n            LOG.debug(\"Ignoring: {}\", keyPath);\n            continue;\n          }\n\n          if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n            result.add(new S3AFileStatus(true, true, keyPath));\n            LOG.debug(\"Adding: fd: {}\", keyPath);\n          } else {\n            result.add(new S3AFileStatus(summary.getSize(),\n                dateToLong(summary.getLastModified()), keyPath,\n                getDefaultBlockSize(fQualified)));\n            LOG.debug(\"Adding: fi: {}\", keyPath);\n          }\n        }\n\n        for (String prefix : objects.getCommonPrefixes()) {\n          Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n          if (keyPath.equals(f)) {\n            continue;\n          }\n          result.add(new S3AFileStatus(true, false, keyPath));\n          LOG.debug(\"Adding: rd: {}\", keyPath);\n        }\n\n        if (objects.isTruncated()) {\n          LOG.debug(\"listStatus: list truncated - getting next batch\");\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          break;\n        }\n      }\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", f);\n      result.add(fileStatus);\n    }\n\n    return result.toArray(new FileStatus[result.size()]);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java"
    }
  }
}