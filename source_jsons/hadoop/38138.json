{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PreemptableResourceCalculator.java",
  "functionName": "computeIdealResourceDistribution",
  "functionId": "computeIdealResourceDistribution___rc-ResourceCalculator__queues-List__TempQueuePerPartition____totalPreemptionAllowed-Resource__tot_guarant-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/PreemptableResourceCalculator.java",
  "functionStartLine": 74,
  "functionEndLine": 137,
  "numCommitsSeen": 48,
  "timeTaken": 5690,
  "changeHistory": [
    "8d5509c68156faaa6641f4e747fc9ff80adccf88",
    "514794e1a5a39ca61de3981d53a05547ae17f5e4",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
    "60e4116bf1d00afed91010e57357fe54057e4e39",
    "ae14e5d07f1b6702a5160637438028bb03d9387e",
    "fa7a43529d529f0006c8033c2003f15b9b93f103",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
    "45b42676f9333ed4fa05355ccb4e1f91a9556525",
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61"
  ],
  "changeHistoryShort": {
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": "Ybodychange",
    "514794e1a5a39ca61de3981d53a05547ae17f5e4": "Ymodifierchange",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Ybodychange",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": "Ybodychange",
    "60e4116bf1d00afed91010e57357fe54057e4e39": "Ymultichange(Ymovefromfile,Ybodychange)",
    "ae14e5d07f1b6702a5160637438028bb03d9387e": "Ybodychange",
    "fa7a43529d529f0006c8033c2003f15b9b93f103": "Ybodychange",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": "Ybodychange",
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51": "Ymultichange(Yparameterchange,Ybodychange)",
    "45b42676f9333ed4fa05355ccb4e1f91a9556525": "Ybodychange",
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8292: Fix the dominant resource preemption cannot happen when some of the resource vector becomes negative. Contributed by Wangda Tan.\n",
      "commitDate": "25/05/18 9:06 AM",
      "commitName": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
      "commitAuthor": "Eric E Payne",
      "commitDateOld": "21/05/18 1:14 PM",
      "commitNameOld": "0b4c44bdeef62945b592d5761666ad026b629c0b",
      "commitAuthorOld": "Eric E Payne",
      "daysBetweenCommits": 3.83,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   protected void computeIdealResourceDistribution(ResourceCalculator rc,\n       List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n       Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n     List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n     // group queues based on whether they have non-zero guaranteed capacity\n     Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n \n     for (TempQueuePerPartition q : qAlloc) {\n       if (Resources.greaterThan(rc, tot_guarant,\n           q.getGuaranteed(), Resources.none())) {\n         nonZeroGuarQueues.add(q);\n       } else {\n         zeroGuarQueues.add(q);\n       }\n     }\n \n     // first compute the allocation as a fixpoint based on guaranteed capacity\n-    computeFixpointAllocation(tot_guarant, nonZeroGuarQueues, unassigned,\n-        false);\n+    computeFixpointAllocation(tot_guarant, new HashSet\u003c\u003e(nonZeroGuarQueues),\n+        unassigned, false);\n \n     // if any capacity is left unassigned, distributed among zero-guarantee\n     // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n     if (!zeroGuarQueues.isEmpty()\n         \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n       computeFixpointAllocation(tot_guarant, zeroGuarQueues, unassigned,\n           true);\n     }\n \n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n     for (TempQueuePerPartition t:queues) {\n       if (Resources.greaterThan(rc, tot_guarant,\n           t.getUsed(), t.idealAssigned)) {\n         Resources.addTo(totPreemptionNeeded, Resources\n             .subtract(t.getUsed(), t.idealAssigned));\n       }\n     }\n \n     /**\n      * if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n      * that is used to scale down how much we ask back from each queue\n      */\n     float scalingFactor \u003d 1.0F;\n     if (Resources.greaterThan(rc,\n         tot_guarant, totPreemptionNeeded, totalPreemptionAllowed)) {\n       scalingFactor \u003d Resources.divide(rc, tot_guarant, totalPreemptionAllowed,\n           totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n     for (TempQueuePerPartition t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n      Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n\n    for (TempQueuePerPartition q : qAlloc) {\n      if (Resources.greaterThan(rc, tot_guarant,\n          q.getGuaranteed(), Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(tot_guarant, new HashSet\u003c\u003e(nonZeroGuarQueues),\n        unassigned, false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee\n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n\n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueuePerPartition t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant,\n          t.getUsed(), t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded, Resources\n            .subtract(t.getUsed(), t.idealAssigned));\n      }\n    }\n\n    /**\n     * if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     * that is used to scale down how much we ask back from each queue\n     */\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc,\n        tot_guarant, totPreemptionNeeded, totalPreemptionAllowed)) {\n      scalingFactor \u003d Resources.divide(rc, tot_guarant, totalPreemptionAllowed,\n          totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueuePerPartition t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/PreemptableResourceCalculator.java",
      "extendedDetails": {}
    },
    "514794e1a5a39ca61de3981d53a05547ae17f5e4": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-7934. [GQ] Refactor preemption calculators to allow overriding for Federation Global Algos. (Contributed by curino)\n",
      "commitDate": "22/02/18 6:12 PM",
      "commitName": "514794e1a5a39ca61de3981d53a05547ae17f5e4",
      "commitAuthor": "Carlo Curino",
      "commitDateOld": "31/10/16 3:18 PM",
      "commitNameOld": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 479.16,
      "commitsBetweenForRepo": 3052,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n-  private void computeIdealResourceDistribution(ResourceCalculator rc,\n+  protected void computeIdealResourceDistribution(ResourceCalculator rc,\n       List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n       Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n     List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n     // group queues based on whether they have non-zero guaranteed capacity\n     Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n \n     for (TempQueuePerPartition q : qAlloc) {\n       if (Resources.greaterThan(rc, tot_guarant,\n           q.getGuaranteed(), Resources.none())) {\n         nonZeroGuarQueues.add(q);\n       } else {\n         zeroGuarQueues.add(q);\n       }\n     }\n \n     // first compute the allocation as a fixpoint based on guaranteed capacity\n     computeFixpointAllocation(tot_guarant, nonZeroGuarQueues, unassigned,\n         false);\n \n     // if any capacity is left unassigned, distributed among zero-guarantee\n     // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n     if (!zeroGuarQueues.isEmpty()\n         \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n       computeFixpointAllocation(tot_guarant, zeroGuarQueues, unassigned,\n           true);\n     }\n \n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n     for (TempQueuePerPartition t:queues) {\n       if (Resources.greaterThan(rc, tot_guarant,\n           t.getUsed(), t.idealAssigned)) {\n         Resources.addTo(totPreemptionNeeded, Resources\n             .subtract(t.getUsed(), t.idealAssigned));\n       }\n     }\n \n     /**\n      * if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n      * that is used to scale down how much we ask back from each queue\n      */\n     float scalingFactor \u003d 1.0F;\n     if (Resources.greaterThan(rc,\n         tot_guarant, totPreemptionNeeded, totalPreemptionAllowed)) {\n       scalingFactor \u003d Resources.divide(rc, tot_guarant, totalPreemptionAllowed,\n           totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n     for (TempQueuePerPartition t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n      Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n\n    for (TempQueuePerPartition q : qAlloc) {\n      if (Resources.greaterThan(rc, tot_guarant,\n          q.getGuaranteed(), Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(tot_guarant, nonZeroGuarQueues, unassigned,\n        false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee\n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n\n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueuePerPartition t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant,\n          t.getUsed(), t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded, Resources\n            .subtract(t.getUsed(), t.idealAssigned));\n      }\n    }\n\n    /**\n     * if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     * that is used to scale down how much we ask back from each queue\n     */\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc,\n        tot_guarant, totPreemptionNeeded, totalPreemptionAllowed)) {\n      scalingFactor \u003d Resources.divide(rc, tot_guarant, totalPreemptionAllowed,\n          totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueuePerPartition t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/PreemptableResourceCalculator.java",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[protected]"
      }
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "05/05/16 12:56 PM",
      "commitNameOld": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 179.1,
      "commitsBetweenForRepo": 1369,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private void computeIdealResourceDistribution(ResourceCalculator rc,\n       List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n       Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n     List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n     // group queues based on whether they have non-zero guaranteed capacity\n     Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n \n     for (TempQueuePerPartition q : qAlloc) {\n       if (Resources.greaterThan(rc, tot_guarant,\n           q.getGuaranteed(), Resources.none())) {\n         nonZeroGuarQueues.add(q);\n       } else {\n         zeroGuarQueues.add(q);\n       }\n     }\n \n     // first compute the allocation as a fixpoint based on guaranteed capacity\n-    computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n+    computeFixpointAllocation(tot_guarant, nonZeroGuarQueues, unassigned,\n         false);\n \n     // if any capacity is left unassigned, distributed among zero-guarantee\n     // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n     if (!zeroGuarQueues.isEmpty()\n         \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n-      computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n+      computeFixpointAllocation(tot_guarant, zeroGuarQueues, unassigned,\n           true);\n     }\n \n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n     for (TempQueuePerPartition t:queues) {\n       if (Resources.greaterThan(rc, tot_guarant,\n           t.getUsed(), t.idealAssigned)) {\n         Resources.addTo(totPreemptionNeeded, Resources\n             .subtract(t.getUsed(), t.idealAssigned));\n       }\n     }\n \n     /**\n      * if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n      * that is used to scale down how much we ask back from each queue\n      */\n     float scalingFactor \u003d 1.0F;\n     if (Resources.greaterThan(rc,\n         tot_guarant, totPreemptionNeeded, totalPreemptionAllowed)) {\n       scalingFactor \u003d Resources.divide(rc, tot_guarant, totalPreemptionAllowed,\n           totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n     for (TempQueuePerPartition t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n      Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n\n    for (TempQueuePerPartition q : qAlloc) {\n      if (Resources.greaterThan(rc, tot_guarant,\n          q.getGuaranteed(), Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(tot_guarant, nonZeroGuarQueues, unassigned,\n        false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee\n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n\n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueuePerPartition t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant,\n          t.getUsed(), t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded, Resources\n            .subtract(t.getUsed(), t.idealAssigned));\n      }\n    }\n\n    /**\n     * if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     * that is used to scale down how much we ask back from each queue\n     */\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc,\n        tot_guarant, totPreemptionNeeded, totalPreemptionAllowed)) {\n      scalingFactor \u003d Resources.divide(rc, tot_guarant, totalPreemptionAllowed,\n          totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueuePerPartition t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/PreemptableResourceCalculator.java",
      "extendedDetails": {}
    },
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
      "commitDate": "05/05/16 12:56 PM",
      "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthor": "Jian He",
      "commitDateOld": "30/03/16 12:43 PM",
      "commitNameOld": "60e4116bf1d00afed91010e57357fe54057e4e39",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 36.01,
      "commitsBetweenForRepo": 225,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,64 @@\n   private void computeIdealResourceDistribution(ResourceCalculator rc,\n       List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n       Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n     List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n     // group queues based on whether they have non-zero guaranteed capacity\n     Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n \n     for (TempQueuePerPartition q : qAlloc) {\n-      if (Resources\n-          .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n+      if (Resources.greaterThan(rc, tot_guarant,\n+          q.getGuaranteed(), Resources.none())) {\n         nonZeroGuarQueues.add(q);\n       } else {\n         zeroGuarQueues.add(q);\n       }\n     }\n \n     // first compute the allocation as a fixpoint based on guaranteed capacity\n     computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n         false);\n \n     // if any capacity is left unassigned, distributed among zero-guarantee\n     // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n     if (!zeroGuarQueues.isEmpty()\n         \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n       computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n           true);\n     }\n \n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n     for (TempQueuePerPartition t:queues) {\n-      if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n-        Resources.addTo(totPreemptionNeeded,\n-            Resources.subtract(t.current, t.idealAssigned));\n+      if (Resources.greaterThan(rc, tot_guarant,\n+          t.getUsed(), t.idealAssigned)) {\n+        Resources.addTo(totPreemptionNeeded, Resources\n+            .subtract(t.getUsed(), t.idealAssigned));\n       }\n     }\n \n-    // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n-    // that is used to scale down how much we ask back from each queue\n+    /**\n+     * if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n+     * that is used to scale down how much we ask back from each queue\n+     */\n     float scalingFactor \u003d 1.0F;\n-    if (Resources.greaterThan(rc, tot_guarant,\n-        totPreemptionNeeded, totalPreemptionAllowed)) {\n-      scalingFactor \u003d Resources.divide(rc, tot_guarant,\n-          totalPreemptionAllowed, totPreemptionNeeded);\n+    if (Resources.greaterThan(rc,\n+        tot_guarant, totPreemptionNeeded, totalPreemptionAllowed)) {\n+      scalingFactor \u003d Resources.divide(rc, tot_guarant, totalPreemptionAllowed,\n+          totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n     for (TempQueuePerPartition t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n-    if (LOG.isDebugEnabled()) {\n-      for (TempQueuePerPartition t : queues) {\n-        LOG.debug(t);\n-      }\n-    }\n-\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n      Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n\n    for (TempQueuePerPartition q : qAlloc) {\n      if (Resources.greaterThan(rc, tot_guarant,\n          q.getGuaranteed(), Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n        false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee\n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n\n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueuePerPartition t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant,\n          t.getUsed(), t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded, Resources\n            .subtract(t.getUsed(), t.idealAssigned));\n      }\n    }\n\n    /**\n     * if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     * that is used to scale down how much we ask back from each queue\n     */\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc,\n        tot_guarant, totPreemptionNeeded, totalPreemptionAllowed)) {\n      scalingFactor \u003d Resources.divide(rc, tot_guarant, totalPreemptionAllowed,\n          totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueuePerPartition t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/PreemptableResourceCalculator.java",
      "extendedDetails": {}
    },
    "60e4116bf1d00afed91010e57357fe54057e4e39": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
      "commitDate": "30/03/16 12:43 PM",
      "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
          "commitDate": "30/03/16 12:43 PM",
          "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
          "commitAuthor": "Jian He",
          "commitDateOld": "29/03/16 11:22 PM",
          "commitNameOld": "09d63d5a192b5d6b172f94ff6c94da348fd49ea6",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 0.56,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,67 @@\n   private void computeIdealResourceDistribution(ResourceCalculator rc,\n       List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n       Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n     List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n     // group queues based on whether they have non-zero guaranteed capacity\n     Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n \n     for (TempQueuePerPartition q : qAlloc) {\n       if (Resources\n           .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n         nonZeroGuarQueues.add(q);\n       } else {\n         zeroGuarQueues.add(q);\n       }\n     }\n \n     // first compute the allocation as a fixpoint based on guaranteed capacity\n     computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n         false);\n \n-    // if any capacity is left unassigned, distributed among zero-guarantee \n+    // if any capacity is left unassigned, distributed among zero-guarantee\n     // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n     if (!zeroGuarQueues.isEmpty()\n         \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n       computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n           true);\n     }\n-    \n+\n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n     for (TempQueuePerPartition t:queues) {\n       if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n         Resources.addTo(totPreemptionNeeded,\n             Resources.subtract(t.current, t.idealAssigned));\n       }\n     }\n \n     // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     // that is used to scale down how much we ask back from each queue\n     float scalingFactor \u003d 1.0F;\n     if (Resources.greaterThan(rc, tot_guarant,\n-          totPreemptionNeeded, totalPreemptionAllowed)) {\n-       scalingFactor \u003d Resources.divide(rc, tot_guarant,\n-           totalPreemptionAllowed, totPreemptionNeeded);\n+        totPreemptionNeeded, totalPreemptionAllowed)) {\n+      scalingFactor \u003d Resources.divide(rc, tot_guarant,\n+          totalPreemptionAllowed, totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n     for (TempQueuePerPartition t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n     if (LOG.isDebugEnabled()) {\n-      long time \u003d clock.getTime();\n       for (TempQueuePerPartition t : queues) {\n-        LOG.debug(time + \": \" + t);\n+        LOG.debug(t);\n       }\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n      Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n\n    for (TempQueuePerPartition q : qAlloc) {\n      if (Resources\n          .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n        false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee\n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n\n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueuePerPartition t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded,\n            Resources.subtract(t.current, t.idealAssigned));\n      }\n    }\n\n    // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n    // that is used to scale down how much we ask back from each queue\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc, tot_guarant,\n        totPreemptionNeeded, totalPreemptionAllowed)) {\n      scalingFactor \u003d Resources.divide(rc, tot_guarant,\n          totalPreemptionAllowed, totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueuePerPartition t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n    if (LOG.isDebugEnabled()) {\n      for (TempQueuePerPartition t : queues) {\n        LOG.debug(t);\n      }\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/PreemptableResourceCalculator.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/PreemptableResourceCalculator.java",
            "oldMethodName": "computeIdealResourceDistribution",
            "newMethodName": "computeIdealResourceDistribution"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
          "commitDate": "30/03/16 12:43 PM",
          "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
          "commitAuthor": "Jian He",
          "commitDateOld": "29/03/16 11:22 PM",
          "commitNameOld": "09d63d5a192b5d6b172f94ff6c94da348fd49ea6",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 0.56,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,67 @@\n   private void computeIdealResourceDistribution(ResourceCalculator rc,\n       List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n       Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n     List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n     // group queues based on whether they have non-zero guaranteed capacity\n     Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n \n     for (TempQueuePerPartition q : qAlloc) {\n       if (Resources\n           .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n         nonZeroGuarQueues.add(q);\n       } else {\n         zeroGuarQueues.add(q);\n       }\n     }\n \n     // first compute the allocation as a fixpoint based on guaranteed capacity\n     computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n         false);\n \n-    // if any capacity is left unassigned, distributed among zero-guarantee \n+    // if any capacity is left unassigned, distributed among zero-guarantee\n     // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n     if (!zeroGuarQueues.isEmpty()\n         \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n       computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n           true);\n     }\n-    \n+\n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n     for (TempQueuePerPartition t:queues) {\n       if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n         Resources.addTo(totPreemptionNeeded,\n             Resources.subtract(t.current, t.idealAssigned));\n       }\n     }\n \n     // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     // that is used to scale down how much we ask back from each queue\n     float scalingFactor \u003d 1.0F;\n     if (Resources.greaterThan(rc, tot_guarant,\n-          totPreemptionNeeded, totalPreemptionAllowed)) {\n-       scalingFactor \u003d Resources.divide(rc, tot_guarant,\n-           totalPreemptionAllowed, totPreemptionNeeded);\n+        totPreemptionNeeded, totalPreemptionAllowed)) {\n+      scalingFactor \u003d Resources.divide(rc, tot_guarant,\n+          totalPreemptionAllowed, totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n     for (TempQueuePerPartition t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n     if (LOG.isDebugEnabled()) {\n-      long time \u003d clock.getTime();\n       for (TempQueuePerPartition t : queues) {\n-        LOG.debug(time + \": \" + t);\n+        LOG.debug(t);\n       }\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n      Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n\n    for (TempQueuePerPartition q : qAlloc) {\n      if (Resources\n          .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n        false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee\n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n\n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueuePerPartition t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded,\n            Resources.subtract(t.current, t.idealAssigned));\n      }\n    }\n\n    // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n    // that is used to scale down how much we ask back from each queue\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc, tot_guarant,\n        totPreemptionNeeded, totalPreemptionAllowed)) {\n      scalingFactor \u003d Resources.divide(rc, tot_guarant,\n          totalPreemptionAllowed, totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueuePerPartition t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n    if (LOG.isDebugEnabled()) {\n      for (TempQueuePerPartition t : queues) {\n        LOG.debug(t);\n      }\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/PreemptableResourceCalculator.java",
          "extendedDetails": {}
        }
      ]
    },
    "ae14e5d07f1b6702a5160637438028bb03d9387e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   private void computeIdealResourceDistribution(ResourceCalculator rc,\n       List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n       Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n-    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003cTempQueuePerPartition\u003e(queues);\n+    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n     // group queues based on whether they have non-zero guaranteed capacity\n-    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n-    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n+    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n+    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n \n     for (TempQueuePerPartition q : qAlloc) {\n       if (Resources\n           .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n         nonZeroGuarQueues.add(q);\n       } else {\n         zeroGuarQueues.add(q);\n       }\n     }\n \n     // first compute the allocation as a fixpoint based on guaranteed capacity\n     computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n         false);\n \n     // if any capacity is left unassigned, distributed among zero-guarantee \n     // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n     if (!zeroGuarQueues.isEmpty()\n         \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n       computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n           true);\n     }\n     \n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n     for (TempQueuePerPartition t:queues) {\n       if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n         Resources.addTo(totPreemptionNeeded,\n             Resources.subtract(t.current, t.idealAssigned));\n       }\n     }\n \n     // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     // that is used to scale down how much we ask back from each queue\n     float scalingFactor \u003d 1.0F;\n     if (Resources.greaterThan(rc, tot_guarant,\n           totPreemptionNeeded, totalPreemptionAllowed)) {\n        scalingFactor \u003d Resources.divide(rc, tot_guarant,\n            totalPreemptionAllowed, totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n     for (TempQueuePerPartition t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n     if (LOG.isDebugEnabled()) {\n       long time \u003d clock.getTime();\n       for (TempQueuePerPartition t : queues) {\n         LOG.debug(time + \": \" + t);\n       }\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n      Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n\n    for (TempQueuePerPartition q : qAlloc) {\n      if (Resources\n          .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n        false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee \n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n    \n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueuePerPartition t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded,\n            Resources.subtract(t.current, t.idealAssigned));\n      }\n    }\n\n    // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n    // that is used to scale down how much we ask back from each queue\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc, tot_guarant,\n          totPreemptionNeeded, totalPreemptionAllowed)) {\n       scalingFactor \u003d Resources.divide(rc, tot_guarant,\n           totalPreemptionAllowed, totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueuePerPartition t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n    if (LOG.isDebugEnabled()) {\n      long time \u003d clock.getTime();\n      for (TempQueuePerPartition t : queues) {\n        LOG.debug(time + \": \" + t);\n      }\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "fa7a43529d529f0006c8033c2003f15b9b93f103": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 4:59 PM",
      "commitNameOld": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   private void computeIdealResourceDistribution(ResourceCalculator rc,\n       List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n       Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n-    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n+    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003cTempQueuePerPartition\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n     // group queues based on whether they have non-zero guaranteed capacity\n-    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n-    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n+    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n+    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n \n     for (TempQueuePerPartition q : qAlloc) {\n       if (Resources\n           .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n         nonZeroGuarQueues.add(q);\n       } else {\n         zeroGuarQueues.add(q);\n       }\n     }\n \n     // first compute the allocation as a fixpoint based on guaranteed capacity\n     computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n         false);\n \n     // if any capacity is left unassigned, distributed among zero-guarantee \n     // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n     if (!zeroGuarQueues.isEmpty()\n         \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n       computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n           true);\n     }\n     \n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n     for (TempQueuePerPartition t:queues) {\n       if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n         Resources.addTo(totPreemptionNeeded,\n             Resources.subtract(t.current, t.idealAssigned));\n       }\n     }\n \n     // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     // that is used to scale down how much we ask back from each queue\n     float scalingFactor \u003d 1.0F;\n     if (Resources.greaterThan(rc, tot_guarant,\n           totPreemptionNeeded, totalPreemptionAllowed)) {\n        scalingFactor \u003d Resources.divide(rc, tot_guarant,\n            totalPreemptionAllowed, totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n     for (TempQueuePerPartition t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n     if (LOG.isDebugEnabled()) {\n       long time \u003d clock.getTime();\n       for (TempQueuePerPartition t : queues) {\n         LOG.debug(time + \": \" + t);\n       }\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n      Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003cTempQueuePerPartition\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n\n    for (TempQueuePerPartition q : qAlloc) {\n      if (Resources\n          .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n        false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee \n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n    \n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueuePerPartition t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded,\n            Resources.subtract(t.current, t.idealAssigned));\n      }\n    }\n\n    // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n    // that is used to scale down how much we ask back from each queue\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc, tot_guarant,\n          totPreemptionNeeded, totalPreemptionAllowed)) {\n       scalingFactor \u003d Resources.divide(rc, tot_guarant,\n           totalPreemptionAllowed, totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueuePerPartition t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n    if (LOG.isDebugEnabled()) {\n      long time \u003d clock.getTime();\n      for (TempQueuePerPartition t : queues) {\n        LOG.debug(time + \": \" + t);\n      }\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": {
      "type": "Ybodychange",
      "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
      "commitDate": "16/03/16 4:59 PM",
      "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 5:30 PM",
      "commitNameOld": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 57.94,
      "commitsBetweenForRepo": 394,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   private void computeIdealResourceDistribution(ResourceCalculator rc,\n       List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n       Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n-    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003cTempQueuePerPartition\u003e(queues);\n+    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n     // group queues based on whether they have non-zero guaranteed capacity\n-    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n-    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n+    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n+    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n \n     for (TempQueuePerPartition q : qAlloc) {\n       if (Resources\n           .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n         nonZeroGuarQueues.add(q);\n       } else {\n         zeroGuarQueues.add(q);\n       }\n     }\n \n     // first compute the allocation as a fixpoint based on guaranteed capacity\n     computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n         false);\n \n     // if any capacity is left unassigned, distributed among zero-guarantee \n     // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n     if (!zeroGuarQueues.isEmpty()\n         \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n       computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n           true);\n     }\n     \n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n     for (TempQueuePerPartition t:queues) {\n       if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n         Resources.addTo(totPreemptionNeeded,\n             Resources.subtract(t.current, t.idealAssigned));\n       }\n     }\n \n     // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     // that is used to scale down how much we ask back from each queue\n     float scalingFactor \u003d 1.0F;\n     if (Resources.greaterThan(rc, tot_guarant,\n           totPreemptionNeeded, totalPreemptionAllowed)) {\n        scalingFactor \u003d Resources.divide(rc, tot_guarant,\n            totalPreemptionAllowed, totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n     for (TempQueuePerPartition t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n     if (LOG.isDebugEnabled()) {\n       long time \u003d clock.getTime();\n       for (TempQueuePerPartition t : queues) {\n         LOG.debug(time + \": \" + t);\n       }\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n      Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003c\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003c\u003e();\n\n    for (TempQueuePerPartition q : qAlloc) {\n      if (Resources\n          .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n        false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee \n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n    \n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueuePerPartition t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded,\n            Resources.subtract(t.current, t.idealAssigned));\n      }\n    }\n\n    // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n    // that is used to scale down how much we ask back from each queue\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc, tot_guarant,\n          totPreemptionNeeded, totalPreemptionAllowed)) {\n       scalingFactor \u003d Resources.divide(rc, tot_guarant,\n           totalPreemptionAllowed, totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueuePerPartition t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n    if (LOG.isDebugEnabled()) {\n      long time \u003d clock.getTime();\n      for (TempQueuePerPartition t : queues) {\n        LOG.debug(time + \": \" + t);\n      }\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
      "commitDate": "24/04/15 5:03 PM",
      "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
          "commitDate": "24/04/15 5:03 PM",
          "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
          "commitAuthor": "Jian He",
          "commitDateOld": "20/04/15 5:12 PM",
          "commitNameOld": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.99,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,68 @@\n   private void computeIdealResourceDistribution(ResourceCalculator rc,\n-      List\u003cTempQueue\u003e queues, Resource totalPreemptionAllowed, Resource tot_guarant) {\n+      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n+      Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n-    List\u003cTempQueue\u003e qAlloc \u003d new ArrayList\u003cTempQueue\u003e(queues);\n+    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003cTempQueuePerPartition\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n     // group queues based on whether they have non-zero guaranteed capacity\n-    Set\u003cTempQueue\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueue\u003e();\n-    Set\u003cTempQueue\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueue\u003e();\n+    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n+    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n \n-    for (TempQueue q : qAlloc) {\n+    for (TempQueuePerPartition q : qAlloc) {\n       if (Resources\n           .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n         nonZeroGuarQueues.add(q);\n       } else {\n         zeroGuarQueues.add(q);\n       }\n     }\n \n     // first compute the allocation as a fixpoint based on guaranteed capacity\n     computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n         false);\n \n     // if any capacity is left unassigned, distributed among zero-guarantee \n     // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n     if (!zeroGuarQueues.isEmpty()\n         \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n       computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n           true);\n     }\n     \n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n-    for (TempQueue t:queues) {\n+    for (TempQueuePerPartition t:queues) {\n       if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n         Resources.addTo(totPreemptionNeeded,\n             Resources.subtract(t.current, t.idealAssigned));\n       }\n     }\n \n     // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     // that is used to scale down how much we ask back from each queue\n     float scalingFactor \u003d 1.0F;\n     if (Resources.greaterThan(rc, tot_guarant,\n           totPreemptionNeeded, totalPreemptionAllowed)) {\n        scalingFactor \u003d Resources.divide(rc, tot_guarant,\n            totalPreemptionAllowed, totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n-    for (TempQueue t : queues) {\n+    for (TempQueuePerPartition t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n     if (LOG.isDebugEnabled()) {\n       long time \u003d clock.getTime();\n-      for (TempQueue t : queues) {\n+      for (TempQueuePerPartition t : queues) {\n         LOG.debug(time + \": \" + t);\n       }\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n      Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003cTempQueuePerPartition\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n\n    for (TempQueuePerPartition q : qAlloc) {\n      if (Resources\n          .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n        false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee \n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n    \n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueuePerPartition t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded,\n            Resources.subtract(t.current, t.idealAssigned));\n      }\n    }\n\n    // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n    // that is used to scale down how much we ask back from each queue\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc, tot_guarant,\n          totPreemptionNeeded, totalPreemptionAllowed)) {\n       scalingFactor \u003d Resources.divide(rc, tot_guarant,\n           totalPreemptionAllowed, totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueuePerPartition t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n    if (LOG.isDebugEnabled()) {\n      long time \u003d clock.getTime();\n      for (TempQueuePerPartition t : queues) {\n        LOG.debug(time + \": \" + t);\n      }\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {
            "oldValue": "[rc-ResourceCalculator, queues-List\u003cTempQueue\u003e, totalPreemptionAllowed-Resource, tot_guarant-Resource]",
            "newValue": "[rc-ResourceCalculator, queues-List\u003cTempQueuePerPartition\u003e, totalPreemptionAllowed-Resource, tot_guarant-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
          "commitDate": "24/04/15 5:03 PM",
          "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
          "commitAuthor": "Jian He",
          "commitDateOld": "20/04/15 5:12 PM",
          "commitNameOld": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.99,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,68 @@\n   private void computeIdealResourceDistribution(ResourceCalculator rc,\n-      List\u003cTempQueue\u003e queues, Resource totalPreemptionAllowed, Resource tot_guarant) {\n+      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n+      Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n-    List\u003cTempQueue\u003e qAlloc \u003d new ArrayList\u003cTempQueue\u003e(queues);\n+    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003cTempQueuePerPartition\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n     // group queues based on whether they have non-zero guaranteed capacity\n-    Set\u003cTempQueue\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueue\u003e();\n-    Set\u003cTempQueue\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueue\u003e();\n+    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n+    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n \n-    for (TempQueue q : qAlloc) {\n+    for (TempQueuePerPartition q : qAlloc) {\n       if (Resources\n           .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n         nonZeroGuarQueues.add(q);\n       } else {\n         zeroGuarQueues.add(q);\n       }\n     }\n \n     // first compute the allocation as a fixpoint based on guaranteed capacity\n     computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n         false);\n \n     // if any capacity is left unassigned, distributed among zero-guarantee \n     // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n     if (!zeroGuarQueues.isEmpty()\n         \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n       computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n           true);\n     }\n     \n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n-    for (TempQueue t:queues) {\n+    for (TempQueuePerPartition t:queues) {\n       if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n         Resources.addTo(totPreemptionNeeded,\n             Resources.subtract(t.current, t.idealAssigned));\n       }\n     }\n \n     // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     // that is used to scale down how much we ask back from each queue\n     float scalingFactor \u003d 1.0F;\n     if (Resources.greaterThan(rc, tot_guarant,\n           totPreemptionNeeded, totalPreemptionAllowed)) {\n        scalingFactor \u003d Resources.divide(rc, tot_guarant,\n            totalPreemptionAllowed, totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n-    for (TempQueue t : queues) {\n+    for (TempQueuePerPartition t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n     if (LOG.isDebugEnabled()) {\n       long time \u003d clock.getTime();\n-      for (TempQueue t : queues) {\n+      for (TempQueuePerPartition t : queues) {\n         LOG.debug(time + \": \" + t);\n       }\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueuePerPartition\u003e queues, Resource totalPreemptionAllowed,\n      Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueuePerPartition\u003e qAlloc \u003d new ArrayList\u003cTempQueuePerPartition\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueuePerPartition\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n    Set\u003cTempQueuePerPartition\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueuePerPartition\u003e();\n\n    for (TempQueuePerPartition q : qAlloc) {\n      if (Resources\n          .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n        false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee \n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n    \n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueuePerPartition t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded,\n            Resources.subtract(t.current, t.idealAssigned));\n      }\n    }\n\n    // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n    // that is used to scale down how much we ask back from each queue\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc, tot_guarant,\n          totPreemptionNeeded, totalPreemptionAllowed)) {\n       scalingFactor \u003d Resources.divide(rc, tot_guarant,\n           totalPreemptionAllowed, totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueuePerPartition t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n    if (LOG.isDebugEnabled()) {\n      long time \u003d clock.getTime();\n      for (TempQueuePerPartition t : queues) {\n        LOG.debug(time + \": \" + t);\n      }\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "45b42676f9333ed4fa05355ccb4e1f91a9556525": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1957. Consider the max capacity of the queue when computing the ideal\ncapacity for preemption. Contributed by Carlo Curino\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594414 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/14 4:15 PM",
      "commitName": "45b42676f9333ed4fa05355ccb4e1f91a9556525",
      "commitAuthor": "Christopher Douglas",
      "commitDateOld": "10/07/13 6:20 PM",
      "commitNameOld": "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61",
      "commitAuthorOld": "Christopher Douglas",
      "daysBetweenCommits": 306.91,
      "commitsBetweenForRepo": 2071,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,67 @@\n   private void computeIdealResourceDistribution(ResourceCalculator rc,\n       List\u003cTempQueue\u003e queues, Resource totalPreemptionAllowed, Resource tot_guarant) {\n \n     // qAlloc tracks currently active queues (will decrease progressively as\n     // demand is met)\n     List\u003cTempQueue\u003e qAlloc \u003d new ArrayList\u003cTempQueue\u003e(queues);\n     // unassigned tracks how much resources are still to assign, initialized\n     // with the total capacity for this set of queues\n     Resource unassigned \u003d Resources.clone(tot_guarant);\n \n-    //assign all cluster resources until no more demand, or no resources are left\n-    while (!qAlloc.isEmpty() \u0026\u0026 Resources.greaterThan(rc, tot_guarant,\n-          unassigned, Resources.none())) {\n-      Resource wQassigned \u003d Resource.newInstance(0, 0);\n+    // group queues based on whether they have non-zero guaranteed capacity\n+    Set\u003cTempQueue\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueue\u003e();\n+    Set\u003cTempQueue\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueue\u003e();\n \n-      // we compute normalizedGuarantees capacity based on currently active\n-      // queues\n-      resetCapacity(rc, unassigned, qAlloc);\n-\n-      // offer for each queue their capacity first and in following invocations\n-      // their share of over-capacity\n-      for (Iterator\u003cTempQueue\u003e i \u003d qAlloc.iterator(); i.hasNext();) {\n-        TempQueue sub \u003d i.next();\n-        Resource wQavail \u003d\n-          Resources.multiply(unassigned, sub.normalizedGuarantee);\n-        Resource wQidle \u003d sub.offer(wQavail, rc, tot_guarant);\n-        Resource wQdone \u003d Resources.subtract(wQavail, wQidle);\n-        // if the queue returned a value \u003e 0 it means it is fully satisfied\n-        // and it is removed from the list of active queues qAlloc\n-        if (!Resources.greaterThan(rc, tot_guarant,\n-              wQdone, Resources.none())) {\n-          i.remove();\n-        }\n-        Resources.addTo(wQassigned, wQdone);\n+    for (TempQueue q : qAlloc) {\n+      if (Resources\n+          .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n+        nonZeroGuarQueues.add(q);\n+      } else {\n+        zeroGuarQueues.add(q);\n       }\n-      Resources.subtractFrom(unassigned, wQassigned);\n     }\n \n+    // first compute the allocation as a fixpoint based on guaranteed capacity\n+    computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n+        false);\n+\n+    // if any capacity is left unassigned, distributed among zero-guarantee \n+    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n+    if (!zeroGuarQueues.isEmpty()\n+        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n+      computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n+          true);\n+    }\n+    \n     // based on ideal assignment computed above and current assignment we derive\n     // how much preemption is required overall\n     Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n     for (TempQueue t:queues) {\n       if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n         Resources.addTo(totPreemptionNeeded,\n             Resources.subtract(t.current, t.idealAssigned));\n       }\n     }\n \n     // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n     // that is used to scale down how much we ask back from each queue\n     float scalingFactor \u003d 1.0F;\n     if (Resources.greaterThan(rc, tot_guarant,\n           totPreemptionNeeded, totalPreemptionAllowed)) {\n        scalingFactor \u003d Resources.divide(rc, tot_guarant,\n            totalPreemptionAllowed, totPreemptionNeeded);\n     }\n \n     // assign to each queue the amount of actual preemption based on local\n     // information of ideal preemption and scaling factor\n     for (TempQueue t : queues) {\n       t.assignPreemption(scalingFactor, rc, tot_guarant);\n     }\n     if (LOG.isDebugEnabled()) {\n       long time \u003d clock.getTime();\n       for (TempQueue t : queues) {\n         LOG.debug(time + \": \" + t);\n       }\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueue\u003e queues, Resource totalPreemptionAllowed, Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueue\u003e qAlloc \u003d new ArrayList\u003cTempQueue\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    // group queues based on whether they have non-zero guaranteed capacity\n    Set\u003cTempQueue\u003e nonZeroGuarQueues \u003d new HashSet\u003cTempQueue\u003e();\n    Set\u003cTempQueue\u003e zeroGuarQueues \u003d new HashSet\u003cTempQueue\u003e();\n\n    for (TempQueue q : qAlloc) {\n      if (Resources\n          .greaterThan(rc, tot_guarant, q.guaranteed, Resources.none())) {\n        nonZeroGuarQueues.add(q);\n      } else {\n        zeroGuarQueues.add(q);\n      }\n    }\n\n    // first compute the allocation as a fixpoint based on guaranteed capacity\n    computeFixpointAllocation(rc, tot_guarant, nonZeroGuarQueues, unassigned,\n        false);\n\n    // if any capacity is left unassigned, distributed among zero-guarantee \n    // queues uniformly (i.e., not based on guaranteed capacity, as this is zero)\n    if (!zeroGuarQueues.isEmpty()\n        \u0026\u0026 Resources.greaterThan(rc, tot_guarant, unassigned, Resources.none())) {\n      computeFixpointAllocation(rc, tot_guarant, zeroGuarQueues, unassigned,\n          true);\n    }\n    \n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueue t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded,\n            Resources.subtract(t.current, t.idealAssigned));\n      }\n    }\n\n    // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n    // that is used to scale down how much we ask back from each queue\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc, tot_guarant,\n          totPreemptionNeeded, totalPreemptionAllowed)) {\n       scalingFactor \u003d Resources.divide(rc, tot_guarant,\n           totalPreemptionAllowed, totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueue t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n    if (LOG.isDebugEnabled()) {\n      long time \u003d clock.getTime();\n      for (TempQueue t : queues) {\n        LOG.debug(time + \": \" + t);\n      }\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61": {
      "type": "Yintroduced",
      "commitMessage": "YARN-569. Add support for requesting and enforcing preemption requests via\na capacity monitor. Contributed by Carlo Curino, Chris Douglas\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502083 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 6:20 PM",
      "commitName": "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61",
      "commitAuthor": "Christopher Douglas",
      "diff": "@@ -0,0 +1,70 @@\n+  private void computeIdealResourceDistribution(ResourceCalculator rc,\n+      List\u003cTempQueue\u003e queues, Resource totalPreemptionAllowed, Resource tot_guarant) {\n+\n+    // qAlloc tracks currently active queues (will decrease progressively as\n+    // demand is met)\n+    List\u003cTempQueue\u003e qAlloc \u003d new ArrayList\u003cTempQueue\u003e(queues);\n+    // unassigned tracks how much resources are still to assign, initialized\n+    // with the total capacity for this set of queues\n+    Resource unassigned \u003d Resources.clone(tot_guarant);\n+\n+    //assign all cluster resources until no more demand, or no resources are left\n+    while (!qAlloc.isEmpty() \u0026\u0026 Resources.greaterThan(rc, tot_guarant,\n+          unassigned, Resources.none())) {\n+      Resource wQassigned \u003d Resource.newInstance(0, 0);\n+\n+      // we compute normalizedGuarantees capacity based on currently active\n+      // queues\n+      resetCapacity(rc, unassigned, qAlloc);\n+\n+      // offer for each queue their capacity first and in following invocations\n+      // their share of over-capacity\n+      for (Iterator\u003cTempQueue\u003e i \u003d qAlloc.iterator(); i.hasNext();) {\n+        TempQueue sub \u003d i.next();\n+        Resource wQavail \u003d\n+          Resources.multiply(unassigned, sub.normalizedGuarantee);\n+        Resource wQidle \u003d sub.offer(wQavail, rc, tot_guarant);\n+        Resource wQdone \u003d Resources.subtract(wQavail, wQidle);\n+        // if the queue returned a value \u003e 0 it means it is fully satisfied\n+        // and it is removed from the list of active queues qAlloc\n+        if (!Resources.greaterThan(rc, tot_guarant,\n+              wQdone, Resources.none())) {\n+          i.remove();\n+        }\n+        Resources.addTo(wQassigned, wQdone);\n+      }\n+      Resources.subtractFrom(unassigned, wQassigned);\n+    }\n+\n+    // based on ideal assignment computed above and current assignment we derive\n+    // how much preemption is required overall\n+    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n+    for (TempQueue t:queues) {\n+      if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n+        Resources.addTo(totPreemptionNeeded,\n+            Resources.subtract(t.current, t.idealAssigned));\n+      }\n+    }\n+\n+    // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n+    // that is used to scale down how much we ask back from each queue\n+    float scalingFactor \u003d 1.0F;\n+    if (Resources.greaterThan(rc, tot_guarant,\n+          totPreemptionNeeded, totalPreemptionAllowed)) {\n+       scalingFactor \u003d Resources.divide(rc, tot_guarant,\n+           totalPreemptionAllowed, totPreemptionNeeded);\n+    }\n+\n+    // assign to each queue the amount of actual preemption based on local\n+    // information of ideal preemption and scaling factor\n+    for (TempQueue t : queues) {\n+      t.assignPreemption(scalingFactor, rc, tot_guarant);\n+    }\n+    if (LOG.isDebugEnabled()) {\n+      long time \u003d clock.getTime();\n+      for (TempQueue t : queues) {\n+        LOG.debug(time + \": \" + t);\n+      }\n+    }\n+\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void computeIdealResourceDistribution(ResourceCalculator rc,\n      List\u003cTempQueue\u003e queues, Resource totalPreemptionAllowed, Resource tot_guarant) {\n\n    // qAlloc tracks currently active queues (will decrease progressively as\n    // demand is met)\n    List\u003cTempQueue\u003e qAlloc \u003d new ArrayList\u003cTempQueue\u003e(queues);\n    // unassigned tracks how much resources are still to assign, initialized\n    // with the total capacity for this set of queues\n    Resource unassigned \u003d Resources.clone(tot_guarant);\n\n    //assign all cluster resources until no more demand, or no resources are left\n    while (!qAlloc.isEmpty() \u0026\u0026 Resources.greaterThan(rc, tot_guarant,\n          unassigned, Resources.none())) {\n      Resource wQassigned \u003d Resource.newInstance(0, 0);\n\n      // we compute normalizedGuarantees capacity based on currently active\n      // queues\n      resetCapacity(rc, unassigned, qAlloc);\n\n      // offer for each queue their capacity first and in following invocations\n      // their share of over-capacity\n      for (Iterator\u003cTempQueue\u003e i \u003d qAlloc.iterator(); i.hasNext();) {\n        TempQueue sub \u003d i.next();\n        Resource wQavail \u003d\n          Resources.multiply(unassigned, sub.normalizedGuarantee);\n        Resource wQidle \u003d sub.offer(wQavail, rc, tot_guarant);\n        Resource wQdone \u003d Resources.subtract(wQavail, wQidle);\n        // if the queue returned a value \u003e 0 it means it is fully satisfied\n        // and it is removed from the list of active queues qAlloc\n        if (!Resources.greaterThan(rc, tot_guarant,\n              wQdone, Resources.none())) {\n          i.remove();\n        }\n        Resources.addTo(wQassigned, wQdone);\n      }\n      Resources.subtractFrom(unassigned, wQassigned);\n    }\n\n    // based on ideal assignment computed above and current assignment we derive\n    // how much preemption is required overall\n    Resource totPreemptionNeeded \u003d Resource.newInstance(0, 0);\n    for (TempQueue t:queues) {\n      if (Resources.greaterThan(rc, tot_guarant, t.current, t.idealAssigned)) {\n        Resources.addTo(totPreemptionNeeded,\n            Resources.subtract(t.current, t.idealAssigned));\n      }\n    }\n\n    // if we need to preempt more than is allowed, compute a factor (0\u003cf\u003c1)\n    // that is used to scale down how much we ask back from each queue\n    float scalingFactor \u003d 1.0F;\n    if (Resources.greaterThan(rc, tot_guarant,\n          totPreemptionNeeded, totalPreemptionAllowed)) {\n       scalingFactor \u003d Resources.divide(rc, tot_guarant,\n           totalPreemptionAllowed, totPreemptionNeeded);\n    }\n\n    // assign to each queue the amount of actual preemption based on local\n    // information of ideal preemption and scaling factor\n    for (TempQueue t : queues) {\n      t.assignPreemption(scalingFactor, rc, tot_guarant);\n    }\n    if (LOG.isDebugEnabled()) {\n      long time \u003d clock.getTime();\n      for (TempQueue t : queues) {\n        LOG.debug(time + \": \" + t);\n      }\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java"
    }
  }
}