{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BootstrapStandby.java",
  "functionName": "doRun",
  "functionId": "doRun",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
  "functionStartLine": 168,
  "functionEndLine": 255,
  "numCommitsSeen": 35,
  "timeTaken": 5180,
  "changeHistory": [
    "8fc0d04517912766a3102f3e611f7d0fabd2f815",
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
    "49dfad942970459297f72632ed8dfd353e0c86de",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846",
    "9f75b97a098381458ed44d913dde167b49dde50d",
    "8f0c3419348d0c10b104f7997854174267c883af",
    "d2024f2e76c8f0d66f7b9819daebdd051c1990e8",
    "e9a17c8ce0656a4e5d47401ca22a575c5f5f66db",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
    "00067895a01c66d53715b50bbcb3605efd6425f2",
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
    "7186000367df5a994e0270690a95ca49fa7b23a0",
    "045dc880e13271737b3cf316296e92fb95806663",
    "9d0f8792a9a1d3d2b24adfc2c213247a099e7ad1",
    "7accbabdee0b7619ff83514c173e815d290b33bf",
    "d1a54b872dc0b38801e7cf6eef0a27272e867c1e",
    "21824d8232875a6aba9c9c1669507ea9d09586df",
    "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7"
  ],
  "changeHistoryShort": {
    "8fc0d04517912766a3102f3e611f7d0fabd2f815": "Ybodychange",
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568": "Ybodychange",
    "49dfad942970459297f72632ed8dfd353e0c86de": "Ybodychange",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846": "Ybodychange",
    "9f75b97a098381458ed44d913dde167b49dde50d": "Ybodychange",
    "8f0c3419348d0c10b104f7997854174267c883af": "Ybodychange",
    "d2024f2e76c8f0d66f7b9819daebdd051c1990e8": "Ybodychange",
    "e9a17c8ce0656a4e5d47401ca22a575c5f5f66db": "Ybodychange",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": "Ybodychange",
    "00067895a01c66d53715b50bbcb3605efd6425f2": "Ybodychange",
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de": "Ybodychange",
    "7186000367df5a994e0270690a95ca49fa7b23a0": "Ybodychange",
    "045dc880e13271737b3cf316296e92fb95806663": "Ybodychange",
    "9d0f8792a9a1d3d2b24adfc2c213247a099e7ad1": "Ybodychange",
    "7accbabdee0b7619ff83514c173e815d290b33bf": "Ybodychange",
    "d1a54b872dc0b38801e7cf6eef0a27272e867c1e": "Ybodychange",
    "21824d8232875a6aba9c9c1669507ea9d09586df": "Ybodychange",
    "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8fc0d04517912766a3102f3e611f7d0fabd2f815": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14001. [PROVIDED Storage] bootstrapStandby should manage the InMemoryAliasMap. Contributed by Virajith Jalaparti.\n",
      "commitDate": "07/12/18 6:30 PM",
      "commitName": "8fc0d04517912766a3102f3e611f7d0fabd2f815",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "06/09/18 2:48 PM",
      "commitNameOld": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 92.2,
      "commitsBetweenForRepo": 832,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,88 @@\n   private int doRun() throws IOException {\n     // find the active NN\n     NamenodeProtocol proxy \u003d null;\n     NamespaceInfo nsInfo \u003d null;\n     boolean isUpgradeFinalized \u003d false;\n     RemoteNameNodeInfo proxyInfo \u003d null;\n     for (int i \u003d 0; i \u003c remoteNNs.size(); i++) {\n       proxyInfo \u003d remoteNNs.get(i);\n       InetSocketAddress otherIpcAddress \u003d proxyInfo.getIpcAddress();\n       proxy \u003d createNNProtocolProxy(otherIpcAddress);\n       try {\n         // Get the namespace from any active NN. If you just formatted the primary NN and are\n         // bootstrapping the other NNs from that layout, it will only contact the single NN.\n         // However, if there cluster is already running and you are adding a NN later (e.g.\n         // replacing a failed NN), then this will bootstrap from any node in the cluster.\n         nsInfo \u003d proxy.versionRequest();\n         isUpgradeFinalized \u003d proxy.isUpgradeFinalized();\n         break;\n       } catch (IOException ioe) {\n         LOG.warn(\"Unable to fetch namespace information from remote NN at \" + otherIpcAddress\n             + \": \" + ioe.getMessage());\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Full exception trace\", ioe);\n         }\n       }\n     }\n \n     if (nsInfo \u003d\u003d null) {\n       LOG.error(\n           \"Unable to fetch namespace information from any remote NN. Possible NameNodes: \"\n               + remoteNNs);\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.error(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n           + \") does not match \" + \"this node\u0027s layout version (\"\n           + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + proxyInfo.getNameNodeID() + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + proxyInfo.getHttpAddress() + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + proxyInfo.getIpcAddress() + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"       isUpgradeFinalized: \" + isUpgradeFinalized + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n \n     if (!isUpgradeFinalized) {\n       // the remote NameNode is in upgrade state, this NameNode should also\n       // create the previous directory. First prepare the upgrade and rename\n       // the current dir to previous.tmp.\n       LOG.info(\"The active NameNode is in Upgrade. \" +\n           \"Prepare the upgrade for the standby NameNode as well.\");\n       if (!doPreUpgrade(storage, nsInfo)) {\n         return ERR_CODE_ALREADY_FORMATTED;\n       }\n     } else if (!format(storage, nsInfo)) { // prompt the user to format storage\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n \n     // download the fsimage from active namenode\n     int download \u003d downloadImage(storage, proxy, proxyInfo);\n     if (download !\u003d 0) {\n       return download;\n     }\n \n     // finish the upgrade: rename previous.tmp to previous\n     if (!isUpgradeFinalized) {\n       doUpgrade(storage);\n     }\n+\n+    if (inMemoryAliasMapEnabled) {\n+      return formatAndDownloadAliasMap(aliasMapPath, proxyInfo);\n+    } else {\n+      LOG.info(\"Skipping InMemoryAliasMap bootstrap as it was not configured\");\n+    }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n    // find the active NN\n    NamenodeProtocol proxy \u003d null;\n    NamespaceInfo nsInfo \u003d null;\n    boolean isUpgradeFinalized \u003d false;\n    RemoteNameNodeInfo proxyInfo \u003d null;\n    for (int i \u003d 0; i \u003c remoteNNs.size(); i++) {\n      proxyInfo \u003d remoteNNs.get(i);\n      InetSocketAddress otherIpcAddress \u003d proxyInfo.getIpcAddress();\n      proxy \u003d createNNProtocolProxy(otherIpcAddress);\n      try {\n        // Get the namespace from any active NN. If you just formatted the primary NN and are\n        // bootstrapping the other NNs from that layout, it will only contact the single NN.\n        // However, if there cluster is already running and you are adding a NN later (e.g.\n        // replacing a failed NN), then this will bootstrap from any node in the cluster.\n        nsInfo \u003d proxy.versionRequest();\n        isUpgradeFinalized \u003d proxy.isUpgradeFinalized();\n        break;\n      } catch (IOException ioe) {\n        LOG.warn(\"Unable to fetch namespace information from remote NN at \" + otherIpcAddress\n            + \": \" + ioe.getMessage());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Full exception trace\", ioe);\n        }\n      }\n    }\n\n    if (nsInfo \u003d\u003d null) {\n      LOG.error(\n          \"Unable to fetch namespace information from any remote NN. Possible NameNodes: \"\n              + remoteNNs);\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.error(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n          + \") does not match \" + \"this node\u0027s layout version (\"\n          + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + proxyInfo.getNameNodeID() + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + proxyInfo.getHttpAddress() + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + proxyInfo.getIpcAddress() + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"       isUpgradeFinalized: \" + isUpgradeFinalized + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n\n    if (!isUpgradeFinalized) {\n      // the remote NameNode is in upgrade state, this NameNode should also\n      // create the previous directory. First prepare the upgrade and rename\n      // the current dir to previous.tmp.\n      LOG.info(\"The active NameNode is in Upgrade. \" +\n          \"Prepare the upgrade for the standby NameNode as well.\");\n      if (!doPreUpgrade(storage, nsInfo)) {\n        return ERR_CODE_ALREADY_FORMATTED;\n      }\n    } else if (!format(storage, nsInfo)) { // prompt the user to format storage\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n\n    // download the fsimage from active namenode\n    int download \u003d downloadImage(storage, proxy, proxyInfo);\n    if (download !\u003d 0) {\n      return download;\n    }\n\n    // finish the upgrade: rename previous.tmp to previous\n    if (!isUpgradeFinalized) {\n      doUpgrade(storage);\n    }\n\n    if (inMemoryAliasMapEnabled) {\n      return formatAndDownloadAliasMap(aliasMapPath, proxyInfo);\n    } else {\n      LOG.info(\"Skipping InMemoryAliasMap bootstrap as it was not configured\");\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13695. Move logging to slf4j in HDFS package. Contributed by Ian Pickering.\n",
      "commitDate": "06/09/18 2:48 PM",
      "commitName": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "27/12/16 11:21 AM",
      "commitNameOld": "c0e0ef29696109af9a018462059f08fd99ee3121",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 618.1,
      "commitsBetweenForRepo": 4720,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   private int doRun() throws IOException {\n     // find the active NN\n     NamenodeProtocol proxy \u003d null;\n     NamespaceInfo nsInfo \u003d null;\n     boolean isUpgradeFinalized \u003d false;\n     RemoteNameNodeInfo proxyInfo \u003d null;\n     for (int i \u003d 0; i \u003c remoteNNs.size(); i++) {\n       proxyInfo \u003d remoteNNs.get(i);\n       InetSocketAddress otherIpcAddress \u003d proxyInfo.getIpcAddress();\n       proxy \u003d createNNProtocolProxy(otherIpcAddress);\n       try {\n         // Get the namespace from any active NN. If you just formatted the primary NN and are\n         // bootstrapping the other NNs from that layout, it will only contact the single NN.\n         // However, if there cluster is already running and you are adding a NN later (e.g.\n         // replacing a failed NN), then this will bootstrap from any node in the cluster.\n         nsInfo \u003d proxy.versionRequest();\n         isUpgradeFinalized \u003d proxy.isUpgradeFinalized();\n         break;\n       } catch (IOException ioe) {\n         LOG.warn(\"Unable to fetch namespace information from remote NN at \" + otherIpcAddress\n             + \": \" + ioe.getMessage());\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Full exception trace\", ioe);\n         }\n       }\n     }\n \n     if (nsInfo \u003d\u003d null) {\n-      LOG.fatal(\n+      LOG.error(\n           \"Unable to fetch namespace information from any remote NN. Possible NameNodes: \"\n               + remoteNNs);\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n-      LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n+      LOG.error(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n           + \") does not match \" + \"this node\u0027s layout version (\"\n           + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + proxyInfo.getNameNodeID() + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + proxyInfo.getHttpAddress() + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + proxyInfo.getIpcAddress() + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"       isUpgradeFinalized: \" + isUpgradeFinalized + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n \n     if (!isUpgradeFinalized) {\n       // the remote NameNode is in upgrade state, this NameNode should also\n       // create the previous directory. First prepare the upgrade and rename\n       // the current dir to previous.tmp.\n       LOG.info(\"The active NameNode is in Upgrade. \" +\n           \"Prepare the upgrade for the standby NameNode as well.\");\n       if (!doPreUpgrade(storage, nsInfo)) {\n         return ERR_CODE_ALREADY_FORMATTED;\n       }\n     } else if (!format(storage, nsInfo)) { // prompt the user to format storage\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n \n     // download the fsimage from active namenode\n     int download \u003d downloadImage(storage, proxy, proxyInfo);\n     if (download !\u003d 0) {\n       return download;\n     }\n \n     // finish the upgrade: rename previous.tmp to previous\n     if (!isUpgradeFinalized) {\n       doUpgrade(storage);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n    // find the active NN\n    NamenodeProtocol proxy \u003d null;\n    NamespaceInfo nsInfo \u003d null;\n    boolean isUpgradeFinalized \u003d false;\n    RemoteNameNodeInfo proxyInfo \u003d null;\n    for (int i \u003d 0; i \u003c remoteNNs.size(); i++) {\n      proxyInfo \u003d remoteNNs.get(i);\n      InetSocketAddress otherIpcAddress \u003d proxyInfo.getIpcAddress();\n      proxy \u003d createNNProtocolProxy(otherIpcAddress);\n      try {\n        // Get the namespace from any active NN. If you just formatted the primary NN and are\n        // bootstrapping the other NNs from that layout, it will only contact the single NN.\n        // However, if there cluster is already running and you are adding a NN later (e.g.\n        // replacing a failed NN), then this will bootstrap from any node in the cluster.\n        nsInfo \u003d proxy.versionRequest();\n        isUpgradeFinalized \u003d proxy.isUpgradeFinalized();\n        break;\n      } catch (IOException ioe) {\n        LOG.warn(\"Unable to fetch namespace information from remote NN at \" + otherIpcAddress\n            + \": \" + ioe.getMessage());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Full exception trace\", ioe);\n        }\n      }\n    }\n\n    if (nsInfo \u003d\u003d null) {\n      LOG.error(\n          \"Unable to fetch namespace information from any remote NN. Possible NameNodes: \"\n              + remoteNNs);\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.error(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n          + \") does not match \" + \"this node\u0027s layout version (\"\n          + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + proxyInfo.getNameNodeID() + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + proxyInfo.getHttpAddress() + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + proxyInfo.getIpcAddress() + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"       isUpgradeFinalized: \" + isUpgradeFinalized + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n\n    if (!isUpgradeFinalized) {\n      // the remote NameNode is in upgrade state, this NameNode should also\n      // create the previous directory. First prepare the upgrade and rename\n      // the current dir to previous.tmp.\n      LOG.info(\"The active NameNode is in Upgrade. \" +\n          \"Prepare the upgrade for the standby NameNode as well.\");\n      if (!doPreUpgrade(storage, nsInfo)) {\n        return ERR_CODE_ALREADY_FORMATTED;\n      }\n    } else if (!format(storage, nsInfo)) { // prompt the user to format storage\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n\n    // download the fsimage from active namenode\n    int download \u003d downloadImage(storage, proxy, proxyInfo);\n    if (download !\u003d 0) {\n      return download;\n    }\n\n    // finish the upgrade: rename previous.tmp to previous\n    if (!isUpgradeFinalized) {\n      doUpgrade(storage);\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "49dfad942970459297f72632ed8dfd353e0c86de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6440. Support more than 2 NameNodes. Contributed by Jesse Yates.\n",
      "commitDate": "23/06/15 5:26 PM",
      "commitName": "49dfad942970459297f72632ed8dfd353e0c86de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "07/05/15 10:55 PM",
      "commitNameOld": "e5e492a9631ff78302fccedcb64d7b64b9407991",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 46.77,
      "commitsBetweenForRepo": 402,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,82 @@\n   private int doRun() throws IOException {\n-    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n-    NamespaceInfo nsInfo;\n-    boolean isUpgradeFinalized;\n-    try {\n-      nsInfo \u003d proxy.versionRequest();\n-      isUpgradeFinalized \u003d proxy.isUpgradeFinalized();\n-    } catch (IOException ioe) {\n-      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n-          otherIpcAddr + \": \" + ioe.getMessage());\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Full exception trace\", ioe);\n+    // find the active NN\n+    NamenodeProtocol proxy \u003d null;\n+    NamespaceInfo nsInfo \u003d null;\n+    boolean isUpgradeFinalized \u003d false;\n+    RemoteNameNodeInfo proxyInfo \u003d null;\n+    for (int i \u003d 0; i \u003c remoteNNs.size(); i++) {\n+      proxyInfo \u003d remoteNNs.get(i);\n+      InetSocketAddress otherIpcAddress \u003d proxyInfo.getIpcAddress();\n+      proxy \u003d createNNProtocolProxy(otherIpcAddress);\n+      try {\n+        // Get the namespace from any active NN. If you just formatted the primary NN and are\n+        // bootstrapping the other NNs from that layout, it will only contact the single NN.\n+        // However, if there cluster is already running and you are adding a NN later (e.g.\n+        // replacing a failed NN), then this will bootstrap from any node in the cluster.\n+        nsInfo \u003d proxy.versionRequest();\n+        isUpgradeFinalized \u003d proxy.isUpgradeFinalized();\n+        break;\n+      } catch (IOException ioe) {\n+        LOG.warn(\"Unable to fetch namespace information from remote NN at \" + otherIpcAddress\n+            + \": \" + ioe.getMessage());\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Full exception trace\", ioe);\n+        }\n       }\n+    }\n+\n+    if (nsInfo \u003d\u003d null) {\n+      LOG.fatal(\n+          \"Unable to fetch namespace information from any remote NN. Possible NameNodes: \"\n+              + remoteNNs);\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n           + \") does not match \" + \"this node\u0027s layout version (\"\n           + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n-        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n-        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n-        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n+        \"        Other Namenode ID: \" + proxyInfo.getNameNodeID() + \"\\n\" +\n+        \"  Other NN\u0027s HTTP address: \" + proxyInfo.getHttpAddress() + \"\\n\" +\n+        \"  Other NN\u0027s IPC  address: \" + proxyInfo.getIpcAddress() + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"       isUpgradeFinalized: \" + isUpgradeFinalized + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n \n     if (!isUpgradeFinalized) {\n       // the remote NameNode is in upgrade state, this NameNode should also\n       // create the previous directory. First prepare the upgrade and rename\n       // the current dir to previous.tmp.\n       LOG.info(\"The active NameNode is in Upgrade. \" +\n           \"Prepare the upgrade for the standby NameNode as well.\");\n       if (!doPreUpgrade(storage, nsInfo)) {\n         return ERR_CODE_ALREADY_FORMATTED;\n       }\n     } else if (!format(storage, nsInfo)) { // prompt the user to format storage\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n \n     // download the fsimage from active namenode\n-    int download \u003d downloadImage(storage, proxy);\n+    int download \u003d downloadImage(storage, proxy, proxyInfo);\n     if (download !\u003d 0) {\n       return download;\n     }\n \n     // finish the upgrade: rename previous.tmp to previous\n     if (!isUpgradeFinalized) {\n       doUpgrade(storage);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n    // find the active NN\n    NamenodeProtocol proxy \u003d null;\n    NamespaceInfo nsInfo \u003d null;\n    boolean isUpgradeFinalized \u003d false;\n    RemoteNameNodeInfo proxyInfo \u003d null;\n    for (int i \u003d 0; i \u003c remoteNNs.size(); i++) {\n      proxyInfo \u003d remoteNNs.get(i);\n      InetSocketAddress otherIpcAddress \u003d proxyInfo.getIpcAddress();\n      proxy \u003d createNNProtocolProxy(otherIpcAddress);\n      try {\n        // Get the namespace from any active NN. If you just formatted the primary NN and are\n        // bootstrapping the other NNs from that layout, it will only contact the single NN.\n        // However, if there cluster is already running and you are adding a NN later (e.g.\n        // replacing a failed NN), then this will bootstrap from any node in the cluster.\n        nsInfo \u003d proxy.versionRequest();\n        isUpgradeFinalized \u003d proxy.isUpgradeFinalized();\n        break;\n      } catch (IOException ioe) {\n        LOG.warn(\"Unable to fetch namespace information from remote NN at \" + otherIpcAddress\n            + \": \" + ioe.getMessage());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Full exception trace\", ioe);\n        }\n      }\n    }\n\n    if (nsInfo \u003d\u003d null) {\n      LOG.fatal(\n          \"Unable to fetch namespace information from any remote NN. Possible NameNodes: \"\n              + remoteNNs);\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n          + \") does not match \" + \"this node\u0027s layout version (\"\n          + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + proxyInfo.getNameNodeID() + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + proxyInfo.getHttpAddress() + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + proxyInfo.getIpcAddress() + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"       isUpgradeFinalized: \" + isUpgradeFinalized + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n\n    if (!isUpgradeFinalized) {\n      // the remote NameNode is in upgrade state, this NameNode should also\n      // create the previous directory. First prepare the upgrade and rename\n      // the current dir to previous.tmp.\n      LOG.info(\"The active NameNode is in Upgrade. \" +\n          \"Prepare the upgrade for the standby NameNode as well.\");\n      if (!doPreUpgrade(storage, nsInfo)) {\n        return ERR_CODE_ALREADY_FORMATTED;\n      }\n    } else if (!format(storage, nsInfo)) { // prompt the user to format storage\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n\n    // download the fsimage from active namenode\n    int download \u003d downloadImage(storage, proxy, proxyInfo);\n    if (download !\u003d 0) {\n      return download;\n    }\n\n    // finish the upgrade: rename previous.tmp to previous\n    if (!isUpgradeFinalized) {\n      doUpgrade(storage);\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "14/04/15 3:05 PM",
      "commitNameOld": "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 17.79,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private int doRun() throws IOException {\n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     boolean isUpgradeFinalized;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n       isUpgradeFinalized \u003d proxy.isUpgradeFinalized();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n           + \") does not match \" + \"this node\u0027s layout version (\"\n-          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n+          + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"       isUpgradeFinalized: \" + isUpgradeFinalized + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n \n     if (!isUpgradeFinalized) {\n       // the remote NameNode is in upgrade state, this NameNode should also\n       // create the previous directory. First prepare the upgrade and rename\n       // the current dir to previous.tmp.\n       LOG.info(\"The active NameNode is in Upgrade. \" +\n           \"Prepare the upgrade for the standby NameNode as well.\");\n       if (!doPreUpgrade(storage, nsInfo)) {\n         return ERR_CODE_ALREADY_FORMATTED;\n       }\n     } else if (!format(storage, nsInfo)) { // prompt the user to format storage\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n \n     // download the fsimage from active namenode\n     int download \u003d downloadImage(storage, proxy);\n     if (download !\u003d 0) {\n       return download;\n     }\n \n     // finish the upgrade: rename previous.tmp to previous\n     if (!isUpgradeFinalized) {\n       doUpgrade(storage);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    boolean isUpgradeFinalized;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n      isUpgradeFinalized \u003d proxy.isUpgradeFinalized();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n          + \") does not match \" + \"this node\u0027s layout version (\"\n          + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"       isUpgradeFinalized: \" + isUpgradeFinalized + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n\n    if (!isUpgradeFinalized) {\n      // the remote NameNode is in upgrade state, this NameNode should also\n      // create the previous directory. First prepare the upgrade and rename\n      // the current dir to previous.tmp.\n      LOG.info(\"The active NameNode is in Upgrade. \" +\n          \"Prepare the upgrade for the standby NameNode as well.\");\n      if (!doPreUpgrade(storage, nsInfo)) {\n        return ERR_CODE_ALREADY_FORMATTED;\n      }\n    } else if (!format(storage, nsInfo)) { // prompt the user to format storage\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n\n    // download the fsimage from active namenode\n    int download \u003d downloadImage(storage, proxy);\n    if (download !\u003d 0) {\n      return download;\n    }\n\n    // finish the upgrade: rename previous.tmp to previous\n    if (!isUpgradeFinalized) {\n      doUpgrade(storage);\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8127. NameNode Failover during HA upgrade can cause DataNode to finalize upgrade. Contributed by Jing Zhao.\n",
      "commitDate": "14/04/15 3:05 PM",
      "commitName": "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "18/07/14 1:48 AM",
      "commitNameOld": "9f75b97a098381458ed44d913dde167b49dde50d",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 270.55,
      "commitsBetweenForRepo": 2350,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,64 @@\n   private int doRun() throws IOException {\n-\n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n+    boolean isUpgradeFinalized;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n+      isUpgradeFinalized \u003d proxy.isUpgradeFinalized();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n           + \") does not match \" + \"this node\u0027s layout version (\"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n-    \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n+        \"       isUpgradeFinalized: \" + isUpgradeFinalized + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n-\n-    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n-    long curTxId \u003d proxy.getTransactionID();\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n-    \n-    // Check with the user before blowing away data.\n-    if (!Storage.confirmFormat(storage.dirIterable(null),\n-            force, interactive)) {\n-      storage.close();\n+\n+    if (!isUpgradeFinalized) {\n+      // the remote NameNode is in upgrade state, this NameNode should also\n+      // create the previous directory. First prepare the upgrade and rename\n+      // the current dir to previous.tmp.\n+      LOG.info(\"The active NameNode is in Upgrade. \" +\n+          \"Prepare the upgrade for the standby NameNode as well.\");\n+      if (!doPreUpgrade(storage, nsInfo)) {\n+        return ERR_CODE_ALREADY_FORMATTED;\n+      }\n+    } else if (!format(storage, nsInfo)) { // prompt the user to format storage\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n-    \n-    // Format the storage (writes VERSION file)\n-    storage.format(nsInfo);\n \n-    // Load the newly formatted image, using all of the directories (including shared\n-    // edits)\n-    FSImage image \u003d new FSImage(conf);\n-    try {\n-      image.getStorage().setStorageInfo(storage);\n-      image.initEditLog(StartupOption.REGULAR);\n-      assert image.getEditLog().isOpenForRead() :\n-        \"Expected edit log to be open for read\";\n+    // download the fsimage from active namenode\n+    int download \u003d downloadImage(storage, proxy);\n+    if (download !\u003d 0) {\n+      return download;\n+    }\n \n-      // Ensure that we have enough edits already in the shared directory to\n-      // start up from the last checkpoint on the active.\n-      if (!skipSharedEditsCheck \u0026\u0026 !checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n-        return ERR_CODE_LOGS_UNAVAILABLE;\n-      }\n-\n-      image.getStorage().writeTransactionIdFileToStorage(curTxId);\n-\n-      // Download that checkpoint into our storage directories.\n-      MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n-        otherHttpAddr, imageTxId, storage, true);\n-      image.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE, imageTxId,\n-          hash);\n-    } catch (IOException ioe) {\n-      image.close();\n-      throw ioe;\n+    // finish the upgrade: rename previous.tmp to previous\n+    if (!isUpgradeFinalized) {\n+      doUpgrade(storage);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    boolean isUpgradeFinalized;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n      isUpgradeFinalized \u003d proxy.isUpgradeFinalized();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n          + \") does not match \" + \"this node\u0027s layout version (\"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"       isUpgradeFinalized: \" + isUpgradeFinalized + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n\n    if (!isUpgradeFinalized) {\n      // the remote NameNode is in upgrade state, this NameNode should also\n      // create the previous directory. First prepare the upgrade and rename\n      // the current dir to previous.tmp.\n      LOG.info(\"The active NameNode is in Upgrade. \" +\n          \"Prepare the upgrade for the standby NameNode as well.\");\n      if (!doPreUpgrade(storage, nsInfo)) {\n        return ERR_CODE_ALREADY_FORMATTED;\n      }\n    } else if (!format(storage, nsInfo)) { // prompt the user to format storage\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n\n    // download the fsimage from active namenode\n    int download \u003d downloadImage(storage, proxy);\n    if (download !\u003d 0) {\n      return download;\n    }\n\n    // finish the upgrade: rename previous.tmp to previous\n    if (!isUpgradeFinalized) {\n      doUpgrade(storage);\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "9f75b97a098381458ed44d913dde167b49dde50d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4120. Add a new \"-skipSharedEditsCheck\" option for BootstrapStandby ( Contributed by Liang Xie and Rakesh R )\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611562 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/14 1:48 AM",
      "commitName": "9f75b97a098381458ed44d913dde167b49dde50d",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "18/07/14 1:46 AM",
      "commitNameOld": "8f0c3419348d0c10b104f7997854174267c883af",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n           + \") does not match \" + \"this node\u0027s layout version (\"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n     long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n     long curTxId \u003d proxy.getTransactionID();\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     \n     // Check with the user before blowing away data.\n     if (!Storage.confirmFormat(storage.dirIterable(null),\n             force, interactive)) {\n       storage.close();\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n     \n     // Format the storage (writes VERSION file)\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n     try {\n       image.getStorage().setStorageInfo(storage);\n       image.initEditLog(StartupOption.REGULAR);\n       assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n \n       // Ensure that we have enough edits already in the shared directory to\n       // start up from the last checkpoint on the active.\n-      if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n+      if (!skipSharedEditsCheck \u0026\u0026 !checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n         return ERR_CODE_LOGS_UNAVAILABLE;\n       }\n \n       image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n       // Download that checkpoint into our storage directories.\n       MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n         otherHttpAddr, imageTxId, storage, true);\n       image.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE, imageTxId,\n           hash);\n     } catch (IOException ioe) {\n       image.close();\n       throw ioe;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n          + \") does not match \" + \"this node\u0027s layout version (\"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    \n    // Check with the user before blowing away data.\n    if (!Storage.confirmFormat(storage.dirIterable(null),\n            force, interactive)) {\n      storage.close();\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    // Format the storage (writes VERSION file)\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    try {\n      image.getStorage().setStorageInfo(storage);\n      image.initEditLog(StartupOption.REGULAR);\n      assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n\n      // Ensure that we have enough edits already in the shared directory to\n      // start up from the last checkpoint on the active.\n      if (!skipSharedEditsCheck \u0026\u0026 !checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n        return ERR_CODE_LOGS_UNAVAILABLE;\n      }\n\n      image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n      // Download that checkpoint into our storage directories.\n      MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr, imageTxId, storage, true);\n      image.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE, imageTxId,\n          hash);\n    } catch (IOException ioe) {\n      image.close();\n      throw ioe;\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "8f0c3419348d0c10b104f7997854174267c883af": {
      "type": "Ybodychange",
      "commitMessage": "reverted\nHDFS-4120. Add a new \"-skipSharedEditsCheck\" option for BootstrapStandby ( Contributed by Rakesh R )\n........\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611560 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/14 1:46 AM",
      "commitName": "8f0c3419348d0c10b104f7997854174267c883af",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "18/07/14 1:32 AM",
      "commitNameOld": "d2024f2e76c8f0d66f7b9819daebdd051c1990e8",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n           + \") does not match \" + \"this node\u0027s layout version (\"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n     long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n     long curTxId \u003d proxy.getTransactionID();\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     \n     // Check with the user before blowing away data.\n     if (!Storage.confirmFormat(storage.dirIterable(null),\n             force, interactive)) {\n       storage.close();\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n     \n     // Format the storage (writes VERSION file)\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n     try {\n       image.getStorage().setStorageInfo(storage);\n       image.initEditLog(StartupOption.REGULAR);\n       assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n \n       // Ensure that we have enough edits already in the shared directory to\n       // start up from the last checkpoint on the active.\n-      if (!skipSharedEditsCheck \u0026\u0026 !checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n+      if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n         return ERR_CODE_LOGS_UNAVAILABLE;\n       }\n \n       image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n       // Download that checkpoint into our storage directories.\n       MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n         otherHttpAddr, imageTxId, storage, true);\n       image.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE, imageTxId,\n           hash);\n     } catch (IOException ioe) {\n       image.close();\n       throw ioe;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n          + \") does not match \" + \"this node\u0027s layout version (\"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    \n    // Check with the user before blowing away data.\n    if (!Storage.confirmFormat(storage.dirIterable(null),\n            force, interactive)) {\n      storage.close();\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    // Format the storage (writes VERSION file)\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    try {\n      image.getStorage().setStorageInfo(storage);\n      image.initEditLog(StartupOption.REGULAR);\n      assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n\n      // Ensure that we have enough edits already in the shared directory to\n      // start up from the last checkpoint on the active.\n      if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n        return ERR_CODE_LOGS_UNAVAILABLE;\n      }\n\n      image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n      // Download that checkpoint into our storage directories.\n      MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr, imageTxId, storage, true);\n      image.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE, imageTxId,\n          hash);\n    } catch (IOException ioe) {\n      image.close();\n      throw ioe;\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "d2024f2e76c8f0d66f7b9819daebdd051c1990e8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4120. Add a new \"-skipSharedEditsCheck\" option for BootstrapStandby ( Contributed by Rakesh R )\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611556 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/14 1:32 AM",
      "commitName": "d2024f2e76c8f0d66f7b9819daebdd051c1990e8",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "07/04/14 11:55 AM",
      "commitNameOld": "a5b37c6ed14e92f5a7f7dd76a9a82b3f859fb6dd",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 101.57,
      "commitsBetweenForRepo": 634,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n           + \") does not match \" + \"this node\u0027s layout version (\"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n     long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n     long curTxId \u003d proxy.getTransactionID();\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     \n     // Check with the user before blowing away data.\n     if (!Storage.confirmFormat(storage.dirIterable(null),\n             force, interactive)) {\n       storage.close();\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n     \n     // Format the storage (writes VERSION file)\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n     try {\n       image.getStorage().setStorageInfo(storage);\n       image.initEditLog(StartupOption.REGULAR);\n       assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n \n       // Ensure that we have enough edits already in the shared directory to\n       // start up from the last checkpoint on the active.\n-      if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n+      if (!skipSharedEditsCheck \u0026\u0026 !checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n         return ERR_CODE_LOGS_UNAVAILABLE;\n       }\n \n       image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n       // Download that checkpoint into our storage directories.\n       MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n         otherHttpAddr, imageTxId, storage, true);\n       image.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE, imageTxId,\n           hash);\n     } catch (IOException ioe) {\n       image.close();\n       throw ioe;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n          + \") does not match \" + \"this node\u0027s layout version (\"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    \n    // Check with the user before blowing away data.\n    if (!Storage.confirmFormat(storage.dirIterable(null),\n            force, interactive)) {\n      storage.close();\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    // Format the storage (writes VERSION file)\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    try {\n      image.getStorage().setStorageInfo(storage);\n      image.initEditLog(StartupOption.REGULAR);\n      assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n\n      // Ensure that we have enough edits already in the shared directory to\n      // start up from the last checkpoint on the active.\n      if (!skipSharedEditsCheck \u0026\u0026 !checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n        return ERR_CODE_LOGS_UNAVAILABLE;\n      }\n\n      image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n      // Download that checkpoint into our storage directories.\n      MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr, imageTxId, storage, true);\n      image.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE, imageTxId,\n          hash);\n    } catch (IOException ioe) {\n      image.close();\n      throw ioe;\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "e9a17c8ce0656a4e5d47401ca22a575c5f5f66db": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6029. Secondary NN fails to checkpoint after -rollingUpgrade prepare. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1572800 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/02/14 5:21 PM",
      "commitName": "e9a17c8ce0656a4e5d47401ca22a575c5f5f66db",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "25/02/14 1:58 PM",
      "commitNameOld": "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.14,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,79 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n           + \") does not match \" + \"this node\u0027s layout version (\"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n     long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n     long curTxId \u003d proxy.getTransactionID();\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     \n     // Check with the user before blowing away data.\n     if (!Storage.confirmFormat(storage.dirIterable(null),\n             force, interactive)) {\n       storage.close();\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n     \n     // Format the storage (writes VERSION file)\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n     try {\n       image.getStorage().setStorageInfo(storage);\n       image.initEditLog(StartupOption.REGULAR);\n       assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n \n       // Ensure that we have enough edits already in the shared directory to\n       // start up from the last checkpoint on the active.\n       if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n         return ERR_CODE_LOGS_UNAVAILABLE;\n       }\n \n       image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n       // Download that checkpoint into our storage directories.\n       MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n-        otherHttpAddr, NameNodeFile.IMAGE, imageTxId,\n-        storage, true);\n+        otherHttpAddr, imageTxId, storage, true);\n       image.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE, imageTxId,\n           hash);\n     } catch (IOException ioe) {\n       image.close();\n       throw ioe;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n          + \") does not match \" + \"this node\u0027s layout version (\"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    \n    // Check with the user before blowing away data.\n    if (!Storage.confirmFormat(storage.dirIterable(null),\n            force, interactive)) {\n      storage.close();\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    // Format the storage (writes VERSION file)\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    try {\n      image.getStorage().setStorageInfo(storage);\n      image.initEditLog(StartupOption.REGULAR);\n      assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n\n      // Ensure that we have enough edits already in the shared directory to\n      // start up from the last checkpoint on the active.\n      if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n        return ERR_CODE_LOGS_UNAVAILABLE;\n      }\n\n      image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n      // Download that checkpoint into our storage directories.\n      MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr, imageTxId, storage, true);\n      image.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE, imageTxId,\n          hash);\n    } catch (IOException ioe) {\n      image.close();\n      throw ioe;\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6000. Avoid saving namespace when starting rolling upgrade. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1571840 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/14 1:58 PM",
      "commitName": "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "30/01/14 7:21 PM",
      "commitNameOld": "00067895a01c66d53715b50bbcb3605efd6425f2",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 25.78,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,80 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n           + \") does not match \" + \"this node\u0027s layout version (\"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n     long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n     long curTxId \u003d proxy.getTransactionID();\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     \n     // Check with the user before blowing away data.\n     if (!Storage.confirmFormat(storage.dirIterable(null),\n             force, interactive)) {\n       storage.close();\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n     \n     // Format the storage (writes VERSION file)\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n     try {\n       image.getStorage().setStorageInfo(storage);\n       image.initEditLog(StartupOption.REGULAR);\n       assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n \n       // Ensure that we have enough edits already in the shared directory to\n       // start up from the last checkpoint on the active.\n       if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n         return ERR_CODE_LOGS_UNAVAILABLE;\n       }\n \n       image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n       // Download that checkpoint into our storage directories.\n       MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n-        otherHttpAddr, imageTxId,\n+        otherHttpAddr, NameNodeFile.IMAGE, imageTxId,\n         storage, true);\n-      image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n+      image.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE, imageTxId,\n+          hash);\n     } catch (IOException ioe) {\n       image.close();\n       throw ioe;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n          + \") does not match \" + \"this node\u0027s layout version (\"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    \n    // Check with the user before blowing away data.\n    if (!Storage.confirmFormat(storage.dirIterable(null),\n            force, interactive)) {\n      storage.close();\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    // Format the storage (writes VERSION file)\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    try {\n      image.getStorage().setStorageInfo(storage);\n      image.initEditLog(StartupOption.REGULAR);\n      assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n\n      // Ensure that we have enough edits already in the shared directory to\n      // start up from the last checkpoint on the active.\n      if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n        return ERR_CODE_LOGS_UNAVAILABLE;\n      }\n\n      image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n      // Download that checkpoint into our storage directories.\n      MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr, NameNodeFile.IMAGE, imageTxId,\n        storage, true);\n      image.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE, imageTxId,\n          hash);\n    } catch (IOException ioe) {\n      image.close();\n      throw ioe;\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "00067895a01c66d53715b50bbcb3605efd6425f2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5754. Split LayoutVerion into NameNodeLayoutVersion and DataNodeLayoutVersion. Contributed by Brandon Li\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1563041 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/01/14 7:21 PM",
      "commitName": "00067895a01c66d53715b50bbcb3605efd6425f2",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "25/01/14 12:01 PM",
      "commitNameOld": "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 5.31,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n-      LOG.fatal(\"Layout version on remote node (\" +\n-          nsInfo.getLayoutVersion() + \") does not match \" +\n-          \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n+      LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n+          + \") does not match \" + \"this node\u0027s layout version (\"\n+          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n     long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n     long curTxId \u003d proxy.getTransactionID();\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     \n     // Check with the user before blowing away data.\n     if (!Storage.confirmFormat(storage.dirIterable(null),\n             force, interactive)) {\n       storage.close();\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n     \n     // Format the storage (writes VERSION file)\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n     try {\n       image.getStorage().setStorageInfo(storage);\n       image.initEditLog(StartupOption.REGULAR);\n       assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n \n       // Ensure that we have enough edits already in the shared directory to\n       // start up from the last checkpoint on the active.\n       if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n         return ERR_CODE_LOGS_UNAVAILABLE;\n       }\n \n       image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n       // Download that checkpoint into our storage directories.\n       MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n         otherHttpAddr, imageTxId,\n         storage, true);\n       image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n     } catch (IOException ioe) {\n       image.close();\n       throw ioe;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" + nsInfo.getLayoutVersion()\n          + \") does not match \" + \"this node\u0027s layout version (\"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    \n    // Check with the user before blowing away data.\n    if (!Storage.confirmFormat(storage.dirIterable(null),\n            force, interactive)) {\n      storage.close();\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    // Format the storage (writes VERSION file)\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    try {\n      image.getStorage().setStorageInfo(storage);\n      image.initEditLog(StartupOption.REGULAR);\n      assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n\n      // Ensure that we have enough edits already in the shared directory to\n      // start up from the last checkpoint on the active.\n      if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n        return ERR_CODE_LOGS_UNAVAILABLE;\n      }\n\n      image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n      // Download that checkpoint into our storage directories.\n      MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr, imageTxId,\n        storage, true);\n      image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n    } catch (IOException ioe) {\n      image.close();\n      throw ioe;\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5138. Support HDFS upgrade in HA. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561381 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/14 12:01 PM",
      "commitName": "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "09/01/14 5:33 AM",
      "commitNameOld": "7186000367df5a994e0270690a95ca49fa7b23a0",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 16.27,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" +\n           nsInfo.getLayoutVersion() + \") does not match \" +\n           \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n     long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n     long curTxId \u003d proxy.getTransactionID();\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     \n     // Check with the user before blowing away data.\n     if (!Storage.confirmFormat(storage.dirIterable(null),\n             force, interactive)) {\n       storage.close();\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n     \n     // Format the storage (writes VERSION file)\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n     try {\n       image.getStorage().setStorageInfo(storage);\n-      image.initEditLog();\n+      image.initEditLog(StartupOption.REGULAR);\n       assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n \n       // Ensure that we have enough edits already in the shared directory to\n       // start up from the last checkpoint on the active.\n       if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n         return ERR_CODE_LOGS_UNAVAILABLE;\n       }\n \n       image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n       // Download that checkpoint into our storage directories.\n       MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n         otherHttpAddr, imageTxId,\n         storage, true);\n       image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n     } catch (IOException ioe) {\n       image.close();\n       throw ioe;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" +\n          nsInfo.getLayoutVersion() + \") does not match \" +\n          \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    \n    // Check with the user before blowing away data.\n    if (!Storage.confirmFormat(storage.dirIterable(null),\n            force, interactive)) {\n      storage.close();\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    // Format the storage (writes VERSION file)\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    try {\n      image.getStorage().setStorageInfo(storage);\n      image.initEditLog(StartupOption.REGULAR);\n      assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n\n      // Ensure that we have enough edits already in the shared directory to\n      // start up from the last checkpoint on the active.\n      if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n        return ERR_CODE_LOGS_UNAVAILABLE;\n      }\n\n      image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n      // Download that checkpoint into our storage directories.\n      MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr, imageTxId,\n        storage, true);\n      image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n    } catch (IOException ioe) {\n      image.close();\n      throw ioe;\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "7186000367df5a994e0270690a95ca49fa7b23a0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5721. sharedEditsImage in Namenode#initializeSharedEdits() should be closed before method returns. (Ted Yu via junping_du)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556803 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/14 5:33 AM",
      "commitName": "7186000367df5a994e0270690a95ca49fa7b23a0",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/12/13 5:32 PM",
      "commitNameOld": "512a18a8d92305a34f3037064ceabdc5aff1f8bf",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 29.5,
      "commitsBetweenForRepo": 133,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,79 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" +\n           nsInfo.getLayoutVersion() + \") does not match \" +\n           \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n     long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n     long curTxId \u003d proxy.getTransactionID();\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     \n     // Check with the user before blowing away data.\n     if (!Storage.confirmFormat(storage.dirIterable(null),\n             force, interactive)) {\n       storage.close();\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n     \n     // Format the storage (writes VERSION file)\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n-    image.getStorage().setStorageInfo(storage);\n-    image.initEditLog();\n-    assert image.getEditLog().isOpenForRead() :\n+    try {\n+      image.getStorage().setStorageInfo(storage);\n+      image.initEditLog();\n+      assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n-    \n-    // Ensure that we have enough edits already in the shared directory to\n-    // start up from the last checkpoint on the active.\n-    if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n-      return ERR_CODE_LOGS_UNAVAILABLE;\n-    }\n-    \n-    image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n-    // Download that checkpoint into our storage directories.\n-    MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n+      // Ensure that we have enough edits already in the shared directory to\n+      // start up from the last checkpoint on the active.\n+      if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n+        return ERR_CODE_LOGS_UNAVAILABLE;\n+      }\n+\n+      image.getStorage().writeTransactionIdFileToStorage(curTxId);\n+\n+      // Download that checkpoint into our storage directories.\n+      MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n         otherHttpAddr, imageTxId,\n         storage, true);\n-    image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n+      image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n+    } catch (IOException ioe) {\n+      image.close();\n+      throw ioe;\n+    }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" +\n          nsInfo.getLayoutVersion() + \") does not match \" +\n          \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    \n    // Check with the user before blowing away data.\n    if (!Storage.confirmFormat(storage.dirIterable(null),\n            force, interactive)) {\n      storage.close();\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    // Format the storage (writes VERSION file)\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    try {\n      image.getStorage().setStorageInfo(storage);\n      image.initEditLog();\n      assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n\n      // Ensure that we have enough edits already in the shared directory to\n      // start up from the last checkpoint on the active.\n      if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n        return ERR_CODE_LOGS_UNAVAILABLE;\n      }\n\n      image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n      // Download that checkpoint into our storage directories.\n      MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr, imageTxId,\n        storage, true);\n      image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n    } catch (IOException ioe) {\n      image.close();\n      throw ioe;\n    }\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "045dc880e13271737b3cf316296e92fb95806663": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5312. Generate HTTP/HTTPS URL in DFSUtil#getInfoServer() based on the configured http policy. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548629 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/12/13 10:01 AM",
      "commitName": "045dc880e13271737b3cf316296e92fb95806663",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "15/08/13 10:19 AM",
      "commitNameOld": "8172215e5601c3bb03fb5c0a0d88768142ea5087",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 113.03,
      "commitsBetweenForRepo": 697,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,74 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" +\n           nsInfo.getLayoutVersion() + \") does not match \" +\n           \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n     long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n     long curTxId \u003d proxy.getTransactionID();\n     \n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     \n     // Check with the user before blowing away data.\n     if (!Storage.confirmFormat(storage.dirIterable(null),\n             force, interactive)) {\n+      storage.close();\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n     \n     // Format the storage (writes VERSION file)\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n     image.getStorage().setStorageInfo(storage);\n     image.initEditLog();\n     assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n     \n     // Ensure that we have enough edits already in the shared directory to\n     // start up from the last checkpoint on the active.\n     if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n       return ERR_CODE_LOGS_UNAVAILABLE;\n     }\n     \n     image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n     // Download that checkpoint into our storage directories.\n     MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n-        otherHttpAddr.toString(), imageTxId,\n+        otherHttpAddr, imageTxId,\n         storage, true);\n     image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" +\n          nsInfo.getLayoutVersion() + \") does not match \" +\n          \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    \n    // Check with the user before blowing away data.\n    if (!Storage.confirmFormat(storage.dirIterable(null),\n            force, interactive)) {\n      storage.close();\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    // Format the storage (writes VERSION file)\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    image.getStorage().setStorageInfo(storage);\n    image.initEditLog();\n    assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n    \n    // Ensure that we have enough edits already in the shared directory to\n    // start up from the last checkpoint on the active.\n    if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n      return ERR_CODE_LOGS_UNAVAILABLE;\n    }\n    \n    image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n    // Download that checkpoint into our storage directories.\n    MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr, imageTxId,\n        storage, true);\n    image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "9d0f8792a9a1d3d2b24adfc2c213247a099e7ad1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3695. Genericize format() to non-file JournalManagers. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1371513 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/08/12 3:13 PM",
      "commitName": "9d0f8792a9a1d3d2b24adfc2c213247a099e7ad1",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "15/07/12 7:58 PM",
      "commitNameOld": "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 24.8,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,73 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" +\n           nsInfo.getLayoutVersion() + \") does not match \" +\n           \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n+    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n+    long curTxId \u003d proxy.getTransactionID();\n+    \n+    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n+    \n     // Check with the user before blowing away data.\n-    if (!NameNode.confirmFormat(\n-            Sets.union(Sets.newHashSet(dirsToFormat),\n-                Sets.newHashSet(editUrisToFormat)),\n+    if (!Storage.confirmFormat(storage.dirIterable(null),\n             force, interactive)) {\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n     \n-    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n-    long curTxId \u003d proxy.getTransactionID();\n-    \n     // Format the storage (writes VERSION file)\n-    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n     image.getStorage().setStorageInfo(storage);\n     image.initEditLog();\n     assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n     \n     // Ensure that we have enough edits already in the shared directory to\n     // start up from the last checkpoint on the active.\n     if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n       return ERR_CODE_LOGS_UNAVAILABLE;\n     }\n     \n     image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n     // Download that checkpoint into our storage directories.\n     MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n         otherHttpAddr.toString(), imageTxId,\n         storage, true);\n     image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" +\n          nsInfo.getLayoutVersion() + \") does not match \" +\n          \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    \n    // Check with the user before blowing away data.\n    if (!Storage.confirmFormat(storage.dirIterable(null),\n            force, interactive)) {\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    // Format the storage (writes VERSION file)\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    image.getStorage().setStorageInfo(storage);\n    image.initEditLog();\n    assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n    \n    // Ensure that we have enough edits already in the shared directory to\n    // start up from the last checkpoint on the active.\n    if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n      return ERR_CODE_LOGS_UNAVAILABLE;\n    }\n    \n    image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n    // Download that checkpoint into our storage directories.\n    MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr.toString(), imageTxId,\n        storage, true);\n    image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "7accbabdee0b7619ff83514c173e815d290b33bf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3573. Supply NamespaceInfo when instantiating JournalManagers. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1356388 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/07/12 11:21 AM",
      "commitName": "7accbabdee0b7619ff83514c173e815d290b33bf",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "23/05/12 5:56 PM",
      "commitNameOld": "6c544adeb35c4aff3fc6d2e8fdfd66e20606d8f3",
      "commitAuthorOld": "",
      "daysBetweenCommits": 39.73,
      "commitsBetweenForRepo": 168,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,74 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" +\n           nsInfo.getLayoutVersion() + \") does not match \" +\n           \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n     // Check with the user before blowing away data.\n     if (!NameNode.confirmFormat(\n             Sets.union(Sets.newHashSet(dirsToFormat),\n                 Sets.newHashSet(editUrisToFormat)),\n             force, interactive)) {\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n     \n     long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n     long curTxId \u003d proxy.getTransactionID();\n     \n     // Format the storage (writes VERSION file)\n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n+    image.getStorage().setStorageInfo(storage);\n+    image.initEditLog();\n     assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n     \n     // Ensure that we have enough edits already in the shared directory to\n     // start up from the last checkpoint on the active.\n     if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n       return ERR_CODE_LOGS_UNAVAILABLE;\n     }\n     \n     image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n     // Download that checkpoint into our storage directories.\n     MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n         otherHttpAddr.toString(), imageTxId,\n         storage, true);\n     image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" +\n          nsInfo.getLayoutVersion() + \") does not match \" +\n          \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    // Check with the user before blowing away data.\n    if (!NameNode.confirmFormat(\n            Sets.union(Sets.newHashSet(dirsToFormat),\n                Sets.newHashSet(editUrisToFormat)),\n            force, interactive)) {\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    // Format the storage (writes VERSION file)\n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    image.getStorage().setStorageInfo(storage);\n    image.initEditLog();\n    assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n    \n    // Ensure that we have enough edits already in the shared directory to\n    // start up from the last checkpoint on the active.\n    if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n      return ERR_CODE_LOGS_UNAVAILABLE;\n    }\n    \n    image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n    // Download that checkpoint into our storage directories.\n    MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr.toString(), imageTxId,\n        storage, true);\n    image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "d1a54b872dc0b38801e7cf6eef0a27272e867c1e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3438. BootstrapStandby should not require a rollEdits on active node. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1340343 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/12 10:13 PM",
      "commitName": "d1a54b872dc0b38801e7cf6eef0a27272e867c1e",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "04/05/12 2:58 PM",
      "commitNameOld": "5dbbe0e0a5d31689d3425e490865f95057dc051c",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 14.3,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,72 @@\n   private int doRun() throws IOException {\n \n     NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n       return ERR_CODE_FAILED_CONNECT;\n     }\n \n     if (!checkLayoutVersion(nsInfo)) {\n       LOG.fatal(\"Layout version on remote node (\" +\n           nsInfo.getLayoutVersion() + \") does not match \" +\n           \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n       return ERR_CODE_INVALID_VERSION;\n     }\n \n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n-    // Ensure the other NN is active - we can\u0027t force it to roll edit logs\n-    // below if it\u0027s not active.\n-    if (!isOtherNNActive()) {\n-      String err \u003d \"NameNode \" + nsId + \".\" + nnId + \" at \" + otherIpcAddr +\n-          \" is not currently in ACTIVE state.\";\n-      if (!interactive) {\n-        LOG.fatal(err + \" Please transition it to \" +\n-            \"active before attempting to bootstrap a standby node.\");\n-        return ERR_CODE_OTHER_NN_NOT_ACTIVE;\n-      }\n-      \n-      System.err.println(err);\n-      if (ToolRunner.confirmPrompt(\n-            \"Do you want to automatically transition it to active now?\")) {\n-        transitionOtherNNActive();\n-      } else {\n-        LOG.fatal(\"User aborted. Exiting without bootstrapping standby.\");\n-        return ERR_CODE_OTHER_NN_NOT_ACTIVE;\n-      }\n-    }\n-    \n-\n-    \n     // Check with the user before blowing away data.\n     if (!NameNode.confirmFormat(\n             Sets.union(Sets.newHashSet(dirsToFormat),\n                 Sets.newHashSet(editUrisToFormat)),\n             force, interactive)) {\n       return ERR_CODE_ALREADY_FORMATTED;\n     }\n-\n-    // Force the active to roll its log\n-    CheckpointSignature csig \u003d proxy.rollEditLog();\n-    long imageTxId \u003d csig.getMostRecentCheckpointTxId();\n-    long rollTxId \u003d csig.getCurSegmentTxId();\n-\n-\n+    \n+    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n+    long curTxId \u003d proxy.getTransactionID();\n+    \n     // Format the storage (writes VERSION file)\n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n     assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n     \n     // Ensure that we have enough edits already in the shared directory to\n     // start up from the last checkpoint on the active.\n-    if (!checkLogsAvailableForRead(image, imageTxId, rollTxId)) {\n+    if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n       return ERR_CODE_LOGS_UNAVAILABLE;\n     }\n     \n-    image.getStorage().writeTransactionIdFileToStorage(rollTxId);\n+    image.getStorage().writeTransactionIdFileToStorage(curTxId);\n \n     // Download that checkpoint into our storage directories.\n     MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n         otherHttpAddr.toString(), imageTxId,\n         storage, true);\n     image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" +\n          nsInfo.getLayoutVersion() + \") does not match \" +\n          \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    // Check with the user before blowing away data.\n    if (!NameNode.confirmFormat(\n            Sets.union(Sets.newHashSet(dirsToFormat),\n                Sets.newHashSet(editUrisToFormat)),\n            force, interactive)) {\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n    \n    long imageTxId \u003d proxy.getMostRecentCheckpointTxId();\n    long curTxId \u003d proxy.getTransactionID();\n    \n    // Format the storage (writes VERSION file)\n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n    \n    // Ensure that we have enough edits already in the shared directory to\n    // start up from the last checkpoint on the active.\n    if (!checkLogsAvailableForRead(image, imageTxId, curTxId)) {\n      return ERR_CODE_LOGS_UNAVAILABLE;\n    }\n    \n    image.getStorage().writeTransactionIdFileToStorage(curTxId);\n\n    // Download that checkpoint into our storage directories.\n    MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr.toString(), imageTxId,\n        storage, true);\n    image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "21824d8232875a6aba9c9c1669507ea9d09586df": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3247. Improve bootstrapStandby behavior when original NN is not active. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1324558 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/04/12 10:16 PM",
      "commitName": "21824d8232875a6aba9c9c1669507ea9d09586df",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "12/03/12 12:41 PM",
      "commitNameOld": "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 29.4,
      "commitsBetweenForRepo": 228,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,98 @@\n   private int doRun() throws IOException {\n-    ProxyAndInfo\u003cNamenodeProtocol\u003e proxyAndInfo \u003d NameNodeProxies.createNonHAProxy(getConf(),\n-      otherIpcAddr, NamenodeProtocol.class,\n-      UserGroupInformation.getLoginUser(), true);\n-    NamenodeProtocol proxy \u003d proxyAndInfo.getProxy();\n+\n+    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n     NamespaceInfo nsInfo;\n     try {\n       nsInfo \u003d proxy.versionRequest();\n-      checkLayoutVersion(nsInfo);\n     } catch (IOException ioe) {\n       LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n           otherIpcAddr + \": \" + ioe.getMessage());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Full exception trace\", ioe);\n       }\n-      return 1;\n+      return ERR_CODE_FAILED_CONNECT;\n     }\n+\n+    if (!checkLayoutVersion(nsInfo)) {\n+      LOG.fatal(\"Layout version on remote node (\" +\n+          nsInfo.getLayoutVersion() + \") does not match \" +\n+          \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n+      return ERR_CODE_INVALID_VERSION;\n+    }\n+\n     \n     System.out.println(\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n         \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n         \"           Nameservice ID: \" + nsId + \"\\n\" +\n         \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n         \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n         \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n         \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n         \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n         \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n         \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n         \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n \n+    // Ensure the other NN is active - we can\u0027t force it to roll edit logs\n+    // below if it\u0027s not active.\n+    if (!isOtherNNActive()) {\n+      String err \u003d \"NameNode \" + nsId + \".\" + nnId + \" at \" + otherIpcAddr +\n+          \" is not currently in ACTIVE state.\";\n+      if (!interactive) {\n+        LOG.fatal(err + \" Please transition it to \" +\n+            \"active before attempting to bootstrap a standby node.\");\n+        return ERR_CODE_OTHER_NN_NOT_ACTIVE;\n+      }\n+      \n+      System.err.println(err);\n+      if (ToolRunner.confirmPrompt(\n+            \"Do you want to automatically transition it to active now?\")) {\n+        transitionOtherNNActive();\n+      } else {\n+        LOG.fatal(\"User aborted. Exiting without bootstrapping standby.\");\n+        return ERR_CODE_OTHER_NN_NOT_ACTIVE;\n+      }\n+    }\n+    \n+\n+    \n     // Check with the user before blowing away data.\n     if (!NameNode.confirmFormat(\n             Sets.union(Sets.newHashSet(dirsToFormat),\n                 Sets.newHashSet(editUrisToFormat)),\n             force, interactive)) {\n-      return 1;\n+      return ERR_CODE_ALREADY_FORMATTED;\n     }\n \n     // Force the active to roll its log\n     CheckpointSignature csig \u003d proxy.rollEditLog();\n     long imageTxId \u003d csig.getMostRecentCheckpointTxId();\n     long rollTxId \u003d csig.getCurSegmentTxId();\n \n \n     // Format the storage (writes VERSION file)\n     NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n     storage.format(nsInfo);\n \n     // Load the newly formatted image, using all of the directories (including shared\n     // edits)\n     FSImage image \u003d new FSImage(conf);\n     assert image.getEditLog().isOpenForRead() :\n         \"Expected edit log to be open for read\";\n     \n     // Ensure that we have enough edits already in the shared directory to\n     // start up from the last checkpoint on the active.\n     if (!checkLogsAvailableForRead(image, imageTxId, rollTxId)) {\n-      return 1;\n+      return ERR_CODE_LOGS_UNAVAILABLE;\n     }\n     \n     image.getStorage().writeTransactionIdFileToStorage(rollTxId);\n \n     // Download that checkpoint into our storage directories.\n     MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n         otherHttpAddr.toString(), imageTxId,\n         storage, true);\n     image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n\n    NamenodeProtocol proxy \u003d createNNProtocolProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return ERR_CODE_FAILED_CONNECT;\n    }\n\n    if (!checkLayoutVersion(nsInfo)) {\n      LOG.fatal(\"Layout version on remote node (\" +\n          nsInfo.getLayoutVersion() + \") does not match \" +\n          \"this node\u0027s layout version (\" + HdfsConstants.LAYOUT_VERSION + \")\");\n      return ERR_CODE_INVALID_VERSION;\n    }\n\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    // Ensure the other NN is active - we can\u0027t force it to roll edit logs\n    // below if it\u0027s not active.\n    if (!isOtherNNActive()) {\n      String err \u003d \"NameNode \" + nsId + \".\" + nnId + \" at \" + otherIpcAddr +\n          \" is not currently in ACTIVE state.\";\n      if (!interactive) {\n        LOG.fatal(err + \" Please transition it to \" +\n            \"active before attempting to bootstrap a standby node.\");\n        return ERR_CODE_OTHER_NN_NOT_ACTIVE;\n      }\n      \n      System.err.println(err);\n      if (ToolRunner.confirmPrompt(\n            \"Do you want to automatically transition it to active now?\")) {\n        transitionOtherNNActive();\n      } else {\n        LOG.fatal(\"User aborted. Exiting without bootstrapping standby.\");\n        return ERR_CODE_OTHER_NN_NOT_ACTIVE;\n      }\n    }\n    \n\n    \n    // Check with the user before blowing away data.\n    if (!NameNode.confirmFormat(\n            Sets.union(Sets.newHashSet(dirsToFormat),\n                Sets.newHashSet(editUrisToFormat)),\n            force, interactive)) {\n      return ERR_CODE_ALREADY_FORMATTED;\n    }\n\n    // Force the active to roll its log\n    CheckpointSignature csig \u003d proxy.rollEditLog();\n    long imageTxId \u003d csig.getMostRecentCheckpointTxId();\n    long rollTxId \u003d csig.getCurSegmentTxId();\n\n\n    // Format the storage (writes VERSION file)\n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n    \n    // Ensure that we have enough edits already in the shared directory to\n    // start up from the last checkpoint on the active.\n    if (!checkLogsAvailableForRead(image, imageTxId, rollTxId)) {\n      return ERR_CODE_LOGS_UNAVAILABLE;\n    }\n    \n    image.getStorage().writeTransactionIdFileToStorage(rollTxId);\n\n    // Download that checkpoint into our storage directories.\n    MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr.toString(), imageTxId,\n        storage, true);\n    image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java",
      "extendedDetails": {}
    },
    "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2731. Add command to bootstrap the Standby Node\u0027s name directories from the Active NameNode. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1299807 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/03/12 12:41 PM",
      "commitName": "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,70 @@\n+  private int doRun() throws IOException {\n+    ProxyAndInfo\u003cNamenodeProtocol\u003e proxyAndInfo \u003d NameNodeProxies.createNonHAProxy(getConf(),\n+      otherIpcAddr, NamenodeProtocol.class,\n+      UserGroupInformation.getLoginUser(), true);\n+    NamenodeProtocol proxy \u003d proxyAndInfo.getProxy();\n+    NamespaceInfo nsInfo;\n+    try {\n+      nsInfo \u003d proxy.versionRequest();\n+      checkLayoutVersion(nsInfo);\n+    } catch (IOException ioe) {\n+      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n+          otherIpcAddr + \": \" + ioe.getMessage());\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Full exception trace\", ioe);\n+      }\n+      return 1;\n+    }\n+    \n+    System.out.println(\n+        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n+        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n+        \"           Nameservice ID: \" + nsId + \"\\n\" +\n+        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n+        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n+        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n+        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n+        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n+        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n+        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n+        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n+\n+    // Check with the user before blowing away data.\n+    if (!NameNode.confirmFormat(\n+            Sets.union(Sets.newHashSet(dirsToFormat),\n+                Sets.newHashSet(editUrisToFormat)),\n+            force, interactive)) {\n+      return 1;\n+    }\n+\n+    // Force the active to roll its log\n+    CheckpointSignature csig \u003d proxy.rollEditLog();\n+    long imageTxId \u003d csig.getMostRecentCheckpointTxId();\n+    long rollTxId \u003d csig.getCurSegmentTxId();\n+\n+\n+    // Format the storage (writes VERSION file)\n+    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n+    storage.format(nsInfo);\n+\n+    // Load the newly formatted image, using all of the directories (including shared\n+    // edits)\n+    FSImage image \u003d new FSImage(conf);\n+    assert image.getEditLog().isOpenForRead() :\n+        \"Expected edit log to be open for read\";\n+    \n+    // Ensure that we have enough edits already in the shared directory to\n+    // start up from the last checkpoint on the active.\n+    if (!checkLogsAvailableForRead(image, imageTxId, rollTxId)) {\n+      return 1;\n+    }\n+    \n+    image.getStorage().writeTransactionIdFileToStorage(rollTxId);\n+\n+    // Download that checkpoint into our storage directories.\n+    MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n+        otherHttpAddr.toString(), imageTxId,\n+        storage, true);\n+    image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n+    return 0;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int doRun() throws IOException {\n    ProxyAndInfo\u003cNamenodeProtocol\u003e proxyAndInfo \u003d NameNodeProxies.createNonHAProxy(getConf(),\n      otherIpcAddr, NamenodeProtocol.class,\n      UserGroupInformation.getLoginUser(), true);\n    NamenodeProtocol proxy \u003d proxyAndInfo.getProxy();\n    NamespaceInfo nsInfo;\n    try {\n      nsInfo \u003d proxy.versionRequest();\n      checkLayoutVersion(nsInfo);\n    } catch (IOException ioe) {\n      LOG.fatal(\"Unable to fetch namespace information from active NN at \" +\n          otherIpcAddr + \": \" + ioe.getMessage());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Full exception trace\", ioe);\n      }\n      return 1;\n    }\n    \n    System.out.println(\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\" +\n        \"About to bootstrap Standby ID \" + nnId + \" from:\\n\" +\n        \"           Nameservice ID: \" + nsId + \"\\n\" +\n        \"        Other Namenode ID: \" + otherNNId + \"\\n\" +\n        \"  Other NN\u0027s HTTP address: \" + otherHttpAddr + \"\\n\" +\n        \"  Other NN\u0027s IPC  address: \" + otherIpcAddr + \"\\n\" +\n        \"             Namespace ID: \" + nsInfo.getNamespaceID() + \"\\n\" +\n        \"            Block pool ID: \" + nsInfo.getBlockPoolID() + \"\\n\" +\n        \"               Cluster ID: \" + nsInfo.getClusterID() + \"\\n\" +\n        \"           Layout version: \" + nsInfo.getLayoutVersion() + \"\\n\" +\n        \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\");\n\n    // Check with the user before blowing away data.\n    if (!NameNode.confirmFormat(\n            Sets.union(Sets.newHashSet(dirsToFormat),\n                Sets.newHashSet(editUrisToFormat)),\n            force, interactive)) {\n      return 1;\n    }\n\n    // Force the active to roll its log\n    CheckpointSignature csig \u003d proxy.rollEditLog();\n    long imageTxId \u003d csig.getMostRecentCheckpointTxId();\n    long rollTxId \u003d csig.getCurSegmentTxId();\n\n\n    // Format the storage (writes VERSION file)\n    NNStorage storage \u003d new NNStorage(conf, dirsToFormat, editUrisToFormat);\n    storage.format(nsInfo);\n\n    // Load the newly formatted image, using all of the directories (including shared\n    // edits)\n    FSImage image \u003d new FSImage(conf);\n    assert image.getEditLog().isOpenForRead() :\n        \"Expected edit log to be open for read\";\n    \n    // Ensure that we have enough edits already in the shared directory to\n    // start up from the last checkpoint on the active.\n    if (!checkLogsAvailableForRead(image, imageTxId, rollTxId)) {\n      return 1;\n    }\n    \n    image.getStorage().writeTransactionIdFileToStorage(rollTxId);\n\n    // Download that checkpoint into our storage directories.\n    MD5Hash hash \u003d TransferFsImage.downloadImageToStorage(\n        otherHttpAddr.toString(), imageTxId,\n        storage, true);\n    image.saveDigestAndRenameCheckpointImage(imageTxId, hash);\n    return 0;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/BootstrapStandby.java"
    }
  }
}