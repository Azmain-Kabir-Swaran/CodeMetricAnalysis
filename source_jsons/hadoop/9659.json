{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockDispatcher.java",
  "functionName": "moveBlock",
  "functionId": "moveBlock___blkMovingInfo-BlockMovingInfo__saslClient-SaslDataTransferClient__eb-ExtendedBlock__sock-Socket__km-DataEncryptionKeyFactory__accessToken-Token__BlockTokenIdentifier__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/sps/BlockDispatcher.java",
  "functionStartLine": 102,
  "functionEndLine": 165,
  "numCommitsSeen": 1,
  "timeTaken": 1162,
  "changeHistory": [
    "b0cb8d9bb44c963ae686d2b5c1b70bc76b955e10"
  ],
  "changeHistoryShort": {
    "b0cb8d9bb44c963ae686d2b5c1b70bc76b955e10": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b0cb8d9bb44c963ae686d2b5c1b70bc76b955e10": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-13033: [SPS]: Implement a mechanism to do file block movements for external SPS. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "b0cb8d9bb44c963ae686d2b5c1b70bc76b955e10",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,64 @@\n+  public BlockMovementStatus moveBlock(BlockMovingInfo blkMovingInfo,\n+      SaslDataTransferClient saslClient, ExtendedBlock eb, Socket sock,\n+      DataEncryptionKeyFactory km, Token\u003cBlockTokenIdentifier\u003e accessToken) {\n+    LOG.info(\"Start moving block:{} from src:{} to destin:{} to satisfy \"\n+        + \"storageType, sourceStoragetype:{} and destinStoragetype:{}\",\n+        blkMovingInfo.getBlock(), blkMovingInfo.getSource(),\n+        blkMovingInfo.getTarget(), blkMovingInfo.getSourceStorageType(),\n+        blkMovingInfo.getTargetStorageType());\n+    DataOutputStream out \u003d null;\n+    DataInputStream in \u003d null;\n+    try {\n+      NetUtils.connect(sock,\n+          NetUtils.createSocketAddr(\n+              blkMovingInfo.getTarget().getXferAddr(connectToDnViaHostname)),\n+          socketTimeout);\n+      // Set read timeout so that it doesn\u0027t hang forever against\n+      // unresponsive nodes. Datanode normally sends IN_PROGRESS response\n+      // twice within the client read timeout period (every 30 seconds by\n+      // default). Here, we make it give up after \"socketTimeout * 5\" period\n+      // of no response.\n+      sock.setSoTimeout(socketTimeout * 5);\n+      sock.setKeepAlive(true);\n+      OutputStream unbufOut \u003d sock.getOutputStream();\n+      InputStream unbufIn \u003d sock.getInputStream();\n+      LOG.debug(\"Connecting to datanode {}\", blkMovingInfo.getTarget());\n+\n+      IOStreamPair saslStreams \u003d saslClient.socketSend(sock, unbufOut,\n+          unbufIn, km, accessToken, blkMovingInfo.getTarget());\n+      unbufOut \u003d saslStreams.out;\n+      unbufIn \u003d saslStreams.in;\n+      out \u003d new DataOutputStream(\n+          new BufferedOutputStream(unbufOut, ioFileBufferSize));\n+      in \u003d new DataInputStream(\n+          new BufferedInputStream(unbufIn, ioFileBufferSize));\n+      sendRequest(out, eb, accessToken, blkMovingInfo.getSource(),\n+          blkMovingInfo.getTargetStorageType());\n+      receiveResponse(in);\n+\n+      LOG.info(\n+          \"Successfully moved block:{} from src:{} to destin:{} for\"\n+              + \" satisfying storageType:{}\",\n+          blkMovingInfo.getBlock(), blkMovingInfo.getSource(),\n+          blkMovingInfo.getTarget(), blkMovingInfo.getTargetStorageType());\n+      return BlockMovementStatus.DN_BLK_STORAGE_MOVEMENT_SUCCESS;\n+    } catch (BlockPinningException e) {\n+      // Pinned block won\u0027t be able to move to a different node. So, its not\n+      // required to do retries, just marked as SUCCESS.\n+      LOG.debug(\"Pinned block can\u0027t be moved, so skipping block:{}\",\n+          blkMovingInfo.getBlock(), e);\n+      return BlockMovementStatus.DN_BLK_STORAGE_MOVEMENT_SUCCESS;\n+    } catch (IOException e) {\n+      // TODO: handle failure retries\n+      LOG.warn(\n+          \"Failed to move block:{} from src:{} to destin:{} to satisfy \"\n+              + \"storageType:{}\",\n+          blkMovingInfo.getBlock(), blkMovingInfo.getSource(),\n+          blkMovingInfo.getTarget(), blkMovingInfo.getTargetStorageType(), e);\n+      return BlockMovementStatus.DN_BLK_STORAGE_MOVEMENT_FAILURE;\n+    } finally {\n+      IOUtils.closeStream(out);\n+      IOUtils.closeStream(in);\n+      IOUtils.closeSocket(sock);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public BlockMovementStatus moveBlock(BlockMovingInfo blkMovingInfo,\n      SaslDataTransferClient saslClient, ExtendedBlock eb, Socket sock,\n      DataEncryptionKeyFactory km, Token\u003cBlockTokenIdentifier\u003e accessToken) {\n    LOG.info(\"Start moving block:{} from src:{} to destin:{} to satisfy \"\n        + \"storageType, sourceStoragetype:{} and destinStoragetype:{}\",\n        blkMovingInfo.getBlock(), blkMovingInfo.getSource(),\n        blkMovingInfo.getTarget(), blkMovingInfo.getSourceStorageType(),\n        blkMovingInfo.getTargetStorageType());\n    DataOutputStream out \u003d null;\n    DataInputStream in \u003d null;\n    try {\n      NetUtils.connect(sock,\n          NetUtils.createSocketAddr(\n              blkMovingInfo.getTarget().getXferAddr(connectToDnViaHostname)),\n          socketTimeout);\n      // Set read timeout so that it doesn\u0027t hang forever against\n      // unresponsive nodes. Datanode normally sends IN_PROGRESS response\n      // twice within the client read timeout period (every 30 seconds by\n      // default). Here, we make it give up after \"socketTimeout * 5\" period\n      // of no response.\n      sock.setSoTimeout(socketTimeout * 5);\n      sock.setKeepAlive(true);\n      OutputStream unbufOut \u003d sock.getOutputStream();\n      InputStream unbufIn \u003d sock.getInputStream();\n      LOG.debug(\"Connecting to datanode {}\", blkMovingInfo.getTarget());\n\n      IOStreamPair saslStreams \u003d saslClient.socketSend(sock, unbufOut,\n          unbufIn, km, accessToken, blkMovingInfo.getTarget());\n      unbufOut \u003d saslStreams.out;\n      unbufIn \u003d saslStreams.in;\n      out \u003d new DataOutputStream(\n          new BufferedOutputStream(unbufOut, ioFileBufferSize));\n      in \u003d new DataInputStream(\n          new BufferedInputStream(unbufIn, ioFileBufferSize));\n      sendRequest(out, eb, accessToken, blkMovingInfo.getSource(),\n          blkMovingInfo.getTargetStorageType());\n      receiveResponse(in);\n\n      LOG.info(\n          \"Successfully moved block:{} from src:{} to destin:{} for\"\n              + \" satisfying storageType:{}\",\n          blkMovingInfo.getBlock(), blkMovingInfo.getSource(),\n          blkMovingInfo.getTarget(), blkMovingInfo.getTargetStorageType());\n      return BlockMovementStatus.DN_BLK_STORAGE_MOVEMENT_SUCCESS;\n    } catch (BlockPinningException e) {\n      // Pinned block won\u0027t be able to move to a different node. So, its not\n      // required to do retries, just marked as SUCCESS.\n      LOG.debug(\"Pinned block can\u0027t be moved, so skipping block:{}\",\n          blkMovingInfo.getBlock(), e);\n      return BlockMovementStatus.DN_BLK_STORAGE_MOVEMENT_SUCCESS;\n    } catch (IOException e) {\n      // TODO: handle failure retries\n      LOG.warn(\n          \"Failed to move block:{} from src:{} to destin:{} to satisfy \"\n              + \"storageType:{}\",\n          blkMovingInfo.getBlock(), blkMovingInfo.getSource(),\n          blkMovingInfo.getTarget(), blkMovingInfo.getTargetStorageType(), e);\n      return BlockMovementStatus.DN_BLK_STORAGE_MOVEMENT_FAILURE;\n    } finally {\n      IOUtils.closeStream(out);\n      IOUtils.closeStream(in);\n      IOUtils.closeSocket(sock);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/sps/BlockDispatcher.java"
    }
  }
}