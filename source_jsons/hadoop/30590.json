{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LeveldbTimelineStore.java",
  "functionName": "getEntity",
  "functionId": "getEntity___entityId-String__entityType-String__startTime-Long__fields-EnumSet__Field____iterator-LeveldbIterator__prefix-byte[]__prefixlen-int",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
  "functionStartLine": 404,
  "functionEndLine": 489,
  "numCommitsSeen": 29,
  "timeTaken": 2809,
  "changeHistory": [
    "7f07c4d81023e3bf4bf8980e64cc9420ec31cf55",
    "241d3b3a50c6af92f023d8b2c24598f4813f4674",
    "1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1",
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
    "b3ea4aebff42131642af0393748dc751cb3fc31e",
    "84425fb435cb603fd8adcc2f76631c0244175310"
  ],
  "changeHistoryShort": {
    "7f07c4d81023e3bf4bf8980e64cc9420ec31cf55": "Ybodychange",
    "241d3b3a50c6af92f023d8b2c24598f4813f4674": "Ybodychange",
    "1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1": "Yparameterchange",
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614": "Ybodychange",
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c": "Yfilerename",
    "b3ea4aebff42131642af0393748dc751cb3fc31e": "Ybodychange",
    "84425fb435cb603fd8adcc2f76631c0244175310": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7f07c4d81023e3bf4bf8980e64cc9420ec31cf55": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3530. ATS throws exception on trying to filter results without\notherinfo. Contributed by zhijie shen\n",
      "commitDate": "27/04/15 10:36 AM",
      "commitName": "7f07c4d81023e3bf4bf8980e64cc9420ec31cf55",
      "commitAuthor": "Xuan",
      "commitDateOld": "13/03/15 10:04 AM",
      "commitNameOld": "8180e676abb2bb500a48b3a0c0809d2a807ab235",
      "commitAuthorOld": "Jonathan Eagles",
      "daysBetweenCommits": 45.02,
      "commitsBetweenForRepo": 407,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,86 @@\n   private static TimelineEntity getEntity(String entityId, String entityType,\n       Long startTime, EnumSet\u003cField\u003e fields, LeveldbIterator iterator,\n       byte[] prefix, int prefixlen) throws IOException {\n-    if (fields \u003d\u003d null) {\n-      fields \u003d EnumSet.allOf(Field.class);\n-    }\n-\n     TimelineEntity entity \u003d new TimelineEntity();\n     boolean events \u003d false;\n     boolean lastEvent \u003d false;\n     if (fields.contains(Field.EVENTS)) {\n       events \u003d true;\n     } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n       lastEvent \u003d true;\n     } else {\n       entity.setEvents(null);\n     }\n     boolean relatedEntities \u003d false;\n     if (fields.contains(Field.RELATED_ENTITIES)) {\n       relatedEntities \u003d true;\n     } else {\n       entity.setRelatedEntities(null);\n     }\n     boolean primaryFilters \u003d false;\n     if (fields.contains(Field.PRIMARY_FILTERS)) {\n       primaryFilters \u003d true;\n     } else {\n       entity.setPrimaryFilters(null);\n     }\n     boolean otherInfo \u003d false;\n     if (fields.contains(Field.OTHER_INFO)) {\n       otherInfo \u003d true;\n     } else {\n       entity.setOtherInfo(null);\n     }\n \n     // iterate through the entity\u0027s entry, parsing information if it is part\n     // of a requested field\n     for (; iterator.hasNext(); iterator.next()) {\n       byte[] key \u003d iterator.peekNext().getKey();\n       if (!prefixMatches(prefix, prefixlen, key)) {\n         break;\n       }\n       if (key.length \u003d\u003d prefixlen) {\n         continue;\n       }\n       if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n         if (primaryFilters) {\n           addPrimaryFilter(entity, key,\n               prefixlen + PRIMARY_FILTERS_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n         if (otherInfo) {\n           entity.addOtherInfo(parseRemainingKey(key,\n               prefixlen + OTHER_INFO_COLUMN.length),\n               GenericObjectMapper.read(iterator.peekNext().getValue()));\n         }\n       } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n         if (relatedEntities) {\n           addRelatedEntity(entity, key,\n               prefixlen + RELATED_ENTITIES_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n         if (events || (lastEvent \u0026\u0026\n             entity.getEvents().size() \u003d\u003d 0)) {\n           TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n               EVENTS_COLUMN.length, iterator.peekNext().getValue());\n           if (event !\u003d null) {\n             entity.addEvent(event);\n           }\n         }\n       } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n         byte[] v \u003d iterator.peekNext().getValue();\n         String domainId \u003d new String(v, Charset.forName(\"UTF-8\"));\n         entity.setDomainId(domainId);\n       } else {\n         if (key[prefixlen] !\u003d\n             INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n           LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n               \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n         }\n       }\n     }\n \n     entity.setEntityId(entityId);\n     entity.setEntityType(entityType);\n     entity.setStartTime(startTime);\n \n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet\u003cField\u003e fields, LeveldbIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    TimelineEntity entity \u003d new TimelineEntity();\n    boolean events \u003d false;\n    boolean lastEvent \u003d false;\n    if (fields.contains(Field.EVENTS)) {\n      events \u003d true;\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent \u003d true;\n    } else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities \u003d false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities \u003d true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters \u003d false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters \u003d true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo \u003d false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo \u003d true;\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity\u0027s entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key \u003d iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key)) {\n        break;\n      }\n      if (key.length \u003d\u003d prefixlen) {\n        continue;\n      }\n      if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key,\n              prefixlen + PRIMARY_FILTERS_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          entity.addOtherInfo(parseRemainingKey(key,\n              prefixlen + OTHER_INFO_COLUMN.length),\n              GenericObjectMapper.read(iterator.peekNext().getValue()));\n        }\n      } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key,\n              prefixlen + RELATED_ENTITIES_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n        if (events || (lastEvent \u0026\u0026\n            entity.getEvents().size() \u003d\u003d 0)) {\n          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n              EVENTS_COLUMN.length, iterator.peekNext().getValue());\n          if (event !\u003d null) {\n            entity.addEvent(event);\n          }\n        }\n      } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n        byte[] v \u003d iterator.peekNext().getValue();\n        String domainId \u003d new String(v, Charset.forName(\"UTF-8\"));\n        entity.setDomainId(domainId);\n      } else {\n        if (key[prefixlen] !\u003d\n            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n          LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n              \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n        }\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "241d3b3a50c6af92f023d8b2c24598f4813f4674": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2938. Fixed new findbugs warnings in hadoop-yarn-resourcemanager and hadoop-yarn-applicationhistoryservice. Contributed by Varun Saxena.\n",
      "commitDate": "29/12/14 9:59 AM",
      "commitName": "241d3b3a50c6af92f023d8b2c24598f4813f4674",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "23/12/14 6:25 PM",
      "commitNameOld": "149512a83743715bb100feb6747b7e88301018ab",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n   private static TimelineEntity getEntity(String entityId, String entityType,\n       Long startTime, EnumSet\u003cField\u003e fields, LeveldbIterator iterator,\n       byte[] prefix, int prefixlen) throws IOException {\n     if (fields \u003d\u003d null) {\n       fields \u003d EnumSet.allOf(Field.class);\n     }\n \n     TimelineEntity entity \u003d new TimelineEntity();\n     boolean events \u003d false;\n     boolean lastEvent \u003d false;\n     if (fields.contains(Field.EVENTS)) {\n       events \u003d true;\n     } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n       lastEvent \u003d true;\n     } else {\n       entity.setEvents(null);\n     }\n     boolean relatedEntities \u003d false;\n     if (fields.contains(Field.RELATED_ENTITIES)) {\n       relatedEntities \u003d true;\n     } else {\n       entity.setRelatedEntities(null);\n     }\n     boolean primaryFilters \u003d false;\n     if (fields.contains(Field.PRIMARY_FILTERS)) {\n       primaryFilters \u003d true;\n     } else {\n       entity.setPrimaryFilters(null);\n     }\n     boolean otherInfo \u003d false;\n     if (fields.contains(Field.OTHER_INFO)) {\n       otherInfo \u003d true;\n     } else {\n       entity.setOtherInfo(null);\n     }\n \n     // iterate through the entity\u0027s entry, parsing information if it is part\n     // of a requested field\n     for (; iterator.hasNext(); iterator.next()) {\n       byte[] key \u003d iterator.peekNext().getKey();\n       if (!prefixMatches(prefix, prefixlen, key)) {\n         break;\n       }\n       if (key.length \u003d\u003d prefixlen) {\n         continue;\n       }\n       if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n         if (primaryFilters) {\n           addPrimaryFilter(entity, key,\n               prefixlen + PRIMARY_FILTERS_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n         if (otherInfo) {\n           entity.addOtherInfo(parseRemainingKey(key,\n               prefixlen + OTHER_INFO_COLUMN.length),\n               GenericObjectMapper.read(iterator.peekNext().getValue()));\n         }\n       } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n         if (relatedEntities) {\n           addRelatedEntity(entity, key,\n               prefixlen + RELATED_ENTITIES_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n         if (events || (lastEvent \u0026\u0026\n             entity.getEvents().size() \u003d\u003d 0)) {\n           TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n               EVENTS_COLUMN.length, iterator.peekNext().getValue());\n           if (event !\u003d null) {\n             entity.addEvent(event);\n           }\n         }\n       } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n         byte[] v \u003d iterator.peekNext().getValue();\n-        String domainId \u003d new String(v);\n+        String domainId \u003d new String(v, Charset.forName(\"UTF-8\"));\n         entity.setDomainId(domainId);\n       } else {\n         if (key[prefixlen] !\u003d\n             INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n           LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n               \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n         }\n       }\n     }\n \n     entity.setEntityId(entityId);\n     entity.setEntityType(entityType);\n     entity.setStartTime(startTime);\n \n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet\u003cField\u003e fields, LeveldbIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    if (fields \u003d\u003d null) {\n      fields \u003d EnumSet.allOf(Field.class);\n    }\n\n    TimelineEntity entity \u003d new TimelineEntity();\n    boolean events \u003d false;\n    boolean lastEvent \u003d false;\n    if (fields.contains(Field.EVENTS)) {\n      events \u003d true;\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent \u003d true;\n    } else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities \u003d false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities \u003d true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters \u003d false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters \u003d true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo \u003d false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo \u003d true;\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity\u0027s entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key \u003d iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key)) {\n        break;\n      }\n      if (key.length \u003d\u003d prefixlen) {\n        continue;\n      }\n      if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key,\n              prefixlen + PRIMARY_FILTERS_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          entity.addOtherInfo(parseRemainingKey(key,\n              prefixlen + OTHER_INFO_COLUMN.length),\n              GenericObjectMapper.read(iterator.peekNext().getValue()));\n        }\n      } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key,\n              prefixlen + RELATED_ENTITIES_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n        if (events || (lastEvent \u0026\u0026\n            entity.getEvents().size() \u003d\u003d 0)) {\n          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n              EVENTS_COLUMN.length, iterator.peekNext().getValue());\n          if (event !\u003d null) {\n            entity.addEvent(event);\n          }\n        }\n      } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n        byte[] v \u003d iterator.peekNext().getValue();\n        String domainId \u003d new String(v, Charset.forName(\"UTF-8\"));\n        entity.setDomainId(domainId);\n      } else {\n        if (key[prefixlen] !\u003d\n            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n          LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n              \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n        }\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-1984. LeveldbTimelineStore does not handle db exceptions properly. Contributed by Varun Saxena\n",
      "commitDate": "24/11/14 2:36 PM",
      "commitName": "1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "07/11/14 4:11 PM",
      "commitNameOld": "4a114dd67aae83e5bb2d65470166de954acf36a2",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 16.93,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n   private static TimelineEntity getEntity(String entityId, String entityType,\n-      Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n+      Long startTime, EnumSet\u003cField\u003e fields, LeveldbIterator iterator,\n       byte[] prefix, int prefixlen) throws IOException {\n     if (fields \u003d\u003d null) {\n       fields \u003d EnumSet.allOf(Field.class);\n     }\n \n     TimelineEntity entity \u003d new TimelineEntity();\n     boolean events \u003d false;\n     boolean lastEvent \u003d false;\n     if (fields.contains(Field.EVENTS)) {\n       events \u003d true;\n     } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n       lastEvent \u003d true;\n     } else {\n       entity.setEvents(null);\n     }\n     boolean relatedEntities \u003d false;\n     if (fields.contains(Field.RELATED_ENTITIES)) {\n       relatedEntities \u003d true;\n     } else {\n       entity.setRelatedEntities(null);\n     }\n     boolean primaryFilters \u003d false;\n     if (fields.contains(Field.PRIMARY_FILTERS)) {\n       primaryFilters \u003d true;\n     } else {\n       entity.setPrimaryFilters(null);\n     }\n     boolean otherInfo \u003d false;\n     if (fields.contains(Field.OTHER_INFO)) {\n       otherInfo \u003d true;\n     } else {\n       entity.setOtherInfo(null);\n     }\n \n     // iterate through the entity\u0027s entry, parsing information if it is part\n     // of a requested field\n     for (; iterator.hasNext(); iterator.next()) {\n       byte[] key \u003d iterator.peekNext().getKey();\n       if (!prefixMatches(prefix, prefixlen, key)) {\n         break;\n       }\n       if (key.length \u003d\u003d prefixlen) {\n         continue;\n       }\n       if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n         if (primaryFilters) {\n           addPrimaryFilter(entity, key,\n               prefixlen + PRIMARY_FILTERS_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n         if (otherInfo) {\n           entity.addOtherInfo(parseRemainingKey(key,\n               prefixlen + OTHER_INFO_COLUMN.length),\n               GenericObjectMapper.read(iterator.peekNext().getValue()));\n         }\n       } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n         if (relatedEntities) {\n           addRelatedEntity(entity, key,\n               prefixlen + RELATED_ENTITIES_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n         if (events || (lastEvent \u0026\u0026\n             entity.getEvents().size() \u003d\u003d 0)) {\n           TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n               EVENTS_COLUMN.length, iterator.peekNext().getValue());\n           if (event !\u003d null) {\n             entity.addEvent(event);\n           }\n         }\n       } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n         byte[] v \u003d iterator.peekNext().getValue();\n         String domainId \u003d new String(v);\n         entity.setDomainId(domainId);\n       } else {\n         if (key[prefixlen] !\u003d\n             INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n           LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n               \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n         }\n       }\n     }\n \n     entity.setEntityId(entityId);\n     entity.setEntityType(entityType);\n     entity.setStartTime(startTime);\n \n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet\u003cField\u003e fields, LeveldbIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    if (fields \u003d\u003d null) {\n      fields \u003d EnumSet.allOf(Field.class);\n    }\n\n    TimelineEntity entity \u003d new TimelineEntity();\n    boolean events \u003d false;\n    boolean lastEvent \u003d false;\n    if (fields.contains(Field.EVENTS)) {\n      events \u003d true;\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent \u003d true;\n    } else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities \u003d false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities \u003d true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters \u003d false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters \u003d true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo \u003d false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo \u003d true;\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity\u0027s entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key \u003d iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key)) {\n        break;\n      }\n      if (key.length \u003d\u003d prefixlen) {\n        continue;\n      }\n      if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key,\n              prefixlen + PRIMARY_FILTERS_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          entity.addOtherInfo(parseRemainingKey(key,\n              prefixlen + OTHER_INFO_COLUMN.length),\n              GenericObjectMapper.read(iterator.peekNext().getValue()));\n        }\n      } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key,\n              prefixlen + RELATED_ENTITIES_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n        if (events || (lastEvent \u0026\u0026\n            entity.getEvents().size() \u003d\u003d 0)) {\n          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n              EVENTS_COLUMN.length, iterator.peekNext().getValue());\n          if (event !\u003d null) {\n            entity.addEvent(event);\n          }\n        }\n      } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n        byte[] v \u003d iterator.peekNext().getValue();\n        String domainId \u003d new String(v);\n        entity.setDomainId(domainId);\n      } else {\n        if (key[prefixlen] !\u003d\n            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n          LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n              \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n        }\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {
        "oldValue": "[entityId-String, entityType-String, startTime-Long, fields-EnumSet\u003cField\u003e, iterator-DBIterator, prefix-byte[], prefixlen-int]",
        "newValue": "[entityId-String, entityType-String, startTime-Long, fields-EnumSet\u003cField\u003e, iterator-LeveldbIterator, prefix-byte[], prefixlen-int]"
      }
    },
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2446. Augmented Timeline service APIs to start taking in domains as a parameter while posting entities and events. Contributed by Zhijie Shen.\n",
      "commitDate": "01/10/14 5:52 PM",
      "commitName": "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/09/14 11:27 AM",
      "commitNameOld": "d78b452a4f413c6931a494c33df0666ce9b44973",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.27,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,90 @@\n   private static TimelineEntity getEntity(String entityId, String entityType,\n       Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n       byte[] prefix, int prefixlen) throws IOException {\n     if (fields \u003d\u003d null) {\n       fields \u003d EnumSet.allOf(Field.class);\n     }\n \n     TimelineEntity entity \u003d new TimelineEntity();\n     boolean events \u003d false;\n     boolean lastEvent \u003d false;\n     if (fields.contains(Field.EVENTS)) {\n       events \u003d true;\n     } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n       lastEvent \u003d true;\n     } else {\n       entity.setEvents(null);\n     }\n     boolean relatedEntities \u003d false;\n     if (fields.contains(Field.RELATED_ENTITIES)) {\n       relatedEntities \u003d true;\n     } else {\n       entity.setRelatedEntities(null);\n     }\n     boolean primaryFilters \u003d false;\n     if (fields.contains(Field.PRIMARY_FILTERS)) {\n       primaryFilters \u003d true;\n     } else {\n       entity.setPrimaryFilters(null);\n     }\n     boolean otherInfo \u003d false;\n     if (fields.contains(Field.OTHER_INFO)) {\n       otherInfo \u003d true;\n     } else {\n       entity.setOtherInfo(null);\n     }\n \n     // iterate through the entity\u0027s entry, parsing information if it is part\n     // of a requested field\n     for (; iterator.hasNext(); iterator.next()) {\n       byte[] key \u003d iterator.peekNext().getKey();\n       if (!prefixMatches(prefix, prefixlen, key)) {\n         break;\n       }\n       if (key.length \u003d\u003d prefixlen) {\n         continue;\n       }\n       if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n         if (primaryFilters) {\n           addPrimaryFilter(entity, key,\n               prefixlen + PRIMARY_FILTERS_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n         if (otherInfo) {\n           entity.addOtherInfo(parseRemainingKey(key,\n               prefixlen + OTHER_INFO_COLUMN.length),\n               GenericObjectMapper.read(iterator.peekNext().getValue()));\n         }\n       } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n         if (relatedEntities) {\n           addRelatedEntity(entity, key,\n               prefixlen + RELATED_ENTITIES_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n         if (events || (lastEvent \u0026\u0026\n             entity.getEvents().size() \u003d\u003d 0)) {\n           TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n               EVENTS_COLUMN.length, iterator.peekNext().getValue());\n           if (event !\u003d null) {\n             entity.addEvent(event);\n           }\n         }\n+      } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n+        byte[] v \u003d iterator.peekNext().getValue();\n+        String domainId \u003d new String(v);\n+        entity.setDomainId(domainId);\n       } else {\n         if (key[prefixlen] !\u003d\n             INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n           LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n               \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n         }\n       }\n     }\n \n     entity.setEntityId(entityId);\n     entity.setEntityType(entityType);\n     entity.setStartTime(startTime);\n \n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    if (fields \u003d\u003d null) {\n      fields \u003d EnumSet.allOf(Field.class);\n    }\n\n    TimelineEntity entity \u003d new TimelineEntity();\n    boolean events \u003d false;\n    boolean lastEvent \u003d false;\n    if (fields.contains(Field.EVENTS)) {\n      events \u003d true;\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent \u003d true;\n    } else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities \u003d false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities \u003d true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters \u003d false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters \u003d true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo \u003d false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo \u003d true;\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity\u0027s entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key \u003d iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key)) {\n        break;\n      }\n      if (key.length \u003d\u003d prefixlen) {\n        continue;\n      }\n      if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key,\n              prefixlen + PRIMARY_FILTERS_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          entity.addOtherInfo(parseRemainingKey(key,\n              prefixlen + OTHER_INFO_COLUMN.length),\n              GenericObjectMapper.read(iterator.peekNext().getValue()));\n        }\n      } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key,\n              prefixlen + RELATED_ENTITIES_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n        if (events || (lastEvent \u0026\u0026\n            entity.getEvents().size() \u003d\u003d 0)) {\n          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n              EVENTS_COLUMN.length, iterator.peekNext().getValue());\n          if (event !\u003d null) {\n            entity.addEvent(event);\n          }\n        }\n      } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n        byte[] v \u003d iterator.peekNext().getValue();\n        String domainId \u003d new String(v);\n        entity.setDomainId(domainId);\n      } else {\n        if (key[prefixlen] !\u003d\n            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n          LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n              \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n        }\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c": {
      "type": "Yfilerename",
      "commitMessage": "YARN-2107. Refactored timeline classes into o.a.h.y.s.timeline package. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598094 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/05/14 11:09 AM",
      "commitName": "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "28/05/14 10:44 AM",
      "commitNameOld": "cfd8647d0f20c08761f908be1f5b718c1c372498",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    if (fields \u003d\u003d null) {\n      fields \u003d EnumSet.allOf(Field.class);\n    }\n\n    TimelineEntity entity \u003d new TimelineEntity();\n    boolean events \u003d false;\n    boolean lastEvent \u003d false;\n    if (fields.contains(Field.EVENTS)) {\n      events \u003d true;\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent \u003d true;\n    } else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities \u003d false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities \u003d true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters \u003d false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters \u003d true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo \u003d false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo \u003d true;\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity\u0027s entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key \u003d iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key)) {\n        break;\n      }\n      if (key.length \u003d\u003d prefixlen) {\n        continue;\n      }\n      if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key,\n              prefixlen + PRIMARY_FILTERS_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          entity.addOtherInfo(parseRemainingKey(key,\n              prefixlen + OTHER_INFO_COLUMN.length),\n              GenericObjectMapper.read(iterator.peekNext().getValue()));\n        }\n      } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key,\n              prefixlen + RELATED_ENTITIES_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n        if (events || (lastEvent \u0026\u0026\n            entity.getEvents().size() \u003d\u003d 0)) {\n          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n              EVENTS_COLUMN.length, iterator.peekNext().getValue());\n          if (event !\u003d null) {\n            entity.addEvent(event);\n          }\n        }\n      } else {\n        if (key[prefixlen] !\u003d\n            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n          LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n              \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n        }\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/LeveldbTimelineStore.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java"
      }
    },
    "b3ea4aebff42131642af0393748dc751cb3fc31e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1717. Enabled periodically discarding old data in LeveldbTimelineStore. Contributed by Billie Rinaldi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1577693 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/03/14 1:35 PM",
      "commitName": "b3ea4aebff42131642af0393748dc751cb3fc31e",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "04/03/14 9:32 AM",
      "commitNameOld": "40464fba22bac99d0e5b79674152aa5dfba99483",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 10.13,
      "commitsBetweenForRepo": 99,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,86 @@\n   private static TimelineEntity getEntity(String entityId, String entityType,\n       Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n       byte[] prefix, int prefixlen) throws IOException {\n-    if (fields \u003d\u003d null)\n+    if (fields \u003d\u003d null) {\n       fields \u003d EnumSet.allOf(Field.class);\n+    }\n \n     TimelineEntity entity \u003d new TimelineEntity();\n     boolean events \u003d false;\n     boolean lastEvent \u003d false;\n     if (fields.contains(Field.EVENTS)) {\n       events \u003d true;\n-      entity.setEvents(new ArrayList\u003cTimelineEvent\u003e());\n     } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n       lastEvent \u003d true;\n-      entity.setEvents(new ArrayList\u003cTimelineEvent\u003e());\n-    }\n-    else {\n+    } else {\n       entity.setEvents(null);\n     }\n     boolean relatedEntities \u003d false;\n     if (fields.contains(Field.RELATED_ENTITIES)) {\n       relatedEntities \u003d true;\n     } else {\n       entity.setRelatedEntities(null);\n     }\n     boolean primaryFilters \u003d false;\n     if (fields.contains(Field.PRIMARY_FILTERS)) {\n       primaryFilters \u003d true;\n     } else {\n       entity.setPrimaryFilters(null);\n     }\n     boolean otherInfo \u003d false;\n     if (fields.contains(Field.OTHER_INFO)) {\n       otherInfo \u003d true;\n-      entity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n     } else {\n       entity.setOtherInfo(null);\n     }\n \n     // iterate through the entity\u0027s entry, parsing information if it is part\n     // of a requested field\n     for (; iterator.hasNext(); iterator.next()) {\n       byte[] key \u003d iterator.peekNext().getKey();\n-      if (!prefixMatches(prefix, prefixlen, key))\n+      if (!prefixMatches(prefix, prefixlen, key)) {\n         break;\n-      if (key[prefixlen] \u003d\u003d PRIMARY_FILTER_COLUMN[0]) {\n+      }\n+      if (key.length \u003d\u003d prefixlen) {\n+        continue;\n+      }\n+      if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n         if (primaryFilters) {\n           addPrimaryFilter(entity, key,\n-              prefixlen + PRIMARY_FILTER_COLUMN.length);\n+              prefixlen + PRIMARY_FILTERS_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n         if (otherInfo) {\n           entity.addOtherInfo(parseRemainingKey(key,\n               prefixlen + OTHER_INFO_COLUMN.length),\n               GenericObjectMapper.read(iterator.peekNext().getValue()));\n         }\n-      } else if (key[prefixlen] \u003d\u003d RELATED_COLUMN[0]) {\n+      } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n         if (relatedEntities) {\n           addRelatedEntity(entity, key,\n-              prefixlen + RELATED_COLUMN.length);\n+              prefixlen + RELATED_ENTITIES_COLUMN.length);\n         }\n-      } else if (key[prefixlen] \u003d\u003d TIME_COLUMN[0]) {\n-        if (events || (lastEvent \u0026\u0026 entity.getEvents().size() \u003d\u003d 0)) {\n+      } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n+        if (events || (lastEvent \u0026\u0026\n+            entity.getEvents().size() \u003d\u003d 0)) {\n           TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n-              TIME_COLUMN.length, iterator.peekNext().getValue());\n+              EVENTS_COLUMN.length, iterator.peekNext().getValue());\n           if (event !\u003d null) {\n             entity.addEvent(event);\n           }\n         }\n       } else {\n-        LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n-            \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n+        if (key[prefixlen] !\u003d\n+            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n+          LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n+              \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n+        }\n       }\n     }\n \n     entity.setEntityId(entityId);\n     entity.setEntityType(entityType);\n     entity.setStartTime(startTime);\n \n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    if (fields \u003d\u003d null) {\n      fields \u003d EnumSet.allOf(Field.class);\n    }\n\n    TimelineEntity entity \u003d new TimelineEntity();\n    boolean events \u003d false;\n    boolean lastEvent \u003d false;\n    if (fields.contains(Field.EVENTS)) {\n      events \u003d true;\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent \u003d true;\n    } else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities \u003d false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities \u003d true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters \u003d false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters \u003d true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo \u003d false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo \u003d true;\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity\u0027s entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key \u003d iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key)) {\n        break;\n      }\n      if (key.length \u003d\u003d prefixlen) {\n        continue;\n      }\n      if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key,\n              prefixlen + PRIMARY_FILTERS_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          entity.addOtherInfo(parseRemainingKey(key,\n              prefixlen + OTHER_INFO_COLUMN.length),\n              GenericObjectMapper.read(iterator.peekNext().getValue()));\n        }\n      } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key,\n              prefixlen + RELATED_ENTITIES_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n        if (events || (lastEvent \u0026\u0026\n            entity.getEvents().size() \u003d\u003d 0)) {\n          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n              EVENTS_COLUMN.length, iterator.peekNext().getValue());\n          if (event !\u003d null) {\n            entity.addEvent(event);\n          }\n        }\n      } else {\n        if (key[prefixlen] !\u003d\n            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n          LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n              \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n        }\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "84425fb435cb603fd8adcc2f76631c0244175310": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1687. Renamed user-facing records for the timeline-service to be simply named after \u0027timeline\u0027 instead of \u0027apptimeline\u0027. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570922 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/02/14 12:55 PM",
      "commitName": "84425fb435cb603fd8adcc2f76631c0244175310",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,81 @@\n+  private static TimelineEntity getEntity(String entityId, String entityType,\n+      Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n+      byte[] prefix, int prefixlen) throws IOException {\n+    if (fields \u003d\u003d null)\n+      fields \u003d EnumSet.allOf(Field.class);\n+\n+    TimelineEntity entity \u003d new TimelineEntity();\n+    boolean events \u003d false;\n+    boolean lastEvent \u003d false;\n+    if (fields.contains(Field.EVENTS)) {\n+      events \u003d true;\n+      entity.setEvents(new ArrayList\u003cTimelineEvent\u003e());\n+    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n+      lastEvent \u003d true;\n+      entity.setEvents(new ArrayList\u003cTimelineEvent\u003e());\n+    }\n+    else {\n+      entity.setEvents(null);\n+    }\n+    boolean relatedEntities \u003d false;\n+    if (fields.contains(Field.RELATED_ENTITIES)) {\n+      relatedEntities \u003d true;\n+    } else {\n+      entity.setRelatedEntities(null);\n+    }\n+    boolean primaryFilters \u003d false;\n+    if (fields.contains(Field.PRIMARY_FILTERS)) {\n+      primaryFilters \u003d true;\n+    } else {\n+      entity.setPrimaryFilters(null);\n+    }\n+    boolean otherInfo \u003d false;\n+    if (fields.contains(Field.OTHER_INFO)) {\n+      otherInfo \u003d true;\n+      entity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n+    } else {\n+      entity.setOtherInfo(null);\n+    }\n+\n+    // iterate through the entity\u0027s entry, parsing information if it is part\n+    // of a requested field\n+    for (; iterator.hasNext(); iterator.next()) {\n+      byte[] key \u003d iterator.peekNext().getKey();\n+      if (!prefixMatches(prefix, prefixlen, key))\n+        break;\n+      if (key[prefixlen] \u003d\u003d PRIMARY_FILTER_COLUMN[0]) {\n+        if (primaryFilters) {\n+          addPrimaryFilter(entity, key,\n+              prefixlen + PRIMARY_FILTER_COLUMN.length);\n+        }\n+      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n+        if (otherInfo) {\n+          entity.addOtherInfo(parseRemainingKey(key,\n+              prefixlen + OTHER_INFO_COLUMN.length),\n+              GenericObjectMapper.read(iterator.peekNext().getValue()));\n+        }\n+      } else if (key[prefixlen] \u003d\u003d RELATED_COLUMN[0]) {\n+        if (relatedEntities) {\n+          addRelatedEntity(entity, key,\n+              prefixlen + RELATED_COLUMN.length);\n+        }\n+      } else if (key[prefixlen] \u003d\u003d TIME_COLUMN[0]) {\n+        if (events || (lastEvent \u0026\u0026 entity.getEvents().size() \u003d\u003d 0)) {\n+          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n+              TIME_COLUMN.length, iterator.peekNext().getValue());\n+          if (event !\u003d null) {\n+            entity.addEvent(event);\n+          }\n+        }\n+      } else {\n+        LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n+            \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n+      }\n+    }\n+\n+    entity.setEntityId(entityId);\n+    entity.setEntityType(entityType);\n+    entity.setStartTime(startTime);\n+\n+    return entity;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    if (fields \u003d\u003d null)\n      fields \u003d EnumSet.allOf(Field.class);\n\n    TimelineEntity entity \u003d new TimelineEntity();\n    boolean events \u003d false;\n    boolean lastEvent \u003d false;\n    if (fields.contains(Field.EVENTS)) {\n      events \u003d true;\n      entity.setEvents(new ArrayList\u003cTimelineEvent\u003e());\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent \u003d true;\n      entity.setEvents(new ArrayList\u003cTimelineEvent\u003e());\n    }\n    else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities \u003d false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities \u003d true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters \u003d false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters \u003d true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo \u003d false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo \u003d true;\n      entity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity\u0027s entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key \u003d iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key))\n        break;\n      if (key[prefixlen] \u003d\u003d PRIMARY_FILTER_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key,\n              prefixlen + PRIMARY_FILTER_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          entity.addOtherInfo(parseRemainingKey(key,\n              prefixlen + OTHER_INFO_COLUMN.length),\n              GenericObjectMapper.read(iterator.peekNext().getValue()));\n        }\n      } else if (key[prefixlen] \u003d\u003d RELATED_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key,\n              prefixlen + RELATED_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d TIME_COLUMN[0]) {\n        if (events || (lastEvent \u0026\u0026 entity.getEvents().size() \u003d\u003d 0)) {\n          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen +\n              TIME_COLUMN.length, iterator.peekNext().getValue());\n          if (event !\u003d null) {\n            entity.addEvent(event);\n          }\n        }\n      } else {\n        LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n            \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/LeveldbTimelineStore.java"
    }
  }
}