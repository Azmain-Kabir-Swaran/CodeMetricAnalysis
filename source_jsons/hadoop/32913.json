{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NonAggregatingLogHandler.java",
  "functionName": "handle",
  "functionId": "handle___event-LogHandlerEvent",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/loghandler/NonAggregatingLogHandler.java",
  "functionStartLine": 152,
  "functionEndLine": 207,
  "numCommitsSeen": 18,
  "timeTaken": 1766,
  "changeHistory": [
    "81effb7dcde2b31423438d6f1b8b8204d4ca05b3",
    "04f5ef18f7877ce30b12b1a3c1e851c420531b72",
    "785c12056ce2c6161b66699d995bd25198b9194f",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "1cf60106758c482991f08caa136446885d5f8f27",
    "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e"
  ],
  "changeHistoryShort": {
    "81effb7dcde2b31423438d6f1b8b8204d4ca05b3": "Ybodychange",
    "04f5ef18f7877ce30b12b1a3c1e851c420531b72": "Ybodychange",
    "785c12056ce2c6161b66699d995bd25198b9194f": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "1cf60106758c482991f08caa136446885d5f8f27": "Ybodychange",
    "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "81effb7dcde2b31423438d6f1b8b8204d4ca05b3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4325. Nodemanager log handlers fail to send finished/failed events in some cases. Contributed by Junping Du\n",
      "commitDate": "16/05/16 8:40 AM",
      "commitName": "81effb7dcde2b31423438d6f1b8b8204d4ca05b3",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "10/02/16 10:36 PM",
      "commitNameOld": "fa00d3e20560bee412b49e5792595749a247a8ab",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 95.38,
      "commitsBetweenForRepo": 577,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,56 @@\n   public void handle(LogHandlerEvent event) {\n     switch (event.getType()) {\n       case APPLICATION_STARTED:\n         LogHandlerAppStartedEvent appStartedEvent \u003d\n             (LogHandlerAppStartedEvent) event;\n         this.appOwners.put(appStartedEvent.getApplicationId(),\n             appStartedEvent.getUser());\n         this.dispatcher.getEventHandler().handle(\n             new ApplicationEvent(appStartedEvent.getApplicationId(),\n                 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED));\n         break;\n       case CONTAINER_FINISHED:\n         // Ignore\n         break;\n       case APPLICATION_FINISHED:\n         LogHandlerAppFinishedEvent appFinishedEvent \u003d\n             (LogHandlerAppFinishedEvent) event;\n         ApplicationId appId \u003d appFinishedEvent.getApplicationId();\n         // Schedule - so that logs are available on the UI till they\u0027re deleted.\n         LOG.info(\"Scheduling Log Deletion for application: \"\n             + appId + \", with delay of \"\n             + this.deleteDelaySeconds + \" seconds\");\n         String user \u003d appOwners.remove(appId);\n         if (user \u003d\u003d null) {\n           LOG.error(\"Unable to locate user for \" + appId);\n+          // send LOG_HANDLING_FAILED out\n+          NonAggregatingLogHandler.this.dispatcher.getEventHandler().handle(\n+              new ApplicationEvent(appId,\n+                  ApplicationEventType.APPLICATION_LOG_HANDLING_FAILED));\n           break;\n         }\n         LogDeleterRunnable logDeleter \u003d new LogDeleterRunnable(user, appId);\n         long deletionTimestamp \u003d System.currentTimeMillis()\n             + this.deleteDelaySeconds * 1000;\n         LogDeleterProto deleterProto \u003d LogDeleterProto.newBuilder()\n             .setUser(user)\n             .setDeletionTime(deletionTimestamp)\n             .build();\n         try {\n           stateStore.storeLogDeleter(appId, deleterProto);\n         } catch (IOException e) {\n           LOG.error(\"Unable to record log deleter state\", e);\n         }\n         try {\n           sched.schedule(logDeleter, this.deleteDelaySeconds,\n               TimeUnit.SECONDS);\n         } catch (RejectedExecutionException e) {\n           // Handling this event in local thread before starting threads\n           // or after calling sched.shutdownNow().\n           logDeleter.run();\n         }\n         break;\n       default:\n         ; // Ignore\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(LogHandlerEvent event) {\n    switch (event.getType()) {\n      case APPLICATION_STARTED:\n        LogHandlerAppStartedEvent appStartedEvent \u003d\n            (LogHandlerAppStartedEvent) event;\n        this.appOwners.put(appStartedEvent.getApplicationId(),\n            appStartedEvent.getUser());\n        this.dispatcher.getEventHandler().handle(\n            new ApplicationEvent(appStartedEvent.getApplicationId(),\n                ApplicationEventType.APPLICATION_LOG_HANDLING_INITED));\n        break;\n      case CONTAINER_FINISHED:\n        // Ignore\n        break;\n      case APPLICATION_FINISHED:\n        LogHandlerAppFinishedEvent appFinishedEvent \u003d\n            (LogHandlerAppFinishedEvent) event;\n        ApplicationId appId \u003d appFinishedEvent.getApplicationId();\n        // Schedule - so that logs are available on the UI till they\u0027re deleted.\n        LOG.info(\"Scheduling Log Deletion for application: \"\n            + appId + \", with delay of \"\n            + this.deleteDelaySeconds + \" seconds\");\n        String user \u003d appOwners.remove(appId);\n        if (user \u003d\u003d null) {\n          LOG.error(\"Unable to locate user for \" + appId);\n          // send LOG_HANDLING_FAILED out\n          NonAggregatingLogHandler.this.dispatcher.getEventHandler().handle(\n              new ApplicationEvent(appId,\n                  ApplicationEventType.APPLICATION_LOG_HANDLING_FAILED));\n          break;\n        }\n        LogDeleterRunnable logDeleter \u003d new LogDeleterRunnable(user, appId);\n        long deletionTimestamp \u003d System.currentTimeMillis()\n            + this.deleteDelaySeconds * 1000;\n        LogDeleterProto deleterProto \u003d LogDeleterProto.newBuilder()\n            .setUser(user)\n            .setDeletionTime(deletionTimestamp)\n            .build();\n        try {\n          stateStore.storeLogDeleter(appId, deleterProto);\n        } catch (IOException e) {\n          LOG.error(\"Unable to record log deleter state\", e);\n        }\n        try {\n          sched.schedule(logDeleter, this.deleteDelaySeconds,\n              TimeUnit.SECONDS);\n        } catch (RejectedExecutionException e) {\n          // Handling this event in local thread before starting threads\n          // or after calling sched.shutdownNow().\n          logDeleter.run();\n        }\n        break;\n      default:\n        ; // Ignore\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/loghandler/NonAggregatingLogHandler.java",
      "extendedDetails": {}
    },
    "04f5ef18f7877ce30b12b1a3c1e851c420531b72": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2079. Recover NonAggregatingLogHandler state upon nodemanager restart. (Contributed by Jason Lowe)\n",
      "commitDate": "12/02/15 11:46 AM",
      "commitName": "04f5ef18f7877ce30b12b1a3c1e851c420531b72",
      "commitAuthor": "Junping Du",
      "commitDateOld": "21/10/14 10:31 AM",
      "commitNameOld": "6f2028bd1514d90b831f889fd0ee7f2ba5c15000",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 114.09,
      "commitsBetweenForRepo": 891,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,52 @@\n   public void handle(LogHandlerEvent event) {\n     switch (event.getType()) {\n       case APPLICATION_STARTED:\n         LogHandlerAppStartedEvent appStartedEvent \u003d\n             (LogHandlerAppStartedEvent) event;\n         this.appOwners.put(appStartedEvent.getApplicationId(),\n             appStartedEvent.getUser());\n         this.dispatcher.getEventHandler().handle(\n             new ApplicationEvent(appStartedEvent.getApplicationId(),\n                 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED));\n         break;\n       case CONTAINER_FINISHED:\n         // Ignore\n         break;\n       case APPLICATION_FINISHED:\n         LogHandlerAppFinishedEvent appFinishedEvent \u003d\n             (LogHandlerAppFinishedEvent) event;\n+        ApplicationId appId \u003d appFinishedEvent.getApplicationId();\n         // Schedule - so that logs are available on the UI till they\u0027re deleted.\n         LOG.info(\"Scheduling Log Deletion for application: \"\n-            + appFinishedEvent.getApplicationId() + \", with delay of \"\n+            + appId + \", with delay of \"\n             + this.deleteDelaySeconds + \" seconds\");\n-        LogDeleterRunnable logDeleter \u003d\n-            new LogDeleterRunnable(appOwners.remove(appFinishedEvent\n-                  .getApplicationId()), appFinishedEvent.getApplicationId());\n+        String user \u003d appOwners.remove(appId);\n+        if (user \u003d\u003d null) {\n+          LOG.error(\"Unable to locate user for \" + appId);\n+          break;\n+        }\n+        LogDeleterRunnable logDeleter \u003d new LogDeleterRunnable(user, appId);\n+        long deletionTimestamp \u003d System.currentTimeMillis()\n+            + this.deleteDelaySeconds * 1000;\n+        LogDeleterProto deleterProto \u003d LogDeleterProto.newBuilder()\n+            .setUser(user)\n+            .setDeletionTime(deletionTimestamp)\n+            .build();\n+        try {\n+          stateStore.storeLogDeleter(appId, deleterProto);\n+        } catch (IOException e) {\n+          LOG.error(\"Unable to record log deleter state\", e);\n+        }\n         try {\n           sched.schedule(logDeleter, this.deleteDelaySeconds,\n               TimeUnit.SECONDS);\n         } catch (RejectedExecutionException e) {\n           // Handling this event in local thread before starting threads\n           // or after calling sched.shutdownNow().\n           logDeleter.run();\n         }\n         break;\n       default:\n         ; // Ignore\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(LogHandlerEvent event) {\n    switch (event.getType()) {\n      case APPLICATION_STARTED:\n        LogHandlerAppStartedEvent appStartedEvent \u003d\n            (LogHandlerAppStartedEvent) event;\n        this.appOwners.put(appStartedEvent.getApplicationId(),\n            appStartedEvent.getUser());\n        this.dispatcher.getEventHandler().handle(\n            new ApplicationEvent(appStartedEvent.getApplicationId(),\n                ApplicationEventType.APPLICATION_LOG_HANDLING_INITED));\n        break;\n      case CONTAINER_FINISHED:\n        // Ignore\n        break;\n      case APPLICATION_FINISHED:\n        LogHandlerAppFinishedEvent appFinishedEvent \u003d\n            (LogHandlerAppFinishedEvent) event;\n        ApplicationId appId \u003d appFinishedEvent.getApplicationId();\n        // Schedule - so that logs are available on the UI till they\u0027re deleted.\n        LOG.info(\"Scheduling Log Deletion for application: \"\n            + appId + \", with delay of \"\n            + this.deleteDelaySeconds + \" seconds\");\n        String user \u003d appOwners.remove(appId);\n        if (user \u003d\u003d null) {\n          LOG.error(\"Unable to locate user for \" + appId);\n          break;\n        }\n        LogDeleterRunnable logDeleter \u003d new LogDeleterRunnable(user, appId);\n        long deletionTimestamp \u003d System.currentTimeMillis()\n            + this.deleteDelaySeconds * 1000;\n        LogDeleterProto deleterProto \u003d LogDeleterProto.newBuilder()\n            .setUser(user)\n            .setDeletionTime(deletionTimestamp)\n            .build();\n        try {\n          stateStore.storeLogDeleter(appId, deleterProto);\n        } catch (IOException e) {\n          LOG.error(\"Unable to record log deleter state\", e);\n        }\n        try {\n          sched.schedule(logDeleter, this.deleteDelaySeconds,\n              TimeUnit.SECONDS);\n        } catch (RejectedExecutionException e) {\n          // Handling this event in local thread before starting threads\n          // or after calling sched.shutdownNow().\n          logDeleter.run();\n        }\n        break;\n      default:\n        ; // Ignore\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/loghandler/NonAggregatingLogHandler.java",
      "extendedDetails": {}
    },
    "785c12056ce2c6161b66699d995bd25198b9194f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1409. NonAggregatingLogHandler can throw RejectedExecutionException. Contributed by Tsuyoshi OZAWA\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556282 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/14 9:11 AM",
      "commitName": "785c12056ce2c6161b66699d995bd25198b9194f",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "16/06/13 11:39 PM",
      "commitNameOld": "b9efe6bd4a1277b4067ecde715a7713a85968886",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 204.44,
      "commitsBetweenForRepo": 1238,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,37 @@\n   public void handle(LogHandlerEvent event) {\n     switch (event.getType()) {\n       case APPLICATION_STARTED:\n         LogHandlerAppStartedEvent appStartedEvent \u003d\n             (LogHandlerAppStartedEvent) event;\n         this.appOwners.put(appStartedEvent.getApplicationId(),\n             appStartedEvent.getUser());\n         this.dispatcher.getEventHandler().handle(\n             new ApplicationEvent(appStartedEvent.getApplicationId(),\n                 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED));\n         break;\n       case CONTAINER_FINISHED:\n         // Ignore\n         break;\n       case APPLICATION_FINISHED:\n         LogHandlerAppFinishedEvent appFinishedEvent \u003d\n             (LogHandlerAppFinishedEvent) event;\n         // Schedule - so that logs are available on the UI till they\u0027re deleted.\n         LOG.info(\"Scheduling Log Deletion for application: \"\n             + appFinishedEvent.getApplicationId() + \", with delay of \"\n             + this.deleteDelaySeconds + \" seconds\");\n-        sched.schedule(\n+        LogDeleterRunnable logDeleter \u003d\n             new LogDeleterRunnable(appOwners.remove(appFinishedEvent\n-                .getApplicationId()), appFinishedEvent.getApplicationId()),\n-            this.deleteDelaySeconds, TimeUnit.SECONDS);\n+                  .getApplicationId()), appFinishedEvent.getApplicationId());\n+        try {\n+          sched.schedule(logDeleter, this.deleteDelaySeconds,\n+              TimeUnit.SECONDS);\n+        } catch (RejectedExecutionException e) {\n+          // Handling this event in local thread before starting threads\n+          // or after calling sched.shutdownNow().\n+          logDeleter.run();\n+        }\n         break;\n       default:\n         ; // Ignore\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(LogHandlerEvent event) {\n    switch (event.getType()) {\n      case APPLICATION_STARTED:\n        LogHandlerAppStartedEvent appStartedEvent \u003d\n            (LogHandlerAppStartedEvent) event;\n        this.appOwners.put(appStartedEvent.getApplicationId(),\n            appStartedEvent.getUser());\n        this.dispatcher.getEventHandler().handle(\n            new ApplicationEvent(appStartedEvent.getApplicationId(),\n                ApplicationEventType.APPLICATION_LOG_HANDLING_INITED));\n        break;\n      case CONTAINER_FINISHED:\n        // Ignore\n        break;\n      case APPLICATION_FINISHED:\n        LogHandlerAppFinishedEvent appFinishedEvent \u003d\n            (LogHandlerAppFinishedEvent) event;\n        // Schedule - so that logs are available on the UI till they\u0027re deleted.\n        LOG.info(\"Scheduling Log Deletion for application: \"\n            + appFinishedEvent.getApplicationId() + \", with delay of \"\n            + this.deleteDelaySeconds + \" seconds\");\n        LogDeleterRunnable logDeleter \u003d\n            new LogDeleterRunnable(appOwners.remove(appFinishedEvent\n                  .getApplicationId()), appFinishedEvent.getApplicationId());\n        try {\n          sched.schedule(logDeleter, this.deleteDelaySeconds,\n              TimeUnit.SECONDS);\n        } catch (RejectedExecutionException e) {\n          // Handling this event in local thread before starting threads\n          // or after calling sched.shutdownNow().\n          logDeleter.run();\n        }\n        break;\n      default:\n        ; // Ignore\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/loghandler/NonAggregatingLogHandler.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void handle(LogHandlerEvent event) {\n    switch (event.getType()) {\n      case APPLICATION_STARTED:\n        LogHandlerAppStartedEvent appStartedEvent \u003d\n            (LogHandlerAppStartedEvent) event;\n        this.appOwners.put(appStartedEvent.getApplicationId(),\n            appStartedEvent.getUser());\n        this.dispatcher.getEventHandler().handle(\n            new ApplicationEvent(appStartedEvent.getApplicationId(),\n                ApplicationEventType.APPLICATION_LOG_HANDLING_INITED));\n        break;\n      case CONTAINER_FINISHED:\n        // Ignore\n        break;\n      case APPLICATION_FINISHED:\n        LogHandlerAppFinishedEvent appFinishedEvent \u003d\n            (LogHandlerAppFinishedEvent) event;\n        // Schedule - so that logs are available on the UI till they\u0027re deleted.\n        LOG.info(\"Scheduling Log Deletion for application: \"\n            + appFinishedEvent.getApplicationId() + \", with delay of \"\n            + this.deleteDelaySeconds + \" seconds\");\n        sched.schedule(\n            new LogDeleterRunnable(appOwners.remove(appFinishedEvent\n                .getApplicationId()), appFinishedEvent.getApplicationId()),\n            this.deleteDelaySeconds, TimeUnit.SECONDS);\n        break;\n      default:\n        ; // Ignore\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/loghandler/NonAggregatingLogHandler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/loghandler/NonAggregatingLogHandler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/loghandler/NonAggregatingLogHandler.java"
      }
    },
    "1cf60106758c482991f08caa136446885d5f8f27": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4302. NM goes down if error encountered during log aggregation (Daryn Sharp via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1345362 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/06/12 2:54 PM",
      "commitName": "1cf60106758c482991f08caa136446885d5f8f27",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "29/11/11 3:17 PM",
      "commitNameOld": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 184.94,
      "commitsBetweenForRepo": 1310,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,30 @@\n   public void handle(LogHandlerEvent event) {\n     switch (event.getType()) {\n       case APPLICATION_STARTED:\n         LogHandlerAppStartedEvent appStartedEvent \u003d\n             (LogHandlerAppStartedEvent) event;\n         this.appOwners.put(appStartedEvent.getApplicationId(),\n             appStartedEvent.getUser());\n+        this.dispatcher.getEventHandler().handle(\n+            new ApplicationEvent(appStartedEvent.getApplicationId(),\n+                ApplicationEventType.APPLICATION_LOG_HANDLING_INITED));\n         break;\n       case CONTAINER_FINISHED:\n         // Ignore\n         break;\n       case APPLICATION_FINISHED:\n         LogHandlerAppFinishedEvent appFinishedEvent \u003d\n             (LogHandlerAppFinishedEvent) event;\n         // Schedule - so that logs are available on the UI till they\u0027re deleted.\n         LOG.info(\"Scheduling Log Deletion for application: \"\n             + appFinishedEvent.getApplicationId() + \", with delay of \"\n             + this.deleteDelaySeconds + \" seconds\");\n         sched.schedule(\n             new LogDeleterRunnable(appOwners.remove(appFinishedEvent\n                 .getApplicationId()), appFinishedEvent.getApplicationId()),\n             this.deleteDelaySeconds, TimeUnit.SECONDS);\n         break;\n       default:\n         ; // Ignore\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(LogHandlerEvent event) {\n    switch (event.getType()) {\n      case APPLICATION_STARTED:\n        LogHandlerAppStartedEvent appStartedEvent \u003d\n            (LogHandlerAppStartedEvent) event;\n        this.appOwners.put(appStartedEvent.getApplicationId(),\n            appStartedEvent.getUser());\n        this.dispatcher.getEventHandler().handle(\n            new ApplicationEvent(appStartedEvent.getApplicationId(),\n                ApplicationEventType.APPLICATION_LOG_HANDLING_INITED));\n        break;\n      case CONTAINER_FINISHED:\n        // Ignore\n        break;\n      case APPLICATION_FINISHED:\n        LogHandlerAppFinishedEvent appFinishedEvent \u003d\n            (LogHandlerAppFinishedEvent) event;\n        // Schedule - so that logs are available on the UI till they\u0027re deleted.\n        LOG.info(\"Scheduling Log Deletion for application: \"\n            + appFinishedEvent.getApplicationId() + \", with delay of \"\n            + this.deleteDelaySeconds + \" seconds\");\n        sched.schedule(\n            new LogDeleterRunnable(appOwners.remove(appFinishedEvent\n                .getApplicationId()), appFinishedEvent.getApplicationId()),\n            this.deleteDelaySeconds, TimeUnit.SECONDS);\n        break;\n      default:\n        ; // Ignore\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/loghandler/NonAggregatingLogHandler.java",
      "extendedDetails": {}
    },
    "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2696. Fixed NodeManager to cleanup logs in a thread when logs\u0027 aggregation is not enabled. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195383 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/11 2:55 AM",
      "commitName": "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,27 @@\n+  public void handle(LogHandlerEvent event) {\n+    switch (event.getType()) {\n+      case APPLICATION_STARTED:\n+        LogHandlerAppStartedEvent appStartedEvent \u003d\n+            (LogHandlerAppStartedEvent) event;\n+        this.appOwners.put(appStartedEvent.getApplicationId(),\n+            appStartedEvent.getUser());\n+        break;\n+      case CONTAINER_FINISHED:\n+        // Ignore\n+        break;\n+      case APPLICATION_FINISHED:\n+        LogHandlerAppFinishedEvent appFinishedEvent \u003d\n+            (LogHandlerAppFinishedEvent) event;\n+        // Schedule - so that logs are available on the UI till they\u0027re deleted.\n+        LOG.info(\"Scheduling Log Deletion for application: \"\n+            + appFinishedEvent.getApplicationId() + \", with delay of \"\n+            + this.deleteDelaySeconds + \" seconds\");\n+        sched.schedule(\n+            new LogDeleterRunnable(appOwners.remove(appFinishedEvent\n+                .getApplicationId()), appFinishedEvent.getApplicationId()),\n+            this.deleteDelaySeconds, TimeUnit.SECONDS);\n+        break;\n+      default:\n+        ; // Ignore\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(LogHandlerEvent event) {\n    switch (event.getType()) {\n      case APPLICATION_STARTED:\n        LogHandlerAppStartedEvent appStartedEvent \u003d\n            (LogHandlerAppStartedEvent) event;\n        this.appOwners.put(appStartedEvent.getApplicationId(),\n            appStartedEvent.getUser());\n        break;\n      case CONTAINER_FINISHED:\n        // Ignore\n        break;\n      case APPLICATION_FINISHED:\n        LogHandlerAppFinishedEvent appFinishedEvent \u003d\n            (LogHandlerAppFinishedEvent) event;\n        // Schedule - so that logs are available on the UI till they\u0027re deleted.\n        LOG.info(\"Scheduling Log Deletion for application: \"\n            + appFinishedEvent.getApplicationId() + \", with delay of \"\n            + this.deleteDelaySeconds + \" seconds\");\n        sched.schedule(\n            new LogDeleterRunnable(appOwners.remove(appFinishedEvent\n                .getApplicationId()), appFinishedEvent.getApplicationId()),\n            this.deleteDelaySeconds, TimeUnit.SECONDS);\n        break;\n      default:\n        ; // Ignore\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/loghandler/NonAggregatingLogHandler.java"
    }
  }
}