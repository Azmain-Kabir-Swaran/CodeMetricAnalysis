{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ActivitiesManager.java",
  "functionName": "serviceStart",
  "functionId": "serviceStart",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java",
  "functionStartLine": 272,
  "functionEndLine": 334,
  "numCommitsSeen": 16,
  "timeTaken": 4098,
  "changeHistory": [
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
    "cbae2413201bc470b5f16421ea69d1cd9edb64a8",
    "1a47c2b7aed1ccd562d393b79772d01244ccab44",
    "7fa73fac2676875561269e9408215e012269a18c",
    "6310c0d17d6422a595f856a55b4f1fb82be43739",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188"
  ],
  "changeHistoryShort": {
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8": "Ybodychange",
    "cbae2413201bc470b5f16421ea69d1cd9edb64a8": "Ybodychange",
    "1a47c2b7aed1ccd562d393b79772d01244ccab44": "Ybodychange",
    "7fa73fac2676875561269e9408215e012269a18c": "Ybodychange",
    "6310c0d17d6422a595f856a55b4f1fb82be43739": "Ybodychange",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9664. Improve response of scheduler/app activities for better understanding. Contributed by Tao Yang.\n",
      "commitDate": "29/08/19 3:14 AM",
      "commitName": "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "28/06/19 8:24 AM",
      "commitNameOld": "cbae2413201bc470b5f16421ea69d1cd9edb64a8",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 61.78,
      "commitsBetweenForRepo": 517,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   protected void serviceStart() throws Exception {\n     cleanUpThread \u003d new Thread(new Runnable() {\n       @Override\n       public void run() {\n         while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n           Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n               completedNodeAllocations.entrySet().iterator();\n           long curTS \u003d SystemClock.getInstance().getTime();\n           while (ite.hasNext()) {\n             Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n             List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n             if (allocations.size() \u003e 0\n-                \u0026\u0026 curTS - allocations.get(0).getTimeStamp()\n+                \u0026\u0026 curTS - allocations.get(0).getTimestamp()\n                 \u003e schedulerActivitiesTTL) {\n               ite.remove();\n             }\n           }\n \n           Iterator\u003cMap.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n               completedAppAllocations.entrySet().iterator();\n           while (iteApp.hasNext()) {\n             Map.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e appAllocation \u003d\n                 iteApp.next();\n             RMApp rmApp \u003d rmContext.getRMApps().get(appAllocation.getKey());\n             if (rmApp \u003d\u003d null || rmApp.getFinalApplicationStatus()\n                 !\u003d FinalApplicationStatus.UNDEFINED) {\n               iteApp.remove();\n             } else {\n               Iterator\u003cAppAllocation\u003e appActivitiesIt \u003d\n                   appAllocation.getValue().iterator();\n               while (appActivitiesIt.hasNext()) {\n                 if (curTS - appActivitiesIt.next().getTime()\n                     \u003e appActivitiesTTL) {\n                   appActivitiesIt.remove();\n                 } else {\n                   break;\n                 }\n               }\n               if (appAllocation.getValue().isEmpty()) {\n                 iteApp.remove();\n                 LOG.debug(\"Removed all expired activities from cache for {}.\",\n                     rmApp.getApplicationId());\n               }\n             }\n           }\n \n           LOG.debug(\"Remaining apps in app activities cache: {}\",\n               completedAppAllocations.keySet());\n           // dynamically update max queue length of app activities if needed\n           dynamicallyUpdateAppActivitiesMaxQueueLengthIfNeeded();\n           try {\n             Thread.sleep(activitiesCleanupIntervalMs);\n           } catch (InterruptedException e) {\n             LOG.info(getName() + \" thread interrupted\");\n             break;\n           }\n         }\n       }\n     });\n     cleanUpThread.setName(\"ActivitiesManager thread.\");\n     cleanUpThread.start();\n     super.serviceStart();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n    cleanUpThread \u003d new Thread(new Runnable() {\n      @Override\n      public void run() {\n        while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n          Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n              completedNodeAllocations.entrySet().iterator();\n          long curTS \u003d SystemClock.getInstance().getTime();\n          while (ite.hasNext()) {\n            Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n            List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n            if (allocations.size() \u003e 0\n                \u0026\u0026 curTS - allocations.get(0).getTimestamp()\n                \u003e schedulerActivitiesTTL) {\n              ite.remove();\n            }\n          }\n\n          Iterator\u003cMap.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n              completedAppAllocations.entrySet().iterator();\n          while (iteApp.hasNext()) {\n            Map.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e appAllocation \u003d\n                iteApp.next();\n            RMApp rmApp \u003d rmContext.getRMApps().get(appAllocation.getKey());\n            if (rmApp \u003d\u003d null || rmApp.getFinalApplicationStatus()\n                !\u003d FinalApplicationStatus.UNDEFINED) {\n              iteApp.remove();\n            } else {\n              Iterator\u003cAppAllocation\u003e appActivitiesIt \u003d\n                  appAllocation.getValue().iterator();\n              while (appActivitiesIt.hasNext()) {\n                if (curTS - appActivitiesIt.next().getTime()\n                    \u003e appActivitiesTTL) {\n                  appActivitiesIt.remove();\n                } else {\n                  break;\n                }\n              }\n              if (appAllocation.getValue().isEmpty()) {\n                iteApp.remove();\n                LOG.debug(\"Removed all expired activities from cache for {}.\",\n                    rmApp.getApplicationId());\n              }\n            }\n          }\n\n          LOG.debug(\"Remaining apps in app activities cache: {}\",\n              completedAppAllocations.keySet());\n          // dynamically update max queue length of app activities if needed\n          dynamicallyUpdateAppActivitiesMaxQueueLengthIfNeeded();\n          try {\n            Thread.sleep(activitiesCleanupIntervalMs);\n          } catch (InterruptedException e) {\n            LOG.info(getName() + \" thread interrupted\");\n            break;\n          }\n        }\n      }\n    });\n    cleanUpThread.setName(\"ActivitiesManager thread.\");\n    cleanUpThread.start();\n    super.serviceStart();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java",
      "extendedDetails": {}
    },
    "cbae2413201bc470b5f16421ea69d1cd9edb64a8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9623. Auto adjust max queue length of app activities to make sure activities on all nodes can be covered. Contributed by Tao Yang.\n",
      "commitDate": "28/06/19 8:24 AM",
      "commitName": "cbae2413201bc470b5f16421ea69d1cd9edb64a8",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "12/06/19 7:44 PM",
      "commitNameOld": "970b0b0c02bb8fbe8ff227c78e2332df623d1aea",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 15.53,
      "commitsBetweenForRepo": 177,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,63 @@\n   protected void serviceStart() throws Exception {\n     cleanUpThread \u003d new Thread(new Runnable() {\n       @Override\n       public void run() {\n         while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n           Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n               completedNodeAllocations.entrySet().iterator();\n           long curTS \u003d SystemClock.getInstance().getTime();\n           while (ite.hasNext()) {\n             Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n             List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n             if (allocations.size() \u003e 0\n                 \u0026\u0026 curTS - allocations.get(0).getTimeStamp()\n                 \u003e schedulerActivitiesTTL) {\n               ite.remove();\n             }\n           }\n \n           Iterator\u003cMap.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n               completedAppAllocations.entrySet().iterator();\n           while (iteApp.hasNext()) {\n             Map.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e appAllocation \u003d\n                 iteApp.next();\n             RMApp rmApp \u003d rmContext.getRMApps().get(appAllocation.getKey());\n             if (rmApp \u003d\u003d null || rmApp.getFinalApplicationStatus()\n                 !\u003d FinalApplicationStatus.UNDEFINED) {\n               iteApp.remove();\n             } else {\n               Iterator\u003cAppAllocation\u003e appActivitiesIt \u003d\n                   appAllocation.getValue().iterator();\n               while (appActivitiesIt.hasNext()) {\n                 if (curTS - appActivitiesIt.next().getTime()\n                     \u003e appActivitiesTTL) {\n                   appActivitiesIt.remove();\n                 } else {\n                   break;\n                 }\n               }\n               if (appAllocation.getValue().isEmpty()) {\n                 iteApp.remove();\n                 LOG.debug(\"Removed all expired activities from cache for {}.\",\n                     rmApp.getApplicationId());\n               }\n             }\n           }\n \n           LOG.debug(\"Remaining apps in app activities cache: {}\",\n               completedAppAllocations.keySet());\n+          // dynamically update max queue length of app activities if needed\n+          dynamicallyUpdateAppActivitiesMaxQueueLengthIfNeeded();\n           try {\n             Thread.sleep(activitiesCleanupIntervalMs);\n           } catch (InterruptedException e) {\n             LOG.info(getName() + \" thread interrupted\");\n             break;\n           }\n         }\n       }\n     });\n     cleanUpThread.setName(\"ActivitiesManager thread.\");\n     cleanUpThread.start();\n     super.serviceStart();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n    cleanUpThread \u003d new Thread(new Runnable() {\n      @Override\n      public void run() {\n        while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n          Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n              completedNodeAllocations.entrySet().iterator();\n          long curTS \u003d SystemClock.getInstance().getTime();\n          while (ite.hasNext()) {\n            Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n            List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n            if (allocations.size() \u003e 0\n                \u0026\u0026 curTS - allocations.get(0).getTimeStamp()\n                \u003e schedulerActivitiesTTL) {\n              ite.remove();\n            }\n          }\n\n          Iterator\u003cMap.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n              completedAppAllocations.entrySet().iterator();\n          while (iteApp.hasNext()) {\n            Map.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e appAllocation \u003d\n                iteApp.next();\n            RMApp rmApp \u003d rmContext.getRMApps().get(appAllocation.getKey());\n            if (rmApp \u003d\u003d null || rmApp.getFinalApplicationStatus()\n                !\u003d FinalApplicationStatus.UNDEFINED) {\n              iteApp.remove();\n            } else {\n              Iterator\u003cAppAllocation\u003e appActivitiesIt \u003d\n                  appAllocation.getValue().iterator();\n              while (appActivitiesIt.hasNext()) {\n                if (curTS - appActivitiesIt.next().getTime()\n                    \u003e appActivitiesTTL) {\n                  appActivitiesIt.remove();\n                } else {\n                  break;\n                }\n              }\n              if (appAllocation.getValue().isEmpty()) {\n                iteApp.remove();\n                LOG.debug(\"Removed all expired activities from cache for {}.\",\n                    rmApp.getApplicationId());\n              }\n            }\n          }\n\n          LOG.debug(\"Remaining apps in app activities cache: {}\",\n              completedAppAllocations.keySet());\n          // dynamically update max queue length of app activities if needed\n          dynamicallyUpdateAppActivitiesMaxQueueLengthIfNeeded();\n          try {\n            Thread.sleep(activitiesCleanupIntervalMs);\n          } catch (InterruptedException e) {\n            LOG.info(getName() + \" thread interrupted\");\n            break;\n          }\n        }\n      }\n    });\n    cleanUpThread.setName(\"ActivitiesManager thread.\");\n    cleanUpThread.start();\n    super.serviceStart();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java",
      "extendedDetails": {}
    },
    "1a47c2b7aed1ccd562d393b79772d01244ccab44": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9539.Improve cleanup process of app activities and make some conditions configurable. Contributed by Tao Yang.\n",
      "commitDate": "12/05/19 10:31 PM",
      "commitName": "1a47c2b7aed1ccd562d393b79772d01244ccab44",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "09/05/19 6:54 AM",
      "commitNameOld": "90add05caa6c48659f0c592ec391b30f2a76069e",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 3.65,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,61 @@\n   protected void serviceStart() throws Exception {\n     cleanUpThread \u003d new Thread(new Runnable() {\n       @Override\n       public void run() {\n         while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n           Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n               completedNodeAllocations.entrySet().iterator();\n+          long curTS \u003d SystemClock.getInstance().getTime();\n           while (ite.hasNext()) {\n             Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n             List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n-            long currTS \u003d SystemClock.getInstance().getTime();\n-            if (allocations.size() \u003e 0 \u0026\u0026 allocations.get(0).getTimeStamp()\n-                - currTS \u003e timeThreshold) {\n+            if (allocations.size() \u003e 0\n+                \u0026\u0026 curTS - allocations.get(0).getTimeStamp()\n+                \u003e schedulerActivitiesTTL) {\n               ite.remove();\n             }\n           }\n \n           Iterator\u003cMap.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n               completedAppAllocations.entrySet().iterator();\n           while (iteApp.hasNext()) {\n             Map.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e appAllocation \u003d\n                 iteApp.next();\n             RMApp rmApp \u003d rmContext.getRMApps().get(appAllocation.getKey());\n             if (rmApp \u003d\u003d null || rmApp.getFinalApplicationStatus()\n                 !\u003d FinalApplicationStatus.UNDEFINED) {\n               iteApp.remove();\n+            } else {\n+              Iterator\u003cAppAllocation\u003e appActivitiesIt \u003d\n+                  appAllocation.getValue().iterator();\n+              while (appActivitiesIt.hasNext()) {\n+                if (curTS - appActivitiesIt.next().getTime()\n+                    \u003e appActivitiesTTL) {\n+                  appActivitiesIt.remove();\n+                } else {\n+                  break;\n+                }\n+              }\n+              if (appAllocation.getValue().isEmpty()) {\n+                iteApp.remove();\n+                LOG.debug(\"Removed all expired activities from cache for {}.\",\n+                    rmApp.getApplicationId());\n+              }\n             }\n           }\n \n+          LOG.debug(\"Remaining apps in app activities cache: {}\",\n+              completedAppAllocations.keySet());\n           try {\n-            Thread.sleep(5000);\n+            Thread.sleep(activitiesCleanupIntervalMs);\n           } catch (InterruptedException e) {\n             LOG.info(getName() + \" thread interrupted\");\n             break;\n           }\n         }\n       }\n     });\n     cleanUpThread.setName(\"ActivitiesManager thread.\");\n     cleanUpThread.start();\n     super.serviceStart();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n    cleanUpThread \u003d new Thread(new Runnable() {\n      @Override\n      public void run() {\n        while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n          Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n              completedNodeAllocations.entrySet().iterator();\n          long curTS \u003d SystemClock.getInstance().getTime();\n          while (ite.hasNext()) {\n            Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n            List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n            if (allocations.size() \u003e 0\n                \u0026\u0026 curTS - allocations.get(0).getTimeStamp()\n                \u003e schedulerActivitiesTTL) {\n              ite.remove();\n            }\n          }\n\n          Iterator\u003cMap.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n              completedAppAllocations.entrySet().iterator();\n          while (iteApp.hasNext()) {\n            Map.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e appAllocation \u003d\n                iteApp.next();\n            RMApp rmApp \u003d rmContext.getRMApps().get(appAllocation.getKey());\n            if (rmApp \u003d\u003d null || rmApp.getFinalApplicationStatus()\n                !\u003d FinalApplicationStatus.UNDEFINED) {\n              iteApp.remove();\n            } else {\n              Iterator\u003cAppAllocation\u003e appActivitiesIt \u003d\n                  appAllocation.getValue().iterator();\n              while (appActivitiesIt.hasNext()) {\n                if (curTS - appActivitiesIt.next().getTime()\n                    \u003e appActivitiesTTL) {\n                  appActivitiesIt.remove();\n                } else {\n                  break;\n                }\n              }\n              if (appAllocation.getValue().isEmpty()) {\n                iteApp.remove();\n                LOG.debug(\"Removed all expired activities from cache for {}.\",\n                    rmApp.getApplicationId());\n              }\n            }\n          }\n\n          LOG.debug(\"Remaining apps in app activities cache: {}\",\n              completedAppAllocations.keySet());\n          try {\n            Thread.sleep(activitiesCleanupIntervalMs);\n          } catch (InterruptedException e) {\n            LOG.info(getName() + \" thread interrupted\");\n            break;\n          }\n        }\n      }\n    });\n    cleanUpThread.setName(\"ActivitiesManager thread.\");\n    cleanUpThread.start();\n    super.serviceStart();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java",
      "extendedDetails": {}
    },
    "7fa73fac2676875561269e9408215e012269a18c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9439. Support asynchronized scheduling mode and multi-node lookup mechanism for app activities. Contributed by Tao Yang.\n",
      "commitDate": "15/04/19 9:12 AM",
      "commitName": "7fa73fac2676875561269e9408215e012269a18c",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "07/04/19 10:40 PM",
      "commitNameOld": "fc05b0e70e9bb556d6bdc00fa8735e18a6f90bc9",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 7.44,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   protected void serviceStart() throws Exception {\n     cleanUpThread \u003d new Thread(new Runnable() {\n       @Override\n       public void run() {\n         while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n           Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n               completedNodeAllocations.entrySet().iterator();\n           while (ite.hasNext()) {\n             Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n             List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n             long currTS \u003d SystemClock.getInstance().getTime();\n             if (allocations.size() \u003e 0 \u0026\u0026 allocations.get(0).getTimeStamp()\n                 - currTS \u003e timeThreshold) {\n               ite.remove();\n             }\n           }\n \n-          Iterator\u003cMap.Entry\u003cApplicationId, List\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n+          Iterator\u003cMap.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n               completedAppAllocations.entrySet().iterator();\n           while (iteApp.hasNext()) {\n-            Map.Entry\u003cApplicationId, List\u003cAppAllocation\u003e\u003e appAllocation \u003d\n+            Map.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e appAllocation \u003d\n                 iteApp.next();\n-            if (rmContext.getRMApps().get(appAllocation.getKey())\n-                .getFinalApplicationStatus()\n+            RMApp rmApp \u003d rmContext.getRMApps().get(appAllocation.getKey());\n+            if (rmApp \u003d\u003d null || rmApp.getFinalApplicationStatus()\n                 !\u003d FinalApplicationStatus.UNDEFINED) {\n               iteApp.remove();\n             }\n           }\n \n           try {\n             Thread.sleep(5000);\n           } catch (InterruptedException e) {\n             LOG.info(getName() + \" thread interrupted\");\n             break;\n           }\n         }\n       }\n     });\n     cleanUpThread.setName(\"ActivitiesManager thread.\");\n     cleanUpThread.start();\n     super.serviceStart();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n    cleanUpThread \u003d new Thread(new Runnable() {\n      @Override\n      public void run() {\n        while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n          Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n              completedNodeAllocations.entrySet().iterator();\n          while (ite.hasNext()) {\n            Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n            List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n            long currTS \u003d SystemClock.getInstance().getTime();\n            if (allocations.size() \u003e 0 \u0026\u0026 allocations.get(0).getTimeStamp()\n                - currTS \u003e timeThreshold) {\n              ite.remove();\n            }\n          }\n\n          Iterator\u003cMap.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n              completedAppAllocations.entrySet().iterator();\n          while (iteApp.hasNext()) {\n            Map.Entry\u003cApplicationId, Queue\u003cAppAllocation\u003e\u003e appAllocation \u003d\n                iteApp.next();\n            RMApp rmApp \u003d rmContext.getRMApps().get(appAllocation.getKey());\n            if (rmApp \u003d\u003d null || rmApp.getFinalApplicationStatus()\n                !\u003d FinalApplicationStatus.UNDEFINED) {\n              iteApp.remove();\n            }\n          }\n\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e) {\n            LOG.info(getName() + \" thread interrupted\");\n            break;\n          }\n        }\n      }\n    });\n    cleanUpThread.setName(\"ActivitiesManager thread.\");\n    cleanUpThread.start();\n    super.serviceStart();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java",
      "extendedDetails": {}
    },
    "6310c0d17d6422a595f856a55b4f1fb82be43739": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8397. Potential thread leak in ActivitiesManager. Contributed by Rohith Sharma K S.\n",
      "commitDate": "31/07/18 8:03 PM",
      "commitName": "6310c0d17d6422a595f856a55b4f1fb82be43739",
      "commitAuthor": "Sunil G",
      "commitDateOld": "07/11/16 10:14 AM",
      "commitNameOld": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 631.37,
      "commitsBetweenForRepo": 4710,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,42 @@\n   protected void serviceStart() throws Exception {\n     cleanUpThread \u003d new Thread(new Runnable() {\n       @Override\n       public void run() {\n-        while (true) {\n+        while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n           Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n               completedNodeAllocations.entrySet().iterator();\n           while (ite.hasNext()) {\n             Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n             List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n             long currTS \u003d SystemClock.getInstance().getTime();\n             if (allocations.size() \u003e 0 \u0026\u0026 allocations.get(0).getTimeStamp()\n                 - currTS \u003e timeThreshold) {\n               ite.remove();\n             }\n           }\n \n           Iterator\u003cMap.Entry\u003cApplicationId, List\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n               completedAppAllocations.entrySet().iterator();\n           while (iteApp.hasNext()) {\n             Map.Entry\u003cApplicationId, List\u003cAppAllocation\u003e\u003e appAllocation \u003d\n                 iteApp.next();\n             if (rmContext.getRMApps().get(appAllocation.getKey())\n                 .getFinalApplicationStatus()\n                 !\u003d FinalApplicationStatus.UNDEFINED) {\n               iteApp.remove();\n             }\n           }\n \n           try {\n             Thread.sleep(5000);\n-          } catch (Exception e) {\n-            // ignore\n+          } catch (InterruptedException e) {\n+            LOG.info(getName() + \" thread interrupted\");\n+            break;\n           }\n         }\n       }\n     });\n-\n+    cleanUpThread.setName(\"ActivitiesManager thread.\");\n     cleanUpThread.start();\n     super.serviceStart();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n    cleanUpThread \u003d new Thread(new Runnable() {\n      @Override\n      public void run() {\n        while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n          Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n              completedNodeAllocations.entrySet().iterator();\n          while (ite.hasNext()) {\n            Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n            List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n            long currTS \u003d SystemClock.getInstance().getTime();\n            if (allocations.size() \u003e 0 \u0026\u0026 allocations.get(0).getTimeStamp()\n                - currTS \u003e timeThreshold) {\n              ite.remove();\n            }\n          }\n\n          Iterator\u003cMap.Entry\u003cApplicationId, List\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n              completedAppAllocations.entrySet().iterator();\n          while (iteApp.hasNext()) {\n            Map.Entry\u003cApplicationId, List\u003cAppAllocation\u003e\u003e appAllocation \u003d\n                iteApp.next();\n            if (rmContext.getRMApps().get(appAllocation.getKey())\n                .getFinalApplicationStatus()\n                !\u003d FinalApplicationStatus.UNDEFINED) {\n              iteApp.remove();\n            }\n          }\n\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException e) {\n            LOG.info(getName() + \" thread interrupted\");\n            break;\n          }\n        }\n      }\n    });\n    cleanUpThread.setName(\"ActivitiesManager thread.\");\n    cleanUpThread.start();\n    super.serviceStart();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java",
      "extendedDetails": {}
    },
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4091. Add REST API to retrieve scheduler activity. (Chen Ge and Sunil G via wangda)\n",
      "commitDate": "05/08/16 10:27 AM",
      "commitName": "e0d131f055ee126052ad4d0f7b0d192e6c730188",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,41 @@\n+  protected void serviceStart() throws Exception {\n+    cleanUpThread \u003d new Thread(new Runnable() {\n+      @Override\n+      public void run() {\n+        while (true) {\n+          Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n+              completedNodeAllocations.entrySet().iterator();\n+          while (ite.hasNext()) {\n+            Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n+            List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n+            long currTS \u003d SystemClock.getInstance().getTime();\n+            if (allocations.size() \u003e 0 \u0026\u0026 allocations.get(0).getTimeStamp()\n+                - currTS \u003e timeThreshold) {\n+              ite.remove();\n+            }\n+          }\n+\n+          Iterator\u003cMap.Entry\u003cApplicationId, List\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n+              completedAppAllocations.entrySet().iterator();\n+          while (iteApp.hasNext()) {\n+            Map.Entry\u003cApplicationId, List\u003cAppAllocation\u003e\u003e appAllocation \u003d\n+                iteApp.next();\n+            if (rmContext.getRMApps().get(appAllocation.getKey())\n+                .getFinalApplicationStatus()\n+                !\u003d FinalApplicationStatus.UNDEFINED) {\n+              iteApp.remove();\n+            }\n+          }\n+\n+          try {\n+            Thread.sleep(5000);\n+          } catch (Exception e) {\n+            // ignore\n+          }\n+        }\n+      }\n+    });\n+\n+    cleanUpThread.start();\n+    super.serviceStart();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n    cleanUpThread \u003d new Thread(new Runnable() {\n      @Override\n      public void run() {\n        while (true) {\n          Iterator\u003cMap.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e\u003e ite \u003d\n              completedNodeAllocations.entrySet().iterator();\n          while (ite.hasNext()) {\n            Map.Entry\u003cNodeId, List\u003cNodeAllocation\u003e\u003e nodeAllocation \u003d ite.next();\n            List\u003cNodeAllocation\u003e allocations \u003d nodeAllocation.getValue();\n            long currTS \u003d SystemClock.getInstance().getTime();\n            if (allocations.size() \u003e 0 \u0026\u0026 allocations.get(0).getTimeStamp()\n                - currTS \u003e timeThreshold) {\n              ite.remove();\n            }\n          }\n\n          Iterator\u003cMap.Entry\u003cApplicationId, List\u003cAppAllocation\u003e\u003e\u003e iteApp \u003d\n              completedAppAllocations.entrySet().iterator();\n          while (iteApp.hasNext()) {\n            Map.Entry\u003cApplicationId, List\u003cAppAllocation\u003e\u003e appAllocation \u003d\n                iteApp.next();\n            if (rmContext.getRMApps().get(appAllocation.getKey())\n                .getFinalApplicationStatus()\n                !\u003d FinalApplicationStatus.UNDEFINED) {\n              iteApp.remove();\n            }\n          }\n\n          try {\n            Thread.sleep(5000);\n          } catch (Exception e) {\n            // ignore\n          }\n        }\n      }\n    });\n\n    cleanUpThread.start();\n    super.serviceStart();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java"
    }
  }
}