{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AclCommands.java",
  "functionName": "processOptions",
  "functionId": "processOptions___args-LinkedList__String__",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/AclCommands.java",
  "functionStartLine": 66,
  "functionEndLine": 76,
  "numCommitsSeen": 18,
  "timeTaken": 1599,
  "changeHistory": [
    "43cf6b101dacd96bacfd199826b717f6946109af",
    "b3649adf6a1b2dc47566b4b0d652bd4e0a6a8056",
    "327d2ceca22119a73ea05ddf4620e5253a2fded6",
    "cae96dfe6e7c57f927bd825711977ae9199776a9",
    "abe13d6ffb0009df859077032aaa19a6d894ae36"
  ],
  "changeHistoryShort": {
    "43cf6b101dacd96bacfd199826b717f6946109af": "Ybodychange",
    "b3649adf6a1b2dc47566b4b0d652bd4e0a6a8056": "Ybodychange",
    "327d2ceca22119a73ea05ddf4620e5253a2fded6": "Ybodychange",
    "cae96dfe6e7c57f927bd825711977ae9199776a9": "Ybodychange",
    "abe13d6ffb0009df859077032aaa19a6d894ae36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "43cf6b101dacd96bacfd199826b717f6946109af": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13240. TestAclCommands.testSetfaclValidations fail. Contributed by John Zhuge.\n",
      "commitDate": "21/07/16 2:12 PM",
      "commitName": "43cf6b101dacd96bacfd199826b717f6946109af",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "28/06/16 8:47 PM",
      "commitNameOld": "b3649adf6a1b2dc47566b4b0d652bd4e0a6a8056",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 22.73,
      "commitsBetweenForRepo": 248,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,60 @@\n     protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n       cf.parse(args);\n       setRecursive(cf.getOpt(\"R\"));\n       // Mix of remove and modify acl flags are not allowed\n       boolean bothRemoveOptions \u003d cf.getOpt(\"b\") \u0026\u0026 cf.getOpt(\"k\");\n       boolean bothModifyOptions \u003d cf.getOpt(\"m\") \u0026\u0026 cf.getOpt(\"x\");\n       boolean oneRemoveOption \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\");\n       boolean oneModifyOption \u003d cf.getOpt(\"m\") || cf.getOpt(\"x\");\n       boolean setOption \u003d cf.getOpt(\"-set\");\n       boolean hasExpectedOptions \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\") ||\n           cf.getOpt(\"m\") || cf.getOpt(\"x\") || cf.getOpt(\"-set\");\n \n       if ((bothRemoveOptions || bothModifyOptions)\n           || (oneRemoveOption \u0026\u0026 oneModifyOption)\n           || (setOption \u0026\u0026 (oneRemoveOption || oneModifyOption))) {\n         throw new HadoopIllegalArgumentException(\n             \"Specified flags contains both remove and modify flags\");\n       }\n \n       // Only -m, -x and --set expects \u003cacl_spec\u003e\n       if (oneModifyOption || setOption) {\n         if (args.isEmpty()) {\n           throw new HadoopIllegalArgumentException(\n               \"Missing arguments: \u003cacl_spec\u003e \u003cpath\u003e\");\n         }\n         if (args.size() \u003c 2) {\n           throw new HadoopIllegalArgumentException(\n               \"Missing either \u003cacl_spec\u003e or \u003cpath\u003e\");\n         }\n         aclEntries \u003d AclEntry.parseAclSpec(args.removeFirst(), !cf.getOpt(\"x\"));\n+        if (aclEntries.isEmpty()) {\n+          throw new HadoopIllegalArgumentException(\n+              \"Missing \u003cacl_spec\u003e entry\");\n+        }\n       }\n \n       if (args.isEmpty()) {\n         throw new HadoopIllegalArgumentException(\"\u003cpath\u003e is missing\");\n       }\n       if (args.size() \u003e 1) {\n         throw new HadoopIllegalArgumentException(\"Too many arguments\");\n       }\n \n       if (!hasExpectedOptions) {\n         throw new HadoopIllegalArgumentException(\n             \"Expected one of -b, -k, -m, -x or --set options\");\n       }\n       // In recursive mode, save a separate list of just the access ACL entries.\n       // Only directories may have a default ACL.  When a recursive operation\n       // encounters a file under the specified path, it must pass only the\n       // access ACL entries.\n       if (isRecursive() \u0026\u0026 (oneModifyOption || setOption)) {\n         accessAclEntries \u003d Lists.newArrayList();\n         for (AclEntry entry: aclEntries) {\n           if (entry.getScope() \u003d\u003d AclEntryScope.ACCESS) {\n             accessAclEntries.add(entry);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n      cf.parse(args);\n      setRecursive(cf.getOpt(\"R\"));\n      // Mix of remove and modify acl flags are not allowed\n      boolean bothRemoveOptions \u003d cf.getOpt(\"b\") \u0026\u0026 cf.getOpt(\"k\");\n      boolean bothModifyOptions \u003d cf.getOpt(\"m\") \u0026\u0026 cf.getOpt(\"x\");\n      boolean oneRemoveOption \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\");\n      boolean oneModifyOption \u003d cf.getOpt(\"m\") || cf.getOpt(\"x\");\n      boolean setOption \u003d cf.getOpt(\"-set\");\n      boolean hasExpectedOptions \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\") ||\n          cf.getOpt(\"m\") || cf.getOpt(\"x\") || cf.getOpt(\"-set\");\n\n      if ((bothRemoveOptions || bothModifyOptions)\n          || (oneRemoveOption \u0026\u0026 oneModifyOption)\n          || (setOption \u0026\u0026 (oneRemoveOption || oneModifyOption))) {\n        throw new HadoopIllegalArgumentException(\n            \"Specified flags contains both remove and modify flags\");\n      }\n\n      // Only -m, -x and --set expects \u003cacl_spec\u003e\n      if (oneModifyOption || setOption) {\n        if (args.isEmpty()) {\n          throw new HadoopIllegalArgumentException(\n              \"Missing arguments: \u003cacl_spec\u003e \u003cpath\u003e\");\n        }\n        if (args.size() \u003c 2) {\n          throw new HadoopIllegalArgumentException(\n              \"Missing either \u003cacl_spec\u003e or \u003cpath\u003e\");\n        }\n        aclEntries \u003d AclEntry.parseAclSpec(args.removeFirst(), !cf.getOpt(\"x\"));\n        if (aclEntries.isEmpty()) {\n          throw new HadoopIllegalArgumentException(\n              \"Missing \u003cacl_spec\u003e entry\");\n        }\n      }\n\n      if (args.isEmpty()) {\n        throw new HadoopIllegalArgumentException(\"\u003cpath\u003e is missing\");\n      }\n      if (args.size() \u003e 1) {\n        throw new HadoopIllegalArgumentException(\"Too many arguments\");\n      }\n\n      if (!hasExpectedOptions) {\n        throw new HadoopIllegalArgumentException(\n            \"Expected one of -b, -k, -m, -x or --set options\");\n      }\n      // In recursive mode, save a separate list of just the access ACL entries.\n      // Only directories may have a default ACL.  When a recursive operation\n      // encounters a file under the specified path, it must pass only the\n      // access ACL entries.\n      if (isRecursive() \u0026\u0026 (oneModifyOption || setOption)) {\n        accessAclEntries \u003d Lists.newArrayList();\n        for (AclEntry entry: aclEntries) {\n          if (entry.getScope() \u003d\u003d AclEntryScope.ACCESS) {\n            accessAclEntries.add(entry);\n          }\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/AclCommands.java",
      "extendedDetails": {}
    },
    "b3649adf6a1b2dc47566b4b0d652bd4e0a6a8056": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9852. hdfs dfs -setfacl error message is misleading (Wei-Chiu Chuang via aw)\n",
      "commitDate": "28/06/16 8:47 PM",
      "commitName": "b3649adf6a1b2dc47566b4b0d652bd4e0a6a8056",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "11/02/16 10:23 PM",
      "commitNameOld": "c78740a979c1b434c6595b302bd376fc3d432509",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 137.89,
      "commitsBetweenForRepo": 905,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,56 @@\n     protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n       cf.parse(args);\n       setRecursive(cf.getOpt(\"R\"));\n       // Mix of remove and modify acl flags are not allowed\n       boolean bothRemoveOptions \u003d cf.getOpt(\"b\") \u0026\u0026 cf.getOpt(\"k\");\n       boolean bothModifyOptions \u003d cf.getOpt(\"m\") \u0026\u0026 cf.getOpt(\"x\");\n       boolean oneRemoveOption \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\");\n       boolean oneModifyOption \u003d cf.getOpt(\"m\") || cf.getOpt(\"x\");\n       boolean setOption \u003d cf.getOpt(\"-set\");\n+      boolean hasExpectedOptions \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\") ||\n+          cf.getOpt(\"m\") || cf.getOpt(\"x\") || cf.getOpt(\"-set\");\n+\n       if ((bothRemoveOptions || bothModifyOptions)\n           || (oneRemoveOption \u0026\u0026 oneModifyOption)\n           || (setOption \u0026\u0026 (oneRemoveOption || oneModifyOption))) {\n         throw new HadoopIllegalArgumentException(\n             \"Specified flags contains both remove and modify flags\");\n       }\n \n       // Only -m, -x and --set expects \u003cacl_spec\u003e\n       if (oneModifyOption || setOption) {\n+        if (args.isEmpty()) {\n+          throw new HadoopIllegalArgumentException(\n+              \"Missing arguments: \u003cacl_spec\u003e \u003cpath\u003e\");\n+        }\n         if (args.size() \u003c 2) {\n-          throw new HadoopIllegalArgumentException(\"\u003cacl_spec\u003e is missing\");\n+          throw new HadoopIllegalArgumentException(\n+              \"Missing either \u003cacl_spec\u003e or \u003cpath\u003e\");\n         }\n         aclEntries \u003d AclEntry.parseAclSpec(args.removeFirst(), !cf.getOpt(\"x\"));\n       }\n \n       if (args.isEmpty()) {\n         throw new HadoopIllegalArgumentException(\"\u003cpath\u003e is missing\");\n       }\n       if (args.size() \u003e 1) {\n         throw new HadoopIllegalArgumentException(\"Too many arguments\");\n       }\n \n+      if (!hasExpectedOptions) {\n+        throw new HadoopIllegalArgumentException(\n+            \"Expected one of -b, -k, -m, -x or --set options\");\n+      }\n       // In recursive mode, save a separate list of just the access ACL entries.\n       // Only directories may have a default ACL.  When a recursive operation\n       // encounters a file under the specified path, it must pass only the\n       // access ACL entries.\n       if (isRecursive() \u0026\u0026 (oneModifyOption || setOption)) {\n         accessAclEntries \u003d Lists.newArrayList();\n         for (AclEntry entry: aclEntries) {\n           if (entry.getScope() \u003d\u003d AclEntryScope.ACCESS) {\n             accessAclEntries.add(entry);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n      cf.parse(args);\n      setRecursive(cf.getOpt(\"R\"));\n      // Mix of remove and modify acl flags are not allowed\n      boolean bothRemoveOptions \u003d cf.getOpt(\"b\") \u0026\u0026 cf.getOpt(\"k\");\n      boolean bothModifyOptions \u003d cf.getOpt(\"m\") \u0026\u0026 cf.getOpt(\"x\");\n      boolean oneRemoveOption \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\");\n      boolean oneModifyOption \u003d cf.getOpt(\"m\") || cf.getOpt(\"x\");\n      boolean setOption \u003d cf.getOpt(\"-set\");\n      boolean hasExpectedOptions \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\") ||\n          cf.getOpt(\"m\") || cf.getOpt(\"x\") || cf.getOpt(\"-set\");\n\n      if ((bothRemoveOptions || bothModifyOptions)\n          || (oneRemoveOption \u0026\u0026 oneModifyOption)\n          || (setOption \u0026\u0026 (oneRemoveOption || oneModifyOption))) {\n        throw new HadoopIllegalArgumentException(\n            \"Specified flags contains both remove and modify flags\");\n      }\n\n      // Only -m, -x and --set expects \u003cacl_spec\u003e\n      if (oneModifyOption || setOption) {\n        if (args.isEmpty()) {\n          throw new HadoopIllegalArgumentException(\n              \"Missing arguments: \u003cacl_spec\u003e \u003cpath\u003e\");\n        }\n        if (args.size() \u003c 2) {\n          throw new HadoopIllegalArgumentException(\n              \"Missing either \u003cacl_spec\u003e or \u003cpath\u003e\");\n        }\n        aclEntries \u003d AclEntry.parseAclSpec(args.removeFirst(), !cf.getOpt(\"x\"));\n      }\n\n      if (args.isEmpty()) {\n        throw new HadoopIllegalArgumentException(\"\u003cpath\u003e is missing\");\n      }\n      if (args.size() \u003e 1) {\n        throw new HadoopIllegalArgumentException(\"Too many arguments\");\n      }\n\n      if (!hasExpectedOptions) {\n        throw new HadoopIllegalArgumentException(\n            \"Expected one of -b, -k, -m, -x or --set options\");\n      }\n      // In recursive mode, save a separate list of just the access ACL entries.\n      // Only directories may have a default ACL.  When a recursive operation\n      // encounters a file under the specified path, it must pass only the\n      // access ACL entries.\n      if (isRecursive() \u0026\u0026 (oneModifyOption || setOption)) {\n        accessAclEntries \u003d Lists.newArrayList();\n        for (AclEntry entry: aclEntries) {\n          if (entry.getScope() \u003d\u003d AclEntryScope.ACCESS) {\n            accessAclEntries.add(entry);\n          }\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/AclCommands.java",
      "extendedDetails": {}
    },
    "327d2ceca22119a73ea05ddf4620e5253a2fded6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10352. Recursive setfacl erroneously attempts to apply default ACL to files. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570466 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/02/14 10:29 PM",
      "commitName": "327d2ceca22119a73ea05ddf4620e5253a2fded6",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "12/02/14 2:54 PM",
      "commitNameOld": "fc14360b0340a33c0e1eb34967d4dcd772533418",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 8.32,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,44 @@\n     protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n       cf.parse(args);\n       setRecursive(cf.getOpt(\"R\"));\n       // Mix of remove and modify acl flags are not allowed\n       boolean bothRemoveOptions \u003d cf.getOpt(\"b\") \u0026\u0026 cf.getOpt(\"k\");\n       boolean bothModifyOptions \u003d cf.getOpt(\"m\") \u0026\u0026 cf.getOpt(\"x\");\n       boolean oneRemoveOption \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\");\n       boolean oneModifyOption \u003d cf.getOpt(\"m\") || cf.getOpt(\"x\");\n       boolean setOption \u003d cf.getOpt(\"-set\");\n       if ((bothRemoveOptions || bothModifyOptions)\n           || (oneRemoveOption \u0026\u0026 oneModifyOption)\n           || (setOption \u0026\u0026 (oneRemoveOption || oneModifyOption))) {\n         throw new HadoopIllegalArgumentException(\n             \"Specified flags contains both remove and modify flags\");\n       }\n \n       // Only -m, -x and --set expects \u003cacl_spec\u003e\n       if (oneModifyOption || setOption) {\n         if (args.size() \u003c 2) {\n           throw new HadoopIllegalArgumentException(\"\u003cacl_spec\u003e is missing\");\n         }\n         aclEntries \u003d AclEntry.parseAclSpec(args.removeFirst(), !cf.getOpt(\"x\"));\n       }\n \n       if (args.isEmpty()) {\n         throw new HadoopIllegalArgumentException(\"\u003cpath\u003e is missing\");\n       }\n       if (args.size() \u003e 1) {\n         throw new HadoopIllegalArgumentException(\"Too many arguments\");\n       }\n+\n+      // In recursive mode, save a separate list of just the access ACL entries.\n+      // Only directories may have a default ACL.  When a recursive operation\n+      // encounters a file under the specified path, it must pass only the\n+      // access ACL entries.\n+      if (isRecursive() \u0026\u0026 (oneModifyOption || setOption)) {\n+        accessAclEntries \u003d Lists.newArrayList();\n+        for (AclEntry entry: aclEntries) {\n+          if (entry.getScope() \u003d\u003d AclEntryScope.ACCESS) {\n+            accessAclEntries.add(entry);\n+          }\n+        }\n+      }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n      cf.parse(args);\n      setRecursive(cf.getOpt(\"R\"));\n      // Mix of remove and modify acl flags are not allowed\n      boolean bothRemoveOptions \u003d cf.getOpt(\"b\") \u0026\u0026 cf.getOpt(\"k\");\n      boolean bothModifyOptions \u003d cf.getOpt(\"m\") \u0026\u0026 cf.getOpt(\"x\");\n      boolean oneRemoveOption \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\");\n      boolean oneModifyOption \u003d cf.getOpt(\"m\") || cf.getOpt(\"x\");\n      boolean setOption \u003d cf.getOpt(\"-set\");\n      if ((bothRemoveOptions || bothModifyOptions)\n          || (oneRemoveOption \u0026\u0026 oneModifyOption)\n          || (setOption \u0026\u0026 (oneRemoveOption || oneModifyOption))) {\n        throw new HadoopIllegalArgumentException(\n            \"Specified flags contains both remove and modify flags\");\n      }\n\n      // Only -m, -x and --set expects \u003cacl_spec\u003e\n      if (oneModifyOption || setOption) {\n        if (args.size() \u003c 2) {\n          throw new HadoopIllegalArgumentException(\"\u003cacl_spec\u003e is missing\");\n        }\n        aclEntries \u003d AclEntry.parseAclSpec(args.removeFirst(), !cf.getOpt(\"x\"));\n      }\n\n      if (args.isEmpty()) {\n        throw new HadoopIllegalArgumentException(\"\u003cpath\u003e is missing\");\n      }\n      if (args.size() \u003e 1) {\n        throw new HadoopIllegalArgumentException(\"Too many arguments\");\n      }\n\n      // In recursive mode, save a separate list of just the access ACL entries.\n      // Only directories may have a default ACL.  When a recursive operation\n      // encounters a file under the specified path, it must pass only the\n      // access ACL entries.\n      if (isRecursive() \u0026\u0026 (oneModifyOption || setOption)) {\n        accessAclEntries \u003d Lists.newArrayList();\n        for (AclEntry entry: aclEntries) {\n          if (entry.getScope() \u003d\u003d AclEntryScope.ACCESS) {\n            accessAclEntries.add(entry);\n          }\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/AclCommands.java",
      "extendedDetails": {}
    },
    "cae96dfe6e7c57f927bd825711977ae9199776a9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10213. Fix bugs parsing ACL spec in FsShell setfacl. Contributed by Vinay.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1559793 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/01/14 10:00 AM",
      "commitName": "cae96dfe6e7c57f927bd825711977ae9199776a9",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "17/01/14 2:05 PM",
      "commitNameOld": "5300294fbe9e235ce42253d6bcd69d8154d8f198",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 2.83,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,31 @@\n     protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n       cf.parse(args);\n       setRecursive(cf.getOpt(\"R\"));\n       // Mix of remove and modify acl flags are not allowed\n       boolean bothRemoveOptions \u003d cf.getOpt(\"b\") \u0026\u0026 cf.getOpt(\"k\");\n       boolean bothModifyOptions \u003d cf.getOpt(\"m\") \u0026\u0026 cf.getOpt(\"x\");\n       boolean oneRemoveOption \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\");\n       boolean oneModifyOption \u003d cf.getOpt(\"m\") || cf.getOpt(\"x\");\n       boolean setOption \u003d cf.getOpt(\"-set\");\n       if ((bothRemoveOptions || bothModifyOptions)\n           || (oneRemoveOption \u0026\u0026 oneModifyOption)\n           || (setOption \u0026\u0026 (oneRemoveOption || oneModifyOption))) {\n         throw new HadoopIllegalArgumentException(\n             \"Specified flags contains both remove and modify flags\");\n       }\n \n       // Only -m, -x and --set expects \u003cacl_spec\u003e\n       if (oneModifyOption || setOption) {\n         if (args.size() \u003c 2) {\n           throw new HadoopIllegalArgumentException(\"\u003cacl_spec\u003e is missing\");\n         }\n-        aclEntries \u003d parseAclSpec(args.removeFirst());\n+        aclEntries \u003d AclEntry.parseAclSpec(args.removeFirst(), !cf.getOpt(\"x\"));\n       }\n \n       if (args.isEmpty()) {\n         throw new HadoopIllegalArgumentException(\"\u003cpath\u003e is missing\");\n       }\n       if (args.size() \u003e 1) {\n         throw new HadoopIllegalArgumentException(\"Too many arguments\");\n       }\n-      path \u003d new Path(args.removeFirst());\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n      cf.parse(args);\n      setRecursive(cf.getOpt(\"R\"));\n      // Mix of remove and modify acl flags are not allowed\n      boolean bothRemoveOptions \u003d cf.getOpt(\"b\") \u0026\u0026 cf.getOpt(\"k\");\n      boolean bothModifyOptions \u003d cf.getOpt(\"m\") \u0026\u0026 cf.getOpt(\"x\");\n      boolean oneRemoveOption \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\");\n      boolean oneModifyOption \u003d cf.getOpt(\"m\") || cf.getOpt(\"x\");\n      boolean setOption \u003d cf.getOpt(\"-set\");\n      if ((bothRemoveOptions || bothModifyOptions)\n          || (oneRemoveOption \u0026\u0026 oneModifyOption)\n          || (setOption \u0026\u0026 (oneRemoveOption || oneModifyOption))) {\n        throw new HadoopIllegalArgumentException(\n            \"Specified flags contains both remove and modify flags\");\n      }\n\n      // Only -m, -x and --set expects \u003cacl_spec\u003e\n      if (oneModifyOption || setOption) {\n        if (args.size() \u003c 2) {\n          throw new HadoopIllegalArgumentException(\"\u003cacl_spec\u003e is missing\");\n        }\n        aclEntries \u003d AclEntry.parseAclSpec(args.removeFirst(), !cf.getOpt(\"x\"));\n      }\n\n      if (args.isEmpty()) {\n        throw new HadoopIllegalArgumentException(\"\u003cpath\u003e is missing\");\n      }\n      if (args.size() \u003e 1) {\n        throw new HadoopIllegalArgumentException(\"Too many arguments\");\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/AclCommands.java",
      "extendedDetails": {}
    },
    "abe13d6ffb0009df859077032aaa19a6d894ae36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10187. add getfacl and setfacl with minimal support for getting and setting ACLs. Contributed by Vinay.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1553735 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/12/13 12:41 PM",
      "commitName": "abe13d6ffb0009df859077032aaa19a6d894ae36",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,32 @@\n+    protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n+      cf.parse(args);\n+      setRecursive(cf.getOpt(\"R\"));\n+      // Mix of remove and modify acl flags are not allowed\n+      boolean bothRemoveOptions \u003d cf.getOpt(\"b\") \u0026\u0026 cf.getOpt(\"k\");\n+      boolean bothModifyOptions \u003d cf.getOpt(\"m\") \u0026\u0026 cf.getOpt(\"x\");\n+      boolean oneRemoveOption \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\");\n+      boolean oneModifyOption \u003d cf.getOpt(\"m\") || cf.getOpt(\"x\");\n+      boolean setOption \u003d cf.getOpt(\"-set\");\n+      if ((bothRemoveOptions || bothModifyOptions)\n+          || (oneRemoveOption \u0026\u0026 oneModifyOption)\n+          || (setOption \u0026\u0026 (oneRemoveOption || oneModifyOption))) {\n+        throw new HadoopIllegalArgumentException(\n+            \"Specified flags contains both remove and modify flags\");\n+      }\n+\n+      // Only -m, -x and --set expects \u003cacl_spec\u003e\n+      if (oneModifyOption || setOption) {\n+        if (args.size() \u003c 2) {\n+          throw new HadoopIllegalArgumentException(\"\u003cacl_spec\u003e is missing\");\n+        }\n+        aclEntries \u003d parseAclSpec(args.removeFirst());\n+      }\n+\n+      if (args.isEmpty()) {\n+        throw new HadoopIllegalArgumentException(\"\u003cpath\u003e is missing\");\n+      }\n+      if (args.size() \u003e 1) {\n+        throw new HadoopIllegalArgumentException(\"Too many arguments\");\n+      }\n+      path \u003d new Path(args.removeFirst());\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processOptions(LinkedList\u003cString\u003e args) throws IOException {\n      cf.parse(args);\n      setRecursive(cf.getOpt(\"R\"));\n      // Mix of remove and modify acl flags are not allowed\n      boolean bothRemoveOptions \u003d cf.getOpt(\"b\") \u0026\u0026 cf.getOpt(\"k\");\n      boolean bothModifyOptions \u003d cf.getOpt(\"m\") \u0026\u0026 cf.getOpt(\"x\");\n      boolean oneRemoveOption \u003d cf.getOpt(\"b\") || cf.getOpt(\"k\");\n      boolean oneModifyOption \u003d cf.getOpt(\"m\") || cf.getOpt(\"x\");\n      boolean setOption \u003d cf.getOpt(\"-set\");\n      if ((bothRemoveOptions || bothModifyOptions)\n          || (oneRemoveOption \u0026\u0026 oneModifyOption)\n          || (setOption \u0026\u0026 (oneRemoveOption || oneModifyOption))) {\n        throw new HadoopIllegalArgumentException(\n            \"Specified flags contains both remove and modify flags\");\n      }\n\n      // Only -m, -x and --set expects \u003cacl_spec\u003e\n      if (oneModifyOption || setOption) {\n        if (args.size() \u003c 2) {\n          throw new HadoopIllegalArgumentException(\"\u003cacl_spec\u003e is missing\");\n        }\n        aclEntries \u003d parseAclSpec(args.removeFirst());\n      }\n\n      if (args.isEmpty()) {\n        throw new HadoopIllegalArgumentException(\"\u003cpath\u003e is missing\");\n      }\n      if (args.size() \u003e 1) {\n        throw new HadoopIllegalArgumentException(\"Too many arguments\");\n      }\n      path \u003d new Path(args.removeFirst());\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/shell/AclCommands.java"
    }
  }
}