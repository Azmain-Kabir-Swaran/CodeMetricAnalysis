{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CopyListing.java",
  "functionName": "validateFinalListing",
  "functionId": "validateFinalListing___pathToListFile-Path__context-DistCpContext",
  "sourceFilePath": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/CopyListing.java",
  "functionStartLine": 142,
  "functionEndLine": 221,
  "numCommitsSeen": 26,
  "timeTaken": 5116,
  "changeHistory": [
    "1976e0066e9ae8852715fa69d8aea3769330e933",
    "26172a94d6431e70d7fe15d66be9a7e195f79f60",
    "bf3fb585aaf2b179836e139c041fc87920a3c886",
    "144f1cf76527e6c75aec77ef683a898580f3cc8d",
    "064c8b25eca9bc825dc07a54d9147d65c9290a03",
    "0bc15cb6e60dc60885234e01dec1c7cb4557a926",
    "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9",
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05"
  ],
  "changeHistoryShort": {
    "1976e0066e9ae8852715fa69d8aea3769330e933": "Ybodychange",
    "26172a94d6431e70d7fe15d66be9a7e195f79f60": "Ymultichange(Yparameterchange,Ybodychange)",
    "bf3fb585aaf2b179836e139c041fc87920a3c886": "Ybodychange",
    "144f1cf76527e6c75aec77ef683a898580f3cc8d": "Ybodychange",
    "064c8b25eca9bc825dc07a54d9147d65c9290a03": "Ybodychange",
    "0bc15cb6e60dc60885234e01dec1c7cb4557a926": "Ybodychange",
    "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9": "Ybodychange",
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1976e0066e9ae8852715fa69d8aea3769330e933": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15209. DistCp to eliminate needless deletion of files under already-deleted directories.\nContributed by Steve Loughran.\n",
      "commitDate": "15/03/18 11:05 AM",
      "commitName": "1976e0066e9ae8852715fa69d8aea3769330e933",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "31/03/17 8:04 PM",
      "commitNameOld": "26172a94d6431e70d7fe15d66be9a7e195f79f60",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 348.63,
      "commitsBetweenForRepo": 2337,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,80 @@\n   private void validateFinalListing(Path pathToListFile, DistCpContext context)\n       throws DuplicateFileException, IOException {\n \n     Configuration config \u003d getConf();\n-    FileSystem fs \u003d pathToListFile.getFileSystem(config);\n \n     final boolean splitLargeFile \u003d context.splitLargeFile();\n \n     // When splitLargeFile is enabled, we don\u0027t randomize the copylist\n     // earlier, so we don\u0027t do the sorting here. For a file that has\n     // multiple entries due to split, we check here that their\n     // \u003cchunkOffset, chunkLength\u003e is continuous.\n     //\n     Path checkPath \u003d splitLargeFile?\n-        pathToListFile : DistCpUtils.sortListing(fs, config, pathToListFile);\n+        pathToListFile : DistCpUtils.sortListing(config, pathToListFile);\n \n     SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                           config, SequenceFile.Reader.file(checkPath));\n     try {\n       Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n       long lastChunkOffset \u003d -1;\n       long lastChunkLength \u003d -1;\n       CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n \n       Text currentKey \u003d new Text();\n       Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n       Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n       long idx \u003d 0;\n       while (reader.next(currentKey)) {\n         if (currentKey.equals(lastKey)) {\n           CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n           reader.getCurrentValue(currentFileStatus);\n           if (!splitLargeFile) {\n             throw new DuplicateFileException(\"File \" + lastFileStatus.getPath()\n                 + \" and \" + currentFileStatus.getPath()\n                 + \" would cause duplicates. Aborting\");\n           } else {\n             if (lastChunkOffset + lastChunkLength !\u003d\n                 currentFileStatus.getChunkOffset()) {\n               throw new InvalidInputException(\"File \" + lastFileStatus.getPath()\n                   + \" \" + lastChunkOffset + \",\" + lastChunkLength\n                   + \" and \" + currentFileStatus.getPath()\n                   + \" \" + currentFileStatus.getChunkOffset() + \",\"\n                   + currentFileStatus.getChunkLength()\n                   + \" are not continuous. Aborting\");\n             }\n           }\n         }\n         reader.getCurrentValue(lastFileStatus);\n         if (context.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemAclSupport(lastFs);\n             aclSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n         if (context.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n             xAttrSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n \n         lastKey.set(currentKey);\n         if (splitLargeFile) {\n           lastChunkOffset \u003d lastFileStatus.getChunkOffset();\n           lastChunkLength \u003d lastFileStatus.getChunkLength();\n         }\n         if (context.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n           LOG.debug(\"Copy list entry \" + idx + \": \" +\n                   lastFileStatus.getPath().toUri().getPath());\n           idx++;\n         }\n       }\n     } finally {\n       IOUtils.closeStream(reader);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateFinalListing(Path pathToListFile, DistCpContext context)\n      throws DuplicateFileException, IOException {\n\n    Configuration config \u003d getConf();\n\n    final boolean splitLargeFile \u003d context.splitLargeFile();\n\n    // When splitLargeFile is enabled, we don\u0027t randomize the copylist\n    // earlier, so we don\u0027t do the sorting here. For a file that has\n    // multiple entries due to split, we check here that their\n    // \u003cchunkOffset, chunkLength\u003e is continuous.\n    //\n    Path checkPath \u003d splitLargeFile?\n        pathToListFile : DistCpUtils.sortListing(config, pathToListFile);\n\n    SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                          config, SequenceFile.Reader.file(checkPath));\n    try {\n      Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n      long lastChunkOffset \u003d -1;\n      long lastChunkLength \u003d -1;\n      CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n\n      Text currentKey \u003d new Text();\n      Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n      Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n      long idx \u003d 0;\n      while (reader.next(currentKey)) {\n        if (currentKey.equals(lastKey)) {\n          CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n          reader.getCurrentValue(currentFileStatus);\n          if (!splitLargeFile) {\n            throw new DuplicateFileException(\"File \" + lastFileStatus.getPath()\n                + \" and \" + currentFileStatus.getPath()\n                + \" would cause duplicates. Aborting\");\n          } else {\n            if (lastChunkOffset + lastChunkLength !\u003d\n                currentFileStatus.getChunkOffset()) {\n              throw new InvalidInputException(\"File \" + lastFileStatus.getPath()\n                  + \" \" + lastChunkOffset + \",\" + lastChunkLength\n                  + \" and \" + currentFileStatus.getPath()\n                  + \" \" + currentFileStatus.getChunkOffset() + \",\"\n                  + currentFileStatus.getChunkLength()\n                  + \" are not continuous. Aborting\");\n            }\n          }\n        }\n        reader.getCurrentValue(lastFileStatus);\n        if (context.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemAclSupport(lastFs);\n            aclSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        if (context.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n            xAttrSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n\n        lastKey.set(currentKey);\n        if (splitLargeFile) {\n          lastChunkOffset \u003d lastFileStatus.getChunkOffset();\n          lastChunkLength \u003d lastFileStatus.getChunkLength();\n        }\n        if (context.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n          LOG.debug(\"Copy list entry \" + idx + \": \" +\n                  lastFileStatus.getPath().toUri().getPath());\n          idx++;\n        }\n      }\n    } finally {\n      IOUtils.closeStream(reader);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/CopyListing.java",
      "extendedDetails": {}
    },
    "26172a94d6431e70d7fe15d66be9a7e195f79f60": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-14267. Make DistCpOptions immutable. Contributed by Mingliang Liu\n",
      "commitDate": "31/03/17 8:04 PM",
      "commitName": "26172a94d6431e70d7fe15d66be9a7e195f79f60",
      "commitAuthor": "Mingliang Liu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-14267. Make DistCpOptions immutable. Contributed by Mingliang Liu\n",
          "commitDate": "31/03/17 8:04 PM",
          "commitName": "26172a94d6431e70d7fe15d66be9a7e195f79f60",
          "commitAuthor": "Mingliang Liu",
          "commitDateOld": "30/03/17 5:38 PM",
          "commitNameOld": "bf3fb585aaf2b179836e139c041fc87920a3c886",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 1.1,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,81 @@\n-  private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n+  private void validateFinalListing(Path pathToListFile, DistCpContext context)\n       throws DuplicateFileException, IOException {\n \n     Configuration config \u003d getConf();\n     FileSystem fs \u003d pathToListFile.getFileSystem(config);\n \n-    final boolean splitLargeFile \u003d options.splitLargeFile();\n+    final boolean splitLargeFile \u003d context.splitLargeFile();\n \n     // When splitLargeFile is enabled, we don\u0027t randomize the copylist\n     // earlier, so we don\u0027t do the sorting here. For a file that has\n     // multiple entries due to split, we check here that their\n     // \u003cchunkOffset, chunkLength\u003e is continuous.\n     //\n     Path checkPath \u003d splitLargeFile?\n         pathToListFile : DistCpUtils.sortListing(fs, config, pathToListFile);\n \n     SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                           config, SequenceFile.Reader.file(checkPath));\n     try {\n       Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n       long lastChunkOffset \u003d -1;\n       long lastChunkLength \u003d -1;\n       CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n \n       Text currentKey \u003d new Text();\n       Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n       Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n       long idx \u003d 0;\n       while (reader.next(currentKey)) {\n         if (currentKey.equals(lastKey)) {\n           CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n           reader.getCurrentValue(currentFileStatus);\n           if (!splitLargeFile) {\n             throw new DuplicateFileException(\"File \" + lastFileStatus.getPath()\n                 + \" and \" + currentFileStatus.getPath()\n                 + \" would cause duplicates. Aborting\");\n           } else {\n             if (lastChunkOffset + lastChunkLength !\u003d\n                 currentFileStatus.getChunkOffset()) {\n               throw new InvalidInputException(\"File \" + lastFileStatus.getPath()\n                   + \" \" + lastChunkOffset + \",\" + lastChunkLength\n                   + \" and \" + currentFileStatus.getPath()\n                   + \" \" + currentFileStatus.getChunkOffset() + \",\"\n                   + currentFileStatus.getChunkLength()\n                   + \" are not continuous. Aborting\");\n             }\n           }\n         }\n         reader.getCurrentValue(lastFileStatus);\n-        if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n+        if (context.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemAclSupport(lastFs);\n             aclSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n-        if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n+        if (context.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n             xAttrSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n \n         lastKey.set(currentKey);\n         if (splitLargeFile) {\n           lastChunkOffset \u003d lastFileStatus.getChunkOffset();\n           lastChunkLength \u003d lastFileStatus.getChunkLength();\n         }\n-        if (options.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n+        if (context.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n           LOG.debug(\"Copy list entry \" + idx + \": \" +\n                   lastFileStatus.getPath().toUri().getPath());\n           idx++;\n         }\n       }\n     } finally {\n       IOUtils.closeStream(reader);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void validateFinalListing(Path pathToListFile, DistCpContext context)\n      throws DuplicateFileException, IOException {\n\n    Configuration config \u003d getConf();\n    FileSystem fs \u003d pathToListFile.getFileSystem(config);\n\n    final boolean splitLargeFile \u003d context.splitLargeFile();\n\n    // When splitLargeFile is enabled, we don\u0027t randomize the copylist\n    // earlier, so we don\u0027t do the sorting here. For a file that has\n    // multiple entries due to split, we check here that their\n    // \u003cchunkOffset, chunkLength\u003e is continuous.\n    //\n    Path checkPath \u003d splitLargeFile?\n        pathToListFile : DistCpUtils.sortListing(fs, config, pathToListFile);\n\n    SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                          config, SequenceFile.Reader.file(checkPath));\n    try {\n      Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n      long lastChunkOffset \u003d -1;\n      long lastChunkLength \u003d -1;\n      CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n\n      Text currentKey \u003d new Text();\n      Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n      Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n      long idx \u003d 0;\n      while (reader.next(currentKey)) {\n        if (currentKey.equals(lastKey)) {\n          CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n          reader.getCurrentValue(currentFileStatus);\n          if (!splitLargeFile) {\n            throw new DuplicateFileException(\"File \" + lastFileStatus.getPath()\n                + \" and \" + currentFileStatus.getPath()\n                + \" would cause duplicates. Aborting\");\n          } else {\n            if (lastChunkOffset + lastChunkLength !\u003d\n                currentFileStatus.getChunkOffset()) {\n              throw new InvalidInputException(\"File \" + lastFileStatus.getPath()\n                  + \" \" + lastChunkOffset + \",\" + lastChunkLength\n                  + \" and \" + currentFileStatus.getPath()\n                  + \" \" + currentFileStatus.getChunkOffset() + \",\"\n                  + currentFileStatus.getChunkLength()\n                  + \" are not continuous. Aborting\");\n            }\n          }\n        }\n        reader.getCurrentValue(lastFileStatus);\n        if (context.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemAclSupport(lastFs);\n            aclSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        if (context.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n            xAttrSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n\n        lastKey.set(currentKey);\n        if (splitLargeFile) {\n          lastChunkOffset \u003d lastFileStatus.getChunkOffset();\n          lastChunkLength \u003d lastFileStatus.getChunkLength();\n        }\n        if (context.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n          LOG.debug(\"Copy list entry \" + idx + \": \" +\n                  lastFileStatus.getPath().toUri().getPath());\n          idx++;\n        }\n      }\n    } finally {\n      IOUtils.closeStream(reader);\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/CopyListing.java",
          "extendedDetails": {
            "oldValue": "[pathToListFile-Path, options-DistCpOptions]",
            "newValue": "[pathToListFile-Path, context-DistCpContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14267. Make DistCpOptions immutable. Contributed by Mingliang Liu\n",
          "commitDate": "31/03/17 8:04 PM",
          "commitName": "26172a94d6431e70d7fe15d66be9a7e195f79f60",
          "commitAuthor": "Mingliang Liu",
          "commitDateOld": "30/03/17 5:38 PM",
          "commitNameOld": "bf3fb585aaf2b179836e139c041fc87920a3c886",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 1.1,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,81 @@\n-  private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n+  private void validateFinalListing(Path pathToListFile, DistCpContext context)\n       throws DuplicateFileException, IOException {\n \n     Configuration config \u003d getConf();\n     FileSystem fs \u003d pathToListFile.getFileSystem(config);\n \n-    final boolean splitLargeFile \u003d options.splitLargeFile();\n+    final boolean splitLargeFile \u003d context.splitLargeFile();\n \n     // When splitLargeFile is enabled, we don\u0027t randomize the copylist\n     // earlier, so we don\u0027t do the sorting here. For a file that has\n     // multiple entries due to split, we check here that their\n     // \u003cchunkOffset, chunkLength\u003e is continuous.\n     //\n     Path checkPath \u003d splitLargeFile?\n         pathToListFile : DistCpUtils.sortListing(fs, config, pathToListFile);\n \n     SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                           config, SequenceFile.Reader.file(checkPath));\n     try {\n       Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n       long lastChunkOffset \u003d -1;\n       long lastChunkLength \u003d -1;\n       CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n \n       Text currentKey \u003d new Text();\n       Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n       Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n       long idx \u003d 0;\n       while (reader.next(currentKey)) {\n         if (currentKey.equals(lastKey)) {\n           CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n           reader.getCurrentValue(currentFileStatus);\n           if (!splitLargeFile) {\n             throw new DuplicateFileException(\"File \" + lastFileStatus.getPath()\n                 + \" and \" + currentFileStatus.getPath()\n                 + \" would cause duplicates. Aborting\");\n           } else {\n             if (lastChunkOffset + lastChunkLength !\u003d\n                 currentFileStatus.getChunkOffset()) {\n               throw new InvalidInputException(\"File \" + lastFileStatus.getPath()\n                   + \" \" + lastChunkOffset + \",\" + lastChunkLength\n                   + \" and \" + currentFileStatus.getPath()\n                   + \" \" + currentFileStatus.getChunkOffset() + \",\"\n                   + currentFileStatus.getChunkLength()\n                   + \" are not continuous. Aborting\");\n             }\n           }\n         }\n         reader.getCurrentValue(lastFileStatus);\n-        if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n+        if (context.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemAclSupport(lastFs);\n             aclSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n-        if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n+        if (context.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n             xAttrSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n \n         lastKey.set(currentKey);\n         if (splitLargeFile) {\n           lastChunkOffset \u003d lastFileStatus.getChunkOffset();\n           lastChunkLength \u003d lastFileStatus.getChunkLength();\n         }\n-        if (options.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n+        if (context.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n           LOG.debug(\"Copy list entry \" + idx + \": \" +\n                   lastFileStatus.getPath().toUri().getPath());\n           idx++;\n         }\n       }\n     } finally {\n       IOUtils.closeStream(reader);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void validateFinalListing(Path pathToListFile, DistCpContext context)\n      throws DuplicateFileException, IOException {\n\n    Configuration config \u003d getConf();\n    FileSystem fs \u003d pathToListFile.getFileSystem(config);\n\n    final boolean splitLargeFile \u003d context.splitLargeFile();\n\n    // When splitLargeFile is enabled, we don\u0027t randomize the copylist\n    // earlier, so we don\u0027t do the sorting here. For a file that has\n    // multiple entries due to split, we check here that their\n    // \u003cchunkOffset, chunkLength\u003e is continuous.\n    //\n    Path checkPath \u003d splitLargeFile?\n        pathToListFile : DistCpUtils.sortListing(fs, config, pathToListFile);\n\n    SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                          config, SequenceFile.Reader.file(checkPath));\n    try {\n      Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n      long lastChunkOffset \u003d -1;\n      long lastChunkLength \u003d -1;\n      CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n\n      Text currentKey \u003d new Text();\n      Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n      Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n      long idx \u003d 0;\n      while (reader.next(currentKey)) {\n        if (currentKey.equals(lastKey)) {\n          CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n          reader.getCurrentValue(currentFileStatus);\n          if (!splitLargeFile) {\n            throw new DuplicateFileException(\"File \" + lastFileStatus.getPath()\n                + \" and \" + currentFileStatus.getPath()\n                + \" would cause duplicates. Aborting\");\n          } else {\n            if (lastChunkOffset + lastChunkLength !\u003d\n                currentFileStatus.getChunkOffset()) {\n              throw new InvalidInputException(\"File \" + lastFileStatus.getPath()\n                  + \" \" + lastChunkOffset + \",\" + lastChunkLength\n                  + \" and \" + currentFileStatus.getPath()\n                  + \" \" + currentFileStatus.getChunkOffset() + \",\"\n                  + currentFileStatus.getChunkLength()\n                  + \" are not continuous. Aborting\");\n            }\n          }\n        }\n        reader.getCurrentValue(lastFileStatus);\n        if (context.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemAclSupport(lastFs);\n            aclSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        if (context.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n            xAttrSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n\n        lastKey.set(currentKey);\n        if (splitLargeFile) {\n          lastChunkOffset \u003d lastFileStatus.getChunkOffset();\n          lastChunkLength \u003d lastFileStatus.getChunkLength();\n        }\n        if (context.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n          LOG.debug(\"Copy list entry \" + idx + \": \" +\n                  lastFileStatus.getPath().toUri().getPath());\n          idx++;\n        }\n      }\n    } finally {\n      IOUtils.closeStream(reader);\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/CopyListing.java",
          "extendedDetails": {}
        }
      ]
    },
    "bf3fb585aaf2b179836e139c041fc87920a3c886": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen, Rosie Li.\n",
      "commitDate": "30/03/17 5:38 PM",
      "commitName": "bf3fb585aaf2b179836e139c041fc87920a3c886",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "30/03/17 5:38 PM",
      "commitNameOld": "144f1cf76527e6c75aec77ef683a898580f3cc8d",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,81 @@\n   private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n       throws DuplicateFileException, IOException {\n \n     Configuration config \u003d getConf();\n     FileSystem fs \u003d pathToListFile.getFileSystem(config);\n \n-    Path sortedList \u003d DistCpUtils.sortListing(fs, config, pathToListFile);\n+    final boolean splitLargeFile \u003d options.splitLargeFile();\n+\n+    // When splitLargeFile is enabled, we don\u0027t randomize the copylist\n+    // earlier, so we don\u0027t do the sorting here. For a file that has\n+    // multiple entries due to split, we check here that their\n+    // \u003cchunkOffset, chunkLength\u003e is continuous.\n+    //\n+    Path checkPath \u003d splitLargeFile?\n+        pathToListFile : DistCpUtils.sortListing(fs, config, pathToListFile);\n \n     SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n-                          config, SequenceFile.Reader.file(sortedList));\n+                          config, SequenceFile.Reader.file(checkPath));\n     try {\n       Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n+      long lastChunkOffset \u003d -1;\n+      long lastChunkLength \u003d -1;\n       CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n \n       Text currentKey \u003d new Text();\n       Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n       Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n       long idx \u003d 0;\n       while (reader.next(currentKey)) {\n         if (currentKey.equals(lastKey)) {\n           CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n           reader.getCurrentValue(currentFileStatus);\n-          throw new DuplicateFileException(\"File \" + lastFileStatus.getPath() + \" and \" +\n-              currentFileStatus.getPath() + \" would cause duplicates. Aborting\");\n+          if (!splitLargeFile) {\n+            throw new DuplicateFileException(\"File \" + lastFileStatus.getPath()\n+                + \" and \" + currentFileStatus.getPath()\n+                + \" would cause duplicates. Aborting\");\n+          } else {\n+            if (lastChunkOffset + lastChunkLength !\u003d\n+                currentFileStatus.getChunkOffset()) {\n+              throw new InvalidInputException(\"File \" + lastFileStatus.getPath()\n+                  + \" \" + lastChunkOffset + \",\" + lastChunkLength\n+                  + \" and \" + currentFileStatus.getPath()\n+                  + \" \" + currentFileStatus.getChunkOffset() + \",\"\n+                  + currentFileStatus.getChunkLength()\n+                  + \" are not continuous. Aborting\");\n+            }\n+          }\n         }\n         reader.getCurrentValue(lastFileStatus);\n         if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemAclSupport(lastFs);\n             aclSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n         if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n             xAttrSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n-        lastKey.set(currentKey);\n \n+        lastKey.set(currentKey);\n+        if (splitLargeFile) {\n+          lastChunkOffset \u003d lastFileStatus.getChunkOffset();\n+          lastChunkLength \u003d lastFileStatus.getChunkLength();\n+        }\n         if (options.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n           LOG.debug(\"Copy list entry \" + idx + \": \" +\n                   lastFileStatus.getPath().toUri().getPath());\n           idx++;\n         }\n       }\n     } finally {\n       IOUtils.closeStream(reader);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n      throws DuplicateFileException, IOException {\n\n    Configuration config \u003d getConf();\n    FileSystem fs \u003d pathToListFile.getFileSystem(config);\n\n    final boolean splitLargeFile \u003d options.splitLargeFile();\n\n    // When splitLargeFile is enabled, we don\u0027t randomize the copylist\n    // earlier, so we don\u0027t do the sorting here. For a file that has\n    // multiple entries due to split, we check here that their\n    // \u003cchunkOffset, chunkLength\u003e is continuous.\n    //\n    Path checkPath \u003d splitLargeFile?\n        pathToListFile : DistCpUtils.sortListing(fs, config, pathToListFile);\n\n    SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                          config, SequenceFile.Reader.file(checkPath));\n    try {\n      Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n      long lastChunkOffset \u003d -1;\n      long lastChunkLength \u003d -1;\n      CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n\n      Text currentKey \u003d new Text();\n      Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n      Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n      long idx \u003d 0;\n      while (reader.next(currentKey)) {\n        if (currentKey.equals(lastKey)) {\n          CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n          reader.getCurrentValue(currentFileStatus);\n          if (!splitLargeFile) {\n            throw new DuplicateFileException(\"File \" + lastFileStatus.getPath()\n                + \" and \" + currentFileStatus.getPath()\n                + \" would cause duplicates. Aborting\");\n          } else {\n            if (lastChunkOffset + lastChunkLength !\u003d\n                currentFileStatus.getChunkOffset()) {\n              throw new InvalidInputException(\"File \" + lastFileStatus.getPath()\n                  + \" \" + lastChunkOffset + \",\" + lastChunkLength\n                  + \" and \" + currentFileStatus.getPath()\n                  + \" \" + currentFileStatus.getChunkOffset() + \",\"\n                  + currentFileStatus.getChunkLength()\n                  + \" are not continuous. Aborting\");\n            }\n          }\n        }\n        reader.getCurrentValue(lastFileStatus);\n        if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemAclSupport(lastFs);\n            aclSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n            xAttrSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n\n        lastKey.set(currentKey);\n        if (splitLargeFile) {\n          lastChunkOffset \u003d lastFileStatus.getChunkOffset();\n          lastChunkLength \u003d lastFileStatus.getChunkLength();\n        }\n        if (options.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n          LOG.debug(\"Copy list entry \" + idx + \": \" +\n                  lastFileStatus.getPath().toUri().getPath());\n          idx++;\n        }\n      }\n    } finally {\n      IOUtils.closeStream(reader);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/CopyListing.java",
      "extendedDetails": {}
    },
    "144f1cf76527e6c75aec77ef683a898580f3cc8d": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen.\"\n\nThis reverts commit 064c8b25eca9bc825dc07a54d9147d65c9290a03.\n",
      "commitDate": "30/03/17 5:38 PM",
      "commitName": "144f1cf76527e6c75aec77ef683a898580f3cc8d",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "30/03/17 5:01 PM",
      "commitNameOld": "064c8b25eca9bc825dc07a54d9147d65c9290a03",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,54 @@\n   private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n       throws DuplicateFileException, IOException {\n \n     Configuration config \u003d getConf();\n     FileSystem fs \u003d pathToListFile.getFileSystem(config);\n \n-    final boolean splitLargeFile \u003d options.splitLargeFile();\n-\n-    // When splitLargeFile is enabled, we don\u0027t randomize the copylist\n-    // earlier, so we don\u0027t do the sorting here. For a file that has\n-    // multiple entries due to split, we check here that their\n-    // \u003cchunkOffset, chunkLength\u003e is continuous.\n-    //\n-    Path checkPath \u003d splitLargeFile?\n-        pathToListFile : DistCpUtils.sortListing(fs, config, pathToListFile);\n+    Path sortedList \u003d DistCpUtils.sortListing(fs, config, pathToListFile);\n \n     SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n-                          config, SequenceFile.Reader.file(checkPath));\n+                          config, SequenceFile.Reader.file(sortedList));\n     try {\n       Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n-      long lastChunkOffset \u003d -1;\n-      long lastChunkLength \u003d -1;\n       CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n \n       Text currentKey \u003d new Text();\n       Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n       Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n       long idx \u003d 0;\n       while (reader.next(currentKey)) {\n         if (currentKey.equals(lastKey)) {\n           CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n           reader.getCurrentValue(currentFileStatus);\n-          if (!splitLargeFile) {\n-            throw new DuplicateFileException(\"File \" + lastFileStatus.getPath()\n-                + \" and \" + currentFileStatus.getPath()\n-                + \" would cause duplicates. Aborting\");\n-          } else {\n-            if (lastChunkOffset + lastChunkLength !\u003d\n-                currentFileStatus.getChunkOffset()) {\n-              throw new InvalidInputException(\"File \" + lastFileStatus.getPath()\n-                  + \" \" + lastChunkOffset + \",\" + lastChunkLength\n-                  + \" and \" + currentFileStatus.getPath()\n-                  + \" \" + currentFileStatus.getChunkOffset() + \",\"\n-                  + currentFileStatus.getChunkLength()\n-                  + \" are not continuous. Aborting\");\n-            }\n-          }\n+          throw new DuplicateFileException(\"File \" + lastFileStatus.getPath() + \" and \" +\n+              currentFileStatus.getPath() + \" would cause duplicates. Aborting\");\n         }\n         reader.getCurrentValue(lastFileStatus);\n         if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemAclSupport(lastFs);\n             aclSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n         if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n             xAttrSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n-\n         lastKey.set(currentKey);\n-        if (splitLargeFile) {\n-          lastChunkOffset \u003d lastFileStatus.getChunkOffset();\n-          lastChunkLength \u003d lastFileStatus.getChunkLength();\n-        }\n+\n         if (options.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n           LOG.debug(\"Copy list entry \" + idx + \": \" +\n                   lastFileStatus.getPath().toUri().getPath());\n           idx++;\n         }\n       }\n     } finally {\n       IOUtils.closeStream(reader);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n      throws DuplicateFileException, IOException {\n\n    Configuration config \u003d getConf();\n    FileSystem fs \u003d pathToListFile.getFileSystem(config);\n\n    Path sortedList \u003d DistCpUtils.sortListing(fs, config, pathToListFile);\n\n    SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                          config, SequenceFile.Reader.file(sortedList));\n    try {\n      Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n      CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n\n      Text currentKey \u003d new Text();\n      Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n      Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n      long idx \u003d 0;\n      while (reader.next(currentKey)) {\n        if (currentKey.equals(lastKey)) {\n          CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n          reader.getCurrentValue(currentFileStatus);\n          throw new DuplicateFileException(\"File \" + lastFileStatus.getPath() + \" and \" +\n              currentFileStatus.getPath() + \" would cause duplicates. Aborting\");\n        }\n        reader.getCurrentValue(lastFileStatus);\n        if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemAclSupport(lastFs);\n            aclSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n            xAttrSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        lastKey.set(currentKey);\n\n        if (options.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n          LOG.debug(\"Copy list entry \" + idx + \": \" +\n                  lastFileStatus.getPath().toUri().getPath());\n          idx++;\n        }\n      }\n    } finally {\n      IOUtils.closeStream(reader);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/CopyListing.java",
      "extendedDetails": {}
    },
    "064c8b25eca9bc825dc07a54d9147d65c9290a03": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen.\n",
      "commitDate": "30/03/17 5:01 PM",
      "commitName": "064c8b25eca9bc825dc07a54d9147d65c9290a03",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "26/04/16 4:08 PM",
      "commitNameOld": "959a28dd1216dfac78d05b438828e8503108d963",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 338.04,
      "commitsBetweenForRepo": 2295,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,81 @@\n   private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n       throws DuplicateFileException, IOException {\n \n     Configuration config \u003d getConf();\n     FileSystem fs \u003d pathToListFile.getFileSystem(config);\n \n-    Path sortedList \u003d DistCpUtils.sortListing(fs, config, pathToListFile);\n+    final boolean splitLargeFile \u003d options.splitLargeFile();\n+\n+    // When splitLargeFile is enabled, we don\u0027t randomize the copylist\n+    // earlier, so we don\u0027t do the sorting here. For a file that has\n+    // multiple entries due to split, we check here that their\n+    // \u003cchunkOffset, chunkLength\u003e is continuous.\n+    //\n+    Path checkPath \u003d splitLargeFile?\n+        pathToListFile : DistCpUtils.sortListing(fs, config, pathToListFile);\n \n     SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n-                          config, SequenceFile.Reader.file(sortedList));\n+                          config, SequenceFile.Reader.file(checkPath));\n     try {\n       Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n+      long lastChunkOffset \u003d -1;\n+      long lastChunkLength \u003d -1;\n       CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n \n       Text currentKey \u003d new Text();\n       Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n       Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n       long idx \u003d 0;\n       while (reader.next(currentKey)) {\n         if (currentKey.equals(lastKey)) {\n           CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n           reader.getCurrentValue(currentFileStatus);\n-          throw new DuplicateFileException(\"File \" + lastFileStatus.getPath() + \" and \" +\n-              currentFileStatus.getPath() + \" would cause duplicates. Aborting\");\n+          if (!splitLargeFile) {\n+            throw new DuplicateFileException(\"File \" + lastFileStatus.getPath()\n+                + \" and \" + currentFileStatus.getPath()\n+                + \" would cause duplicates. Aborting\");\n+          } else {\n+            if (lastChunkOffset + lastChunkLength !\u003d\n+                currentFileStatus.getChunkOffset()) {\n+              throw new InvalidInputException(\"File \" + lastFileStatus.getPath()\n+                  + \" \" + lastChunkOffset + \",\" + lastChunkLength\n+                  + \" and \" + currentFileStatus.getPath()\n+                  + \" \" + currentFileStatus.getChunkOffset() + \",\"\n+                  + currentFileStatus.getChunkLength()\n+                  + \" are not continuous. Aborting\");\n+            }\n+          }\n         }\n         reader.getCurrentValue(lastFileStatus);\n         if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemAclSupport(lastFs);\n             aclSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n         if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n             xAttrSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n-        lastKey.set(currentKey);\n \n+        lastKey.set(currentKey);\n+        if (splitLargeFile) {\n+          lastChunkOffset \u003d lastFileStatus.getChunkOffset();\n+          lastChunkLength \u003d lastFileStatus.getChunkLength();\n+        }\n         if (options.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n           LOG.debug(\"Copy list entry \" + idx + \": \" +\n                   lastFileStatus.getPath().toUri().getPath());\n           idx++;\n         }\n       }\n     } finally {\n       IOUtils.closeStream(reader);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n      throws DuplicateFileException, IOException {\n\n    Configuration config \u003d getConf();\n    FileSystem fs \u003d pathToListFile.getFileSystem(config);\n\n    final boolean splitLargeFile \u003d options.splitLargeFile();\n\n    // When splitLargeFile is enabled, we don\u0027t randomize the copylist\n    // earlier, so we don\u0027t do the sorting here. For a file that has\n    // multiple entries due to split, we check here that their\n    // \u003cchunkOffset, chunkLength\u003e is continuous.\n    //\n    Path checkPath \u003d splitLargeFile?\n        pathToListFile : DistCpUtils.sortListing(fs, config, pathToListFile);\n\n    SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                          config, SequenceFile.Reader.file(checkPath));\n    try {\n      Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n      long lastChunkOffset \u003d -1;\n      long lastChunkLength \u003d -1;\n      CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n\n      Text currentKey \u003d new Text();\n      Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n      Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n      long idx \u003d 0;\n      while (reader.next(currentKey)) {\n        if (currentKey.equals(lastKey)) {\n          CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n          reader.getCurrentValue(currentFileStatus);\n          if (!splitLargeFile) {\n            throw new DuplicateFileException(\"File \" + lastFileStatus.getPath()\n                + \" and \" + currentFileStatus.getPath()\n                + \" would cause duplicates. Aborting\");\n          } else {\n            if (lastChunkOffset + lastChunkLength !\u003d\n                currentFileStatus.getChunkOffset()) {\n              throw new InvalidInputException(\"File \" + lastFileStatus.getPath()\n                  + \" \" + lastChunkOffset + \",\" + lastChunkLength\n                  + \" and \" + currentFileStatus.getPath()\n                  + \" \" + currentFileStatus.getChunkOffset() + \",\"\n                  + currentFileStatus.getChunkLength()\n                  + \" are not continuous. Aborting\");\n            }\n          }\n        }\n        reader.getCurrentValue(lastFileStatus);\n        if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemAclSupport(lastFs);\n            aclSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n            xAttrSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n\n        lastKey.set(currentKey);\n        if (splitLargeFile) {\n          lastChunkOffset \u003d lastFileStatus.getChunkOffset();\n          lastChunkLength \u003d lastFileStatus.getChunkLength();\n        }\n        if (options.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n          LOG.debug(\"Copy list entry \" + idx + \": \" +\n                  lastFileStatus.getPath().toUri().getPath());\n          idx++;\n        }\n      }\n    } finally {\n      IOUtils.closeStream(reader);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/CopyListing.java",
      "extendedDetails": {}
    },
    "0bc15cb6e60dc60885234e01dec1c7cb4557a926": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8828. Utilize Snapshot diff report to build diff copy list in distcp. (Yufei Gu via Yongjun Zhang)\n",
      "commitDate": "20/08/15 8:02 AM",
      "commitName": "0bc15cb6e60dc60885234e01dec1c7cb4557a926",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "04/03/15 10:30 AM",
      "commitNameOld": "ed70fa142cabdbc1065e4dbbc95e99c8850c4751",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 168.86,
      "commitsBetweenForRepo": 1325,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,54 @@\n   private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n       throws DuplicateFileException, IOException {\n \n     Configuration config \u003d getConf();\n     FileSystem fs \u003d pathToListFile.getFileSystem(config);\n \n     Path sortedList \u003d DistCpUtils.sortListing(fs, config, pathToListFile);\n \n     SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                           config, SequenceFile.Reader.file(sortedList));\n     try {\n       Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n       CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n \n       Text currentKey \u003d new Text();\n       Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n       Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n+      long idx \u003d 0;\n       while (reader.next(currentKey)) {\n         if (currentKey.equals(lastKey)) {\n           CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n           reader.getCurrentValue(currentFileStatus);\n           throw new DuplicateFileException(\"File \" + lastFileStatus.getPath() + \" and \" +\n               currentFileStatus.getPath() + \" would cause duplicates. Aborting\");\n         }\n         reader.getCurrentValue(lastFileStatus);\n         if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemAclSupport(lastFs);\n             aclSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n         if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n             xAttrSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n         lastKey.set(currentKey);\n+\n+        if (options.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n+          LOG.debug(\"Copy list entry \" + idx + \": \" +\n+                  lastFileStatus.getPath().toUri().getPath());\n+          idx++;\n+        }\n       }\n     } finally {\n       IOUtils.closeStream(reader);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n      throws DuplicateFileException, IOException {\n\n    Configuration config \u003d getConf();\n    FileSystem fs \u003d pathToListFile.getFileSystem(config);\n\n    Path sortedList \u003d DistCpUtils.sortListing(fs, config, pathToListFile);\n\n    SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                          config, SequenceFile.Reader.file(sortedList));\n    try {\n      Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n      CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n\n      Text currentKey \u003d new Text();\n      Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n      Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n      long idx \u003d 0;\n      while (reader.next(currentKey)) {\n        if (currentKey.equals(lastKey)) {\n          CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n          reader.getCurrentValue(currentFileStatus);\n          throw new DuplicateFileException(\"File \" + lastFileStatus.getPath() + \" and \" +\n              currentFileStatus.getPath() + \" would cause duplicates. Aborting\");\n        }\n        reader.getCurrentValue(lastFileStatus);\n        if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemAclSupport(lastFs);\n            aclSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n            xAttrSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        lastKey.set(currentKey);\n\n        if (options.shouldUseDiff() \u0026\u0026 LOG.isDebugEnabled()) {\n          LOG.debug(\"Copy list entry \" + idx + \": \" +\n                  lastFileStatus.getPath().toUri().getPath());\n          idx++;\n        }\n      }\n    } finally {\n      IOUtils.closeStream(reader);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/CopyListing.java",
      "extendedDetails": {}
    },
    "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5898. distcp to support preserving HDFS extended attributes(XAttrs). Contributed by Yi Liu.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1600900 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/14 7:45 AM",
      "commitName": "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "16/05/14 11:25 AM",
      "commitNameOld": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 20.85,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,47 @@\n   private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n       throws DuplicateFileException, IOException {\n \n     Configuration config \u003d getConf();\n     FileSystem fs \u003d pathToListFile.getFileSystem(config);\n \n     Path sortedList \u003d DistCpUtils.sortListing(fs, config, pathToListFile);\n \n     SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                           config, SequenceFile.Reader.file(sortedList));\n     try {\n       Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n       CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n \n       Text currentKey \u003d new Text();\n       Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n+      Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n       while (reader.next(currentKey)) {\n         if (currentKey.equals(lastKey)) {\n           CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n           reader.getCurrentValue(currentFileStatus);\n           throw new DuplicateFileException(\"File \" + lastFileStatus.getPath() + \" and \" +\n               currentFileStatus.getPath() + \" would cause duplicates. Aborting\");\n         }\n         reader.getCurrentValue(lastFileStatus);\n         if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n           FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n           URI lastFsUri \u003d lastFs.getUri();\n           if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n             DistCpUtils.checkFileSystemAclSupport(lastFs);\n             aclSupportCheckFsSet.add(lastFsUri);\n           }\n         }\n+        if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n+          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n+          URI lastFsUri \u003d lastFs.getUri();\n+          if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n+            DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n+            xAttrSupportCheckFsSet.add(lastFsUri);\n+          }\n+        }\n         lastKey.set(currentKey);\n       }\n     } finally {\n       IOUtils.closeStream(reader);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n      throws DuplicateFileException, IOException {\n\n    Configuration config \u003d getConf();\n    FileSystem fs \u003d pathToListFile.getFileSystem(config);\n\n    Path sortedList \u003d DistCpUtils.sortListing(fs, config, pathToListFile);\n\n    SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                          config, SequenceFile.Reader.file(sortedList));\n    try {\n      Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n      CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n\n      Text currentKey \u003d new Text();\n      Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n      Set\u003cURI\u003e xAttrSupportCheckFsSet \u003d Sets.newHashSet();\n      while (reader.next(currentKey)) {\n        if (currentKey.equals(lastKey)) {\n          CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n          reader.getCurrentValue(currentFileStatus);\n          throw new DuplicateFileException(\"File \" + lastFileStatus.getPath() + \" and \" +\n              currentFileStatus.getPath() + \" would cause duplicates. Aborting\");\n        }\n        reader.getCurrentValue(lastFileStatus);\n        if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemAclSupport(lastFs);\n            aclSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        if (options.shouldPreserve(DistCpOptions.FileAttribute.XATTR)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!xAttrSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemXAttrSupport(lastFs);\n            xAttrSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        lastKey.set(currentKey);\n      }\n    } finally {\n      IOUtils.closeStream(reader);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/CopyListing.java",
      "extendedDetails": {}
    },
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-5809. Enhance distcp to support preserving HDFS ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/14 11:25 AM",
      "commitName": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,38 @@\n+  private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n+      throws DuplicateFileException, IOException {\n+\n+    Configuration config \u003d getConf();\n+    FileSystem fs \u003d pathToListFile.getFileSystem(config);\n+\n+    Path sortedList \u003d DistCpUtils.sortListing(fs, config, pathToListFile);\n+\n+    SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n+                          config, SequenceFile.Reader.file(sortedList));\n+    try {\n+      Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n+      CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n+\n+      Text currentKey \u003d new Text();\n+      Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n+      while (reader.next(currentKey)) {\n+        if (currentKey.equals(lastKey)) {\n+          CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n+          reader.getCurrentValue(currentFileStatus);\n+          throw new DuplicateFileException(\"File \" + lastFileStatus.getPath() + \" and \" +\n+              currentFileStatus.getPath() + \" would cause duplicates. Aborting\");\n+        }\n+        reader.getCurrentValue(lastFileStatus);\n+        if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n+          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n+          URI lastFsUri \u003d lastFs.getUri();\n+          if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n+            DistCpUtils.checkFileSystemAclSupport(lastFs);\n+            aclSupportCheckFsSet.add(lastFsUri);\n+          }\n+        }\n+        lastKey.set(currentKey);\n+      }\n+    } finally {\n+      IOUtils.closeStream(reader);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateFinalListing(Path pathToListFile, DistCpOptions options)\n      throws DuplicateFileException, IOException {\n\n    Configuration config \u003d getConf();\n    FileSystem fs \u003d pathToListFile.getFileSystem(config);\n\n    Path sortedList \u003d DistCpUtils.sortListing(fs, config, pathToListFile);\n\n    SequenceFile.Reader reader \u003d new SequenceFile.Reader(\n                          config, SequenceFile.Reader.file(sortedList));\n    try {\n      Text lastKey \u003d new Text(\"*\"); //source relative path can never hold *\n      CopyListingFileStatus lastFileStatus \u003d new CopyListingFileStatus();\n\n      Text currentKey \u003d new Text();\n      Set\u003cURI\u003e aclSupportCheckFsSet \u003d Sets.newHashSet();\n      while (reader.next(currentKey)) {\n        if (currentKey.equals(lastKey)) {\n          CopyListingFileStatus currentFileStatus \u003d new CopyListingFileStatus();\n          reader.getCurrentValue(currentFileStatus);\n          throw new DuplicateFileException(\"File \" + lastFileStatus.getPath() + \" and \" +\n              currentFileStatus.getPath() + \" would cause duplicates. Aborting\");\n        }\n        reader.getCurrentValue(lastFileStatus);\n        if (options.shouldPreserve(DistCpOptions.FileAttribute.ACL)) {\n          FileSystem lastFs \u003d lastFileStatus.getPath().getFileSystem(config);\n          URI lastFsUri \u003d lastFs.getUri();\n          if (!aclSupportCheckFsSet.contains(lastFsUri)) {\n            DistCpUtils.checkFileSystemAclSupport(lastFs);\n            aclSupportCheckFsSet.add(lastFsUri);\n          }\n        }\n        lastKey.set(currentKey);\n      }\n    } finally {\n      IOUtils.closeStream(reader);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/CopyListing.java"
    }
  }
}