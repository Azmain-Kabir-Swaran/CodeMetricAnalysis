{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ZKDelegationTokenSecretManager.java",
  "functionName": "startThreads",
  "functionId": "startThreads",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/ZKDelegationTokenSecretManager.java",
  "functionStartLine": 300,
  "functionEndLine": 401,
  "numCommitsSeen": 16,
  "timeTaken": 2313,
  "changeHistory": [
    "f4d4d3474cfd2d1f2d243f5ae5cec17af38270b1",
    "fd3cb533d2495ea220ab2e468835a43a784d7532",
    "bd8196e85e49d44de57237a59bcd7ceae4332c2e",
    "db45f047ab6b19d8a3e7752bb2cde10827cd8dad",
    "70719e5c62f32836914bea88e1ddd99c0ed009e1",
    "db890eef3208cc557476fa510f7a253ba22bc68a"
  ],
  "changeHistoryShort": {
    "f4d4d3474cfd2d1f2d243f5ae5cec17af38270b1": "Ybodychange",
    "fd3cb533d2495ea220ab2e468835a43a784d7532": "Ybodychange",
    "bd8196e85e49d44de57237a59bcd7ceae4332c2e": "Ybodychange",
    "db45f047ab6b19d8a3e7752bb2cde10827cd8dad": "Ymultichange(Ymodifierchange,Ybodychange)",
    "70719e5c62f32836914bea88e1ddd99c0ed009e1": "Ymodifierchange",
    "db890eef3208cc557476fa510f7a253ba22bc68a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f4d4d3474cfd2d1f2d243f5ae5cec17af38270b1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13487. Hadoop KMS should load old delegation tokens from Zookeeper on startup. Contributed by Xiao Chen.\n",
      "commitDate": "22/08/16 2:42 PM",
      "commitName": "f4d4d3474cfd2d1f2d243f5ae5cec17af38270b1",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "26/07/16 3:33 PM",
      "commitNameOld": "255ea45e50e102505ee61eb0ba45ea93035abe3c",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 26.96,
      "commitsBetweenForRepo": 192,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,102 @@\n   public void startThreads() throws IOException {\n     if (!isExternalClient) {\n       try {\n         zkClient.start();\n       } catch (Exception e) {\n         throw new IOException(\"Could not start Curator Framework\", e);\n       }\n     } else {\n       // If namespace parents are implicitly created, they won\u0027t have ACLs.\n       // So, let\u0027s explicitly create them.\n       CuratorFramework nullNsFw \u003d zkClient.usingNamespace(null);\n       EnsurePath ensureNs \u003d\n         nullNsFw.newNamespaceAwareEnsurePath(\"/\" + zkClient.getNamespace());\n       try {\n         ensureNs.ensure(nullNsFw.getZookeeperClient());\n       } catch (Exception e) {\n         throw new IOException(\"Could not create namespace\", e);\n       }\n     }\n     listenerThreadPool \u003d Executors.newSingleThreadExecutor();\n     try {\n       delTokSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n       if (delTokSeqCounter !\u003d null) {\n         delTokSeqCounter.start();\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start Sequence Counter\", e);\n     }\n     try {\n       keyIdSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_KEYID_ROOT, 0);\n       if (keyIdSeqCounter !\u003d null) {\n         keyIdSeqCounter.start();\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start KeyId Counter\", e);\n     }\n     try {\n       createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n       createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n     } catch (Exception e) {\n       throw new RuntimeException(\"Could not create ZK paths\");\n     }\n     try {\n       keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n       if (keyCache !\u003d null) {\n         keyCache.start(StartMode.BUILD_INITIAL_CACHE);\n         keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event)\n               throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_UPDATED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_REMOVED:\n               processKeyRemoved(event.getData().getPath());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n+        loadFromZKCache(false);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n     }\n     try {\n       tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n       if (tokenCache !\u003d null) {\n         tokenCache.start(StartMode.BUILD_INITIAL_CACHE);\n         tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n \n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event) throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n               processTokenAddOrUpdate(event.getData());\n               break;\n             case CHILD_UPDATED:\n               processTokenAddOrUpdate(event.getData());\n               break;\n             case CHILD_REMOVED:\n               processTokenRemoved(event.getData());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n+        loadFromZKCache(true);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n     }\n     super.startThreads();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void startThreads() throws IOException {\n    if (!isExternalClient) {\n      try {\n        zkClient.start();\n      } catch (Exception e) {\n        throw new IOException(\"Could not start Curator Framework\", e);\n      }\n    } else {\n      // If namespace parents are implicitly created, they won\u0027t have ACLs.\n      // So, let\u0027s explicitly create them.\n      CuratorFramework nullNsFw \u003d zkClient.usingNamespace(null);\n      EnsurePath ensureNs \u003d\n        nullNsFw.newNamespaceAwareEnsurePath(\"/\" + zkClient.getNamespace());\n      try {\n        ensureNs.ensure(nullNsFw.getZookeeperClient());\n      } catch (Exception e) {\n        throw new IOException(\"Could not create namespace\", e);\n      }\n    }\n    listenerThreadPool \u003d Executors.newSingleThreadExecutor();\n    try {\n      delTokSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n      if (delTokSeqCounter !\u003d null) {\n        delTokSeqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start Sequence Counter\", e);\n    }\n    try {\n      keyIdSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_KEYID_ROOT, 0);\n      if (keyIdSeqCounter !\u003d null) {\n        keyIdSeqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start KeyId Counter\", e);\n    }\n    try {\n      createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n      createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not create ZK paths\");\n    }\n    try {\n      keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n      if (keyCache !\u003d null) {\n        keyCache.start(StartMode.BUILD_INITIAL_CACHE);\n        keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event)\n              throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_UPDATED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_REMOVED:\n              processKeyRemoved(event.getData().getPath());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n        loadFromZKCache(false);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n    }\n    try {\n      tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n      if (tokenCache !\u003d null) {\n        tokenCache.start(StartMode.BUILD_INITIAL_CACHE);\n        tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event) throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processTokenAddOrUpdate(event.getData());\n              break;\n            case CHILD_UPDATED:\n              processTokenAddOrUpdate(event.getData());\n              break;\n            case CHILD_REMOVED:\n              processTokenRemoved(event.getData());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n        loadFromZKCache(true);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n    }\n    super.startThreads();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/ZKDelegationTokenSecretManager.java",
      "extendedDetails": {}
    },
    "fd3cb533d2495ea220ab2e468835a43a784d7532": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11973. Ensure ZkDelegationTokenSecretManager namespace znodes get created with ACLs. (Gregory Chanan via asuresh)\n",
      "commitDate": "19/05/15 11:35 AM",
      "commitName": "fd3cb533d2495ea220ab2e468835a43a784d7532",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "17/03/15 7:41 PM",
      "commitNameOld": "fc90bf7b27cc20486f2806670a14fd7d654b0a31",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 62.66,
      "commitsBetweenForRepo": 639,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,100 @@\n   public void startThreads() throws IOException {\n     if (!isExternalClient) {\n       try {\n         zkClient.start();\n       } catch (Exception e) {\n         throw new IOException(\"Could not start Curator Framework\", e);\n       }\n+    } else {\n+      // If namespace parents are implicitly created, they won\u0027t have ACLs.\n+      // So, let\u0027s explicitly create them.\n+      CuratorFramework nullNsFw \u003d zkClient.usingNamespace(null);\n+      EnsurePath ensureNs \u003d\n+        nullNsFw.newNamespaceAwareEnsurePath(\"/\" + zkClient.getNamespace());\n+      try {\n+        ensureNs.ensure(nullNsFw.getZookeeperClient());\n+      } catch (Exception e) {\n+        throw new IOException(\"Could not create namespace\", e);\n+      }\n     }\n     listenerThreadPool \u003d Executors.newSingleThreadExecutor();\n     try {\n       delTokSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n       if (delTokSeqCounter !\u003d null) {\n         delTokSeqCounter.start();\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start Sequence Counter\", e);\n     }\n     try {\n       keyIdSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_KEYID_ROOT, 0);\n       if (keyIdSeqCounter !\u003d null) {\n         keyIdSeqCounter.start();\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start KeyId Counter\", e);\n     }\n     try {\n       createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n       createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n     } catch (Exception e) {\n       throw new RuntimeException(\"Could not create ZK paths\");\n     }\n     try {\n       keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n       if (keyCache !\u003d null) {\n         keyCache.start(StartMode.BUILD_INITIAL_CACHE);\n         keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event)\n               throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_UPDATED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_REMOVED:\n               processKeyRemoved(event.getData().getPath());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n     }\n     try {\n       tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n       if (tokenCache !\u003d null) {\n         tokenCache.start(StartMode.BUILD_INITIAL_CACHE);\n         tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n \n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event) throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n               processTokenAddOrUpdate(event.getData());\n               break;\n             case CHILD_UPDATED:\n               processTokenAddOrUpdate(event.getData());\n               break;\n             case CHILD_REMOVED:\n               processTokenRemoved(event.getData());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n     }\n     super.startThreads();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void startThreads() throws IOException {\n    if (!isExternalClient) {\n      try {\n        zkClient.start();\n      } catch (Exception e) {\n        throw new IOException(\"Could not start Curator Framework\", e);\n      }\n    } else {\n      // If namespace parents are implicitly created, they won\u0027t have ACLs.\n      // So, let\u0027s explicitly create them.\n      CuratorFramework nullNsFw \u003d zkClient.usingNamespace(null);\n      EnsurePath ensureNs \u003d\n        nullNsFw.newNamespaceAwareEnsurePath(\"/\" + zkClient.getNamespace());\n      try {\n        ensureNs.ensure(nullNsFw.getZookeeperClient());\n      } catch (Exception e) {\n        throw new IOException(\"Could not create namespace\", e);\n      }\n    }\n    listenerThreadPool \u003d Executors.newSingleThreadExecutor();\n    try {\n      delTokSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n      if (delTokSeqCounter !\u003d null) {\n        delTokSeqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start Sequence Counter\", e);\n    }\n    try {\n      keyIdSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_KEYID_ROOT, 0);\n      if (keyIdSeqCounter !\u003d null) {\n        keyIdSeqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start KeyId Counter\", e);\n    }\n    try {\n      createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n      createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not create ZK paths\");\n    }\n    try {\n      keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n      if (keyCache !\u003d null) {\n        keyCache.start(StartMode.BUILD_INITIAL_CACHE);\n        keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event)\n              throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_UPDATED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_REMOVED:\n              processKeyRemoved(event.getData().getPath());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n    }\n    try {\n      tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n      if (tokenCache !\u003d null) {\n        tokenCache.start(StartMode.BUILD_INITIAL_CACHE);\n        tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event) throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processTokenAddOrUpdate(event.getData());\n              break;\n            case CHILD_UPDATED:\n              processTokenAddOrUpdate(event.getData());\n              break;\n            case CHILD_REMOVED:\n              processTokenRemoved(event.getData());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n    }\n    super.startThreads();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/ZKDelegationTokenSecretManager.java",
      "extendedDetails": {}
    },
    "bd8196e85e49d44de57237a59bcd7ceae4332c2e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11157. ZKDelegationTokenSecretManager never shuts down listenerThreadPool. Contributed by Arun Suresh.\n",
      "commitDate": "17/11/14 1:02 PM",
      "commitName": "bd8196e85e49d44de57237a59bcd7ceae4332c2e",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "05/11/14 5:47 PM",
      "commitNameOld": "8a261e68e4177b47be01ceae7310ea56aeb7ca38",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 11.8,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,89 @@\n   public void startThreads() throws IOException {\n     if (!isExternalClient) {\n       try {\n         zkClient.start();\n       } catch (Exception e) {\n         throw new IOException(\"Could not start Curator Framework\", e);\n       }\n     }\n+    listenerThreadPool \u003d Executors.newSingleThreadExecutor();\n     try {\n       delTokSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n       if (delTokSeqCounter !\u003d null) {\n         delTokSeqCounter.start();\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start Sequence Counter\", e);\n     }\n     try {\n       keyIdSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_KEYID_ROOT, 0);\n       if (keyIdSeqCounter !\u003d null) {\n         keyIdSeqCounter.start();\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start KeyId Counter\", e);\n     }\n     try {\n       createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n       createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n     } catch (Exception e) {\n       throw new RuntimeException(\"Could not create ZK paths\");\n     }\n     try {\n       keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n       if (keyCache !\u003d null) {\n-        keyCache.start(StartMode.POST_INITIALIZED_EVENT);\n+        keyCache.start(StartMode.BUILD_INITIAL_CACHE);\n         keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event)\n               throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_UPDATED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_REMOVED:\n               processKeyRemoved(event.getData().getPath());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n     }\n     try {\n       tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n       if (tokenCache !\u003d null) {\n-        tokenCache.start(StartMode.POST_INITIALIZED_EVENT);\n+        tokenCache.start(StartMode.BUILD_INITIAL_CACHE);\n         tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n \n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event) throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n-              processTokenAddOrUpdate(event.getData().getData());\n+              processTokenAddOrUpdate(event.getData());\n               break;\n             case CHILD_UPDATED:\n-              processTokenAddOrUpdate(event.getData().getData());\n+              processTokenAddOrUpdate(event.getData());\n               break;\n             case CHILD_REMOVED:\n-              processTokenRemoved(event.getData().getData());\n+              processTokenRemoved(event.getData());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n     }\n     super.startThreads();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void startThreads() throws IOException {\n    if (!isExternalClient) {\n      try {\n        zkClient.start();\n      } catch (Exception e) {\n        throw new IOException(\"Could not start Curator Framework\", e);\n      }\n    }\n    listenerThreadPool \u003d Executors.newSingleThreadExecutor();\n    try {\n      delTokSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n      if (delTokSeqCounter !\u003d null) {\n        delTokSeqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start Sequence Counter\", e);\n    }\n    try {\n      keyIdSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_KEYID_ROOT, 0);\n      if (keyIdSeqCounter !\u003d null) {\n        keyIdSeqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start KeyId Counter\", e);\n    }\n    try {\n      createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n      createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not create ZK paths\");\n    }\n    try {\n      keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n      if (keyCache !\u003d null) {\n        keyCache.start(StartMode.BUILD_INITIAL_CACHE);\n        keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event)\n              throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_UPDATED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_REMOVED:\n              processKeyRemoved(event.getData().getPath());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n    }\n    try {\n      tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n      if (tokenCache !\u003d null) {\n        tokenCache.start(StartMode.BUILD_INITIAL_CACHE);\n        tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event) throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processTokenAddOrUpdate(event.getData());\n              break;\n            case CHILD_UPDATED:\n              processTokenAddOrUpdate(event.getData());\n              break;\n            case CHILD_REMOVED:\n              processTokenRemoved(event.getData());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n    }\n    super.startThreads();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/ZKDelegationTokenSecretManager.java",
      "extendedDetails": {}
    },
    "db45f047ab6b19d8a3e7752bb2cde10827cd8dad": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HADOOP-11170. ZKDelegationTokenSecretManager fails to renewToken created by a peer. (Arun Suresh and Gregory Chanan via kasha)\n",
      "commitDate": "23/10/14 5:04 PM",
      "commitName": "db45f047ab6b19d8a3e7752bb2cde10827cd8dad",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-11170. ZKDelegationTokenSecretManager fails to renewToken created by a peer. (Arun Suresh and Gregory Chanan via kasha)\n",
          "commitDate": "23/10/14 5:04 PM",
          "commitName": "db45f047ab6b19d8a3e7752bb2cde10827cd8dad",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "22/10/14 2:26 PM",
          "commitNameOld": "70719e5c62f32836914bea88e1ddd99c0ed009e1",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.11,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,88 @@\n-  public synchronized void startThreads() throws IOException {\n+  public void startThreads() throws IOException {\n     if (!isExternalClient) {\n       try {\n         zkClient.start();\n       } catch (Exception e) {\n         throw new IOException(\"Could not start Curator Framework\", e);\n       }\n     }\n     try {\n-      seqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n-      if (seqCounter !\u003d null) {\n-        seqCounter.start();\n+      delTokSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n+      if (delTokSeqCounter !\u003d null) {\n+        delTokSeqCounter.start();\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start Sequence Counter\", e);\n     }\n     try {\n+      keyIdSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_KEYID_ROOT, 0);\n+      if (keyIdSeqCounter !\u003d null) {\n+        keyIdSeqCounter.start();\n+      }\n+    } catch (Exception e) {\n+      throw new IOException(\"Could not start KeyId Counter\", e);\n+    }\n+    try {\n       createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n       createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n     } catch (Exception e) {\n       throw new RuntimeException(\"Could not create ZK paths\");\n     }\n     try {\n       keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n       if (keyCache !\u003d null) {\n         keyCache.start(StartMode.POST_INITIALIZED_EVENT);\n         keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event)\n               throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_UPDATED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_REMOVED:\n               processKeyRemoved(event.getData().getPath());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n     }\n     try {\n       tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n       if (tokenCache !\u003d null) {\n         tokenCache.start(StartMode.POST_INITIALIZED_EVENT);\n         tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n \n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event) throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n               processTokenAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_UPDATED:\n               processTokenAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_REMOVED:\n               processTokenRemoved(event.getData().getData());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n     }\n     super.startThreads();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void startThreads() throws IOException {\n    if (!isExternalClient) {\n      try {\n        zkClient.start();\n      } catch (Exception e) {\n        throw new IOException(\"Could not start Curator Framework\", e);\n      }\n    }\n    try {\n      delTokSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n      if (delTokSeqCounter !\u003d null) {\n        delTokSeqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start Sequence Counter\", e);\n    }\n    try {\n      keyIdSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_KEYID_ROOT, 0);\n      if (keyIdSeqCounter !\u003d null) {\n        keyIdSeqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start KeyId Counter\", e);\n    }\n    try {\n      createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n      createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not create ZK paths\");\n    }\n    try {\n      keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n      if (keyCache !\u003d null) {\n        keyCache.start(StartMode.POST_INITIALIZED_EVENT);\n        keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event)\n              throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_UPDATED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_REMOVED:\n              processKeyRemoved(event.getData().getPath());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n    }\n    try {\n      tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n      if (tokenCache !\u003d null) {\n        tokenCache.start(StartMode.POST_INITIALIZED_EVENT);\n        tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event) throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processTokenAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_UPDATED:\n              processTokenAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_REMOVED:\n              processTokenRemoved(event.getData().getData());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n    }\n    super.startThreads();\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/ZKDelegationTokenSecretManager.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-11170. ZKDelegationTokenSecretManager fails to renewToken created by a peer. (Arun Suresh and Gregory Chanan via kasha)\n",
          "commitDate": "23/10/14 5:04 PM",
          "commitName": "db45f047ab6b19d8a3e7752bb2cde10827cd8dad",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "22/10/14 2:26 PM",
          "commitNameOld": "70719e5c62f32836914bea88e1ddd99c0ed009e1",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.11,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,88 @@\n-  public synchronized void startThreads() throws IOException {\n+  public void startThreads() throws IOException {\n     if (!isExternalClient) {\n       try {\n         zkClient.start();\n       } catch (Exception e) {\n         throw new IOException(\"Could not start Curator Framework\", e);\n       }\n     }\n     try {\n-      seqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n-      if (seqCounter !\u003d null) {\n-        seqCounter.start();\n+      delTokSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n+      if (delTokSeqCounter !\u003d null) {\n+        delTokSeqCounter.start();\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start Sequence Counter\", e);\n     }\n     try {\n+      keyIdSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_KEYID_ROOT, 0);\n+      if (keyIdSeqCounter !\u003d null) {\n+        keyIdSeqCounter.start();\n+      }\n+    } catch (Exception e) {\n+      throw new IOException(\"Could not start KeyId Counter\", e);\n+    }\n+    try {\n       createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n       createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n     } catch (Exception e) {\n       throw new RuntimeException(\"Could not create ZK paths\");\n     }\n     try {\n       keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n       if (keyCache !\u003d null) {\n         keyCache.start(StartMode.POST_INITIALIZED_EVENT);\n         keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event)\n               throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_UPDATED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_REMOVED:\n               processKeyRemoved(event.getData().getPath());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n     }\n     try {\n       tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n       if (tokenCache !\u003d null) {\n         tokenCache.start(StartMode.POST_INITIALIZED_EVENT);\n         tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n \n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event) throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n               processTokenAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_UPDATED:\n               processTokenAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_REMOVED:\n               processTokenRemoved(event.getData().getData());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n     }\n     super.startThreads();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void startThreads() throws IOException {\n    if (!isExternalClient) {\n      try {\n        zkClient.start();\n      } catch (Exception e) {\n        throw new IOException(\"Could not start Curator Framework\", e);\n      }\n    }\n    try {\n      delTokSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n      if (delTokSeqCounter !\u003d null) {\n        delTokSeqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start Sequence Counter\", e);\n    }\n    try {\n      keyIdSeqCounter \u003d new SharedCount(zkClient, ZK_DTSM_KEYID_ROOT, 0);\n      if (keyIdSeqCounter !\u003d null) {\n        keyIdSeqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start KeyId Counter\", e);\n    }\n    try {\n      createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n      createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not create ZK paths\");\n    }\n    try {\n      keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n      if (keyCache !\u003d null) {\n        keyCache.start(StartMode.POST_INITIALIZED_EVENT);\n        keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event)\n              throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_UPDATED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_REMOVED:\n              processKeyRemoved(event.getData().getPath());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n    }\n    try {\n      tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n      if (tokenCache !\u003d null) {\n        tokenCache.start(StartMode.POST_INITIALIZED_EVENT);\n        tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event) throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processTokenAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_UPDATED:\n              processTokenAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_REMOVED:\n              processTokenRemoved(event.getData().getData());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n    }\n    super.startThreads();\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/ZKDelegationTokenSecretManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "70719e5c62f32836914bea88e1ddd99c0ed009e1": {
      "type": "Ymodifierchange",
      "commitMessage": "HADOOP-11122. Fix findbugs in ZK DelegationTokenSecretManagers. (Arun Suresh via kasha)\n",
      "commitDate": "22/10/14 2:26 PM",
      "commitName": "70719e5c62f32836914bea88e1ddd99c0ed009e1",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "20/09/14 8:21 AM",
      "commitNameOld": "db890eef3208cc557476fa510f7a253ba22bc68a",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 32.25,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n-  public void startThreads() throws IOException {\n+  public synchronized void startThreads() throws IOException {\n     if (!isExternalClient) {\n       try {\n         zkClient.start();\n       } catch (Exception e) {\n         throw new IOException(\"Could not start Curator Framework\", e);\n       }\n     }\n     try {\n       seqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n       if (seqCounter !\u003d null) {\n         seqCounter.start();\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start Sequence Counter\", e);\n     }\n     try {\n       createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n       createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n     } catch (Exception e) {\n       throw new RuntimeException(\"Could not create ZK paths\");\n     }\n     try {\n       keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n       if (keyCache !\u003d null) {\n         keyCache.start(StartMode.POST_INITIALIZED_EVENT);\n         keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event)\n               throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_UPDATED:\n               processKeyAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_REMOVED:\n               processKeyRemoved(event.getData().getPath());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n     }\n     try {\n       tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n       if (tokenCache !\u003d null) {\n         tokenCache.start(StartMode.POST_INITIALIZED_EVENT);\n         tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n \n           @Override\n           public void childEvent(CuratorFramework client,\n               PathChildrenCacheEvent event) throws Exception {\n             switch (event.getType()) {\n             case CHILD_ADDED:\n               processTokenAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_UPDATED:\n               processTokenAddOrUpdate(event.getData().getData());\n               break;\n             case CHILD_REMOVED:\n               processTokenRemoved(event.getData().getData());\n               break;\n             default:\n               break;\n             }\n           }\n         }, listenerThreadPool);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n     }\n     super.startThreads();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void startThreads() throws IOException {\n    if (!isExternalClient) {\n      try {\n        zkClient.start();\n      } catch (Exception e) {\n        throw new IOException(\"Could not start Curator Framework\", e);\n      }\n    }\n    try {\n      seqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n      if (seqCounter !\u003d null) {\n        seqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start Sequence Counter\", e);\n    }\n    try {\n      createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n      createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not create ZK paths\");\n    }\n    try {\n      keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n      if (keyCache !\u003d null) {\n        keyCache.start(StartMode.POST_INITIALIZED_EVENT);\n        keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event)\n              throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_UPDATED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_REMOVED:\n              processKeyRemoved(event.getData().getPath());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n    }\n    try {\n      tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n      if (tokenCache !\u003d null) {\n        tokenCache.start(StartMode.POST_INITIALIZED_EVENT);\n        tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event) throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processTokenAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_UPDATED:\n              processTokenAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_REMOVED:\n              processTokenRemoved(event.getData().getData());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n    }\n    super.startThreads();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/ZKDelegationTokenSecretManager.java",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[public, synchronized]"
      }
    },
    "db890eef3208cc557476fa510f7a253ba22bc68a": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-11017. KMS delegation token secret manager should be able to use zookeeper as store. (asuresh via tucu)\n",
      "commitDate": "20/09/14 8:21 AM",
      "commitName": "db890eef3208cc557476fa510f7a253ba22bc68a",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,80 @@\n+  public void startThreads() throws IOException {\n+    if (!isExternalClient) {\n+      try {\n+        zkClient.start();\n+      } catch (Exception e) {\n+        throw new IOException(\"Could not start Curator Framework\", e);\n+      }\n+    }\n+    try {\n+      seqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n+      if (seqCounter !\u003d null) {\n+        seqCounter.start();\n+      }\n+    } catch (Exception e) {\n+      throw new IOException(\"Could not start Sequence Counter\", e);\n+    }\n+    try {\n+      createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n+      createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Could not create ZK paths\");\n+    }\n+    try {\n+      keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n+      if (keyCache !\u003d null) {\n+        keyCache.start(StartMode.POST_INITIALIZED_EVENT);\n+        keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n+          @Override\n+          public void childEvent(CuratorFramework client,\n+              PathChildrenCacheEvent event)\n+              throws Exception {\n+            switch (event.getType()) {\n+            case CHILD_ADDED:\n+              processKeyAddOrUpdate(event.getData().getData());\n+              break;\n+            case CHILD_UPDATED:\n+              processKeyAddOrUpdate(event.getData().getData());\n+              break;\n+            case CHILD_REMOVED:\n+              processKeyRemoved(event.getData().getPath());\n+              break;\n+            default:\n+              break;\n+            }\n+          }\n+        }, listenerThreadPool);\n+      }\n+    } catch (Exception e) {\n+      throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n+    }\n+    try {\n+      tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n+      if (tokenCache !\u003d null) {\n+        tokenCache.start(StartMode.POST_INITIALIZED_EVENT);\n+        tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n+\n+          @Override\n+          public void childEvent(CuratorFramework client,\n+              PathChildrenCacheEvent event) throws Exception {\n+            switch (event.getType()) {\n+            case CHILD_ADDED:\n+              processTokenAddOrUpdate(event.getData().getData());\n+              break;\n+            case CHILD_UPDATED:\n+              processTokenAddOrUpdate(event.getData().getData());\n+              break;\n+            case CHILD_REMOVED:\n+              processTokenRemoved(event.getData().getData());\n+              break;\n+            default:\n+              break;\n+            }\n+          }\n+        }, listenerThreadPool);\n+      }\n+    } catch (Exception e) {\n+      throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n+    }\n+    super.startThreads();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void startThreads() throws IOException {\n    if (!isExternalClient) {\n      try {\n        zkClient.start();\n      } catch (Exception e) {\n        throw new IOException(\"Could not start Curator Framework\", e);\n      }\n    }\n    try {\n      seqCounter \u003d new SharedCount(zkClient, ZK_DTSM_SEQNUM_ROOT, 0);\n      if (seqCounter !\u003d null) {\n        seqCounter.start();\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start Sequence Counter\", e);\n    }\n    try {\n      createPersistentNode(ZK_DTSM_MASTER_KEY_ROOT);\n      createPersistentNode(ZK_DTSM_TOKENS_ROOT);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not create ZK paths\");\n    }\n    try {\n      keyCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_MASTER_KEY_ROOT, true);\n      if (keyCache !\u003d null) {\n        keyCache.start(StartMode.POST_INITIALIZED_EVENT);\n        keyCache.getListenable().addListener(new PathChildrenCacheListener() {\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event)\n              throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_UPDATED:\n              processKeyAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_REMOVED:\n              processKeyRemoved(event.getData().getPath());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for keys\", e);\n    }\n    try {\n      tokenCache \u003d new PathChildrenCache(zkClient, ZK_DTSM_TOKENS_ROOT, true);\n      if (tokenCache !\u003d null) {\n        tokenCache.start(StartMode.POST_INITIALIZED_EVENT);\n        tokenCache.getListenable().addListener(new PathChildrenCacheListener() {\n\n          @Override\n          public void childEvent(CuratorFramework client,\n              PathChildrenCacheEvent event) throws Exception {\n            switch (event.getType()) {\n            case CHILD_ADDED:\n              processTokenAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_UPDATED:\n              processTokenAddOrUpdate(event.getData().getData());\n              break;\n            case CHILD_REMOVED:\n              processTokenRemoved(event.getData().getData());\n              break;\n            default:\n              break;\n            }\n          }\n        }, listenerThreadPool);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Could not start PathChildrenCache for tokens\", e);\n    }\n    super.startThreads();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/ZKDelegationTokenSecretManager.java"
    }
  }
}