{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ProcfsBasedProcessTree.java",
  "functionName": "updateProcessTree",
  "functionId": "updateProcessTree",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
  "functionStartLine": 195,
  "functionEndLine": 282,
  "numCommitsSeen": 38,
  "timeTaken": 10002,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509",
    "626b5103d44692adf3882af61bdafa40114c44f7",
    "c6b48391680c1b81a86aabc3ad4c725bfade6d2e",
    "06579878dfca0b634aaecfe63bb90c46113b3037",
    "1a49c854386d3ba4aef6f29f46e2bd5e71e86dc1",
    "a1aa1b93497034411d76906405bb6a70a441a0b7",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "b4c8567e1b975ccf32dfc1f63aadb78ac29f2c69",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509": "Ybodychange",
    "626b5103d44692adf3882af61bdafa40114c44f7": "Ybodychange",
    "c6b48391680c1b81a86aabc3ad4c725bfade6d2e": "Ybodychange",
    "06579878dfca0b634aaecfe63bb90c46113b3037": "Ybodychange",
    "1a49c854386d3ba4aef6f29f46e2bd5e71e86dc1": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
    "a1aa1b93497034411d76906405bb6a70a441a0b7": "Yreturntypechange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "b4c8567e1b975ccf32dfc1f63aadb78ac29f2c69": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "03/03/19 11:59 PM",
      "commitNameOld": "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 11.64,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   public void updateProcessTree() {\n     if (!pid.equals(deadPid)) {\n       // Get the list of processes\n       List\u003cString\u003e processList \u003d getProcessList();\n \n       Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n \n       // cache the processTree to get the age for processes\n       Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n               new HashMap\u003cString, ProcessInfo\u003e(processTree);\n       processTree.clear();\n \n       ProcessInfo me \u003d null;\n       for (String proc : processList) {\n         // Get information for each process\n         ProcessInfo pInfo \u003d new ProcessInfo(proc);\n         if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n           allProcessInfo.put(proc, pInfo);\n           if (proc.equals(this.pid)) {\n             me \u003d pInfo; // cache \u0027me\u0027\n             processTree.put(proc, pInfo);\n           }\n         }\n       }\n \n       if (me \u003d\u003d null) {\n         return;\n       }\n \n       // Add each process to its parent.\n       for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n         String pID \u003d entry.getKey();\n         if (!\"1\".equals(pID)) {\n           ProcessInfo pInfo \u003d entry.getValue();\n           String ppid \u003d pInfo.getPpid();\n           // If parent is init and process is not session leader,\n           // attach to sessionID\n           if (\"1\".equals(ppid)) {\n               String sid \u003d pInfo.getSessionId().toString();\n               if (!pID.equals(sid)) {\n                  ppid \u003d sid;\n               }\n           }\n           ProcessInfo parentPInfo \u003d allProcessInfo.get(ppid);\n           if (parentPInfo !\u003d null) {\n             parentPInfo.addChild(pInfo);\n           }\n         }\n       }\n \n       // now start constructing the process-tree\n       List\u003cProcessInfo\u003e children \u003d me.getChildren();\n       Queue\u003cProcessInfo\u003e pInfoQueue \u003d new ArrayDeque\u003cProcessInfo\u003e(children);\n       while (!pInfoQueue.isEmpty()) {\n         ProcessInfo pInfo \u003d pInfoQueue.remove();\n         if (!processTree.containsKey(pInfo.getPid())) {\n           processTree.put(pInfo.getPid(), pInfo);\n         }\n         pInfoQueue.addAll(pInfo.getChildren());\n       }\n \n       // update age values and compute the number of jiffies since last update\n       for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n         ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n         if (procs.getValue() !\u003d null) {\n           procs.getValue().updateJiffy(oldInfo);\n           if (oldInfo !\u003d null) {\n             procs.getValue().updateAge(oldInfo);\n           }\n         }\n       }\n \n-      LOG.debug(this.toString());\n+      LOG.debug(\"{}\", this);\n \n       if (smapsEnabled) {\n         // Update smaps info\n         processSMAPTree.clear();\n         for (ProcessInfo p : processTree.values()) {\n           if (p !\u003d null) {\n             // Get information for each process\n             ProcessTreeSmapMemInfo memInfo \u003d new ProcessTreeSmapMemInfo(p.getPid());\n             constructProcessSMAPInfo(memInfo, procfsDir);\n             processSMAPTree.put(p.getPid(), memInfo);\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateProcessTree() {\n    if (!pid.equals(deadPid)) {\n      // Get the list of processes\n      List\u003cString\u003e processList \u003d getProcessList();\n\n      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n\n      // cache the processTree to get the age for processes\n      Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (String proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return;\n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        String pID \u003d entry.getKey();\n        if (!\"1\".equals(pID)) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          String ppid \u003d pInfo.getPpid();\n          // If parent is init and process is not session leader,\n          // attach to sessionID\n          if (\"1\".equals(ppid)) {\n              String sid \u003d pInfo.getSessionId().toString();\n              if (!pID.equals(sid)) {\n                 ppid \u003d sid;\n              }\n          }\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(ppid);\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      List\u003cProcessInfo\u003e children \u003d me.getChildren();\n      Queue\u003cProcessInfo\u003e pInfoQueue \u003d new ArrayDeque\u003cProcessInfo\u003e(children);\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);\n          }\n        }\n      }\n\n      LOG.debug(\"{}\", this);\n\n      if (smapsEnabled) {\n        // Update smaps info\n        processSMAPTree.clear();\n        for (ProcessInfo p : processTree.values()) {\n          if (p !\u003d null) {\n            // Get information for each process\n            ProcessTreeSmapMemInfo memInfo \u003d new ProcessTreeSmapMemInfo(p.getPid());\n            constructProcessSMAPInfo(memInfo, procfsDir);\n            processSMAPTree.put(p.getPid(), memInfo);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7477. Moving logging APIs over to slf4j in hadoop-yarn-common. Contributed by Prabhu Joseph.\n",
      "commitDate": "03/03/19 11:59 PM",
      "commitName": "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "25/02/19 11:45 AM",
      "commitNameOld": "95372657fc25c02399b01793833021ccf88dada2",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 6.51,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   public void updateProcessTree() {\n     if (!pid.equals(deadPid)) {\n       // Get the list of processes\n       List\u003cString\u003e processList \u003d getProcessList();\n \n       Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n \n       // cache the processTree to get the age for processes\n       Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n               new HashMap\u003cString, ProcessInfo\u003e(processTree);\n       processTree.clear();\n \n       ProcessInfo me \u003d null;\n       for (String proc : processList) {\n         // Get information for each process\n         ProcessInfo pInfo \u003d new ProcessInfo(proc);\n         if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n           allProcessInfo.put(proc, pInfo);\n           if (proc.equals(this.pid)) {\n             me \u003d pInfo; // cache \u0027me\u0027\n             processTree.put(proc, pInfo);\n           }\n         }\n       }\n \n       if (me \u003d\u003d null) {\n         return;\n       }\n \n       // Add each process to its parent.\n       for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n         String pID \u003d entry.getKey();\n         if (!\"1\".equals(pID)) {\n           ProcessInfo pInfo \u003d entry.getValue();\n           String ppid \u003d pInfo.getPpid();\n           // If parent is init and process is not session leader,\n           // attach to sessionID\n           if (\"1\".equals(ppid)) {\n               String sid \u003d pInfo.getSessionId().toString();\n               if (!pID.equals(sid)) {\n                  ppid \u003d sid;\n               }\n           }\n           ProcessInfo parentPInfo \u003d allProcessInfo.get(ppid);\n           if (parentPInfo !\u003d null) {\n             parentPInfo.addChild(pInfo);\n           }\n         }\n       }\n \n       // now start constructing the process-tree\n       List\u003cProcessInfo\u003e children \u003d me.getChildren();\n       Queue\u003cProcessInfo\u003e pInfoQueue \u003d new ArrayDeque\u003cProcessInfo\u003e(children);\n       while (!pInfoQueue.isEmpty()) {\n         ProcessInfo pInfo \u003d pInfoQueue.remove();\n         if (!processTree.containsKey(pInfo.getPid())) {\n           processTree.put(pInfo.getPid(), pInfo);\n         }\n         pInfoQueue.addAll(pInfo.getChildren());\n       }\n \n       // update age values and compute the number of jiffies since last update\n       for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n         ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n         if (procs.getValue() !\u003d null) {\n           procs.getValue().updateJiffy(oldInfo);\n           if (oldInfo !\u003d null) {\n             procs.getValue().updateAge(oldInfo);\n           }\n         }\n       }\n \n-      LOG.debug(this);\n+      LOG.debug(this.toString());\n \n       if (smapsEnabled) {\n         // Update smaps info\n         processSMAPTree.clear();\n         for (ProcessInfo p : processTree.values()) {\n           if (p !\u003d null) {\n             // Get information for each process\n             ProcessTreeSmapMemInfo memInfo \u003d new ProcessTreeSmapMemInfo(p.getPid());\n             constructProcessSMAPInfo(memInfo, procfsDir);\n             processSMAPTree.put(p.getPid(), memInfo);\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateProcessTree() {\n    if (!pid.equals(deadPid)) {\n      // Get the list of processes\n      List\u003cString\u003e processList \u003d getProcessList();\n\n      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n\n      // cache the processTree to get the age for processes\n      Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (String proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return;\n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        String pID \u003d entry.getKey();\n        if (!\"1\".equals(pID)) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          String ppid \u003d pInfo.getPpid();\n          // If parent is init and process is not session leader,\n          // attach to sessionID\n          if (\"1\".equals(ppid)) {\n              String sid \u003d pInfo.getSessionId().toString();\n              if (!pID.equals(sid)) {\n                 ppid \u003d sid;\n              }\n          }\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(ppid);\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      List\u003cProcessInfo\u003e children \u003d me.getChildren();\n      Queue\u003cProcessInfo\u003e pInfoQueue \u003d new ArrayDeque\u003cProcessInfo\u003e(children);\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);\n          }\n        }\n      }\n\n      LOG.debug(this.toString());\n\n      if (smapsEnabled) {\n        // Update smaps info\n        processSMAPTree.clear();\n        for (ProcessInfo p : processTree.values()) {\n          if (p !\u003d null) {\n            // Get information for each process\n            ProcessTreeSmapMemInfo memInfo \u003d new ProcessTreeSmapMemInfo(p.getPid());\n            constructProcessSMAPInfo(memInfo, procfsDir);\n            processSMAPTree.put(p.getPid(), memInfo);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "626b5103d44692adf3882af61bdafa40114c44f7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7688. Miscellaneous Improvements To ProcfsBasedProcessTree. Contributed by BELUGA BEHR.\n",
      "commitDate": "02/01/18 5:39 PM",
      "commitName": "626b5103d44692adf3882af61bdafa40114c44f7",
      "commitAuthor": "Miklos Szegedi",
      "commitDateOld": "01/05/17 4:01 AM",
      "commitNameOld": "4b5bd73ac53f7de4899b5b70078249ad20216048",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 246.61,
      "commitsBetweenForRepo": 1710,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,88 @@\n   public void updateProcessTree() {\n     if (!pid.equals(deadPid)) {\n       // Get the list of processes\n       List\u003cString\u003e processList \u003d getProcessList();\n \n       Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n \n       // cache the processTree to get the age for processes\n       Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n               new HashMap\u003cString, ProcessInfo\u003e(processTree);\n       processTree.clear();\n \n       ProcessInfo me \u003d null;\n       for (String proc : processList) {\n         // Get information for each process\n         ProcessInfo pInfo \u003d new ProcessInfo(proc);\n         if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n           allProcessInfo.put(proc, pInfo);\n           if (proc.equals(this.pid)) {\n             me \u003d pInfo; // cache \u0027me\u0027\n             processTree.put(proc, pInfo);\n           }\n         }\n       }\n \n       if (me \u003d\u003d null) {\n         return;\n       }\n \n       // Add each process to its parent.\n       for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n         String pID \u003d entry.getKey();\n-        if (!pID.equals(\"1\")) {\n+        if (!\"1\".equals(pID)) {\n           ProcessInfo pInfo \u003d entry.getValue();\n           String ppid \u003d pInfo.getPpid();\n           // If parent is init and process is not session leader,\n           // attach to sessionID\n-          if (ppid.equals(\"1\")) {\n+          if (\"1\".equals(ppid)) {\n               String sid \u003d pInfo.getSessionId().toString();\n               if (!pID.equals(sid)) {\n                  ppid \u003d sid;\n               }\n           }\n           ProcessInfo parentPInfo \u003d allProcessInfo.get(ppid);\n           if (parentPInfo !\u003d null) {\n             parentPInfo.addChild(pInfo);\n           }\n         }\n       }\n \n       // now start constructing the process-tree\n-      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n-      pInfoQueue.addAll(me.getChildren());\n+      List\u003cProcessInfo\u003e children \u003d me.getChildren();\n+      Queue\u003cProcessInfo\u003e pInfoQueue \u003d new ArrayDeque\u003cProcessInfo\u003e(children);\n       while (!pInfoQueue.isEmpty()) {\n         ProcessInfo pInfo \u003d pInfoQueue.remove();\n         if (!processTree.containsKey(pInfo.getPid())) {\n           processTree.put(pInfo.getPid(), pInfo);\n         }\n         pInfoQueue.addAll(pInfo.getChildren());\n       }\n \n       // update age values and compute the number of jiffies since last update\n       for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n         ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n         if (procs.getValue() !\u003d null) {\n           procs.getValue().updateJiffy(oldInfo);\n           if (oldInfo !\u003d null) {\n             procs.getValue().updateAge(oldInfo);\n           }\n         }\n       }\n \n-      if (LOG.isDebugEnabled()) {\n-        // Log.debug the ProcfsBasedProcessTree\n-        LOG.debug(this.toString());\n-      }\n+      LOG.debug(this);\n+\n       if (smapsEnabled) {\n-        //Update smaps info\n+        // Update smaps info\n         processSMAPTree.clear();\n         for (ProcessInfo p : processTree.values()) {\n           if (p !\u003d null) {\n             // Get information for each process\n             ProcessTreeSmapMemInfo memInfo \u003d new ProcessTreeSmapMemInfo(p.getPid());\n             constructProcessSMAPInfo(memInfo, procfsDir);\n             processSMAPTree.put(p.getPid(), memInfo);\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateProcessTree() {\n    if (!pid.equals(deadPid)) {\n      // Get the list of processes\n      List\u003cString\u003e processList \u003d getProcessList();\n\n      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n\n      // cache the processTree to get the age for processes\n      Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (String proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return;\n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        String pID \u003d entry.getKey();\n        if (!\"1\".equals(pID)) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          String ppid \u003d pInfo.getPpid();\n          // If parent is init and process is not session leader,\n          // attach to sessionID\n          if (\"1\".equals(ppid)) {\n              String sid \u003d pInfo.getSessionId().toString();\n              if (!pID.equals(sid)) {\n                 ppid \u003d sid;\n              }\n          }\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(ppid);\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      List\u003cProcessInfo\u003e children \u003d me.getChildren();\n      Queue\u003cProcessInfo\u003e pInfoQueue \u003d new ArrayDeque\u003cProcessInfo\u003e(children);\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);\n          }\n        }\n      }\n\n      LOG.debug(this);\n\n      if (smapsEnabled) {\n        // Update smaps info\n        processSMAPTree.clear();\n        for (ProcessInfo p : processTree.values()) {\n          if (p !\u003d null) {\n            // Get information for each process\n            ProcessTreeSmapMemInfo memInfo \u003d new ProcessTreeSmapMemInfo(p.getPid());\n            constructProcessSMAPInfo(memInfo, procfsDir);\n            processSMAPTree.put(p.getPid(), memInfo);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "c6b48391680c1b81a86aabc3ad4c725bfade6d2e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4834. ProcfsBasedProcessTree doesn\u0027t track daemonized processes. Contributed by Nathan Roberts\n",
      "commitDate": "03/05/16 10:27 AM",
      "commitName": "c6b48391680c1b81a86aabc3ad4c725bfade6d2e",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "20/03/16 10:47 AM",
      "commitNameOld": "7fae4c68e6d599d0c01bb2cb2c8d5e52925b3e1e",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 43.99,
      "commitsBetweenForRepo": 265,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,90 @@\n   public void updateProcessTree() {\n     if (!pid.equals(deadPid)) {\n       // Get the list of processes\n       List\u003cString\u003e processList \u003d getProcessList();\n \n       Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n \n       // cache the processTree to get the age for processes\n       Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n               new HashMap\u003cString, ProcessInfo\u003e(processTree);\n       processTree.clear();\n \n       ProcessInfo me \u003d null;\n       for (String proc : processList) {\n         // Get information for each process\n         ProcessInfo pInfo \u003d new ProcessInfo(proc);\n         if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n           allProcessInfo.put(proc, pInfo);\n           if (proc.equals(this.pid)) {\n             me \u003d pInfo; // cache \u0027me\u0027\n             processTree.put(proc, pInfo);\n           }\n         }\n       }\n \n       if (me \u003d\u003d null) {\n         return;\n       }\n \n       // Add each process to its parent.\n       for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n         String pID \u003d entry.getKey();\n         if (!pID.equals(\"1\")) {\n           ProcessInfo pInfo \u003d entry.getValue();\n-          ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n+          String ppid \u003d pInfo.getPpid();\n+          // If parent is init and process is not session leader,\n+          // attach to sessionID\n+          if (ppid.equals(\"1\")) {\n+              String sid \u003d pInfo.getSessionId().toString();\n+              if (!pID.equals(sid)) {\n+                 ppid \u003d sid;\n+              }\n+          }\n+          ProcessInfo parentPInfo \u003d allProcessInfo.get(ppid);\n           if (parentPInfo !\u003d null) {\n             parentPInfo.addChild(pInfo);\n           }\n         }\n       }\n \n       // now start constructing the process-tree\n       LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n       pInfoQueue.addAll(me.getChildren());\n       while (!pInfoQueue.isEmpty()) {\n         ProcessInfo pInfo \u003d pInfoQueue.remove();\n         if (!processTree.containsKey(pInfo.getPid())) {\n           processTree.put(pInfo.getPid(), pInfo);\n         }\n         pInfoQueue.addAll(pInfo.getChildren());\n       }\n \n       // update age values and compute the number of jiffies since last update\n       for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n         ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n         if (procs.getValue() !\u003d null) {\n           procs.getValue().updateJiffy(oldInfo);\n           if (oldInfo !\u003d null) {\n             procs.getValue().updateAge(oldInfo);\n           }\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         // Log.debug the ProcfsBasedProcessTree\n         LOG.debug(this.toString());\n       }\n       if (smapsEnabled) {\n         //Update smaps info\n         processSMAPTree.clear();\n         for (ProcessInfo p : processTree.values()) {\n           if (p !\u003d null) {\n             // Get information for each process\n             ProcessTreeSmapMemInfo memInfo \u003d new ProcessTreeSmapMemInfo(p.getPid());\n             constructProcessSMAPInfo(memInfo, procfsDir);\n             processSMAPTree.put(p.getPid(), memInfo);\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateProcessTree() {\n    if (!pid.equals(deadPid)) {\n      // Get the list of processes\n      List\u003cString\u003e processList \u003d getProcessList();\n\n      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n\n      // cache the processTree to get the age for processes\n      Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (String proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return;\n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        String pID \u003d entry.getKey();\n        if (!pID.equals(\"1\")) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          String ppid \u003d pInfo.getPpid();\n          // If parent is init and process is not session leader,\n          // attach to sessionID\n          if (ppid.equals(\"1\")) {\n              String sid \u003d pInfo.getSessionId().toString();\n              if (!pID.equals(sid)) {\n                 ppid \u003d sid;\n              }\n          }\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(ppid);\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n      pInfoQueue.addAll(me.getChildren());\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);\n          }\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        // Log.debug the ProcfsBasedProcessTree\n        LOG.debug(this.toString());\n      }\n      if (smapsEnabled) {\n        //Update smaps info\n        processSMAPTree.clear();\n        for (ProcessInfo p : processTree.values()) {\n          if (p !\u003d null) {\n            // Get information for each process\n            ProcessTreeSmapMemInfo memInfo \u003d new ProcessTreeSmapMemInfo(p.getPid());\n            constructProcessSMAPInfo(memInfo, procfsDir);\n            processSMAPTree.put(p.getPid(), memInfo);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "06579878dfca0b634aaecfe63bb90c46113b3037": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1775. Enhanced ProcfsBasedProcessTree to optionally add the ability to use smaps for obtaining used memory information. Contributed by Rajesh Balamohan.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580087 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/14 5:01 PM",
      "commitName": "06579878dfca0b634aaecfe63bb90c46113b3037",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/04/13 4:11 PM",
      "commitNameOld": "de6d05c8b00d978094b09bf1f92638049dc35a61",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 338.04,
      "commitsBetweenForRepo": 2271,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,81 @@\n   public void updateProcessTree() {\n     if (!pid.equals(deadPid)) {\n       // Get the list of processes\n       List\u003cString\u003e processList \u003d getProcessList();\n \n       Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n \n       // cache the processTree to get the age for processes\n       Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n               new HashMap\u003cString, ProcessInfo\u003e(processTree);\n       processTree.clear();\n \n       ProcessInfo me \u003d null;\n       for (String proc : processList) {\n         // Get information for each process\n         ProcessInfo pInfo \u003d new ProcessInfo(proc);\n         if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n           allProcessInfo.put(proc, pInfo);\n           if (proc.equals(this.pid)) {\n             me \u003d pInfo; // cache \u0027me\u0027\n             processTree.put(proc, pInfo);\n           }\n         }\n       }\n \n       if (me \u003d\u003d null) {\n         return;\n       }\n \n       // Add each process to its parent.\n       for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n         String pID \u003d entry.getKey();\n         if (!pID.equals(\"1\")) {\n           ProcessInfo pInfo \u003d entry.getValue();\n           ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n           if (parentPInfo !\u003d null) {\n             parentPInfo.addChild(pInfo);\n           }\n         }\n       }\n \n       // now start constructing the process-tree\n       LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n       pInfoQueue.addAll(me.getChildren());\n       while (!pInfoQueue.isEmpty()) {\n         ProcessInfo pInfo \u003d pInfoQueue.remove();\n         if (!processTree.containsKey(pInfo.getPid())) {\n           processTree.put(pInfo.getPid(), pInfo);\n         }\n         pInfoQueue.addAll(pInfo.getChildren());\n       }\n \n       // update age values and compute the number of jiffies since last update\n       for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n         ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n         if (procs.getValue() !\u003d null) {\n           procs.getValue().updateJiffy(oldInfo);\n           if (oldInfo !\u003d null) {\n             procs.getValue().updateAge(oldInfo);\n           }\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         // Log.debug the ProcfsBasedProcessTree\n         LOG.debug(this.toString());\n       }\n+      if (smapsEnabled) {\n+        //Update smaps info\n+        processSMAPTree.clear();\n+        for (ProcessInfo p : processTree.values()) {\n+          if (p !\u003d null) {\n+            // Get information for each process\n+            ProcessTreeSmapMemInfo memInfo \u003d new ProcessTreeSmapMemInfo(p.getPid());\n+            constructProcessSMAPInfo(memInfo, procfsDir);\n+            processSMAPTree.put(p.getPid(), memInfo);\n+          }\n+        }\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateProcessTree() {\n    if (!pid.equals(deadPid)) {\n      // Get the list of processes\n      List\u003cString\u003e processList \u003d getProcessList();\n\n      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n\n      // cache the processTree to get the age for processes\n      Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (String proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return;\n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        String pID \u003d entry.getKey();\n        if (!pID.equals(\"1\")) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n      pInfoQueue.addAll(me.getChildren());\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);\n          }\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        // Log.debug the ProcfsBasedProcessTree\n        LOG.debug(this.toString());\n      }\n      if (smapsEnabled) {\n        //Update smaps info\n        processSMAPTree.clear();\n        for (ProcessInfo p : processTree.values()) {\n          if (p !\u003d null) {\n            // Get information for each process\n            ProcessTreeSmapMemInfo memInfo \u003d new ProcessTreeSmapMemInfo(p.getPid());\n            constructProcessSMAPInfo(memInfo, procfsDir);\n            processSMAPTree.put(p.getPid(), memInfo);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "1a49c854386d3ba4aef6f29f46e2bd5e71e86dc1": {
      "type": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-223. Update process tree instead of getting new process trees. (Radim Kolar via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1424244 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/12/12 4:20 PM",
      "commitName": "1a49c854386d3ba4aef6f29f46e2bd5e71e86dc1",
      "commitAuthor": "Luke Lu",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-223. Update process tree instead of getting new process trees. (Radim Kolar via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1424244 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/12/12 4:20 PM",
          "commitName": "1a49c854386d3ba4aef6f29f46e2bd5e71e86dc1",
          "commitAuthor": "Luke Lu",
          "commitDateOld": "24/10/12 7:07 AM",
          "commitNameOld": "244ec4a5d175801382f7d6d5bf67c0dce61361c8",
          "commitAuthorOld": "Robert Joseph Evans",
          "daysBetweenCommits": 56.43,
          "commitsBetweenForRepo": 255,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,69 @@\n-  public ResourceCalculatorProcessTree getProcessTree() {\n+  public void updateProcessTree() {\n     if (!pid.equals(deadPid)) {\n       // Get the list of processes\n       List\u003cString\u003e processList \u003d getProcessList();\n \n       Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n \n       // cache the processTree to get the age for processes\n       Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n               new HashMap\u003cString, ProcessInfo\u003e(processTree);\n       processTree.clear();\n \n       ProcessInfo me \u003d null;\n       for (String proc : processList) {\n         // Get information for each process\n         ProcessInfo pInfo \u003d new ProcessInfo(proc);\n         if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n           allProcessInfo.put(proc, pInfo);\n           if (proc.equals(this.pid)) {\n             me \u003d pInfo; // cache \u0027me\u0027\n             processTree.put(proc, pInfo);\n           }\n         }\n       }\n \n       if (me \u003d\u003d null) {\n-        return this;\n+        return;\n       }\n \n       // Add each process to its parent.\n       for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n         String pID \u003d entry.getKey();\n         if (!pID.equals(\"1\")) {\n           ProcessInfo pInfo \u003d entry.getValue();\n           ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n           if (parentPInfo !\u003d null) {\n             parentPInfo.addChild(pInfo);\n           }\n         }\n       }\n \n       // now start constructing the process-tree\n       LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n       pInfoQueue.addAll(me.getChildren());\n       while (!pInfoQueue.isEmpty()) {\n         ProcessInfo pInfo \u003d pInfoQueue.remove();\n         if (!processTree.containsKey(pInfo.getPid())) {\n           processTree.put(pInfo.getPid(), pInfo);\n         }\n         pInfoQueue.addAll(pInfo.getChildren());\n       }\n \n       // update age values and compute the number of jiffies since last update\n       for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n         ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n         if (procs.getValue() !\u003d null) {\n           procs.getValue().updateJiffy(oldInfo);\n           if (oldInfo !\u003d null) {\n             procs.getValue().updateAge(oldInfo);\n           }\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         // Log.debug the ProcfsBasedProcessTree\n         LOG.debug(this.toString());\n       }\n     }\n-    return this;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void updateProcessTree() {\n    if (!pid.equals(deadPid)) {\n      // Get the list of processes\n      List\u003cString\u003e processList \u003d getProcessList();\n\n      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n\n      // cache the processTree to get the age for processes\n      Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (String proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return;\n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        String pID \u003d entry.getKey();\n        if (!pID.equals(\"1\")) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n      pInfoQueue.addAll(me.getChildren());\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);\n          }\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        // Log.debug the ProcfsBasedProcessTree\n        LOG.debug(this.toString());\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
          "extendedDetails": {
            "oldValue": "getProcessTree",
            "newValue": "updateProcessTree"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-223. Update process tree instead of getting new process trees. (Radim Kolar via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1424244 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/12/12 4:20 PM",
          "commitName": "1a49c854386d3ba4aef6f29f46e2bd5e71e86dc1",
          "commitAuthor": "Luke Lu",
          "commitDateOld": "24/10/12 7:07 AM",
          "commitNameOld": "244ec4a5d175801382f7d6d5bf67c0dce61361c8",
          "commitAuthorOld": "Robert Joseph Evans",
          "daysBetweenCommits": 56.43,
          "commitsBetweenForRepo": 255,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,69 @@\n-  public ResourceCalculatorProcessTree getProcessTree() {\n+  public void updateProcessTree() {\n     if (!pid.equals(deadPid)) {\n       // Get the list of processes\n       List\u003cString\u003e processList \u003d getProcessList();\n \n       Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n \n       // cache the processTree to get the age for processes\n       Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n               new HashMap\u003cString, ProcessInfo\u003e(processTree);\n       processTree.clear();\n \n       ProcessInfo me \u003d null;\n       for (String proc : processList) {\n         // Get information for each process\n         ProcessInfo pInfo \u003d new ProcessInfo(proc);\n         if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n           allProcessInfo.put(proc, pInfo);\n           if (proc.equals(this.pid)) {\n             me \u003d pInfo; // cache \u0027me\u0027\n             processTree.put(proc, pInfo);\n           }\n         }\n       }\n \n       if (me \u003d\u003d null) {\n-        return this;\n+        return;\n       }\n \n       // Add each process to its parent.\n       for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n         String pID \u003d entry.getKey();\n         if (!pID.equals(\"1\")) {\n           ProcessInfo pInfo \u003d entry.getValue();\n           ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n           if (parentPInfo !\u003d null) {\n             parentPInfo.addChild(pInfo);\n           }\n         }\n       }\n \n       // now start constructing the process-tree\n       LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n       pInfoQueue.addAll(me.getChildren());\n       while (!pInfoQueue.isEmpty()) {\n         ProcessInfo pInfo \u003d pInfoQueue.remove();\n         if (!processTree.containsKey(pInfo.getPid())) {\n           processTree.put(pInfo.getPid(), pInfo);\n         }\n         pInfoQueue.addAll(pInfo.getChildren());\n       }\n \n       // update age values and compute the number of jiffies since last update\n       for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n         ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n         if (procs.getValue() !\u003d null) {\n           procs.getValue().updateJiffy(oldInfo);\n           if (oldInfo !\u003d null) {\n             procs.getValue().updateAge(oldInfo);\n           }\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         // Log.debug the ProcfsBasedProcessTree\n         LOG.debug(this.toString());\n       }\n     }\n-    return this;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void updateProcessTree() {\n    if (!pid.equals(deadPid)) {\n      // Get the list of processes\n      List\u003cString\u003e processList \u003d getProcessList();\n\n      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n\n      // cache the processTree to get the age for processes\n      Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (String proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return;\n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        String pID \u003d entry.getKey();\n        if (!pID.equals(\"1\")) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n      pInfoQueue.addAll(me.getChildren());\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);\n          }\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        // Log.debug the ProcfsBasedProcessTree\n        LOG.debug(this.toString());\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
          "extendedDetails": {
            "oldValue": "ResourceCalculatorProcessTree",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-223. Update process tree instead of getting new process trees. (Radim Kolar via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1424244 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/12/12 4:20 PM",
          "commitName": "1a49c854386d3ba4aef6f29f46e2bd5e71e86dc1",
          "commitAuthor": "Luke Lu",
          "commitDateOld": "24/10/12 7:07 AM",
          "commitNameOld": "244ec4a5d175801382f7d6d5bf67c0dce61361c8",
          "commitAuthorOld": "Robert Joseph Evans",
          "daysBetweenCommits": 56.43,
          "commitsBetweenForRepo": 255,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,69 @@\n-  public ResourceCalculatorProcessTree getProcessTree() {\n+  public void updateProcessTree() {\n     if (!pid.equals(deadPid)) {\n       // Get the list of processes\n       List\u003cString\u003e processList \u003d getProcessList();\n \n       Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n \n       // cache the processTree to get the age for processes\n       Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n               new HashMap\u003cString, ProcessInfo\u003e(processTree);\n       processTree.clear();\n \n       ProcessInfo me \u003d null;\n       for (String proc : processList) {\n         // Get information for each process\n         ProcessInfo pInfo \u003d new ProcessInfo(proc);\n         if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n           allProcessInfo.put(proc, pInfo);\n           if (proc.equals(this.pid)) {\n             me \u003d pInfo; // cache \u0027me\u0027\n             processTree.put(proc, pInfo);\n           }\n         }\n       }\n \n       if (me \u003d\u003d null) {\n-        return this;\n+        return;\n       }\n \n       // Add each process to its parent.\n       for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n         String pID \u003d entry.getKey();\n         if (!pID.equals(\"1\")) {\n           ProcessInfo pInfo \u003d entry.getValue();\n           ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n           if (parentPInfo !\u003d null) {\n             parentPInfo.addChild(pInfo);\n           }\n         }\n       }\n \n       // now start constructing the process-tree\n       LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n       pInfoQueue.addAll(me.getChildren());\n       while (!pInfoQueue.isEmpty()) {\n         ProcessInfo pInfo \u003d pInfoQueue.remove();\n         if (!processTree.containsKey(pInfo.getPid())) {\n           processTree.put(pInfo.getPid(), pInfo);\n         }\n         pInfoQueue.addAll(pInfo.getChildren());\n       }\n \n       // update age values and compute the number of jiffies since last update\n       for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n         ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n         if (procs.getValue() !\u003d null) {\n           procs.getValue().updateJiffy(oldInfo);\n           if (oldInfo !\u003d null) {\n             procs.getValue().updateAge(oldInfo);\n           }\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         // Log.debug the ProcfsBasedProcessTree\n         LOG.debug(this.toString());\n       }\n     }\n-    return this;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void updateProcessTree() {\n    if (!pid.equals(deadPid)) {\n      // Get the list of processes\n      List\u003cString\u003e processList \u003d getProcessList();\n\n      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n\n      // cache the processTree to get the age for processes\n      Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (String proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return;\n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        String pID \u003d entry.getKey();\n        if (!pID.equals(\"1\")) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n      pInfoQueue.addAll(me.getChildren());\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);\n          }\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        // Log.debug the ProcfsBasedProcessTree\n        LOG.debug(this.toString());\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
          "extendedDetails": {}
        }
      ]
    },
    "a1aa1b93497034411d76906405bb6a70a441a0b7": {
      "type": "Yreturntypechange",
      "commitMessage": "YARN-57. Allow process-tree based resource calculation et al. to be pluggable to support it on multiple platforms. Contributed by Radim Kolar.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1382072 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/09/12 8:48 AM",
      "commitName": "a1aa1b93497034411d76906405bb6a70a441a0b7",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "21/08/12 10:46 AM",
      "commitNameOld": "ca2dc3e78507288f4e6a7b652de150c5e172b037",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 16.92,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n-  public ProcfsBasedProcessTree getProcessTree() {\n+  public ResourceCalculatorProcessTree getProcessTree() {\n     if (!pid.equals(deadPid)) {\n       // Get the list of processes\n       List\u003cString\u003e processList \u003d getProcessList();\n \n       Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n-      \n+\n       // cache the processTree to get the age for processes\n-      Map\u003cString, ProcessInfo\u003e oldProcs \u003d \n+      Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n               new HashMap\u003cString, ProcessInfo\u003e(processTree);\n       processTree.clear();\n \n       ProcessInfo me \u003d null;\n       for (String proc : processList) {\n         // Get information for each process\n         ProcessInfo pInfo \u003d new ProcessInfo(proc);\n         if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n           allProcessInfo.put(proc, pInfo);\n           if (proc.equals(this.pid)) {\n             me \u003d pInfo; // cache \u0027me\u0027\n             processTree.put(proc, pInfo);\n           }\n         }\n       }\n \n       if (me \u003d\u003d null) {\n-        return this; \n+        return this;\n       }\n \n       // Add each process to its parent.\n       for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n         String pID \u003d entry.getKey();\n         if (!pID.equals(\"1\")) {\n           ProcessInfo pInfo \u003d entry.getValue();\n           ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n           if (parentPInfo !\u003d null) {\n             parentPInfo.addChild(pInfo);\n           }\n         }\n       }\n \n       // now start constructing the process-tree\n       LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n       pInfoQueue.addAll(me.getChildren());\n       while (!pInfoQueue.isEmpty()) {\n         ProcessInfo pInfo \u003d pInfoQueue.remove();\n         if (!processTree.containsKey(pInfo.getPid())) {\n           processTree.put(pInfo.getPid(), pInfo);\n         }\n         pInfoQueue.addAll(pInfo.getChildren());\n       }\n \n       // update age values and compute the number of jiffies since last update\n       for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n         ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n         if (procs.getValue() !\u003d null) {\n           procs.getValue().updateJiffy(oldInfo);\n           if (oldInfo !\u003d null) {\n-            procs.getValue().updateAge(oldInfo);  \n+            procs.getValue().updateAge(oldInfo);\n           }\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         // Log.debug the ProcfsBasedProcessTree\n         LOG.debug(this.toString());\n       }\n     }\n     return this;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ResourceCalculatorProcessTree getProcessTree() {\n    if (!pid.equals(deadPid)) {\n      // Get the list of processes\n      List\u003cString\u003e processList \u003d getProcessList();\n\n      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n\n      // cache the processTree to get the age for processes\n      Map\u003cString, ProcessInfo\u003e oldProcs \u003d\n              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (String proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return this;\n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        String pID \u003d entry.getKey();\n        if (!pID.equals(\"1\")) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n      pInfoQueue.addAll(me.getChildren());\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);\n          }\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        // Log.debug the ProcfsBasedProcessTree\n        LOG.debug(this.toString());\n      }\n    }\n    return this;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {
        "oldValue": "ProcfsBasedProcessTree",
        "newValue": "ResourceCalculatorProcessTree"
      }
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public ProcfsBasedProcessTree getProcessTree() {\n    if (!pid.equals(deadPid)) {\n      // Get the list of processes\n      List\u003cString\u003e processList \u003d getProcessList();\n\n      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n      \n      // cache the processTree to get the age for processes\n      Map\u003cString, ProcessInfo\u003e oldProcs \u003d \n              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (String proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return this; \n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        String pID \u003d entry.getKey();\n        if (!pID.equals(\"1\")) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n      pInfoQueue.addAll(me.getChildren());\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);  \n          }\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        // Log.debug the ProcfsBasedProcessTree\n        LOG.debug(this.toString());\n      }\n    }\n    return this;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java"
      }
    },
    "b4c8567e1b975ccf32dfc1f63aadb78ac29f2c69": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3583. Change pid to String and stime to BigInteger in order to handle integers larger than Long.MAX_VALUE.  Contributed by Zhihong Yu\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1245828 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/02/12 5:12 PM",
      "commitName": "b4c8567e1b975ccf32dfc1f63aadb78ac29f2c69",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "29/08/11 4:27 PM",
      "commitNameOld": "fb6ecb9b27798a923ca290ba5d23368e3a820a6c",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 172.07,
      "commitsBetweenForRepo": 1095,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public ProcfsBasedProcessTree getProcessTree() {\n-    if (pid !\u003d -1) {\n+    if (!pid.equals(deadPid)) {\n       // Get the list of processes\n-      List\u003cInteger\u003e processList \u003d getProcessList();\n+      List\u003cString\u003e processList \u003d getProcessList();\n \n-      Map\u003cInteger, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cInteger, ProcessInfo\u003e();\n+      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n       \n       // cache the processTree to get the age for processes\n-      Map\u003cInteger, ProcessInfo\u003e oldProcs \u003d \n-              new HashMap\u003cInteger, ProcessInfo\u003e(processTree);\n+      Map\u003cString, ProcessInfo\u003e oldProcs \u003d \n+              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n       processTree.clear();\n \n       ProcessInfo me \u003d null;\n-      for (Integer proc : processList) {\n+      for (String proc : processList) {\n         // Get information for each process\n         ProcessInfo pInfo \u003d new ProcessInfo(proc);\n         if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n           allProcessInfo.put(proc, pInfo);\n           if (proc.equals(this.pid)) {\n             me \u003d pInfo; // cache \u0027me\u0027\n             processTree.put(proc, pInfo);\n           }\n         }\n       }\n \n       if (me \u003d\u003d null) {\n         return this; \n       }\n \n       // Add each process to its parent.\n-      for (Map.Entry\u003cInteger, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n-        Integer pID \u003d entry.getKey();\n-        if (pID !\u003d 1) {\n+      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n+        String pID \u003d entry.getKey();\n+        if (!pID.equals(\"1\")) {\n           ProcessInfo pInfo \u003d entry.getValue();\n           ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n           if (parentPInfo !\u003d null) {\n             parentPInfo.addChild(pInfo);\n           }\n         }\n       }\n \n       // now start constructing the process-tree\n       LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n       pInfoQueue.addAll(me.getChildren());\n       while (!pInfoQueue.isEmpty()) {\n         ProcessInfo pInfo \u003d pInfoQueue.remove();\n         if (!processTree.containsKey(pInfo.getPid())) {\n           processTree.put(pInfo.getPid(), pInfo);\n         }\n         pInfoQueue.addAll(pInfo.getChildren());\n       }\n \n       // update age values and compute the number of jiffies since last update\n-      for (Map.Entry\u003cInteger, ProcessInfo\u003e procs : processTree.entrySet()) {\n+      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n         ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n         if (procs.getValue() !\u003d null) {\n           procs.getValue().updateJiffy(oldInfo);\n           if (oldInfo !\u003d null) {\n             procs.getValue().updateAge(oldInfo);  \n           }\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         // Log.debug the ProcfsBasedProcessTree\n         LOG.debug(this.toString());\n       }\n     }\n     return this;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ProcfsBasedProcessTree getProcessTree() {\n    if (!pid.equals(deadPid)) {\n      // Get the list of processes\n      List\u003cString\u003e processList \u003d getProcessList();\n\n      Map\u003cString, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cString, ProcessInfo\u003e();\n      \n      // cache the processTree to get the age for processes\n      Map\u003cString, ProcessInfo\u003e oldProcs \u003d \n              new HashMap\u003cString, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (String proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return this; \n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cString, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        String pID \u003d entry.getKey();\n        if (!pID.equals(\"1\")) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n      pInfoQueue.addAll(me.getChildren());\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cString, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);  \n          }\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        // Log.debug the ProcfsBasedProcessTree\n        LOG.debug(this.toString());\n      }\n    }\n    return this;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public ProcfsBasedProcessTree getProcessTree() {\n    if (pid !\u003d -1) {\n      // Get the list of processes\n      List\u003cInteger\u003e processList \u003d getProcessList();\n\n      Map\u003cInteger, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cInteger, ProcessInfo\u003e();\n      \n      // cache the processTree to get the age for processes\n      Map\u003cInteger, ProcessInfo\u003e oldProcs \u003d \n              new HashMap\u003cInteger, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (Integer proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return this; \n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cInteger, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        Integer pID \u003d entry.getKey();\n        if (pID !\u003d 1) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n      pInfoQueue.addAll(me.getChildren());\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cInteger, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);  \n          }\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        // Log.debug the ProcfsBasedProcessTree\n        LOG.debug(this.toString());\n      }\n    }\n    return this;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,70 @@\n+  public ProcfsBasedProcessTree getProcessTree() {\n+    if (pid !\u003d -1) {\n+      // Get the list of processes\n+      List\u003cInteger\u003e processList \u003d getProcessList();\n+\n+      Map\u003cInteger, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cInteger, ProcessInfo\u003e();\n+      \n+      // cache the processTree to get the age for processes\n+      Map\u003cInteger, ProcessInfo\u003e oldProcs \u003d \n+              new HashMap\u003cInteger, ProcessInfo\u003e(processTree);\n+      processTree.clear();\n+\n+      ProcessInfo me \u003d null;\n+      for (Integer proc : processList) {\n+        // Get information for each process\n+        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n+        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n+          allProcessInfo.put(proc, pInfo);\n+          if (proc.equals(this.pid)) {\n+            me \u003d pInfo; // cache \u0027me\u0027\n+            processTree.put(proc, pInfo);\n+          }\n+        }\n+      }\n+\n+      if (me \u003d\u003d null) {\n+        return this; \n+      }\n+\n+      // Add each process to its parent.\n+      for (Map.Entry\u003cInteger, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n+        Integer pID \u003d entry.getKey();\n+        if (pID !\u003d 1) {\n+          ProcessInfo pInfo \u003d entry.getValue();\n+          ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n+          if (parentPInfo !\u003d null) {\n+            parentPInfo.addChild(pInfo);\n+          }\n+        }\n+      }\n+\n+      // now start constructing the process-tree\n+      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n+      pInfoQueue.addAll(me.getChildren());\n+      while (!pInfoQueue.isEmpty()) {\n+        ProcessInfo pInfo \u003d pInfoQueue.remove();\n+        if (!processTree.containsKey(pInfo.getPid())) {\n+          processTree.put(pInfo.getPid(), pInfo);\n+        }\n+        pInfoQueue.addAll(pInfo.getChildren());\n+      }\n+\n+      // update age values and compute the number of jiffies since last update\n+      for (Map.Entry\u003cInteger, ProcessInfo\u003e procs : processTree.entrySet()) {\n+        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n+        if (procs.getValue() !\u003d null) {\n+          procs.getValue().updateJiffy(oldInfo);\n+          if (oldInfo !\u003d null) {\n+            procs.getValue().updateAge(oldInfo);  \n+          }\n+        }\n+      }\n+\n+      if (LOG.isDebugEnabled()) {\n+        // Log.debug the ProcfsBasedProcessTree\n+        LOG.debug(this.toString());\n+      }\n+    }\n+    return this;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public ProcfsBasedProcessTree getProcessTree() {\n    if (pid !\u003d -1) {\n      // Get the list of processes\n      List\u003cInteger\u003e processList \u003d getProcessList();\n\n      Map\u003cInteger, ProcessInfo\u003e allProcessInfo \u003d new HashMap\u003cInteger, ProcessInfo\u003e();\n      \n      // cache the processTree to get the age for processes\n      Map\u003cInteger, ProcessInfo\u003e oldProcs \u003d \n              new HashMap\u003cInteger, ProcessInfo\u003e(processTree);\n      processTree.clear();\n\n      ProcessInfo me \u003d null;\n      for (Integer proc : processList) {\n        // Get information for each process\n        ProcessInfo pInfo \u003d new ProcessInfo(proc);\n        if (constructProcessInfo(pInfo, procfsDir) !\u003d null) {\n          allProcessInfo.put(proc, pInfo);\n          if (proc.equals(this.pid)) {\n            me \u003d pInfo; // cache \u0027me\u0027\n            processTree.put(proc, pInfo);\n          }\n        }\n      }\n\n      if (me \u003d\u003d null) {\n        return this; \n      }\n\n      // Add each process to its parent.\n      for (Map.Entry\u003cInteger, ProcessInfo\u003e entry : allProcessInfo.entrySet()) {\n        Integer pID \u003d entry.getKey();\n        if (pID !\u003d 1) {\n          ProcessInfo pInfo \u003d entry.getValue();\n          ProcessInfo parentPInfo \u003d allProcessInfo.get(pInfo.getPpid());\n          if (parentPInfo !\u003d null) {\n            parentPInfo.addChild(pInfo);\n          }\n        }\n      }\n\n      // now start constructing the process-tree\n      LinkedList\u003cProcessInfo\u003e pInfoQueue \u003d new LinkedList\u003cProcessInfo\u003e();\n      pInfoQueue.addAll(me.getChildren());\n      while (!pInfoQueue.isEmpty()) {\n        ProcessInfo pInfo \u003d pInfoQueue.remove();\n        if (!processTree.containsKey(pInfo.getPid())) {\n          processTree.put(pInfo.getPid(), pInfo);\n        }\n        pInfoQueue.addAll(pInfo.getChildren());\n      }\n\n      // update age values and compute the number of jiffies since last update\n      for (Map.Entry\u003cInteger, ProcessInfo\u003e procs : processTree.entrySet()) {\n        ProcessInfo oldInfo \u003d oldProcs.get(procs.getKey());\n        if (procs.getValue() !\u003d null) {\n          procs.getValue().updateJiffy(oldInfo);\n          if (oldInfo !\u003d null) {\n            procs.getValue().updateAge(oldInfo);  \n          }\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        // Log.debug the ProcfsBasedProcessTree\n        LOG.debug(this.toString());\n      }\n    }\n    return this;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java"
    }
  }
}