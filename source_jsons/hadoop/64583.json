{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AFileSystem.java",
  "functionName": "initiateRename",
  "functionId": "initiateRename___src-Path(modifiers-final)__dst-Path(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
  "functionStartLine": 1361,
  "functionEndLine": 1434,
  "numCommitsSeen": 141,
  "timeTaken": 3226,
  "changeHistory": [
    "9221704f857e33a5f9e00c19d3705e46e94f427b",
    "e02eb24e0a9139418120027b694492e0738df20a"
  ],
  "changeHistoryShort": {
    "9221704f857e33a5f9e00c19d3705e46e94f427b": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9221704f857e33a5f9e00c19d3705e46e94f427b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16490. Avoid/handle cached 404s during S3A file creation.\n\nContributed by Steve Loughran.\n\nThis patch avoids issuing any HEAD path request when creating a file with overwrite\u003dtrue,\nso 404s will not end up in the S3 load balancers unless someone calls getFileStatus/exists/isFile\nin their own code.\n\nThe Hadoop FsShell CommandWithDestination class is modified to not register uncreated files\nfor deleteOnExit(), because that calls exists() and so can place the 404 in the cache, even\nafter S3A is patched to not do it itself.\n\nBecause S3Guard knows when a file should be present, it adds a special FileNotFound retry policy\nindependently configurable from other retry policies; it is also exponential, but with\ndifferent parameters. This is because every HEAD request will refresh any 404 cached in\nthe S3 Load Balancers. It\u0027s not enough to retry: we have to have a suitable gap between\nattempts to (hopefully) ensure any cached entry wil be gone.\n\nThe options and values are:\n\nfs.s3a.s3guard.consistency.retry.interval: 2s\nfs.s3a.s3guard.consistency.retry.limit: 7\n\nThe S3A copy() method used during rename() raises a RemoteFileChangedException which is not caught\nso not downgraded to false. Thus: when a rename is unrecoverable, this fact is propagated.\n\nCopy operations without S3Guard lack the confidence that the file exists, so don\u0027t retry the same way:\nit will fail fast with a different error message. However, because create(path, overwrite\u003dfalse) no\nlonger does HEAD path, we can at least be confident that S3A itself is not creating those cached\n404 markers.\n\nChange-Id: Ia7807faad8b9a8546836cb19f816cccf17cca26d\n",
      "commitDate": "11/09/19 8:46 AM",
      "commitName": "9221704f857e33a5f9e00c19d3705e46e94f427b",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/09/19 6:25 AM",
      "commitNameOld": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 6.1,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,74 @@\n   private Pair\u003cS3AFileStatus, S3AFileStatus\u003e initiateRename(\n       final Path src,\n       final Path dst) throws IOException {\n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"source is root directory\");\n     }\n     if (dstKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"dest is root directory\");\n     }\n \n     // get the source file status; this raises a FNFE if there is no source\n     // file.\n-    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n+    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true,\n+        StatusProbeEnum.ALL);\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n           dst);\n       throw new RenameFailedException(src, dst,\n           \"source and dest refer to the same file or directory\")\n           .withExitCode(srcStatus.isFile());\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n-      dstStatus \u003d innerGetFileStatus(dst, true);\n+      dstStatus \u003d innerGetFileStatus(dst, true, StatusProbeEnum.ALL);\n       // if there is no destination entry, an exception is raised.\n       // hence this code sequence can assume that there is something\n       // at the end of the path; the only detail being what it is and\n       // whether or not it can be the destination of the rename.\n       if (srcStatus.isDirectory()) {\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"source is a directory and dest is a file\")\n               .withExitCode(srcStatus.isFile());\n         } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n           throw new RenameFailedException(src, dst,\n               \"Destination is a non-empty directory\")\n               .withExitCode(false);\n         }\n         // at this point the destination is an empty directory\n       } else {\n         // source is a file. The destination must be a directory,\n         // empty or not\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"Cannot rename onto an existing file\")\n               .withExitCode(false);\n         }\n       }\n \n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n-              false);\n+              false, StatusProbeEnum.ALL);\n           if (!dstParentStatus.isDirectory()) {\n             throw new RenameFailedException(src, dst,\n                 \"destination parent is not a directory\");\n           }\n         } catch (FileNotFoundException e2) {\n           throw new RenameFailedException(src, dst,\n               \"destination has no parent \");\n         }\n       }\n     }\n     return Pair.of(srcStatus, dstStatus);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Pair\u003cS3AFileStatus, S3AFileStatus\u003e initiateRename(\n      final Path src,\n      final Path dst) throws IOException {\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true,\n        StatusProbeEnum.ALL);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d innerGetFileStatus(dst, true, StatusProbeEnum.ALL);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n              false, StatusProbeEnum.ALL);\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n    return Pair.of(srcStatus, dstStatus);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,73 @@\n+  private Pair\u003cS3AFileStatus, S3AFileStatus\u003e initiateRename(\n+      final Path src,\n+      final Path dst) throws IOException {\n+    String srcKey \u003d pathToKey(src);\n+    String dstKey \u003d pathToKey(dst);\n+\n+    if (srcKey.isEmpty()) {\n+      throw new RenameFailedException(src, dst, \"source is root directory\");\n+    }\n+    if (dstKey.isEmpty()) {\n+      throw new RenameFailedException(src, dst, \"dest is root directory\");\n+    }\n+\n+    // get the source file status; this raises a FNFE if there is no source\n+    // file.\n+    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n+\n+    if (srcKey.equals(dstKey)) {\n+      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n+          dst);\n+      throw new RenameFailedException(src, dst,\n+          \"source and dest refer to the same file or directory\")\n+          .withExitCode(srcStatus.isFile());\n+    }\n+\n+    S3AFileStatus dstStatus \u003d null;\n+    try {\n+      dstStatus \u003d innerGetFileStatus(dst, true);\n+      // if there is no destination entry, an exception is raised.\n+      // hence this code sequence can assume that there is something\n+      // at the end of the path; the only detail being what it is and\n+      // whether or not it can be the destination of the rename.\n+      if (srcStatus.isDirectory()) {\n+        if (dstStatus.isFile()) {\n+          throw new RenameFailedException(src, dst,\n+              \"source is a directory and dest is a file\")\n+              .withExitCode(srcStatus.isFile());\n+        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n+          throw new RenameFailedException(src, dst,\n+              \"Destination is a non-empty directory\")\n+              .withExitCode(false);\n+        }\n+        // at this point the destination is an empty directory\n+      } else {\n+        // source is a file. The destination must be a directory,\n+        // empty or not\n+        if (dstStatus.isFile()) {\n+          throw new RenameFailedException(src, dst,\n+              \"Cannot rename onto an existing file\")\n+              .withExitCode(false);\n+        }\n+      }\n+\n+    } catch (FileNotFoundException e) {\n+      LOG.debug(\"rename: destination path {} not found\", dst);\n+      // Parent must exist\n+      Path parent \u003d dst.getParent();\n+      if (!pathToKey(parent).isEmpty()) {\n+        try {\n+          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n+              false);\n+          if (!dstParentStatus.isDirectory()) {\n+            throw new RenameFailedException(src, dst,\n+                \"destination parent is not a directory\");\n+          }\n+        } catch (FileNotFoundException e2) {\n+          throw new RenameFailedException(src, dst,\n+              \"destination has no parent \");\n+        }\n+      }\n+    }\n+    return Pair.of(srcStatus, dstStatus);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Pair\u003cS3AFileStatus, S3AFileStatus\u003e initiateRename(\n      final Path src,\n      final Path dst) throws IOException {\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d innerGetFileStatus(dst, true);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n              false);\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n    return Pair.of(srcStatus, dstStatus);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java"
    }
  }
}