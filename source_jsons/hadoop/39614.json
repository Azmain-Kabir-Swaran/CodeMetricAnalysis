{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LeafQueue.java",
  "functionName": "setupQueueConfigs",
  "functionId": "setupQueueConfigs___clusterResource-Resource__conf-CapacitySchedulerConfiguration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
  "functionStartLine": 162,
  "functionEndLine": 321,
  "numCommitsSeen": 176,
  "timeTaken": 5687,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "e578e52aae01248507e089b406fe038ab8e84207",
    "d2d963f3d4819704351c04dbeb90fc8154488f91",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "95372657fc25c02399b01793833021ccf88dada2",
    "890d3d06456a026d9551a0cf15ce3986b0641454",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "e578e52aae01248507e089b406fe038ab8e84207": "Ybodychange",
    "d2d963f3d4819704351c04dbeb90fc8154488f91": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "95372657fc25c02399b01793833021ccf88dada2": "Ybodychange",
    "890d3d06456a026d9551a0cf15ce3986b0641454": "Ybodychange",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "28/01/20 7:54 PM",
      "commitNameOld": "e578e52aae01248507e089b406fe038ab8e84207",
      "commitAuthorOld": "Eric Badger",
      "daysBetweenCommits": 56.31,
      "commitsBetweenForRepo": 177,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,159 +1,160 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration conf) throws\n       IOException {\n     writeLock.lock();\n     try {\n       CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n       super.setupQueueConfigs(clusterResource, conf);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n \n       usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n       usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d schedConf\n             .getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d schedConf.\n               getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n               * usersManager.getUserLimitFactor()));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n           scheduler.getMaxClusterLevelAppPriority());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n-            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n+            \"Invalid default label expression of \" + \" queue\u003d\" + getQueuePath()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n       rackLocalityAdditionalDelay \u003d schedConf\n           .getRackLocalityAdditionalDelay();\n       rackLocalityFullReset \u003d schedConf\n           .getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s)\n               .append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n       // Validate leaf queue\u0027s user\u0027s weights.\n       int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n       for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n         float val \u003d e.getValue().floatValue();\n         if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n           throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n               + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n               100.0f/queueUL + \", the number of concurrent active users in \"\n               + getQueuePath() + \")\");\n         }\n       }\n \n       usersManager.updateUserWeights();\n \n       LOG.info(\n-          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n-              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n+          \"Initializing \" + getQueuePath() + \"\\n\" + \"capacity \u003d \"\n+              + queueCapacities.getCapacity()\n+              + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"effectiveMinResource\u003d\" +\n               getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n               + \" , effectiveMaxResource\u003d\" +\n               getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n               + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n               + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n               + usersManager.getUserLimitFactor()\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\"\n               + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n               + \"rackLocalityAdditionalDelay \u003d \"\n               + rackLocalityAdditionalDelay + \"\\n\"\n               + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n               + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n               + \"\\nmaxLifetime \u003d \" + getMaximumApplicationLifetime()\n               + \" seconds\" + \"\\ndefaultLifetime \u003d \"\n               + getDefaultApplicationLifetime() + \" seconds\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration conf) throws\n      IOException {\n    writeLock.lock();\n    try {\n      CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n      super.setupQueueConfigs(clusterResource, conf);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d schedConf\n            .getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d schedConf.\n              getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n              * usersManager.getUserLimitFactor()));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueuePath()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n      rackLocalityAdditionalDelay \u003d schedConf\n          .getRackLocalityAdditionalDelay();\n      rackLocalityFullReset \u003d schedConf\n          .getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s)\n              .append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      // Validate leaf queue\u0027s user\u0027s weights.\n      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n        float val \u003d e.getValue().floatValue();\n        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n              100.0f/queueUL + \", the number of concurrent active users in \"\n              + getQueuePath() + \")\");\n        }\n      }\n\n      usersManager.updateUserWeights();\n\n      LOG.info(\n          \"Initializing \" + getQueuePath() + \"\\n\" + \"capacity \u003d \"\n              + queueCapacities.getCapacity()\n              + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"effectiveMinResource\u003d\" +\n              getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n              + \" , effectiveMaxResource\u003d\" +\n              getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n              + usersManager.getUserLimitFactor()\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\"\n              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n              + \"rackLocalityAdditionalDelay \u003d \"\n              + rackLocalityAdditionalDelay + \"\\n\"\n              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n              + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n              + \"\\nmaxLifetime \u003d \" + getMaximumApplicationLifetime()\n              + \" seconds\" + \"\\ndefaultLifetime \u003d \"\n              + getDefaultApplicationLifetime() + \" seconds\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "e578e52aae01248507e089b406fe038ab8e84207": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10084. Allow inheritance of max app lifetime / default app lifetime. Contributed by Eric Payne.\n",
      "commitDate": "28/01/20 7:54 PM",
      "commitName": "e578e52aae01248507e089b406fe038ab8e84207",
      "commitAuthor": "Eric Badger",
      "commitDateOld": "22/11/19 12:06 AM",
      "commitNameOld": "8afabe41e4175551ae71217a45f7c4276f10b7da",
      "commitAuthorOld": "Tao Yang",
      "daysBetweenCommits": 67.83,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,172 +1,159 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration conf) throws\n       IOException {\n     writeLock.lock();\n     try {\n       CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n       super.setupQueueConfigs(clusterResource, conf);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n \n       usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n       usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d schedConf\n             .getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d schedConf.\n               getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n               * usersManager.getUserLimitFactor()));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n           scheduler.getMaxClusterLevelAppPriority());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n       rackLocalityAdditionalDelay \u003d schedConf\n           .getRackLocalityAdditionalDelay();\n       rackLocalityFullReset \u003d schedConf\n           .getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s)\n               .append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n-      maxApplicationLifetime \u003d\n-          conf.getMaximumLifetimePerQueue((getQueuePath()));\n-      defaultApplicationLifetime \u003d\n-          conf.getDefaultLifetimePerQueue((getQueuePath()));\n-      if (maxApplicationLifetime \u003e 0 \u0026\u0026\n-          defaultApplicationLifetime \u003e maxApplicationLifetime) {\n-        throw new YarnRuntimeException(\n-            \"Default lifetime\" + defaultApplicationLifetime\n-                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n-      }\n-      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n-          ? defaultApplicationLifetime : maxApplicationLifetime;\n-\n       // Validate leaf queue\u0027s user\u0027s weights.\n       int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n       for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n         float val \u003d e.getValue().floatValue();\n         if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n           throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n               + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n               100.0f/queueUL + \", the number of concurrent active users in \"\n               + getQueuePath() + \")\");\n         }\n       }\n \n       usersManager.updateUserWeights();\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"effectiveMinResource\u003d\" +\n               getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n               + \" , effectiveMaxResource\u003d\" +\n               getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n               + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n               + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n               + usersManager.getUserLimitFactor()\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\"\n               + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n               + \"rackLocalityAdditionalDelay \u003d \"\n               + rackLocalityAdditionalDelay + \"\\n\"\n               + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n               + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n-              + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n-              + \"\\ndefaultLifetime \u003d \"\n-              + defaultApplicationLifetime + \" seconds\");\n+              + \"\\nmaxLifetime \u003d \" + getMaximumApplicationLifetime()\n+              + \" seconds\" + \"\\ndefaultLifetime \u003d \"\n+              + getDefaultApplicationLifetime() + \" seconds\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration conf) throws\n      IOException {\n    writeLock.lock();\n    try {\n      CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n      super.setupQueueConfigs(clusterResource, conf);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d schedConf\n            .getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d schedConf.\n              getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n              * usersManager.getUserLimitFactor()));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n      rackLocalityAdditionalDelay \u003d schedConf\n          .getRackLocalityAdditionalDelay();\n      rackLocalityFullReset \u003d schedConf\n          .getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s)\n              .append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      // Validate leaf queue\u0027s user\u0027s weights.\n      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n        float val \u003d e.getValue().floatValue();\n        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n              100.0f/queueUL + \", the number of concurrent active users in \"\n              + getQueuePath() + \")\");\n        }\n      }\n\n      usersManager.updateUserWeights();\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"effectiveMinResource\u003d\" +\n              getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n              + \" , effectiveMaxResource\u003d\" +\n              getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n              + usersManager.getUserLimitFactor()\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\"\n              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n              + \"rackLocalityAdditionalDelay \u003d \"\n              + rackLocalityAdditionalDelay + \"\\n\"\n              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n              + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n              + \"\\nmaxLifetime \u003d \" + getMaximumApplicationLifetime()\n              + \" seconds\" + \"\\ndefaultLifetime \u003d \"\n              + getDefaultApplicationLifetime() + \" seconds\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "d2d963f3d4819704351c04dbeb90fc8154488f91": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9790. Failed to set default-application-lifetime if maximum-application-lifetime is less than or equal to zero. Contributed by kyungwan nam.\n",
      "commitDate": "31/08/19 9:24 PM",
      "commitName": "d2d963f3d4819704351c04dbeb90fc8154488f91",
      "commitAuthor": "Abhishek Modi",
      "commitDateOld": "29/08/19 3:14 AM",
      "commitNameOld": "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 2.76,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,172 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration conf) throws\n       IOException {\n     writeLock.lock();\n     try {\n       CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n       super.setupQueueConfigs(clusterResource, conf);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n \n       usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n       usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d schedConf\n             .getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d schedConf.\n               getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n               * usersManager.getUserLimitFactor()));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n           scheduler.getMaxClusterLevelAppPriority());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n       rackLocalityAdditionalDelay \u003d schedConf\n           .getRackLocalityAdditionalDelay();\n       rackLocalityFullReset \u003d schedConf\n           .getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s)\n               .append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n       maxApplicationLifetime \u003d\n           conf.getMaximumLifetimePerQueue((getQueuePath()));\n       defaultApplicationLifetime \u003d\n           conf.getDefaultLifetimePerQueue((getQueuePath()));\n-      if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n+      if (maxApplicationLifetime \u003e 0 \u0026\u0026\n+          defaultApplicationLifetime \u003e maxApplicationLifetime) {\n         throw new YarnRuntimeException(\n             \"Default lifetime\" + defaultApplicationLifetime\n                 + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n       }\n       defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n           ? defaultApplicationLifetime : maxApplicationLifetime;\n \n       // Validate leaf queue\u0027s user\u0027s weights.\n       int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n       for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n         float val \u003d e.getValue().floatValue();\n         if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n           throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n               + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n               100.0f/queueUL + \", the number of concurrent active users in \"\n               + getQueuePath() + \")\");\n         }\n       }\n \n       usersManager.updateUserWeights();\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"effectiveMinResource\u003d\" +\n               getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n               + \" , effectiveMaxResource\u003d\" +\n               getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n               + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n               + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n               + usersManager.getUserLimitFactor()\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\"\n               + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n               + \"rackLocalityAdditionalDelay \u003d \"\n               + rackLocalityAdditionalDelay + \"\\n\"\n               + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n               + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n               + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n               + \"\\ndefaultLifetime \u003d \"\n               + defaultApplicationLifetime + \" seconds\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration conf) throws\n      IOException {\n    writeLock.lock();\n    try {\n      CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n      super.setupQueueConfigs(clusterResource, conf);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d schedConf\n            .getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d schedConf.\n              getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n              * usersManager.getUserLimitFactor()));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n      rackLocalityAdditionalDelay \u003d schedConf\n          .getRackLocalityAdditionalDelay();\n      rackLocalityFullReset \u003d schedConf\n          .getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s)\n              .append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      maxApplicationLifetime \u003d\n          conf.getMaximumLifetimePerQueue((getQueuePath()));\n      defaultApplicationLifetime \u003d\n          conf.getDefaultLifetimePerQueue((getQueuePath()));\n      if (maxApplicationLifetime \u003e 0 \u0026\u0026\n          defaultApplicationLifetime \u003e maxApplicationLifetime) {\n        throw new YarnRuntimeException(\n            \"Default lifetime\" + defaultApplicationLifetime\n                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n      }\n      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n          ? defaultApplicationLifetime : maxApplicationLifetime;\n\n      // Validate leaf queue\u0027s user\u0027s weights.\n      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n        float val \u003d e.getValue().floatValue();\n        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n              100.0f/queueUL + \", the number of concurrent active users in \"\n              + getQueuePath() + \")\");\n        }\n      }\n\n      usersManager.updateUserWeights();\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"effectiveMinResource\u003d\" +\n              getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n              + \" , effectiveMaxResource\u003d\" +\n              getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n              + usersManager.getUserLimitFactor()\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\"\n              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n              + \"rackLocalityAdditionalDelay \u003d \"\n              + rackLocalityAdditionalDelay + \"\\n\"\n              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n              + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n              + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n              + \"\\ndefaultLifetime \u003d \"\n              + defaultApplicationLifetime + \" seconds\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,171 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration conf) throws\n       IOException {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n       super.setupQueueConfigs(clusterResource, conf);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n \n       usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n       usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d schedConf\n             .getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d schedConf.\n               getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n               * usersManager.getUserLimitFactor()));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n           scheduler.getMaxClusterLevelAppPriority());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n       rackLocalityAdditionalDelay \u003d schedConf\n           .getRackLocalityAdditionalDelay();\n       rackLocalityFullReset \u003d schedConf\n           .getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s)\n               .append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n       maxApplicationLifetime \u003d\n           conf.getMaximumLifetimePerQueue((getQueuePath()));\n       defaultApplicationLifetime \u003d\n           conf.getDefaultLifetimePerQueue((getQueuePath()));\n       if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n         throw new YarnRuntimeException(\n             \"Default lifetime\" + defaultApplicationLifetime\n                 + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n       }\n       defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n           ? defaultApplicationLifetime : maxApplicationLifetime;\n \n       // Validate leaf queue\u0027s user\u0027s weights.\n       int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n       for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n         float val \u003d e.getValue().floatValue();\n         if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n           throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n               + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n               100.0f/queueUL + \", the number of concurrent active users in \"\n               + getQueuePath() + \")\");\n         }\n       }\n \n       usersManager.updateUserWeights();\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"effectiveMinResource\u003d\" +\n               getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n               + \" , effectiveMaxResource\u003d\" +\n               getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n               + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n               + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n               + usersManager.getUserLimitFactor()\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\"\n               + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n               + \"rackLocalityAdditionalDelay \u003d \"\n               + rackLocalityAdditionalDelay + \"\\n\"\n               + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n               + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n               + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n               + \"\\ndefaultLifetime \u003d \"\n               + defaultApplicationLifetime + \" seconds\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration conf) throws\n      IOException {\n    writeLock.lock();\n    try {\n      CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n      super.setupQueueConfigs(clusterResource, conf);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d schedConf\n            .getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d schedConf.\n              getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n              * usersManager.getUserLimitFactor()));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n      rackLocalityAdditionalDelay \u003d schedConf\n          .getRackLocalityAdditionalDelay();\n      rackLocalityFullReset \u003d schedConf\n          .getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s)\n              .append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      maxApplicationLifetime \u003d\n          conf.getMaximumLifetimePerQueue((getQueuePath()));\n      defaultApplicationLifetime \u003d\n          conf.getDefaultLifetimePerQueue((getQueuePath()));\n      if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n        throw new YarnRuntimeException(\n            \"Default lifetime\" + defaultApplicationLifetime\n                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n      }\n      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n          ? defaultApplicationLifetime : maxApplicationLifetime;\n\n      // Validate leaf queue\u0027s user\u0027s weights.\n      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n        float val \u003d e.getValue().floatValue();\n        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n              100.0f/queueUL + \", the number of concurrent active users in \"\n              + getQueuePath() + \")\");\n        }\n      }\n\n      usersManager.updateUserWeights();\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"effectiveMinResource\u003d\" +\n              getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n              + \" , effectiveMaxResource\u003d\" +\n              getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n              + usersManager.getUserLimitFactor()\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\"\n              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n              + \"rackLocalityAdditionalDelay \u003d \"\n              + rackLocalityAdditionalDelay + \"\\n\"\n              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n              + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n              + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n              + \"\\ndefaultLifetime \u003d \"\n              + defaultApplicationLifetime + \" seconds\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "95372657fc25c02399b01793833021ccf88dada2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9287. Consecutive StringBuilder append should be reuse. Contributed by Ayush Saxena.\n",
      "commitDate": "25/02/19 11:45 AM",
      "commitName": "95372657fc25c02399b01793833021ccf88dada2",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "24/02/19 6:17 AM",
      "commitNameOld": "50094d7fefafaf0e88798b43cdce291ae067e3fd",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 1.23,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,171 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration conf) throws\n       IOException {\n     try {\n       writeLock.lock();\n       CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n       super.setupQueueConfigs(clusterResource, conf);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n \n       usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n       usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d schedConf\n             .getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d schedConf.\n               getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n               * usersManager.getUserLimitFactor()));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n           scheduler.getMaxClusterLevelAppPriority());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n       rackLocalityAdditionalDelay \u003d schedConf\n           .getRackLocalityAdditionalDelay();\n       rackLocalityFullReset \u003d schedConf\n           .getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n-          labelStrBuilder.append(s);\n-          labelStrBuilder.append(\",\");\n+          labelStrBuilder.append(s)\n+              .append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n       maxApplicationLifetime \u003d\n           conf.getMaximumLifetimePerQueue((getQueuePath()));\n       defaultApplicationLifetime \u003d\n           conf.getDefaultLifetimePerQueue((getQueuePath()));\n       if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n         throw new YarnRuntimeException(\n             \"Default lifetime\" + defaultApplicationLifetime\n                 + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n       }\n       defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n           ? defaultApplicationLifetime : maxApplicationLifetime;\n \n       // Validate leaf queue\u0027s user\u0027s weights.\n       int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n       for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n         float val \u003d e.getValue().floatValue();\n         if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n           throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n               + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n               100.0f/queueUL + \", the number of concurrent active users in \"\n               + getQueuePath() + \")\");\n         }\n       }\n \n       usersManager.updateUserWeights();\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"effectiveMinResource\u003d\" +\n               getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n               + \" , effectiveMaxResource\u003d\" +\n               getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n               + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n               + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n               + usersManager.getUserLimitFactor()\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\"\n               + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n               + \"rackLocalityAdditionalDelay \u003d \"\n               + rackLocalityAdditionalDelay + \"\\n\"\n               + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n               + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n               + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n               + \"\\ndefaultLifetime \u003d \"\n               + defaultApplicationLifetime + \" seconds\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration conf) throws\n      IOException {\n    try {\n      writeLock.lock();\n      CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n      super.setupQueueConfigs(clusterResource, conf);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d schedConf\n            .getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d schedConf.\n              getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n              * usersManager.getUserLimitFactor()));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n      rackLocalityAdditionalDelay \u003d schedConf\n          .getRackLocalityAdditionalDelay();\n      rackLocalityFullReset \u003d schedConf\n          .getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s)\n              .append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      maxApplicationLifetime \u003d\n          conf.getMaximumLifetimePerQueue((getQueuePath()));\n      defaultApplicationLifetime \u003d\n          conf.getDefaultLifetimePerQueue((getQueuePath()));\n      if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n        throw new YarnRuntimeException(\n            \"Default lifetime\" + defaultApplicationLifetime\n                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n      }\n      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n          ? defaultApplicationLifetime : maxApplicationLifetime;\n\n      // Validate leaf queue\u0027s user\u0027s weights.\n      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n        float val \u003d e.getValue().floatValue();\n        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n              100.0f/queueUL + \", the number of concurrent active users in \"\n              + getQueuePath() + \")\");\n        }\n      }\n\n      usersManager.updateUserWeights();\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"effectiveMinResource\u003d\" +\n              getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n              + \" , effectiveMaxResource\u003d\" +\n              getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n              + usersManager.getUserLimitFactor()\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\"\n              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n              + \"rackLocalityAdditionalDelay \u003d \"\n              + rackLocalityAdditionalDelay + \"\\n\"\n              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n              + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n              + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n              + \"\\ndefaultLifetime \u003d \"\n              + defaultApplicationLifetime + \" seconds\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "890d3d06456a026d9551a0cf15ce3986b0641454": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7638. Unit tests related to preemption for auto created leaf queues feature.Contributed by Suma Shivaprasad.\n",
      "commitDate": "14/12/17 11:30 PM",
      "commitName": "890d3d06456a026d9551a0cf15ce3986b0641454",
      "commitAuthor": "Sunil G",
      "commitDateOld": "08/12/17 3:17 PM",
      "commitNameOld": "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 6.34,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,167 +1,171 @@\n   protected void setupQueueConfigs(Resource clusterResource,\n       CapacitySchedulerConfiguration conf) throws\n       IOException {\n     try {\n       writeLock.lock();\n       CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n       super.setupQueueConfigs(clusterResource, conf);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n \n       usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n       usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d schedConf\n             .getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d schedConf.\n               getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n               * usersManager.getUserLimitFactor()));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n           scheduler.getMaxClusterLevelAppPriority());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n       rackLocalityAdditionalDelay \u003d schedConf\n           .getRackLocalityAdditionalDelay();\n       rackLocalityFullReset \u003d schedConf\n           .getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s);\n           labelStrBuilder.append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n       maxApplicationLifetime \u003d\n           conf.getMaximumLifetimePerQueue((getQueuePath()));\n       defaultApplicationLifetime \u003d\n           conf.getDefaultLifetimePerQueue((getQueuePath()));\n       if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n         throw new YarnRuntimeException(\n             \"Default lifetime\" + defaultApplicationLifetime\n                 + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n       }\n       defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n           ? defaultApplicationLifetime : maxApplicationLifetime;\n \n       // Validate leaf queue\u0027s user\u0027s weights.\n       int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n       for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n         float val \u003d e.getValue().floatValue();\n         if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n           throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n               + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n               100.0f/queueUL + \", the number of concurrent active users in \"\n               + getQueuePath() + \")\");\n         }\n       }\n \n       usersManager.updateUserWeights();\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n+              + \"\\n\" + \"effectiveMinResource\u003d\" +\n+              getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n+              + \" , effectiveMaxResource\u003d\" +\n+              getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n               + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n               + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n               + usersManager.getUserLimitFactor()\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\"\n               + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n               + \"rackLocalityAdditionalDelay \u003d \"\n               + rackLocalityAdditionalDelay + \"\\n\"\n               + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n               + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n               + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n               + \"\\ndefaultLifetime \u003d \"\n               + defaultApplicationLifetime + \" seconds\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration conf) throws\n      IOException {\n    try {\n      writeLock.lock();\n      CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n      super.setupQueueConfigs(clusterResource, conf);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d schedConf\n            .getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d schedConf.\n              getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n              * usersManager.getUserLimitFactor()));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n      rackLocalityAdditionalDelay \u003d schedConf\n          .getRackLocalityAdditionalDelay();\n      rackLocalityFullReset \u003d schedConf\n          .getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      maxApplicationLifetime \u003d\n          conf.getMaximumLifetimePerQueue((getQueuePath()));\n      defaultApplicationLifetime \u003d\n          conf.getDefaultLifetimePerQueue((getQueuePath()));\n      if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n        throw new YarnRuntimeException(\n            \"Default lifetime\" + defaultApplicationLifetime\n                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n      }\n      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n          ? defaultApplicationLifetime : maxApplicationLifetime;\n\n      // Validate leaf queue\u0027s user\u0027s weights.\n      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n        float val \u003d e.getValue().floatValue();\n        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n              100.0f/queueUL + \", the number of concurrent active users in \"\n              + getQueuePath() + \")\");\n        }\n      }\n\n      usersManager.updateUserWeights();\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"effectiveMinResource\u003d\" +\n              getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + \"\\n\"\n              + \" , effectiveMaxResource\u003d\" +\n              getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL)\n              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n              + usersManager.getUserLimitFactor()\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\"\n              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n              + \"rackLocalityAdditionalDelay \u003d \"\n              + rackLocalityAdditionalDelay + \"\\n\"\n              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n              + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n              + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n              + \"\\ndefaultLifetime \u003d \"\n              + defaultApplicationLifetime + \" seconds\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,167 @@\n+  protected void setupQueueConfigs(Resource clusterResource,\n+      CapacitySchedulerConfiguration conf) throws\n+      IOException {\n+    try {\n+      writeLock.lock();\n+      CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n+      super.setupQueueConfigs(clusterResource, conf);\n+\n+      this.lastClusterResource \u003d clusterResource;\n+\n+      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n+          clusterResource);\n+\n+      // Initialize headroom info, also used for calculating application\n+      // master resource limits.  Since this happens during queue initialization\n+      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n+      // absoluteMaxCapacity (it will be replaced with the more accurate\n+      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n+      setQueueResourceLimitsInfo(clusterResource);\n+\n+      setOrderingPolicy(\n+          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n+\n+      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n+      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n+\n+      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n+      if (maxApplications \u003c 0) {\n+        int maxGlobalPerQueueApps \u003d schedConf\n+            .getGlobalMaximumApplicationsPerQueue();\n+        if (maxGlobalPerQueueApps \u003e 0) {\n+          maxApplications \u003d maxGlobalPerQueueApps;\n+        } else {\n+          int maxSystemApps \u003d schedConf.\n+              getMaximumSystemApplications();\n+          maxApplications \u003d\n+              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n+        }\n+      }\n+      maxApplicationsPerUser \u003d Math.min(maxApplications,\n+          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n+              * usersManager.getUserLimitFactor()));\n+\n+      maxAMResourcePerQueuePercent \u003d\n+          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n+              getQueuePath());\n+\n+      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n+          scheduler.getMaxClusterLevelAppPriority());\n+\n+      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n+          this.defaultLabelExpression, null)) {\n+        throw new IOException(\n+            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n+                + \" doesn\u0027t have permission to access all labels \"\n+                + \"in default label expression. labelExpression of resource request\u003d\"\n+                + (this.defaultLabelExpression \u003d\u003d null ?\n+                \"\" :\n+                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n+                getAccessibleNodeLabels() \u003d\u003d null ?\n+                    \"\" :\n+                    StringUtils\n+                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n+      }\n+\n+      nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n+      rackLocalityAdditionalDelay \u003d schedConf\n+          .getRackLocalityAdditionalDelay();\n+      rackLocalityFullReset \u003d schedConf\n+          .getRackLocalityFullReset();\n+\n+      // re-init this since max allocation could have changed\n+      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n+          Resources.subtract(maximumAllocation, minimumAllocation),\n+          maximumAllocation);\n+\n+      StringBuilder aclsString \u003d new StringBuilder();\n+      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n+        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n+      }\n+\n+      StringBuilder labelStrBuilder \u003d new StringBuilder();\n+      if (accessibleLabels !\u003d null) {\n+        for (String s : accessibleLabels) {\n+          labelStrBuilder.append(s);\n+          labelStrBuilder.append(\",\");\n+        }\n+      }\n+\n+      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n+          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n+\n+      maxApplicationLifetime \u003d\n+          conf.getMaximumLifetimePerQueue((getQueuePath()));\n+      defaultApplicationLifetime \u003d\n+          conf.getDefaultLifetimePerQueue((getQueuePath()));\n+      if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n+        throw new YarnRuntimeException(\n+            \"Default lifetime\" + defaultApplicationLifetime\n+                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n+      }\n+      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n+          ? defaultApplicationLifetime : maxApplicationLifetime;\n+\n+      // Validate leaf queue\u0027s user\u0027s weights.\n+      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n+      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n+        float val \u003d e.getValue().floatValue();\n+        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n+          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n+              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n+              100.0f/queueUL + \", the number of concurrent active users in \"\n+              + getQueuePath() + \")\");\n+        }\n+      }\n+\n+      usersManager.updateUserWeights();\n+\n+      LOG.info(\n+          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n+              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n+              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n+              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n+              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n+              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n+              + queueCapacities.getAbsoluteMaximumCapacity()\n+              + \" [\u003d 1.0 maximumCapacity undefined, \"\n+              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n+              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n+              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n+              + usersManager.getUserLimitFactor()\n+              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n+              + maxApplications\n+              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n+              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n+              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n+              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n+              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n+              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n+              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n+              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n+              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n+              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n+              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n+              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n+              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n+              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n+              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n+              + \"numContainers \u003d \" + numContainers\n+              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n+              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n+              + \" [\u003d configuredAcls ]\" + \"\\n\"\n+              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n+              + \"rackLocalityAdditionalDelay \u003d \"\n+              + rackLocalityAdditionalDelay + \"\\n\"\n+              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n+              + \"reservationsContinueLooking \u003d \"\n+              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n+              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n+              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n+              + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n+              + \"\\ndefaultLifetime \u003d \"\n+              + defaultApplicationLifetime + \" seconds\");\n+    } finally {\n+      writeLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource,\n      CapacitySchedulerConfiguration conf) throws\n      IOException {\n    try {\n      writeLock.lock();\n      CapacitySchedulerConfiguration schedConf \u003d csContext.getConfiguration();\n      super.setupQueueConfigs(clusterResource, conf);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d schedConf\n            .getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d schedConf.\n              getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n              * usersManager.getUserLimitFactor()));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d schedConf.getNodeLocalityDelay();\n      rackLocalityAdditionalDelay \u003d schedConf\n          .getRackLocalityAdditionalDelay();\n      rackLocalityFullReset \u003d schedConf\n          .getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      maxApplicationLifetime \u003d\n          conf.getMaximumLifetimePerQueue((getQueuePath()));\n      defaultApplicationLifetime \u003d\n          conf.getDefaultLifetimePerQueue((getQueuePath()));\n      if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n        throw new YarnRuntimeException(\n            \"Default lifetime\" + defaultApplicationLifetime\n                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n      }\n      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n          ? defaultApplicationLifetime : maxApplicationLifetime;\n\n      // Validate leaf queue\u0027s user\u0027s weights.\n      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n        float val \u003d e.getValue().floatValue();\n        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n              100.0f/queueUL + \", the number of concurrent active users in \"\n              + getQueuePath() + \")\");\n        }\n      }\n\n      usersManager.updateUserWeights();\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n              + usersManager.getUserLimitFactor()\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\"\n              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n              + \"rackLocalityAdditionalDelay \u003d \"\n              + rackLocalityAdditionalDelay + \"\\n\"\n              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n              + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n              + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n              + \"\\ndefaultLifetime \u003d \"\n              + defaultApplicationLifetime + \" seconds\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
    }
  }
}