{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "MountTableStoreImpl.java",
  "functionName": "getMountTableEntries",
  "functionId": "getMountTableEntries___request-GetMountTableEntriesRequest",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/impl/MountTableStoreImpl.java",
  "functionStartLine": 178,
  "functionEndLine": 232,
  "numCommitsSeen": 11,
  "timeTaken": 3637,
  "changeHistory": [
    "8730a7bf6025a3b2b7d6e6686533283b854af192",
    "47fdae79041ba2bb036ef7723a93ade5b1ac3619",
    "6b2d6d4aafb110bef1b77d4ccbba4350e624b57d",
    "0b796754b9d746c0389782f1a5e3ee9ef673e54c",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
    "ee028bfdf1c88a27cd925bed93ebb599a164dd2e",
    "6f0de2731806628b5b01bd1350225692147590da"
  ],
  "changeHistoryShort": {
    "8730a7bf6025a3b2b7d6e6686533283b854af192": "Ybodychange",
    "47fdae79041ba2bb036ef7723a93ade5b1ac3619": "Ybodychange",
    "6b2d6d4aafb110bef1b77d4ccbba4350e624b57d": "Ybodychange",
    "0b796754b9d746c0389782f1a5e3ee9ef673e54c": "Ybodychange",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": "Yfilerename",
    "ee028bfdf1c88a27cd925bed93ebb599a164dd2e": "Ybodychange",
    "6f0de2731806628b5b01bd1350225692147590da": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8730a7bf6025a3b2b7d6e6686533283b854af192": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15003. RBF: Make Router support storage type quota. Contributed by Jinglun.\n",
      "commitDate": "26/12/19 7:52 PM",
      "commitName": "8730a7bf6025a3b2b7d6e6686533283b854af192",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "04/12/19 2:19 AM",
      "commitNameOld": "47fdae79041ba2bb036ef7723a93ade5b1ac3619",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 22.73,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,55 @@\n   public GetMountTableEntriesResponse getMountTableEntries(\n       GetMountTableEntriesRequest request) throws IOException {\n     RouterPermissionChecker pc \u003d\n         RouterAdminServer.getPermissionChecker();\n     // Get all values from the cache\n     List\u003cMountTable\u003e records \u003d getCachedRecords();\n \n     // Sort and filter\n     Collections.sort(records, MountTable.SOURCE_COMPARATOR);\n     String reqSrcPath \u003d request.getSrcPath();\n     if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n       // Return only entries beneath this path\n       Iterator\u003cMountTable\u003e it \u003d records.iterator();\n       while (it.hasNext()) {\n         MountTable record \u003d it.next();\n         String srcPath \u003d record.getSourcePath();\n         if (!isParentEntry(srcPath, reqSrcPath)) {\n           it.remove();\n         } else if (pc !\u003d null) {\n           // do the READ permission check\n           try {\n             pc.checkPermission(record, FsAction.READ);\n           } catch (AccessControlException ignored) {\n             // Remove this mount table entry if it cannot\n             // be accessed by current user.\n             it.remove();\n           }\n         }\n         // If quota manager is not null, update quota usage from quota cache.\n         if (this.getQuotaManager() !\u003d null) {\n           RouterQuotaUsage quota \u003d\n               this.getQuotaManager().getQuotaUsage(record.getSourcePath());\n           if (quota !\u003d null) {\n             RouterQuotaUsage oldquota \u003d record.getQuota();\n-            RouterQuotaUsage newQuota \u003d new RouterQuotaUsage.Builder()\n+            RouterQuotaUsage.Builder builder \u003d new RouterQuotaUsage.Builder()\n                 .fileAndDirectoryCount(quota.getFileAndDirectoryCount())\n                 .quota(oldquota.getQuota())\n                 .spaceConsumed(quota.getSpaceConsumed())\n-                .spaceQuota(oldquota.getSpaceQuota()).build();\n-            record.setQuota(newQuota);\n+                .spaceQuota(oldquota.getSpaceQuota());\n+            eachByStorageType(t -\u003e {\n+              builder.typeQuota(t, oldquota.getTypeQuota(t));\n+              builder.typeConsumed(t, quota.getTypeConsumed(t));\n+            });\n+            record.setQuota(builder.build());\n           }\n         }\n       }\n     }\n \n     GetMountTableEntriesResponse response \u003d\n         GetMountTableEntriesResponse.newInstance();\n     response.setEntries(records);\n     response.setTimestamp(Time.now());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetMountTableEntriesResponse getMountTableEntries(\n      GetMountTableEntriesRequest request) throws IOException {\n    RouterPermissionChecker pc \u003d\n        RouterAdminServer.getPermissionChecker();\n    // Get all values from the cache\n    List\u003cMountTable\u003e records \u003d getCachedRecords();\n\n    // Sort and filter\n    Collections.sort(records, MountTable.SOURCE_COMPARATOR);\n    String reqSrcPath \u003d request.getSrcPath();\n    if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n      // Return only entries beneath this path\n      Iterator\u003cMountTable\u003e it \u003d records.iterator();\n      while (it.hasNext()) {\n        MountTable record \u003d it.next();\n        String srcPath \u003d record.getSourcePath();\n        if (!isParentEntry(srcPath, reqSrcPath)) {\n          it.remove();\n        } else if (pc !\u003d null) {\n          // do the READ permission check\n          try {\n            pc.checkPermission(record, FsAction.READ);\n          } catch (AccessControlException ignored) {\n            // Remove this mount table entry if it cannot\n            // be accessed by current user.\n            it.remove();\n          }\n        }\n        // If quota manager is not null, update quota usage from quota cache.\n        if (this.getQuotaManager() !\u003d null) {\n          RouterQuotaUsage quota \u003d\n              this.getQuotaManager().getQuotaUsage(record.getSourcePath());\n          if (quota !\u003d null) {\n            RouterQuotaUsage oldquota \u003d record.getQuota();\n            RouterQuotaUsage.Builder builder \u003d new RouterQuotaUsage.Builder()\n                .fileAndDirectoryCount(quota.getFileAndDirectoryCount())\n                .quota(oldquota.getQuota())\n                .spaceConsumed(quota.getSpaceConsumed())\n                .spaceQuota(oldquota.getSpaceQuota());\n            eachByStorageType(t -\u003e {\n              builder.typeQuota(t, oldquota.getTypeQuota(t));\n              builder.typeConsumed(t, quota.getTypeConsumed(t));\n            });\n            record.setQuota(builder.build());\n          }\n        }\n      }\n    }\n\n    GetMountTableEntriesResponse response \u003d\n        GetMountTableEntriesResponse.newInstance();\n    response.setEntries(records);\n    response.setTimestamp(Time.now());\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/impl/MountTableStoreImpl.java",
      "extendedDetails": {}
    },
    "47fdae79041ba2bb036ef7723a93ade5b1ac3619": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13811. RBF: Race condition between router admin quota update and periodic quota update service. Contributed by Jinglun.\n",
      "commitDate": "04/12/19 2:19 AM",
      "commitName": "47fdae79041ba2bb036ef7723a93ade5b1ac3619",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "29/11/19 10:25 AM",
      "commitNameOld": "6b2d6d4aafb110bef1b77d4ccbba4350e624b57d",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 4.66,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,51 @@\n   public GetMountTableEntriesResponse getMountTableEntries(\n       GetMountTableEntriesRequest request) throws IOException {\n     RouterPermissionChecker pc \u003d\n         RouterAdminServer.getPermissionChecker();\n     // Get all values from the cache\n     List\u003cMountTable\u003e records \u003d getCachedRecords();\n \n     // Sort and filter\n     Collections.sort(records, MountTable.SOURCE_COMPARATOR);\n     String reqSrcPath \u003d request.getSrcPath();\n     if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n       // Return only entries beneath this path\n       Iterator\u003cMountTable\u003e it \u003d records.iterator();\n       while (it.hasNext()) {\n         MountTable record \u003d it.next();\n         String srcPath \u003d record.getSourcePath();\n         if (!isParentEntry(srcPath, reqSrcPath)) {\n           it.remove();\n         } else if (pc !\u003d null) {\n           // do the READ permission check\n           try {\n             pc.checkPermission(record, FsAction.READ);\n           } catch (AccessControlException ignored) {\n             // Remove this mount table entry if it cannot\n             // be accessed by current user.\n             it.remove();\n           }\n         }\n+        // If quota manager is not null, update quota usage from quota cache.\n+        if (this.getQuotaManager() !\u003d null) {\n+          RouterQuotaUsage quota \u003d\n+              this.getQuotaManager().getQuotaUsage(record.getSourcePath());\n+          if (quota !\u003d null) {\n+            RouterQuotaUsage oldquota \u003d record.getQuota();\n+            RouterQuotaUsage newQuota \u003d new RouterQuotaUsage.Builder()\n+                .fileAndDirectoryCount(quota.getFileAndDirectoryCount())\n+                .quota(oldquota.getQuota())\n+                .spaceConsumed(quota.getSpaceConsumed())\n+                .spaceQuota(oldquota.getSpaceQuota()).build();\n+            record.setQuota(newQuota);\n+          }\n+        }\n       }\n     }\n \n     GetMountTableEntriesResponse response \u003d\n         GetMountTableEntriesResponse.newInstance();\n     response.setEntries(records);\n     response.setTimestamp(Time.now());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetMountTableEntriesResponse getMountTableEntries(\n      GetMountTableEntriesRequest request) throws IOException {\n    RouterPermissionChecker pc \u003d\n        RouterAdminServer.getPermissionChecker();\n    // Get all values from the cache\n    List\u003cMountTable\u003e records \u003d getCachedRecords();\n\n    // Sort and filter\n    Collections.sort(records, MountTable.SOURCE_COMPARATOR);\n    String reqSrcPath \u003d request.getSrcPath();\n    if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n      // Return only entries beneath this path\n      Iterator\u003cMountTable\u003e it \u003d records.iterator();\n      while (it.hasNext()) {\n        MountTable record \u003d it.next();\n        String srcPath \u003d record.getSourcePath();\n        if (!isParentEntry(srcPath, reqSrcPath)) {\n          it.remove();\n        } else if (pc !\u003d null) {\n          // do the READ permission check\n          try {\n            pc.checkPermission(record, FsAction.READ);\n          } catch (AccessControlException ignored) {\n            // Remove this mount table entry if it cannot\n            // be accessed by current user.\n            it.remove();\n          }\n        }\n        // If quota manager is not null, update quota usage from quota cache.\n        if (this.getQuotaManager() !\u003d null) {\n          RouterQuotaUsage quota \u003d\n              this.getQuotaManager().getQuotaUsage(record.getSourcePath());\n          if (quota !\u003d null) {\n            RouterQuotaUsage oldquota \u003d record.getQuota();\n            RouterQuotaUsage newQuota \u003d new RouterQuotaUsage.Builder()\n                .fileAndDirectoryCount(quota.getFileAndDirectoryCount())\n                .quota(oldquota.getQuota())\n                .spaceConsumed(quota.getSpaceConsumed())\n                .spaceQuota(oldquota.getSpaceQuota()).build();\n            record.setQuota(newQuota);\n          }\n        }\n      }\n    }\n\n    GetMountTableEntriesResponse response \u003d\n        GetMountTableEntriesResponse.newInstance();\n    response.setEntries(records);\n    response.setTimestamp(Time.now());\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/impl/MountTableStoreImpl.java",
      "extendedDetails": {}
    },
    "6b2d6d4aafb110bef1b77d4ccbba4350e624b57d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15009. FSCK -list-corruptfileblocks return Invalid Entries. Contributed by hemanthboyina.\n",
      "commitDate": "29/11/19 10:25 AM",
      "commitName": "6b2d6d4aafb110bef1b77d4ccbba4350e624b57d",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "23/08/19 2:53 PM",
      "commitNameOld": "0b796754b9d746c0389782f1a5e3ee9ef673e54c",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 97.86,
      "commitsBetweenForRepo": 595,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   public GetMountTableEntriesResponse getMountTableEntries(\n       GetMountTableEntriesRequest request) throws IOException {\n     RouterPermissionChecker pc \u003d\n         RouterAdminServer.getPermissionChecker();\n     // Get all values from the cache\n     List\u003cMountTable\u003e records \u003d getCachedRecords();\n \n     // Sort and filter\n     Collections.sort(records, MountTable.SOURCE_COMPARATOR);\n     String reqSrcPath \u003d request.getSrcPath();\n     if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n       // Return only entries beneath this path\n       Iterator\u003cMountTable\u003e it \u003d records.iterator();\n       while (it.hasNext()) {\n         MountTable record \u003d it.next();\n         String srcPath \u003d record.getSourcePath();\n-        if (!FederationUtil.isParentEntry(srcPath, reqSrcPath)) {\n+        if (!isParentEntry(srcPath, reqSrcPath)) {\n           it.remove();\n         } else if (pc !\u003d null) {\n           // do the READ permission check\n           try {\n             pc.checkPermission(record, FsAction.READ);\n           } catch (AccessControlException ignored) {\n             // Remove this mount table entry if it cannot\n             // be accessed by current user.\n             it.remove();\n           }\n         }\n       }\n     }\n \n     GetMountTableEntriesResponse response \u003d\n         GetMountTableEntriesResponse.newInstance();\n     response.setEntries(records);\n     response.setTimestamp(Time.now());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetMountTableEntriesResponse getMountTableEntries(\n      GetMountTableEntriesRequest request) throws IOException {\n    RouterPermissionChecker pc \u003d\n        RouterAdminServer.getPermissionChecker();\n    // Get all values from the cache\n    List\u003cMountTable\u003e records \u003d getCachedRecords();\n\n    // Sort and filter\n    Collections.sort(records, MountTable.SOURCE_COMPARATOR);\n    String reqSrcPath \u003d request.getSrcPath();\n    if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n      // Return only entries beneath this path\n      Iterator\u003cMountTable\u003e it \u003d records.iterator();\n      while (it.hasNext()) {\n        MountTable record \u003d it.next();\n        String srcPath \u003d record.getSourcePath();\n        if (!isParentEntry(srcPath, reqSrcPath)) {\n          it.remove();\n        } else if (pc !\u003d null) {\n          // do the READ permission check\n          try {\n            pc.checkPermission(record, FsAction.READ);\n          } catch (AccessControlException ignored) {\n            // Remove this mount table entry if it cannot\n            // be accessed by current user.\n            it.remove();\n          }\n        }\n      }\n    }\n\n    GetMountTableEntriesResponse response \u003d\n        GetMountTableEntriesResponse.newInstance();\n    response.setEntries(records);\n    response.setTimestamp(Time.now());\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/impl/MountTableStoreImpl.java",
      "extendedDetails": {}
    },
    "0b796754b9d746c0389782f1a5e3ee9ef673e54c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14766. RBF: MountTableStoreImpl#getMountTableEntries returns extra entry. Contributed by Chen Zhang.\n",
      "commitDate": "23/08/19 2:53 PM",
      "commitName": "0b796754b9d746c0389782f1a5e3ee9ef673e54c",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "6c42d4050461ab71c88f123569649793dc53aebd",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 60.22,
      "commitsBetweenForRepo": 517,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   public GetMountTableEntriesResponse getMountTableEntries(\n       GetMountTableEntriesRequest request) throws IOException {\n     RouterPermissionChecker pc \u003d\n         RouterAdminServer.getPermissionChecker();\n     // Get all values from the cache\n     List\u003cMountTable\u003e records \u003d getCachedRecords();\n \n     // Sort and filter\n     Collections.sort(records, MountTable.SOURCE_COMPARATOR);\n     String reqSrcPath \u003d request.getSrcPath();\n     if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n       // Return only entries beneath this path\n       Iterator\u003cMountTable\u003e it \u003d records.iterator();\n       while (it.hasNext()) {\n         MountTable record \u003d it.next();\n         String srcPath \u003d record.getSourcePath();\n-        if (!srcPath.startsWith(reqSrcPath)) {\n+        if (!FederationUtil.isParentEntry(srcPath, reqSrcPath)) {\n           it.remove();\n         } else if (pc !\u003d null) {\n           // do the READ permission check\n           try {\n             pc.checkPermission(record, FsAction.READ);\n           } catch (AccessControlException ignored) {\n             // Remove this mount table entry if it cannot\n             // be accessed by current user.\n             it.remove();\n           }\n         }\n       }\n     }\n \n     GetMountTableEntriesResponse response \u003d\n         GetMountTableEntriesResponse.newInstance();\n     response.setEntries(records);\n     response.setTimestamp(Time.now());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetMountTableEntriesResponse getMountTableEntries(\n      GetMountTableEntriesRequest request) throws IOException {\n    RouterPermissionChecker pc \u003d\n        RouterAdminServer.getPermissionChecker();\n    // Get all values from the cache\n    List\u003cMountTable\u003e records \u003d getCachedRecords();\n\n    // Sort and filter\n    Collections.sort(records, MountTable.SOURCE_COMPARATOR);\n    String reqSrcPath \u003d request.getSrcPath();\n    if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n      // Return only entries beneath this path\n      Iterator\u003cMountTable\u003e it \u003d records.iterator();\n      while (it.hasNext()) {\n        MountTable record \u003d it.next();\n        String srcPath \u003d record.getSourcePath();\n        if (!FederationUtil.isParentEntry(srcPath, reqSrcPath)) {\n          it.remove();\n        } else if (pc !\u003d null) {\n          // do the READ permission check\n          try {\n            pc.checkPermission(record, FsAction.READ);\n          } catch (AccessControlException ignored) {\n            // Remove this mount table entry if it cannot\n            // be accessed by current user.\n            it.remove();\n          }\n        }\n      }\n    }\n\n    GetMountTableEntriesResponse response \u003d\n        GetMountTableEntriesResponse.newInstance();\n    response.setEntries(records);\n    response.setTimestamp(Time.now());\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/impl/MountTableStoreImpl.java",
      "extendedDetails": {}
    },
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-13215. RBF: Move Router to its own module. Contributed by Wei Yan\n",
      "commitDate": "19/03/18 10:13 PM",
      "commitName": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
      "commitAuthor": "weiy",
      "commitDateOld": "19/03/18 5:19 PM",
      "commitNameOld": "e65ff1c8be48ef4f04ed96f96ac4caef4974944d",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public GetMountTableEntriesResponse getMountTableEntries(\n      GetMountTableEntriesRequest request) throws IOException {\n    RouterPermissionChecker pc \u003d\n        RouterAdminServer.getPermissionChecker();\n    // Get all values from the cache\n    List\u003cMountTable\u003e records \u003d getCachedRecords();\n\n    // Sort and filter\n    Collections.sort(records, MountTable.SOURCE_COMPARATOR);\n    String reqSrcPath \u003d request.getSrcPath();\n    if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n      // Return only entries beneath this path\n      Iterator\u003cMountTable\u003e it \u003d records.iterator();\n      while (it.hasNext()) {\n        MountTable record \u003d it.next();\n        String srcPath \u003d record.getSourcePath();\n        if (!srcPath.startsWith(reqSrcPath)) {\n          it.remove();\n        } else if (pc !\u003d null) {\n          // do the READ permission check\n          try {\n            pc.checkPermission(record, FsAction.READ);\n          } catch (AccessControlException ignored) {\n            // Remove this mount table entry if it cannot\n            // be accessed by current user.\n            it.remove();\n          }\n        }\n      }\n    }\n\n    GetMountTableEntriesResponse response \u003d\n        GetMountTableEntriesResponse.newInstance();\n    response.setEntries(records);\n    response.setTimestamp(Time.now());\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/impl/MountTableStoreImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/impl/MountTableStoreImpl.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/impl/MountTableStoreImpl.java"
      }
    },
    "ee028bfdf1c88a27cd925bed93ebb599a164dd2e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12895. RBF: Add ACL support for mount table. Contributed by Yiqun Lin.\n",
      "commitDate": "14/12/17 10:09 PM",
      "commitName": "ee028bfdf1c88a27cd925bed93ebb599a164dd2e",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "06/10/17 6:50 PM",
      "commitNameOld": "6f0de2731806628b5b01bd1350225692147590da",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 69.18,
      "commitsBetweenForRepo": 527,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,37 @@\n   public GetMountTableEntriesResponse getMountTableEntries(\n       GetMountTableEntriesRequest request) throws IOException {\n-\n+    RouterPermissionChecker pc \u003d\n+        RouterAdminServer.getPermissionChecker();\n     // Get all values from the cache\n     List\u003cMountTable\u003e records \u003d getCachedRecords();\n \n     // Sort and filter\n-    Collections.sort(records);\n+    Collections.sort(records, MountTable.SOURCE_COMPARATOR);\n     String reqSrcPath \u003d request.getSrcPath();\n     if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n       // Return only entries beneath this path\n       Iterator\u003cMountTable\u003e it \u003d records.iterator();\n       while (it.hasNext()) {\n         MountTable record \u003d it.next();\n         String srcPath \u003d record.getSourcePath();\n         if (!srcPath.startsWith(reqSrcPath)) {\n           it.remove();\n+        } else if (pc !\u003d null) {\n+          // do the READ permission check\n+          try {\n+            pc.checkPermission(record, FsAction.READ);\n+          } catch (AccessControlException ignored) {\n+            // Remove this mount table entry if it cannot\n+            // be accessed by current user.\n+            it.remove();\n+          }\n         }\n       }\n     }\n \n     GetMountTableEntriesResponse response \u003d\n         GetMountTableEntriesResponse.newInstance();\n     response.setEntries(records);\n     response.setTimestamp(Time.now());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public GetMountTableEntriesResponse getMountTableEntries(\n      GetMountTableEntriesRequest request) throws IOException {\n    RouterPermissionChecker pc \u003d\n        RouterAdminServer.getPermissionChecker();\n    // Get all values from the cache\n    List\u003cMountTable\u003e records \u003d getCachedRecords();\n\n    // Sort and filter\n    Collections.sort(records, MountTable.SOURCE_COMPARATOR);\n    String reqSrcPath \u003d request.getSrcPath();\n    if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n      // Return only entries beneath this path\n      Iterator\u003cMountTable\u003e it \u003d records.iterator();\n      while (it.hasNext()) {\n        MountTable record \u003d it.next();\n        String srcPath \u003d record.getSourcePath();\n        if (!srcPath.startsWith(reqSrcPath)) {\n          it.remove();\n        } else if (pc !\u003d null) {\n          // do the READ permission check\n          try {\n            pc.checkPermission(record, FsAction.READ);\n          } catch (AccessControlException ignored) {\n            // Remove this mount table entry if it cannot\n            // be accessed by current user.\n            it.remove();\n          }\n        }\n      }\n    }\n\n    GetMountTableEntriesResponse response \u003d\n        GetMountTableEntriesResponse.newInstance();\n    response.setEntries(records);\n    response.setTimestamp(Time.now());\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/impl/MountTableStoreImpl.java",
      "extendedDetails": {}
    },
    "6f0de2731806628b5b01bd1350225692147590da": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10880. Federation Mount Table State Store internal API. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 58b97df661441150d35abd44b3a8606206b46441)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "6f0de2731806628b5b01bd1350225692147590da",
      "commitAuthor": "Inigo Goiri",
      "diff": "@@ -0,0 +1,27 @@\n+  public GetMountTableEntriesResponse getMountTableEntries(\n+      GetMountTableEntriesRequest request) throws IOException {\n+\n+    // Get all values from the cache\n+    List\u003cMountTable\u003e records \u003d getCachedRecords();\n+\n+    // Sort and filter\n+    Collections.sort(records);\n+    String reqSrcPath \u003d request.getSrcPath();\n+    if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n+      // Return only entries beneath this path\n+      Iterator\u003cMountTable\u003e it \u003d records.iterator();\n+      while (it.hasNext()) {\n+        MountTable record \u003d it.next();\n+        String srcPath \u003d record.getSourcePath();\n+        if (!srcPath.startsWith(reqSrcPath)) {\n+          it.remove();\n+        }\n+      }\n+    }\n+\n+    GetMountTableEntriesResponse response \u003d\n+        GetMountTableEntriesResponse.newInstance();\n+    response.setEntries(records);\n+    response.setTimestamp(Time.now());\n+    return response;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public GetMountTableEntriesResponse getMountTableEntries(\n      GetMountTableEntriesRequest request) throws IOException {\n\n    // Get all values from the cache\n    List\u003cMountTable\u003e records \u003d getCachedRecords();\n\n    // Sort and filter\n    Collections.sort(records);\n    String reqSrcPath \u003d request.getSrcPath();\n    if (reqSrcPath !\u003d null \u0026\u0026 !reqSrcPath.isEmpty()) {\n      // Return only entries beneath this path\n      Iterator\u003cMountTable\u003e it \u003d records.iterator();\n      while (it.hasNext()) {\n        MountTable record \u003d it.next();\n        String srcPath \u003d record.getSourcePath();\n        if (!srcPath.startsWith(reqSrcPath)) {\n          it.remove();\n        }\n      }\n    }\n\n    GetMountTableEntriesResponse response \u003d\n        GetMountTableEntriesResponse.newInstance();\n    response.setEntries(records);\n    response.setTimestamp(Time.now());\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/impl/MountTableStoreImpl.java"
    }
  }
}