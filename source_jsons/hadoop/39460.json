{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractCSQueue.java",
  "functionName": "setupQueueConfigs",
  "functionId": "setupQueueConfigs___clusterResource-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
  "functionStartLine": 347,
  "functionEndLine": 350,
  "numCommitsSeen": 100,
  "timeTaken": 9417,
  "changeHistory": [
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
    "5e798b1a0ddceeaf54703b94052501867156e979",
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
    "0e065f2edead41f6f894c9d70def389af1c0f239",
    "ce832059db077fa95922198b066a737ed4f609fe",
    "0840b4329b2428b20b862f70d72cbdcd6d1618ed",
    "f885160f4ac56a0999e3b051eb7bccce928c1c33",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
    "f489a4ec969f3727d03c8e85d51af1018fc0b2a1",
    "d573f09fb93dbb711d504620af5d73840ea063a6",
    "14dd647c556016d351f425ee956ccf800ccb9ce2",
    "18a594257e052e8f10a03e5594e6cc6901dc56be",
    "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
    "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
    "18741adf97f4fda5f8743318b59c440928e51297",
    "dd57c2047bfd21910acc38c98153eedf1db75169",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1"
  ],
  "changeHistoryShort": {
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Ybodychange",
    "5e798b1a0ddceeaf54703b94052501867156e979": "Ybodychange",
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35": "Ybodychange",
    "0e065f2edead41f6f894c9d70def389af1c0f239": "Ybodychange",
    "ce832059db077fa95922198b066a737ed4f609fe": "Ybodychange",
    "0840b4329b2428b20b862f70d72cbdcd6d1618ed": "Ybodychange",
    "f885160f4ac56a0999e3b051eb7bccce928c1c33": "Ybodychange",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": "Ymultichange(Ymodifierchange,Ybodychange)",
    "f489a4ec969f3727d03c8e85d51af1018fc0b2a1": "Ybodychange",
    "d573f09fb93dbb711d504620af5d73840ea063a6": "Ybodychange",
    "14dd647c556016d351f425ee956ccf800ccb9ce2": "Ybodychange",
    "18a594257e052e8f10a03e5594e6cc6901dc56be": "Ymultichange(Yparameterchange,Ybodychange)",
    "23bf6c72071782e3fd5a628e21495d6b974c7a9e": "Yparameterchange",
    "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628": "Ymultichange(Yparameterchange,Ybodychange)",
    "18741adf97f4fda5f8743318b59c440928e51297": "Ybodychange",
    "dd57c2047bfd21910acc38c98153eedf1db75169": "Ybodychange",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.84,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,4 @@\n   void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n-    try {\n-      writeLock.lock();\n-      // get labels\n-      this.accessibleLabels \u003d\n-          csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n-      this.defaultLabelExpression \u003d\n-          csContext.getConfiguration().getDefaultNodeLabelExpression(\n-              getQueuePath());\n-      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n-      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n-        resourceTypes.add(type.toString().toLowerCase());\n-      }\n-\n-      // inherit from parent if labels not set\n-      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n-        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n-      }\n-\n-      // inherit from parent if labels not set\n-      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n-          \u0026\u0026 this.accessibleLabels.containsAll(\n-          parent.getAccessibleNodeLabels())) {\n-        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n-      }\n-\n-      // After we setup labels, we can setup capacities\n-      setupConfigurableCapacities();\n-\n-      // Also fetch minimum/maximum resource constraint for this queue if\n-      // configured.\n-      capacityConfigType \u003d CapacityConfigType.NONE;\n-      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n-\n-      this.maximumAllocation \u003d\n-          csContext.getConfiguration().getMaximumAllocationPerQueue(\n-              getQueuePath());\n-\n-      // initialized the queue state based on previous state, configured state\n-      // and its parent state.\n-      QueueState previous \u003d getState();\n-      QueueState configuredState \u003d csContext.getConfiguration()\n-          .getConfiguredState(getQueuePath());\n-      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n-      initializeQueueState(previous, configuredState, parentState);\n-\n-      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n-\n-      this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n-\n-      // Update metrics\n-      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n-          this, labelManager, null);\n-\n-      // Check if labels of this queue is a subset of parent queue, only do this\n-      // when we not root\n-      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n-        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n-            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n-          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n-          if (this.getAccessibleNodeLabels().contains(\n-              RMNodeLabelsManager.ANY)) {\n-            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n-                + \"but child\u0027s accessible queue is *\");\n-          } else{\n-            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n-                parent.getAccessibleNodeLabels());\n-            if (!diff.isEmpty()) {\n-              throw new IOException(\n-                  \"Some labels of child queue is not a subset \"\n-                      + \"of parent queue, these labels\u003d[\" + StringUtils\n-                      .join(diff, \",\") + \"]\");\n-            }\n-          }\n-        }\n-      }\n-\n-      this.reservationsContinueLooking \u003d\n-          csContext.getConfiguration().getReservationContinueLook();\n-\n-      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n-\n-      this.priority \u003d csContext.getConfiguration().getQueuePriority(\n-          getQueuePath());\n-\n-      this.userWeights \u003d getUserWeightsFromHierarchy();\n-    } finally {\n-      writeLock.unlock();\n-    }\n+    setupQueueConfigs(clusterResource, csContext.getConfiguration());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    setupQueueConfigs(clusterResource, csContext.getConfiguration());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "5e798b1a0ddceeaf54703b94052501867156e979": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/11/17 11:25 AM",
      "commitNameOld": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 21.31,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,91 @@\n   void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           csContext.getConfiguration().getDefaultNodeLabelExpression(\n               getQueuePath());\n+      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n+      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n+        resourceTypes.add(type.toString().toLowerCase());\n+      }\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities();\n \n+      // Also fetch minimum/maximum resource constraint for this queue if\n+      // configured.\n+      capacityConfigType \u003d CapacityConfigType.NONE;\n+      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n+\n       this.maximumAllocation \u003d\n           csContext.getConfiguration().getMaximumAllocationPerQueue(\n               getQueuePath());\n \n       // initialized the queue state based on previous state, configured state\n       // and its parent state.\n       QueueState previous \u003d getState();\n       QueueState configuredState \u003d csContext.getConfiguration()\n           .getConfiguredState(getQueuePath());\n       QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n       initializeQueueState(previous, configuredState, parentState);\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n \n       this.priority \u003d csContext.getConfiguration().getQueuePriority(\n           getQueuePath());\n \n       this.userWeights \u003d getUserWeightsFromHierarchy();\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          csContext.getConfiguration().getDefaultNodeLabelExpression(\n              getQueuePath());\n      this.resourceTypes \u003d new HashSet\u003cString\u003e();\n      for (AbsoluteResourceType type : AbsoluteResourceType.values()) {\n        resourceTypes.add(type.toString().toLowerCase());\n      }\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities();\n\n      // Also fetch minimum/maximum resource constraint for this queue if\n      // configured.\n      capacityConfigType \u003d CapacityConfigType.NONE;\n      updateConfigurableResourceRequirement(getQueuePath(), clusterResource);\n\n      this.maximumAllocation \u003d\n          csContext.getConfiguration().getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d csContext.getConfiguration()\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n\n      this.priority \u003d csContext.getConfiguration().getQueuePriority(\n          getQueuePath());\n\n      this.userWeights \u003d getUserWeightsFromHierarchy();\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5892. Support user-specific minimum user limit percentage in Capacity Scheduler. Contributed by Eric Payne.\n",
      "commitDate": "22/06/17 11:50 PM",
      "commitName": "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
      "commitAuthor": "Sunil G",
      "commitDateOld": "19/04/17 8:09 AM",
      "commitNameOld": "9ff25408bc096dfc0a8522106eec54282303c7ab",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 64.65,
      "commitsBetweenForRepo": 337,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,82 @@\n   void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           csContext.getConfiguration().getDefaultNodeLabelExpression(\n               getQueuePath());\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities();\n \n       this.maximumAllocation \u003d\n           csContext.getConfiguration().getMaximumAllocationPerQueue(\n               getQueuePath());\n \n       // initialized the queue state based on previous state, configured state\n       // and its parent state.\n       QueueState previous \u003d getState();\n       QueueState configuredState \u003d csContext.getConfiguration()\n           .getConfiguredState(getQueuePath());\n       QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n       initializeQueueState(previous, configuredState, parentState);\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n \n       this.priority \u003d csContext.getConfiguration().getQueuePriority(\n           getQueuePath());\n+\n+      this.userWeights \u003d getUserWeightsFromHierarchy();\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          csContext.getConfiguration().getDefaultNodeLabelExpression(\n              getQueuePath());\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities();\n\n      this.maximumAllocation \u003d\n          csContext.getConfiguration().getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d csContext.getConfiguration()\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n\n      this.priority \u003d csContext.getConfiguration().getQueuePriority(\n          getQueuePath());\n\n      this.userWeights \u003d getUserWeightsFromHierarchy();\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "0e065f2edead41f6f894c9d70def389af1c0f239": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6195. Export UsedCapacity and AbsoluteUsedCapacity to JMX. Contributed by Benson Qiu\n",
      "commitDate": "11/04/17 6:44 AM",
      "commitName": "0e065f2edead41f6f894c9d70def389af1c0f239",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "28/02/17 10:35 AM",
      "commitNameOld": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 41.8,
      "commitsBetweenForRepo": 257,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n   void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           csContext.getConfiguration().getDefaultNodeLabelExpression(\n               getQueuePath());\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities();\n \n       this.maximumAllocation \u003d\n           csContext.getConfiguration().getMaximumAllocationPerQueue(\n               getQueuePath());\n \n       // initialized the queue state based on previous state, configured state\n       // and its parent state.\n       QueueState previous \u003d getState();\n       QueueState configuredState \u003d csContext.getConfiguration()\n           .getConfiguredState(getQueuePath());\n       QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n       initializeQueueState(previous, configuredState, parentState);\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n-          minimumAllocation, this, labelManager, null);\n+          this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n \n       this.priority \u003d csContext.getConfiguration().getQueuePriority(\n           getQueuePath());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          csContext.getConfiguration().getDefaultNodeLabelExpression(\n              getQueuePath());\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities();\n\n      this.maximumAllocation \u003d\n          csContext.getConfiguration().getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d csContext.getConfiguration()\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n\n      this.priority \u003d csContext.getConfiguration().getQueuePriority(\n          getQueuePath());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "ce832059db077fa95922198b066a737ed4f609fe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
      "commitDate": "23/01/17 10:52 AM",
      "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "10/01/17 12:38 AM",
      "commitNameOld": "9594c35dcb655add1991d8fd15897b40c4ad6205",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 13.43,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,80 @@\n   void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           csContext.getConfiguration().getDefaultNodeLabelExpression(\n               getQueuePath());\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities();\n \n       this.maximumAllocation \u003d\n           csContext.getConfiguration().getMaximumAllocationPerQueue(\n               getQueuePath());\n \n       // initialized the queue state based on previous state, configured state\n       // and its parent state.\n       QueueState previous \u003d getState();\n       QueueState configuredState \u003d csContext.getConfiguration()\n           .getConfiguredState(getQueuePath());\n       QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n       initializeQueueState(previous, configuredState, parentState);\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           minimumAllocation, this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n+\n+      this.priority \u003d csContext.getConfiguration().getQueuePriority(\n+          getQueuePath());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          csContext.getConfiguration().getDefaultNodeLabelExpression(\n              getQueuePath());\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities();\n\n      this.maximumAllocation \u003d\n          csContext.getConfiguration().getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d csContext.getConfiguration()\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          minimumAllocation, this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n\n      this.priority \u003d csContext.getConfiguration().getQueuePriority(\n          getQueuePath());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "0840b4329b2428b20b862f70d72cbdcd6d1618ed": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5756. Add state-machine implementation for scheduler queues. (Xuan Gong via wangda)\n",
      "commitDate": "27/12/16 9:18 PM",
      "commitName": "0840b4329b2428b20b862f70d72cbdcd6d1618ed",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "06/12/16 9:09 PM",
      "commitNameOld": "563480dccd0136d82730f4228f1df44449ed5822",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 21.01,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,77 @@\n   void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           csContext.getConfiguration().getDefaultNodeLabelExpression(\n               getQueuePath());\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities();\n \n       this.maximumAllocation \u003d\n           csContext.getConfiguration().getMaximumAllocationPerQueue(\n               getQueuePath());\n \n-      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n+      // initialized the queue state based on previous state, configured state\n+      // and its parent state.\n+      QueueState previous \u003d getState();\n+      QueueState configuredState \u003d csContext.getConfiguration()\n+          .getConfiguredState(getQueuePath());\n+      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n+      initializeQueueState(previous, configuredState, parentState);\n \n-      initializeQueueState();\n+      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n       this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           minimumAllocation, this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          csContext.getConfiguration().getDefaultNodeLabelExpression(\n              getQueuePath());\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities();\n\n      this.maximumAllocation \u003d\n          csContext.getConfiguration().getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      // initialized the queue state based on previous state, configured state\n      // and its parent state.\n      QueueState previous \u003d getState();\n      QueueState configuredState \u003d csContext.getConfiguration()\n          .getConfiguredState(getQueuePath());\n      QueueState parentState \u003d (parent \u003d\u003d null) ? null : parent.getState();\n      initializeQueueState(previous, configuredState, parentState);\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          minimumAllocation, this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "f885160f4ac56a0999e3b051eb7bccce928c1c33": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5746. The state of the parentQueue and its childQueues should be synchronized. Contributed by Xuan Gong\n",
      "commitDate": "02/12/16 4:17 PM",
      "commitName": "f885160f4ac56a0999e3b051eb7bccce928c1c33",
      "commitAuthor": "Jian He",
      "commitDateOld": "11/11/16 3:16 PM",
      "commitNameOld": "fad9609d13e76e9e3a4e01c96f698bb60b03807e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 21.04,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,71 @@\n   void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       // get labels\n       this.accessibleLabels \u003d\n           csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n       this.defaultLabelExpression \u003d\n           csContext.getConfiguration().getDefaultNodeLabelExpression(\n               getQueuePath());\n \n       // inherit from parent if labels not set\n       if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n         this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n       }\n \n       // inherit from parent if labels not set\n       if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n           \u0026\u0026 this.accessibleLabels.containsAll(\n           parent.getAccessibleNodeLabels())) {\n         this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n       }\n \n       // After we setup labels, we can setup capacities\n       setupConfigurableCapacities();\n \n       this.maximumAllocation \u003d\n           csContext.getConfiguration().getMaximumAllocationPerQueue(\n               getQueuePath());\n \n       authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n \n-      this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n+      initializeQueueState();\n+\n       this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n \n       // Update metrics\n       CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n           minimumAllocation, this, labelManager, null);\n \n       // Check if labels of this queue is a subset of parent queue, only do this\n       // when we not root\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n         if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n             .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n           if (this.getAccessibleNodeLabels().contains(\n               RMNodeLabelsManager.ANY)) {\n             throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                 + \"but child\u0027s accessible queue is *\");\n           } else{\n             Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                 parent.getAccessibleNodeLabels());\n             if (!diff.isEmpty()) {\n               throw new IOException(\n                   \"Some labels of child queue is not a subset \"\n                       + \"of parent queue, these labels\u003d[\" + StringUtils\n                       .join(diff, \",\") + \"]\");\n             }\n           }\n         }\n       }\n \n       this.reservationsContinueLooking \u003d\n           csContext.getConfiguration().getReservationContinueLook();\n \n       this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          csContext.getConfiguration().getDefaultNodeLabelExpression(\n              getQueuePath());\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities();\n\n      this.maximumAllocation \u003d\n          csContext.getConfiguration().getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      initializeQueueState();\n\n      this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          minimumAllocation, this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
      "commitDate": "20/09/16 12:03 AM",
      "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "05/08/16 10:27 AM",
          "commitNameOld": "e0d131f055ee126052ad4d0f7b0d192e6c730188",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 45.57,
          "commitsBetweenForRepo": 270,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,70 @@\n-  synchronized void setupQueueConfigs(Resource clusterResource)\n+  void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n-    // get labels\n-    this.accessibleLabels \u003d\n-        csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n-    this.defaultLabelExpression \u003d csContext.getConfiguration()\n-        .getDefaultNodeLabelExpression(getQueuePath());\n+    try {\n+      writeLock.lock();\n+      // get labels\n+      this.accessibleLabels \u003d\n+          csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n+      this.defaultLabelExpression \u003d\n+          csContext.getConfiguration().getDefaultNodeLabelExpression(\n+              getQueuePath());\n \n-    // inherit from parent if labels not set\n-    if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n-      this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n-    }\n-    \n-    // inherit from parent if labels not set\n-    if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n-        \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n-      this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n-    }\n+      // inherit from parent if labels not set\n+      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n+        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n+      }\n \n-    // After we setup labels, we can setup capacities\n-    setupConfigurableCapacities();\n-    \n-    this.maximumAllocation \u003d\n-        csContext.getConfiguration().getMaximumAllocationPerQueue(\n-            getQueuePath());\n-    \n-    authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n-    \n-    this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n-    this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n+      // inherit from parent if labels not set\n+      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n+          \u0026\u0026 this.accessibleLabels.containsAll(\n+          parent.getAccessibleNodeLabels())) {\n+        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n+      }\n \n-    // Update metrics\n-    CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n-        minimumAllocation, this, labelManager, null);\n-    \n-    // Check if labels of this queue is a subset of parent queue, only do this\n-    // when we not root\n-    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n-      if (parent.getAccessibleNodeLabels() !\u003d null\n-          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n-        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n-        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n-          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n-              + \"but child\u0027s accessible queue is *\");\n-        } else {\n-          Set\u003cString\u003e diff \u003d\n-              Sets.difference(this.getAccessibleNodeLabels(),\n-                  parent.getAccessibleNodeLabels());\n-          if (!diff.isEmpty()) {\n-            throw new IOException(\"Some labels of child queue is not a subset \"\n-                + \"of parent queue, these labels\u003d[\"\n-                + StringUtils.join(diff, \",\") + \"]\");\n+      // After we setup labels, we can setup capacities\n+      setupConfigurableCapacities();\n+\n+      this.maximumAllocation \u003d\n+          csContext.getConfiguration().getMaximumAllocationPerQueue(\n+              getQueuePath());\n+\n+      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n+\n+      this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n+      this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n+\n+      // Update metrics\n+      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n+          minimumAllocation, this, labelManager, null);\n+\n+      // Check if labels of this queue is a subset of parent queue, only do this\n+      // when we not root\n+      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n+        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n+            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n+          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n+          if (this.getAccessibleNodeLabels().contains(\n+              RMNodeLabelsManager.ANY)) {\n+            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n+                + \"but child\u0027s accessible queue is *\");\n+          } else{\n+            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n+                parent.getAccessibleNodeLabels());\n+            if (!diff.isEmpty()) {\n+              throw new IOException(\n+                  \"Some labels of child queue is not a subset \"\n+                      + \"of parent queue, these labels\u003d[\" + StringUtils\n+                      .join(diff, \",\") + \"]\");\n+            }\n           }\n         }\n       }\n+\n+      this.reservationsContinueLooking \u003d\n+          csContext.getConfiguration().getReservationContinueLook();\n+\n+      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    this.reservationsContinueLooking \u003d csContext.getConfiguration()\n-        .getReservationContinueLook();\n-\n-    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          csContext.getConfiguration().getDefaultNodeLabelExpression(\n              getQueuePath());\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities();\n\n      this.maximumAllocation \u003d\n          csContext.getConfiguration().getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n      this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          minimumAllocation, this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {
            "oldValue": "[synchronized]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "05/08/16 10:27 AM",
          "commitNameOld": "e0d131f055ee126052ad4d0f7b0d192e6c730188",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 45.57,
          "commitsBetweenForRepo": 270,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,70 @@\n-  synchronized void setupQueueConfigs(Resource clusterResource)\n+  void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n-    // get labels\n-    this.accessibleLabels \u003d\n-        csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n-    this.defaultLabelExpression \u003d csContext.getConfiguration()\n-        .getDefaultNodeLabelExpression(getQueuePath());\n+    try {\n+      writeLock.lock();\n+      // get labels\n+      this.accessibleLabels \u003d\n+          csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n+      this.defaultLabelExpression \u003d\n+          csContext.getConfiguration().getDefaultNodeLabelExpression(\n+              getQueuePath());\n \n-    // inherit from parent if labels not set\n-    if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n-      this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n-    }\n-    \n-    // inherit from parent if labels not set\n-    if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n-        \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n-      this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n-    }\n+      // inherit from parent if labels not set\n+      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n+        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n+      }\n \n-    // After we setup labels, we can setup capacities\n-    setupConfigurableCapacities();\n-    \n-    this.maximumAllocation \u003d\n-        csContext.getConfiguration().getMaximumAllocationPerQueue(\n-            getQueuePath());\n-    \n-    authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n-    \n-    this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n-    this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n+      // inherit from parent if labels not set\n+      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n+          \u0026\u0026 this.accessibleLabels.containsAll(\n+          parent.getAccessibleNodeLabels())) {\n+        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n+      }\n \n-    // Update metrics\n-    CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n-        minimumAllocation, this, labelManager, null);\n-    \n-    // Check if labels of this queue is a subset of parent queue, only do this\n-    // when we not root\n-    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n-      if (parent.getAccessibleNodeLabels() !\u003d null\n-          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n-        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n-        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n-          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n-              + \"but child\u0027s accessible queue is *\");\n-        } else {\n-          Set\u003cString\u003e diff \u003d\n-              Sets.difference(this.getAccessibleNodeLabels(),\n-                  parent.getAccessibleNodeLabels());\n-          if (!diff.isEmpty()) {\n-            throw new IOException(\"Some labels of child queue is not a subset \"\n-                + \"of parent queue, these labels\u003d[\"\n-                + StringUtils.join(diff, \",\") + \"]\");\n+      // After we setup labels, we can setup capacities\n+      setupConfigurableCapacities();\n+\n+      this.maximumAllocation \u003d\n+          csContext.getConfiguration().getMaximumAllocationPerQueue(\n+              getQueuePath());\n+\n+      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n+\n+      this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n+      this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n+\n+      // Update metrics\n+      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n+          minimumAllocation, this, labelManager, null);\n+\n+      // Check if labels of this queue is a subset of parent queue, only do this\n+      // when we not root\n+      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n+        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n+            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n+          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n+          if (this.getAccessibleNodeLabels().contains(\n+              RMNodeLabelsManager.ANY)) {\n+            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n+                + \"but child\u0027s accessible queue is *\");\n+          } else{\n+            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n+                parent.getAccessibleNodeLabels());\n+            if (!diff.isEmpty()) {\n+              throw new IOException(\n+                  \"Some labels of child queue is not a subset \"\n+                      + \"of parent queue, these labels\u003d[\" + StringUtils\n+                      .join(diff, \",\") + \"]\");\n+            }\n           }\n         }\n       }\n+\n+      this.reservationsContinueLooking \u003d\n+          csContext.getConfiguration().getReservationContinueLook();\n+\n+      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    this.reservationsContinueLooking \u003d csContext.getConfiguration()\n-        .getReservationContinueLook();\n-\n-    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      // get labels\n      this.accessibleLabels \u003d\n          csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n      this.defaultLabelExpression \u003d\n          csContext.getConfiguration().getDefaultNodeLabelExpression(\n              getQueuePath());\n\n      // inherit from parent if labels not set\n      if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n        this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n      }\n\n      // inherit from parent if labels not set\n      if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n          \u0026\u0026 this.accessibleLabels.containsAll(\n          parent.getAccessibleNodeLabels())) {\n        this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n      }\n\n      // After we setup labels, we can setup capacities\n      setupConfigurableCapacities();\n\n      this.maximumAllocation \u003d\n          csContext.getConfiguration().getMaximumAllocationPerQueue(\n              getQueuePath());\n\n      authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n\n      this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n      this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n      // Update metrics\n      CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n          minimumAllocation, this, labelManager, null);\n\n      // Check if labels of this queue is a subset of parent queue, only do this\n      // when we not root\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n        if (parent.getAccessibleNodeLabels() !\u003d null \u0026\u0026 !parent\n            .getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n          if (this.getAccessibleNodeLabels().contains(\n              RMNodeLabelsManager.ANY)) {\n            throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n                + \"but child\u0027s accessible queue is *\");\n          } else{\n            Set\u003cString\u003e diff \u003d Sets.difference(this.getAccessibleNodeLabels(),\n                parent.getAccessibleNodeLabels());\n            if (!diff.isEmpty()) {\n              throw new IOException(\n                  \"Some labels of child queue is not a subset \"\n                      + \"of parent queue, these labels\u003d[\" + StringUtils\n                      .join(diff, \",\") + \"]\");\n            }\n          }\n        }\n      }\n\n      this.reservationsContinueLooking \u003d\n          csContext.getConfiguration().getReservationContinueLook();\n\n      this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "f489a4ec969f3727d03c8e85d51af1018fc0b2a1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2918. RM should not fail on startup if queue\u0027s configured labels do not exist in cluster-node-labels. Contributed by Wangda Tan\n",
      "commitDate": "07/05/15 5:35 PM",
      "commitName": "f489a4ec969f3727d03c8e85d51af1018fc0b2a1",
      "commitAuthor": "Jian He",
      "commitDateOld": "23/04/15 7:39 AM",
      "commitNameOld": "189a63a719c63b67a1783a280bfc2f72dcb55277",
      "commitAuthorOld": "tgraves",
      "daysBetweenCommits": 14.41,
      "commitsBetweenForRepo": 145,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,62 @@\n   synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     // get labels\n     this.accessibleLabels \u003d\n         csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n     this.defaultLabelExpression \u003d csContext.getConfiguration()\n         .getDefaultNodeLabelExpression(getQueuePath());\n \n     // inherit from parent if labels not set\n     if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n       this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n     }\n-    SchedulerUtils.checkIfLabelInClusterNodeLabels(labelManager,\n-        this.accessibleLabels);\n     \n     // inherit from parent if labels not set\n     if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n         \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n       this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n     }\n \n     // After we setup labels, we can setup capacities\n     setupConfigurableCapacities();\n     \n     this.maximumAllocation \u003d\n         csContext.getConfiguration().getMaximumAllocationPerQueue(\n             getQueuePath());\n     \n     authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n     \n     this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n     this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n         minimumAllocation, this, labelManager, null);\n     \n     // Check if labels of this queue is a subset of parent queue, only do this\n     // when we not root\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n       if (parent.getAccessibleNodeLabels() !\u003d null\n           \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n         // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n         if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n               + \"but child\u0027s accessible queue is *\");\n         } else {\n           Set\u003cString\u003e diff \u003d\n               Sets.difference(this.getAccessibleNodeLabels(),\n                   parent.getAccessibleNodeLabels());\n           if (!diff.isEmpty()) {\n             throw new IOException(\"Some labels of child queue is not a subset \"\n                 + \"of parent queue, these labels\u003d[\"\n                 + StringUtils.join(diff, \",\") + \"]\");\n           }\n         }\n       }\n     }\n \n     this.reservationsContinueLooking \u003d csContext.getConfiguration()\n         .getReservationContinueLook();\n \n     this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    // get labels\n    this.accessibleLabels \u003d\n        csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n    this.defaultLabelExpression \u003d csContext.getConfiguration()\n        .getDefaultNodeLabelExpression(getQueuePath());\n\n    // inherit from parent if labels not set\n    if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n      this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n    }\n    \n    // inherit from parent if labels not set\n    if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n        \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n      this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n    }\n\n    // After we setup labels, we can setup capacities\n    setupConfigurableCapacities();\n    \n    this.maximumAllocation \u003d\n        csContext.getConfiguration().getMaximumAllocationPerQueue(\n            getQueuePath());\n    \n    authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n    \n    this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n    this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n        minimumAllocation, this, labelManager, null);\n    \n    // Check if labels of this queue is a subset of parent queue, only do this\n    // when we not root\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n      if (parent.getAccessibleNodeLabels() !\u003d null\n          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n              + \"but child\u0027s accessible queue is *\");\n        } else {\n          Set\u003cString\u003e diff \u003d\n              Sets.difference(this.getAccessibleNodeLabels(),\n                  parent.getAccessibleNodeLabels());\n          if (!diff.isEmpty()) {\n            throw new IOException(\"Some labels of child queue is not a subset \"\n                + \"of parent queue, these labels\u003d[\"\n                + StringUtils.join(diff, \",\") + \"]\");\n          }\n        }\n      }\n    }\n\n    this.reservationsContinueLooking \u003d csContext.getConfiguration()\n        .getReservationContinueLook();\n\n    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "d573f09fb93dbb711d504620af5d73840ea063a6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2696. Queue sorting in CapacityScheduler should consider node label. Contributed by Wangda Tan\n",
      "commitDate": "17/04/15 1:36 PM",
      "commitName": "d573f09fb93dbb711d504620af5d73840ea063a6",
      "commitAuthor": "Jian He",
      "commitDateOld": "14/04/15 11:45 AM",
      "commitNameOld": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 3.08,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     // get labels\n     this.accessibleLabels \u003d\n         csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n     this.defaultLabelExpression \u003d csContext.getConfiguration()\n         .getDefaultNodeLabelExpression(getQueuePath());\n \n     // inherit from parent if labels not set\n     if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n       this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n     }\n     SchedulerUtils.checkIfLabelInClusterNodeLabels(labelManager,\n         this.accessibleLabels);\n     \n     // inherit from parent if labels not set\n     if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n         \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n       this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n     }\n \n     // After we setup labels, we can setup capacities\n     setupConfigurableCapacities();\n     \n     this.maximumAllocation \u003d\n         csContext.getConfiguration().getMaximumAllocationPerQueue(\n             getQueuePath());\n     \n     authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n     \n     this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n     this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n \n     // Update metrics\n-    CSQueueUtils.updateQueueStatistics(\n-        resourceCalculator, this, parent, clusterResource, minimumAllocation);\n+    CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n+        minimumAllocation, this, labelManager, null);\n     \n     // Check if labels of this queue is a subset of parent queue, only do this\n     // when we not root\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n       if (parent.getAccessibleNodeLabels() !\u003d null\n           \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n         // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n         if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n               + \"but child\u0027s accessible queue is *\");\n         } else {\n           Set\u003cString\u003e diff \u003d\n               Sets.difference(this.getAccessibleNodeLabels(),\n                   parent.getAccessibleNodeLabels());\n           if (!diff.isEmpty()) {\n             throw new IOException(\"Some labels of child queue is not a subset \"\n                 + \"of parent queue, these labels\u003d[\"\n                 + StringUtils.join(diff, \",\") + \"]\");\n           }\n         }\n       }\n     }\n \n     this.reservationsContinueLooking \u003d csContext.getConfiguration()\n         .getReservationContinueLook();\n \n     this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    // get labels\n    this.accessibleLabels \u003d\n        csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n    this.defaultLabelExpression \u003d csContext.getConfiguration()\n        .getDefaultNodeLabelExpression(getQueuePath());\n\n    // inherit from parent if labels not set\n    if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n      this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n    }\n    SchedulerUtils.checkIfLabelInClusterNodeLabels(labelManager,\n        this.accessibleLabels);\n    \n    // inherit from parent if labels not set\n    if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n        \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n      this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n    }\n\n    // After we setup labels, we can setup capacities\n    setupConfigurableCapacities();\n    \n    this.maximumAllocation \u003d\n        csContext.getConfiguration().getMaximumAllocationPerQueue(\n            getQueuePath());\n    \n    authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n    \n    this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n    this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(resourceCalculator, clusterResource,\n        minimumAllocation, this, labelManager, null);\n    \n    // Check if labels of this queue is a subset of parent queue, only do this\n    // when we not root\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n      if (parent.getAccessibleNodeLabels() !\u003d null\n          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n              + \"but child\u0027s accessible queue is *\");\n        } else {\n          Set\u003cString\u003e diff \u003d\n              Sets.difference(this.getAccessibleNodeLabels(),\n                  parent.getAccessibleNodeLabels());\n          if (!diff.isEmpty()) {\n            throw new IOException(\"Some labels of child queue is not a subset \"\n                + \"of parent queue, these labels\u003d[\"\n                + StringUtils.join(diff, \",\") + \"]\");\n          }\n        }\n      }\n    }\n\n    this.reservationsContinueLooking \u003d csContext.getConfiguration()\n        .getReservationContinueLook();\n\n    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "14dd647c556016d351f425ee956ccf800ccb9ce2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3265. Fixed a deadlock in CapacityScheduler by always passing a queue\u0027s available resource-limit from the parent queue. Contributed by Wangda Tan.\n",
      "commitDate": "02/03/15 5:52 PM",
      "commitName": "14dd647c556016d351f425ee956ccf800ccb9ce2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/02/15 2:58 PM",
      "commitNameOld": "18a594257e052e8f10a03e5594e6cc6901dc56be",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 18.12,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,64 @@\n   synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     // get labels\n     this.accessibleLabels \u003d\n         csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n     this.defaultLabelExpression \u003d csContext.getConfiguration()\n         .getDefaultNodeLabelExpression(getQueuePath());\n \n     // inherit from parent if labels not set\n     if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n       this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n     }\n     SchedulerUtils.checkIfLabelInClusterNodeLabels(labelManager,\n         this.accessibleLabels);\n     \n     // inherit from parent if labels not set\n     if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n         \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n       this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n     }\n \n     // After we setup labels, we can setup capacities\n     setupConfigurableCapacities();\n     \n-    this.minimumAllocation \u003d csContext.getMinimumResourceCapability();\n     this.maximumAllocation \u003d\n         csContext.getConfiguration().getMaximumAllocationPerQueue(\n             getQueuePath());\n     \n     authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n     \n     this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n     this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, parent, clusterResource, minimumAllocation);\n     \n     // Check if labels of this queue is a subset of parent queue, only do this\n     // when we not root\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n       if (parent.getAccessibleNodeLabels() !\u003d null\n           \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n         // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n         if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n               + \"but child\u0027s accessible queue is *\");\n         } else {\n           Set\u003cString\u003e diff \u003d\n               Sets.difference(this.getAccessibleNodeLabels(),\n                   parent.getAccessibleNodeLabels());\n           if (!diff.isEmpty()) {\n             throw new IOException(\"Some labels of child queue is not a subset \"\n                 + \"of parent queue, these labels\u003d[\"\n                 + StringUtils.join(diff, \",\") + \"]\");\n           }\n         }\n       }\n     }\n \n     this.reservationsContinueLooking \u003d csContext.getConfiguration()\n         .getReservationContinueLook();\n \n     this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    // get labels\n    this.accessibleLabels \u003d\n        csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n    this.defaultLabelExpression \u003d csContext.getConfiguration()\n        .getDefaultNodeLabelExpression(getQueuePath());\n\n    // inherit from parent if labels not set\n    if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n      this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n    }\n    SchedulerUtils.checkIfLabelInClusterNodeLabels(labelManager,\n        this.accessibleLabels);\n    \n    // inherit from parent if labels not set\n    if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n        \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n      this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n    }\n\n    // After we setup labels, we can setup capacities\n    setupConfigurableCapacities();\n    \n    this.maximumAllocation \u003d\n        csContext.getConfiguration().getMaximumAllocationPerQueue(\n            getQueuePath());\n    \n    authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n    \n    this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n    this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, parent, clusterResource, minimumAllocation);\n    \n    // Check if labels of this queue is a subset of parent queue, only do this\n    // when we not root\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n      if (parent.getAccessibleNodeLabels() !\u003d null\n          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n              + \"but child\u0027s accessible queue is *\");\n        } else {\n          Set\u003cString\u003e diff \u003d\n              Sets.difference(this.getAccessibleNodeLabels(),\n                  parent.getAccessibleNodeLabels());\n          if (!diff.isEmpty()) {\n            throw new IOException(\"Some labels of child queue is not a subset \"\n                + \"of parent queue, these labels\u003d[\"\n                + StringUtils.join(diff, \",\") + \"]\");\n          }\n        }\n      }\n    }\n\n    this.reservationsContinueLooking \u003d csContext.getConfiguration()\n        .getReservationContinueLook();\n\n    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "18a594257e052e8f10a03e5594e6cc6901dc56be": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3124. Fixed CS LeafQueue/ParentQueue to use QueueCapacities to track capacities-by-label. Contributed by Wangda Tan\n",
      "commitDate": "12/02/15 2:58 PM",
      "commitName": "18a594257e052e8f10a03e5594e6cc6901dc56be",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3124. Fixed CS LeafQueue/ParentQueue to use QueueCapacities to track capacities-by-label. Contributed by Wangda Tan\n",
          "commitDate": "12/02/15 2:58 PM",
          "commitName": "18a594257e052e8f10a03e5594e6cc6901dc56be",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/02/15 8:34 PM",
          "commitNameOld": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 2.77,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,65 @@\n-  synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n-      float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n-      QueueState state, Map\u003cAccessType, AccessControlList\u003e acls,\n-      Set\u003cString\u003e labels, String defaultLabelExpression,\n-      Map\u003cString, Float\u003e nodeLabelCapacities,\n-      Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n-      boolean reservationContinueLooking, Resource maxAllocation)\n+  synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n-    // Sanity check\n-    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n-    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n-        absoluteMaxCapacity);\n+    // get labels\n+    this.accessibleLabels \u003d\n+        csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n+    this.defaultLabelExpression \u003d csContext.getConfiguration()\n+        .getDefaultNodeLabelExpression(getQueuePath());\n \n-    this.capacity \u003d capacity;\n-    this.absoluteCapacity \u003d absoluteCapacity;\n-\n-    this.maximumCapacity \u003d maximumCapacity;\n-    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n-\n-    this.state \u003d state;\n-\n-    this.acls \u003d acls;\n+    // inherit from parent if labels not set\n+    if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n+      this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n+    }\n+    SchedulerUtils.checkIfLabelInClusterNodeLabels(labelManager,\n+        this.accessibleLabels);\n     \n-    // set labels\n-    this.accessibleLabels \u003d labels;\n+    // inherit from parent if labels not set\n+    if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n+        \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n+      this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n+    }\n+\n+    // After we setup labels, we can setup capacities\n+    setupConfigurableCapacities();\n     \n-    // set label expression\n-    this.defaultLabelExpression \u003d defaultLabelExpression;\n+    this.minimumAllocation \u003d csContext.getMinimumResourceCapability();\n+    this.maximumAllocation \u003d\n+        csContext.getConfiguration().getMaximumAllocationPerQueue(\n+            getQueuePath());\n     \n-    // copy node label capacity\n-    this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n-    this.maxCapacityByNodeLabels \u003d\n-        new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n+    authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n+    \n+    this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n+    this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, parent, clusterResource, minimumAllocation);\n     \n     // Check if labels of this queue is a subset of parent queue, only do this\n     // when we not root\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n       if (parent.getAccessibleNodeLabels() !\u003d null\n           \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n         // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n         if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n               + \"but child\u0027s accessible queue is *\");\n         } else {\n           Set\u003cString\u003e diff \u003d\n               Sets.difference(this.getAccessibleNodeLabels(),\n                   parent.getAccessibleNodeLabels());\n           if (!diff.isEmpty()) {\n             throw new IOException(\"Some labels of child queue is not a subset \"\n                 + \"of parent queue, these labels\u003d[\"\n                 + StringUtils.join(diff, \",\") + \"]\");\n           }\n         }\n       }\n     }\n-    \n-    // calculate absolute capacity by each node label\n-    this.absoluteCapacityByNodeLabels \u003d\n-        CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n-            this.capacitiyByNodeLabels, parent);\n-    \n-    // calculate maximum capacity by each node label\n-    this.absoluteMaxCapacityByNodeLabels \u003d\n-        CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n-            maximumNodeLabelCapacities, parent);\n-    \n-    // check absoluteMaximumNodeLabelCapacities is valid\n-    CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n-        absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n-    \n-    this.reservationsContinueLooking \u003d reservationContinueLooking;\n+\n+    this.reservationsContinueLooking \u003d csContext.getConfiguration()\n+        .getReservationContinueLook();\n \n     this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n-\n-    this.maximumAllocation \u003d maxAllocation;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    // get labels\n    this.accessibleLabels \u003d\n        csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n    this.defaultLabelExpression \u003d csContext.getConfiguration()\n        .getDefaultNodeLabelExpression(getQueuePath());\n\n    // inherit from parent if labels not set\n    if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n      this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n    }\n    SchedulerUtils.checkIfLabelInClusterNodeLabels(labelManager,\n        this.accessibleLabels);\n    \n    // inherit from parent if labels not set\n    if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n        \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n      this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n    }\n\n    // After we setup labels, we can setup capacities\n    setupConfigurableCapacities();\n    \n    this.minimumAllocation \u003d csContext.getMinimumResourceCapability();\n    this.maximumAllocation \u003d\n        csContext.getConfiguration().getMaximumAllocationPerQueue(\n            getQueuePath());\n    \n    authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n    \n    this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n    this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, parent, clusterResource, minimumAllocation);\n    \n    // Check if labels of this queue is a subset of parent queue, only do this\n    // when we not root\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n      if (parent.getAccessibleNodeLabels() !\u003d null\n          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n              + \"but child\u0027s accessible queue is *\");\n        } else {\n          Set\u003cString\u003e diff \u003d\n              Sets.difference(this.getAccessibleNodeLabels(),\n                  parent.getAccessibleNodeLabels());\n          if (!diff.isEmpty()) {\n            throw new IOException(\"Some labels of child queue is not a subset \"\n                + \"of parent queue, these labels\u003d[\"\n                + StringUtils.join(diff, \",\") + \"]\");\n          }\n        }\n      }\n    }\n\n    this.reservationsContinueLooking \u003d csContext.getConfiguration()\n        .getReservationContinueLook();\n\n    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, state-QueueState, acls-Map\u003cAccessType,AccessControlList\u003e, labels-Set\u003cString\u003e, defaultLabelExpression-String, nodeLabelCapacities-Map\u003cString,Float\u003e, maximumNodeLabelCapacities-Map\u003cString,Float\u003e, reservationContinueLooking-boolean, maxAllocation-Resource]",
            "newValue": "[clusterResource-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3124. Fixed CS LeafQueue/ParentQueue to use QueueCapacities to track capacities-by-label. Contributed by Wangda Tan\n",
          "commitDate": "12/02/15 2:58 PM",
          "commitName": "18a594257e052e8f10a03e5594e6cc6901dc56be",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/02/15 8:34 PM",
          "commitNameOld": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 2.77,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,65 @@\n-  synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n-      float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n-      QueueState state, Map\u003cAccessType, AccessControlList\u003e acls,\n-      Set\u003cString\u003e labels, String defaultLabelExpression,\n-      Map\u003cString, Float\u003e nodeLabelCapacities,\n-      Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n-      boolean reservationContinueLooking, Resource maxAllocation)\n+  synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n-    // Sanity check\n-    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n-    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n-        absoluteMaxCapacity);\n+    // get labels\n+    this.accessibleLabels \u003d\n+        csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n+    this.defaultLabelExpression \u003d csContext.getConfiguration()\n+        .getDefaultNodeLabelExpression(getQueuePath());\n \n-    this.capacity \u003d capacity;\n-    this.absoluteCapacity \u003d absoluteCapacity;\n-\n-    this.maximumCapacity \u003d maximumCapacity;\n-    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n-\n-    this.state \u003d state;\n-\n-    this.acls \u003d acls;\n+    // inherit from parent if labels not set\n+    if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n+      this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n+    }\n+    SchedulerUtils.checkIfLabelInClusterNodeLabels(labelManager,\n+        this.accessibleLabels);\n     \n-    // set labels\n-    this.accessibleLabels \u003d labels;\n+    // inherit from parent if labels not set\n+    if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n+        \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n+      this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n+    }\n+\n+    // After we setup labels, we can setup capacities\n+    setupConfigurableCapacities();\n     \n-    // set label expression\n-    this.defaultLabelExpression \u003d defaultLabelExpression;\n+    this.minimumAllocation \u003d csContext.getMinimumResourceCapability();\n+    this.maximumAllocation \u003d\n+        csContext.getConfiguration().getMaximumAllocationPerQueue(\n+            getQueuePath());\n     \n-    // copy node label capacity\n-    this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n-    this.maxCapacityByNodeLabels \u003d\n-        new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n+    authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n+    \n+    this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n+    this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, parent, clusterResource, minimumAllocation);\n     \n     // Check if labels of this queue is a subset of parent queue, only do this\n     // when we not root\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n       if (parent.getAccessibleNodeLabels() !\u003d null\n           \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n         // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n         if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n               + \"but child\u0027s accessible queue is *\");\n         } else {\n           Set\u003cString\u003e diff \u003d\n               Sets.difference(this.getAccessibleNodeLabels(),\n                   parent.getAccessibleNodeLabels());\n           if (!diff.isEmpty()) {\n             throw new IOException(\"Some labels of child queue is not a subset \"\n                 + \"of parent queue, these labels\u003d[\"\n                 + StringUtils.join(diff, \",\") + \"]\");\n           }\n         }\n       }\n     }\n-    \n-    // calculate absolute capacity by each node label\n-    this.absoluteCapacityByNodeLabels \u003d\n-        CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n-            this.capacitiyByNodeLabels, parent);\n-    \n-    // calculate maximum capacity by each node label\n-    this.absoluteMaxCapacityByNodeLabels \u003d\n-        CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n-            maximumNodeLabelCapacities, parent);\n-    \n-    // check absoluteMaximumNodeLabelCapacities is valid\n-    CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n-        absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n-    \n-    this.reservationsContinueLooking \u003d reservationContinueLooking;\n+\n+    this.reservationsContinueLooking \u003d csContext.getConfiguration()\n+        .getReservationContinueLook();\n \n     this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n-\n-    this.maximumAllocation \u003d maxAllocation;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    // get labels\n    this.accessibleLabels \u003d\n        csContext.getConfiguration().getAccessibleNodeLabels(getQueuePath());\n    this.defaultLabelExpression \u003d csContext.getConfiguration()\n        .getDefaultNodeLabelExpression(getQueuePath());\n\n    // inherit from parent if labels not set\n    if (this.accessibleLabels \u003d\u003d null \u0026\u0026 parent !\u003d null) {\n      this.accessibleLabels \u003d parent.getAccessibleNodeLabels();\n    }\n    SchedulerUtils.checkIfLabelInClusterNodeLabels(labelManager,\n        this.accessibleLabels);\n    \n    // inherit from parent if labels not set\n    if (this.defaultLabelExpression \u003d\u003d null \u0026\u0026 parent !\u003d null\n        \u0026\u0026 this.accessibleLabels.containsAll(parent.getAccessibleNodeLabels())) {\n      this.defaultLabelExpression \u003d parent.getDefaultNodeLabelExpression();\n    }\n\n    // After we setup labels, we can setup capacities\n    setupConfigurableCapacities();\n    \n    this.minimumAllocation \u003d csContext.getMinimumResourceCapability();\n    this.maximumAllocation \u003d\n        csContext.getConfiguration().getMaximumAllocationPerQueue(\n            getQueuePath());\n    \n    authorizer \u003d YarnAuthorizationProvider.getInstance(csContext.getConf());\n    \n    this.state \u003d csContext.getConfiguration().getState(getQueuePath());\n    this.acls \u003d csContext.getConfiguration().getAcls(getQueuePath());\n\n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, parent, clusterResource, minimumAllocation);\n    \n    // Check if labels of this queue is a subset of parent queue, only do this\n    // when we not root\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n      if (parent.getAccessibleNodeLabels() !\u003d null\n          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n              + \"but child\u0027s accessible queue is *\");\n        } else {\n          Set\u003cString\u003e diff \u003d\n              Sets.difference(this.getAccessibleNodeLabels(),\n                  parent.getAccessibleNodeLabels());\n          if (!diff.isEmpty()) {\n            throw new IOException(\"Some labels of child queue is not a subset \"\n                + \"of parent queue, these labels\u003d[\"\n                + StringUtils.join(diff, \",\") + \"]\");\n          }\n        }\n      }\n    }\n\n    this.reservationsContinueLooking \u003d csContext.getConfiguration()\n        .getReservationContinueLook();\n\n    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "23bf6c72071782e3fd5a628e21495d6b974c7a9e": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-3100. Made YARN authorization pluggable. Contributed by Jian He.\n",
      "commitDate": "09/02/15 8:34 PM",
      "commitName": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "05/02/15 11:28 AM",
      "commitNameOld": "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 4.38,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n   synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n       float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n-      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls,\n+      QueueState state, Map\u003cAccessType, AccessControlList\u003e acls,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e nodeLabelCapacities,\n       Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n       boolean reservationContinueLooking, Resource maxAllocation)\n       throws IOException {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n         absoluteMaxCapacity);\n \n     this.capacity \u003d capacity;\n     this.absoluteCapacity \u003d absoluteCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n     \n     // set labels\n     this.accessibleLabels \u003d labels;\n     \n     // set label expression\n     this.defaultLabelExpression \u003d defaultLabelExpression;\n     \n     // copy node label capacity\n     this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n     this.maxCapacityByNodeLabels \u003d\n         new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, parent, clusterResource, minimumAllocation);\n     \n     // Check if labels of this queue is a subset of parent queue, only do this\n     // when we not root\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n       if (parent.getAccessibleNodeLabels() !\u003d null\n           \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n         // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n         if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n               + \"but child\u0027s accessible queue is *\");\n         } else {\n           Set\u003cString\u003e diff \u003d\n               Sets.difference(this.getAccessibleNodeLabels(),\n                   parent.getAccessibleNodeLabels());\n           if (!diff.isEmpty()) {\n             throw new IOException(\"Some labels of child queue is not a subset \"\n                 + \"of parent queue, these labels\u003d[\"\n                 + StringUtils.join(diff, \",\") + \"]\");\n           }\n         }\n       }\n     }\n     \n     // calculate absolute capacity by each node label\n     this.absoluteCapacityByNodeLabels \u003d\n         CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n             this.capacitiyByNodeLabels, parent);\n     \n     // calculate maximum capacity by each node label\n     this.absoluteMaxCapacityByNodeLabels \u003d\n         CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n             maximumNodeLabelCapacities, parent);\n     \n     // check absoluteMaximumNodeLabelCapacities is valid\n     CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n         absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n     \n     this.reservationsContinueLooking \u003d reservationContinueLooking;\n \n     this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n \n     this.maximumAllocation \u003d maxAllocation;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n      float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n      QueueState state, Map\u003cAccessType, AccessControlList\u003e acls,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e nodeLabelCapacities,\n      Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n      boolean reservationContinueLooking, Resource maxAllocation)\n      throws IOException {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n        absoluteMaxCapacity);\n\n    this.capacity \u003d capacity;\n    this.absoluteCapacity \u003d absoluteCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.state \u003d state;\n\n    this.acls \u003d acls;\n    \n    // set labels\n    this.accessibleLabels \u003d labels;\n    \n    // set label expression\n    this.defaultLabelExpression \u003d defaultLabelExpression;\n    \n    // copy node label capacity\n    this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n    this.maxCapacityByNodeLabels \u003d\n        new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n\n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, parent, clusterResource, minimumAllocation);\n    \n    // Check if labels of this queue is a subset of parent queue, only do this\n    // when we not root\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n      if (parent.getAccessibleNodeLabels() !\u003d null\n          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n              + \"but child\u0027s accessible queue is *\");\n        } else {\n          Set\u003cString\u003e diff \u003d\n              Sets.difference(this.getAccessibleNodeLabels(),\n                  parent.getAccessibleNodeLabels());\n          if (!diff.isEmpty()) {\n            throw new IOException(\"Some labels of child queue is not a subset \"\n                + \"of parent queue, these labels\u003d[\"\n                + StringUtils.join(diff, \",\") + \"]\");\n          }\n        }\n      }\n    }\n    \n    // calculate absolute capacity by each node label\n    this.absoluteCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n            this.capacitiyByNodeLabels, parent);\n    \n    // calculate maximum capacity by each node label\n    this.absoluteMaxCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n            maximumNodeLabelCapacities, parent);\n    \n    // check absoluteMaximumNodeLabelCapacities is valid\n    CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n        absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n    \n    this.reservationsContinueLooking \u003d reservationContinueLooking;\n\n    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n\n    this.maximumAllocation \u003d maxAllocation;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {
        "oldValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, labels-Set\u003cString\u003e, defaultLabelExpression-String, nodeLabelCapacities-Map\u003cString,Float\u003e, maximumNodeLabelCapacities-Map\u003cString,Float\u003e, reservationContinueLooking-boolean, maxAllocation-Resource]",
        "newValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, state-QueueState, acls-Map\u003cAccessType,AccessControlList\u003e, labels-Set\u003cString\u003e, defaultLabelExpression-String, nodeLabelCapacities-Map\u003cString,Float\u003e, maximumNodeLabelCapacities-Map\u003cString,Float\u003e, reservationContinueLooking-boolean, maxAllocation-Resource]"
      }
    },
    "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1582. Capacity Scheduler: add a maximum-allocation-mb setting per queue. Contributed by Thomas Graves\n",
      "commitDate": "05/02/15 11:28 AM",
      "commitName": "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1582. Capacity Scheduler: add a maximum-allocation-mb setting per queue. Contributed by Thomas Graves\n",
          "commitDate": "05/02/15 11:28 AM",
          "commitName": "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "30/01/15 3:15 PM",
          "commitNameOld": "86358221fc85a7743052a0b4c1647353508bf308",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 5.84,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,78 +1,80 @@\n   synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n       float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e nodeLabelCapacities,\n       Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n-      boolean reservationContinueLooking)\n+      boolean reservationContinueLooking, Resource maxAllocation)\n       throws IOException {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n         absoluteMaxCapacity);\n \n     this.capacity \u003d capacity;\n     this.absoluteCapacity \u003d absoluteCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n     \n     // set labels\n     this.accessibleLabels \u003d labels;\n     \n     // set label expression\n     this.defaultLabelExpression \u003d defaultLabelExpression;\n     \n     // copy node label capacity\n     this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n     this.maxCapacityByNodeLabels \u003d\n         new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, parent, clusterResource, minimumAllocation);\n     \n     // Check if labels of this queue is a subset of parent queue, only do this\n     // when we not root\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n       if (parent.getAccessibleNodeLabels() !\u003d null\n           \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n         // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n         if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n               + \"but child\u0027s accessible queue is *\");\n         } else {\n           Set\u003cString\u003e diff \u003d\n               Sets.difference(this.getAccessibleNodeLabels(),\n                   parent.getAccessibleNodeLabels());\n           if (!diff.isEmpty()) {\n             throw new IOException(\"Some labels of child queue is not a subset \"\n                 + \"of parent queue, these labels\u003d[\"\n                 + StringUtils.join(diff, \",\") + \"]\");\n           }\n         }\n       }\n     }\n     \n     // calculate absolute capacity by each node label\n     this.absoluteCapacityByNodeLabels \u003d\n         CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n             this.capacitiyByNodeLabels, parent);\n     \n     // calculate maximum capacity by each node label\n     this.absoluteMaxCapacityByNodeLabels \u003d\n         CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n             maximumNodeLabelCapacities, parent);\n     \n     // check absoluteMaximumNodeLabelCapacities is valid\n     CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n         absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n     \n     this.reservationsContinueLooking \u003d reservationContinueLooking;\n \n     this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n+\n+    this.maximumAllocation \u003d maxAllocation;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n      float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e nodeLabelCapacities,\n      Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n      boolean reservationContinueLooking, Resource maxAllocation)\n      throws IOException {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n        absoluteMaxCapacity);\n\n    this.capacity \u003d capacity;\n    this.absoluteCapacity \u003d absoluteCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.state \u003d state;\n\n    this.acls \u003d acls;\n    \n    // set labels\n    this.accessibleLabels \u003d labels;\n    \n    // set label expression\n    this.defaultLabelExpression \u003d defaultLabelExpression;\n    \n    // copy node label capacity\n    this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n    this.maxCapacityByNodeLabels \u003d\n        new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n\n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, parent, clusterResource, minimumAllocation);\n    \n    // Check if labels of this queue is a subset of parent queue, only do this\n    // when we not root\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n      if (parent.getAccessibleNodeLabels() !\u003d null\n          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n              + \"but child\u0027s accessible queue is *\");\n        } else {\n          Set\u003cString\u003e diff \u003d\n              Sets.difference(this.getAccessibleNodeLabels(),\n                  parent.getAccessibleNodeLabels());\n          if (!diff.isEmpty()) {\n            throw new IOException(\"Some labels of child queue is not a subset \"\n                + \"of parent queue, these labels\u003d[\"\n                + StringUtils.join(diff, \",\") + \"]\");\n          }\n        }\n      }\n    }\n    \n    // calculate absolute capacity by each node label\n    this.absoluteCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n            this.capacitiyByNodeLabels, parent);\n    \n    // calculate maximum capacity by each node label\n    this.absoluteMaxCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n            maximumNodeLabelCapacities, parent);\n    \n    // check absoluteMaximumNodeLabelCapacities is valid\n    CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n        absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n    \n    this.reservationsContinueLooking \u003d reservationContinueLooking;\n\n    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n\n    this.maximumAllocation \u003d maxAllocation;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, labels-Set\u003cString\u003e, defaultLabelExpression-String, nodeLabelCapacities-Map\u003cString,Float\u003e, maximumNodeLabelCapacities-Map\u003cString,Float\u003e, reservationContinueLooking-boolean]",
            "newValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, labels-Set\u003cString\u003e, defaultLabelExpression-String, nodeLabelCapacities-Map\u003cString,Float\u003e, maximumNodeLabelCapacities-Map\u003cString,Float\u003e, reservationContinueLooking-boolean, maxAllocation-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1582. Capacity Scheduler: add a maximum-allocation-mb setting per queue. Contributed by Thomas Graves\n",
          "commitDate": "05/02/15 11:28 AM",
          "commitName": "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "30/01/15 3:15 PM",
          "commitNameOld": "86358221fc85a7743052a0b4c1647353508bf308",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 5.84,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,78 +1,80 @@\n   synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n       float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e nodeLabelCapacities,\n       Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n-      boolean reservationContinueLooking)\n+      boolean reservationContinueLooking, Resource maxAllocation)\n       throws IOException {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n         absoluteMaxCapacity);\n \n     this.capacity \u003d capacity;\n     this.absoluteCapacity \u003d absoluteCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n     \n     // set labels\n     this.accessibleLabels \u003d labels;\n     \n     // set label expression\n     this.defaultLabelExpression \u003d defaultLabelExpression;\n     \n     // copy node label capacity\n     this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n     this.maxCapacityByNodeLabels \u003d\n         new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, parent, clusterResource, minimumAllocation);\n     \n     // Check if labels of this queue is a subset of parent queue, only do this\n     // when we not root\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n       if (parent.getAccessibleNodeLabels() !\u003d null\n           \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n         // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n         if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n               + \"but child\u0027s accessible queue is *\");\n         } else {\n           Set\u003cString\u003e diff \u003d\n               Sets.difference(this.getAccessibleNodeLabels(),\n                   parent.getAccessibleNodeLabels());\n           if (!diff.isEmpty()) {\n             throw new IOException(\"Some labels of child queue is not a subset \"\n                 + \"of parent queue, these labels\u003d[\"\n                 + StringUtils.join(diff, \",\") + \"]\");\n           }\n         }\n       }\n     }\n     \n     // calculate absolute capacity by each node label\n     this.absoluteCapacityByNodeLabels \u003d\n         CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n             this.capacitiyByNodeLabels, parent);\n     \n     // calculate maximum capacity by each node label\n     this.absoluteMaxCapacityByNodeLabels \u003d\n         CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n             maximumNodeLabelCapacities, parent);\n     \n     // check absoluteMaximumNodeLabelCapacities is valid\n     CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n         absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n     \n     this.reservationsContinueLooking \u003d reservationContinueLooking;\n \n     this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n+\n+    this.maximumAllocation \u003d maxAllocation;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n      float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e nodeLabelCapacities,\n      Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n      boolean reservationContinueLooking, Resource maxAllocation)\n      throws IOException {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n        absoluteMaxCapacity);\n\n    this.capacity \u003d capacity;\n    this.absoluteCapacity \u003d absoluteCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.state \u003d state;\n\n    this.acls \u003d acls;\n    \n    // set labels\n    this.accessibleLabels \u003d labels;\n    \n    // set label expression\n    this.defaultLabelExpression \u003d defaultLabelExpression;\n    \n    // copy node label capacity\n    this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n    this.maxCapacityByNodeLabels \u003d\n        new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n\n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, parent, clusterResource, minimumAllocation);\n    \n    // Check if labels of this queue is a subset of parent queue, only do this\n    // when we not root\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n      if (parent.getAccessibleNodeLabels() !\u003d null\n          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n              + \"but child\u0027s accessible queue is *\");\n        } else {\n          Set\u003cString\u003e diff \u003d\n              Sets.difference(this.getAccessibleNodeLabels(),\n                  parent.getAccessibleNodeLabels());\n          if (!diff.isEmpty()) {\n            throw new IOException(\"Some labels of child queue is not a subset \"\n                + \"of parent queue, these labels\u003d[\"\n                + StringUtils.join(diff, \",\") + \"]\");\n          }\n        }\n      }\n    }\n    \n    // calculate absolute capacity by each node label\n    this.absoluteCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n            this.capacitiyByNodeLabels, parent);\n    \n    // calculate maximum capacity by each node label\n    this.absoluteMaxCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n            maximumNodeLabelCapacities, parent);\n    \n    // check absoluteMaximumNodeLabelCapacities is valid\n    CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n        absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n    \n    this.reservationsContinueLooking \u003d reservationContinueLooking;\n\n    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n\n    this.maximumAllocation \u003d maxAllocation;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "18741adf97f4fda5f8743318b59c440928e51297": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2932. Add entry for preemptable status (enabled/disabled) to scheduler web UI and queue initialize/refresh logging. (Eric Payne via wangda)\n",
      "commitDate": "27/01/15 3:36 PM",
      "commitName": "18741adf97f4fda5f8743318b59c440928e51297",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "06/01/15 2:15 PM",
      "commitNameOld": "dd57c2047bfd21910acc38c98153eedf1db75169",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 21.06,
      "commitsBetweenForRepo": 146,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,78 @@\n   synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n       float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e nodeLabelCapacities,\n       Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n       boolean reservationContinueLooking)\n       throws IOException {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n         absoluteMaxCapacity);\n \n     this.capacity \u003d capacity;\n     this.absoluteCapacity \u003d absoluteCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n     \n     // set labels\n     this.accessibleLabels \u003d labels;\n     \n     // set label expression\n     this.defaultLabelExpression \u003d defaultLabelExpression;\n     \n     // copy node label capacity\n     this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n     this.maxCapacityByNodeLabels \u003d\n         new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, parent, clusterResource, minimumAllocation);\n     \n     // Check if labels of this queue is a subset of parent queue, only do this\n     // when we not root\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n       if (parent.getAccessibleNodeLabels() !\u003d null\n           \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n         // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n         if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n               + \"but child\u0027s accessible queue is *\");\n         } else {\n           Set\u003cString\u003e diff \u003d\n               Sets.difference(this.getAccessibleNodeLabels(),\n                   parent.getAccessibleNodeLabels());\n           if (!diff.isEmpty()) {\n             throw new IOException(\"Some labels of child queue is not a subset \"\n                 + \"of parent queue, these labels\u003d[\"\n                 + StringUtils.join(diff, \",\") + \"]\");\n           }\n         }\n       }\n     }\n     \n     // calculate absolute capacity by each node label\n     this.absoluteCapacityByNodeLabels \u003d\n         CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n             this.capacitiyByNodeLabels, parent);\n     \n     // calculate maximum capacity by each node label\n     this.absoluteMaxCapacityByNodeLabels \u003d\n         CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n             maximumNodeLabelCapacities, parent);\n     \n     // check absoluteMaximumNodeLabelCapacities is valid\n     CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n         absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n     \n     this.reservationsContinueLooking \u003d reservationContinueLooking;\n+\n+    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n      float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e nodeLabelCapacities,\n      Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n      boolean reservationContinueLooking)\n      throws IOException {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n        absoluteMaxCapacity);\n\n    this.capacity \u003d capacity;\n    this.absoluteCapacity \u003d absoluteCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.state \u003d state;\n\n    this.acls \u003d acls;\n    \n    // set labels\n    this.accessibleLabels \u003d labels;\n    \n    // set label expression\n    this.defaultLabelExpression \u003d defaultLabelExpression;\n    \n    // copy node label capacity\n    this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n    this.maxCapacityByNodeLabels \u003d\n        new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n\n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, parent, clusterResource, minimumAllocation);\n    \n    // Check if labels of this queue is a subset of parent queue, only do this\n    // when we not root\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n      if (parent.getAccessibleNodeLabels() !\u003d null\n          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n              + \"but child\u0027s accessible queue is *\");\n        } else {\n          Set\u003cString\u003e diff \u003d\n              Sets.difference(this.getAccessibleNodeLabels(),\n                  parent.getAccessibleNodeLabels());\n          if (!diff.isEmpty()) {\n            throw new IOException(\"Some labels of child queue is not a subset \"\n                + \"of parent queue, these labels\u003d[\"\n                + StringUtils.join(diff, \",\") + \"]\");\n          }\n        }\n      }\n    }\n    \n    // calculate absolute capacity by each node label\n    this.absoluteCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n            this.capacitiyByNodeLabels, parent);\n    \n    // calculate maximum capacity by each node label\n    this.absoluteMaxCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n            maximumNodeLabelCapacities, parent);\n    \n    // check absoluteMaximumNodeLabelCapacities is valid\n    CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n        absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n    \n    this.reservationsContinueLooking \u003d reservationContinueLooking;\n\n    this.preemptionDisabled \u003d isQueueHierarchyPreemptionDisabled(this);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "dd57c2047bfd21910acc38c98153eedf1db75169": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2978. Fixed potential NPE while getting queue info. Contributed by Varun Saxena\n",
      "commitDate": "06/01/15 2:15 PM",
      "commitName": "dd57c2047bfd21910acc38c98153eedf1db75169",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/12/14 4:51 PM",
      "commitNameOld": "fdf042dfffa4d2474e3cac86cfb8fe9ee4648beb",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 14.89,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,76 @@\n   synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n       float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e nodeLabelCapacities,\n       Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n       boolean reservationContinueLooking)\n       throws IOException {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n         absoluteMaxCapacity);\n \n     this.capacity \u003d capacity;\n     this.absoluteCapacity \u003d absoluteCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n     \n     // set labels\n     this.accessibleLabels \u003d labels;\n     \n     // set label expression\n     this.defaultLabelExpression \u003d defaultLabelExpression;\n     \n     // copy node label capacity\n     this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n     this.maxCapacityByNodeLabels \u003d\n         new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n-    \n-    this.queueInfo.setAccessibleNodeLabels(this.accessibleLabels);\n-    this.queueInfo.setCapacity(this.capacity);\n-    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n-    this.queueInfo.setQueueState(this.state);\n-    this.queueInfo.setDefaultNodeLabelExpression(this.defaultLabelExpression);\n \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, parent, clusterResource, minimumAllocation);\n     \n     // Check if labels of this queue is a subset of parent queue, only do this\n     // when we not root\n     if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n       if (parent.getAccessibleNodeLabels() !\u003d null\n           \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n         // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n         if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n           throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n               + \"but child\u0027s accessible queue is *\");\n         } else {\n           Set\u003cString\u003e diff \u003d\n               Sets.difference(this.getAccessibleNodeLabels(),\n                   parent.getAccessibleNodeLabels());\n           if (!diff.isEmpty()) {\n             throw new IOException(\"Some labels of child queue is not a subset \"\n                 + \"of parent queue, these labels\u003d[\"\n                 + StringUtils.join(diff, \",\") + \"]\");\n           }\n         }\n       }\n     }\n     \n     // calculate absolute capacity by each node label\n     this.absoluteCapacityByNodeLabels \u003d\n         CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n             this.capacitiyByNodeLabels, parent);\n     \n     // calculate maximum capacity by each node label\n     this.absoluteMaxCapacityByNodeLabels \u003d\n         CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n             maximumNodeLabelCapacities, parent);\n     \n     // check absoluteMaximumNodeLabelCapacities is valid\n     CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n         absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n     \n     this.reservationsContinueLooking \u003d reservationContinueLooking;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n      float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e nodeLabelCapacities,\n      Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n      boolean reservationContinueLooking)\n      throws IOException {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n        absoluteMaxCapacity);\n\n    this.capacity \u003d capacity;\n    this.absoluteCapacity \u003d absoluteCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.state \u003d state;\n\n    this.acls \u003d acls;\n    \n    // set labels\n    this.accessibleLabels \u003d labels;\n    \n    // set label expression\n    this.defaultLabelExpression \u003d defaultLabelExpression;\n    \n    // copy node label capacity\n    this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n    this.maxCapacityByNodeLabels \u003d\n        new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n\n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, parent, clusterResource, minimumAllocation);\n    \n    // Check if labels of this queue is a subset of parent queue, only do this\n    // when we not root\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n      if (parent.getAccessibleNodeLabels() !\u003d null\n          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n              + \"but child\u0027s accessible queue is *\");\n        } else {\n          Set\u003cString\u003e diff \u003d\n              Sets.difference(this.getAccessibleNodeLabels(),\n                  parent.getAccessibleNodeLabels());\n          if (!diff.isEmpty()) {\n            throw new IOException(\"Some labels of child queue is not a subset \"\n                + \"of parent queue, these labels\u003d[\"\n                + StringUtils.join(diff, \",\") + \"]\");\n          }\n        }\n      }\n    }\n    \n    // calculate absolute capacity by each node label\n    this.absoluteCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n            this.capacitiyByNodeLabels, parent);\n    \n    // calculate maximum capacity by each node label\n    this.absoluteMaxCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n            maximumNodeLabelCapacities, parent);\n    \n    // check absoluteMaximumNodeLabelCapacities is valid\n    CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n        absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n    \n    this.reservationsContinueLooking \u003d reservationContinueLooking;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,82 @@\n+  synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n+      float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n+      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls,\n+      Set\u003cString\u003e labels, String defaultLabelExpression,\n+      Map\u003cString, Float\u003e nodeLabelCapacities,\n+      Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n+      boolean reservationContinueLooking)\n+      throws IOException {\n+    // Sanity check\n+    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n+    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n+        absoluteMaxCapacity);\n+\n+    this.capacity \u003d capacity;\n+    this.absoluteCapacity \u003d absoluteCapacity;\n+\n+    this.maximumCapacity \u003d maximumCapacity;\n+    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n+\n+    this.state \u003d state;\n+\n+    this.acls \u003d acls;\n+    \n+    // set labels\n+    this.accessibleLabels \u003d labels;\n+    \n+    // set label expression\n+    this.defaultLabelExpression \u003d defaultLabelExpression;\n+    \n+    // copy node label capacity\n+    this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n+    this.maxCapacityByNodeLabels \u003d\n+        new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n+    \n+    this.queueInfo.setAccessibleNodeLabels(this.accessibleLabels);\n+    this.queueInfo.setCapacity(this.capacity);\n+    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n+    this.queueInfo.setQueueState(this.state);\n+    this.queueInfo.setDefaultNodeLabelExpression(this.defaultLabelExpression);\n+\n+    // Update metrics\n+    CSQueueUtils.updateQueueStatistics(\n+        resourceCalculator, this, parent, clusterResource, minimumAllocation);\n+    \n+    // Check if labels of this queue is a subset of parent queue, only do this\n+    // when we not root\n+    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n+      if (parent.getAccessibleNodeLabels() !\u003d null\n+          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n+        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n+        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n+          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n+              + \"but child\u0027s accessible queue is *\");\n+        } else {\n+          Set\u003cString\u003e diff \u003d\n+              Sets.difference(this.getAccessibleNodeLabels(),\n+                  parent.getAccessibleNodeLabels());\n+          if (!diff.isEmpty()) {\n+            throw new IOException(\"Some labels of child queue is not a subset \"\n+                + \"of parent queue, these labels\u003d[\"\n+                + StringUtils.join(diff, \",\") + \"]\");\n+          }\n+        }\n+      }\n+    }\n+    \n+    // calculate absolute capacity by each node label\n+    this.absoluteCapacityByNodeLabels \u003d\n+        CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n+            this.capacitiyByNodeLabels, parent);\n+    \n+    // calculate maximum capacity by each node label\n+    this.absoluteMaxCapacityByNodeLabels \u003d\n+        CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n+            maximumNodeLabelCapacities, parent);\n+    \n+    // check absoluteMaximumNodeLabelCapacities is valid\n+    CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n+        absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n+    \n+    this.reservationsContinueLooking \u003d reservationContinueLooking;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized void setupQueueConfigs(Resource clusterResource, float capacity,\n      float absoluteCapacity, float maximumCapacity, float absoluteMaxCapacity,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e nodeLabelCapacities,\n      Map\u003cString, Float\u003e maximumNodeLabelCapacities,\n      boolean reservationContinueLooking)\n      throws IOException {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absoluteCapacity,\n        absoluteMaxCapacity);\n\n    this.capacity \u003d capacity;\n    this.absoluteCapacity \u003d absoluteCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.state \u003d state;\n\n    this.acls \u003d acls;\n    \n    // set labels\n    this.accessibleLabels \u003d labels;\n    \n    // set label expression\n    this.defaultLabelExpression \u003d defaultLabelExpression;\n    \n    // copy node label capacity\n    this.capacitiyByNodeLabels \u003d new HashMap\u003cString, Float\u003e(nodeLabelCapacities);\n    this.maxCapacityByNodeLabels \u003d\n        new HashMap\u003cString, Float\u003e(maximumNodeLabelCapacities);\n    \n    this.queueInfo.setAccessibleNodeLabels(this.accessibleLabels);\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n    this.queueInfo.setDefaultNodeLabelExpression(this.defaultLabelExpression);\n\n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, parent, clusterResource, minimumAllocation);\n    \n    // Check if labels of this queue is a subset of parent queue, only do this\n    // when we not root\n    if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) {\n      if (parent.getAccessibleNodeLabels() !\u003d null\n          \u0026\u0026 !parent.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n        // if parent isn\u0027t \"*\", child shouldn\u0027t be \"*\" too\n        if (this.getAccessibleNodeLabels().contains(RMNodeLabelsManager.ANY)) {\n          throw new IOException(\"Parent\u0027s accessible queue is not ANY(*), \"\n              + \"but child\u0027s accessible queue is *\");\n        } else {\n          Set\u003cString\u003e diff \u003d\n              Sets.difference(this.getAccessibleNodeLabels(),\n                  parent.getAccessibleNodeLabels());\n          if (!diff.isEmpty()) {\n            throw new IOException(\"Some labels of child queue is not a subset \"\n                + \"of parent queue, these labels\u003d[\"\n                + StringUtils.join(diff, \",\") + \"]\");\n          }\n        }\n      }\n    }\n    \n    // calculate absolute capacity by each node label\n    this.absoluteCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteCapacityByNodeLabels(\n            this.capacitiyByNodeLabels, parent);\n    \n    // calculate maximum capacity by each node label\n    this.absoluteMaxCapacityByNodeLabels \u003d\n        CSQueueUtils.computeAbsoluteMaxCapacityByNodeLabels(\n            maximumNodeLabelCapacities, parent);\n    \n    // check absoluteMaximumNodeLabelCapacities is valid\n    CSQueueUtils.checkAbsoluteCapacitiesByLabel(getQueueName(),\n        absoluteCapacityByNodeLabels, absoluteCapacityByNodeLabels);\n    \n    this.reservationsContinueLooking \u003d reservationContinueLooking;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java"
    }
  }
}