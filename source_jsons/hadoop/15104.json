{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OfflineImageReconstructor.java",
  "functionName": "xattrsXmlToProto",
  "functionId": "xattrsXmlToProto___xattrs-Node",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java",
  "functionStartLine": 873,
  "functionEndLine": 918,
  "numCommitsSeen": 15,
  "timeTaken": 1563,
  "changeHistory": [
    "680716f31e120f4d3ee70b095e4db46c05b891d9",
    "700b0e4019cf483f7532609711812150b8c44742"
  ],
  "changeHistoryShort": {
    "680716f31e120f4d3ee70b095e4db46c05b891d9": "Ybodychange",
    "700b0e4019cf483f7532609711812150b8c44742": "Yintroduced"
  },
  "changeHistoryDetails": {
    "680716f31e120f4d3ee70b095e4db46c05b891d9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9951. Use string constants for XML tags in OfflineImageReconstructor (Lin Yiqun via cmccabe)\n",
      "commitDate": "21/03/16 11:40 AM",
      "commitName": "680716f31e120f4d3ee70b095e4db46c05b891d9",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "10/03/16 1:41 PM",
      "commitNameOld": "bd49354c6d6387620b0de2219eab1714ec2d64f8",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 10.87,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private INodeSection.XAttrFeatureProto.Builder xattrsXmlToProto(Node xattrs)\n       throws IOException {\n     INodeSection.XAttrFeatureProto.Builder bld \u003d\n         INodeSection.XAttrFeatureProto.newBuilder();\n     while (true) {\n-      Node xattr \u003d xattrs.removeChild(\"xattr\");\n+      Node xattr \u003d xattrs.removeChild(INODE_SECTION_XATTR);\n       if (xattr \u003d\u003d null) {\n         break;\n       }\n       INodeSection.XAttrCompactProto.Builder b \u003d\n           INodeSection.XAttrCompactProto.newBuilder();\n-      String ns \u003d xattr.removeChildStr(\"ns\");\n+      String ns \u003d xattr.removeChildStr(INODE_SECTION_NS);\n       if (ns \u003d\u003d null) {\n         throw new IOException(\"\u003cxattr\u003e had no \u003cns\u003e entry.\");\n       }\n       int nsIdx \u003d XAttrProtos.XAttrProto.\n           XAttrNamespaceProto.valueOf(ns).ordinal();\n-      String name \u003d xattr.removeChildStr(\"name\");\n-      String valStr \u003d xattr.removeChildStr(\"val\");\n+      String name \u003d xattr.removeChildStr(SECTION_NAME);\n+      String valStr \u003d xattr.removeChildStr(INODE_SECTION_VAL);\n       byte[] val \u003d null;\n       if (valStr \u003d\u003d null) {\n-        String valHex \u003d xattr.removeChildStr(\"valHex\");\n+        String valHex \u003d xattr.removeChildStr(INODE_SECTION_VAL_HEX);\n         if (valHex \u003d\u003d null) {\n           throw new IOException(\"\u003cxattr\u003e had no \u003cval\u003e or \u003cvalHex\u003e entry.\");\n         }\n         val \u003d new HexBinaryAdapter().unmarshal(valHex);\n       } else {\n         val \u003d valStr.getBytes(\"UTF8\");\n       }\n       b.setValue(ByteString.copyFrom(val));\n \n       // The XAttrCompactProto name field uses a fairly complex format\n       // to encode both the string table ID of the xattr name and the\n       // namespace ID.  See the protobuf file for details.\n       int nameId \u003d registerStringId(name);\n       int encodedName \u003d (nameId \u003c\u003c XATTR_NAME_OFFSET) |\n           ((nsIdx \u0026 XATTR_NAMESPACE_MASK) \u003c\u003c XATTR_NAMESPACE_OFFSET) |\n           (((nsIdx \u003e\u003e 2) \u0026 XATTR_NAMESPACE_EXT_MASK)\n               \u003c\u003c XATTR_NAMESPACE_EXT_OFFSET);\n       b.setName(encodedName);\n       xattr.verifyNoRemainingKeys(\"xattr\");\n       bld.addXAttrs(b);\n     }\n     xattrs.verifyNoRemainingKeys(\"xattrs\");\n     return bld;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private INodeSection.XAttrFeatureProto.Builder xattrsXmlToProto(Node xattrs)\n      throws IOException {\n    INodeSection.XAttrFeatureProto.Builder bld \u003d\n        INodeSection.XAttrFeatureProto.newBuilder();\n    while (true) {\n      Node xattr \u003d xattrs.removeChild(INODE_SECTION_XATTR);\n      if (xattr \u003d\u003d null) {\n        break;\n      }\n      INodeSection.XAttrCompactProto.Builder b \u003d\n          INodeSection.XAttrCompactProto.newBuilder();\n      String ns \u003d xattr.removeChildStr(INODE_SECTION_NS);\n      if (ns \u003d\u003d null) {\n        throw new IOException(\"\u003cxattr\u003e had no \u003cns\u003e entry.\");\n      }\n      int nsIdx \u003d XAttrProtos.XAttrProto.\n          XAttrNamespaceProto.valueOf(ns).ordinal();\n      String name \u003d xattr.removeChildStr(SECTION_NAME);\n      String valStr \u003d xattr.removeChildStr(INODE_SECTION_VAL);\n      byte[] val \u003d null;\n      if (valStr \u003d\u003d null) {\n        String valHex \u003d xattr.removeChildStr(INODE_SECTION_VAL_HEX);\n        if (valHex \u003d\u003d null) {\n          throw new IOException(\"\u003cxattr\u003e had no \u003cval\u003e or \u003cvalHex\u003e entry.\");\n        }\n        val \u003d new HexBinaryAdapter().unmarshal(valHex);\n      } else {\n        val \u003d valStr.getBytes(\"UTF8\");\n      }\n      b.setValue(ByteString.copyFrom(val));\n\n      // The XAttrCompactProto name field uses a fairly complex format\n      // to encode both the string table ID of the xattr name and the\n      // namespace ID.  See the protobuf file for details.\n      int nameId \u003d registerStringId(name);\n      int encodedName \u003d (nameId \u003c\u003c XATTR_NAME_OFFSET) |\n          ((nsIdx \u0026 XATTR_NAMESPACE_MASK) \u003c\u003c XATTR_NAMESPACE_OFFSET) |\n          (((nsIdx \u003e\u003e 2) \u0026 XATTR_NAMESPACE_EXT_MASK)\n              \u003c\u003c XATTR_NAMESPACE_EXT_OFFSET);\n      b.setName(encodedName);\n      xattr.verifyNoRemainingKeys(\"xattr\");\n      bld.addXAttrs(b);\n    }\n    xattrs.verifyNoRemainingKeys(\"xattrs\");\n    return bld;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java",
      "extendedDetails": {}
    },
    "700b0e4019cf483f7532609711812150b8c44742": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9835. OIV: add ReverseXML processor which reconstructs an fsimage from an XML file (cmccabe)\n",
      "commitDate": "02/03/16 5:56 PM",
      "commitName": "700b0e4019cf483f7532609711812150b8c44742",
      "commitAuthor": "Colin Patrick Mccabe",
      "diff": "@@ -0,0 +1,46 @@\n+  private INodeSection.XAttrFeatureProto.Builder xattrsXmlToProto(Node xattrs)\n+      throws IOException {\n+    INodeSection.XAttrFeatureProto.Builder bld \u003d\n+        INodeSection.XAttrFeatureProto.newBuilder();\n+    while (true) {\n+      Node xattr \u003d xattrs.removeChild(\"xattr\");\n+      if (xattr \u003d\u003d null) {\n+        break;\n+      }\n+      INodeSection.XAttrCompactProto.Builder b \u003d\n+          INodeSection.XAttrCompactProto.newBuilder();\n+      String ns \u003d xattr.removeChildStr(\"ns\");\n+      if (ns \u003d\u003d null) {\n+        throw new IOException(\"\u003cxattr\u003e had no \u003cns\u003e entry.\");\n+      }\n+      int nsIdx \u003d XAttrProtos.XAttrProto.\n+          XAttrNamespaceProto.valueOf(ns).ordinal();\n+      String name \u003d xattr.removeChildStr(\"name\");\n+      String valStr \u003d xattr.removeChildStr(\"val\");\n+      byte[] val \u003d null;\n+      if (valStr \u003d\u003d null) {\n+        String valHex \u003d xattr.removeChildStr(\"valHex\");\n+        if (valHex \u003d\u003d null) {\n+          throw new IOException(\"\u003cxattr\u003e had no \u003cval\u003e or \u003cvalHex\u003e entry.\");\n+        }\n+        val \u003d new HexBinaryAdapter().unmarshal(valHex);\n+      } else {\n+        val \u003d valStr.getBytes(\"UTF8\");\n+      }\n+      b.setValue(ByteString.copyFrom(val));\n+\n+      // The XAttrCompactProto name field uses a fairly complex format\n+      // to encode both the string table ID of the xattr name and the\n+      // namespace ID.  See the protobuf file for details.\n+      int nameId \u003d registerStringId(name);\n+      int encodedName \u003d (nameId \u003c\u003c XATTR_NAME_OFFSET) |\n+          ((nsIdx \u0026 XATTR_NAMESPACE_MASK) \u003c\u003c XATTR_NAMESPACE_OFFSET) |\n+          (((nsIdx \u003e\u003e 2) \u0026 XATTR_NAMESPACE_EXT_MASK)\n+              \u003c\u003c XATTR_NAMESPACE_EXT_OFFSET);\n+      b.setName(encodedName);\n+      xattr.verifyNoRemainingKeys(\"xattr\");\n+      bld.addXAttrs(b);\n+    }\n+    xattrs.verifyNoRemainingKeys(\"xattrs\");\n+    return bld;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private INodeSection.XAttrFeatureProto.Builder xattrsXmlToProto(Node xattrs)\n      throws IOException {\n    INodeSection.XAttrFeatureProto.Builder bld \u003d\n        INodeSection.XAttrFeatureProto.newBuilder();\n    while (true) {\n      Node xattr \u003d xattrs.removeChild(\"xattr\");\n      if (xattr \u003d\u003d null) {\n        break;\n      }\n      INodeSection.XAttrCompactProto.Builder b \u003d\n          INodeSection.XAttrCompactProto.newBuilder();\n      String ns \u003d xattr.removeChildStr(\"ns\");\n      if (ns \u003d\u003d null) {\n        throw new IOException(\"\u003cxattr\u003e had no \u003cns\u003e entry.\");\n      }\n      int nsIdx \u003d XAttrProtos.XAttrProto.\n          XAttrNamespaceProto.valueOf(ns).ordinal();\n      String name \u003d xattr.removeChildStr(\"name\");\n      String valStr \u003d xattr.removeChildStr(\"val\");\n      byte[] val \u003d null;\n      if (valStr \u003d\u003d null) {\n        String valHex \u003d xattr.removeChildStr(\"valHex\");\n        if (valHex \u003d\u003d null) {\n          throw new IOException(\"\u003cxattr\u003e had no \u003cval\u003e or \u003cvalHex\u003e entry.\");\n        }\n        val \u003d new HexBinaryAdapter().unmarshal(valHex);\n      } else {\n        val \u003d valStr.getBytes(\"UTF8\");\n      }\n      b.setValue(ByteString.copyFrom(val));\n\n      // The XAttrCompactProto name field uses a fairly complex format\n      // to encode both the string table ID of the xattr name and the\n      // namespace ID.  See the protobuf file for details.\n      int nameId \u003d registerStringId(name);\n      int encodedName \u003d (nameId \u003c\u003c XATTR_NAME_OFFSET) |\n          ((nsIdx \u0026 XATTR_NAMESPACE_MASK) \u003c\u003c XATTR_NAMESPACE_OFFSET) |\n          (((nsIdx \u003e\u003e 2) \u0026 XATTR_NAMESPACE_EXT_MASK)\n              \u003c\u003c XATTR_NAMESPACE_EXT_OFFSET);\n      b.setName(encodedName);\n      xattr.verifyNoRemainingKeys(\"xattr\");\n      bld.addXAttrs(b);\n    }\n    xattrs.verifyNoRemainingKeys(\"xattrs\");\n    return bld;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java"
    }
  }
}