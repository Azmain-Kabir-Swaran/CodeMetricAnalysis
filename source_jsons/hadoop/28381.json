{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AMRMClientRelayer.java",
  "functionName": "addNewAllocateRequest",
  "functionId": "addNewAllocateRequest___allocateRequest-AllocateRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java",
  "functionStartLine": 249,
  "functionEndLine": 306,
  "numCommitsSeen": 8,
  "timeTaken": 1552,
  "changeHistory": [
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
    "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9"
  ],
  "changeHistoryShort": {
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": "Ybodychange",
    "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8658. [AMRMProxy] Metrics for AMRMClientRelayer inside FederationInterceptor. Contributed by Young Chen.\n",
      "commitDate": "12/09/18 11:46 AM",
      "commitName": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "20/08/18 12:22 PM",
      "commitNameOld": "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 22.97,
      "commitsBetweenForRepo": 175,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,58 @@\n   private void addNewAllocateRequest(AllocateRequest allocateRequest)\n       throws YarnException {\n     // update the data structures first\n     addNewAsks(allocateRequest.getAskList());\n \n     if (allocateRequest.getReleaseList() !\u003d null) {\n       this.remotePendingRelease.addAll(allocateRequest.getReleaseList());\n       this.release.addAll(allocateRequest.getReleaseList());\n     }\n \n     if (allocateRequest.getResourceBlacklistRequest() !\u003d null) {\n       if (allocateRequest.getResourceBlacklistRequest()\n           .getBlacklistAdditions() !\u003d null) {\n         this.remoteBlacklistedNodes.addAll(allocateRequest\n             .getResourceBlacklistRequest().getBlacklistAdditions());\n         this.blacklistAdditions.addAll(allocateRequest\n             .getResourceBlacklistRequest().getBlacklistAdditions());\n       }\n       if (allocateRequest.getResourceBlacklistRequest()\n           .getBlacklistRemovals() !\u003d null) {\n         this.remoteBlacklistedNodes.removeAll(allocateRequest\n             .getResourceBlacklistRequest().getBlacklistRemovals());\n         this.blacklistRemovals.addAll(allocateRequest\n             .getResourceBlacklistRequest().getBlacklistRemovals());\n       }\n     }\n \n     if (allocateRequest.getUpdateRequests() !\u003d null) {\n       for (UpdateContainerRequest update : allocateRequest\n           .getUpdateRequests()) {\n-        this.remotePendingChange.put(update.getContainerId(), update);\n+        UpdateContainerRequest req \u003d\n+            this.remotePendingChange.put(update.getContainerId(), update);\n+        this.changeTimeStamp\n+            .put(update.getContainerId(), System.currentTimeMillis());\n+        if (req \u003d\u003d null) {\n+          // If this is a brand new request, all we have to do is increment\n+          this.metrics\n+              .incrClientPending(rmId, update.getContainerUpdateType(), 1);\n+        } else if (req.getContainerUpdateType() !\u003d update\n+            .getContainerUpdateType()) {\n+          // If this is replacing a request with a different update type, we\n+          // need to decrement the replaced type\n+          this.metrics\n+              .decrClientPending(rmId, req.getContainerUpdateType(), 1);\n+          this.metrics\n+              .incrClientPending(rmId, update.getContainerUpdateType(), 1);\n+        }\n         this.change.put(update.getContainerId(), update);\n       }\n     }\n \n     if (allocateRequest.getSchedulingRequests() !\u003d null) {\n       AMRMClientUtils.addToOutstandingSchedulingRequests(\n           allocateRequest.getSchedulingRequests(),\n           this.remotePendingSchedRequest);\n       this.schedulingRequest.addAll(allocateRequest.getSchedulingRequests());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void addNewAllocateRequest(AllocateRequest allocateRequest)\n      throws YarnException {\n    // update the data structures first\n    addNewAsks(allocateRequest.getAskList());\n\n    if (allocateRequest.getReleaseList() !\u003d null) {\n      this.remotePendingRelease.addAll(allocateRequest.getReleaseList());\n      this.release.addAll(allocateRequest.getReleaseList());\n    }\n\n    if (allocateRequest.getResourceBlacklistRequest() !\u003d null) {\n      if (allocateRequest.getResourceBlacklistRequest()\n          .getBlacklistAdditions() !\u003d null) {\n        this.remoteBlacklistedNodes.addAll(allocateRequest\n            .getResourceBlacklistRequest().getBlacklistAdditions());\n        this.blacklistAdditions.addAll(allocateRequest\n            .getResourceBlacklistRequest().getBlacklistAdditions());\n      }\n      if (allocateRequest.getResourceBlacklistRequest()\n          .getBlacklistRemovals() !\u003d null) {\n        this.remoteBlacklistedNodes.removeAll(allocateRequest\n            .getResourceBlacklistRequest().getBlacklistRemovals());\n        this.blacklistRemovals.addAll(allocateRequest\n            .getResourceBlacklistRequest().getBlacklistRemovals());\n      }\n    }\n\n    if (allocateRequest.getUpdateRequests() !\u003d null) {\n      for (UpdateContainerRequest update : allocateRequest\n          .getUpdateRequests()) {\n        UpdateContainerRequest req \u003d\n            this.remotePendingChange.put(update.getContainerId(), update);\n        this.changeTimeStamp\n            .put(update.getContainerId(), System.currentTimeMillis());\n        if (req \u003d\u003d null) {\n          // If this is a brand new request, all we have to do is increment\n          this.metrics\n              .incrClientPending(rmId, update.getContainerUpdateType(), 1);\n        } else if (req.getContainerUpdateType() !\u003d update\n            .getContainerUpdateType()) {\n          // If this is replacing a request with a different update type, we\n          // need to decrement the replaced type\n          this.metrics\n              .decrClientPending(rmId, req.getContainerUpdateType(), 1);\n          this.metrics\n              .incrClientPending(rmId, update.getContainerUpdateType(), 1);\n        }\n        this.change.put(update.getContainerId(), update);\n      }\n    }\n\n    if (allocateRequest.getSchedulingRequests() !\u003d null) {\n      AMRMClientUtils.addToOutstandingSchedulingRequests(\n          allocateRequest.getSchedulingRequests(),\n          this.remotePendingSchedRequest);\n      this.schedulingRequest.addAll(allocateRequest.getSchedulingRequests());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java",
      "extendedDetails": {}
    },
    "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-8673. [AMRMProxy] More robust responseId resync after an YarnRM master slave switch. Contributed by Botong Huang.\n",
      "commitDate": "20/08/18 12:22 PM",
      "commitName": "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "diff": "@@ -0,0 +1,42 @@\n+  private void addNewAllocateRequest(AllocateRequest allocateRequest)\n+      throws YarnException {\n+    // update the data structures first\n+    addNewAsks(allocateRequest.getAskList());\n+\n+    if (allocateRequest.getReleaseList() !\u003d null) {\n+      this.remotePendingRelease.addAll(allocateRequest.getReleaseList());\n+      this.release.addAll(allocateRequest.getReleaseList());\n+    }\n+\n+    if (allocateRequest.getResourceBlacklistRequest() !\u003d null) {\n+      if (allocateRequest.getResourceBlacklistRequest()\n+          .getBlacklistAdditions() !\u003d null) {\n+        this.remoteBlacklistedNodes.addAll(allocateRequest\n+            .getResourceBlacklistRequest().getBlacklistAdditions());\n+        this.blacklistAdditions.addAll(allocateRequest\n+            .getResourceBlacklistRequest().getBlacklistAdditions());\n+      }\n+      if (allocateRequest.getResourceBlacklistRequest()\n+          .getBlacklistRemovals() !\u003d null) {\n+        this.remoteBlacklistedNodes.removeAll(allocateRequest\n+            .getResourceBlacklistRequest().getBlacklistRemovals());\n+        this.blacklistRemovals.addAll(allocateRequest\n+            .getResourceBlacklistRequest().getBlacklistRemovals());\n+      }\n+    }\n+\n+    if (allocateRequest.getUpdateRequests() !\u003d null) {\n+      for (UpdateContainerRequest update : allocateRequest\n+          .getUpdateRequests()) {\n+        this.remotePendingChange.put(update.getContainerId(), update);\n+        this.change.put(update.getContainerId(), update);\n+      }\n+    }\n+\n+    if (allocateRequest.getSchedulingRequests() !\u003d null) {\n+      AMRMClientUtils.addToOutstandingSchedulingRequests(\n+          allocateRequest.getSchedulingRequests(),\n+          this.remotePendingSchedRequest);\n+      this.schedulingRequest.addAll(allocateRequest.getSchedulingRequests());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void addNewAllocateRequest(AllocateRequest allocateRequest)\n      throws YarnException {\n    // update the data structures first\n    addNewAsks(allocateRequest.getAskList());\n\n    if (allocateRequest.getReleaseList() !\u003d null) {\n      this.remotePendingRelease.addAll(allocateRequest.getReleaseList());\n      this.release.addAll(allocateRequest.getReleaseList());\n    }\n\n    if (allocateRequest.getResourceBlacklistRequest() !\u003d null) {\n      if (allocateRequest.getResourceBlacklistRequest()\n          .getBlacklistAdditions() !\u003d null) {\n        this.remoteBlacklistedNodes.addAll(allocateRequest\n            .getResourceBlacklistRequest().getBlacklistAdditions());\n        this.blacklistAdditions.addAll(allocateRequest\n            .getResourceBlacklistRequest().getBlacklistAdditions());\n      }\n      if (allocateRequest.getResourceBlacklistRequest()\n          .getBlacklistRemovals() !\u003d null) {\n        this.remoteBlacklistedNodes.removeAll(allocateRequest\n            .getResourceBlacklistRequest().getBlacklistRemovals());\n        this.blacklistRemovals.addAll(allocateRequest\n            .getResourceBlacklistRequest().getBlacklistRemovals());\n      }\n    }\n\n    if (allocateRequest.getUpdateRequests() !\u003d null) {\n      for (UpdateContainerRequest update : allocateRequest\n          .getUpdateRequests()) {\n        this.remotePendingChange.put(update.getContainerId(), update);\n        this.change.put(update.getContainerId(), update);\n      }\n    }\n\n    if (allocateRequest.getSchedulingRequests() !\u003d null) {\n      AMRMClientUtils.addToOutstandingSchedulingRequests(\n          allocateRequest.getSchedulingRequests(),\n          this.remotePendingSchedRequest);\n      this.schedulingRequest.addAll(allocateRequest.getSchedulingRequests());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java"
    }
  }
}