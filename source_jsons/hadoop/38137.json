{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FifoIntraQueuePreemptionPlugin.java",
  "functionName": "skipContainerBasedOnIntraQueuePolicy",
  "functionId": "skipContainerBasedOnIntraQueuePolicy___app-FiCaSchedulerApp__clusterResource-Resource__usedResource-Resource__c-RMContainer",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoIntraQueuePreemptionPlugin.java",
  "functionStartLine": 598,
  "functionEndLine": 630,
  "numCommitsSeen": 11,
  "timeTaken": 2209,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 375.5,
      "commitsBetweenForRepo": 2190,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,33 @@\n   public boolean skipContainerBasedOnIntraQueuePolicy(FiCaSchedulerApp app,\n       Resource clusterResource, Resource usedResource, RMContainer c) {\n     // Ensure below checks\n     // 1. This check must be done only when preemption order is USERLIMIT_FIRST\n     // 2. By selecting container \"c\", check whether this user\u0027s resource usage\n     // is going below its user-limit.\n     // 3. Used resource of user must be always greater than user-limit to\n     // skip some containers as per this check. If used resource is under user\n     // limit, then these containers of this user has to be preempted as demand\n     // might be due to high priority apps running in same user.\n     String partition \u003d context.getScheduler()\n         .getSchedulerNode(c.getAllocatedNode()).getPartition();\n-    TempQueuePerPartition tq \u003d context.getQueueByPartition(app.getQueueName(),\n-        partition);\n+    String queuePath \u003d\n+        context.getScheduler().getQueue(app.getQueueName()).getQueuePath();\n+    TempQueuePerPartition tq \u003d\n+        context.getQueueByPartition(queuePath, partition);\n     TempUserPerPartition tmpUser \u003d tq.getUsersPerPartition().get(app.getUser());\n \n     // Given user is not present, skip the check.\n     if (tmpUser \u003d\u003d null) {\n       return false;\n     }\n \n     // For ideal resource computations, user-limit got saved by subtracting am\n     // used resource in TempUser. Hence it has to be added back here for\n     // complete check.\n     Resource userLimit \u003d Resources.add(tmpUser.getUserLimit(), tmpUser.amUsed);\n \n     return Resources.lessThanOrEqual(rc, clusterResource,\n         Resources.subtract(usedResource, c.getAllocatedResource()), userLimit)\n         \u0026\u0026 context.getIntraQueuePreemptionOrderPolicy()\n             .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean skipContainerBasedOnIntraQueuePolicy(FiCaSchedulerApp app,\n      Resource clusterResource, Resource usedResource, RMContainer c) {\n    // Ensure below checks\n    // 1. This check must be done only when preemption order is USERLIMIT_FIRST\n    // 2. By selecting container \"c\", check whether this user\u0027s resource usage\n    // is going below its user-limit.\n    // 3. Used resource of user must be always greater than user-limit to\n    // skip some containers as per this check. If used resource is under user\n    // limit, then these containers of this user has to be preempted as demand\n    // might be due to high priority apps running in same user.\n    String partition \u003d context.getScheduler()\n        .getSchedulerNode(c.getAllocatedNode()).getPartition();\n    String queuePath \u003d\n        context.getScheduler().getQueue(app.getQueueName()).getQueuePath();\n    TempQueuePerPartition tq \u003d\n        context.getQueueByPartition(queuePath, partition);\n    TempUserPerPartition tmpUser \u003d tq.getUsersPerPartition().get(app.getUser());\n\n    // Given user is not present, skip the check.\n    if (tmpUser \u003d\u003d null) {\n      return false;\n    }\n\n    // For ideal resource computations, user-limit got saved by subtracting am\n    // used resource in TempUser. Hence it has to be added back here for\n    // complete check.\n    Resource userLimit \u003d Resources.add(tmpUser.getUserLimit(), tmpUser.amUsed);\n\n    return Resources.lessThanOrEqual(rc, clusterResource,\n        Resources.subtract(usedResource, c.getAllocatedResource()), userLimit)\n        \u0026\u0026 context.getIntraQueuePreemptionOrderPolicy()\n            .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoIntraQueuePreemptionPlugin.java",
      "extendedDetails": {}
    },
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2113. Add cross-user preemption within CapacityScheduler\u0027s leaf-queue. (Sunil G via wangda)\n\nChange-Id: I9b19f69788068be05b3295247cdd7b972f8a573c\n",
      "commitDate": "22/05/17 2:26 PM",
      "commitName": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,31 @@\n+  public boolean skipContainerBasedOnIntraQueuePolicy(FiCaSchedulerApp app,\n+      Resource clusterResource, Resource usedResource, RMContainer c) {\n+    // Ensure below checks\n+    // 1. This check must be done only when preemption order is USERLIMIT_FIRST\n+    // 2. By selecting container \"c\", check whether this user\u0027s resource usage\n+    // is going below its user-limit.\n+    // 3. Used resource of user must be always greater than user-limit to\n+    // skip some containers as per this check. If used resource is under user\n+    // limit, then these containers of this user has to be preempted as demand\n+    // might be due to high priority apps running in same user.\n+    String partition \u003d context.getScheduler()\n+        .getSchedulerNode(c.getAllocatedNode()).getPartition();\n+    TempQueuePerPartition tq \u003d context.getQueueByPartition(app.getQueueName(),\n+        partition);\n+    TempUserPerPartition tmpUser \u003d tq.getUsersPerPartition().get(app.getUser());\n+\n+    // Given user is not present, skip the check.\n+    if (tmpUser \u003d\u003d null) {\n+      return false;\n+    }\n+\n+    // For ideal resource computations, user-limit got saved by subtracting am\n+    // used resource in TempUser. Hence it has to be added back here for\n+    // complete check.\n+    Resource userLimit \u003d Resources.add(tmpUser.getUserLimit(), tmpUser.amUsed);\n+\n+    return Resources.lessThanOrEqual(rc, clusterResource,\n+        Resources.subtract(usedResource, c.getAllocatedResource()), userLimit)\n+        \u0026\u0026 context.getIntraQueuePreemptionOrderPolicy()\n+            .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean skipContainerBasedOnIntraQueuePolicy(FiCaSchedulerApp app,\n      Resource clusterResource, Resource usedResource, RMContainer c) {\n    // Ensure below checks\n    // 1. This check must be done only when preemption order is USERLIMIT_FIRST\n    // 2. By selecting container \"c\", check whether this user\u0027s resource usage\n    // is going below its user-limit.\n    // 3. Used resource of user must be always greater than user-limit to\n    // skip some containers as per this check. If used resource is under user\n    // limit, then these containers of this user has to be preempted as demand\n    // might be due to high priority apps running in same user.\n    String partition \u003d context.getScheduler()\n        .getSchedulerNode(c.getAllocatedNode()).getPartition();\n    TempQueuePerPartition tq \u003d context.getQueueByPartition(app.getQueueName(),\n        partition);\n    TempUserPerPartition tmpUser \u003d tq.getUsersPerPartition().get(app.getUser());\n\n    // Given user is not present, skip the check.\n    if (tmpUser \u003d\u003d null) {\n      return false;\n    }\n\n    // For ideal resource computations, user-limit got saved by subtracting am\n    // used resource in TempUser. Hence it has to be added back here for\n    // complete check.\n    Resource userLimit \u003d Resources.add(tmpUser.getUserLimit(), tmpUser.amUsed);\n\n    return Resources.lessThanOrEqual(rc, clusterResource,\n        Resources.subtract(usedResource, c.getAllocatedResource()), userLimit)\n        \u0026\u0026 context.getIntraQueuePreemptionOrderPolicy()\n            .equals(IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoIntraQueuePreemptionPlugin.java"
    }
  }
}