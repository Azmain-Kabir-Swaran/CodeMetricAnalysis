{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMWebServices.java",
  "functionName": "getApps",
  "functionId": "getApps___hsr-HttpServletRequest(annotations-@Context)__stateQuery-String(annotations-@QueryParam(RMWSConsts.STATE))__statesQuery-Set__String__(annotations-@QueryParam(RMWSConsts.STATES))__finalStatusQuery-String(annotations-@QueryParam(RMWSConsts.FINAL_STATUS))__userQuery-String(annotations-@QueryParam(RMWSConsts.USER))__queueQuery-String(annotations-@QueryParam(RMWSConsts.QUEUE))__limit-String(annotations-@QueryParam(RMWSConsts.LIMIT))__startedBegin-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_BEGIN))__startedEnd-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_END))__finishBegin-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_BEGIN))__finishEnd-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_END))__applicationTypes-Set__String__(annotations-@QueryParam(RMWSConsts.APPLICATION_TYPES))__applicationTags-Set__String__(annotations-@QueryParam(RMWSConsts.APPLICATION_TAGS))__name-String(annotations-@QueryParam(RMWSConsts.NAME))__unselectedFields-Set__String__(annotations-@QueryParam(RMWSConsts.DESELECTS))",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
  "functionStartLine": 603,
  "functionEndLine": 690,
  "numCommitsSeen": 387,
  "timeTaken": 13098,
  "changeHistory": [
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
    "10144a580e4647eb7d3d59d043608ffbf8cf090d",
    "5836e0a46bf9793e0a61bb8ec46536f4a67d38d7",
    "c05b5d424b000bab766f57e88a07f2b4e9a56647",
    "d76fbbc9b82e720d7d5188f9ae2f56a8d78f3a98",
    "ef3ecc308dbea41c6a88bd4d16739c7bbc10cdda",
    "312b1fd9da2781da97f8c76fe1262c4d99b9c37f",
    "acda6b96a4e92e432bd1d97fa14004a11e70387e",
    "c1edca101c32a5999100bc6031784274d416b599",
    "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd",
    "edcecedc1c39d54db0f86a1325b4db26c38d2d4d",
    "da2fb2bc46bddf42d79c6d7664cbf0311973709e",
    "990cffdcfa9349fff0cee144b1d0e5267c40f63d",
    "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
    "72c6d6255a86225ae1771fcc15e46aff7a4cc384",
    "4ea295016e20add7ab45ddc558acf77a8f1f5925",
    "03ae82a311c033318496111d3dbd77bbaaa990b6",
    "1c133ffb72094a832b1d6c4b641821c6e2a7f9b2",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "e7583d816a69677bbaa4280deb58ea73dbc42cef",
    "01ce7ba3a4af867763e437ce46a4f5e1d6e5a6bf",
    "0ea8570be578be60e2f32849900a1c50506d78d3"
  ],
  "changeHistoryShort": {
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411": "Ymultichange(Yparameterchange,Ybodychange)",
    "10144a580e4647eb7d3d59d043608ffbf8cf090d": "Ybodychange",
    "5836e0a46bf9793e0a61bb8ec46536f4a67d38d7": "Ymultichange(Yparameterchange,Ybodychange)",
    "c05b5d424b000bab766f57e88a07f2b4e9a56647": "Ybodychange",
    "d76fbbc9b82e720d7d5188f9ae2f56a8d78f3a98": "Ybodychange",
    "ef3ecc308dbea41c6a88bd4d16739c7bbc10cdda": "Ybodychange",
    "312b1fd9da2781da97f8c76fe1262c4d99b9c37f": "Ybodychange",
    "acda6b96a4e92e432bd1d97fa14004a11e70387e": "Yparametermetachange",
    "c1edca101c32a5999100bc6031784274d416b599": "Ymultichange(Yparameterchange,Ybodychange)",
    "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd": "Yparametermetachange",
    "edcecedc1c39d54db0f86a1325b4db26c38d2d4d": "Ybodychange",
    "da2fb2bc46bddf42d79c6d7664cbf0311973709e": "Ybodychange",
    "990cffdcfa9349fff0cee144b1d0e5267c40f63d": "Ybodychange",
    "ebe0c17a95ae37d4768f2928ea193e89db34ead5": "Ymultichange(Yparameterchange,Ybodychange)",
    "72c6d6255a86225ae1771fcc15e46aff7a4cc384": "Ybodychange",
    "4ea295016e20add7ab45ddc558acf77a8f1f5925": "Ybodychange",
    "03ae82a311c033318496111d3dbd77bbaaa990b6": "Ymultichange(Yparameterchange,Ybodychange)",
    "1c133ffb72094a832b1d6c4b641821c6e2a7f9b2": "Ymultichange(Yparameterchange,Ybodychange)",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "e7583d816a69677bbaa4280deb58ea73dbc42cef": "Ybodychange",
    "01ce7ba3a4af867763e437ce46a4f5e1d6e5a6bf": "Ymultichange(Yparameterchange,Ybodychange)",
    "0ea8570be578be60e2f32849900a1c50506d78d3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-10035. Add ability to filter the Cluster Applications API request by name. Contributed by Adam Antal\n",
      "commitDate": "06/01/20 7:26 AM",
      "commitName": "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
      "commitAuthor": "Szilard Nemeth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-10035. Add ability to filter the Cluster Applications API request by name. Contributed by Adam Antal\n",
          "commitDate": "06/01/20 7:26 AM",
          "commitName": "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "18/12/19 10:48 AM",
          "commitNameOld": "fddc3d55c3e309936216b8c61944e113509999e2",
          "commitAuthorOld": "Jonathan Hung",
          "daysBetweenCommits": 18.86,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,86 +1,88 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n       @QueryParam(RMWSConsts.LIMIT) String limit,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n       @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n+      @QueryParam(RMWSConsts.NAME) String name,\n       @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n \n     initForReadableEndpoints();\n \n     GetApplicationsRequest request \u003d\n             ApplicationsRequestBuilder.create()\n                     .withStateQuery(stateQuery)\n                     .withStatesQuery(statesQuery)\n                     .withUserQuery(userQuery)\n                     .withQueueQuery(rm, queueQuery)\n                     .withLimit(limit)\n                     .withStartedTimeBegin(startedBegin)\n                     .withStartedTimeEnd(startedEnd)\n                     .withFinishTimeBegin(finishBegin)\n                     .withFinishTimeEnd(finishEnd)\n                     .withApplicationTypes(applicationTypes)\n                     .withApplicationTags(applicationTags)\n+                    .withName(name)\n             .build();\n \n     List\u003cApplicationReport\u003e appReports;\n     try {\n       appReports \u003d rm.getClientRMService().getApplications(request)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       DeSelectFields deSelectFields \u003d new DeSelectFields();\n       deSelectFields.initFields(unselectedFields);\n \n       boolean allowAccess \u003d hasAccess(rmapp, hsr);\n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n       if (filterAppsByUser \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n           WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n \n     if (filterInvalidXMLChars) {\n       final String format \u003d hsr.getHeader(HttpHeaders.ACCEPT);\n       if (format !\u003d null \u0026\u0026\n           format.toLowerCase().contains(MediaType.APPLICATION_XML)) {\n         for (AppInfo appInfo : allApps.getApps()) {\n           appInfo.setNote(escapeInvalidXMLCharacters(appInfo.getNote()));\n         }\n       }\n     }\n \n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String limit,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(RMWSConsts.NAME) String name,\n      @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n\n    initForReadableEndpoints();\n\n    GetApplicationsRequest request \u003d\n            ApplicationsRequestBuilder.create()\n                    .withStateQuery(stateQuery)\n                    .withStatesQuery(statesQuery)\n                    .withUserQuery(userQuery)\n                    .withQueueQuery(rm, queueQuery)\n                    .withLimit(limit)\n                    .withStartedTimeBegin(startedBegin)\n                    .withStartedTimeEnd(startedEnd)\n                    .withFinishTimeBegin(finishBegin)\n                    .withFinishTimeEnd(finishEnd)\n                    .withApplicationTypes(applicationTypes)\n                    .withApplicationTags(applicationTags)\n                    .withName(name)\n            .build();\n\n    List\u003cApplicationReport\u003e appReports;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      boolean allowAccess \u003d hasAccess(rmapp, hsr);\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n\n    if (filterInvalidXMLChars) {\n      final String format \u003d hsr.getHeader(HttpHeaders.ACCEPT);\n      if (format !\u003d null \u0026\u0026\n          format.toLowerCase().contains(MediaType.APPLICATION_XML)) {\n        for (AppInfo appInfo : allApps.getApps()) {\n          appInfo.setNote(escapeInvalidXMLCharacters(appInfo.getNote()));\n        }\n      }\n    }\n\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {
            "oldValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(RMWSConsts.STATE)), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.STATES)), finalStatusQuery-String(annotations-@QueryParam(RMWSConsts.FINAL_STATUS)), userQuery-String(annotations-@QueryParam(RMWSConsts.USER)), queueQuery-String(annotations-@QueryParam(RMWSConsts.QUEUE)), limit-String(annotations-@QueryParam(RMWSConsts.LIMIT)), startedBegin-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_BEGIN)), startedEnd-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_END)), finishBegin-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_BEGIN)), finishEnd-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_END)), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TYPES)), applicationTags-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TAGS)), unselectedFields-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.DESELECTS))]",
            "newValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(RMWSConsts.STATE)), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.STATES)), finalStatusQuery-String(annotations-@QueryParam(RMWSConsts.FINAL_STATUS)), userQuery-String(annotations-@QueryParam(RMWSConsts.USER)), queueQuery-String(annotations-@QueryParam(RMWSConsts.QUEUE)), limit-String(annotations-@QueryParam(RMWSConsts.LIMIT)), startedBegin-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_BEGIN)), startedEnd-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_END)), finishBegin-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_BEGIN)), finishEnd-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_END)), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TYPES)), applicationTags-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TAGS)), name-String(annotations-@QueryParam(RMWSConsts.NAME)), unselectedFields-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.DESELECTS))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-10035. Add ability to filter the Cluster Applications API request by name. Contributed by Adam Antal\n",
          "commitDate": "06/01/20 7:26 AM",
          "commitName": "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "18/12/19 10:48 AM",
          "commitNameOld": "fddc3d55c3e309936216b8c61944e113509999e2",
          "commitAuthorOld": "Jonathan Hung",
          "daysBetweenCommits": 18.86,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,86 +1,88 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n       @QueryParam(RMWSConsts.LIMIT) String limit,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n       @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n+      @QueryParam(RMWSConsts.NAME) String name,\n       @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n \n     initForReadableEndpoints();\n \n     GetApplicationsRequest request \u003d\n             ApplicationsRequestBuilder.create()\n                     .withStateQuery(stateQuery)\n                     .withStatesQuery(statesQuery)\n                     .withUserQuery(userQuery)\n                     .withQueueQuery(rm, queueQuery)\n                     .withLimit(limit)\n                     .withStartedTimeBegin(startedBegin)\n                     .withStartedTimeEnd(startedEnd)\n                     .withFinishTimeBegin(finishBegin)\n                     .withFinishTimeEnd(finishEnd)\n                     .withApplicationTypes(applicationTypes)\n                     .withApplicationTags(applicationTags)\n+                    .withName(name)\n             .build();\n \n     List\u003cApplicationReport\u003e appReports;\n     try {\n       appReports \u003d rm.getClientRMService().getApplications(request)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       DeSelectFields deSelectFields \u003d new DeSelectFields();\n       deSelectFields.initFields(unselectedFields);\n \n       boolean allowAccess \u003d hasAccess(rmapp, hsr);\n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n       if (filterAppsByUser \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n           WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n \n     if (filterInvalidXMLChars) {\n       final String format \u003d hsr.getHeader(HttpHeaders.ACCEPT);\n       if (format !\u003d null \u0026\u0026\n           format.toLowerCase().contains(MediaType.APPLICATION_XML)) {\n         for (AppInfo appInfo : allApps.getApps()) {\n           appInfo.setNote(escapeInvalidXMLCharacters(appInfo.getNote()));\n         }\n       }\n     }\n \n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String limit,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(RMWSConsts.NAME) String name,\n      @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n\n    initForReadableEndpoints();\n\n    GetApplicationsRequest request \u003d\n            ApplicationsRequestBuilder.create()\n                    .withStateQuery(stateQuery)\n                    .withStatesQuery(statesQuery)\n                    .withUserQuery(userQuery)\n                    .withQueueQuery(rm, queueQuery)\n                    .withLimit(limit)\n                    .withStartedTimeBegin(startedBegin)\n                    .withStartedTimeEnd(startedEnd)\n                    .withFinishTimeBegin(finishBegin)\n                    .withFinishTimeEnd(finishEnd)\n                    .withApplicationTypes(applicationTypes)\n                    .withApplicationTags(applicationTags)\n                    .withName(name)\n            .build();\n\n    List\u003cApplicationReport\u003e appReports;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      boolean allowAccess \u003d hasAccess(rmapp, hsr);\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n\n    if (filterInvalidXMLChars) {\n      final String format \u003d hsr.getHeader(HttpHeaders.ACCEPT);\n      if (format !\u003d null \u0026\u0026\n          format.toLowerCase().contains(MediaType.APPLICATION_XML)) {\n        for (AppInfo appInfo : allApps.getApps()) {\n          appInfo.setNote(escapeInvalidXMLCharacters(appInfo.getNote()));\n        }\n      }\n    }\n\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "10144a580e4647eb7d3d59d043608ffbf8cf090d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9728. Bugfix for escaping illegal xml characters for Resource Manager REST API.\n           Contributed by Prabhu Joseph\n",
      "commitDate": "10/09/19 2:04 PM",
      "commitName": "10144a580e4647eb7d3d59d043608ffbf8cf090d",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "29/08/19 3:14 AM",
      "commitNameOld": "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 12.45,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,86 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n       @QueryParam(RMWSConsts.LIMIT) String limit,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n       @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n       @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n \n     initForReadableEndpoints();\n \n     GetApplicationsRequest request \u003d\n             ApplicationsRequestBuilder.create()\n                     .withStateQuery(stateQuery)\n                     .withStatesQuery(statesQuery)\n                     .withUserQuery(userQuery)\n                     .withQueueQuery(rm, queueQuery)\n                     .withLimit(limit)\n                     .withStartedTimeBegin(startedBegin)\n                     .withStartedTimeEnd(startedEnd)\n                     .withFinishTimeBegin(finishBegin)\n                     .withFinishTimeEnd(finishEnd)\n                     .withApplicationTypes(applicationTypes)\n                     .withApplicationTags(applicationTags)\n             .build();\n \n     List\u003cApplicationReport\u003e appReports;\n     try {\n       appReports \u003d rm.getClientRMService().getApplications(request)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       DeSelectFields deSelectFields \u003d new DeSelectFields();\n       deSelectFields.initFields(unselectedFields);\n \n       boolean allowAccess \u003d hasAccess(rmapp, hsr);\n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n       if (filterAppsByUser \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n           WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n+\n+    if (filterInvalidXMLChars) {\n+      final String format \u003d hsr.getHeader(HttpHeaders.ACCEPT);\n+      if (format !\u003d null \u0026\u0026\n+          format.toLowerCase().contains(MediaType.APPLICATION_XML)) {\n+        for (AppInfo appInfo : allApps.getApps()) {\n+          appInfo.setNote(escapeInvalidXMLCharacters(appInfo.getNote()));\n+        }\n+      }\n+    }\n+\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String limit,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n\n    initForReadableEndpoints();\n\n    GetApplicationsRequest request \u003d\n            ApplicationsRequestBuilder.create()\n                    .withStateQuery(stateQuery)\n                    .withStatesQuery(statesQuery)\n                    .withUserQuery(userQuery)\n                    .withQueueQuery(rm, queueQuery)\n                    .withLimit(limit)\n                    .withStartedTimeBegin(startedBegin)\n                    .withStartedTimeEnd(startedEnd)\n                    .withFinishTimeBegin(finishBegin)\n                    .withFinishTimeEnd(finishEnd)\n                    .withApplicationTypes(applicationTypes)\n                    .withApplicationTags(applicationTags)\n            .build();\n\n    List\u003cApplicationReport\u003e appReports;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      boolean allowAccess \u003d hasAccess(rmapp, hsr);\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n\n    if (filterInvalidXMLChars) {\n      final String format \u003d hsr.getHeader(HttpHeaders.ACCEPT);\n      if (format !\u003d null \u0026\u0026\n          format.toLowerCase().contains(MediaType.APPLICATION_XML)) {\n        for (AppInfo appInfo : allApps.getApps()) {\n          appInfo.setNote(escapeInvalidXMLCharacters(appInfo.getNote()));\n        }\n      }\n    }\n\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "5836e0a46bf9793e0a61bb8ec46536f4a67d38d7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8501. Reduce complexity of RMWebServices getApps method.\n           Contributed by Szilard Nemeth\n",
      "commitDate": "19/07/18 9:30 AM",
      "commitName": "5836e0a46bf9793e0a61bb8ec46536f4a67d38d7",
      "commitAuthor": "Eric Yang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8501. Reduce complexity of RMWebServices getApps method.\n           Contributed by Szilard Nemeth\n",
          "commitDate": "19/07/18 9:30 AM",
          "commitName": "5836e0a46bf9793e0a61bb8ec46536f4a67d38d7",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "10/07/18 10:36 AM",
          "commitNameOld": "82ac3aa6d0a83235cfac2805a444dd26efe5f9ce",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 8.95,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,188 +1,75 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n-      @QueryParam(RMWSConsts.LIMIT) String count,\n+      @QueryParam(RMWSConsts.LIMIT) String limit,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n       @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n       @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n \n     initForReadableEndpoints();\n \n-    boolean checkCount \u003d false;\n-    boolean checkStart \u003d false;\n-    boolean checkEnd \u003d false;\n-    boolean checkAppTypes \u003d false;\n-    boolean checkAppStates \u003d false;\n-    boolean checkAppTags \u003d false;\n-    long countNum \u003d 0;\n+    GetApplicationsRequest request \u003d\n+            ApplicationsRequestBuilder.create()\n+                    .withStateQuery(stateQuery)\n+                    .withStatesQuery(statesQuery)\n+                    .withUserQuery(userQuery)\n+                    .withQueueQuery(rm, queueQuery)\n+                    .withLimit(limit)\n+                    .withStartedTimeBegin(startedBegin)\n+                    .withStartedTimeEnd(startedEnd)\n+                    .withFinishTimeBegin(finishBegin)\n+                    .withFinishTimeEnd(finishEnd)\n+                    .withApplicationTypes(applicationTypes)\n+                    .withApplicationTags(applicationTags)\n+            .build();\n \n-    // set values suitable in case both of begin/end not specified\n-    long sBegin \u003d 0;\n-    long sEnd \u003d Long.MAX_VALUE;\n-    long fBegin \u003d 0;\n-    long fEnd \u003d Long.MAX_VALUE;\n-\n-    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n-      checkCount \u003d true;\n-      countNum \u003d Long.parseLong(count);\n-      if (countNum \u003c\u003d 0) {\n-        throw new BadRequestException(\"limit value must be greater then 0\");\n-      }\n-    }\n-\n-    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n-      checkStart \u003d true;\n-      sBegin \u003d Long.parseLong(startedBegin);\n-      if (sBegin \u003c 0) {\n-        throw new BadRequestException(\n-            \"startedTimeBegin must be greater than 0\");\n-      }\n-    }\n-    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n-      checkStart \u003d true;\n-      sEnd \u003d Long.parseLong(startedEnd);\n-      if (sEnd \u003c 0) {\n-        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n-      }\n-    }\n-    if (sBegin \u003e sEnd) {\n-      throw new BadRequestException(\n-          \"startedTimeEnd must be greater than startTimeBegin\");\n-    }\n-\n-    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n-      checkEnd \u003d true;\n-      fBegin \u003d Long.parseLong(finishBegin);\n-      if (fBegin \u003c 0) {\n-        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n-      }\n-    }\n-    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n-      checkEnd \u003d true;\n-      fEnd \u003d Long.parseLong(finishEnd);\n-      if (fEnd \u003c 0) {\n-        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n-      }\n-    }\n-    if (fBegin \u003e fEnd) {\n-      throw new BadRequestException(\n-          \"finishTimeEnd must be greater than finishTimeBegin\");\n-    }\n-\n-    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n-    if (!appTypes.isEmpty()) {\n-      checkAppTypes \u003d true;\n-    }\n-\n-    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n-    if (!appTags.isEmpty()) {\n-      checkAppTags \u003d true;\n-    }\n-\n-    // stateQuery is deprecated.\n-    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n-      statesQuery.add(stateQuery);\n-    }\n-    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n-    if (!appStates.isEmpty()) {\n-      checkAppStates \u003d true;\n-    }\n-\n-    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n-\n-    if (checkStart) {\n-      request.setStartRange(sBegin, sEnd);\n-    }\n-\n-    if (checkEnd) {\n-      request.setFinishRange(fBegin, fEnd);\n-    }\n-\n-    if (checkCount) {\n-      request.setLimit(countNum);\n-    }\n-\n-    if (checkAppTypes) {\n-      request.setApplicationTypes(appTypes);\n-    }\n-\n-    if (checkAppTags) {\n-      request.setApplicationTags(appTags);\n-    }\n-\n-    if (checkAppStates) {\n-      request.setApplicationStates(appStates);\n-    }\n-\n-    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n-      ResourceScheduler rs \u003d rm.getResourceScheduler();\n-      if (rs instanceof CapacityScheduler) {\n-        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n-        // validate queue exists\n-        try {\n-          cs.getQueueInfo(queueQuery, false, false);\n-        } catch (IOException e) {\n-          throw new BadRequestException(e.getMessage());\n-        }\n-      }\n-      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n-      queues.add(queueQuery);\n-      request.setQueues(queues);\n-    }\n-\n-    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n-      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n-      users.add(userQuery);\n-      request.setUsers(users);\n-    }\n-\n-    List\u003cApplicationReport\u003e appReports \u003d null;\n+    List\u003cApplicationReport\u003e appReports;\n     try {\n       appReports \u003d rm.getClientRMService().getApplications(request)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       DeSelectFields deSelectFields \u003d new DeSelectFields();\n       deSelectFields.initFields(unselectedFields);\n \n       boolean allowAccess \u003d hasAccess(rmapp, hsr);\n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n       if (filterAppsByUser \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n           WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String limit,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n\n    initForReadableEndpoints();\n\n    GetApplicationsRequest request \u003d\n            ApplicationsRequestBuilder.create()\n                    .withStateQuery(stateQuery)\n                    .withStatesQuery(statesQuery)\n                    .withUserQuery(userQuery)\n                    .withQueueQuery(rm, queueQuery)\n                    .withLimit(limit)\n                    .withStartedTimeBegin(startedBegin)\n                    .withStartedTimeEnd(startedEnd)\n                    .withFinishTimeBegin(finishBegin)\n                    .withFinishTimeEnd(finishEnd)\n                    .withApplicationTypes(applicationTypes)\n                    .withApplicationTags(applicationTags)\n            .build();\n\n    List\u003cApplicationReport\u003e appReports;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      boolean allowAccess \u003d hasAccess(rmapp, hsr);\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {
            "oldValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(RMWSConsts.STATE)), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.STATES)), finalStatusQuery-String(annotations-@QueryParam(RMWSConsts.FINAL_STATUS)), userQuery-String(annotations-@QueryParam(RMWSConsts.USER)), queueQuery-String(annotations-@QueryParam(RMWSConsts.QUEUE)), count-String(annotations-@QueryParam(RMWSConsts.LIMIT)), startedBegin-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_BEGIN)), startedEnd-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_END)), finishBegin-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_BEGIN)), finishEnd-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_END)), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TYPES)), applicationTags-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TAGS)), unselectedFields-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.DESELECTS))]",
            "newValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(RMWSConsts.STATE)), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.STATES)), finalStatusQuery-String(annotations-@QueryParam(RMWSConsts.FINAL_STATUS)), userQuery-String(annotations-@QueryParam(RMWSConsts.USER)), queueQuery-String(annotations-@QueryParam(RMWSConsts.QUEUE)), limit-String(annotations-@QueryParam(RMWSConsts.LIMIT)), startedBegin-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_BEGIN)), startedEnd-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_END)), finishBegin-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_BEGIN)), finishEnd-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_END)), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TYPES)), applicationTags-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TAGS)), unselectedFields-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.DESELECTS))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8501. Reduce complexity of RMWebServices getApps method.\n           Contributed by Szilard Nemeth\n",
          "commitDate": "19/07/18 9:30 AM",
          "commitName": "5836e0a46bf9793e0a61bb8ec46536f4a67d38d7",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "10/07/18 10:36 AM",
          "commitNameOld": "82ac3aa6d0a83235cfac2805a444dd26efe5f9ce",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 8.95,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,188 +1,75 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n-      @QueryParam(RMWSConsts.LIMIT) String count,\n+      @QueryParam(RMWSConsts.LIMIT) String limit,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n       @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n       @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n \n     initForReadableEndpoints();\n \n-    boolean checkCount \u003d false;\n-    boolean checkStart \u003d false;\n-    boolean checkEnd \u003d false;\n-    boolean checkAppTypes \u003d false;\n-    boolean checkAppStates \u003d false;\n-    boolean checkAppTags \u003d false;\n-    long countNum \u003d 0;\n+    GetApplicationsRequest request \u003d\n+            ApplicationsRequestBuilder.create()\n+                    .withStateQuery(stateQuery)\n+                    .withStatesQuery(statesQuery)\n+                    .withUserQuery(userQuery)\n+                    .withQueueQuery(rm, queueQuery)\n+                    .withLimit(limit)\n+                    .withStartedTimeBegin(startedBegin)\n+                    .withStartedTimeEnd(startedEnd)\n+                    .withFinishTimeBegin(finishBegin)\n+                    .withFinishTimeEnd(finishEnd)\n+                    .withApplicationTypes(applicationTypes)\n+                    .withApplicationTags(applicationTags)\n+            .build();\n \n-    // set values suitable in case both of begin/end not specified\n-    long sBegin \u003d 0;\n-    long sEnd \u003d Long.MAX_VALUE;\n-    long fBegin \u003d 0;\n-    long fEnd \u003d Long.MAX_VALUE;\n-\n-    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n-      checkCount \u003d true;\n-      countNum \u003d Long.parseLong(count);\n-      if (countNum \u003c\u003d 0) {\n-        throw new BadRequestException(\"limit value must be greater then 0\");\n-      }\n-    }\n-\n-    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n-      checkStart \u003d true;\n-      sBegin \u003d Long.parseLong(startedBegin);\n-      if (sBegin \u003c 0) {\n-        throw new BadRequestException(\n-            \"startedTimeBegin must be greater than 0\");\n-      }\n-    }\n-    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n-      checkStart \u003d true;\n-      sEnd \u003d Long.parseLong(startedEnd);\n-      if (sEnd \u003c 0) {\n-        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n-      }\n-    }\n-    if (sBegin \u003e sEnd) {\n-      throw new BadRequestException(\n-          \"startedTimeEnd must be greater than startTimeBegin\");\n-    }\n-\n-    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n-      checkEnd \u003d true;\n-      fBegin \u003d Long.parseLong(finishBegin);\n-      if (fBegin \u003c 0) {\n-        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n-      }\n-    }\n-    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n-      checkEnd \u003d true;\n-      fEnd \u003d Long.parseLong(finishEnd);\n-      if (fEnd \u003c 0) {\n-        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n-      }\n-    }\n-    if (fBegin \u003e fEnd) {\n-      throw new BadRequestException(\n-          \"finishTimeEnd must be greater than finishTimeBegin\");\n-    }\n-\n-    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n-    if (!appTypes.isEmpty()) {\n-      checkAppTypes \u003d true;\n-    }\n-\n-    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n-    if (!appTags.isEmpty()) {\n-      checkAppTags \u003d true;\n-    }\n-\n-    // stateQuery is deprecated.\n-    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n-      statesQuery.add(stateQuery);\n-    }\n-    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n-    if (!appStates.isEmpty()) {\n-      checkAppStates \u003d true;\n-    }\n-\n-    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n-\n-    if (checkStart) {\n-      request.setStartRange(sBegin, sEnd);\n-    }\n-\n-    if (checkEnd) {\n-      request.setFinishRange(fBegin, fEnd);\n-    }\n-\n-    if (checkCount) {\n-      request.setLimit(countNum);\n-    }\n-\n-    if (checkAppTypes) {\n-      request.setApplicationTypes(appTypes);\n-    }\n-\n-    if (checkAppTags) {\n-      request.setApplicationTags(appTags);\n-    }\n-\n-    if (checkAppStates) {\n-      request.setApplicationStates(appStates);\n-    }\n-\n-    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n-      ResourceScheduler rs \u003d rm.getResourceScheduler();\n-      if (rs instanceof CapacityScheduler) {\n-        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n-        // validate queue exists\n-        try {\n-          cs.getQueueInfo(queueQuery, false, false);\n-        } catch (IOException e) {\n-          throw new BadRequestException(e.getMessage());\n-        }\n-      }\n-      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n-      queues.add(queueQuery);\n-      request.setQueues(queues);\n-    }\n-\n-    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n-      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n-      users.add(userQuery);\n-      request.setUsers(users);\n-    }\n-\n-    List\u003cApplicationReport\u003e appReports \u003d null;\n+    List\u003cApplicationReport\u003e appReports;\n     try {\n       appReports \u003d rm.getClientRMService().getApplications(request)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       DeSelectFields deSelectFields \u003d new DeSelectFields();\n       deSelectFields.initFields(unselectedFields);\n \n       boolean allowAccess \u003d hasAccess(rmapp, hsr);\n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n       if (filterAppsByUser \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n           WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String limit,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n\n    initForReadableEndpoints();\n\n    GetApplicationsRequest request \u003d\n            ApplicationsRequestBuilder.create()\n                    .withStateQuery(stateQuery)\n                    .withStatesQuery(statesQuery)\n                    .withUserQuery(userQuery)\n                    .withQueueQuery(rm, queueQuery)\n                    .withLimit(limit)\n                    .withStartedTimeBegin(startedBegin)\n                    .withStartedTimeEnd(startedEnd)\n                    .withFinishTimeBegin(finishBegin)\n                    .withFinishTimeEnd(finishEnd)\n                    .withApplicationTypes(applicationTypes)\n                    .withApplicationTags(applicationTags)\n            .build();\n\n    List\u003cApplicationReport\u003e appReports;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      boolean allowAccess \u003d hasAccess(rmapp, hsr);\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "c05b5d424b000bab766f57e88a07f2b4e9a56647": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8319. More YARN pages need to honor yarn.resourcemanager.display.per-user-apps. Contributed by Sunil G.\n",
      "commitDate": "24/05/18 1:49 AM",
      "commitName": "c05b5d424b000bab766f57e88a07f2b4e9a56647",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "10/05/18 7:05 PM",
      "commitNameOld": "d76fbbc9b82e720d7d5188f9ae2f56a8d78f3a98",
      "commitAuthorOld": "Vinod Kumar Vavilapalli (I am also known as @tshooter.)",
      "daysBetweenCommits": 13.28,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,188 +1,188 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n       @QueryParam(RMWSConsts.LIMIT) String count,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n       @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n       @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n \n     initForReadableEndpoints();\n \n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\n             \"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n     if (!appTags.isEmpty()) {\n       checkAppTags \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n     if (checkAppTags) {\n       request.setApplicationTags(appTags);\n     }\n \n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       appReports \u003d rm.getClientRMService().getApplications(request)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       DeSelectFields deSelectFields \u003d new DeSelectFields();\n       deSelectFields.initFields(unselectedFields);\n \n       boolean allowAccess \u003d hasAccess(rmapp, hsr);\n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n-      if (displayPerUserApps \u0026\u0026 !allowAccess) {\n+      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n           WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String count,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n\n    initForReadableEndpoints();\n\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\n            \"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      boolean allowAccess \u003d hasAccess(rmapp, hsr);\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (filterAppsByUser \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "d76fbbc9b82e720d7d5188f9ae2f56a8d78f3a98": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8249. Fixed few REST APIs in RMWebServices to have static-user check. Contributed by Sunil Govindan.\n",
      "commitDate": "10/05/18 7:05 PM",
      "commitName": "d76fbbc9b82e720d7d5188f9ae2f56a8d78f3a98",
      "commitAuthor": "Vinod Kumar Vavilapalli (I am also known as @tshooter.)",
      "commitDateOld": "27/04/18 10:28 AM",
      "commitNameOld": "ef3ecc308dbea41c6a88bd4d16739c7bbc10cdda",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 13.36,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,186 +1,188 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n       @QueryParam(RMWSConsts.LIMIT) String count,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n       @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n       @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n+\n+    initForReadableEndpoints();\n+\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n-    init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\n             \"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n     if (!appTags.isEmpty()) {\n       checkAppTags \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n     if (checkAppTags) {\n       request.setApplicationTags(appTags);\n     }\n \n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       appReports \u003d rm.getClientRMService().getApplications(request)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       DeSelectFields deSelectFields \u003d new DeSelectFields();\n       deSelectFields.initFields(unselectedFields);\n \n       boolean allowAccess \u003d hasAccess(rmapp, hsr);\n       // Given RM is configured to display apps per user, skip apps to which\n       // this caller doesn\u0027t have access to view.\n       if (displayPerUserApps \u0026\u0026 !allowAccess) {\n         continue;\n       }\n \n       AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n           WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String count,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n\n    initForReadableEndpoints();\n\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\n            \"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      boolean allowAccess \u003d hasAccess(rmapp, hsr);\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (displayPerUserApps \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "ef3ecc308dbea41c6a88bd4d16739c7bbc10cdda": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8221. RMWebServices also need to honor yarn.resourcemanager.display.per-user-apps. Contributed by Sunil G.\n",
      "commitDate": "27/04/18 10:28 AM",
      "commitName": "ef3ecc308dbea41c6a88bd4d16739c7bbc10cdda",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "02/04/18 3:22 PM",
      "commitNameOld": "c78cb18c61a0565b9697ab5bbf4d186e43e82f55",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 24.8,
      "commitsBetweenForRepo": 682,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,179 +1,186 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n       @QueryParam(RMWSConsts.LIMIT) String count,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n       @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n       @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\n             \"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n     if (!appTags.isEmpty()) {\n       checkAppTags \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n     if (checkAppTags) {\n       request.setApplicationTags(appTags);\n     }\n \n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       appReports \u003d rm.getClientRMService().getApplications(request)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       DeSelectFields deSelectFields \u003d new DeSelectFields();\n       deSelectFields.initFields(unselectedFields);\n \n-      AppInfo app \u003d new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),\n+      boolean allowAccess \u003d hasAccess(rmapp, hsr);\n+      // Given RM is configured to display apps per user, skip apps to which\n+      // this caller doesn\u0027t have access to view.\n+      if (displayPerUserApps \u0026\u0026 !allowAccess) {\n+        continue;\n+      }\n+\n+      AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n           WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String count,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\n            \"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      boolean allowAccess \u003d hasAccess(rmapp, hsr);\n      // Given RM is configured to display apps per user, skip apps to which\n      // this caller doesn\u0027t have access to view.\n      if (displayPerUserApps \u0026\u0026 !allowAccess) {\n        continue;\n      }\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, allowAccess,\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "312b1fd9da2781da97f8c76fe1262c4d99b9c37f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7076. yarn application -list -appTypes is not working. Contributed by Jian He.\n",
      "commitDate": "28/08/17 6:26 PM",
      "commitName": "312b1fd9da2781da97f8c76fe1262c4d99b9c37f",
      "commitAuthor": "Junping Du",
      "commitDateOld": "01/08/17 5:28 PM",
      "commitNameOld": "acda6b96a4e92e432bd1d97fa14004a11e70387e",
      "commitAuthorOld": "Carlo Curino",
      "daysBetweenCommits": 27.04,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,179 +1,179 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n       @QueryParam(RMWSConsts.LIMIT) String count,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n       @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n       @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\n             \"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n     if (!appTags.isEmpty()) {\n       checkAppTags \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n     if (checkAppTags) {\n       request.setApplicationTags(appTags);\n     }\n \n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n-      appReports \u003d rm.getClientRMService().getApplications(request, false)\n+      appReports \u003d rm.getClientRMService().getApplications(request)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       DeSelectFields deSelectFields \u003d new DeSelectFields();\n       deSelectFields.initFields(unselectedFields);\n \n       AppInfo app \u003d new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),\n           WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String count,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\n            \"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "acda6b96a4e92e432bd1d97fa14004a11e70387e": {
      "type": "Yparametermetachange",
      "commitMessage": "YARN-5412. Create a proxy chain for ResourceManager REST API in the Router. (Contributed by Giovanni Matteo Fumarola via curino)\n\n(cherry picked from commit b6240b92abf453affc5fd64e1eedf2d29842aa75)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "acda6b96a4e92e432bd1d97fa14004a11e70387e",
      "commitAuthor": "Carlo Curino",
      "commitDateOld": "28/07/17 3:44 PM",
      "commitNameOld": "bcde66bed1e41b5644811fe90bfbf3d56827db36",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 4.07,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,179 +1,179 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n       @QueryParam(RMWSConsts.LIMIT) String count,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n       @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n-      @QueryParam(\"deSelects\") Set\u003cString\u003e unselectedFields) {\n+      @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\n             \"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n     if (!appTags.isEmpty()) {\n       checkAppTags \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n     if (checkAppTags) {\n       request.setApplicationTags(appTags);\n     }\n \n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       appReports \u003d rm.getClientRMService().getApplications(request, false)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       DeSelectFields deSelectFields \u003d new DeSelectFields();\n       deSelectFields.initFields(unselectedFields);\n \n       AppInfo app \u003d new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),\n           WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String count,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(RMWSConsts.DESELECTS) Set\u003cString\u003e unselectedFields) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\n            \"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request, false)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {
        "oldValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(RMWSConsts.STATE)), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.STATES)), finalStatusQuery-String(annotations-@QueryParam(RMWSConsts.FINAL_STATUS)), userQuery-String(annotations-@QueryParam(RMWSConsts.USER)), queueQuery-String(annotations-@QueryParam(RMWSConsts.QUEUE)), count-String(annotations-@QueryParam(RMWSConsts.LIMIT)), startedBegin-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_BEGIN)), startedEnd-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_END)), finishBegin-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_BEGIN)), finishEnd-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_END)), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TYPES)), applicationTags-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TAGS)), unselectedFields-Set\u003cString\u003e(annotations-@QueryParam(\"deSelects\"))]",
        "newValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(RMWSConsts.STATE)), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.STATES)), finalStatusQuery-String(annotations-@QueryParam(RMWSConsts.FINAL_STATUS)), userQuery-String(annotations-@QueryParam(RMWSConsts.USER)), queueQuery-String(annotations-@QueryParam(RMWSConsts.QUEUE)), count-String(annotations-@QueryParam(RMWSConsts.LIMIT)), startedBegin-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_BEGIN)), startedEnd-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_END)), finishBegin-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_BEGIN)), finishEnd-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_END)), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TYPES)), applicationTags-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TAGS)), unselectedFields-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.DESELECTS))]"
      }
    },
    "c1edca101c32a5999100bc6031784274d416b599": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6280. Introduce deselect query param to skip ResourceRequest from getApp/getApps REST API. Contributed by Lantao Jin.\n",
      "commitDate": "28/06/17 3:40 PM",
      "commitName": "c1edca101c32a5999100bc6031784274d416b599",
      "commitAuthor": "Sunil G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6280. Introduce deselect query param to skip ResourceRequest from getApp/getApps REST API. Contributed by Lantao Jin.\n",
          "commitDate": "28/06/17 3:40 PM",
          "commitName": "c1edca101c32a5999100bc6031784274d416b599",
          "commitAuthor": "Sunil G",
          "commitDateOld": "07/06/17 1:41 PM",
          "commitNameOld": "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd",
          "commitAuthorOld": "Carlo Curino",
          "daysBetweenCommits": 21.08,
          "commitsBetweenForRepo": 101,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,175 +1,179 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n       @QueryParam(RMWSConsts.LIMIT) String count,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n-      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags) {\n+      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n+      @QueryParam(\"deSelects\") Set\u003cString\u003e unselectedFields) {\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\n             \"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n     if (!appTags.isEmpty()) {\n       checkAppTags \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n     if (checkAppTags) {\n       request.setApplicationTags(appTags);\n     }\n \n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       appReports \u003d rm.getClientRMService().getApplications(request, false)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n+      DeSelectFields deSelectFields \u003d new DeSelectFields();\n+      deSelectFields.initFields(unselectedFields);\n+\n       AppInfo app \u003d new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),\n-          WebAppUtils.getHttpSchemePrefix(conf));\n+          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String count,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(\"deSelects\") Set\u003cString\u003e unselectedFields) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\n            \"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request, false)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {
            "oldValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(RMWSConsts.STATE)), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.STATES)), finalStatusQuery-String(annotations-@QueryParam(RMWSConsts.FINAL_STATUS)), userQuery-String(annotations-@QueryParam(RMWSConsts.USER)), queueQuery-String(annotations-@QueryParam(RMWSConsts.QUEUE)), count-String(annotations-@QueryParam(RMWSConsts.LIMIT)), startedBegin-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_BEGIN)), startedEnd-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_END)), finishBegin-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_BEGIN)), finishEnd-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_END)), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TYPES)), applicationTags-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TAGS))]",
            "newValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(RMWSConsts.STATE)), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.STATES)), finalStatusQuery-String(annotations-@QueryParam(RMWSConsts.FINAL_STATUS)), userQuery-String(annotations-@QueryParam(RMWSConsts.USER)), queueQuery-String(annotations-@QueryParam(RMWSConsts.QUEUE)), count-String(annotations-@QueryParam(RMWSConsts.LIMIT)), startedBegin-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_BEGIN)), startedEnd-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_END)), finishBegin-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_BEGIN)), finishEnd-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_END)), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TYPES)), applicationTags-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TAGS)), unselectedFields-Set\u003cString\u003e(annotations-@QueryParam(\"deSelects\"))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6280. Introduce deselect query param to skip ResourceRequest from getApp/getApps REST API. Contributed by Lantao Jin.\n",
          "commitDate": "28/06/17 3:40 PM",
          "commitName": "c1edca101c32a5999100bc6031784274d416b599",
          "commitAuthor": "Sunil G",
          "commitDateOld": "07/06/17 1:41 PM",
          "commitNameOld": "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd",
          "commitAuthorOld": "Carlo Curino",
          "daysBetweenCommits": 21.08,
          "commitsBetweenForRepo": 101,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,175 +1,179 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(RMWSConsts.STATE) String stateQuery,\n       @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n       @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n       @QueryParam(RMWSConsts.USER) String userQuery,\n       @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n       @QueryParam(RMWSConsts.LIMIT) String count,\n       @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n       @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n       @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n       @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n       @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n-      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags) {\n+      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n+      @QueryParam(\"deSelects\") Set\u003cString\u003e unselectedFields) {\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\n             \"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n     if (!appTags.isEmpty()) {\n       checkAppTags \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n     if (checkAppTags) {\n       request.setApplicationTags(appTags);\n     }\n \n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       appReports \u003d rm.getClientRMService().getApplications(request, false)\n           .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n+      DeSelectFields deSelectFields \u003d new DeSelectFields();\n+      deSelectFields.initFields(unselectedFields);\n+\n       AppInfo app \u003d new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),\n-          WebAppUtils.getHttpSchemePrefix(conf));\n+          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String count,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags,\n      @QueryParam(\"deSelects\") Set\u003cString\u003e unselectedFields) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\n            \"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request, false)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      DeSelectFields deSelectFields \u003d new DeSelectFields();\n      deSelectFields.initFields(unselectedFields);\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),\n          WebAppUtils.getHttpSchemePrefix(conf), deSelectFields);\n      allApps.add(app);\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd": {
      "type": "Yparametermetachange",
      "commitMessage": "YARN-6634. [API] Refactor ResourceManager WebServices to make API explicit. (Giovanni Matteo Fumarola via curino)\n",
      "commitDate": "07/06/17 1:41 PM",
      "commitName": "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd",
      "commitAuthor": "Carlo Curino",
      "commitDateOld": "08/12/16 2:23 AM",
      "commitNameOld": "74d0066d3392169bec872f438a0818e2f5323010",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 181.43,
      "commitsBetweenForRepo": 954,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,174 +1,175 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n-      @QueryParam(\"state\") String stateQuery,\n-      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n-      @QueryParam(\"finalStatus\") String finalStatusQuery,\n-      @QueryParam(\"user\") String userQuery,\n-      @QueryParam(\"queue\") String queueQuery,\n-      @QueryParam(\"limit\") String count,\n-      @QueryParam(\"startedTimeBegin\") String startedBegin,\n-      @QueryParam(\"startedTimeEnd\") String startedEnd,\n-      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n-      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n-      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes,\n-      @QueryParam(\"applicationTags\") Set\u003cString\u003e applicationTags) {\n+      @QueryParam(RMWSConsts.STATE) String stateQuery,\n+      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n+      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n+      @QueryParam(RMWSConsts.USER) String userQuery,\n+      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n+      @QueryParam(RMWSConsts.LIMIT) String count,\n+      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n+      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n+      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n+      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n+      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n+      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags) {\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n-        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n+        throw new BadRequestException(\n+            \"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n     if (!appTags.isEmpty()) {\n       checkAppTags \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n     if (checkAppTags) {\n       request.setApplicationTags(appTags);\n     }\n \n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n-      appReports \u003d rm.getClientRMService()\n-          .getApplications(request, false).getApplicationList();\n+      appReports \u003d rm.getClientRMService().getApplications(request, false)\n+          .getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n-      AppInfo app \u003d new AppInfo(rm, rmapp,\n-          hasAccess(rmapp, hsr), WebAppUtils.getHttpSchemePrefix(conf));\n+      AppInfo app \u003d new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),\n+          WebAppUtils.getHttpSchemePrefix(conf));\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(RMWSConsts.STATE) String stateQuery,\n      @QueryParam(RMWSConsts.STATES) Set\u003cString\u003e statesQuery,\n      @QueryParam(RMWSConsts.FINAL_STATUS) String finalStatusQuery,\n      @QueryParam(RMWSConsts.USER) String userQuery,\n      @QueryParam(RMWSConsts.QUEUE) String queueQuery,\n      @QueryParam(RMWSConsts.LIMIT) String count,\n      @QueryParam(RMWSConsts.STARTED_TIME_BEGIN) String startedBegin,\n      @QueryParam(RMWSConsts.STARTED_TIME_END) String startedEnd,\n      @QueryParam(RMWSConsts.FINISHED_TIME_BEGIN) String finishBegin,\n      @QueryParam(RMWSConsts.FINISHED_TIME_END) String finishEnd,\n      @QueryParam(RMWSConsts.APPLICATION_TYPES) Set\u003cString\u003e applicationTypes,\n      @QueryParam(RMWSConsts.APPLICATION_TAGS) Set\u003cString\u003e applicationTags) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\n            \"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService().getApplications(request, false)\n          .getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      AppInfo app \u003d new AppInfo(rm, rmapp, hasAccess(rmapp, hsr),\n          WebAppUtils.getHttpSchemePrefix(conf));\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {
        "oldValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(\"state\")), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(\"states\")), finalStatusQuery-String(annotations-@QueryParam(\"finalStatus\")), userQuery-String(annotations-@QueryParam(\"user\")), queueQuery-String(annotations-@QueryParam(\"queue\")), count-String(annotations-@QueryParam(\"limit\")), startedBegin-String(annotations-@QueryParam(\"startedTimeBegin\")), startedEnd-String(annotations-@QueryParam(\"startedTimeEnd\")), finishBegin-String(annotations-@QueryParam(\"finishedTimeBegin\")), finishEnd-String(annotations-@QueryParam(\"finishedTimeEnd\")), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(\"applicationTypes\")), applicationTags-Set\u003cString\u003e(annotations-@QueryParam(\"applicationTags\"))]",
        "newValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(RMWSConsts.STATE)), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.STATES)), finalStatusQuery-String(annotations-@QueryParam(RMWSConsts.FINAL_STATUS)), userQuery-String(annotations-@QueryParam(RMWSConsts.USER)), queueQuery-String(annotations-@QueryParam(RMWSConsts.QUEUE)), count-String(annotations-@QueryParam(RMWSConsts.LIMIT)), startedBegin-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_BEGIN)), startedEnd-String(annotations-@QueryParam(RMWSConsts.STARTED_TIME_END)), finishBegin-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_BEGIN)), finishEnd-String(annotations-@QueryParam(RMWSConsts.FINISHED_TIME_END)), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TYPES)), applicationTags-Set\u003cString\u003e(annotations-@QueryParam(RMWSConsts.APPLICATION_TAGS))]"
      }
    },
    "edcecedc1c39d54db0f86a1325b4db26c38d2d4d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3262. Surface application outstanding resource requests table in RM web UI. (Jian He via wangda)\n",
      "commitDate": "27/02/15 4:13 PM",
      "commitName": "edcecedc1c39d54db0f86a1325b4db26c38d2d4d",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "24/02/15 7:32 AM",
      "commitNameOld": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 3.36,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,174 +1,174 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n       @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd,\n       @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes,\n       @QueryParam(\"applicationTags\") Set\u003cString\u003e applicationTags) {\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n     if (!appTags.isEmpty()) {\n       checkAppTags \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n     if (checkAppTags) {\n       request.setApplicationTags(appTags);\n     }\n \n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       appReports \u003d rm.getClientRMService()\n           .getApplications(request, false).getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n       if (rmapp \u003d\u003d null) {\n         continue;\n       }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n-      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr),\n-          WebAppUtils.getHttpSchemePrefix(conf));\n+      AppInfo app \u003d new AppInfo(rm, rmapp,\n+          hasAccess(rmapp, hsr), WebAppUtils.getHttpSchemePrefix(conf));\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes,\n      @QueryParam(\"applicationTags\") Set\u003cString\u003e applicationTags) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService()\n          .getApplications(request, false).getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      AppInfo app \u003d new AppInfo(rm, rmapp,\n          hasAccess(rmapp, hsr), WebAppUtils.getHttpSchemePrefix(conf));\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "da2fb2bc46bddf42d79c6d7664cbf0311973709e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3143. RM Apps REST API can return NPE or entries missing id and other fields. Contributed by Jason Lowe\n",
      "commitDate": "06/02/15 1:47 PM",
      "commitName": "da2fb2bc46bddf42d79c6d7664cbf0311973709e",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "06/01/15 2:37 PM",
      "commitNameOld": "60103fca04dc713183e4ec9e12f961642e7d1001",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 30.97,
      "commitsBetweenForRepo": 250,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,174 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n       @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd,\n       @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes,\n       @QueryParam(\"applicationTags\") Set\u003cString\u003e applicationTags) {\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n     if (!appTags.isEmpty()) {\n       checkAppTags \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n     if (checkAppTags) {\n       request.setApplicationTags(appTags);\n     }\n \n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       appReports \u003d rm.getClientRMService()\n           .getApplications(request, false).getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n+      if (rmapp \u003d\u003d null) {\n+        continue;\n+      }\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr),\n           WebAppUtils.getHttpSchemePrefix(conf));\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes,\n      @QueryParam(\"applicationTags\") Set\u003cString\u003e applicationTags) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService()\n          .getApplications(request, false).getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n      if (rmapp \u003d\u003d null) {\n        continue;\n      }\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr),\n          WebAppUtils.getHttpSchemePrefix(conf));\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "990cffdcfa9349fff0cee144b1d0e5267c40f63d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1553. Modified YARN and MR to stop using HttpConfig.isSecure() and\ninstead rely on the http policy framework. And also fix some bugs related\nto https handling in YARN web-apps. Contributed by Haohui Mai.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1568501 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/02/14 12:01 PM",
      "commitName": "990cffdcfa9349fff0cee144b1d0e5267c40f63d",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "04/02/14 8:55 PM",
      "commitNameOld": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 9.63,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,170 +1,171 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n       @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd,\n       @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes,\n       @QueryParam(\"applicationTags\") Set\u003cString\u003e applicationTags) {\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n     if (!appTags.isEmpty()) {\n       checkAppTags \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n     if (checkAppTags) {\n       request.setApplicationTags(appTags);\n     }\n \n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       appReports \u003d rm.getClientRMService()\n           .getApplications(request, false).getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n-      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n+      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr),\n+          WebAppUtils.getHttpSchemePrefix(conf));\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes,\n      @QueryParam(\"applicationTags\") Set\u003cString\u003e applicationTags) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService()\n          .getApplications(request, false).getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr),\n          WebAppUtils.getHttpSchemePrefix(conf));\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "ebe0c17a95ae37d4768f2928ea193e89db34ead5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1461. Added tags for YARN applications and changed RM to handle them. Contributed by Karthik Kambatla.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564633 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/02/14 8:55 PM",
      "commitName": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
      "commitAuthor": "Zhijie Shen",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1461. Added tags for YARN applications and changed RM to handle them. Contributed by Karthik Kambatla.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564633 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/02/14 8:55 PM",
          "commitName": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "11/11/13 1:49 PM",
          "commitNameOld": "72c6d6255a86225ae1771fcc15e46aff7a4cc384",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 85.3,
          "commitsBetweenForRepo": 484,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,159 +1,170 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n       @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd,\n-      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n+      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes,\n+      @QueryParam(\"applicationTags\") Set\u003cString\u003e applicationTags) {\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n+    boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n+    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n+    if (!appTags.isEmpty()) {\n+      checkAppTags \u003d true;\n+    }\n+\n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n+    if (checkAppTags) {\n+      request.setApplicationTags(appTags);\n+    }\n+\n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       appReports \u003d rm.getClientRMService()\n           .getApplications(request, false).getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes,\n      @QueryParam(\"applicationTags\") Set\u003cString\u003e applicationTags) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService()\n          .getApplications(request, false).getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n      allApps.add(app);\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {
            "oldValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(\"state\")), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(\"states\")), finalStatusQuery-String(annotations-@QueryParam(\"finalStatus\")), userQuery-String(annotations-@QueryParam(\"user\")), queueQuery-String(annotations-@QueryParam(\"queue\")), count-String(annotations-@QueryParam(\"limit\")), startedBegin-String(annotations-@QueryParam(\"startedTimeBegin\")), startedEnd-String(annotations-@QueryParam(\"startedTimeEnd\")), finishBegin-String(annotations-@QueryParam(\"finishedTimeBegin\")), finishEnd-String(annotations-@QueryParam(\"finishedTimeEnd\")), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(\"applicationTypes\"))]",
            "newValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(\"state\")), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(\"states\")), finalStatusQuery-String(annotations-@QueryParam(\"finalStatus\")), userQuery-String(annotations-@QueryParam(\"user\")), queueQuery-String(annotations-@QueryParam(\"queue\")), count-String(annotations-@QueryParam(\"limit\")), startedBegin-String(annotations-@QueryParam(\"startedTimeBegin\")), startedEnd-String(annotations-@QueryParam(\"startedTimeEnd\")), finishBegin-String(annotations-@QueryParam(\"finishedTimeBegin\")), finishEnd-String(annotations-@QueryParam(\"finishedTimeEnd\")), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(\"applicationTypes\")), applicationTags-Set\u003cString\u003e(annotations-@QueryParam(\"applicationTags\"))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1461. Added tags for YARN applications and changed RM to handle them. Contributed by Karthik Kambatla.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564633 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/02/14 8:55 PM",
          "commitName": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "11/11/13 1:49 PM",
          "commitNameOld": "72c6d6255a86225ae1771fcc15e46aff7a4cc384",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 85.3,
          "commitsBetweenForRepo": 484,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,159 +1,170 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n       @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd,\n-      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n+      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes,\n+      @QueryParam(\"applicationTags\") Set\u003cString\u003e applicationTags) {\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n+    boolean checkAppTags \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n+    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n+    if (!appTags.isEmpty()) {\n+      checkAppTags \u003d true;\n+    }\n+\n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n \n     if (checkStart) {\n       request.setStartRange(sBegin, sEnd);\n     }\n \n     if (checkEnd) {\n       request.setFinishRange(fBegin, fEnd);\n     }\n \n     if (checkCount) {\n       request.setLimit(countNum);\n     }\n \n     if (checkAppTypes) {\n       request.setApplicationTypes(appTypes);\n     }\n \n+    if (checkAppTags) {\n+      request.setApplicationTags(appTags);\n+    }\n+\n     if (checkAppStates) {\n       request.setApplicationStates(appStates);\n     }\n \n     if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n       ResourceScheduler rs \u003d rm.getResourceScheduler();\n       if (rs instanceof CapacityScheduler) {\n         CapacityScheduler cs \u003d (CapacityScheduler) rs;\n         // validate queue exists\n         try {\n           cs.getQueueInfo(queueQuery, false, false);\n         } catch (IOException e) {\n           throw new BadRequestException(e.getMessage());\n         }\n       }\n       Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n       queues.add(queueQuery);\n       request.setQueues(queues);\n     }\n \n     if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n       Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n       users.add(userQuery);\n       request.setUsers(users);\n     }\n \n     List\u003cApplicationReport\u003e appReports \u003d null;\n     try {\n       appReports \u003d rm.getClientRMService()\n           .getApplications(request, false).getApplicationList();\n     } catch (YarnException e) {\n       LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n       throw new YarnRuntimeException(\n           \"Unable to retrieve apps from ClientRMService\", e);\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n         rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (ApplicationReport report : appReports) {\n       RMApp rmapp \u003d apps.get(report.getApplicationId());\n \n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n \n       AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n       allApps.add(app);\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes,\n      @QueryParam(\"applicationTags\") Set\u003cString\u003e applicationTags) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    boolean checkAppTags \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    Set\u003cString\u003e appTags \u003d parseQueries(applicationTags, false);\n    if (!appTags.isEmpty()) {\n      checkAppTags \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppTags) {\n      request.setApplicationTags(appTags);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService()\n          .getApplications(request, false).getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n      allApps.add(app);\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "72c6d6255a86225ae1771fcc15e46aff7a4cc384": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1387. RMWebServices should use ClientRMService for filtering applications (Karthik Kambatla via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1540851 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/11/13 1:49 PM",
      "commitName": "72c6d6255a86225ae1771fcc15e46aff7a4cc384",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "29/09/13 1:21 AM",
      "commitNameOld": "1c5b49eeafc2253d4fa92456e6ccf0f35290c889",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 43.56,
      "commitsBetweenForRepo": 271,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,159 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n       @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd,\n       @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n-    long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n     Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n-    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n-        .getRMApps();\n+    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n+\n+    if (checkStart) {\n+      request.setStartRange(sBegin, sEnd);\n+    }\n+\n+    if (checkEnd) {\n+      request.setFinishRange(fBegin, fEnd);\n+    }\n+\n+    if (checkCount) {\n+      request.setLimit(countNum);\n+    }\n+\n+    if (checkAppTypes) {\n+      request.setApplicationTypes(appTypes);\n+    }\n+\n+    if (checkAppStates) {\n+      request.setApplicationStates(appStates);\n+    }\n+\n+    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n+      ResourceScheduler rs \u003d rm.getResourceScheduler();\n+      if (rs instanceof CapacityScheduler) {\n+        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n+        // validate queue exists\n+        try {\n+          cs.getQueueInfo(queueQuery, false, false);\n+        } catch (IOException e) {\n+          throw new BadRequestException(e.getMessage());\n+        }\n+      }\n+      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n+      queues.add(queueQuery);\n+      request.setQueues(queues);\n+    }\n+\n+    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n+      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n+      users.add(userQuery);\n+      request.setUsers(users);\n+    }\n+\n+    List\u003cApplicationReport\u003e appReports \u003d null;\n+    try {\n+      appReports \u003d rm.getClientRMService()\n+          .getApplications(request, false).getApplicationList();\n+    } catch (YarnException e) {\n+      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n+      throw new YarnRuntimeException(\n+          \"Unable to retrieve apps from ClientRMService\", e);\n+    }\n+\n+    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n+        rm.getRMContext().getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n-    for (RMApp rmapp : apps.values()) {\n+    for (ApplicationReport report : appReports) {\n+      RMApp rmapp \u003d apps.get(report.getApplicationId());\n \n-      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n-        break;\n-      }\n-\n-      if (checkAppStates \u0026\u0026 !appStates.contains(\n-          rmapp.createApplicationState().toString().toLowerCase())) {\n-        continue;\n-      }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n-      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n-        if (!rmapp.getUser().equals(userQuery)) {\n-          continue;\n-        }\n-      }\n-      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n-        ResourceScheduler rs \u003d rm.getResourceScheduler();\n-        if (rs instanceof CapacityScheduler) {\n-          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n-          // validate queue exists\n-          try {\n-            cs.getQueueInfo(queueQuery, false, false);\n-          } catch (IOException e) {\n-            throw new BadRequestException(e.getMessage());\n-          }\n-        }\n-        if (!rmapp.getQueue().equals(queueQuery)) {\n-          continue;\n-        }\n-      }\n-      if (checkAppTypes \u0026\u0026 !appTypes.contains(\n-          rmapp.getApplicationType().trim().toLowerCase())) {\n-        continue;\n-      }\n \n-      if (checkStart\n-          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n-        continue;\n-      }\n-      if (checkEnd\n-          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n-        continue;\n-      }\n       AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n-\n       allApps.add(app);\n-      num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    GetApplicationsRequest request \u003d GetApplicationsRequest.newInstance();\n\n    if (checkStart) {\n      request.setStartRange(sBegin, sEnd);\n    }\n\n    if (checkEnd) {\n      request.setFinishRange(fBegin, fEnd);\n    }\n\n    if (checkCount) {\n      request.setLimit(countNum);\n    }\n\n    if (checkAppTypes) {\n      request.setApplicationTypes(appTypes);\n    }\n\n    if (checkAppStates) {\n      request.setApplicationStates(appStates);\n    }\n\n    if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n      ResourceScheduler rs \u003d rm.getResourceScheduler();\n      if (rs instanceof CapacityScheduler) {\n        CapacityScheduler cs \u003d (CapacityScheduler) rs;\n        // validate queue exists\n        try {\n          cs.getQueueInfo(queueQuery, false, false);\n        } catch (IOException e) {\n          throw new BadRequestException(e.getMessage());\n        }\n      }\n      Set\u003cString\u003e queues \u003d new HashSet\u003cString\u003e(1);\n      queues.add(queueQuery);\n      request.setQueues(queues);\n    }\n\n    if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n      Set\u003cString\u003e users \u003d new HashSet\u003cString\u003e(1);\n      users.add(userQuery);\n      request.setUsers(users);\n    }\n\n    List\u003cApplicationReport\u003e appReports \u003d null;\n    try {\n      appReports \u003d rm.getClientRMService()\n          .getApplications(request, false).getApplicationList();\n    } catch (YarnException e) {\n      LOG.error(\"Unable to retrieve apps from ClientRMService\", e);\n      throw new YarnRuntimeException(\n          \"Unable to retrieve apps from ClientRMService\", e);\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d\n        rm.getRMContext().getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (ApplicationReport report : appReports) {\n      RMApp rmapp \u003d apps.get(report.getApplicationId());\n\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n      allApps.add(app);\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "4ea295016e20add7ab45ddc558acf77a8f1f5925": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1001. Added a web-service to get statistics about per application-type per state for consumption by downstream projects. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1523855 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/09/13 5:24 PM",
      "commitName": "4ea295016e20add7ab45ddc558acf77a8f1f5925",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "07/09/13 12:28 AM",
      "commitNameOld": "03ae82a311c033318496111d3dbd77bbaaa990b6",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 9.71,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,184 +1,147 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n       @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd,\n       @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n     boolean checkAppStates \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n-    Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n-    if (!applicationTypes.isEmpty()) {\n-      for (String applicationType : applicationTypes) {\n-        if (applicationType !\u003d null \u0026\u0026 !applicationType.trim().isEmpty()) {\n-          if (applicationType.indexOf(\",\") \u003d\u003d -1) {\n-            appTypes.add(applicationType.trim());\n-          } else {\n-            String[] types \u003d applicationType.split(\",\");\n-            for (String type : types) {\n-              if (!type.trim().isEmpty()) {\n-                appTypes.add(type.trim());\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n+    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n-    String allAppStates;\n-    RMAppState[] stateArray \u003d RMAppState.values();\n-    allAppStates \u003d Arrays.toString(stateArray);\n-\n-    Set\u003cString\u003e appStates \u003d new HashSet\u003cString\u003e();\n     // stateQuery is deprecated.\n     if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n       statesQuery.add(stateQuery);\n     }\n-    if (!statesQuery.isEmpty()) {\n-      for (String applicationState : statesQuery) {\n-        if (applicationState !\u003d null \u0026\u0026 !applicationState.isEmpty()) {\n-          String[] states \u003d applicationState.split(\",\");\n-          for (String state : states) {\n-            try {\n-              RMAppState.valueOf(state.trim());\n-            } catch (IllegalArgumentException iae) {\n-              throw new BadRequestException(\n-                  \"Invalid application-state \" + state\n-                  + \" specified. It should be one of \" + allAppStates);\n-            }\n-            appStates.add(state.trim().toLowerCase());\n-          }\n-        }\n-      }\n-    }\n+    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n     if (!appStates.isEmpty()) {\n       checkAppStates \u003d true;\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n         .getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (RMApp rmapp : apps.values()) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n \n-      if (checkAppStates\n-          \u0026\u0026 !appStates.contains(rmapp.getState().toString().toLowerCase())) {\n+      if (checkAppStates \u0026\u0026 !appStates.contains(\n+          rmapp.createApplicationState().toString().toLowerCase())) {\n         continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!rmapp.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         ResourceScheduler rs \u003d rm.getResourceScheduler();\n         if (rs instanceof CapacityScheduler) {\n           CapacityScheduler cs \u003d (CapacityScheduler) rs;\n           // validate queue exists\n           try {\n             cs.getQueueInfo(queueQuery, false, false);\n           } catch (IOException e) {\n             throw new BadRequestException(e.getMessage());\n           }\n         }\n         if (!rmapp.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n-      if (checkAppTypes\n-          \u0026\u0026 !appTypes.contains(rmapp.getApplicationType())) {\n+      if (checkAppTypes \u0026\u0026 !appTypes.contains(\n+          rmapp.getApplicationType().trim().toLowerCase())) {\n         continue;\n       }\n \n       if (checkStart\n           \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d parseQueries(applicationTypes, false);\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    Set\u003cString\u003e appStates \u003d parseQueries(statesQuery, true);\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n        .getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (RMApp rmapp : apps.values()) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n\n      if (checkAppStates \u0026\u0026 !appStates.contains(\n          rmapp.createApplicationState().toString().toLowerCase())) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!rmapp.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        ResourceScheduler rs \u003d rm.getResourceScheduler();\n        if (rs instanceof CapacityScheduler) {\n          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n          // validate queue exists\n          try {\n            cs.getQueueInfo(queueQuery, false, false);\n          } catch (IOException e) {\n            throw new BadRequestException(e.getMessage());\n          }\n        }\n        if (!rmapp.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes \u0026\u0026 !appTypes.contains(\n          rmapp.getApplicationType().trim().toLowerCase())) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "03ae82a311c033318496111d3dbd77bbaaa990b6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-696. Changed RMWebservice apps call to take in multiple application states. Contributed by Trevor Lorimer.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1520736 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/09/13 12:28 AM",
      "commitName": "03ae82a311c033318496111d3dbd77bbaaa990b6",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-696. Changed RMWebservice apps call to take in multiple application states. Contributed by Trevor Lorimer.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1520736 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/09/13 12:28 AM",
          "commitName": "03ae82a311c033318496111d3dbd77bbaaa990b6",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "08/08/13 5:26 PM",
          "commitNameOld": "5b001e1a8ff4db80dfda3ff9bd69ceadea937318",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 29.29,
          "commitsBetweenForRepo": 165,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,153 +1,184 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n+      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd,\n       @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n+    boolean checkAppStates \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n     if (!applicationTypes.isEmpty()) {\n       for (String applicationType : applicationTypes) {\n         if (applicationType !\u003d null \u0026\u0026 !applicationType.trim().isEmpty()) {\n           if (applicationType.indexOf(\",\") \u003d\u003d -1) {\n             appTypes.add(applicationType.trim());\n           } else {\n             String[] types \u003d applicationType.split(\",\");\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(type.trim());\n               }\n             }\n           }\n         }\n       }\n     }\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n+    String allAppStates;\n+    RMAppState[] stateArray \u003d RMAppState.values();\n+    allAppStates \u003d Arrays.toString(stateArray);\n+\n+    Set\u003cString\u003e appStates \u003d new HashSet\u003cString\u003e();\n+    // stateQuery is deprecated.\n+    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n+      statesQuery.add(stateQuery);\n+    }\n+    if (!statesQuery.isEmpty()) {\n+      for (String applicationState : statesQuery) {\n+        if (applicationState !\u003d null \u0026\u0026 !applicationState.isEmpty()) {\n+          String[] states \u003d applicationState.split(\",\");\n+          for (String state : states) {\n+            try {\n+              RMAppState.valueOf(state.trim());\n+            } catch (IllegalArgumentException iae) {\n+              throw new BadRequestException(\n+                  \"Invalid application-state \" + state\n+                  + \" specified. It should be one of \" + allAppStates);\n+            }\n+            appStates.add(state.trim().toLowerCase());\n+          }\n+        }\n+      }\n+    }\n+    if (!appStates.isEmpty()) {\n+      checkAppStates \u003d true;\n+    }\n+\n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n         .getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (RMApp rmapp : apps.values()) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n-      if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n-        RMAppState.valueOf(stateQuery);\n-        if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n-          continue;\n-        }\n+\n+      if (checkAppStates\n+          \u0026\u0026 !appStates.contains(rmapp.getState().toString().toLowerCase())) {\n+        continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!rmapp.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         ResourceScheduler rs \u003d rm.getResourceScheduler();\n         if (rs instanceof CapacityScheduler) {\n           CapacityScheduler cs \u003d (CapacityScheduler) rs;\n           // validate queue exists\n           try {\n             cs.getQueueInfo(queueQuery, false, false);\n           } catch (IOException e) {\n             throw new BadRequestException(e.getMessage());\n           }\n         }\n         if (!rmapp.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes\n           \u0026\u0026 !appTypes.contains(rmapp.getApplicationType())) {\n         continue;\n       }\n \n       if (checkStart\n           \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n    if (!applicationTypes.isEmpty()) {\n      for (String applicationType : applicationTypes) {\n        if (applicationType !\u003d null \u0026\u0026 !applicationType.trim().isEmpty()) {\n          if (applicationType.indexOf(\",\") \u003d\u003d -1) {\n            appTypes.add(applicationType.trim());\n          } else {\n            String[] types \u003d applicationType.split(\",\");\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.trim());\n              }\n            }\n          }\n        }\n      }\n    }\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    String allAppStates;\n    RMAppState[] stateArray \u003d RMAppState.values();\n    allAppStates \u003d Arrays.toString(stateArray);\n\n    Set\u003cString\u003e appStates \u003d new HashSet\u003cString\u003e();\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    if (!statesQuery.isEmpty()) {\n      for (String applicationState : statesQuery) {\n        if (applicationState !\u003d null \u0026\u0026 !applicationState.isEmpty()) {\n          String[] states \u003d applicationState.split(\",\");\n          for (String state : states) {\n            try {\n              RMAppState.valueOf(state.trim());\n            } catch (IllegalArgumentException iae) {\n              throw new BadRequestException(\n                  \"Invalid application-state \" + state\n                  + \" specified. It should be one of \" + allAppStates);\n            }\n            appStates.add(state.trim().toLowerCase());\n          }\n        }\n      }\n    }\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n        .getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (RMApp rmapp : apps.values()) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n\n      if (checkAppStates\n          \u0026\u0026 !appStates.contains(rmapp.getState().toString().toLowerCase())) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!rmapp.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        ResourceScheduler rs \u003d rm.getResourceScheduler();\n        if (rs instanceof CapacityScheduler) {\n          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n          // validate queue exists\n          try {\n            cs.getQueueInfo(queueQuery, false, false);\n          } catch (IOException e) {\n            throw new BadRequestException(e.getMessage());\n          }\n        }\n        if (!rmapp.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes\n          \u0026\u0026 !appTypes.contains(rmapp.getApplicationType())) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {
            "oldValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(\"state\")), finalStatusQuery-String(annotations-@QueryParam(\"finalStatus\")), userQuery-String(annotations-@QueryParam(\"user\")), queueQuery-String(annotations-@QueryParam(\"queue\")), count-String(annotations-@QueryParam(\"limit\")), startedBegin-String(annotations-@QueryParam(\"startedTimeBegin\")), startedEnd-String(annotations-@QueryParam(\"startedTimeEnd\")), finishBegin-String(annotations-@QueryParam(\"finishedTimeBegin\")), finishEnd-String(annotations-@QueryParam(\"finishedTimeEnd\")), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(\"applicationTypes\"))]",
            "newValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(\"state\")), statesQuery-Set\u003cString\u003e(annotations-@QueryParam(\"states\")), finalStatusQuery-String(annotations-@QueryParam(\"finalStatus\")), userQuery-String(annotations-@QueryParam(\"user\")), queueQuery-String(annotations-@QueryParam(\"queue\")), count-String(annotations-@QueryParam(\"limit\")), startedBegin-String(annotations-@QueryParam(\"startedTimeBegin\")), startedEnd-String(annotations-@QueryParam(\"startedTimeEnd\")), finishBegin-String(annotations-@QueryParam(\"finishedTimeBegin\")), finishEnd-String(annotations-@QueryParam(\"finishedTimeEnd\")), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(\"applicationTypes\"))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-696. Changed RMWebservice apps call to take in multiple application states. Contributed by Trevor Lorimer.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1520736 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/09/13 12:28 AM",
          "commitName": "03ae82a311c033318496111d3dbd77bbaaa990b6",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "08/08/13 5:26 PM",
          "commitNameOld": "5b001e1a8ff4db80dfda3ff9bd69ceadea937318",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 29.29,
          "commitsBetweenForRepo": 165,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,153 +1,184 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n+      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd,\n       @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     boolean checkAppTypes \u003d false;\n+    boolean checkAppStates \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n     if (!applicationTypes.isEmpty()) {\n       for (String applicationType : applicationTypes) {\n         if (applicationType !\u003d null \u0026\u0026 !applicationType.trim().isEmpty()) {\n           if (applicationType.indexOf(\",\") \u003d\u003d -1) {\n             appTypes.add(applicationType.trim());\n           } else {\n             String[] types \u003d applicationType.split(\",\");\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(type.trim());\n               }\n             }\n           }\n         }\n       }\n     }\n     if (!appTypes.isEmpty()) {\n       checkAppTypes \u003d true;\n     }\n \n+    String allAppStates;\n+    RMAppState[] stateArray \u003d RMAppState.values();\n+    allAppStates \u003d Arrays.toString(stateArray);\n+\n+    Set\u003cString\u003e appStates \u003d new HashSet\u003cString\u003e();\n+    // stateQuery is deprecated.\n+    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n+      statesQuery.add(stateQuery);\n+    }\n+    if (!statesQuery.isEmpty()) {\n+      for (String applicationState : statesQuery) {\n+        if (applicationState !\u003d null \u0026\u0026 !applicationState.isEmpty()) {\n+          String[] states \u003d applicationState.split(\",\");\n+          for (String state : states) {\n+            try {\n+              RMAppState.valueOf(state.trim());\n+            } catch (IllegalArgumentException iae) {\n+              throw new BadRequestException(\n+                  \"Invalid application-state \" + state\n+                  + \" specified. It should be one of \" + allAppStates);\n+            }\n+            appStates.add(state.trim().toLowerCase());\n+          }\n+        }\n+      }\n+    }\n+    if (!appStates.isEmpty()) {\n+      checkAppStates \u003d true;\n+    }\n+\n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n         .getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (RMApp rmapp : apps.values()) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n-      if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n-        RMAppState.valueOf(stateQuery);\n-        if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n-          continue;\n-        }\n+\n+      if (checkAppStates\n+          \u0026\u0026 !appStates.contains(rmapp.getState().toString().toLowerCase())) {\n+        continue;\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!rmapp.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         ResourceScheduler rs \u003d rm.getResourceScheduler();\n         if (rs instanceof CapacityScheduler) {\n           CapacityScheduler cs \u003d (CapacityScheduler) rs;\n           // validate queue exists\n           try {\n             cs.getQueueInfo(queueQuery, false, false);\n           } catch (IOException e) {\n             throw new BadRequestException(e.getMessage());\n           }\n         }\n         if (!rmapp.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n       if (checkAppTypes\n           \u0026\u0026 !appTypes.contains(rmapp.getApplicationType())) {\n         continue;\n       }\n \n       if (checkStart\n           \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"states\") Set\u003cString\u003e statesQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    boolean checkAppStates \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n    if (!applicationTypes.isEmpty()) {\n      for (String applicationType : applicationTypes) {\n        if (applicationType !\u003d null \u0026\u0026 !applicationType.trim().isEmpty()) {\n          if (applicationType.indexOf(\",\") \u003d\u003d -1) {\n            appTypes.add(applicationType.trim());\n          } else {\n            String[] types \u003d applicationType.split(\",\");\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.trim());\n              }\n            }\n          }\n        }\n      }\n    }\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    String allAppStates;\n    RMAppState[] stateArray \u003d RMAppState.values();\n    allAppStates \u003d Arrays.toString(stateArray);\n\n    Set\u003cString\u003e appStates \u003d new HashSet\u003cString\u003e();\n    // stateQuery is deprecated.\n    if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n      statesQuery.add(stateQuery);\n    }\n    if (!statesQuery.isEmpty()) {\n      for (String applicationState : statesQuery) {\n        if (applicationState !\u003d null \u0026\u0026 !applicationState.isEmpty()) {\n          String[] states \u003d applicationState.split(\",\");\n          for (String state : states) {\n            try {\n              RMAppState.valueOf(state.trim());\n            } catch (IllegalArgumentException iae) {\n              throw new BadRequestException(\n                  \"Invalid application-state \" + state\n                  + \" specified. It should be one of \" + allAppStates);\n            }\n            appStates.add(state.trim().toLowerCase());\n          }\n        }\n      }\n    }\n    if (!appStates.isEmpty()) {\n      checkAppStates \u003d true;\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n        .getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (RMApp rmapp : apps.values()) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n\n      if (checkAppStates\n          \u0026\u0026 !appStates.contains(rmapp.getState().toString().toLowerCase())) {\n        continue;\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!rmapp.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        ResourceScheduler rs \u003d rm.getResourceScheduler();\n        if (rs instanceof CapacityScheduler) {\n          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n          // validate queue exists\n          try {\n            cs.getQueueInfo(queueQuery, false, false);\n          } catch (IOException e) {\n            throw new BadRequestException(e.getMessage());\n          }\n        }\n        if (!rmapp.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes\n          \u0026\u0026 !appTypes.contains(rmapp.getApplicationType())) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "1c133ffb72094a832b1d6c4b641821c6e2a7f9b2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-865. RM webservices can\u0027t query based on application Types. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504288 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/07/13 2:42 PM",
      "commitName": "1c133ffb72094a832b1d6c4b641821c6e2a7f9b2",
      "commitAuthor": "Hitesh Shah",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-865. RM webservices can\u0027t query based on application Types. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504288 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/07/13 2:42 PM",
          "commitName": "1c133ffb72094a832b1d6c4b641821c6e2a7f9b2",
          "commitAuthor": "Hitesh Shah",
          "commitDateOld": "08/07/13 3:30 PM",
          "commitNameOld": "5e4f6ad1d9aa6df96af837600674af4467c1e99c",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 8.97,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,126 +1,153 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n-      @QueryParam(\"finishedTimeEnd\") String finishEnd) {\n+      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n+      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n+    boolean checkAppTypes \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n+    Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n+    if (!applicationTypes.isEmpty()) {\n+      for (String applicationType : applicationTypes) {\n+        if (applicationType !\u003d null \u0026\u0026 !applicationType.trim().isEmpty()) {\n+          if (applicationType.indexOf(\",\") \u003d\u003d -1) {\n+            appTypes.add(applicationType.trim());\n+          } else {\n+            String[] types \u003d applicationType.split(\",\");\n+            for (String type : types) {\n+              if (!type.trim().isEmpty()) {\n+                appTypes.add(type.trim());\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+    if (!appTypes.isEmpty()) {\n+      checkAppTypes \u003d true;\n+    }\n+\n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n         .getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (RMApp rmapp : apps.values()) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n       if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n         RMAppState.valueOf(stateQuery);\n         if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n           continue;\n         }\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!rmapp.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         ResourceScheduler rs \u003d rm.getResourceScheduler();\n         if (rs instanceof CapacityScheduler) {\n           CapacityScheduler cs \u003d (CapacityScheduler) rs;\n           // validate queue exists\n           try {\n             cs.getQueueInfo(queueQuery, false, false);\n           } catch (IOException e) {\n             throw new BadRequestException(e.getMessage());\n           }\n         }\n         if (!rmapp.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n+      if (checkAppTypes\n+          \u0026\u0026 !appTypes.contains(rmapp.getApplicationType())) {\n+        continue;\n+      }\n \n       if (checkStart\n           \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n    if (!applicationTypes.isEmpty()) {\n      for (String applicationType : applicationTypes) {\n        if (applicationType !\u003d null \u0026\u0026 !applicationType.trim().isEmpty()) {\n          if (applicationType.indexOf(\",\") \u003d\u003d -1) {\n            appTypes.add(applicationType.trim());\n          } else {\n            String[] types \u003d applicationType.split(\",\");\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.trim());\n              }\n            }\n          }\n        }\n      }\n    }\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n        .getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (RMApp rmapp : apps.values()) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n      if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n        RMAppState.valueOf(stateQuery);\n        if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n          continue;\n        }\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!rmapp.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        ResourceScheduler rs \u003d rm.getResourceScheduler();\n        if (rs instanceof CapacityScheduler) {\n          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n          // validate queue exists\n          try {\n            cs.getQueueInfo(queueQuery, false, false);\n          } catch (IOException e) {\n            throw new BadRequestException(e.getMessage());\n          }\n        }\n        if (!rmapp.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes\n          \u0026\u0026 !appTypes.contains(rmapp.getApplicationType())) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {
            "oldValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(\"state\")), finalStatusQuery-String(annotations-@QueryParam(\"finalStatus\")), userQuery-String(annotations-@QueryParam(\"user\")), queueQuery-String(annotations-@QueryParam(\"queue\")), count-String(annotations-@QueryParam(\"limit\")), startedBegin-String(annotations-@QueryParam(\"startedTimeBegin\")), startedEnd-String(annotations-@QueryParam(\"startedTimeEnd\")), finishBegin-String(annotations-@QueryParam(\"finishedTimeBegin\")), finishEnd-String(annotations-@QueryParam(\"finishedTimeEnd\"))]",
            "newValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(\"state\")), finalStatusQuery-String(annotations-@QueryParam(\"finalStatus\")), userQuery-String(annotations-@QueryParam(\"user\")), queueQuery-String(annotations-@QueryParam(\"queue\")), count-String(annotations-@QueryParam(\"limit\")), startedBegin-String(annotations-@QueryParam(\"startedTimeBegin\")), startedEnd-String(annotations-@QueryParam(\"startedTimeEnd\")), finishBegin-String(annotations-@QueryParam(\"finishedTimeBegin\")), finishEnd-String(annotations-@QueryParam(\"finishedTimeEnd\")), applicationTypes-Set\u003cString\u003e(annotations-@QueryParam(\"applicationTypes\"))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-865. RM webservices can\u0027t query based on application Types. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504288 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/07/13 2:42 PM",
          "commitName": "1c133ffb72094a832b1d6c4b641821c6e2a7f9b2",
          "commitAuthor": "Hitesh Shah",
          "commitDateOld": "08/07/13 3:30 PM",
          "commitNameOld": "5e4f6ad1d9aa6df96af837600674af4467c1e99c",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 8.97,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,126 +1,153 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n-      @QueryParam(\"finishedTimeEnd\") String finishEnd) {\n+      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n+      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n+    boolean checkAppTypes \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n+    Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n+    if (!applicationTypes.isEmpty()) {\n+      for (String applicationType : applicationTypes) {\n+        if (applicationType !\u003d null \u0026\u0026 !applicationType.trim().isEmpty()) {\n+          if (applicationType.indexOf(\",\") \u003d\u003d -1) {\n+            appTypes.add(applicationType.trim());\n+          } else {\n+            String[] types \u003d applicationType.split(\",\");\n+            for (String type : types) {\n+              if (!type.trim().isEmpty()) {\n+                appTypes.add(type.trim());\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+    if (!appTypes.isEmpty()) {\n+      checkAppTypes \u003d true;\n+    }\n+\n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n         .getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (RMApp rmapp : apps.values()) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n       if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n         RMAppState.valueOf(stateQuery);\n         if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n           continue;\n         }\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!rmapp.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         ResourceScheduler rs \u003d rm.getResourceScheduler();\n         if (rs instanceof CapacityScheduler) {\n           CapacityScheduler cs \u003d (CapacityScheduler) rs;\n           // validate queue exists\n           try {\n             cs.getQueueInfo(queueQuery, false, false);\n           } catch (IOException e) {\n             throw new BadRequestException(e.getMessage());\n           }\n         }\n         if (!rmapp.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n+      if (checkAppTypes\n+          \u0026\u0026 !appTypes.contains(rmapp.getApplicationType())) {\n+        continue;\n+      }\n \n       if (checkStart\n           \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd,\n      @QueryParam(\"applicationTypes\") Set\u003cString\u003e applicationTypes) {\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    boolean checkAppTypes \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n    if (!applicationTypes.isEmpty()) {\n      for (String applicationType : applicationTypes) {\n        if (applicationType !\u003d null \u0026\u0026 !applicationType.trim().isEmpty()) {\n          if (applicationType.indexOf(\",\") \u003d\u003d -1) {\n            appTypes.add(applicationType.trim());\n          } else {\n            String[] types \u003d applicationType.split(\",\");\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.trim());\n              }\n            }\n          }\n        }\n      }\n    }\n    if (!appTypes.isEmpty()) {\n      checkAppTypes \u003d true;\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n        .getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (RMApp rmapp : apps.values()) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n      if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n        RMAppState.valueOf(stateQuery);\n        if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n          continue;\n        }\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!rmapp.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        ResourceScheduler rs \u003d rm.getResourceScheduler();\n        if (rs instanceof CapacityScheduler) {\n          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n          // validate queue exists\n          try {\n            cs.getQueueInfo(queueQuery, false, false);\n          } catch (IOException e) {\n            throw new BadRequestException(e.getMessage());\n          }\n        }\n        if (!rmapp.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n      if (checkAppTypes\n          \u0026\u0026 !appTypes.contains(rmapp.getApplicationType())) {\n        continue;\n      }\n\n      if (checkStart\n          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd) {\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n        .getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (RMApp rmapp : apps.values()) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n      if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n        RMAppState.valueOf(stateQuery);\n        if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n          continue;\n        }\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!rmapp.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        ResourceScheduler rs \u003d rm.getResourceScheduler();\n        if (rs instanceof CapacityScheduler) {\n          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n          // validate queue exists\n          try {\n            cs.getQueueInfo(queueQuery, false, false);\n          } catch (IOException e) {\n            throw new BadRequestException(e.getMessage());\n          }\n        }\n        if (!rmapp.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n\n      if (checkStart\n          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java"
      }
    },
    "e7583d816a69677bbaa4280deb58ea73dbc42cef": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3613. web service calls header contains 2 content types (tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1330560 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/04/12 2:13 PM",
      "commitName": "e7583d816a69677bbaa4280deb58ea73dbc42cef",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "02/04/12 2:06 PM",
      "commitNameOld": "01ce7ba3a4af867763e437ce46a4f5e1d6e5a6bf",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 23.0,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,126 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n       @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd) {\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n+    init();\n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n         .getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (RMApp rmapp : apps.values()) {\n \n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n       if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n         RMAppState.valueOf(stateQuery);\n         if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n           continue;\n         }\n       }\n       if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n         FinalApplicationStatus.valueOf(finalStatusQuery);\n         if (!rmapp.getFinalApplicationStatus().toString()\n             .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n         if (!rmapp.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         ResourceScheduler rs \u003d rm.getResourceScheduler();\n         if (rs instanceof CapacityScheduler) {\n           CapacityScheduler cs \u003d (CapacityScheduler) rs;\n           // validate queue exists\n           try {\n             cs.getQueueInfo(queueQuery, false, false);\n           } catch (IOException e) {\n             throw new BadRequestException(e.getMessage());\n           }\n         }\n         if (!rmapp.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n \n       if (checkStart\n           \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n           \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n       AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd) {\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    init();\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n        .getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (RMApp rmapp : apps.values()) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n      if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n        RMAppState.valueOf(stateQuery);\n        if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n          continue;\n        }\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!rmapp.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        ResourceScheduler rs \u003d rm.getResourceScheduler();\n        if (rs instanceof CapacityScheduler) {\n          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n          // validate queue exists\n          try {\n            cs.getQueueInfo(queueQuery, false, false);\n          } catch (IOException e) {\n            throw new BadRequestException(e.getMessage());\n          }\n        }\n        if (!rmapp.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n\n      if (checkStart\n          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "01ce7ba3a4af867763e437ce46a4f5e1d6e5a6bf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-4024. RM webservices can\u0027t query on finalStatus (Tom Graves via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308566 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/04/12 2:06 PM",
      "commitName": "01ce7ba3a4af867763e437ce46a4f5e1d6e5a6bf",
      "commitAuthor": "Robert Joseph Evans",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-4024. RM webservices can\u0027t query on finalStatus (Tom Graves via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308566 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/04/12 2:06 PM",
          "commitName": "01ce7ba3a4af867763e437ce46a4f5e1d6e5a6bf",
          "commitAuthor": "Robert Joseph Evans",
          "commitDateOld": "03/02/12 5:03 PM",
          "commitNameOld": "3343494d6c39883485d29c7439831ab3c1c7248d",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 58.84,
          "commitsBetweenForRepo": 440,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,117 +1,125 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n+      @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd) {\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n         .getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (RMApp rmapp : apps.values()) {\n+\n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n-      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n-\n       if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n         RMAppState.valueOf(stateQuery);\n-        if (!app.getState().equalsIgnoreCase(stateQuery)) {\n+        if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n+          continue;\n+        }\n+      }\n+      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n+        FinalApplicationStatus.valueOf(finalStatusQuery);\n+        if (!rmapp.getFinalApplicationStatus().toString()\n+            .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n-        if (!app.getUser().equals(userQuery)) {\n+        if (!rmapp.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         ResourceScheduler rs \u003d rm.getResourceScheduler();\n         if (rs instanceof CapacityScheduler) {\n           CapacityScheduler cs \u003d (CapacityScheduler) rs;\n           // validate queue exists\n           try {\n             cs.getQueueInfo(queueQuery, false, false);\n           } catch (IOException e) {\n             throw new BadRequestException(e.getMessage());\n           }\n         }\n-        if (!app.getQueue().equals(queueQuery)) {\n+        if (!rmapp.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n \n       if (checkStart\n-          \u0026\u0026 (app.getStartTime() \u003c sBegin || app.getStartTime() \u003e sEnd)) {\n+          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n-          \u0026\u0026 (app.getFinishTime() \u003c fBegin || app.getFinishTime() \u003e fEnd)) {\n+          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n+      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd) {\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n        .getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (RMApp rmapp : apps.values()) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n      if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n        RMAppState.valueOf(stateQuery);\n        if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n          continue;\n        }\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!rmapp.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        ResourceScheduler rs \u003d rm.getResourceScheduler();\n        if (rs instanceof CapacityScheduler) {\n          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n          // validate queue exists\n          try {\n            cs.getQueueInfo(queueQuery, false, false);\n          } catch (IOException e) {\n            throw new BadRequestException(e.getMessage());\n          }\n        }\n        if (!rmapp.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n\n      if (checkStart\n          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {
            "oldValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(\"state\")), userQuery-String(annotations-@QueryParam(\"user\")), queueQuery-String(annotations-@QueryParam(\"queue\")), count-String(annotations-@QueryParam(\"limit\")), startedBegin-String(annotations-@QueryParam(\"startedTimeBegin\")), startedEnd-String(annotations-@QueryParam(\"startedTimeEnd\")), finishBegin-String(annotations-@QueryParam(\"finishedTimeBegin\")), finishEnd-String(annotations-@QueryParam(\"finishedTimeEnd\"))]",
            "newValue": "[hsr-HttpServletRequest(annotations-@Context), stateQuery-String(annotations-@QueryParam(\"state\")), finalStatusQuery-String(annotations-@QueryParam(\"finalStatus\")), userQuery-String(annotations-@QueryParam(\"user\")), queueQuery-String(annotations-@QueryParam(\"queue\")), count-String(annotations-@QueryParam(\"limit\")), startedBegin-String(annotations-@QueryParam(\"startedTimeBegin\")), startedEnd-String(annotations-@QueryParam(\"startedTimeEnd\")), finishBegin-String(annotations-@QueryParam(\"finishedTimeBegin\")), finishEnd-String(annotations-@QueryParam(\"finishedTimeEnd\"))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-4024. RM webservices can\u0027t query on finalStatus (Tom Graves via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308566 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/04/12 2:06 PM",
          "commitName": "01ce7ba3a4af867763e437ce46a4f5e1d6e5a6bf",
          "commitAuthor": "Robert Joseph Evans",
          "commitDateOld": "03/02/12 5:03 PM",
          "commitNameOld": "3343494d6c39883485d29c7439831ab3c1c7248d",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 58.84,
          "commitsBetweenForRepo": 440,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,117 +1,125 @@\n   public AppsInfo getApps(@Context HttpServletRequest hsr,\n       @QueryParam(\"state\") String stateQuery,\n+      @QueryParam(\"finalStatus\") String finalStatusQuery,\n       @QueryParam(\"user\") String userQuery,\n       @QueryParam(\"queue\") String queueQuery,\n       @QueryParam(\"limit\") String count,\n       @QueryParam(\"startedTimeBegin\") String startedBegin,\n       @QueryParam(\"startedTimeEnd\") String startedEnd,\n       @QueryParam(\"finishedTimeBegin\") String finishBegin,\n       @QueryParam(\"finishedTimeEnd\") String finishEnd) {\n     long num \u003d 0;\n     boolean checkCount \u003d false;\n     boolean checkStart \u003d false;\n     boolean checkEnd \u003d false;\n     long countNum \u003d 0;\n \n     // set values suitable in case both of begin/end not specified\n     long sBegin \u003d 0;\n     long sEnd \u003d Long.MAX_VALUE;\n     long fBegin \u003d 0;\n     long fEnd \u003d Long.MAX_VALUE;\n \n     if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n       checkCount \u003d true;\n       countNum \u003d Long.parseLong(count);\n       if (countNum \u003c\u003d 0) {\n         throw new BadRequestException(\"limit value must be greater then 0\");\n       }\n     }\n \n     if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n       checkStart \u003d true;\n       sBegin \u003d Long.parseLong(startedBegin);\n       if (sBegin \u003c 0) {\n         throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n       }\n     }\n     if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n       checkStart \u003d true;\n       sEnd \u003d Long.parseLong(startedEnd);\n       if (sEnd \u003c 0) {\n         throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n       }\n     }\n     if (sBegin \u003e sEnd) {\n       throw new BadRequestException(\n           \"startedTimeEnd must be greater than startTimeBegin\");\n     }\n \n     if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n       checkEnd \u003d true;\n       fBegin \u003d Long.parseLong(finishBegin);\n       if (fBegin \u003c 0) {\n         throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n       }\n     }\n     if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n       checkEnd \u003d true;\n       fEnd \u003d Long.parseLong(finishEnd);\n       if (fEnd \u003c 0) {\n         throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n       }\n     }\n     if (fBegin \u003e fEnd) {\n       throw new BadRequestException(\n           \"finishTimeEnd must be greater than finishTimeBegin\");\n     }\n \n     final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n         .getRMApps();\n     AppsInfo allApps \u003d new AppsInfo();\n     for (RMApp rmapp : apps.values()) {\n+\n       if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n         break;\n       }\n-      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n-\n       if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n         RMAppState.valueOf(stateQuery);\n-        if (!app.getState().equalsIgnoreCase(stateQuery)) {\n+        if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n+          continue;\n+        }\n+      }\n+      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n+        FinalApplicationStatus.valueOf(finalStatusQuery);\n+        if (!rmapp.getFinalApplicationStatus().toString()\n+            .equalsIgnoreCase(finalStatusQuery)) {\n           continue;\n         }\n       }\n       if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n-        if (!app.getUser().equals(userQuery)) {\n+        if (!rmapp.getUser().equals(userQuery)) {\n           continue;\n         }\n       }\n       if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n         ResourceScheduler rs \u003d rm.getResourceScheduler();\n         if (rs instanceof CapacityScheduler) {\n           CapacityScheduler cs \u003d (CapacityScheduler) rs;\n           // validate queue exists\n           try {\n             cs.getQueueInfo(queueQuery, false, false);\n           } catch (IOException e) {\n             throw new BadRequestException(e.getMessage());\n           }\n         }\n-        if (!app.getQueue().equals(queueQuery)) {\n+        if (!rmapp.getQueue().equals(queueQuery)) {\n           continue;\n         }\n       }\n \n       if (checkStart\n-          \u0026\u0026 (app.getStartTime() \u003c sBegin || app.getStartTime() \u003e sEnd)) {\n+          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n         continue;\n       }\n       if (checkEnd\n-          \u0026\u0026 (app.getFinishTime() \u003c fBegin || app.getFinishTime() \u003e fEnd)) {\n+          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n         continue;\n       }\n+      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n \n       allApps.add(app);\n       num++;\n     }\n     return allApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"finalStatus\") String finalStatusQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd) {\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n        .getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (RMApp rmapp : apps.values()) {\n\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n      if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n        RMAppState.valueOf(stateQuery);\n        if (!rmapp.getState().toString().equalsIgnoreCase(stateQuery)) {\n          continue;\n        }\n      }\n      if (finalStatusQuery !\u003d null \u0026\u0026 !finalStatusQuery.isEmpty()) {\n        FinalApplicationStatus.valueOf(finalStatusQuery);\n        if (!rmapp.getFinalApplicationStatus().toString()\n            .equalsIgnoreCase(finalStatusQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!rmapp.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        ResourceScheduler rs \u003d rm.getResourceScheduler();\n        if (rs instanceof CapacityScheduler) {\n          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n          // validate queue exists\n          try {\n            cs.getQueueInfo(queueQuery, false, false);\n          } catch (IOException e) {\n            throw new BadRequestException(e.getMessage());\n          }\n        }\n        if (!rmapp.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n\n      if (checkStart\n          \u0026\u0026 (rmapp.getStartTime() \u003c sBegin || rmapp.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (rmapp.getFinishTime() \u003c fBegin || rmapp.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "0ea8570be578be60e2f32849900a1c50506d78d3": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2863. Support web services for YARN and MR components. (Thomas Graves via vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1213975 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 3:05 PM",
      "commitName": "0ea8570be578be60e2f32849900a1c50506d78d3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,117 @@\n+  public AppsInfo getApps(@Context HttpServletRequest hsr,\n+      @QueryParam(\"state\") String stateQuery,\n+      @QueryParam(\"user\") String userQuery,\n+      @QueryParam(\"queue\") String queueQuery,\n+      @QueryParam(\"limit\") String count,\n+      @QueryParam(\"startedTimeBegin\") String startedBegin,\n+      @QueryParam(\"startedTimeEnd\") String startedEnd,\n+      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n+      @QueryParam(\"finishedTimeEnd\") String finishEnd) {\n+    long num \u003d 0;\n+    boolean checkCount \u003d false;\n+    boolean checkStart \u003d false;\n+    boolean checkEnd \u003d false;\n+    long countNum \u003d 0;\n+\n+    // set values suitable in case both of begin/end not specified\n+    long sBegin \u003d 0;\n+    long sEnd \u003d Long.MAX_VALUE;\n+    long fBegin \u003d 0;\n+    long fEnd \u003d Long.MAX_VALUE;\n+\n+    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n+      checkCount \u003d true;\n+      countNum \u003d Long.parseLong(count);\n+      if (countNum \u003c\u003d 0) {\n+        throw new BadRequestException(\"limit value must be greater then 0\");\n+      }\n+    }\n+\n+    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n+      checkStart \u003d true;\n+      sBegin \u003d Long.parseLong(startedBegin);\n+      if (sBegin \u003c 0) {\n+        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n+      }\n+    }\n+    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n+      checkStart \u003d true;\n+      sEnd \u003d Long.parseLong(startedEnd);\n+      if (sEnd \u003c 0) {\n+        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n+      }\n+    }\n+    if (sBegin \u003e sEnd) {\n+      throw new BadRequestException(\n+          \"startedTimeEnd must be greater than startTimeBegin\");\n+    }\n+\n+    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n+      checkEnd \u003d true;\n+      fBegin \u003d Long.parseLong(finishBegin);\n+      if (fBegin \u003c 0) {\n+        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n+      }\n+    }\n+    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n+      checkEnd \u003d true;\n+      fEnd \u003d Long.parseLong(finishEnd);\n+      if (fEnd \u003c 0) {\n+        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n+      }\n+    }\n+    if (fBegin \u003e fEnd) {\n+      throw new BadRequestException(\n+          \"finishTimeEnd must be greater than finishTimeBegin\");\n+    }\n+\n+    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n+        .getRMApps();\n+    AppsInfo allApps \u003d new AppsInfo();\n+    for (RMApp rmapp : apps.values()) {\n+      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n+        break;\n+      }\n+      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n+\n+      if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n+        RMAppState.valueOf(stateQuery);\n+        if (!app.getState().equalsIgnoreCase(stateQuery)) {\n+          continue;\n+        }\n+      }\n+      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n+        if (!app.getUser().equals(userQuery)) {\n+          continue;\n+        }\n+      }\n+      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n+        ResourceScheduler rs \u003d rm.getResourceScheduler();\n+        if (rs instanceof CapacityScheduler) {\n+          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n+          // validate queue exists\n+          try {\n+            cs.getQueueInfo(queueQuery, false, false);\n+          } catch (IOException e) {\n+            throw new BadRequestException(e.getMessage());\n+          }\n+        }\n+        if (!app.getQueue().equals(queueQuery)) {\n+          continue;\n+        }\n+      }\n+\n+      if (checkStart\n+          \u0026\u0026 (app.getStartTime() \u003c sBegin || app.getStartTime() \u003e sEnd)) {\n+        continue;\n+      }\n+      if (checkEnd\n+          \u0026\u0026 (app.getFinishTime() \u003c fBegin || app.getFinishTime() \u003e fEnd)) {\n+        continue;\n+      }\n+\n+      allApps.add(app);\n+      num++;\n+    }\n+    return allApps;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(@Context HttpServletRequest hsr,\n      @QueryParam(\"state\") String stateQuery,\n      @QueryParam(\"user\") String userQuery,\n      @QueryParam(\"queue\") String queueQuery,\n      @QueryParam(\"limit\") String count,\n      @QueryParam(\"startedTimeBegin\") String startedBegin,\n      @QueryParam(\"startedTimeEnd\") String startedEnd,\n      @QueryParam(\"finishedTimeBegin\") String finishBegin,\n      @QueryParam(\"finishedTimeEnd\") String finishEnd) {\n    long num \u003d 0;\n    boolean checkCount \u003d false;\n    boolean checkStart \u003d false;\n    boolean checkEnd \u003d false;\n    long countNum \u003d 0;\n\n    // set values suitable in case both of begin/end not specified\n    long sBegin \u003d 0;\n    long sEnd \u003d Long.MAX_VALUE;\n    long fBegin \u003d 0;\n    long fEnd \u003d Long.MAX_VALUE;\n\n    if (count !\u003d null \u0026\u0026 !count.isEmpty()) {\n      checkCount \u003d true;\n      countNum \u003d Long.parseLong(count);\n      if (countNum \u003c\u003d 0) {\n        throw new BadRequestException(\"limit value must be greater then 0\");\n      }\n    }\n\n    if (startedBegin !\u003d null \u0026\u0026 !startedBegin.isEmpty()) {\n      checkStart \u003d true;\n      sBegin \u003d Long.parseLong(startedBegin);\n      if (sBegin \u003c 0) {\n        throw new BadRequestException(\"startedTimeBegin must be greater than 0\");\n      }\n    }\n    if (startedEnd !\u003d null \u0026\u0026 !startedEnd.isEmpty()) {\n      checkStart \u003d true;\n      sEnd \u003d Long.parseLong(startedEnd);\n      if (sEnd \u003c 0) {\n        throw new BadRequestException(\"startedTimeEnd must be greater than 0\");\n      }\n    }\n    if (sBegin \u003e sEnd) {\n      throw new BadRequestException(\n          \"startedTimeEnd must be greater than startTimeBegin\");\n    }\n\n    if (finishBegin !\u003d null \u0026\u0026 !finishBegin.isEmpty()) {\n      checkEnd \u003d true;\n      fBegin \u003d Long.parseLong(finishBegin);\n      if (fBegin \u003c 0) {\n        throw new BadRequestException(\"finishTimeBegin must be greater than 0\");\n      }\n    }\n    if (finishEnd !\u003d null \u0026\u0026 !finishEnd.isEmpty()) {\n      checkEnd \u003d true;\n      fEnd \u003d Long.parseLong(finishEnd);\n      if (fEnd \u003c 0) {\n        throw new BadRequestException(\"finishTimeEnd must be greater than 0\");\n      }\n    }\n    if (fBegin \u003e fEnd) {\n      throw new BadRequestException(\n          \"finishTimeEnd must be greater than finishTimeBegin\");\n    }\n\n    final ConcurrentMap\u003cApplicationId, RMApp\u003e apps \u003d rm.getRMContext()\n        .getRMApps();\n    AppsInfo allApps \u003d new AppsInfo();\n    for (RMApp rmapp : apps.values()) {\n      if (checkCount \u0026\u0026 num \u003d\u003d countNum) {\n        break;\n      }\n      AppInfo app \u003d new AppInfo(rmapp, hasAccess(rmapp, hsr));\n\n      if (stateQuery !\u003d null \u0026\u0026 !stateQuery.isEmpty()) {\n        RMAppState.valueOf(stateQuery);\n        if (!app.getState().equalsIgnoreCase(stateQuery)) {\n          continue;\n        }\n      }\n      if (userQuery !\u003d null \u0026\u0026 !userQuery.isEmpty()) {\n        if (!app.getUser().equals(userQuery)) {\n          continue;\n        }\n      }\n      if (queueQuery !\u003d null \u0026\u0026 !queueQuery.isEmpty()) {\n        ResourceScheduler rs \u003d rm.getResourceScheduler();\n        if (rs instanceof CapacityScheduler) {\n          CapacityScheduler cs \u003d (CapacityScheduler) rs;\n          // validate queue exists\n          try {\n            cs.getQueueInfo(queueQuery, false, false);\n          } catch (IOException e) {\n            throw new BadRequestException(e.getMessage());\n          }\n        }\n        if (!app.getQueue().equals(queueQuery)) {\n          continue;\n        }\n      }\n\n      if (checkStart\n          \u0026\u0026 (app.getStartTime() \u003c sBegin || app.getStartTime() \u003e sEnd)) {\n        continue;\n      }\n      if (checkEnd\n          \u0026\u0026 (app.getFinishTime() \u003c fBegin || app.getFinishTime() \u003e fEnd)) {\n        continue;\n      }\n\n      allApps.add(app);\n      num++;\n    }\n    return allApps;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java"
    }
  }
}