{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Task.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
  "functionStartLine": 851,
  "functionEndLine": 946,
  "numCommitsSeen": 47,
  "timeTaken": 11894,
  "changeHistory": [
    "87e2570a1419d3616de2de3b553108ad1a8af425",
    "6eef3d7f1a1e5e3f27fb3bf7596663640d786181",
    "a37e7f0ad8b68c7ed16c242bedf62f4cde48d6fd",
    "178751ed8c9d47038acf8616c226f1f52e884feb",
    "537095d13cd38212ed162e0a360bdd9a8bd83498",
    "cb26cd4bee8ab75b304ebad6dc7c77523d0e9ce5",
    "7e6f384dd742de21f29e96ee76df5316529c9019",
    "47cca0cb6d1f4e5979d11d9a624b005e6e666f2f",
    "75d2d6185e38f014658a06541894fd7f75b9baee",
    "d05e6d2671db3876756e5a55c369c189a8fcbdb7",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "87e2570a1419d3616de2de3b553108ad1a8af425": "Ybodychange",
    "6eef3d7f1a1e5e3f27fb3bf7596663640d786181": "Ybodychange",
    "a37e7f0ad8b68c7ed16c242bedf62f4cde48d6fd": "Ybodychange",
    "178751ed8c9d47038acf8616c226f1f52e884feb": "Ybodychange",
    "537095d13cd38212ed162e0a360bdd9a8bd83498": "Ybodychange",
    "cb26cd4bee8ab75b304ebad6dc7c77523d0e9ce5": "Ybodychange",
    "7e6f384dd742de21f29e96ee76df5316529c9019": "Ybodychange",
    "47cca0cb6d1f4e5979d11d9a624b005e6e666f2f": "Ybodychange",
    "75d2d6185e38f014658a06541894fd7f75b9baee": "Ybodychange",
    "d05e6d2671db3876756e5a55c369c189a8fcbdb7": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Ymovefromfile",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "87e2570a1419d3616de2de3b553108ad1a8af425": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7048. Uber AM can crash due to unknown task in statusUpdate. Contributed by Peter Bacsko\n",
      "commitDate": "12/02/18 11:21 AM",
      "commitName": "87e2570a1419d3616de2de3b553108ad1a8af425",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "26/01/18 1:31 PM",
      "commitNameOld": "6eef3d7f1a1e5e3f27fb3bf7596663640d786181",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 16.91,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,96 @@\n     public void run() {\n       final int MAX_RETRIES \u003d 3;\n       int remainingRetries \u003d MAX_RETRIES;\n       // get current flag value and reset it as well\n       boolean sendProgress \u003d resetProgressFlag();\n \n       long taskProgressInterval \u003d MRJobConfUtil.\n           getTaskProgressReportInterval(conf);\n \n-      boolean uberized \u003d conf.getBoolean(\"mapreduce.task.uberized\",\n-          false);\n-\n       while (!taskDone.get()) {\n         synchronized (lock) {\n           done \u003d false;\n         }\n         try {\n           boolean taskFound \u003d true; // whether TT knows about this task\n           AMFeedback amFeedback \u003d null;\n           // sleep for a bit\n           synchronized(lock) {\n             if (taskDone.get()) {\n               break;\n             }\n             lock.wait(taskProgressInterval);\n           }\n           if (taskDone.get()) {\n             break;\n           }\n \n           if (sendProgress) {\n             // we need to send progress update\n             updateCounters();\n             checkTaskLimits();\n             taskStatus.statusUpdate(taskProgress.get(),\n                                     taskProgress.toString(),\n                                     counters);\n             amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n             taskFound \u003d amFeedback.getTaskFound();\n             taskStatus.clearStatus();\n           }\n           else {\n             // send ping \n             amFeedback \u003d umbilical.statusUpdate(taskId, null);\n             taskFound \u003d amFeedback.getTaskFound();\n           }\n \n           // if Task Tracker is not aware of our task ID (probably because it died and \n           // came back up), kill ourselves\n           if (!taskFound) {\n             if (uberized) {\n               taskDone.set(true);\n               break;\n             } else {\n               LOG.warn(\"Parent died.  Exiting \"+taskId);\n               resetDoneFlag();\n               System.exit(66);\n             }\n           }\n \n           // Set a flag that says we should preempt this is read by\n           // ReduceTasks in places of the execution where it is\n           // safe/easy to preempt\n           boolean lastPreempt \u003d mustPreempt.get();\n           mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n \n           if (lastPreempt ^ mustPreempt.get()) {\n             LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                 mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                 \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n           }\n           sendProgress \u003d resetProgressFlag();\n           remainingRetries \u003d MAX_RETRIES;\n         } catch (TaskLimitException e) {\n           String errMsg \u003d \"Task exceeded the limits: \" +\n                   StringUtils.stringifyException(e);\n           LOG.error(errMsg);\n           try {\n             umbilical.fatalError(taskId, errMsg, true);\n           } catch (IOException ioe) {\n             LOG.error(\"Failed to update failure diagnosis\", ioe);\n           }\n           LOG.error(\"Killing \" + taskId);\n           resetDoneFlag();\n           ExitUtil.terminate(69);\n         } catch (Throwable t) {\n           LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n           remainingRetries -\u003d1;\n           if (remainingRetries \u003d\u003d 0) {\n             ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n             LOG.warn(\"Last retry, killing \"+taskId);\n             resetDoneFlag();\n             System.exit(65);\n           }\n         }\n       }\n       //Notify that we are done with the work\n       resetDoneFlag();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n\n      long taskProgressInterval \u003d MRJobConfUtil.\n          getTaskProgressReportInterval(conf);\n\n      while (!taskDone.get()) {\n        synchronized (lock) {\n          done \u003d false;\n        }\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          AMFeedback amFeedback \u003d null;\n          // sleep for a bit\n          synchronized(lock) {\n            if (taskDone.get()) {\n              break;\n            }\n            lock.wait(taskProgressInterval);\n          }\n          if (taskDone.get()) {\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            checkTaskLimits();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(),\n                                    counters);\n            amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskFound \u003d amFeedback.getTaskFound();\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            amFeedback \u003d umbilical.statusUpdate(taskId, null);\n            taskFound \u003d amFeedback.getTaskFound();\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            if (uberized) {\n              taskDone.set(true);\n              break;\n            } else {\n              LOG.warn(\"Parent died.  Exiting \"+taskId);\n              resetDoneFlag();\n              System.exit(66);\n            }\n          }\n\n          // Set a flag that says we should preempt this is read by\n          // ReduceTasks in places of the execution where it is\n          // safe/easy to preempt\n          boolean lastPreempt \u003d mustPreempt.get();\n          mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n\n          if (lastPreempt ^ mustPreempt.get()) {\n            LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n          }\n          sendProgress \u003d resetProgressFlag();\n          remainingRetries \u003d MAX_RETRIES;\n        } catch (TaskLimitException e) {\n          String errMsg \u003d \"Task exceeded the limits: \" +\n                  StringUtils.stringifyException(e);\n          LOG.error(errMsg);\n          try {\n            umbilical.fatalError(taskId, errMsg, true);\n          } catch (IOException ioe) {\n            LOG.error(\"Failed to update failure diagnosis\", ioe);\n          }\n          LOG.error(\"Killing \" + taskId);\n          resetDoneFlag();\n          ExitUtil.terminate(69);\n        } catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            resetDoneFlag();\n            System.exit(65);\n          }\n        }\n      }\n      //Notify that we are done with the work\n      resetDoneFlag();\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {}
    },
    "6eef3d7f1a1e5e3f27fb3bf7596663640d786181": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7020. Task timeout in uber mode can crash AM. Contributed by Peter Bacsko\n",
      "commitDate": "26/01/18 1:31 PM",
      "commitName": "6eef3d7f1a1e5e3f27fb3bf7596663640d786181",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "26/01/18 12:36 PM",
      "commitNameOld": "a37e7f0ad8b68c7ed16c242bedf62f4cde48d6fd",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,99 @@\n     public void run() {\n       final int MAX_RETRIES \u003d 3;\n       int remainingRetries \u003d MAX_RETRIES;\n       // get current flag value and reset it as well\n       boolean sendProgress \u003d resetProgressFlag();\n \n       long taskProgressInterval \u003d MRJobConfUtil.\n           getTaskProgressReportInterval(conf);\n \n+      boolean uberized \u003d conf.getBoolean(\"mapreduce.task.uberized\",\n+          false);\n+\n       while (!taskDone.get()) {\n         synchronized (lock) {\n           done \u003d false;\n         }\n         try {\n           boolean taskFound \u003d true; // whether TT knows about this task\n           AMFeedback amFeedback \u003d null;\n           // sleep for a bit\n           synchronized(lock) {\n             if (taskDone.get()) {\n               break;\n             }\n             lock.wait(taskProgressInterval);\n           }\n           if (taskDone.get()) {\n             break;\n           }\n \n           if (sendProgress) {\n             // we need to send progress update\n             updateCounters();\n             checkTaskLimits();\n             taskStatus.statusUpdate(taskProgress.get(),\n                                     taskProgress.toString(),\n                                     counters);\n             amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n             taskFound \u003d amFeedback.getTaskFound();\n             taskStatus.clearStatus();\n           }\n           else {\n             // send ping \n             amFeedback \u003d umbilical.statusUpdate(taskId, null);\n             taskFound \u003d amFeedback.getTaskFound();\n           }\n \n           // if Task Tracker is not aware of our task ID (probably because it died and \n           // came back up), kill ourselves\n           if (!taskFound) {\n-            LOG.warn(\"Parent died.  Exiting \"+taskId);\n-            resetDoneFlag();\n-            System.exit(66);\n+            if (uberized) {\n+              taskDone.set(true);\n+              break;\n+            } else {\n+              LOG.warn(\"Parent died.  Exiting \"+taskId);\n+              resetDoneFlag();\n+              System.exit(66);\n+            }\n           }\n \n           // Set a flag that says we should preempt this is read by\n           // ReduceTasks in places of the execution where it is\n           // safe/easy to preempt\n           boolean lastPreempt \u003d mustPreempt.get();\n           mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n \n           if (lastPreempt ^ mustPreempt.get()) {\n             LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                 mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                 \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n           }\n           sendProgress \u003d resetProgressFlag();\n           remainingRetries \u003d MAX_RETRIES;\n         } catch (TaskLimitException e) {\n           String errMsg \u003d \"Task exceeded the limits: \" +\n                   StringUtils.stringifyException(e);\n           LOG.error(errMsg);\n           try {\n             umbilical.fatalError(taskId, errMsg, true);\n           } catch (IOException ioe) {\n             LOG.error(\"Failed to update failure diagnosis\", ioe);\n           }\n           LOG.error(\"Killing \" + taskId);\n           resetDoneFlag();\n           ExitUtil.terminate(69);\n         } catch (Throwable t) {\n           LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n           remainingRetries -\u003d1;\n           if (remainingRetries \u003d\u003d 0) {\n             ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n             LOG.warn(\"Last retry, killing \"+taskId);\n             resetDoneFlag();\n             System.exit(65);\n           }\n         }\n       }\n       //Notify that we are done with the work\n       resetDoneFlag();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n\n      long taskProgressInterval \u003d MRJobConfUtil.\n          getTaskProgressReportInterval(conf);\n\n      boolean uberized \u003d conf.getBoolean(\"mapreduce.task.uberized\",\n          false);\n\n      while (!taskDone.get()) {\n        synchronized (lock) {\n          done \u003d false;\n        }\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          AMFeedback amFeedback \u003d null;\n          // sleep for a bit\n          synchronized(lock) {\n            if (taskDone.get()) {\n              break;\n            }\n            lock.wait(taskProgressInterval);\n          }\n          if (taskDone.get()) {\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            checkTaskLimits();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(),\n                                    counters);\n            amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskFound \u003d amFeedback.getTaskFound();\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            amFeedback \u003d umbilical.statusUpdate(taskId, null);\n            taskFound \u003d amFeedback.getTaskFound();\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            if (uberized) {\n              taskDone.set(true);\n              break;\n            } else {\n              LOG.warn(\"Parent died.  Exiting \"+taskId);\n              resetDoneFlag();\n              System.exit(66);\n            }\n          }\n\n          // Set a flag that says we should preempt this is read by\n          // ReduceTasks in places of the execution where it is\n          // safe/easy to preempt\n          boolean lastPreempt \u003d mustPreempt.get();\n          mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n\n          if (lastPreempt ^ mustPreempt.get()) {\n            LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n          }\n          sendProgress \u003d resetProgressFlag();\n          remainingRetries \u003d MAX_RETRIES;\n        } catch (TaskLimitException e) {\n          String errMsg \u003d \"Task exceeded the limits: \" +\n                  StringUtils.stringifyException(e);\n          LOG.error(errMsg);\n          try {\n            umbilical.fatalError(taskId, errMsg, true);\n          } catch (IOException ioe) {\n            LOG.error(\"Failed to update failure diagnosis\", ioe);\n          }\n          LOG.error(\"Killing \" + taskId);\n          resetDoneFlag();\n          ExitUtil.terminate(69);\n        } catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            resetDoneFlag();\n            System.exit(65);\n          }\n        }\n      }\n      //Notify that we are done with the work\n      resetDoneFlag();\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {}
    },
    "a37e7f0ad8b68c7ed16c242bedf62f4cde48d6fd": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7022. Fast fail rogue jobs based on task scratch dir size. Contributed by Johan Gustavsson\n",
      "commitDate": "26/01/18 12:36 PM",
      "commitName": "a37e7f0ad8b68c7ed16c242bedf62f4cde48d6fd",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "05/11/17 11:28 PM",
      "commitNameOld": "61bbdc511e4e98c11a05d7c3bc01f3e971adbe13",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 81.55,
      "commitsBetweenForRepo": 546,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,91 @@\n     public void run() {\n       final int MAX_RETRIES \u003d 3;\n       int remainingRetries \u003d MAX_RETRIES;\n       // get current flag value and reset it as well\n       boolean sendProgress \u003d resetProgressFlag();\n \n       long taskProgressInterval \u003d MRJobConfUtil.\n           getTaskProgressReportInterval(conf);\n \n       while (!taskDone.get()) {\n         synchronized (lock) {\n           done \u003d false;\n         }\n         try {\n           boolean taskFound \u003d true; // whether TT knows about this task\n           AMFeedback amFeedback \u003d null;\n           // sleep for a bit\n           synchronized(lock) {\n             if (taskDone.get()) {\n               break;\n             }\n             lock.wait(taskProgressInterval);\n           }\n           if (taskDone.get()) {\n             break;\n           }\n \n           if (sendProgress) {\n             // we need to send progress update\n             updateCounters();\n             checkTaskLimits();\n             taskStatus.statusUpdate(taskProgress.get(),\n                                     taskProgress.toString(),\n                                     counters);\n             amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n             taskFound \u003d amFeedback.getTaskFound();\n             taskStatus.clearStatus();\n           }\n           else {\n             // send ping \n             amFeedback \u003d umbilical.statusUpdate(taskId, null);\n             taskFound \u003d amFeedback.getTaskFound();\n           }\n \n           // if Task Tracker is not aware of our task ID (probably because it died and \n           // came back up), kill ourselves\n           if (!taskFound) {\n             LOG.warn(\"Parent died.  Exiting \"+taskId);\n             resetDoneFlag();\n             System.exit(66);\n           }\n \n           // Set a flag that says we should preempt this is read by\n           // ReduceTasks in places of the execution where it is\n           // safe/easy to preempt\n           boolean lastPreempt \u003d mustPreempt.get();\n           mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n \n           if (lastPreempt ^ mustPreempt.get()) {\n             LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                 mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                 \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n           }\n           sendProgress \u003d resetProgressFlag();\n           remainingRetries \u003d MAX_RETRIES;\n         } catch (TaskLimitException e) {\n           String errMsg \u003d \"Task exceeded the limits: \" +\n                   StringUtils.stringifyException(e);\n           LOG.error(errMsg);\n           try {\n-            umbilical.fatalError(taskId, errMsg);\n+            umbilical.fatalError(taskId, errMsg, true);\n           } catch (IOException ioe) {\n             LOG.error(\"Failed to update failure diagnosis\", ioe);\n           }\n           LOG.error(\"Killing \" + taskId);\n           resetDoneFlag();\n           ExitUtil.terminate(69);\n         } catch (Throwable t) {\n           LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n           remainingRetries -\u003d1;\n           if (remainingRetries \u003d\u003d 0) {\n             ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n             LOG.warn(\"Last retry, killing \"+taskId);\n             resetDoneFlag();\n             System.exit(65);\n           }\n         }\n       }\n       //Notify that we are done with the work\n       resetDoneFlag();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n\n      long taskProgressInterval \u003d MRJobConfUtil.\n          getTaskProgressReportInterval(conf);\n\n      while (!taskDone.get()) {\n        synchronized (lock) {\n          done \u003d false;\n        }\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          AMFeedback amFeedback \u003d null;\n          // sleep for a bit\n          synchronized(lock) {\n            if (taskDone.get()) {\n              break;\n            }\n            lock.wait(taskProgressInterval);\n          }\n          if (taskDone.get()) {\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            checkTaskLimits();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(),\n                                    counters);\n            amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskFound \u003d amFeedback.getTaskFound();\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            amFeedback \u003d umbilical.statusUpdate(taskId, null);\n            taskFound \u003d amFeedback.getTaskFound();\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            LOG.warn(\"Parent died.  Exiting \"+taskId);\n            resetDoneFlag();\n            System.exit(66);\n          }\n\n          // Set a flag that says we should preempt this is read by\n          // ReduceTasks in places of the execution where it is\n          // safe/easy to preempt\n          boolean lastPreempt \u003d mustPreempt.get();\n          mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n\n          if (lastPreempt ^ mustPreempt.get()) {\n            LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n          }\n          sendProgress \u003d resetProgressFlag();\n          remainingRetries \u003d MAX_RETRIES;\n        } catch (TaskLimitException e) {\n          String errMsg \u003d \"Task exceeded the limits: \" +\n                  StringUtils.stringifyException(e);\n          LOG.error(errMsg);\n          try {\n            umbilical.fatalError(taskId, errMsg, true);\n          } catch (IOException ioe) {\n            LOG.error(\"Failed to update failure diagnosis\", ioe);\n          }\n          LOG.error(\"Killing \" + taskId);\n          resetDoneFlag();\n          ExitUtil.terminate(69);\n        } catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            resetDoneFlag();\n            System.exit(65);\n          }\n        }\n      }\n      //Notify that we are done with the work\n      resetDoneFlag();\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {}
    },
    "178751ed8c9d47038acf8616c226f1f52e884feb": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6983. Moving logging APIs over to slf4j in hadoop-mapreduce-client-core. Contributed by Jinjiang Ling.\n",
      "commitDate": "02/11/17 1:43 AM",
      "commitName": "178751ed8c9d47038acf8616c226f1f52e884feb",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "08/09/17 10:02 AM",
      "commitNameOld": "c35510a465cbda72c08239bcb5537375478bec3a",
      "commitAuthorOld": "Anu Engineer",
      "daysBetweenCommits": 54.65,
      "commitsBetweenForRepo": 448,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,91 @@\n     public void run() {\n       final int MAX_RETRIES \u003d 3;\n       int remainingRetries \u003d MAX_RETRIES;\n       // get current flag value and reset it as well\n       boolean sendProgress \u003d resetProgressFlag();\n \n       long taskProgressInterval \u003d MRJobConfUtil.\n           getTaskProgressReportInterval(conf);\n \n       while (!taskDone.get()) {\n         synchronized (lock) {\n           done \u003d false;\n         }\n         try {\n           boolean taskFound \u003d true; // whether TT knows about this task\n           AMFeedback amFeedback \u003d null;\n           // sleep for a bit\n           synchronized(lock) {\n             if (taskDone.get()) {\n               break;\n             }\n             lock.wait(taskProgressInterval);\n           }\n           if (taskDone.get()) {\n             break;\n           }\n \n           if (sendProgress) {\n             // we need to send progress update\n             updateCounters();\n             checkTaskLimits();\n             taskStatus.statusUpdate(taskProgress.get(),\n                                     taskProgress.toString(),\n                                     counters);\n             amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n             taskFound \u003d amFeedback.getTaskFound();\n             taskStatus.clearStatus();\n           }\n           else {\n             // send ping \n             amFeedback \u003d umbilical.statusUpdate(taskId, null);\n             taskFound \u003d amFeedback.getTaskFound();\n           }\n \n           // if Task Tracker is not aware of our task ID (probably because it died and \n           // came back up), kill ourselves\n           if (!taskFound) {\n             LOG.warn(\"Parent died.  Exiting \"+taskId);\n             resetDoneFlag();\n             System.exit(66);\n           }\n \n           // Set a flag that says we should preempt this is read by\n           // ReduceTasks in places of the execution where it is\n           // safe/easy to preempt\n           boolean lastPreempt \u003d mustPreempt.get();\n           mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n \n           if (lastPreempt ^ mustPreempt.get()) {\n             LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                 mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                 \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n           }\n           sendProgress \u003d resetProgressFlag();\n           remainingRetries \u003d MAX_RETRIES;\n         } catch (TaskLimitException e) {\n           String errMsg \u003d \"Task exceeded the limits: \" +\n                   StringUtils.stringifyException(e);\n-          LOG.fatal(errMsg);\n+          LOG.error(errMsg);\n           try {\n             umbilical.fatalError(taskId, errMsg);\n           } catch (IOException ioe) {\n-            LOG.fatal(\"Failed to update failure diagnosis\", ioe);\n+            LOG.error(\"Failed to update failure diagnosis\", ioe);\n           }\n-          LOG.fatal(\"Killing \" + taskId);\n+          LOG.error(\"Killing \" + taskId);\n           resetDoneFlag();\n           ExitUtil.terminate(69);\n         } catch (Throwable t) {\n           LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n           remainingRetries -\u003d1;\n           if (remainingRetries \u003d\u003d 0) {\n             ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n             LOG.warn(\"Last retry, killing \"+taskId);\n             resetDoneFlag();\n             System.exit(65);\n           }\n         }\n       }\n       //Notify that we are done with the work\n       resetDoneFlag();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n\n      long taskProgressInterval \u003d MRJobConfUtil.\n          getTaskProgressReportInterval(conf);\n\n      while (!taskDone.get()) {\n        synchronized (lock) {\n          done \u003d false;\n        }\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          AMFeedback amFeedback \u003d null;\n          // sleep for a bit\n          synchronized(lock) {\n            if (taskDone.get()) {\n              break;\n            }\n            lock.wait(taskProgressInterval);\n          }\n          if (taskDone.get()) {\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            checkTaskLimits();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(),\n                                    counters);\n            amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskFound \u003d amFeedback.getTaskFound();\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            amFeedback \u003d umbilical.statusUpdate(taskId, null);\n            taskFound \u003d amFeedback.getTaskFound();\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            LOG.warn(\"Parent died.  Exiting \"+taskId);\n            resetDoneFlag();\n            System.exit(66);\n          }\n\n          // Set a flag that says we should preempt this is read by\n          // ReduceTasks in places of the execution where it is\n          // safe/easy to preempt\n          boolean lastPreempt \u003d mustPreempt.get();\n          mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n\n          if (lastPreempt ^ mustPreempt.get()) {\n            LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n          }\n          sendProgress \u003d resetProgressFlag();\n          remainingRetries \u003d MAX_RETRIES;\n        } catch (TaskLimitException e) {\n          String errMsg \u003d \"Task exceeded the limits: \" +\n                  StringUtils.stringifyException(e);\n          LOG.error(errMsg);\n          try {\n            umbilical.fatalError(taskId, errMsg);\n          } catch (IOException ioe) {\n            LOG.error(\"Failed to update failure diagnosis\", ioe);\n          }\n          LOG.error(\"Killing \" + taskId);\n          resetDoneFlag();\n          ExitUtil.terminate(69);\n        } catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            resetDoneFlag();\n            System.exit(65);\n          }\n        }\n      }\n      //Notify that we are done with the work\n      resetDoneFlag();\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {}
    },
    "537095d13cd38212ed162e0a360bdd9a8bd83498": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6740. Enforce mapreduce.task.timeout to be at least mapreduce.task.progress-report.interval. (Haibo Chen via kasha)\n",
      "commitDate": "21/09/16 6:30 PM",
      "commitName": "537095d13cd38212ed162e0a360bdd9a8bd83498",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "16/09/16 9:49 PM",
      "commitNameOld": "7d21c280a82b2f02675bf0048f0e965d99a05ae7",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 4.86,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,91 @@\n     public void run() {\n       final int MAX_RETRIES \u003d 3;\n       int remainingRetries \u003d MAX_RETRIES;\n       // get current flag value and reset it as well\n       boolean sendProgress \u003d resetProgressFlag();\n-      long taskProgressInterval \u003d\n-          conf.getLong(MRJobConfig.TASK_PROGRESS_REPORT_INTERVAL,\n-                       MRJobConfig.DEFAULT_TASK_PROGRESS_REPORT_INTERVAL);\n+\n+      long taskProgressInterval \u003d MRJobConfUtil.\n+          getTaskProgressReportInterval(conf);\n+\n       while (!taskDone.get()) {\n         synchronized (lock) {\n           done \u003d false;\n         }\n         try {\n           boolean taskFound \u003d true; // whether TT knows about this task\n           AMFeedback amFeedback \u003d null;\n           // sleep for a bit\n           synchronized(lock) {\n             if (taskDone.get()) {\n               break;\n             }\n             lock.wait(taskProgressInterval);\n           }\n           if (taskDone.get()) {\n             break;\n           }\n \n           if (sendProgress) {\n             // we need to send progress update\n             updateCounters();\n             checkTaskLimits();\n             taskStatus.statusUpdate(taskProgress.get(),\n                                     taskProgress.toString(),\n                                     counters);\n             amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n             taskFound \u003d amFeedback.getTaskFound();\n             taskStatus.clearStatus();\n           }\n           else {\n             // send ping \n             amFeedback \u003d umbilical.statusUpdate(taskId, null);\n             taskFound \u003d amFeedback.getTaskFound();\n           }\n \n           // if Task Tracker is not aware of our task ID (probably because it died and \n           // came back up), kill ourselves\n           if (!taskFound) {\n             LOG.warn(\"Parent died.  Exiting \"+taskId);\n             resetDoneFlag();\n             System.exit(66);\n           }\n \n           // Set a flag that says we should preempt this is read by\n           // ReduceTasks in places of the execution where it is\n           // safe/easy to preempt\n           boolean lastPreempt \u003d mustPreempt.get();\n           mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n \n           if (lastPreempt ^ mustPreempt.get()) {\n             LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                 mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                 \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n           }\n           sendProgress \u003d resetProgressFlag();\n           remainingRetries \u003d MAX_RETRIES;\n         } catch (TaskLimitException e) {\n           String errMsg \u003d \"Task exceeded the limits: \" +\n                   StringUtils.stringifyException(e);\n           LOG.fatal(errMsg);\n           try {\n             umbilical.fatalError(taskId, errMsg);\n           } catch (IOException ioe) {\n             LOG.fatal(\"Failed to update failure diagnosis\", ioe);\n           }\n           LOG.fatal(\"Killing \" + taskId);\n           resetDoneFlag();\n           ExitUtil.terminate(69);\n         } catch (Throwable t) {\n           LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n           remainingRetries -\u003d1;\n           if (remainingRetries \u003d\u003d 0) {\n             ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n             LOG.warn(\"Last retry, killing \"+taskId);\n             resetDoneFlag();\n             System.exit(65);\n           }\n         }\n       }\n       //Notify that we are done with the work\n       resetDoneFlag();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n\n      long taskProgressInterval \u003d MRJobConfUtil.\n          getTaskProgressReportInterval(conf);\n\n      while (!taskDone.get()) {\n        synchronized (lock) {\n          done \u003d false;\n        }\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          AMFeedback amFeedback \u003d null;\n          // sleep for a bit\n          synchronized(lock) {\n            if (taskDone.get()) {\n              break;\n            }\n            lock.wait(taskProgressInterval);\n          }\n          if (taskDone.get()) {\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            checkTaskLimits();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(),\n                                    counters);\n            amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskFound \u003d amFeedback.getTaskFound();\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            amFeedback \u003d umbilical.statusUpdate(taskId, null);\n            taskFound \u003d amFeedback.getTaskFound();\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            LOG.warn(\"Parent died.  Exiting \"+taskId);\n            resetDoneFlag();\n            System.exit(66);\n          }\n\n          // Set a flag that says we should preempt this is read by\n          // ReduceTasks in places of the execution where it is\n          // safe/easy to preempt\n          boolean lastPreempt \u003d mustPreempt.get();\n          mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n\n          if (lastPreempt ^ mustPreempt.get()) {\n            LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n          }\n          sendProgress \u003d resetProgressFlag();\n          remainingRetries \u003d MAX_RETRIES;\n        } catch (TaskLimitException e) {\n          String errMsg \u003d \"Task exceeded the limits: \" +\n                  StringUtils.stringifyException(e);\n          LOG.fatal(errMsg);\n          try {\n            umbilical.fatalError(taskId, errMsg);\n          } catch (IOException ioe) {\n            LOG.fatal(\"Failed to update failure diagnosis\", ioe);\n          }\n          LOG.fatal(\"Killing \" + taskId);\n          resetDoneFlag();\n          ExitUtil.terminate(69);\n        } catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            resetDoneFlag();\n            System.exit(65);\n          }\n        }\n      }\n      //Notify that we are done with the work\n      resetDoneFlag();\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {}
    },
    "cb26cd4bee8ab75b304ebad6dc7c77523d0e9ce5": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6489. Fail fast rogue tasks that write too much to local disk. Contributed by Maysam Yabandeh\n",
      "commitDate": "21/10/15 7:01 AM",
      "commitName": "cb26cd4bee8ab75b304ebad6dc7c77523d0e9ce5",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "05/06/15 9:14 AM",
      "commitNameOld": "6786daab33792c9c426adf0fc6b361f193d356a8",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 137.91,
      "commitsBetweenForRepo": 923,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,90 @@\n     public void run() {\n       final int MAX_RETRIES \u003d 3;\n       int remainingRetries \u003d MAX_RETRIES;\n       // get current flag value and reset it as well\n       boolean sendProgress \u003d resetProgressFlag();\n       long taskProgressInterval \u003d\n           conf.getLong(MRJobConfig.TASK_PROGRESS_REPORT_INTERVAL,\n                        MRJobConfig.DEFAULT_TASK_PROGRESS_REPORT_INTERVAL);\n       while (!taskDone.get()) {\n         synchronized (lock) {\n           done \u003d false;\n         }\n         try {\n           boolean taskFound \u003d true; // whether TT knows about this task\n           AMFeedback amFeedback \u003d null;\n           // sleep for a bit\n           synchronized(lock) {\n             if (taskDone.get()) {\n               break;\n             }\n             lock.wait(taskProgressInterval);\n           }\n           if (taskDone.get()) {\n             break;\n           }\n \n           if (sendProgress) {\n             // we need to send progress update\n             updateCounters();\n+            checkTaskLimits();\n             taskStatus.statusUpdate(taskProgress.get(),\n-                                    taskProgress.toString(), \n+                                    taskProgress.toString(),\n                                     counters);\n             amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n             taskFound \u003d amFeedback.getTaskFound();\n             taskStatus.clearStatus();\n           }\n           else {\n             // send ping \n             amFeedback \u003d umbilical.statusUpdate(taskId, null);\n             taskFound \u003d amFeedback.getTaskFound();\n           }\n \n           // if Task Tracker is not aware of our task ID (probably because it died and \n           // came back up), kill ourselves\n           if (!taskFound) {\n             LOG.warn(\"Parent died.  Exiting \"+taskId);\n             resetDoneFlag();\n             System.exit(66);\n           }\n \n           // Set a flag that says we should preempt this is read by\n           // ReduceTasks in places of the execution where it is\n           // safe/easy to preempt\n           boolean lastPreempt \u003d mustPreempt.get();\n           mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n \n           if (lastPreempt ^ mustPreempt.get()) {\n             LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                 mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                 \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n           }\n-          sendProgress \u003d resetProgressFlag(); \n+          sendProgress \u003d resetProgressFlag();\n           remainingRetries \u003d MAX_RETRIES;\n-        } \n-        catch (Throwable t) {\n+        } catch (TaskLimitException e) {\n+          String errMsg \u003d \"Task exceeded the limits: \" +\n+                  StringUtils.stringifyException(e);\n+          LOG.fatal(errMsg);\n+          try {\n+            umbilical.fatalError(taskId, errMsg);\n+          } catch (IOException ioe) {\n+            LOG.fatal(\"Failed to update failure diagnosis\", ioe);\n+          }\n+          LOG.fatal(\"Killing \" + taskId);\n+          resetDoneFlag();\n+          ExitUtil.terminate(69);\n+        } catch (Throwable t) {\n           LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n           remainingRetries -\u003d1;\n           if (remainingRetries \u003d\u003d 0) {\n             ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n             LOG.warn(\"Last retry, killing \"+taskId);\n             resetDoneFlag();\n             System.exit(65);\n           }\n         }\n       }\n       //Notify that we are done with the work\n       resetDoneFlag();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n      long taskProgressInterval \u003d\n          conf.getLong(MRJobConfig.TASK_PROGRESS_REPORT_INTERVAL,\n                       MRJobConfig.DEFAULT_TASK_PROGRESS_REPORT_INTERVAL);\n      while (!taskDone.get()) {\n        synchronized (lock) {\n          done \u003d false;\n        }\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          AMFeedback amFeedback \u003d null;\n          // sleep for a bit\n          synchronized(lock) {\n            if (taskDone.get()) {\n              break;\n            }\n            lock.wait(taskProgressInterval);\n          }\n          if (taskDone.get()) {\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            checkTaskLimits();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(),\n                                    counters);\n            amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskFound \u003d amFeedback.getTaskFound();\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            amFeedback \u003d umbilical.statusUpdate(taskId, null);\n            taskFound \u003d amFeedback.getTaskFound();\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            LOG.warn(\"Parent died.  Exiting \"+taskId);\n            resetDoneFlag();\n            System.exit(66);\n          }\n\n          // Set a flag that says we should preempt this is read by\n          // ReduceTasks in places of the execution where it is\n          // safe/easy to preempt\n          boolean lastPreempt \u003d mustPreempt.get();\n          mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n\n          if (lastPreempt ^ mustPreempt.get()) {\n            LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n          }\n          sendProgress \u003d resetProgressFlag();\n          remainingRetries \u003d MAX_RETRIES;\n        } catch (TaskLimitException e) {\n          String errMsg \u003d \"Task exceeded the limits: \" +\n                  StringUtils.stringifyException(e);\n          LOG.fatal(errMsg);\n          try {\n            umbilical.fatalError(taskId, errMsg);\n          } catch (IOException ioe) {\n            LOG.fatal(\"Failed to update failure diagnosis\", ioe);\n          }\n          LOG.fatal(\"Killing \" + taskId);\n          resetDoneFlag();\n          ExitUtil.terminate(69);\n        } catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            resetDoneFlag();\n            System.exit(65);\n          }\n        }\n      }\n      //Notify that we are done with the work\n      resetDoneFlag();\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {}
    },
    "7e6f384dd742de21f29e96ee76df5316529c9019": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6242. Progress report log is incredibly excessive in application\nmaster. Contributed by Varun Saxena.\n",
      "commitDate": "23/03/15 10:21 AM",
      "commitName": "7e6f384dd742de21f29e96ee76df5316529c9019",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "02/03/15 9:17 PM",
      "commitNameOld": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 20.5,
      "commitsBetweenForRepo": 177,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,78 @@\n     public void run() {\n       final int MAX_RETRIES \u003d 3;\n       int remainingRetries \u003d MAX_RETRIES;\n       // get current flag value and reset it as well\n       boolean sendProgress \u003d resetProgressFlag();\n+      long taskProgressInterval \u003d\n+          conf.getLong(MRJobConfig.TASK_PROGRESS_REPORT_INTERVAL,\n+                       MRJobConfig.DEFAULT_TASK_PROGRESS_REPORT_INTERVAL);\n       while (!taskDone.get()) {\n         synchronized (lock) {\n           done \u003d false;\n         }\n         try {\n           boolean taskFound \u003d true; // whether TT knows about this task\n           AMFeedback amFeedback \u003d null;\n           // sleep for a bit\n           synchronized(lock) {\n             if (taskDone.get()) {\n               break;\n             }\n-            lock.wait(PROGRESS_INTERVAL);\n+            lock.wait(taskProgressInterval);\n           }\n           if (taskDone.get()) {\n             break;\n           }\n \n           if (sendProgress) {\n             // we need to send progress update\n             updateCounters();\n             taskStatus.statusUpdate(taskProgress.get(),\n                                     taskProgress.toString(), \n                                     counters);\n             amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n             taskFound \u003d amFeedback.getTaskFound();\n             taskStatus.clearStatus();\n           }\n           else {\n             // send ping \n             amFeedback \u003d umbilical.statusUpdate(taskId, null);\n             taskFound \u003d amFeedback.getTaskFound();\n           }\n \n           // if Task Tracker is not aware of our task ID (probably because it died and \n           // came back up), kill ourselves\n           if (!taskFound) {\n             LOG.warn(\"Parent died.  Exiting \"+taskId);\n             resetDoneFlag();\n             System.exit(66);\n           }\n \n           // Set a flag that says we should preempt this is read by\n           // ReduceTasks in places of the execution where it is\n           // safe/easy to preempt\n           boolean lastPreempt \u003d mustPreempt.get();\n           mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n \n           if (lastPreempt ^ mustPreempt.get()) {\n             LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                 mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                 \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n           }\n           sendProgress \u003d resetProgressFlag(); \n           remainingRetries \u003d MAX_RETRIES;\n         } \n         catch (Throwable t) {\n           LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n           remainingRetries -\u003d1;\n           if (remainingRetries \u003d\u003d 0) {\n             ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n             LOG.warn(\"Last retry, killing \"+taskId);\n             resetDoneFlag();\n             System.exit(65);\n           }\n         }\n       }\n       //Notify that we are done with the work\n       resetDoneFlag();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n      long taskProgressInterval \u003d\n          conf.getLong(MRJobConfig.TASK_PROGRESS_REPORT_INTERVAL,\n                       MRJobConfig.DEFAULT_TASK_PROGRESS_REPORT_INTERVAL);\n      while (!taskDone.get()) {\n        synchronized (lock) {\n          done \u003d false;\n        }\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          AMFeedback amFeedback \u003d null;\n          // sleep for a bit\n          synchronized(lock) {\n            if (taskDone.get()) {\n              break;\n            }\n            lock.wait(taskProgressInterval);\n          }\n          if (taskDone.get()) {\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(), \n                                    counters);\n            amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskFound \u003d amFeedback.getTaskFound();\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            amFeedback \u003d umbilical.statusUpdate(taskId, null);\n            taskFound \u003d amFeedback.getTaskFound();\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            LOG.warn(\"Parent died.  Exiting \"+taskId);\n            resetDoneFlag();\n            System.exit(66);\n          }\n\n          // Set a flag that says we should preempt this is read by\n          // ReduceTasks in places of the execution where it is\n          // safe/easy to preempt\n          boolean lastPreempt \u003d mustPreempt.get();\n          mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n\n          if (lastPreempt ^ mustPreempt.get()) {\n            LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n          }\n          sendProgress \u003d resetProgressFlag(); \n          remainingRetries \u003d MAX_RETRIES;\n        } \n        catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            resetDoneFlag();\n            System.exit(65);\n          }\n        }\n      }\n      //Notify that we are done with the work\n      resetDoneFlag();\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {}
    },
    "47cca0cb6d1f4e5979d11d9a624b005e6e666f2f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5196. Add bookkeeping for managing checkpoints of task state.\nContributed by Carlo Curino\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1553939 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/12/13 1:58 PM",
      "commitName": "47cca0cb6d1f4e5979d11d9a624b005e6e666f2f",
      "commitAuthor": "Christopher Douglas",
      "commitDateOld": "15/03/13 2:09 PM",
      "commitNameOld": "7d7553c4eb7d9a282410a3213d26a89fea9b7865",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 288.03,
      "commitsBetweenForRepo": 1794,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,75 @@\n     public void run() {\n       final int MAX_RETRIES \u003d 3;\n       int remainingRetries \u003d MAX_RETRIES;\n       // get current flag value and reset it as well\n       boolean sendProgress \u003d resetProgressFlag();\n       while (!taskDone.get()) {\n         synchronized (lock) {\n           done \u003d false;\n         }\n         try {\n           boolean taskFound \u003d true; // whether TT knows about this task\n+          AMFeedback amFeedback \u003d null;\n           // sleep for a bit\n           synchronized(lock) {\n             if (taskDone.get()) {\n               break;\n             }\n             lock.wait(PROGRESS_INTERVAL);\n           }\n           if (taskDone.get()) {\n             break;\n           }\n \n           if (sendProgress) {\n             // we need to send progress update\n             updateCounters();\n             taskStatus.statusUpdate(taskProgress.get(),\n                                     taskProgress.toString(), \n                                     counters);\n-            taskFound \u003d umbilical.statusUpdate(taskId, taskStatus);\n+            amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n+            taskFound \u003d amFeedback.getTaskFound();\n             taskStatus.clearStatus();\n           }\n           else {\n             // send ping \n-            taskFound \u003d umbilical.ping(taskId);\n+            amFeedback \u003d umbilical.statusUpdate(taskId, null);\n+            taskFound \u003d amFeedback.getTaskFound();\n           }\n \n           // if Task Tracker is not aware of our task ID (probably because it died and \n           // came back up), kill ourselves\n           if (!taskFound) {\n             LOG.warn(\"Parent died.  Exiting \"+taskId);\n             resetDoneFlag();\n             System.exit(66);\n           }\n \n+          // Set a flag that says we should preempt this is read by\n+          // ReduceTasks in places of the execution where it is\n+          // safe/easy to preempt\n+          boolean lastPreempt \u003d mustPreempt.get();\n+          mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n+\n+          if (lastPreempt ^ mustPreempt.get()) {\n+            LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n+                mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n+                \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n+          }\n           sendProgress \u003d resetProgressFlag(); \n           remainingRetries \u003d MAX_RETRIES;\n         } \n         catch (Throwable t) {\n           LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n           remainingRetries -\u003d1;\n           if (remainingRetries \u003d\u003d 0) {\n             ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n             LOG.warn(\"Last retry, killing \"+taskId);\n             resetDoneFlag();\n             System.exit(65);\n           }\n         }\n       }\n       //Notify that we are done with the work\n       resetDoneFlag();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n      while (!taskDone.get()) {\n        synchronized (lock) {\n          done \u003d false;\n        }\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          AMFeedback amFeedback \u003d null;\n          // sleep for a bit\n          synchronized(lock) {\n            if (taskDone.get()) {\n              break;\n            }\n            lock.wait(PROGRESS_INTERVAL);\n          }\n          if (taskDone.get()) {\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(), \n                                    counters);\n            amFeedback \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskFound \u003d amFeedback.getTaskFound();\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            amFeedback \u003d umbilical.statusUpdate(taskId, null);\n            taskFound \u003d amFeedback.getTaskFound();\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            LOG.warn(\"Parent died.  Exiting \"+taskId);\n            resetDoneFlag();\n            System.exit(66);\n          }\n\n          // Set a flag that says we should preempt this is read by\n          // ReduceTasks in places of the execution where it is\n          // safe/easy to preempt\n          boolean lastPreempt \u003d mustPreempt.get();\n          mustPreempt.set(mustPreempt.get() || amFeedback.getPreemption());\n\n          if (lastPreempt ^ mustPreempt.get()) {\n            LOG.info(\"PREEMPTION TASK: setting mustPreempt to \" +\n                mustPreempt.get() + \" given \" + amFeedback.getPreemption() +\n                \" for \"+ taskId + \" task status: \" +taskStatus.getPhase());\n          }\n          sendProgress \u003d resetProgressFlag(); \n          remainingRetries \u003d MAX_RETRIES;\n        } \n        catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            resetDoneFlag();\n            System.exit(65);\n          }\n        }\n      }\n      //Notify that we are done with the work\n      resetDoneFlag();\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {}
    },
    "75d2d6185e38f014658a06541894fd7f75b9baee": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3809. Ensure that there is no needless sleep in Task at the end of the task. Contributed by Siddharth Seth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1241282 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/02/12 4:13 PM",
      "commitName": "75d2d6185e38f014658a06541894fd7f75b9baee",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "03/02/12 4:04 PM",
      "commitNameOld": "94242c93857a06fb9c56ee571a47d6ca18f00f48",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.01,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,61 @@\n     public void run() {\n       final int MAX_RETRIES \u003d 3;\n       int remainingRetries \u003d MAX_RETRIES;\n       // get current flag value and reset it as well\n       boolean sendProgress \u003d resetProgressFlag();\n       while (!taskDone.get()) {\n         synchronized (lock) {\n           done \u003d false;\n         }\n         try {\n           boolean taskFound \u003d true; // whether TT knows about this task\n           // sleep for a bit\n-          try {\n-            Thread.sleep(PROGRESS_INTERVAL);\n-          } \n-          catch (InterruptedException e) {\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(getTaskID() + \" Progress/ping thread exiting \" +\n-                        \"since it got interrupted\");\n+          synchronized(lock) {\n+            if (taskDone.get()) {\n+              break;\n             }\n+            lock.wait(PROGRESS_INTERVAL);\n+          }\n+          if (taskDone.get()) {\n             break;\n           }\n \n           if (sendProgress) {\n             // we need to send progress update\n             updateCounters();\n             taskStatus.statusUpdate(taskProgress.get(),\n                                     taskProgress.toString(), \n                                     counters);\n             taskFound \u003d umbilical.statusUpdate(taskId, taskStatus);\n             taskStatus.clearStatus();\n           }\n           else {\n             // send ping \n             taskFound \u003d umbilical.ping(taskId);\n           }\n \n           // if Task Tracker is not aware of our task ID (probably because it died and \n           // came back up), kill ourselves\n           if (!taskFound) {\n             LOG.warn(\"Parent died.  Exiting \"+taskId);\n             resetDoneFlag();\n             System.exit(66);\n           }\n \n           sendProgress \u003d resetProgressFlag(); \n           remainingRetries \u003d MAX_RETRIES;\n         } \n         catch (Throwable t) {\n           LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n           remainingRetries -\u003d1;\n           if (remainingRetries \u003d\u003d 0) {\n             ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n             LOG.warn(\"Last retry, killing \"+taskId);\n             resetDoneFlag();\n             System.exit(65);\n           }\n         }\n       }\n       //Notify that we are done with the work\n       resetDoneFlag();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n      while (!taskDone.get()) {\n        synchronized (lock) {\n          done \u003d false;\n        }\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          // sleep for a bit\n          synchronized(lock) {\n            if (taskDone.get()) {\n              break;\n            }\n            lock.wait(PROGRESS_INTERVAL);\n          }\n          if (taskDone.get()) {\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(), \n                                    counters);\n            taskFound \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            taskFound \u003d umbilical.ping(taskId);\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            LOG.warn(\"Parent died.  Exiting \"+taskId);\n            resetDoneFlag();\n            System.exit(66);\n          }\n\n          sendProgress \u003d resetProgressFlag(); \n          remainingRetries \u003d MAX_RETRIES;\n        } \n        catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            resetDoneFlag();\n            System.exit(65);\n          }\n        }\n      }\n      //Notify that we are done with the work\n      resetDoneFlag();\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {}
    },
    "d05e6d2671db3876756e5a55c369c189a8fcbdb7": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2450. Fixed a corner case with interrupted communication threads leading to a long timeout in Task. Contributed by Rajesh Balamohan.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1232314 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/01/12 10:10 PM",
      "commitName": "d05e6d2671db3876756e5a55c369c189a8fcbdb7",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "20/12/11 2:01 PM",
      "commitNameOld": "96247ead035cc4d6b7be477e1875e8112298ce3d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 27.34,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,62 @@\n     public void run() {\n       final int MAX_RETRIES \u003d 3;\n       int remainingRetries \u003d MAX_RETRIES;\n       // get current flag value and reset it as well\n       boolean sendProgress \u003d resetProgressFlag();\n       while (!taskDone.get()) {\n+        synchronized (lock) {\n+          done \u003d false;\n+        }\n         try {\n           boolean taskFound \u003d true; // whether TT knows about this task\n           // sleep for a bit\n           try {\n             Thread.sleep(PROGRESS_INTERVAL);\n           } \n           catch (InterruptedException e) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(getTaskID() + \" Progress/ping thread exiting \" +\n                         \"since it got interrupted\");\n             }\n             break;\n           }\n \n           if (sendProgress) {\n             // we need to send progress update\n             updateCounters();\n             taskStatus.statusUpdate(taskProgress.get(),\n                                     taskProgress.toString(), \n                                     counters);\n             taskFound \u003d umbilical.statusUpdate(taskId, taskStatus);\n             taskStatus.clearStatus();\n           }\n           else {\n             // send ping \n             taskFound \u003d umbilical.ping(taskId);\n           }\n \n           // if Task Tracker is not aware of our task ID (probably because it died and \n           // came back up), kill ourselves\n           if (!taskFound) {\n             LOG.warn(\"Parent died.  Exiting \"+taskId);\n+            resetDoneFlag();\n             System.exit(66);\n           }\n \n           sendProgress \u003d resetProgressFlag(); \n           remainingRetries \u003d MAX_RETRIES;\n         } \n         catch (Throwable t) {\n           LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n           remainingRetries -\u003d1;\n           if (remainingRetries \u003d\u003d 0) {\n             ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n             LOG.warn(\"Last retry, killing \"+taskId);\n+            resetDoneFlag();\n             System.exit(65);\n           }\n         }\n       }\n+      //Notify that we are done with the work\n+      resetDoneFlag();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n      while (!taskDone.get()) {\n        synchronized (lock) {\n          done \u003d false;\n        }\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          // sleep for a bit\n          try {\n            Thread.sleep(PROGRESS_INTERVAL);\n          } \n          catch (InterruptedException e) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(getTaskID() + \" Progress/ping thread exiting \" +\n                        \"since it got interrupted\");\n            }\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(), \n                                    counters);\n            taskFound \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            taskFound \u003d umbilical.ping(taskId);\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            LOG.warn(\"Parent died.  Exiting \"+taskId);\n            resetDoneFlag();\n            System.exit(66);\n          }\n\n          sendProgress \u003d resetProgressFlag(); \n          remainingRetries \u003d MAX_RETRIES;\n        } \n        catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            resetDoneFlag();\n            System.exit(65);\n          }\n        }\n      }\n      //Notify that we are done with the work\n      resetDoneFlag();\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n      while (!taskDone.get()) {\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          // sleep for a bit\n          try {\n            Thread.sleep(PROGRESS_INTERVAL);\n          } \n          catch (InterruptedException e) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(getTaskID() + \" Progress/ping thread exiting \" +\n                        \"since it got interrupted\");\n            }\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(), \n                                    counters);\n            taskFound \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            taskFound \u003d umbilical.ping(taskId);\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            LOG.warn(\"Parent died.  Exiting \"+taskId);\n            System.exit(66);\n          }\n\n          sendProgress \u003d resetProgressFlag(); \n          remainingRetries \u003d MAX_RETRIES;\n        } \n        catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            System.exit(65);\n          }\n        }\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Ymovefromfile",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/08/11 8:02 PM",
      "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n      while (!taskDone.get()) {\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          // sleep for a bit\n          try {\n            Thread.sleep(PROGRESS_INTERVAL);\n          } \n          catch (InterruptedException e) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(getTaskID() + \" Progress/ping thread exiting \" +\n                        \"since it got interrupted\");\n            }\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(), \n                                    counters);\n            taskFound \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            taskFound \u003d umbilical.ping(taskId);\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            LOG.warn(\"Parent died.  Exiting \"+taskId);\n            System.exit(66);\n          }\n\n          sendProgress \u003d resetProgressFlag(); \n          remainingRetries \u003d MAX_RETRIES;\n        } \n        catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            System.exit(65);\n          }\n        }\n      }\n    }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
      "extendedDetails": {
        "oldPath": "mapreduce/src/java/org/apache/hadoop/mapred/Task.java",
        "newPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/Task.java",
        "oldMethodName": "run",
        "newMethodName": "run"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,55 @@\n+    public void run() {\n+      final int MAX_RETRIES \u003d 3;\n+      int remainingRetries \u003d MAX_RETRIES;\n+      // get current flag value and reset it as well\n+      boolean sendProgress \u003d resetProgressFlag();\n+      while (!taskDone.get()) {\n+        try {\n+          boolean taskFound \u003d true; // whether TT knows about this task\n+          // sleep for a bit\n+          try {\n+            Thread.sleep(PROGRESS_INTERVAL);\n+          } \n+          catch (InterruptedException e) {\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(getTaskID() + \" Progress/ping thread exiting \" +\n+                        \"since it got interrupted\");\n+            }\n+            break;\n+          }\n+\n+          if (sendProgress) {\n+            // we need to send progress update\n+            updateCounters();\n+            taskStatus.statusUpdate(taskProgress.get(),\n+                                    taskProgress.toString(), \n+                                    counters);\n+            taskFound \u003d umbilical.statusUpdate(taskId, taskStatus);\n+            taskStatus.clearStatus();\n+          }\n+          else {\n+            // send ping \n+            taskFound \u003d umbilical.ping(taskId);\n+          }\n+\n+          // if Task Tracker is not aware of our task ID (probably because it died and \n+          // came back up), kill ourselves\n+          if (!taskFound) {\n+            LOG.warn(\"Parent died.  Exiting \"+taskId);\n+            System.exit(66);\n+          }\n+\n+          sendProgress \u003d resetProgressFlag(); \n+          remainingRetries \u003d MAX_RETRIES;\n+        } \n+        catch (Throwable t) {\n+          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n+          remainingRetries -\u003d1;\n+          if (remainingRetries \u003d\u003d 0) {\n+            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n+            LOG.warn(\"Last retry, killing \"+taskId);\n+            System.exit(65);\n+          }\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      final int MAX_RETRIES \u003d 3;\n      int remainingRetries \u003d MAX_RETRIES;\n      // get current flag value and reset it as well\n      boolean sendProgress \u003d resetProgressFlag();\n      while (!taskDone.get()) {\n        try {\n          boolean taskFound \u003d true; // whether TT knows about this task\n          // sleep for a bit\n          try {\n            Thread.sleep(PROGRESS_INTERVAL);\n          } \n          catch (InterruptedException e) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(getTaskID() + \" Progress/ping thread exiting \" +\n                        \"since it got interrupted\");\n            }\n            break;\n          }\n\n          if (sendProgress) {\n            // we need to send progress update\n            updateCounters();\n            taskStatus.statusUpdate(taskProgress.get(),\n                                    taskProgress.toString(), \n                                    counters);\n            taskFound \u003d umbilical.statusUpdate(taskId, taskStatus);\n            taskStatus.clearStatus();\n          }\n          else {\n            // send ping \n            taskFound \u003d umbilical.ping(taskId);\n          }\n\n          // if Task Tracker is not aware of our task ID (probably because it died and \n          // came back up), kill ourselves\n          if (!taskFound) {\n            LOG.warn(\"Parent died.  Exiting \"+taskId);\n            System.exit(66);\n          }\n\n          sendProgress \u003d resetProgressFlag(); \n          remainingRetries \u003d MAX_RETRIES;\n        } \n        catch (Throwable t) {\n          LOG.info(\"Communication exception: \" + StringUtils.stringifyException(t));\n          remainingRetries -\u003d1;\n          if (remainingRetries \u003d\u003d 0) {\n            ReflectionUtils.logThreadInfo(LOG, \"Communication exception\", 0);\n            LOG.warn(\"Last retry, killing \"+taskId);\n            System.exit(65);\n          }\n        }\n      }\n    }",
      "path": "mapreduce/src/java/org/apache/hadoop/mapred/Task.java"
    }
  }
}