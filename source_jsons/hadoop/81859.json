{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "GcTimeMonitor.java",
  "functionName": "calculateGCTimePercentageWithinObservedInterval",
  "functionId": "calculateGCTimePercentageWithinObservedInterval",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/GcTimeMonitor.java",
  "functionStartLine": 177,
  "functionEndLine": 215,
  "numCommitsSeen": 2,
  "timeTaken": 553,
  "changeHistory": [
    "3c6adda291745c592741b87cd613214ae11887e4"
  ],
  "changeHistoryShort": {
    "3c6adda291745c592741b87cd613214ae11887e4": "Yintroduced"
  },
  "changeHistoryDetails": {
    "3c6adda291745c592741b87cd613214ae11887e4": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-14960. Add GC time percentage monitor/alerter. Contributed by Misha Dmitriev.\n",
      "commitDate": "09/11/17 9:06 PM",
      "commitName": "3c6adda291745c592741b87cd613214ae11887e4",
      "commitAuthor": "Xiao Chen",
      "diff": "@@ -0,0 +1,39 @@\n+  private void calculateGCTimePercentageWithinObservedInterval() {\n+    long prevTotalGcTime \u003d curData.totalGcTime;\n+    long totalGcTime \u003d 0;\n+    long totalGcCount \u003d 0;\n+    for (GarbageCollectorMXBean gcBean : gcBeans) {\n+      totalGcTime +\u003d gcBean.getCollectionTime();\n+      totalGcCount +\u003d gcBean.getCollectionCount();\n+    }\n+    long gcTimeWithinSleepInterval \u003d totalGcTime - prevTotalGcTime;\n+\n+    long ts \u003d System.currentTimeMillis();\n+    long gcMonitorRunTime \u003d ts - startTime;\n+\n+    endIdx \u003d (endIdx + 1) % bufSize;\n+    gcDataBuf[endIdx].setValues(ts, gcTimeWithinSleepInterval);\n+\n+    // Move startIdx forward until we reach the first buffer entry with\n+    // timestamp within the observation window.\n+    long startObsWindowTs \u003d ts - observationWindowMs;\n+    while (gcDataBuf[startIdx].ts \u003c startObsWindowTs \u0026\u0026 startIdx !\u003d endIdx) {\n+      startIdx \u003d (startIdx + 1) % bufSize;\n+    }\n+\n+    // Calculate total GC time within observationWindowMs.\n+    // We should be careful about GC time that passed before the first timestamp\n+    // in our observation window.\n+    long gcTimeWithinObservationWindow \u003d Math.min(\n+        gcDataBuf[startIdx].gcPause, gcDataBuf[startIdx].ts - startObsWindowTs);\n+    if (startIdx !\u003d endIdx) {\n+      for (int i \u003d (startIdx + 1) % bufSize; i !\u003d endIdx;\n+           i \u003d (i + 1) % bufSize) {\n+        gcTimeWithinObservationWindow +\u003d gcDataBuf[i].gcPause;\n+      }\n+    }\n+\n+    curData.update(ts, gcMonitorRunTime, totalGcTime, totalGcCount,\n+        (int) (gcTimeWithinObservationWindow * 100 /\n+          Math.min(observationWindowMs, gcMonitorRunTime)));\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void calculateGCTimePercentageWithinObservedInterval() {\n    long prevTotalGcTime \u003d curData.totalGcTime;\n    long totalGcTime \u003d 0;\n    long totalGcCount \u003d 0;\n    for (GarbageCollectorMXBean gcBean : gcBeans) {\n      totalGcTime +\u003d gcBean.getCollectionTime();\n      totalGcCount +\u003d gcBean.getCollectionCount();\n    }\n    long gcTimeWithinSleepInterval \u003d totalGcTime - prevTotalGcTime;\n\n    long ts \u003d System.currentTimeMillis();\n    long gcMonitorRunTime \u003d ts - startTime;\n\n    endIdx \u003d (endIdx + 1) % bufSize;\n    gcDataBuf[endIdx].setValues(ts, gcTimeWithinSleepInterval);\n\n    // Move startIdx forward until we reach the first buffer entry with\n    // timestamp within the observation window.\n    long startObsWindowTs \u003d ts - observationWindowMs;\n    while (gcDataBuf[startIdx].ts \u003c startObsWindowTs \u0026\u0026 startIdx !\u003d endIdx) {\n      startIdx \u003d (startIdx + 1) % bufSize;\n    }\n\n    // Calculate total GC time within observationWindowMs.\n    // We should be careful about GC time that passed before the first timestamp\n    // in our observation window.\n    long gcTimeWithinObservationWindow \u003d Math.min(\n        gcDataBuf[startIdx].gcPause, gcDataBuf[startIdx].ts - startObsWindowTs);\n    if (startIdx !\u003d endIdx) {\n      for (int i \u003d (startIdx + 1) % bufSize; i !\u003d endIdx;\n           i \u003d (i + 1) % bufSize) {\n        gcTimeWithinObservationWindow +\u003d gcDataBuf[i].gcPause;\n      }\n    }\n\n    curData.update(ts, gcMonitorRunTime, totalGcTime, totalGcCount,\n        (int) (gcTimeWithinObservationWindow * 100 /\n          Math.min(observationWindowMs, gcMonitorRunTime)));\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/GcTimeMonitor.java"
    }
  }
}