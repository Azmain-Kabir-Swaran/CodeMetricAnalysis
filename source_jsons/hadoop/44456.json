{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ApplicationMaster.java",
  "functionName": "onContainersCompleted",
  "functionId": "onContainersCompleted___completedContainers-List__ContainerStatus__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
  "functionStartLine": 1075,
  "functionEndLine": 1167,
  "numCommitsSeen": 113,
  "timeTaken": 5873,
  "changeHistory": [
    "1ef0a1db1d6a412b2a26782329a8325635866d0a",
    "e60f51299dba360d13aa39f9ab714fdfc666b532",
    "d09058b2fd18803d12f0835fdf78aef5e0b99c90",
    "092fead5d9875fb3760206bcdd76cdafec5e9481",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
    "7438966586f1896ab3e8b067d47a4af28a894106",
    "c298a9a845f89317eb9efad332e6657c56736a4d",
    "1d4612f5ad9678c952b416e798dccd20c88f96ef",
    "3de66011c2e80d7c458a67f80042af986fcc677d",
    "7e54b1c6d9dc3a7fb07df36347130d605bd0a718",
    "fd1c424548999cb8843f40cb6a342387f98bde6c",
    "42c3cd3d137ba1de1c0573c0bb655fa380ed9412",
    "3520039979188c4ca6e69654223b3ac794e8bf8f",
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e",
    "0e01f26821caa3bf8554afe422bb080abcfe1e83",
    "28bac402953a4337deedf0472611f5775c7a74c9"
  ],
  "changeHistoryShort": {
    "1ef0a1db1d6a412b2a26782329a8325635866d0a": "Ybodychange",
    "e60f51299dba360d13aa39f9ab714fdfc666b532": "Ybodychange",
    "d09058b2fd18803d12f0835fdf78aef5e0b99c90": "Ybodychange",
    "092fead5d9875fb3760206bcdd76cdafec5e9481": "Ybodychange",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c": "Ybodychange",
    "7438966586f1896ab3e8b067d47a4af28a894106": "Ybodychange",
    "c298a9a845f89317eb9efad332e6657c56736a4d": "Ybodychange",
    "1d4612f5ad9678c952b416e798dccd20c88f96ef": "Ybodychange",
    "3de66011c2e80d7c458a67f80042af986fcc677d": "Ybodychange",
    "7e54b1c6d9dc3a7fb07df36347130d605bd0a718": "Ybodychange",
    "fd1c424548999cb8843f40cb6a342387f98bde6c": "Ybodychange",
    "42c3cd3d137ba1de1c0573c0bb655fa380ed9412": "Ybodychange",
    "3520039979188c4ca6e69654223b3ac794e8bf8f": "Ybodychange",
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e": "Ybodychange",
    "0e01f26821caa3bf8554afe422bb080abcfe1e83": "Ybodychange",
    "28bac402953a4337deedf0472611f5775c7a74c9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1ef0a1db1d6a412b2a26782329a8325635866d0a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7894. Improve ATS response for DShell DS_CONTAINER when container launch fails. Contributed by Chandni Singh\n",
      "commitDate": "08/05/18 1:49 PM",
      "commitName": "1ef0a1db1d6a412b2a26782329a8325635866d0a",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "01/05/18 7:27 AM",
      "commitNameOld": "4e1382aca4cf23ca229bdd24e0f143c22449b329",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 7.27,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,93 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n-        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n+        String message \u003d appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n-            + containerStatus.getDiagnostics());\n+            + containerStatus.getDiagnostics();\n+        if (containerStatus.getExitStatus() !\u003d 0) {\n+          LOG.error(message);\n+          diagnostics.append(containerStatus.getDiagnostics());\n+        } else {\n+          LOG.info(message);\n+        }\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n         // ignore containers we know nothing about - probably from a previous\n         // attempt\n         if (!launchedContainers.contains(containerStatus.getContainerId())) {\n           LOG.info(\"Ignoring completed status of \"\n               + containerStatus.getContainerId()\n               + \"; unknown container(probably launched by previous attempt)\");\n           continue;\n         }\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n \n             // Ignore these containers if placementspec is enabled\n             // for the time being.\n             if (placementSpecs !\u003d null) {\n               numIgnore.incrementAndGet();\n             }\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n         if (timelineServiceV2Enabled) {\n           Long containerStartTime \u003d\n               containerStartTimes.get(containerStatus.getContainerId());\n           if (containerStartTime \u003d\u003d null) {\n             containerStartTime \u003d SystemClock.getInstance().getTime();\n             containerStartTimes.put(containerStatus.getContainerId(),\n                 containerStartTime);\n           }\n           publishContainerEndEventOnTimelineServiceV2(containerStatus,\n               containerStartTime);\n         }\n         if (timelineServiceV1Enabled) {\n           publishContainerEndEvent(timelineClient, containerStatus, domainId,\n               appSubmitterUgi);\n         }\n       }\n \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       // Dont bother re-asking if we are using placementSpecs\n       if (placementSpecs \u003d\u003d null) {\n         if (askCount \u003e 0) {\n           for (int i \u003d 0; i \u003c askCount; ++i) {\n             ContainerRequest containerAsk \u003d setupContainerAskForRM();\n             amRMClient.addContainerRequest(containerAsk);\n           }\n         }\n       }\n \n       if (numCompletedContainers.get() + numIgnore.get() \u003e\u003d\n           numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        String message \u003d appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics();\n        if (containerStatus.getExitStatus() !\u003d 0) {\n          LOG.error(message);\n          diagnostics.append(containerStatus.getDiagnostics());\n        } else {\n          LOG.info(message);\n        }\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n        // ignore containers we know nothing about - probably from a previous\n        // attempt\n        if (!launchedContainers.contains(containerStatus.getContainerId())) {\n          LOG.info(\"Ignoring completed status of \"\n              + containerStatus.getContainerId()\n              + \"; unknown container(probably launched by previous attempt)\");\n          continue;\n        }\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n\n            // Ignore these containers if placementspec is enabled\n            // for the time being.\n            if (placementSpecs !\u003d null) {\n              numIgnore.incrementAndGet();\n            }\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        if (timelineServiceV2Enabled) {\n          Long containerStartTime \u003d\n              containerStartTimes.get(containerStatus.getContainerId());\n          if (containerStartTime \u003d\u003d null) {\n            containerStartTime \u003d SystemClock.getInstance().getTime();\n            containerStartTimes.put(containerStatus.getContainerId(),\n                containerStartTime);\n          }\n          publishContainerEndEventOnTimelineServiceV2(containerStatus,\n              containerStartTime);\n        }\n        if (timelineServiceV1Enabled) {\n          publishContainerEndEvent(timelineClient, containerStatus, domainId,\n              appSubmitterUgi);\n        }\n      }\n\n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      // Dont bother re-asking if we are using placementSpecs\n      if (placementSpecs \u003d\u003d null) {\n        if (askCount \u003e 0) {\n          for (int i \u003d 0; i \u003c askCount; ++i) {\n            ContainerRequest containerAsk \u003d setupContainerAskForRM();\n            amRMClient.addContainerRequest(containerAsk);\n          }\n        }\n      }\n\n      if (numCompletedContainers.get() + numIgnore.get() \u003e\u003d\n          numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "e60f51299dba360d13aa39f9ab714fdfc666b532": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7745. Allow DistributedShell to take a placement specification for containers it wants to launch. (Arun Suresh via wangda)\n\nChange-Id: Ided146d662e944a8a4692e5d6885f23fd9bbcad5\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "e60f51299dba360d13aa39f9ab714fdfc666b532",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "24/01/18 3:26 AM",
      "commitNameOld": "97607617ce01ee21af4fb9eb8df26fc6986a38a2",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 6.92,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,87 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n         // ignore containers we know nothing about - probably from a previous\n         // attempt\n         if (!launchedContainers.contains(containerStatus.getContainerId())) {\n           LOG.info(\"Ignoring completed status of \"\n               + containerStatus.getContainerId()\n               + \"; unknown container(probably launched by previous attempt)\");\n           continue;\n         }\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n+\n+            // Ignore these containers if placementspec is enabled\n+            // for the time being.\n+            if (placementSpecs !\u003d null) {\n+              numIgnore.incrementAndGet();\n+            }\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n         if (timelineServiceV2Enabled) {\n           Long containerStartTime \u003d\n               containerStartTimes.get(containerStatus.getContainerId());\n           if (containerStartTime \u003d\u003d null) {\n             containerStartTime \u003d SystemClock.getInstance().getTime();\n             containerStartTimes.put(containerStatus.getContainerId(),\n                 containerStartTime);\n           }\n           publishContainerEndEventOnTimelineServiceV2(containerStatus,\n               containerStartTime);\n         }\n         if (timelineServiceV1Enabled) {\n           publishContainerEndEvent(timelineClient, containerStatus, domainId,\n               appSubmitterUgi);\n         }\n       }\n \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n-      if (askCount \u003e 0) {\n-        for (int i \u003d 0; i \u003c askCount; ++i) {\n-          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n-          amRMClient.addContainerRequest(containerAsk);\n+      // Dont bother re-asking if we are using placementSpecs\n+      if (placementSpecs \u003d\u003d null) {\n+        if (askCount \u003e 0) {\n+          for (int i \u003d 0; i \u003c askCount; ++i) {\n+            ContainerRequest containerAsk \u003d setupContainerAskForRM();\n+            amRMClient.addContainerRequest(containerAsk);\n+          }\n         }\n       }\n-      \n-      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n+\n+      if (numCompletedContainers.get() + numIgnore.get() \u003e\u003d\n+          numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n        // ignore containers we know nothing about - probably from a previous\n        // attempt\n        if (!launchedContainers.contains(containerStatus.getContainerId())) {\n          LOG.info(\"Ignoring completed status of \"\n              + containerStatus.getContainerId()\n              + \"; unknown container(probably launched by previous attempt)\");\n          continue;\n        }\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n\n            // Ignore these containers if placementspec is enabled\n            // for the time being.\n            if (placementSpecs !\u003d null) {\n              numIgnore.incrementAndGet();\n            }\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        if (timelineServiceV2Enabled) {\n          Long containerStartTime \u003d\n              containerStartTimes.get(containerStatus.getContainerId());\n          if (containerStartTime \u003d\u003d null) {\n            containerStartTime \u003d SystemClock.getInstance().getTime();\n            containerStartTimes.put(containerStatus.getContainerId(),\n                containerStartTime);\n          }\n          publishContainerEndEventOnTimelineServiceV2(containerStatus,\n              containerStartTime);\n        }\n        if (timelineServiceV1Enabled) {\n          publishContainerEndEvent(timelineClient, containerStatus, domainId,\n              appSubmitterUgi);\n        }\n      }\n\n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      // Dont bother re-asking if we are using placementSpecs\n      if (placementSpecs \u003d\u003d null) {\n        if (askCount \u003e 0) {\n          for (int i \u003d 0; i \u003c askCount; ++i) {\n            ContainerRequest containerAsk \u003d setupContainerAskForRM();\n            amRMClient.addContainerRequest(containerAsk);\n          }\n        }\n      }\n\n      if (numCompletedContainers.get() + numIgnore.get() \u003e\u003d\n          numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "d09058b2fd18803d12f0835fdf78aef5e0b99c90": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6736. Consider writing to both ats v1 \u0026 v2 from RM for smoother upgrades. Contributed by Aaron Gresch.\n",
      "commitDate": "15/01/18 6:28 PM",
      "commitName": "d09058b2fd18803d12f0835fdf78aef5e0b99c90",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "09/01/18 3:09 AM",
      "commitNameOld": "783a01eb4a155044a54a30a636b86b3ab2b33044",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 6.64,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,77 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n         // ignore containers we know nothing about - probably from a previous\n         // attempt\n         if (!launchedContainers.contains(containerStatus.getContainerId())) {\n           LOG.info(\"Ignoring completed status of \"\n               + containerStatus.getContainerId()\n               + \"; unknown container(probably launched by previous attempt)\");\n           continue;\n         }\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n         if (timelineServiceV2Enabled) {\n           Long containerStartTime \u003d\n               containerStartTimes.get(containerStatus.getContainerId());\n           if (containerStartTime \u003d\u003d null) {\n             containerStartTime \u003d SystemClock.getInstance().getTime();\n             containerStartTimes.put(containerStatus.getContainerId(),\n                 containerStartTime);\n           }\n           publishContainerEndEventOnTimelineServiceV2(containerStatus,\n               containerStartTime);\n-        } else if (timelineServiceV1Enabled) {\n+        }\n+        if (timelineServiceV1Enabled) {\n           publishContainerEndEvent(timelineClient, containerStatus, domainId,\n               appSubmitterUgi);\n         }\n       }\n \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n           amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n        // ignore containers we know nothing about - probably from a previous\n        // attempt\n        if (!launchedContainers.contains(containerStatus.getContainerId())) {\n          LOG.info(\"Ignoring completed status of \"\n              + containerStatus.getContainerId()\n              + \"; unknown container(probably launched by previous attempt)\");\n          continue;\n        }\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        if (timelineServiceV2Enabled) {\n          Long containerStartTime \u003d\n              containerStartTimes.get(containerStatus.getContainerId());\n          if (containerStartTime \u003d\u003d null) {\n            containerStartTime \u003d SystemClock.getInstance().getTime();\n            containerStartTimes.put(containerStatus.getContainerId(),\n                containerStartTime);\n          }\n          publishContainerEndEventOnTimelineServiceV2(containerStatus,\n              containerStartTime);\n        }\n        if (timelineServiceV1Enabled) {\n          publishContainerEndEvent(timelineClient, containerStatus, domainId,\n              appSubmitterUgi);\n        }\n      }\n\n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "092fead5d9875fb3760206bcdd76cdafec5e9481": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5792. Adopt the id prefix for YARN, MR, and DS entities. Contributed by Varun Saxena.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "092fead5d9875fb3760206bcdd76cdafec5e9481",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "26/05/17 12:05 PM",
      "commitNameOld": "d81372dfad32488e7c46ffcfccdf0aa26bee04a5",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 95.45,
      "commitsBetweenForRepo": 557,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,76 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n         // ignore containers we know nothing about - probably from a previous\n         // attempt\n         if (!launchedContainers.contains(containerStatus.getContainerId())) {\n           LOG.info(\"Ignoring completed status of \"\n               + containerStatus.getContainerId()\n               + \"; unknown container(probably launched by previous attempt)\");\n           continue;\n         }\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n         if (timelineServiceV2Enabled) {\n-          publishContainerEndEventOnTimelineServiceV2(containerStatus);\n+          Long containerStartTime \u003d\n+              containerStartTimes.get(containerStatus.getContainerId());\n+          if (containerStartTime \u003d\u003d null) {\n+            containerStartTime \u003d SystemClock.getInstance().getTime();\n+            containerStartTimes.put(containerStatus.getContainerId(),\n+                containerStartTime);\n+          }\n+          publishContainerEndEventOnTimelineServiceV2(containerStatus,\n+              containerStartTime);\n         } else if (timelineServiceV1Enabled) {\n           publishContainerEndEvent(timelineClient, containerStatus, domainId,\n               appSubmitterUgi);\n         }\n       }\n \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n           amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n        // ignore containers we know nothing about - probably from a previous\n        // attempt\n        if (!launchedContainers.contains(containerStatus.getContainerId())) {\n          LOG.info(\"Ignoring completed status of \"\n              + containerStatus.getContainerId()\n              + \"; unknown container(probably launched by previous attempt)\");\n          continue;\n        }\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        if (timelineServiceV2Enabled) {\n          Long containerStartTime \u003d\n              containerStartTimes.get(containerStatus.getContainerId());\n          if (containerStartTime \u003d\u003d null) {\n            containerStartTime \u003d SystemClock.getInstance().getTime();\n            containerStartTimes.put(containerStatus.getContainerId(),\n                containerStartTime);\n          }\n          publishContainerEndEventOnTimelineServiceV2(containerStatus,\n              containerStartTime);\n        } else if (timelineServiceV1Enabled) {\n          publishContainerEndEvent(timelineClient, containerStatus, domainId,\n              appSubmitterUgi);\n        }\n      }\n\n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4675. Reorganize TimelineClient and TimelineClientImpl into separate classes for ATSv1.x and ATSv2. Contributed by Naganarasimha G R.\n",
      "commitDate": "16/02/17 11:41 AM",
      "commitName": "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "06/01/17 2:26 PM",
      "commitNameOld": "71a4acf74bc9ca34f0e57835c9d6e3efbe7c0567",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 40.89,
      "commitsBetweenForRepo": 204,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,68 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n         // ignore containers we know nothing about - probably from a previous\n         // attempt\n         if (!launchedContainers.contains(containerStatus.getContainerId())) {\n           LOG.info(\"Ignoring completed status of \"\n               + containerStatus.getContainerId()\n               + \"; unknown container(probably launched by previous attempt)\");\n           continue;\n         }\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n-        if(timelineClient !\u003d null) {\n-          if (timelineServiceV2) {\n-            publishContainerEndEventOnTimelineServiceV2(containerStatus);\n-          } else {\n-            publishContainerEndEvent(\n-                timelineClient, containerStatus, domainId, appSubmitterUgi);\n-          }\n+        if (timelineServiceV2Enabled) {\n+          publishContainerEndEventOnTimelineServiceV2(containerStatus);\n+        } else if (timelineServiceV1Enabled) {\n+          publishContainerEndEvent(timelineClient, containerStatus, domainId,\n+              appSubmitterUgi);\n         }\n       }\n-      \n+\n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n           amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n        // ignore containers we know nothing about - probably from a previous\n        // attempt\n        if (!launchedContainers.contains(containerStatus.getContainerId())) {\n          LOG.info(\"Ignoring completed status of \"\n              + containerStatus.getContainerId()\n              + \"; unknown container(probably launched by previous attempt)\");\n          continue;\n        }\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        if (timelineServiceV2Enabled) {\n          publishContainerEndEventOnTimelineServiceV2(containerStatus);\n        } else if (timelineServiceV1Enabled) {\n          publishContainerEndEvent(timelineClient, containerStatus, domainId,\n              appSubmitterUgi);\n        }\n      }\n\n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "5712b8f9fd1859fe046b482889239bd164ed7dab",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,70 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n         // ignore containers we know nothing about - probably from a previous\n         // attempt\n         if (!launchedContainers.contains(containerStatus.getContainerId())) {\n           LOG.info(\"Ignoring completed status of \"\n               + containerStatus.getContainerId()\n               + \"; unknown container(probably launched by previous attempt)\");\n           continue;\n         }\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n         if(timelineClient !\u003d null) {\n-          if (newTimelineService) {\n-            publishContainerEndEventOnNewTimelineService(\n-                timelineClient, containerStatus, domainId, appSubmitterUgi);\n+          if (timelineServiceV2) {\n+            publishContainerEndEventOnTimelineServiceV2(containerStatus);\n           } else {\n             publishContainerEndEvent(\n-                timelineClient, containerStatus, domainId, appSubmitterUgi);\n+              timelineClient, containerStatus, domainId, appSubmitterUgi);\n           }\n         }\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n           amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n        // ignore containers we know nothing about - probably from a previous\n        // attempt\n        if (!launchedContainers.contains(containerStatus.getContainerId())) {\n          LOG.info(\"Ignoring completed status of \"\n              + containerStatus.getContainerId()\n              + \"; unknown container(probably launched by previous attempt)\");\n          continue;\n        }\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        if(timelineClient !\u003d null) {\n          if (timelineServiceV2) {\n            publishContainerEndEventOnTimelineServiceV2(containerStatus);\n          } else {\n            publishContainerEndEvent(\n              timelineClient, containerStatus, domainId, appSubmitterUgi);\n          }\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3125. Made the distributed shell use timeline service next gen and add an integration test for it. Contributed by Junping Du and Li Lu.\n\n(cherry picked from commit bf08f7f0ed4900ce52f98137297dd1a47ba2a536)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "09/07/16 5:09 AM",
      "commitNameOld": "9bdb5bebea1183ec2f697ee3e55392df4fe697bb",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 1.15,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,71 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n         // ignore containers we know nothing about - probably from a previous\n         // attempt\n         if (!launchedContainers.contains(containerStatus.getContainerId())) {\n           LOG.info(\"Ignoring completed status of \"\n               + containerStatus.getContainerId()\n               + \"; unknown container(probably launched by previous attempt)\");\n           continue;\n         }\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n         if(timelineClient !\u003d null) {\n-          publishContainerEndEvent(\n-              timelineClient, containerStatus, domainId, appSubmitterUgi);\n+          if (newTimelineService) {\n+            publishContainerEndEventOnNewTimelineService(\n+                timelineClient, containerStatus, domainId, appSubmitterUgi);\n+          } else {\n+            publishContainerEndEvent(\n+                timelineClient, containerStatus, domainId, appSubmitterUgi);\n+          }\n         }\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n           amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n        // ignore containers we know nothing about - probably from a previous\n        // attempt\n        if (!launchedContainers.contains(containerStatus.getContainerId())) {\n          LOG.info(\"Ignoring completed status of \"\n              + containerStatus.getContainerId()\n              + \"; unknown container(probably launched by previous attempt)\");\n          continue;\n        }\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        if(timelineClient !\u003d null) {\n          if (newTimelineService) {\n            publishContainerEndEventOnNewTimelineService(\n                timelineClient, containerStatus, domainId, appSubmitterUgi);\n          } else {\n            publishContainerEndEvent(\n                timelineClient, containerStatus, domainId, appSubmitterUgi);\n          }\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "7438966586f1896ab3e8b067d47a4af28a894106": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2821. Fixed a problem that DistributedShell AM may hang if restarted. Contributed by Varun Vasudev\n",
      "commitDate": "19/05/15 2:20 PM",
      "commitName": "7438966586f1896ab3e8b067d47a4af28a894106",
      "commitAuthor": "Jian He",
      "commitDateOld": "24/04/15 2:08 PM",
      "commitNameOld": "5ce3a77f3c00aeabcd791c3373dd3c8c25160ce2",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 25.01,
      "commitsBetweenForRepo": 293,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,66 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n+        // ignore containers we know nothing about - probably from a previous\n+        // attempt\n+        if (!launchedContainers.contains(containerStatus.getContainerId())) {\n+          LOG.info(\"Ignoring completed status of \"\n+              + containerStatus.getContainerId()\n+              + \"; unknown container(probably launched by previous attempt)\");\n+          continue;\n+        }\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n         if(timelineClient !\u003d null) {\n           publishContainerEndEvent(\n               timelineClient, containerStatus, domainId, appSubmitterUgi);\n         }\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n           amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n        // ignore containers we know nothing about - probably from a previous\n        // attempt\n        if (!launchedContainers.contains(containerStatus.getContainerId())) {\n          LOG.info(\"Ignoring completed status of \"\n              + containerStatus.getContainerId()\n              + \"; unknown container(probably launched by previous attempt)\");\n          continue;\n        }\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        if(timelineClient !\u003d null) {\n          publishContainerEndEvent(\n              timelineClient, containerStatus, domainId, appSubmitterUgi);\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "c298a9a845f89317eb9efad332e6657c56736a4d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2375. Allow enabling/disabling timeline server per framework. (Mit Desai via jeagles)\n",
      "commitDate": "20/11/14 9:34 PM",
      "commitName": "c298a9a845f89317eb9efad332e6657c56736a4d",
      "commitAuthor": "Jonathan Eagles",
      "commitDateOld": "29/10/14 12:12 PM",
      "commitNameOld": "a8c120222047280234c3411ce1c1c9b17f08c851",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 22.43,
      "commitsBetweenForRepo": 218,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,58 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n-        publishContainerEndEvent(\n-            timelineClient, containerStatus, domainId, appSubmitterUgi);\n+        if(timelineClient !\u003d null) {\n+          publishContainerEndEvent(\n+              timelineClient, containerStatus, domainId, appSubmitterUgi);\n+        }\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n           amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        if(timelineClient !\u003d null) {\n          publishContainerEndEvent(\n              timelineClient, containerStatus, domainId, appSubmitterUgi);\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "1d4612f5ad9678c952b416e798dccd20c88f96ef": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2629. Made the distributed shell use the domain-based timeline ACLs. Contributed by Zhijie Shen.\n",
      "commitDate": "09/10/14 12:59 PM",
      "commitName": "1d4612f5ad9678c952b416e798dccd20c88f96ef",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "01/10/14 3:38 PM",
      "commitNameOld": "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 7.89,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,56 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n-        try {\n-          publishContainerEndEvent(timelineClient, containerStatus);\n-        } catch (Exception e) {\n-          LOG.error(\"Container start event could not be published for \"\n-              + containerStatus.getContainerId().toString(), e);\n-        }\n+        publishContainerEndEvent(\n+            timelineClient, containerStatus, domainId, appSubmitterUgi);\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n           amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        publishContainerEndEvent(\n            timelineClient, containerStatus, domainId, appSubmitterUgi);\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "3de66011c2e80d7c458a67f80042af986fcc677d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2450. Fix typos in log messages. Contributed by Ray Chiang.\n",
      "commitDate": "29/08/14 11:16 AM",
      "commitName": "3de66011c2e80d7c458a67f80042af986fcc677d",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "13/08/14 2:07 PM",
      "commitNameOld": "1a535f8dcdfc4fab8ba6125680957caf55ea8f46",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 15.88,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n         try {\n           publishContainerEndEvent(timelineClient, containerStatus);\n         } catch (Exception e) {\n-          LOG.error(\"Container start event could not be pulished for \"\n+          LOG.error(\"Container start event could not be published for \"\n               + containerStatus.getContainerId().toString(), e);\n         }\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n           amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        try {\n          publishContainerEndEvent(timelineClient, containerStatus);\n        } catch (Exception e) {\n          LOG.error(\"Container start event could not be published for \"\n              + containerStatus.getContainerId().toString(), e);\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "7e54b1c6d9dc3a7fb07df36347130d605bd0a718": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2354. DistributedShell may allocate more containers than client specified after AM restarts. Contributed by Li Lu\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1614538 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/14 8:58 PM",
      "commitName": "7e54b1c6d9dc3a7fb07df36347130d605bd0a718",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/07/14 10:49 AM",
      "commitNameOld": "f6c723ff0c09134d721534a409e8d688cc028307",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 7.42,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n-        LOG.info(\"Got container status for containerID\u003d\"\n+        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n         try {\n           publishContainerEndEvent(timelineClient, containerStatus);\n         } catch (Exception e) {\n           LOG.error(\"Container start event could not be pulished for \"\n               + containerStatus.getContainerId().toString(), e);\n         }\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n           amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(appAttemptID + \" got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        try {\n          publishContainerEndEvent(timelineClient, containerStatus);\n        } catch (Exception e) {\n          LOG.error(\"Container start event could not be pulished for \"\n              + containerStatus.getContainerId().toString(), e);\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "fd1c424548999cb8843f40cb6a342387f98bde6c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1690. Made DistributedShell send timeline entities+events. Contributed by Mayank Bansal.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1579123 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/03/14 8:49 PM",
      "commitName": "fd1c424548999cb8843f40cb6a342387f98bde6c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "16/03/14 11:32 AM",
      "commitNameOld": "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.39,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,60 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(\"Got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n+        try {\n+          publishContainerEndEvent(timelineClient, containerStatus);\n+        } catch (Exception e) {\n+          LOG.error(\"Container start event could not be pulished for \"\n+              + containerStatus.getContainerId().toString(), e);\n+        }\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n           amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(\"Got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n        try {\n          publishContainerEndEvent(timelineClient, containerStatus);\n        } catch (Exception e) {\n          LOG.error(\"Container start event could not be pulished for \"\n              + containerStatus.getContainerId().toString(), e);\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "42c3cd3d137ba1de1c0573c0bb655fa380ed9412": {
      "type": "Ybodychange",
      "commitMessage": "YARN-49. Improve distributed shell application to work on a secure cluster. Contributed by Vinod Kumar Vavilapalli.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1526330 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/09/13 4:39 PM",
      "commitName": "42c3cd3d137ba1de1c0573c0bb655fa380ed9412",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "24/07/13 3:13 PM",
      "commitNameOld": "9c453d4432a6ce75afab2087017781e614cc320f",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 63.06,
      "commitsBetweenForRepo": 352,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(\"Got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         for (int i \u003d 0; i \u003c askCount; ++i) {\n           ContainerRequest containerAsk \u003d setupContainerAskForRM();\n-          resourceManager.addContainerRequest(containerAsk);\n+          amRMClient.addContainerRequest(containerAsk);\n         }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(\"Got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          amRMClient.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "3520039979188c4ca6e69654223b3ac794e8bf8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-927. Change ContainerRequest to not have more than 1 container count and remove StoreContainerRequest (bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503960 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/13 5:47 PM",
      "commitName": "3520039979188c4ca6e69654223b3ac794e8bf8f",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "20/06/13 5:08 PM",
      "commitNameOld": "1a06175440eec7994d6b63b0e5ac8b6532870fb3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 26.03,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,54 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(\"Got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n-        ContainerRequest containerAsk \u003d setupContainerAskForRM(askCount);\n-        resourceManager.addContainerRequest(containerAsk);\n+        for (int i \u003d 0; i \u003c askCount; ++i) {\n+          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n+          resourceManager.addContainerRequest(containerAsk);\n+        }\n       }\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(\"Got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        for (int i \u003d 0; i \u003c askCount; ++i) {\n          ContainerRequest containerAsk \u003d setupContainerAskForRM();\n          resourceManager.addContainerRequest(containerAsk);\n        }\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-660. Improve AMRMClient with matching requests (bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488485 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/06/13 1:23 AM",
      "commitName": "3492f5eff1a22aba0d09d72a9dfd3353525c072e",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "30/05/13 9:13 PM",
      "commitNameOld": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,52 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(\"Got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n           if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         ContainerRequest containerAsk \u003d setupContainerAskForRM(askCount);\n         resourceManager.addContainerRequest(containerAsk);\n       }\n       \n-      // set progress to deliver to RM on next heartbeat\n-      float progress \u003d (float) numCompletedContainers.get()\n-          / numTotalContainers;\n-      resourceManager.setProgress(progress);\n-      \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(\"Got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        ContainerRequest containerAsk \u003d setupContainerAskForRM(askCount);\n        resourceManager.addContainerRequest(containerAsk);\n      }\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "0e01f26821caa3bf8554afe422bb080abcfe1e83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-444. Moved special container exit codes from YarnConfiguration to API where they belong. Contributed by Sandy Ryza.\nMAPREDUCE-5151. Updated MR AM to use standard exit codes from the API after YARN-444. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1468276 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/04/13 4:54 PM",
      "commitName": "0e01f26821caa3bf8554afe422bb080abcfe1e83",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/04/13 12:28 PM",
      "commitNameOld": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.18,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n     public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n       LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n           + completedContainers.size());\n       for (ContainerStatus containerStatus : completedContainers) {\n         LOG.info(\"Got container status for containerID\u003d\"\n             + containerStatus.getContainerId() + \", state\u003d\"\n             + containerStatus.getState() + \", exitStatus\u003d\"\n             + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n             + containerStatus.getDiagnostics());\n \n         // non complete containers should not be here\n         assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n \n         // increment counters for completed/failed containers\n         int exitStatus \u003d containerStatus.getExitStatus();\n         if (0 !\u003d exitStatus) {\n           // container failed\n-          if (YarnConfiguration.ABORTED_CONTAINER_EXIT_STATUS !\u003d exitStatus) {\n+          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n             // shell script failed\n             // counts as completed\n             numCompletedContainers.incrementAndGet();\n             numFailedContainers.incrementAndGet();\n           } else {\n             // container was killed by framework, possibly preempted\n             // we should re-try as the container was lost for some reason\n             numAllocatedContainers.decrementAndGet();\n             numRequestedContainers.decrementAndGet();\n             // we do not need to release the container as it would be done\n             // by the RM\n           }\n         } else {\n           // nothing to do\n           // container completed successfully\n           numCompletedContainers.incrementAndGet();\n           LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n               + containerStatus.getContainerId());\n         }\n       }\n       \n       // ask for more containers if any failed\n       int askCount \u003d numTotalContainers - numRequestedContainers.get();\n       numRequestedContainers.addAndGet(askCount);\n \n       if (askCount \u003e 0) {\n         ContainerRequest containerAsk \u003d setupContainerAskForRM(askCount);\n         resourceManager.addContainerRequest(containerAsk);\n       }\n       \n       // set progress to deliver to RM on next heartbeat\n       float progress \u003d (float) numCompletedContainers.get()\n           / numTotalContainers;\n       resourceManager.setProgress(progress);\n       \n       if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n         done \u003d true;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(\"Got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (ContainerExitStatus.ABORTED !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        ContainerRequest containerAsk \u003d setupContainerAskForRM(askCount);\n        resourceManager.addContainerRequest(containerAsk);\n      }\n      \n      // set progress to deliver to RM on next heartbeat\n      float progress \u003d (float) numCompletedContainers.get()\n          / numTotalContainers;\n      resourceManager.setProgress(progress);\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "28bac402953a4337deedf0472611f5775c7a74c9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-417. Create AMRMClient wrapper that provides asynchronous callbacks. (Sandy Ryza via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459555 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/13 3:26 PM",
      "commitName": "28bac402953a4337deedf0472611f5775c7a74c9",
      "commitAuthor": "Bikas Saha",
      "diff": "@@ -0,0 +1,57 @@\n+    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n+      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n+          + completedContainers.size());\n+      for (ContainerStatus containerStatus : completedContainers) {\n+        LOG.info(\"Got container status for containerID\u003d\"\n+            + containerStatus.getContainerId() + \", state\u003d\"\n+            + containerStatus.getState() + \", exitStatus\u003d\"\n+            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n+            + containerStatus.getDiagnostics());\n+\n+        // non complete containers should not be here\n+        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n+\n+        // increment counters for completed/failed containers\n+        int exitStatus \u003d containerStatus.getExitStatus();\n+        if (0 !\u003d exitStatus) {\n+          // container failed\n+          if (YarnConfiguration.ABORTED_CONTAINER_EXIT_STATUS !\u003d exitStatus) {\n+            // shell script failed\n+            // counts as completed\n+            numCompletedContainers.incrementAndGet();\n+            numFailedContainers.incrementAndGet();\n+          } else {\n+            // container was killed by framework, possibly preempted\n+            // we should re-try as the container was lost for some reason\n+            numAllocatedContainers.decrementAndGet();\n+            numRequestedContainers.decrementAndGet();\n+            // we do not need to release the container as it would be done\n+            // by the RM\n+          }\n+        } else {\n+          // nothing to do\n+          // container completed successfully\n+          numCompletedContainers.incrementAndGet();\n+          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n+              + containerStatus.getContainerId());\n+        }\n+      }\n+      \n+      // ask for more containers if any failed\n+      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n+      numRequestedContainers.addAndGet(askCount);\n+\n+      if (askCount \u003e 0) {\n+        ContainerRequest containerAsk \u003d setupContainerAskForRM(askCount);\n+        resourceManager.addContainerRequest(containerAsk);\n+      }\n+      \n+      // set progress to deliver to RM on next heartbeat\n+      float progress \u003d (float) numCompletedContainers.get()\n+          / numTotalContainers;\n+      resourceManager.setProgress(progress);\n+      \n+      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n+        done \u003d true;\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void onContainersCompleted(List\u003cContainerStatus\u003e completedContainers) {\n      LOG.info(\"Got response from RM for container ask, completedCnt\u003d\"\n          + completedContainers.size());\n      for (ContainerStatus containerStatus : completedContainers) {\n        LOG.info(\"Got container status for containerID\u003d\"\n            + containerStatus.getContainerId() + \", state\u003d\"\n            + containerStatus.getState() + \", exitStatus\u003d\"\n            + containerStatus.getExitStatus() + \", diagnostics\u003d\"\n            + containerStatus.getDiagnostics());\n\n        // non complete containers should not be here\n        assert (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE);\n\n        // increment counters for completed/failed containers\n        int exitStatus \u003d containerStatus.getExitStatus();\n        if (0 !\u003d exitStatus) {\n          // container failed\n          if (YarnConfiguration.ABORTED_CONTAINER_EXIT_STATUS !\u003d exitStatus) {\n            // shell script failed\n            // counts as completed\n            numCompletedContainers.incrementAndGet();\n            numFailedContainers.incrementAndGet();\n          } else {\n            // container was killed by framework, possibly preempted\n            // we should re-try as the container was lost for some reason\n            numAllocatedContainers.decrementAndGet();\n            numRequestedContainers.decrementAndGet();\n            // we do not need to release the container as it would be done\n            // by the RM\n          }\n        } else {\n          // nothing to do\n          // container completed successfully\n          numCompletedContainers.incrementAndGet();\n          LOG.info(\"Container completed successfully.\" + \", containerId\u003d\"\n              + containerStatus.getContainerId());\n        }\n      }\n      \n      // ask for more containers if any failed\n      int askCount \u003d numTotalContainers - numRequestedContainers.get();\n      numRequestedContainers.addAndGet(askCount);\n\n      if (askCount \u003e 0) {\n        ContainerRequest containerAsk \u003d setupContainerAskForRM(askCount);\n        resourceManager.addContainerRequest(containerAsk);\n      }\n      \n      // set progress to deliver to RM on next heartbeat\n      float progress \u003d (float) numCompletedContainers.get()\n          / numTotalContainers;\n      resourceManager.setProgress(progress);\n      \n      if (numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n        done \u003d true;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java"
    }
  }
}