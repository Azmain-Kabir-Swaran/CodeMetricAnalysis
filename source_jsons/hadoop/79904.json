{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Trash.java",
  "functionName": "moveToTrash",
  "functionId": "moveToTrash___path-Path",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Trash.java",
  "functionStartLine": 109,
  "functionEndLine": 111,
  "numCommitsSeen": 24,
  "timeTaken": 1012,
  "changeHistory": [
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "184ff33de5598b04bf968ea3b113b175a4225b82",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "3db6c4a94448163af5a1af50bc5e97aef28878c0",
    "e79d8afcd05722fe369eba919abe4f4205771a41",
    "1596a106e4db28b7372b97a55e6cd7ea844f3df6",
    "e3b587e56f46a269fc9a7b3115b9ade35945e7cd",
    "175a92850d8207ae5231632f915767033b035c5f",
    "382af3f62737491afb380b2402ce2f58256c5974",
    "d09ade4d0b64c1f0f629fe9361d511ed905732c6",
    "09d826ebed0394d80dd24432a3bbf894efe46265",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "184ff33de5598b04bf968ea3b113b175a4225b82": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "3db6c4a94448163af5a1af50bc5e97aef28878c0": "Ybodychange",
    "e79d8afcd05722fe369eba919abe4f4205771a41": "Ybodychange",
    "1596a106e4db28b7372b97a55e6cd7ea844f3df6": "Ybodychange",
    "e3b587e56f46a269fc9a7b3115b9ade35945e7cd": "Ybodychange",
    "175a92850d8207ae5231632f915767033b035c5f": "Ybodychange",
    "382af3f62737491afb380b2402ce2f58256c5974": "Ybodychange",
    "d09ade4d0b64c1f0f629fe9361d511ed905732c6": "Ybodychange",
    "09d826ebed0394d80dd24432a3bbf894efe46265": "Ybodychange",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    return trashPolicy.moveToTrash(path);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/fs/Trash.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Trash.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    return trashPolicy.moveToTrash(path);\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/fs/Trash.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/fs/Trash.java"
      }
    },
    "184ff33de5598b04bf968ea3b113b175a4225b82": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7460. Support pluggable trash policies. Contributed by Usman Masoon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1149760 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/11 4:23 PM",
      "commitName": "184ff33de5598b04bf968ea3b113b175a4225b82",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "23/06/11 4:55 PM",
      "commitNameOld": "1191be630ff05c9f1a540b952a8e34665f7fc181",
      "commitAuthorOld": "Tanping Wang",
      "daysBetweenCommits": 28.98,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,3 @@\n   public boolean moveToTrash(Path path) throws IOException {\n-    if (!isEnabled())\n-      return false;\n-\n-    if (!path.isAbsolute())                       // make path absolute\n-      path \u003d new Path(fs.getWorkingDirectory(), path);\n-\n-    if (!fs.exists(path))                         // check that path exists\n-      throw new FileNotFoundException(path.toString());\n-\n-    String qpath \u003d fs.makeQualified(path).toString();\n-\n-    if (qpath.startsWith(trash.toString())) {\n-      return false;                               // already in trash\n-    }\n-\n-    if (trash.getParent().toString().startsWith(qpath)) {\n-      throw new IOException(\"Cannot move \\\"\" + path +\n-                            \"\\\" to the trash, as it contains the trash\");\n-    }\n-\n-    Path trashPath \u003d makeTrashRelativePath(current, path);\n-    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n-    \n-    IOException cause \u003d null;\n-\n-    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n-    for (int i \u003d 0; i \u003c 2; i++) {\n-      try {\n-        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n-          LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n-          return false;\n-        }\n-      } catch (IOException e) {\n-        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n-        cause \u003d e;\n-        break;\n-      }\n-      try {\n-        //\n-        // if the target path in Trash already exists, then append with \n-        // a current time in millisecs.\n-        //\n-        String orig \u003d trashPath.toString();\n-        \n-        while(fs.exists(trashPath)) {\n-          trashPath \u003d new Path(orig + System.currentTimeMillis());\n-        }\n-        \n-        if (fs.rename(path, trashPath))           // move to current trash\n-          return true;\n-      } catch (IOException e) {\n-        cause \u003d e;\n-      }\n-    }\n-    throw (IOException)\n-      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n+    return trashPolicy.moveToTrash(path);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    return trashPolicy.moveToTrash(path);\n  }",
      "path": "common/src/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    if (!isEnabled())\n      return false;\n\n    if (!path.isAbsolute())                       // make path absolute\n      path \u003d new Path(fs.getWorkingDirectory(), path);\n\n    if (!fs.exists(path))                         // check that path exists\n      throw new FileNotFoundException(path.toString());\n\n    String qpath \u003d fs.makeQualified(path).toString();\n\n    if (qpath.startsWith(trash.toString())) {\n      return false;                               // already in trash\n    }\n\n    if (trash.getParent().toString().startsWith(qpath)) {\n      throw new IOException(\"Cannot move \\\"\" + path +\n                            \"\\\" to the trash, as it contains the trash\");\n    }\n\n    Path trashPath \u003d makeTrashRelativePath(current, path);\n    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n    \n    IOException cause \u003d null;\n\n    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n    for (int i \u003d 0; i \u003c 2; i++) {\n      try {\n        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n          LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n          return false;\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n        cause \u003d e;\n        break;\n      }\n      try {\n        //\n        // if the target path in Trash already exists, then append with \n        // a current time in millisecs.\n        //\n        String orig \u003d trashPath.toString();\n        \n        while(fs.exists(trashPath)) {\n          trashPath \u003d new Path(orig + System.currentTimeMillis());\n        }\n        \n        if (fs.rename(path, trashPath))           // move to current trash\n          return true;\n      } catch (IOException e) {\n        cause \u003d e;\n      }\n    }\n    throw (IOException)\n      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n  }",
      "path": "common/src/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/fs/Trash.java",
        "newPath": "common/src/java/org/apache/hadoop/fs/Trash.java"
      }
    },
    "3db6c4a94448163af5a1af50bc5e97aef28878c0": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-7284 Trash and shell\u0027s rm does not work for viewfs\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1129989 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/05/11 8:27 PM",
      "commitName": "3db6c4a94448163af5a1af50bc5e97aef28878c0",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "25/05/11 1:45 PM",
      "commitNameOld": "e79d8afcd05722fe369eba919abe4f4205771a41",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 6.28,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   public boolean moveToTrash(Path path) throws IOException {\n     if (!isEnabled())\n       return false;\n \n     if (!path.isAbsolute())                       // make path absolute\n       path \u003d new Path(fs.getWorkingDirectory(), path);\n \n     if (!fs.exists(path))                         // check that path exists\n       throw new FileNotFoundException(path.toString());\n \n-    String qpath \u003d path.makeQualified(fs).toString();\n+    String qpath \u003d fs.makeQualified(path).toString();\n \n     if (qpath.startsWith(trash.toString())) {\n       return false;                               // already in trash\n     }\n \n     if (trash.getParent().toString().startsWith(qpath)) {\n       throw new IOException(\"Cannot move \\\"\" + path +\n                             \"\\\" to the trash, as it contains the trash\");\n     }\n \n     Path trashPath \u003d makeTrashRelativePath(current, path);\n     Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n     \n     IOException cause \u003d null;\n \n     // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n     for (int i \u003d 0; i \u003c 2; i++) {\n       try {\n         if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n           LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n           return false;\n         }\n       } catch (IOException e) {\n         LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n         cause \u003d e;\n         break;\n       }\n       try {\n         //\n         // if the target path in Trash already exists, then append with \n         // a current time in millisecs.\n         //\n         String orig \u003d trashPath.toString();\n         \n         while(fs.exists(trashPath)) {\n           trashPath \u003d new Path(orig + System.currentTimeMillis());\n         }\n         \n         if (fs.rename(path, trashPath))           // move to current trash\n           return true;\n       } catch (IOException e) {\n         cause \u003d e;\n       }\n     }\n     throw (IOException)\n       new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    if (!isEnabled())\n      return false;\n\n    if (!path.isAbsolute())                       // make path absolute\n      path \u003d new Path(fs.getWorkingDirectory(), path);\n\n    if (!fs.exists(path))                         // check that path exists\n      throw new FileNotFoundException(path.toString());\n\n    String qpath \u003d fs.makeQualified(path).toString();\n\n    if (qpath.startsWith(trash.toString())) {\n      return false;                               // already in trash\n    }\n\n    if (trash.getParent().toString().startsWith(qpath)) {\n      throw new IOException(\"Cannot move \\\"\" + path +\n                            \"\\\" to the trash, as it contains the trash\");\n    }\n\n    Path trashPath \u003d makeTrashRelativePath(current, path);\n    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n    \n    IOException cause \u003d null;\n\n    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n    for (int i \u003d 0; i \u003c 2; i++) {\n      try {\n        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n          LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n          return false;\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n        cause \u003d e;\n        break;\n      }\n      try {\n        //\n        // if the target path in Trash already exists, then append with \n        // a current time in millisecs.\n        //\n        String orig \u003d trashPath.toString();\n        \n        while(fs.exists(trashPath)) {\n          trashPath \u003d new Path(orig + System.currentTimeMillis());\n        }\n        \n        if (fs.rename(path, trashPath))           // move to current trash\n          return true;\n      } catch (IOException e) {\n        cause \u003d e;\n      }\n    }\n    throw (IOException)\n      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n  }",
      "path": "src/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {}
    },
    "e79d8afcd05722fe369eba919abe4f4205771a41": {
      "type": "Ybodychange",
      "commitMessage": "Revert HADOOP-7284 (r1127642) since it broke the HDFS build.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1127679 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/05/11 1:45 PM",
      "commitName": "e79d8afcd05722fe369eba919abe4f4205771a41",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "25/05/11 12:23 PM",
      "commitNameOld": "1596a106e4db28b7372b97a55e6cd7ea844f3df6",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   public boolean moveToTrash(Path path) throws IOException {\n     if (!isEnabled())\n       return false;\n \n     if (!path.isAbsolute())                       // make path absolute\n       path \u003d new Path(fs.getWorkingDirectory(), path);\n \n     if (!fs.exists(path))                         // check that path exists\n       throw new FileNotFoundException(path.toString());\n \n-    String qpath \u003d fs.makeQualified(path).toString();\n+    String qpath \u003d path.makeQualified(fs).toString();\n \n     if (qpath.startsWith(trash.toString())) {\n       return false;                               // already in trash\n     }\n \n     if (trash.getParent().toString().startsWith(qpath)) {\n       throw new IOException(\"Cannot move \\\"\" + path +\n                             \"\\\" to the trash, as it contains the trash\");\n     }\n \n     Path trashPath \u003d makeTrashRelativePath(current, path);\n     Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n     \n     IOException cause \u003d null;\n \n     // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n     for (int i \u003d 0; i \u003c 2; i++) {\n       try {\n         if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n           LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n           return false;\n         }\n       } catch (IOException e) {\n         LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n         cause \u003d e;\n         break;\n       }\n       try {\n         //\n         // if the target path in Trash already exists, then append with \n         // a current time in millisecs.\n         //\n         String orig \u003d trashPath.toString();\n         \n         while(fs.exists(trashPath)) {\n           trashPath \u003d new Path(orig + System.currentTimeMillis());\n         }\n         \n         if (fs.rename(path, trashPath))           // move to current trash\n           return true;\n       } catch (IOException e) {\n         cause \u003d e;\n       }\n     }\n     throw (IOException)\n       new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    if (!isEnabled())\n      return false;\n\n    if (!path.isAbsolute())                       // make path absolute\n      path \u003d new Path(fs.getWorkingDirectory(), path);\n\n    if (!fs.exists(path))                         // check that path exists\n      throw new FileNotFoundException(path.toString());\n\n    String qpath \u003d path.makeQualified(fs).toString();\n\n    if (qpath.startsWith(trash.toString())) {\n      return false;                               // already in trash\n    }\n\n    if (trash.getParent().toString().startsWith(qpath)) {\n      throw new IOException(\"Cannot move \\\"\" + path +\n                            \"\\\" to the trash, as it contains the trash\");\n    }\n\n    Path trashPath \u003d makeTrashRelativePath(current, path);\n    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n    \n    IOException cause \u003d null;\n\n    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n    for (int i \u003d 0; i \u003c 2; i++) {\n      try {\n        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n          LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n          return false;\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n        cause \u003d e;\n        break;\n      }\n      try {\n        //\n        // if the target path in Trash already exists, then append with \n        // a current time in millisecs.\n        //\n        String orig \u003d trashPath.toString();\n        \n        while(fs.exists(trashPath)) {\n          trashPath \u003d new Path(orig + System.currentTimeMillis());\n        }\n        \n        if (fs.rename(path, trashPath))           // move to current trash\n          return true;\n      } catch (IOException e) {\n        cause \u003d e;\n      }\n    }\n    throw (IOException)\n      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n  }",
      "path": "src/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {}
    },
    "1596a106e4db28b7372b97a55e6cd7ea844f3df6": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-7284 Trash and shell\u0027s rm does not work for viewfs (Sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1127642 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/05/11 12:23 PM",
      "commitName": "1596a106e4db28b7372b97a55e6cd7ea844f3df6",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "14/03/11 3:42 PM",
      "commitNameOld": "e3b587e56f46a269fc9a7b3115b9ade35945e7cd",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 71.86,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   public boolean moveToTrash(Path path) throws IOException {\n     if (!isEnabled())\n       return false;\n \n     if (!path.isAbsolute())                       // make path absolute\n       path \u003d new Path(fs.getWorkingDirectory(), path);\n \n     if (!fs.exists(path))                         // check that path exists\n       throw new FileNotFoundException(path.toString());\n \n-    String qpath \u003d path.makeQualified(fs).toString();\n+    String qpath \u003d fs.makeQualified(path).toString();\n \n     if (qpath.startsWith(trash.toString())) {\n       return false;                               // already in trash\n     }\n \n     if (trash.getParent().toString().startsWith(qpath)) {\n       throw new IOException(\"Cannot move \\\"\" + path +\n                             \"\\\" to the trash, as it contains the trash\");\n     }\n \n     Path trashPath \u003d makeTrashRelativePath(current, path);\n     Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n     \n     IOException cause \u003d null;\n \n     // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n     for (int i \u003d 0; i \u003c 2; i++) {\n       try {\n         if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n           LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n           return false;\n         }\n       } catch (IOException e) {\n         LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n         cause \u003d e;\n         break;\n       }\n       try {\n         //\n         // if the target path in Trash already exists, then append with \n         // a current time in millisecs.\n         //\n         String orig \u003d trashPath.toString();\n         \n         while(fs.exists(trashPath)) {\n           trashPath \u003d new Path(orig + System.currentTimeMillis());\n         }\n         \n         if (fs.rename(path, trashPath))           // move to current trash\n           return true;\n       } catch (IOException e) {\n         cause \u003d e;\n       }\n     }\n     throw (IOException)\n       new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    if (!isEnabled())\n      return false;\n\n    if (!path.isAbsolute())                       // make path absolute\n      path \u003d new Path(fs.getWorkingDirectory(), path);\n\n    if (!fs.exists(path))                         // check that path exists\n      throw new FileNotFoundException(path.toString());\n\n    String qpath \u003d fs.makeQualified(path).toString();\n\n    if (qpath.startsWith(trash.toString())) {\n      return false;                               // already in trash\n    }\n\n    if (trash.getParent().toString().startsWith(qpath)) {\n      throw new IOException(\"Cannot move \\\"\" + path +\n                            \"\\\" to the trash, as it contains the trash\");\n    }\n\n    Path trashPath \u003d makeTrashRelativePath(current, path);\n    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n    \n    IOException cause \u003d null;\n\n    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n    for (int i \u003d 0; i \u003c 2; i++) {\n      try {\n        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n          LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n          return false;\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n        cause \u003d e;\n        break;\n      }\n      try {\n        //\n        // if the target path in Trash already exists, then append with \n        // a current time in millisecs.\n        //\n        String orig \u003d trashPath.toString();\n        \n        while(fs.exists(trashPath)) {\n          trashPath \u003d new Path(orig + System.currentTimeMillis());\n        }\n        \n        if (fs.rename(path, trashPath))           // move to current trash\n          return true;\n      } catch (IOException e) {\n        cause \u003d e;\n      }\n    }\n    throw (IOException)\n      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n  }",
      "path": "src/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {}
    },
    "e3b587e56f46a269fc9a7b3115b9ade35945e7cd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7175. Add isEnabled() to Trash.  Contributed by Daryn Sharp\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1081598 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/03/11 3:42 PM",
      "commitName": "e3b587e56f46a269fc9a7b3115b9ade35945e7cd",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "11/06/10 2:34 PM",
      "commitNameOld": "6378822a67c0baa502d22201f5c2b478cbe1261c",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 276.05,
      "commitsBetweenForRepo": 220,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   public boolean moveToTrash(Path path) throws IOException {\n-    if (deletionInterval \u003d\u003d 0)\n+    if (!isEnabled())\n       return false;\n \n     if (!path.isAbsolute())                       // make path absolute\n       path \u003d new Path(fs.getWorkingDirectory(), path);\n \n     if (!fs.exists(path))                         // check that path exists\n       throw new FileNotFoundException(path.toString());\n \n     String qpath \u003d path.makeQualified(fs).toString();\n \n     if (qpath.startsWith(trash.toString())) {\n       return false;                               // already in trash\n     }\n \n     if (trash.getParent().toString().startsWith(qpath)) {\n       throw new IOException(\"Cannot move \\\"\" + path +\n                             \"\\\" to the trash, as it contains the trash\");\n     }\n \n     Path trashPath \u003d makeTrashRelativePath(current, path);\n     Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n     \n     IOException cause \u003d null;\n \n     // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n     for (int i \u003d 0; i \u003c 2; i++) {\n       try {\n         if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n           LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n           return false;\n         }\n       } catch (IOException e) {\n         LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n         cause \u003d e;\n         break;\n       }\n       try {\n         //\n         // if the target path in Trash already exists, then append with \n         // a current time in millisecs.\n         //\n         String orig \u003d trashPath.toString();\n         \n         while(fs.exists(trashPath)) {\n           trashPath \u003d new Path(orig + System.currentTimeMillis());\n         }\n         \n         if (fs.rename(path, trashPath))           // move to current trash\n           return true;\n       } catch (IOException e) {\n         cause \u003d e;\n       }\n     }\n     throw (IOException)\n       new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    if (!isEnabled())\n      return false;\n\n    if (!path.isAbsolute())                       // make path absolute\n      path \u003d new Path(fs.getWorkingDirectory(), path);\n\n    if (!fs.exists(path))                         // check that path exists\n      throw new FileNotFoundException(path.toString());\n\n    String qpath \u003d path.makeQualified(fs).toString();\n\n    if (qpath.startsWith(trash.toString())) {\n      return false;                               // already in trash\n    }\n\n    if (trash.getParent().toString().startsWith(qpath)) {\n      throw new IOException(\"Cannot move \\\"\" + path +\n                            \"\\\" to the trash, as it contains the trash\");\n    }\n\n    Path trashPath \u003d makeTrashRelativePath(current, path);\n    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n    \n    IOException cause \u003d null;\n\n    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n    for (int i \u003d 0; i \u003c 2; i++) {\n      try {\n        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n          LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n          return false;\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n        cause \u003d e;\n        break;\n      }\n      try {\n        //\n        // if the target path in Trash already exists, then append with \n        // a current time in millisecs.\n        //\n        String orig \u003d trashPath.toString();\n        \n        while(fs.exists(trashPath)) {\n          trashPath \u003d new Path(orig + System.currentTimeMillis());\n        }\n        \n        if (fs.rename(path, trashPath))           // move to current trash\n          return true;\n      } catch (IOException e) {\n        cause \u003d e;\n      }\n    }\n    throw (IOException)\n      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n  }",
      "path": "src/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {}
    },
    "175a92850d8207ae5231632f915767033b035c5f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6761. The Trash Emptier has the ability to run more frequently.\n(Dmytro Molkov via dhruba)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@945439 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/05/10 4:51 PM",
      "commitName": "175a92850d8207ae5231632f915767033b035c5f",
      "commitAuthor": "Dhruba Borthakur",
      "commitDateOld": "30/10/09 3:39 PM",
      "commitNameOld": "382af3f62737491afb380b2402ce2f58256c5974",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 199.05,
      "commitsBetweenForRepo": 179,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   public boolean moveToTrash(Path path) throws IOException {\n-    if (interval \u003d\u003d 0)\n+    if (deletionInterval \u003d\u003d 0)\n       return false;\n \n     if (!path.isAbsolute())                       // make path absolute\n       path \u003d new Path(fs.getWorkingDirectory(), path);\n \n     if (!fs.exists(path))                         // check that path exists\n       throw new FileNotFoundException(path.toString());\n \n     String qpath \u003d path.makeQualified(fs).toString();\n \n     if (qpath.startsWith(trash.toString())) {\n       return false;                               // already in trash\n     }\n \n     if (trash.getParent().toString().startsWith(qpath)) {\n       throw new IOException(\"Cannot move \\\"\" + path +\n                             \"\\\" to the trash, as it contains the trash\");\n     }\n \n     Path trashPath \u003d makeTrashRelativePath(current, path);\n     Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n     \n     IOException cause \u003d null;\n \n     // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n     for (int i \u003d 0; i \u003c 2; i++) {\n       try {\n         if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n           LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n           return false;\n         }\n       } catch (IOException e) {\n         LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n         cause \u003d e;\n         break;\n       }\n       try {\n         //\n         // if the target path in Trash already exists, then append with \n         // a current time in millisecs.\n         //\n         String orig \u003d trashPath.toString();\n         \n         while(fs.exists(trashPath)) {\n           trashPath \u003d new Path(orig + System.currentTimeMillis());\n         }\n         \n         if (fs.rename(path, trashPath))           // move to current trash\n           return true;\n       } catch (IOException e) {\n         cause \u003d e;\n       }\n     }\n     throw (IOException)\n       new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    if (deletionInterval \u003d\u003d 0)\n      return false;\n\n    if (!path.isAbsolute())                       // make path absolute\n      path \u003d new Path(fs.getWorkingDirectory(), path);\n\n    if (!fs.exists(path))                         // check that path exists\n      throw new FileNotFoundException(path.toString());\n\n    String qpath \u003d path.makeQualified(fs).toString();\n\n    if (qpath.startsWith(trash.toString())) {\n      return false;                               // already in trash\n    }\n\n    if (trash.getParent().toString().startsWith(qpath)) {\n      throw new IOException(\"Cannot move \\\"\" + path +\n                            \"\\\" to the trash, as it contains the trash\");\n    }\n\n    Path trashPath \u003d makeTrashRelativePath(current, path);\n    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n    \n    IOException cause \u003d null;\n\n    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n    for (int i \u003d 0; i \u003c 2; i++) {\n      try {\n        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n          LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n          return false;\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n        cause \u003d e;\n        break;\n      }\n      try {\n        //\n        // if the target path in Trash already exists, then append with \n        // a current time in millisecs.\n        //\n        String orig \u003d trashPath.toString();\n        \n        while(fs.exists(trashPath)) {\n          trashPath \u003d new Path(orig + System.currentTimeMillis());\n        }\n        \n        if (fs.rename(path, trashPath))           // move to current trash\n          return true;\n      } catch (IOException e) {\n        cause \u003d e;\n      }\n    }\n    throw (IOException)\n      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n  }",
      "path": "src/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {}
    },
    "382af3f62737491afb380b2402ce2f58256c5974": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6344. Fix rm and rmr immediately delete files rather than sending to trash, if a user is over-quota. Contributed by Jakob Homan.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@831478 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/10/09 3:39 PM",
      "commitName": "382af3f62737491afb380b2402ce2f58256c5974",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "07/09/09 6:41 PM",
      "commitNameOld": "d09ade4d0b64c1f0f629fe9361d511ed905732c6",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 52.87,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,58 @@\n   public boolean moveToTrash(Path path) throws IOException {\n     if (interval \u003d\u003d 0)\n       return false;\n \n     if (!path.isAbsolute())                       // make path absolute\n       path \u003d new Path(fs.getWorkingDirectory(), path);\n \n     if (!fs.exists(path))                         // check that path exists\n       throw new FileNotFoundException(path.toString());\n \n     String qpath \u003d path.makeQualified(fs).toString();\n \n     if (qpath.startsWith(trash.toString())) {\n       return false;                               // already in trash\n     }\n \n     if (trash.getParent().toString().startsWith(qpath)) {\n       throw new IOException(\"Cannot move \\\"\" + path +\n                             \"\\\" to the trash, as it contains the trash\");\n     }\n \n     Path trashPath \u003d makeTrashRelativePath(current, path);\n     Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n     \n     IOException cause \u003d null;\n \n     // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n     for (int i \u003d 0; i \u003c 2; i++) {\n       try {\n         if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n           LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n           return false;\n         }\n       } catch (IOException e) {\n         LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n-        return false;\n+        cause \u003d e;\n+        break;\n       }\n       try {\n         //\n         // if the target path in Trash already exists, then append with \n         // a current time in millisecs.\n         //\n         String orig \u003d trashPath.toString();\n         \n         while(fs.exists(trashPath)) {\n           trashPath \u003d new Path(orig + System.currentTimeMillis());\n         }\n         \n         if (fs.rename(path, trashPath))           // move to current trash\n           return true;\n       } catch (IOException e) {\n         cause \u003d e;\n       }\n     }\n     throw (IOException)\n       new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    if (interval \u003d\u003d 0)\n      return false;\n\n    if (!path.isAbsolute())                       // make path absolute\n      path \u003d new Path(fs.getWorkingDirectory(), path);\n\n    if (!fs.exists(path))                         // check that path exists\n      throw new FileNotFoundException(path.toString());\n\n    String qpath \u003d path.makeQualified(fs).toString();\n\n    if (qpath.startsWith(trash.toString())) {\n      return false;                               // already in trash\n    }\n\n    if (trash.getParent().toString().startsWith(qpath)) {\n      throw new IOException(\"Cannot move \\\"\" + path +\n                            \"\\\" to the trash, as it contains the trash\");\n    }\n\n    Path trashPath \u003d makeTrashRelativePath(current, path);\n    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n    \n    IOException cause \u003d null;\n\n    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n    for (int i \u003d 0; i \u003c 2; i++) {\n      try {\n        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n          LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n          return false;\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n        cause \u003d e;\n        break;\n      }\n      try {\n        //\n        // if the target path in Trash already exists, then append with \n        // a current time in millisecs.\n        //\n        String orig \u003d trashPath.toString();\n        \n        while(fs.exists(trashPath)) {\n          trashPath \u003d new Path(orig + System.currentTimeMillis());\n        }\n        \n        if (fs.rename(path, trashPath))           // move to current trash\n          return true;\n      } catch (IOException e) {\n        cause \u003d e;\n      }\n    }\n    throw (IOException)\n      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n  }",
      "path": "src/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {}
    },
    "d09ade4d0b64c1f0f629fe9361d511ed905732c6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6203. FsShell rm/rmr error message indicates exceeding Trash quota and suggests using -skpTrash, when moving to trash fails. Contributed by Boris Shkolnik.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@812317 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/09/09 6:41 PM",
      "commitName": "d09ade4d0b64c1f0f629fe9361d511ed905732c6",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "21/08/09 3:50 PM",
      "commitNameOld": "76a77aea78301c6b632d06d20520abc8a21d4cb0",
      "commitAuthorOld": "Christopher Douglas",
      "daysBetweenCommits": 17.12,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n   public boolean moveToTrash(Path path) throws IOException {\n     if (interval \u003d\u003d 0)\n       return false;\n \n     if (!path.isAbsolute())                       // make path absolute\n       path \u003d new Path(fs.getWorkingDirectory(), path);\n \n     if (!fs.exists(path))                         // check that path exists\n       throw new FileNotFoundException(path.toString());\n \n     String qpath \u003d path.makeQualified(fs).toString();\n \n     if (qpath.startsWith(trash.toString())) {\n       return false;                               // already in trash\n     }\n \n     if (trash.getParent().toString().startsWith(qpath)) {\n       throw new IOException(\"Cannot move \\\"\" + path +\n                             \"\\\" to the trash, as it contains the trash\");\n     }\n \n     Path trashPath \u003d makeTrashRelativePath(current, path);\n     Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n     \n     IOException cause \u003d null;\n \n     // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n     for (int i \u003d 0; i \u003c 2; i++) {\n       try {\n         if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n-          LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n+          LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n           return false;\n         }\n       } catch (IOException e) {\n         LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n         return false;\n       }\n       try {\n         //\n         // if the target path in Trash already exists, then append with \n         // a current time in millisecs.\n         //\n         String orig \u003d trashPath.toString();\n         \n         while(fs.exists(trashPath)) {\n           trashPath \u003d new Path(orig + System.currentTimeMillis());\n         }\n         \n         if (fs.rename(path, trashPath))           // move to current trash\n           return true;\n       } catch (IOException e) {\n         cause \u003d e;\n       }\n     }\n     throw (IOException)\n       new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    if (interval \u003d\u003d 0)\n      return false;\n\n    if (!path.isAbsolute())                       // make path absolute\n      path \u003d new Path(fs.getWorkingDirectory(), path);\n\n    if (!fs.exists(path))                         // check that path exists\n      throw new FileNotFoundException(path.toString());\n\n    String qpath \u003d path.makeQualified(fs).toString();\n\n    if (qpath.startsWith(trash.toString())) {\n      return false;                               // already in trash\n    }\n\n    if (trash.getParent().toString().startsWith(qpath)) {\n      throw new IOException(\"Cannot move \\\"\" + path +\n                            \"\\\" to the trash, as it contains the trash\");\n    }\n\n    Path trashPath \u003d makeTrashRelativePath(current, path);\n    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n    \n    IOException cause \u003d null;\n\n    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n    for (int i \u003d 0; i \u003c 2; i++) {\n      try {\n        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n          LOG.warn(\"Can\u0027t create(mkdir) trash directory: \"+baseTrashPath);\n          return false;\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n        return false;\n      }\n      try {\n        //\n        // if the target path in Trash already exists, then append with \n        // a current time in millisecs.\n        //\n        String orig \u003d trashPath.toString();\n        \n        while(fs.exists(trashPath)) {\n          trashPath \u003d new Path(orig + System.currentTimeMillis());\n        }\n        \n        if (fs.rename(path, trashPath))           // move to current trash\n          return true;\n      } catch (IOException e) {\n        cause \u003d e;\n      }\n    }\n    throw (IOException)\n      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n  }",
      "path": "src/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {}
    },
    "09d826ebed0394d80dd24432a3bbf894efe46265": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6180. NameNode slowed down when many files with same filename were moved to Trash. Contributed by Boris Shkolnik.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@802107 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/09 10:59 AM",
      "commitName": "09d826ebed0394d80dd24432a3bbf894efe46265",
      "commitAuthor": "Hairong Kuang",
      "commitDateOld": "18/05/09 9:20 PM",
      "commitNameOld": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 80.57,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,57 @@\n   public boolean moveToTrash(Path path) throws IOException {\n     if (interval \u003d\u003d 0)\n       return false;\n \n     if (!path.isAbsolute())                       // make path absolute\n       path \u003d new Path(fs.getWorkingDirectory(), path);\n \n     if (!fs.exists(path))                         // check that path exists\n       throw new FileNotFoundException(path.toString());\n \n     String qpath \u003d path.makeQualified(fs).toString();\n \n     if (qpath.startsWith(trash.toString())) {\n       return false;                               // already in trash\n     }\n \n     if (trash.getParent().toString().startsWith(qpath)) {\n       throw new IOException(\"Cannot move \\\"\" + path +\n                             \"\\\" to the trash, as it contains the trash\");\n     }\n \n     Path trashPath \u003d makeTrashRelativePath(current, path);\n     Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n     \n     IOException cause \u003d null;\n \n     // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n     for (int i \u003d 0; i \u003c 2; i++) {\n       try {\n         if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n           LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n           return false;\n         }\n       } catch (IOException e) {\n         LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n         return false;\n       }\n       try {\n         //\n         // if the target path in Trash already exists, then append with \n-        // a number. Start from 1.\n+        // a current time in millisecs.\n         //\n         String orig \u003d trashPath.toString();\n-        for (int j \u003d 1; fs.exists(trashPath); j++) {\n-          trashPath \u003d new Path(orig + \".\" + j);\n+        \n+        while(fs.exists(trashPath)) {\n+          trashPath \u003d new Path(orig + System.currentTimeMillis());\n         }\n+        \n         if (fs.rename(path, trashPath))           // move to current trash\n           return true;\n       } catch (IOException e) {\n         cause \u003d e;\n       }\n     }\n     throw (IOException)\n       new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    if (interval \u003d\u003d 0)\n      return false;\n\n    if (!path.isAbsolute())                       // make path absolute\n      path \u003d new Path(fs.getWorkingDirectory(), path);\n\n    if (!fs.exists(path))                         // check that path exists\n      throw new FileNotFoundException(path.toString());\n\n    String qpath \u003d path.makeQualified(fs).toString();\n\n    if (qpath.startsWith(trash.toString())) {\n      return false;                               // already in trash\n    }\n\n    if (trash.getParent().toString().startsWith(qpath)) {\n      throw new IOException(\"Cannot move \\\"\" + path +\n                            \"\\\" to the trash, as it contains the trash\");\n    }\n\n    Path trashPath \u003d makeTrashRelativePath(current, path);\n    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n    \n    IOException cause \u003d null;\n\n    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n    for (int i \u003d 0; i \u003c 2; i++) {\n      try {\n        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n          LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n          return false;\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n        return false;\n      }\n      try {\n        //\n        // if the target path in Trash already exists, then append with \n        // a current time in millisecs.\n        //\n        String orig \u003d trashPath.toString();\n        \n        while(fs.exists(trashPath)) {\n          trashPath \u003d new Path(orig + System.currentTimeMillis());\n        }\n        \n        if (fs.rename(path, trashPath))           // move to current trash\n          return true;\n      } catch (IOException e) {\n        cause \u003d e;\n      }\n    }\n    throw (IOException)\n      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n  }",
      "path": "src/java/org/apache/hadoop/fs/Trash.java",
      "extendedDetails": {}
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,55 @@\n+  public boolean moveToTrash(Path path) throws IOException {\n+    if (interval \u003d\u003d 0)\n+      return false;\n+\n+    if (!path.isAbsolute())                       // make path absolute\n+      path \u003d new Path(fs.getWorkingDirectory(), path);\n+\n+    if (!fs.exists(path))                         // check that path exists\n+      throw new FileNotFoundException(path.toString());\n+\n+    String qpath \u003d path.makeQualified(fs).toString();\n+\n+    if (qpath.startsWith(trash.toString())) {\n+      return false;                               // already in trash\n+    }\n+\n+    if (trash.getParent().toString().startsWith(qpath)) {\n+      throw new IOException(\"Cannot move \\\"\" + path +\n+                            \"\\\" to the trash, as it contains the trash\");\n+    }\n+\n+    Path trashPath \u003d makeTrashRelativePath(current, path);\n+    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n+    \n+    IOException cause \u003d null;\n+\n+    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n+    for (int i \u003d 0; i \u003c 2; i++) {\n+      try {\n+        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n+          LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n+          return false;\n+        }\n+      } catch (IOException e) {\n+        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n+        return false;\n+      }\n+      try {\n+        //\n+        // if the target path in Trash already exists, then append with \n+        // a number. Start from 1.\n+        //\n+        String orig \u003d trashPath.toString();\n+        for (int j \u003d 1; fs.exists(trashPath); j++) {\n+          trashPath \u003d new Path(orig + \".\" + j);\n+        }\n+        if (fs.rename(path, trashPath))           // move to current trash\n+          return true;\n+      } catch (IOException e) {\n+        cause \u003d e;\n+      }\n+    }\n+    throw (IOException)\n+      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean moveToTrash(Path path) throws IOException {\n    if (interval \u003d\u003d 0)\n      return false;\n\n    if (!path.isAbsolute())                       // make path absolute\n      path \u003d new Path(fs.getWorkingDirectory(), path);\n\n    if (!fs.exists(path))                         // check that path exists\n      throw new FileNotFoundException(path.toString());\n\n    String qpath \u003d path.makeQualified(fs).toString();\n\n    if (qpath.startsWith(trash.toString())) {\n      return false;                               // already in trash\n    }\n\n    if (trash.getParent().toString().startsWith(qpath)) {\n      throw new IOException(\"Cannot move \\\"\" + path +\n                            \"\\\" to the trash, as it contains the trash\");\n    }\n\n    Path trashPath \u003d makeTrashRelativePath(current, path);\n    Path baseTrashPath \u003d makeTrashRelativePath(current, path.getParent());\n    \n    IOException cause \u003d null;\n\n    // try twice, in case checkpoint between the mkdirs() \u0026 rename()\n    for (int i \u003d 0; i \u003c 2; i++) {\n      try {\n        if (!fs.mkdirs(baseTrashPath, PERMISSION)) {      // create current\n          LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n          return false;\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Can\u0027t create trash directory: \"+baseTrashPath);\n        return false;\n      }\n      try {\n        //\n        // if the target path in Trash already exists, then append with \n        // a number. Start from 1.\n        //\n        String orig \u003d trashPath.toString();\n        for (int j \u003d 1; fs.exists(trashPath); j++) {\n          trashPath \u003d new Path(orig + \".\" + j);\n        }\n        if (fs.rename(path, trashPath))           // move to current trash\n          return true;\n      } catch (IOException e) {\n        cause \u003d e;\n      }\n    }\n    throw (IOException)\n      new IOException(\"Failed to move to trash: \"+path).initCause(cause);\n  }",
      "path": "src/java/org/apache/hadoop/fs/Trash.java"
    }
  }
}