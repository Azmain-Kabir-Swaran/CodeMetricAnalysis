{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OpenFileCtx.java",
  "functionName": "receivedNewWrite",
  "functionId": "receivedNewWrite___dfsClient-DFSClient__request-WRITE3Request__channel-Channel__xid-int__asyncDataService-AsyncDataService__iug-IdMappingServiceProvider",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
  "functionStartLine": 426,
  "functionEndLine": 468,
  "numCommitsSeen": 62,
  "timeTaken": 2789,
  "changeHistory": [
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "d6602b5f39833611b4afa4581552f6c4c37e23a8",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f",
    "72a556d3b0def0ab4e4509528cc513f6df06b084",
    "875aa797caee96572162ff59bc50cf97d1195348",
    "08a9ac7098cb4ae684f40cf2513e3137110cc7e4",
    "28e3d09230971b32f74284311931525cb7ad1b7c",
    "5e18410e06dd63113c49029894007e0878312903",
    "a56a4b6ef06602312144783b7507bf2b82821e4f",
    "37f587563a943a827fbff865f5302bac6d202415"
  ],
  "changeHistoryShort": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "d6602b5f39833611b4afa4581552f6c4c37e23a8": "Ybodychange",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": "Ybodychange",
    "72a556d3b0def0ab4e4509528cc513f6df06b084": "Yparameterchange",
    "875aa797caee96572162ff59bc50cf97d1195348": "Ybodychange",
    "08a9ac7098cb4ae684f40cf2513e3137110cc7e4": "Ybodychange",
    "28e3d09230971b32f74284311931525cb7ad1b7c": "Ybodychange",
    "5e18410e06dd63113c49029894007e0878312903": "Ybodychange",
    "a56a4b6ef06602312144783b7507bf2b82821e4f": "Ybodychange",
    "37f587563a943a827fbff865f5302bac6d202415": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "10/10/17 10:38 AM",
      "commitNameOld": "d6602b5f39833611b4afa4581552f6c4c37e23a8",
      "commitAuthorOld": "Jitendra Pandey",
      "daysBetweenCommits": 126.95,
      "commitsBetweenForRepo": 833,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,43 @@\n   public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n       Channel channel, int xid, AsyncDataService asyncDataService,\n       IdMappingServiceProvider iug) {\n     \n     if (!activeState) {\n-      LOG.info(\"OpenFileCtx is inactive, fileId: \"\n-          + request.getHandle().dumpFileHandle());\n+      LOG.info(\"OpenFileCtx is inactive, fileId: {}\",\n+          request.getHandle().dumpFileHandle());\n       WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n       WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n           fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n       Nfs3Utils.writeChannel(channel,\n           response.serialize(new XDR(), xid, new VerifierNone()),\n           xid);\n     } else {\n       // Update the write time first\n       updateLastAccessTime();\n       \n       // Handle repeated write requests (same xid or not).\n       // If already replied, send reply again. If not replied, drop the\n       // repeated request.\n       WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n           xid);\n       if (existantWriteCtx !\u003d null) {\n         if (!existantWriteCtx.getReplied()) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Repeated write request which hasn\u0027t been served: xid\u003d\"\n-                + xid + \", drop it.\");\n-          }\n+          LOG.debug(\"Repeated write request which hasn\u0027t been served: \" +\n+                    \"xid\u003d{}, drop it.\", xid);\n         } else {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n-                + xid + \", resend response.\");\n-          }\n+          LOG.debug(\"Repeated write request which is already served: xid\u003d{}\" +\n+              \", resend response.\", xid);\n           WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n           WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n               fileWcc, request.getCount(), request.getStableHow(),\n               Nfs3Constant.WRITE_COMMIT_VERF);\n           Nfs3Utils.writeChannel(channel, response.serialize(\n               new XDR(), xid, new VerifierNone()), xid);\n         }\n       } else {\n         // not a repeated write request\n         receivedNewWriteInternal(dfsClient, request, channel, xid,\n             asyncDataService, iug);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n      Channel channel, int xid, AsyncDataService asyncDataService,\n      IdMappingServiceProvider iug) {\n    \n    if (!activeState) {\n      LOG.info(\"OpenFileCtx is inactive, fileId: {}\",\n          request.getHandle().dumpFileHandle());\n      WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n      WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n          fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n      Nfs3Utils.writeChannel(channel,\n          response.serialize(new XDR(), xid, new VerifierNone()),\n          xid);\n    } else {\n      // Update the write time first\n      updateLastAccessTime();\n      \n      // Handle repeated write requests (same xid or not).\n      // If already replied, send reply again. If not replied, drop the\n      // repeated request.\n      WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n          xid);\n      if (existantWriteCtx !\u003d null) {\n        if (!existantWriteCtx.getReplied()) {\n          LOG.debug(\"Repeated write request which hasn\u0027t been served: \" +\n                    \"xid\u003d{}, drop it.\", xid);\n        } else {\n          LOG.debug(\"Repeated write request which is already served: xid\u003d{}\" +\n              \", resend response.\", xid);\n          WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n          WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n              fileWcc, request.getCount(), request.getStableHow(),\n              Nfs3Constant.WRITE_COMMIT_VERF);\n          Nfs3Utils.writeChannel(channel, response.serialize(\n              new XDR(), xid, new VerifierNone()), xid);\n        }\n      } else {\n        // not a repeated write request\n        receivedNewWriteInternal(dfsClient, request, channel, xid,\n            asyncDataService, iug);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "d6602b5f39833611b4afa4581552f6c4c37e23a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11575. Supporting HDFS NFS gateway with Federated HDFS. Contributed by Mukul Kumar Singh.\n",
      "commitDate": "10/10/17 10:38 AM",
      "commitName": "d6602b5f39833611b4afa4581552f6c4c37e23a8",
      "commitAuthor": "Jitendra Pandey",
      "commitDateOld": "31/05/17 8:09 AM",
      "commitNameOld": "13de636b4079b077890ad10389ff350dcf8086a2",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 132.1,
      "commitsBetweenForRepo": 969,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n       Channel channel, int xid, AsyncDataService asyncDataService,\n       IdMappingServiceProvider iug) {\n     \n     if (!activeState) {\n       LOG.info(\"OpenFileCtx is inactive, fileId: \"\n-          + request.getHandle().getFileId());\n+          + request.getHandle().dumpFileHandle());\n       WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n       WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n           fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n       Nfs3Utils.writeChannel(channel,\n           response.serialize(new XDR(), xid, new VerifierNone()),\n           xid);\n     } else {\n       // Update the write time first\n       updateLastAccessTime();\n       \n       // Handle repeated write requests (same xid or not).\n       // If already replied, send reply again. If not replied, drop the\n       // repeated request.\n       WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n           xid);\n       if (existantWriteCtx !\u003d null) {\n         if (!existantWriteCtx.getReplied()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Repeated write request which hasn\u0027t been served: xid\u003d\"\n                 + xid + \", drop it.\");\n           }\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                 + xid + \", resend response.\");\n           }\n           WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n           WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n               fileWcc, request.getCount(), request.getStableHow(),\n               Nfs3Constant.WRITE_COMMIT_VERF);\n           Nfs3Utils.writeChannel(channel, response.serialize(\n               new XDR(), xid, new VerifierNone()), xid);\n         }\n       } else {\n         // not a repeated write request\n         receivedNewWriteInternal(dfsClient, request, channel, xid,\n             asyncDataService, iug);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n      Channel channel, int xid, AsyncDataService asyncDataService,\n      IdMappingServiceProvider iug) {\n    \n    if (!activeState) {\n      LOG.info(\"OpenFileCtx is inactive, fileId: \"\n          + request.getHandle().dumpFileHandle());\n      WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n      WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n          fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n      Nfs3Utils.writeChannel(channel,\n          response.serialize(new XDR(), xid, new VerifierNone()),\n          xid);\n    } else {\n      // Update the write time first\n      updateLastAccessTime();\n      \n      // Handle repeated write requests (same xid or not).\n      // If already replied, send reply again. If not replied, drop the\n      // repeated request.\n      WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n          xid);\n      if (existantWriteCtx !\u003d null) {\n        if (!existantWriteCtx.getReplied()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which hasn\u0027t been served: xid\u003d\"\n                + xid + \", drop it.\");\n          }\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                + xid + \", resend response.\");\n          }\n          WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n          WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n              fileWcc, request.getCount(), request.getStableHow(),\n              Nfs3Constant.WRITE_COMMIT_VERF);\n          Nfs3Utils.writeChannel(channel, response.serialize(\n              new XDR(), xid, new VerifierNone()), xid);\n        }\n      } else {\n        // not a repeated write request\n        receivedNewWriteInternal(dfsClient, request, channel, xid,\n            asyncDataService, iug);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7423. various typos and message formatting fixes in nfs daemon and doc. (Charles Lamb via yliu)\n",
      "commitDate": "28/01/15 12:56 PM",
      "commitName": "f37849188b05a6251584de1aed5e66d5dfa7da4f",
      "commitAuthor": "yliu",
      "commitDateOld": "11/12/14 3:40 PM",
      "commitNameOld": "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 47.89,
      "commitsBetweenForRepo": 279,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n       Channel channel, int xid, AsyncDataService asyncDataService,\n       IdMappingServiceProvider iug) {\n     \n     if (!activeState) {\n-      LOG.info(\"OpenFileCtx is inactive, fileId:\"\n+      LOG.info(\"OpenFileCtx is inactive, fileId: \"\n           + request.getHandle().getFileId());\n       WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n       WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n           fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n       Nfs3Utils.writeChannel(channel,\n           response.serialize(new XDR(), xid, new VerifierNone()),\n           xid);\n     } else {\n       // Update the write time first\n       updateLastAccessTime();\n       \n       // Handle repeated write requests (same xid or not).\n       // If already replied, send reply again. If not replied, drop the\n       // repeated request.\n       WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n           xid);\n       if (existantWriteCtx !\u003d null) {\n         if (!existantWriteCtx.getReplied()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Repeated write request which hasn\u0027t been served: xid\u003d\"\n                 + xid + \", drop it.\");\n           }\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                 + xid + \", resend response.\");\n           }\n           WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n           WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n               fileWcc, request.getCount(), request.getStableHow(),\n               Nfs3Constant.WRITE_COMMIT_VERF);\n           Nfs3Utils.writeChannel(channel, response.serialize(\n               new XDR(), xid, new VerifierNone()), xid);\n         }\n       } else {\n         // not a repeated write request\n         receivedNewWriteInternal(dfsClient, request, channel, xid,\n             asyncDataService, iug);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n      Channel channel, int xid, AsyncDataService asyncDataService,\n      IdMappingServiceProvider iug) {\n    \n    if (!activeState) {\n      LOG.info(\"OpenFileCtx is inactive, fileId: \"\n          + request.getHandle().getFileId());\n      WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n      WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n          fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n      Nfs3Utils.writeChannel(channel,\n          response.serialize(new XDR(), xid, new VerifierNone()),\n          xid);\n    } else {\n      // Update the write time first\n      updateLastAccessTime();\n      \n      // Handle repeated write requests (same xid or not).\n      // If already replied, send reply again. If not replied, drop the\n      // repeated request.\n      WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n          xid);\n      if (existantWriteCtx !\u003d null) {\n        if (!existantWriteCtx.getReplied()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which hasn\u0027t been served: xid\u003d\"\n                + xid + \", drop it.\");\n          }\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                + xid + \", resend response.\");\n          }\n          WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n          WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n              fileWcc, request.getCount(), request.getStableHow(),\n              Nfs3Constant.WRITE_COMMIT_VERF);\n          Nfs3Utils.writeChannel(channel, response.serialize(\n              new XDR(), xid, new VerifierNone()), xid);\n        }\n      } else {\n        // not a repeated write request\n        receivedNewWriteInternal(dfsClient, request, channel, xid,\n            asyncDataService, iug);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "72a556d3b0def0ab4e4509528cc513f6df06b084": {
      "type": "Yparameterchange",
      "commitMessage": "HADOOP-11195. Move Id-Name mapping in NFS to the hadoop-common area for better maintenance. Contributed by Yongjun Zhang\n",
      "commitDate": "29/10/14 11:05 AM",
      "commitName": "72a556d3b0def0ab4e4509528cc513f6df06b084",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "22/10/14 9:27 PM",
      "commitNameOld": "d71d40a63d198991077d5babd70be5e9787a53f1",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n       Channel channel, int xid, AsyncDataService asyncDataService,\n-      IdUserGroup iug) {\n+      IdMappingServiceProvider iug) {\n     \n     if (!activeState) {\n       LOG.info(\"OpenFileCtx is inactive, fileId:\"\n           + request.getHandle().getFileId());\n       WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n       WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n           fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n       Nfs3Utils.writeChannel(channel,\n           response.serialize(new XDR(), xid, new VerifierNone()),\n           xid);\n     } else {\n       // Update the write time first\n       updateLastAccessTime();\n       \n       // Handle repeated write requests (same xid or not).\n       // If already replied, send reply again. If not replied, drop the\n       // repeated request.\n       WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n           xid);\n       if (existantWriteCtx !\u003d null) {\n         if (!existantWriteCtx.getReplied()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Repeated write request which hasn\u0027t been served: xid\u003d\"\n                 + xid + \", drop it.\");\n           }\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                 + xid + \", resend response.\");\n           }\n           WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n           WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n               fileWcc, request.getCount(), request.getStableHow(),\n               Nfs3Constant.WRITE_COMMIT_VERF);\n           Nfs3Utils.writeChannel(channel, response.serialize(\n               new XDR(), xid, new VerifierNone()), xid);\n         }\n       } else {\n         // not a repeated write request\n         receivedNewWriteInternal(dfsClient, request, channel, xid,\n             asyncDataService, iug);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n      Channel channel, int xid, AsyncDataService asyncDataService,\n      IdMappingServiceProvider iug) {\n    \n    if (!activeState) {\n      LOG.info(\"OpenFileCtx is inactive, fileId:\"\n          + request.getHandle().getFileId());\n      WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n      WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n          fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n      Nfs3Utils.writeChannel(channel,\n          response.serialize(new XDR(), xid, new VerifierNone()),\n          xid);\n    } else {\n      // Update the write time first\n      updateLastAccessTime();\n      \n      // Handle repeated write requests (same xid or not).\n      // If already replied, send reply again. If not replied, drop the\n      // repeated request.\n      WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n          xid);\n      if (existantWriteCtx !\u003d null) {\n        if (!existantWriteCtx.getReplied()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which hasn\u0027t been served: xid\u003d\"\n                + xid + \", drop it.\");\n          }\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                + xid + \", resend response.\");\n          }\n          WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n          WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n              fileWcc, request.getCount(), request.getStableHow(),\n              Nfs3Constant.WRITE_COMMIT_VERF);\n          Nfs3Utils.writeChannel(channel, response.serialize(\n              new XDR(), xid, new VerifierNone()), xid);\n        }\n      } else {\n        // not a repeated write request\n        receivedNewWriteInternal(dfsClient, request, channel, xid,\n            asyncDataService, iug);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {
        "oldValue": "[dfsClient-DFSClient, request-WRITE3Request, channel-Channel, xid-int, asyncDataService-AsyncDataService, iug-IdUserGroup]",
        "newValue": "[dfsClient-DFSClient, request-WRITE3Request, channel-Channel, xid-int, asyncDataService-AsyncDataService, iug-IdMappingServiceProvider]"
      }
    },
    "875aa797caee96572162ff59bc50cf97d1195348": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6894. Add XDR parser method for each NFS response. Contributed by Brandon Li.\n",
      "commitDate": "01/10/14 1:18 PM",
      "commitName": "875aa797caee96572162ff59bc50cf97d1195348",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "18/09/14 2:57 PM",
      "commitNameOld": "70be56d093022de9953e14a92dfa1a146bd9a290",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 12.93,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n       Channel channel, int xid, AsyncDataService asyncDataService,\n       IdUserGroup iug) {\n     \n     if (!activeState) {\n       LOG.info(\"OpenFileCtx is inactive, fileId:\"\n           + request.getHandle().getFileId());\n       WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n       WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n           fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n       Nfs3Utils.writeChannel(channel,\n-          response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n+          response.serialize(new XDR(), xid, new VerifierNone()),\n           xid);\n     } else {\n       // Update the write time first\n       updateLastAccessTime();\n       \n       // Handle repeated write requests (same xid or not).\n       // If already replied, send reply again. If not replied, drop the\n       // repeated request.\n       WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n           xid);\n       if (existantWriteCtx !\u003d null) {\n         if (!existantWriteCtx.getReplied()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Repeated write request which hasn\u0027t been served: xid\u003d\"\n                 + xid + \", drop it.\");\n           }\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                 + xid + \", resend response.\");\n           }\n           WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n           WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n               fileWcc, request.getCount(), request.getStableHow(),\n               Nfs3Constant.WRITE_COMMIT_VERF);\n-          Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n+          Nfs3Utils.writeChannel(channel, response.serialize(\n               new XDR(), xid, new VerifierNone()), xid);\n         }\n       } else {\n         // not a repeated write request\n         receivedNewWriteInternal(dfsClient, request, channel, xid,\n             asyncDataService, iug);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n      Channel channel, int xid, AsyncDataService asyncDataService,\n      IdUserGroup iug) {\n    \n    if (!activeState) {\n      LOG.info(\"OpenFileCtx is inactive, fileId:\"\n          + request.getHandle().getFileId());\n      WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n      WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n          fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n      Nfs3Utils.writeChannel(channel,\n          response.serialize(new XDR(), xid, new VerifierNone()),\n          xid);\n    } else {\n      // Update the write time first\n      updateLastAccessTime();\n      \n      // Handle repeated write requests (same xid or not).\n      // If already replied, send reply again. If not replied, drop the\n      // repeated request.\n      WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n          xid);\n      if (existantWriteCtx !\u003d null) {\n        if (!existantWriteCtx.getReplied()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which hasn\u0027t been served: xid\u003d\"\n                + xid + \", drop it.\");\n          }\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                + xid + \", resend response.\");\n          }\n          WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n          WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n              fileWcc, request.getCount(), request.getStableHow(),\n              Nfs3Constant.WRITE_COMMIT_VERF);\n          Nfs3Utils.writeChannel(channel, response.serialize(\n              new XDR(), xid, new VerifierNone()), xid);\n        }\n      } else {\n        // not a repeated write request\n        receivedNewWriteInternal(dfsClient, request, channel, xid,\n            asyncDataService, iug);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "08a9ac7098cb4ae684f40cf2513e3137110cc7e4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6942. Fix typos in log messages. Contributed by Ray Chiang.\n",
      "commitDate": "02/09/14 4:22 PM",
      "commitName": "08a9ac7098cb4ae684f40cf2513e3137110cc7e4",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "19/06/14 12:39 PM",
      "commitNameOld": "9ff3836a367737d6dfcb12f50c8bd2f1b2233e37",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 75.15,
      "commitsBetweenForRepo": 587,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n       Channel channel, int xid, AsyncDataService asyncDataService,\n       IdUserGroup iug) {\n     \n     if (!activeState) {\n       LOG.info(\"OpenFileCtx is inactive, fileId:\"\n           + request.getHandle().getFileId());\n       WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n       WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n           fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n       Nfs3Utils.writeChannel(channel,\n           response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n           xid);\n     } else {\n       // Update the write time first\n       updateLastAccessTime();\n       \n       // Handle repeated write requests (same xid or not).\n       // If already replied, send reply again. If not replied, drop the\n       // repeated request.\n       WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n           xid);\n       if (existantWriteCtx !\u003d null) {\n         if (!existantWriteCtx.getReplied()) {\n           if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Repeated write request which hasn\u0027t be served: xid\u003d\"\n+            LOG.debug(\"Repeated write request which hasn\u0027t been served: xid\u003d\"\n                 + xid + \", drop it.\");\n           }\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                 + xid + \", resend response.\");\n           }\n           WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n           WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n               fileWcc, request.getCount(), request.getStableHow(),\n               Nfs3Constant.WRITE_COMMIT_VERF);\n           Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n               new XDR(), xid, new VerifierNone()), xid);\n         }\n       } else {\n         // not a repeated write request\n         receivedNewWriteInternal(dfsClient, request, channel, xid,\n             asyncDataService, iug);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n      Channel channel, int xid, AsyncDataService asyncDataService,\n      IdUserGroup iug) {\n    \n    if (!activeState) {\n      LOG.info(\"OpenFileCtx is inactive, fileId:\"\n          + request.getHandle().getFileId());\n      WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n      WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n          fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n      Nfs3Utils.writeChannel(channel,\n          response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n          xid);\n    } else {\n      // Update the write time first\n      updateLastAccessTime();\n      \n      // Handle repeated write requests (same xid or not).\n      // If already replied, send reply again. If not replied, drop the\n      // repeated request.\n      WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n          xid);\n      if (existantWriteCtx !\u003d null) {\n        if (!existantWriteCtx.getReplied()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which hasn\u0027t been served: xid\u003d\"\n                + xid + \", drop it.\");\n          }\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                + xid + \", resend response.\");\n          }\n          WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n          WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n              fileWcc, request.getCount(), request.getStableHow(),\n              Nfs3Constant.WRITE_COMMIT_VERF);\n          Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n              new XDR(), xid, new VerifierNone()), xid);\n        }\n      } else {\n        // not a repeated write request\n        receivedNewWriteInternal(dfsClient, request, channel, xid,\n            asyncDataService, iug);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "28e3d09230971b32f74284311931525cb7ad1b7c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4971. Move IO operations out of locking in OpenFileCtx. Contributed by Jing Zhao and Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1525681 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/09/13 1:02 PM",
      "commitName": "28e3d09230971b32f74284311931525cb7ad1b7c",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "17/09/13 11:08 PM",
      "commitNameOld": "5e18410e06dd63113c49029894007e0878312903",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.58,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,47 @@\n   public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n       Channel channel, int xid, AsyncDataService asyncDataService,\n       IdUserGroup iug) {\n-\n-    lockCtx();\n-    try {\n-      if (!activeState) {\n-        LOG.info(\"OpenFileCtx is inactive, fileId:\"\n-            + request.getHandle().getFileId());\n-        WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n-        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n-            fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n-        Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n-            new XDR(), xid, new VerifierNone()), xid);\n-      } else {\n-        // Handle repeated write requests(same xid or not).\n-        // If already replied, send reply again. If not replied, drop the\n-        // repeated request.\n-        WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n-            xid);\n-        if (existantWriteCtx !\u003d null) {\n-          if (!existantWriteCtx.getReplied()) {\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Repeated write request which hasn\u0027t be served: xid\u003d\"\n-                  + xid + \", drop it.\");\n-            }\n-          } else {\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n-                  + xid + \", resend response.\");\n-            }\n-            WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n-            WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n-                fileWcc, request.getCount(), request.getStableHow(),\n-                Nfs3Constant.WRITE_COMMIT_VERF);\n-            Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n-                new XDR(), xid, new VerifierNone()), xid);\n+    \n+    if (!activeState) {\n+      LOG.info(\"OpenFileCtx is inactive, fileId:\"\n+          + request.getHandle().getFileId());\n+      WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n+      WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n+          fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n+      Nfs3Utils.writeChannel(channel,\n+          response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n+          xid);\n+    } else {\n+      // Update the write time first\n+      updateLastAccessTime();\n+      \n+      // Handle repeated write requests (same xid or not).\n+      // If already replied, send reply again. If not replied, drop the\n+      // repeated request.\n+      WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n+          xid);\n+      if (existantWriteCtx !\u003d null) {\n+        if (!existantWriteCtx.getReplied()) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Repeated write request which hasn\u0027t be served: xid\u003d\"\n+                + xid + \", drop it.\");\n           }\n-          updateLastAccessTime();\n-          \n         } else {\n-          receivedNewWriteInternal(dfsClient, request, channel, xid,\n-              asyncDataService, iug);\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n+                + xid + \", resend response.\");\n+          }\n+          WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n+          WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n+              fileWcc, request.getCount(), request.getStableHow(),\n+              Nfs3Constant.WRITE_COMMIT_VERF);\n+          Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n+              new XDR(), xid, new VerifierNone()), xid);\n         }\n+      } else {\n+        // not a repeated write request\n+        receivedNewWriteInternal(dfsClient, request, channel, xid,\n+            asyncDataService, iug);\n       }\n-\n-    } finally {\n-      unlockCtx();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n      Channel channel, int xid, AsyncDataService asyncDataService,\n      IdUserGroup iug) {\n    \n    if (!activeState) {\n      LOG.info(\"OpenFileCtx is inactive, fileId:\"\n          + request.getHandle().getFileId());\n      WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n      WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n          fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n      Nfs3Utils.writeChannel(channel,\n          response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n          xid);\n    } else {\n      // Update the write time first\n      updateLastAccessTime();\n      \n      // Handle repeated write requests (same xid or not).\n      // If already replied, send reply again. If not replied, drop the\n      // repeated request.\n      WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n          xid);\n      if (existantWriteCtx !\u003d null) {\n        if (!existantWriteCtx.getReplied()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which hasn\u0027t be served: xid\u003d\"\n                + xid + \", drop it.\");\n          }\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                + xid + \", resend response.\");\n          }\n          WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n          WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n              fileWcc, request.getCount(), request.getStableHow(),\n              Nfs3Constant.WRITE_COMMIT_VERF);\n          Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n              new XDR(), xid, new VerifierNone()), xid);\n        }\n      } else {\n        // not a repeated write request\n        receivedNewWriteInternal(dfsClient, request, channel, xid,\n            asyncDataService, iug);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "5e18410e06dd63113c49029894007e0878312903": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5212. Refactor RpcMessage and NFS3Response to support different types of authentication information. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1524298 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/09/13 11:08 PM",
      "commitName": "5e18410e06dd63113c49029894007e0878312903",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/09/13 4:14 PM",
      "commitNameOld": "a56a4b6ef06602312144783b7507bf2b82821e4f",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 4.29,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,50 @@\n   public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n       Channel channel, int xid, AsyncDataService asyncDataService,\n       IdUserGroup iug) {\n \n     lockCtx();\n     try {\n       if (!activeState) {\n         LOG.info(\"OpenFileCtx is inactive, fileId:\"\n             + request.getHandle().getFileId());\n         WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n             fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n-        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n+        Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n+            new XDR(), xid, new VerifierNone()), xid);\n       } else {\n         // Handle repeated write requests(same xid or not).\n         // If already replied, send reply again. If not replied, drop the\n         // repeated request.\n         WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n             xid);\n         if (existantWriteCtx !\u003d null) {\n           if (!existantWriteCtx.getReplied()) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Repeated write request which hasn\u0027t be served: xid\u003d\"\n                   + xid + \", drop it.\");\n             }\n           } else {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                   + xid + \", resend response.\");\n             }\n             WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n             WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n                 fileWcc, request.getCount(), request.getStableHow(),\n                 Nfs3Constant.WRITE_COMMIT_VERF);\n-            Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n+            Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n+                new XDR(), xid, new VerifierNone()), xid);\n           }\n           updateLastAccessTime();\n           \n         } else {\n           receivedNewWriteInternal(dfsClient, request, channel, xid,\n               asyncDataService, iug);\n         }\n       }\n \n     } finally {\n       unlockCtx();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n      Channel channel, int xid, AsyncDataService asyncDataService,\n      IdUserGroup iug) {\n\n    lockCtx();\n    try {\n      if (!activeState) {\n        LOG.info(\"OpenFileCtx is inactive, fileId:\"\n            + request.getHandle().getFileId());\n        WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n            fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n            new XDR(), xid, new VerifierNone()), xid);\n      } else {\n        // Handle repeated write requests(same xid or not).\n        // If already replied, send reply again. If not replied, drop the\n        // repeated request.\n        WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n            xid);\n        if (existantWriteCtx !\u003d null) {\n          if (!existantWriteCtx.getReplied()) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Repeated write request which hasn\u0027t be served: xid\u003d\"\n                  + xid + \", drop it.\");\n            }\n          } else {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                  + xid + \", resend response.\");\n            }\n            WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n            WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n                fileWcc, request.getCount(), request.getStableHow(),\n                Nfs3Constant.WRITE_COMMIT_VERF);\n            Nfs3Utils.writeChannel(channel, response.writeHeaderAndResponse(\n                new XDR(), xid, new VerifierNone()), xid);\n          }\n          updateLastAccessTime();\n          \n        } else {\n          receivedNewWriteInternal(dfsClient, request, channel, xid,\n              asyncDataService, iug);\n        }\n      }\n\n    } finally {\n      unlockCtx();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "a56a4b6ef06602312144783b7507bf2b82821e4f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5199 Add more debug trace for NFS READ and WRITE. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1523140 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/09/13 4:14 PM",
      "commitName": "a56a4b6ef06602312144783b7507bf2b82821e4f",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "28/08/13 10:23 AM",
      "commitNameOld": "30b8ef91a32ddf1fe3756bae6d7dc538a150bdc4",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 16.24,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n       Channel channel, int xid, AsyncDataService asyncDataService,\n       IdUserGroup iug) {\n \n     lockCtx();\n     try {\n       if (!activeState) {\n         LOG.info(\"OpenFileCtx is inactive, fileId:\"\n             + request.getHandle().getFileId());\n         WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n         WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n             fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n-        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n+        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n       } else {\n         // Handle repeated write requests(same xid or not).\n         // If already replied, send reply again. If not replied, drop the\n         // repeated request.\n         WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n             xid);\n         if (existantWriteCtx !\u003d null) {\n           if (!existantWriteCtx.getReplied()) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Repeated write request which hasn\u0027t be served: xid\u003d\"\n                   + xid + \", drop it.\");\n             }\n           } else {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                   + xid + \", resend response.\");\n             }\n             WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n             WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n                 fileWcc, request.getCount(), request.getStableHow(),\n                 Nfs3Constant.WRITE_COMMIT_VERF);\n-            Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n+            Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n           }\n           updateLastAccessTime();\n           \n         } else {\n           receivedNewWriteInternal(dfsClient, request, channel, xid,\n               asyncDataService, iug);\n         }\n       }\n \n     } finally {\n       unlockCtx();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n      Channel channel, int xid, AsyncDataService asyncDataService,\n      IdUserGroup iug) {\n\n    lockCtx();\n    try {\n      if (!activeState) {\n        LOG.info(\"OpenFileCtx is inactive, fileId:\"\n            + request.getHandle().getFileId());\n        WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n            fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n      } else {\n        // Handle repeated write requests(same xid or not).\n        // If already replied, send reply again. If not replied, drop the\n        // repeated request.\n        WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n            xid);\n        if (existantWriteCtx !\u003d null) {\n          if (!existantWriteCtx.getReplied()) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Repeated write request which hasn\u0027t be served: xid\u003d\"\n                  + xid + \", drop it.\");\n            }\n          } else {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                  + xid + \", resend response.\");\n            }\n            WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n            WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n                fileWcc, request.getCount(), request.getStableHow(),\n                Nfs3Constant.WRITE_COMMIT_VERF);\n            Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid), xid);\n          }\n          updateLastAccessTime();\n          \n        } else {\n          receivedNewWriteInternal(dfsClient, request, channel, xid,\n              asyncDataService, iug);\n        }\n      }\n\n    } finally {\n      unlockCtx();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java",
      "extendedDetails": {}
    },
    "37f587563a943a827fbff865f5302bac6d202415": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-4762 Provide HDFS based NFSv3 and Mountd implementation. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1499029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/07/13 10:31 AM",
      "commitName": "37f587563a943a827fbff865f5302bac6d202415",
      "commitAuthor": "Brandon Li",
      "diff": "@@ -0,0 +1,48 @@\n+  public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n+      Channel channel, int xid, AsyncDataService asyncDataService,\n+      IdUserGroup iug) {\n+\n+    lockCtx();\n+    try {\n+      if (!activeState) {\n+        LOG.info(\"OpenFileCtx is inactive, fileId:\"\n+            + request.getHandle().getFileId());\n+        WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n+        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n+            fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n+        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n+      } else {\n+        // Handle repeated write requests(same xid or not).\n+        // If already replied, send reply again. If not replied, drop the\n+        // repeated request.\n+        WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n+            xid);\n+        if (existantWriteCtx !\u003d null) {\n+          if (!existantWriteCtx.getReplied()) {\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Repeated write request which hasn\u0027t be served: xid\u003d\"\n+                  + xid + \", drop it.\");\n+            }\n+          } else {\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n+                  + xid + \", resend response.\");\n+            }\n+            WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n+            WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n+                fileWcc, request.getCount(), request.getStableHow(),\n+                Nfs3Constant.WRITE_COMMIT_VERF);\n+            Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n+          }\n+          updateLastAccessTime();\n+          \n+        } else {\n+          receivedNewWriteInternal(dfsClient, request, channel, xid,\n+              asyncDataService, iug);\n+        }\n+      }\n+\n+    } finally {\n+      unlockCtx();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void receivedNewWrite(DFSClient dfsClient, WRITE3Request request,\n      Channel channel, int xid, AsyncDataService asyncDataService,\n      IdUserGroup iug) {\n\n    lockCtx();\n    try {\n      if (!activeState) {\n        LOG.info(\"OpenFileCtx is inactive, fileId:\"\n            + request.getHandle().getFileId());\n        WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n        WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3ERR_IO,\n            fileWcc, 0, request.getStableHow(), Nfs3Constant.WRITE_COMMIT_VERF);\n        Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n      } else {\n        // Handle repeated write requests(same xid or not).\n        // If already replied, send reply again. If not replied, drop the\n        // repeated request.\n        WriteCtx existantWriteCtx \u003d checkRepeatedWriteRequest(request, channel,\n            xid);\n        if (existantWriteCtx !\u003d null) {\n          if (!existantWriteCtx.getReplied()) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Repeated write request which hasn\u0027t be served: xid\u003d\"\n                  + xid + \", drop it.\");\n            }\n          } else {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Repeated write request which is already served: xid\u003d\"\n                  + xid + \", resend response.\");\n            }\n            WccData fileWcc \u003d new WccData(latestAttr.getWccAttr(), latestAttr);\n            WRITE3Response response \u003d new WRITE3Response(Nfs3Status.NFS3_OK,\n                fileWcc, request.getCount(), request.getStableHow(),\n                Nfs3Constant.WRITE_COMMIT_VERF);\n            Nfs3Utils.writeChannel(channel, response.send(new XDR(), xid));\n          }\n          updateLastAccessTime();\n          \n        } else {\n          receivedNewWriteInternal(dfsClient, request, channel, xid,\n              asyncDataService, iug);\n        }\n      }\n\n    } finally {\n      unlockCtx();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/OpenFileCtx.java"
    }
  }
}