{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ServiceAuthorizationManager.java",
  "functionName": "authorize",
  "functionId": "authorize___user-UserGroupInformation__protocol-Class__?____conf-Configuration__addr-InetAddress",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
  "functionStartLine": 89,
  "functionEndLine": 141,
  "numCommitsSeen": 59,
  "timeTaken": 2724,
  "changeHistory": [
    "22430c10e2c41d7b5e4f0457eedaf5395b2b3c84",
    "318c9b68b059981796f2742b4b7ee604ccdc47e5",
    "20625c8f048701c9516da159b24c0b33983e4bb7",
    "c1cd41cc49ad99e733dc6b4e90cf29bb8020be06",
    "4c56bccf5ee1d6ec1fcef0804eacae785c4d7c18",
    "d94899877709836153244c2f0c5f14c37c9d4795",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "85461fb0fa36c82a85b7787162541cdc83e9c237",
    "f5c604f49c5559c402e682e5f15a6e9053ff68cf",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "c3fdd289cf26fa3bb9c0d2d9f906eba769ddd789",
    "642ed17a4808e36f1458546cc66d52e212cc5acf",
    "47d4ebebaca1d023342a93bc87dedbb00a60b2fa",
    "0fd49b35370e3c0c72abaf2007d34d4207347693",
    "7efb9640be26aabe3878310e82248a1b6b767a9a",
    "fa3a3bf5d8f3167f9725a3f91a0f4ae0481f24ea",
    "6ba9b70d85a89f1a28c5b159ad553ab6ffef80b2",
    "e346c2f4e08a38a80c7f505d8a8f3554b408e997",
    "d9b6103f8f63f66c254a7bd3a423a2a5fb6672e3",
    "c4c122a0def592136e03a653c9fdc4f464ed0854",
    "0c5734e4aca873f405fbf994e5fe7061e31731c8",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "22430c10e2c41d7b5e4f0457eedaf5395b2b3c84": "Ybodychange",
    "318c9b68b059981796f2742b4b7ee604ccdc47e5": "Ybodychange",
    "20625c8f048701c9516da159b24c0b33983e4bb7": "Ybodychange",
    "c1cd41cc49ad99e733dc6b4e90cf29bb8020be06": "Ybodychange",
    "4c56bccf5ee1d6ec1fcef0804eacae785c4d7c18": "Ybodychange",
    "d94899877709836153244c2f0c5f14c37c9d4795": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "85461fb0fa36c82a85b7787162541cdc83e9c237": "Ybodychange",
    "f5c604f49c5559c402e682e5f15a6e9053ff68cf": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "c3fdd289cf26fa3bb9c0d2d9f906eba769ddd789": "Ymultichange(Yparameterchange,Ybodychange)",
    "642ed17a4808e36f1458546cc66d52e212cc5acf": "Ymodifierchange",
    "47d4ebebaca1d023342a93bc87dedbb00a60b2fa": "Ymodifierchange",
    "0fd49b35370e3c0c72abaf2007d34d4207347693": "Ymodifierchange",
    "7efb9640be26aabe3878310e82248a1b6b767a9a": "Ybodychange",
    "fa3a3bf5d8f3167f9725a3f91a0f4ae0481f24ea": "Ymultichange(Yparameterchange,Ybodychange)",
    "6ba9b70d85a89f1a28c5b159ad553ab6ffef80b2": "Ybodychange",
    "e346c2f4e08a38a80c7f505d8a8f3554b408e997": "Ybodychange",
    "d9b6103f8f63f66c254a7bd3a423a2a5fb6672e3": "Ymultichange(Yparameterchange,Ybodychange)",
    "c4c122a0def592136e03a653c9fdc4f464ed0854": "Ybodychange",
    "0c5734e4aca873f405fbf994e5fe7061e31731c8": "Ymultichange(Yparameterchange,Ybodychange)",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "22430c10e2c41d7b5e4f0457eedaf5395b2b3c84": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16457. Fixed Kerberos activation in ServiceAuthorizationManager.\n              Contributed by Prabhu Joseph\n",
      "commitDate": "06/08/19 2:04 PM",
      "commitName": "22430c10e2c41d7b5e4f0457eedaf5395b2b3c84",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "17/07/17 9:32 PM",
      "commitNameOld": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 749.69,
      "commitsBetweenForRepo": 6227,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,53 @@\n   public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                InetAddress addr\n                                ) throws AuthorizationException {\n     AccessControlList[] acls \u003d protocolToAcls.get(protocol);\n     MachineList[] hosts \u003d protocolToMachineLists.get(protocol);\n     if (acls \u003d\u003d null || hosts \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n-    \n-    // get client principal key to verify (if available)\n-    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n-    String clientPrincipal \u003d null; \n-    if (krbInfo !\u003d null) {\n-      String clientKey \u003d krbInfo.clientPrincipal();\n-      if (clientKey !\u003d null \u0026\u0026 !clientKey.isEmpty()) {\n-        try {\n-          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n-              conf.get(clientKey), addr);\n-        } catch (IOException e) {\n-          throw (AuthorizationException) new AuthorizationException(\n-              \"Can\u0027t figure out Kerberos principal name for connection from \"\n-                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n-              .initCause(e);\n+\n+    String clientPrincipal \u003d null;\n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      // get client principal key to verify (if available)\n+      KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n+      if (krbInfo !\u003d null) {\n+        String clientKey \u003d krbInfo.clientPrincipal();\n+        if (clientKey !\u003d null \u0026\u0026 !clientKey.isEmpty()) {\n+          try {\n+            clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n+                conf.get(clientKey), addr);\n+          } catch (IOException e) {\n+            throw (AuthorizationException) new AuthorizationException(\n+                \"Can\u0027t figure out Kerberos principal name for connection from \"\n+                + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n+                .initCause(e);\n+          }\n         }\n       }\n     }\n     if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        acls.length !\u003d 2  || !acls[0].isUserAllowed(user) || acls[1].isUserAllowed(user)) {\n       String cause \u003d clientPrincipal !\u003d null ?\n           \": this service is only accessible by \" + clientPrincipal :\n           \": denied by configured ACL\";\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user\n           + \" for protocol\u003d\" + protocol + cause);\n       throw new AuthorizationException(\"User \" + user +\n           \" is not authorized for protocol \" + protocol + cause);\n     }\n     if (addr !\u003d null) {\n       String hostAddress \u003d addr.getHostAddress();\n       if (hosts.length !\u003d 2 || !hosts[0].includes(hostAddress) ||\n           hosts[1].includes(hostAddress)) {\n         AUDITLOG.warn(AUTHZ_FAILED_FOR + \" for protocol\u003d\" + protocol\n             + \" from host \u003d \" +  hostAddress);\n         throw new AuthorizationException(\"Host \" + hostAddress +\n             \" is not authorized for protocol \" + protocol) ;\n       }\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList[] acls \u003d protocolToAcls.get(protocol);\n    MachineList[] hosts \u003d protocolToMachineLists.get(protocol);\n    if (acls \u003d\u003d null || hosts \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n\n    String clientPrincipal \u003d null;\n    if (UserGroupInformation.isSecurityEnabled()) {\n      // get client principal key to verify (if available)\n      KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n      if (krbInfo !\u003d null) {\n        String clientKey \u003d krbInfo.clientPrincipal();\n        if (clientKey !\u003d null \u0026\u0026 !clientKey.isEmpty()) {\n          try {\n            clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n                conf.get(clientKey), addr);\n          } catch (IOException e) {\n            throw (AuthorizationException) new AuthorizationException(\n                \"Can\u0027t figure out Kerberos principal name for connection from \"\n                + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n                .initCause(e);\n          }\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n       acls.length !\u003d 2  || !acls[0].isUserAllowed(user) || acls[1].isUserAllowed(user)) {\n      String cause \u003d clientPrincipal !\u003d null ?\n          \": this service is only accessible by \" + clientPrincipal :\n          \": denied by configured ACL\";\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user\n          + \" for protocol\u003d\" + protocol + cause);\n      throw new AuthorizationException(\"User \" + user +\n          \" is not authorized for protocol \" + protocol + cause);\n    }\n    if (addr !\u003d null) {\n      String hostAddress \u003d addr.getHostAddress();\n      if (hosts.length !\u003d 2 || !hosts[0].includes(hostAddress) ||\n          hosts[1].includes(hostAddress)) {\n        AUDITLOG.warn(AUTHZ_FAILED_FOR + \" for protocol\u003d\" + protocol\n            + \" from host \u003d \" +  hostAddress);\n        throw new AuthorizationException(\"Host \" + hostAddress +\n            \" is not authorized for protocol \" + protocol) ;\n      }\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "318c9b68b059981796f2742b4b7ee604ccdc47e5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11404. Clarify the \"expected client Kerberos principal is null\" authorization message. Contributed by Stephen Chu\n",
      "commitDate": "10/03/16 3:35 AM",
      "commitName": "318c9b68b059981796f2742b4b7ee604ccdc47e5",
      "commitAuthor": "Harsh J",
      "commitDateOld": "08/01/15 10:06 AM",
      "commitNameOld": "20625c8f048701c9516da159b24c0b33983e4bb7",
      "commitAuthorOld": "Benoy Antony",
      "daysBetweenCommits": 426.73,
      "commitsBetweenForRepo": 3393,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,51 @@\n   public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                InetAddress addr\n                                ) throws AuthorizationException {\n     AccessControlList[] acls \u003d protocolToAcls.get(protocol);\n     MachineList[] hosts \u003d protocolToMachineLists.get(protocol);\n     if (acls \u003d\u003d null || hosts \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.isEmpty()) {\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n               conf.get(clientKey), addr);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n                   + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n     if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        acls.length !\u003d 2  || !acls[0].isUserAllowed(user) || acls[1].isUserAllowed(user)) {\n-      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n-          + \", expected client Kerberos principal is \" + clientPrincipal);\n-      throw new AuthorizationException(\"User \" + user + \n-          \" is not authorized for protocol \" + protocol + \n-          \", expected client Kerberos principal is \" + clientPrincipal);\n+      String cause \u003d clientPrincipal !\u003d null ?\n+          \": this service is only accessible by \" + clientPrincipal :\n+          \": denied by configured ACL\";\n+      AUDITLOG.warn(AUTHZ_FAILED_FOR + user\n+          + \" for protocol\u003d\" + protocol + cause);\n+      throw new AuthorizationException(\"User \" + user +\n+          \" is not authorized for protocol \" + protocol + cause);\n     }\n     if (addr !\u003d null) {\n       String hostAddress \u003d addr.getHostAddress();\n       if (hosts.length !\u003d 2 || !hosts[0].includes(hostAddress) ||\n           hosts[1].includes(hostAddress)) {\n         AUDITLOG.warn(AUTHZ_FAILED_FOR + \" for protocol\u003d\" + protocol\n             + \" from host \u003d \" +  hostAddress);\n         throw new AuthorizationException(\"Host \" + hostAddress +\n             \" is not authorized for protocol \" + protocol) ;\n       }\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList[] acls \u003d protocolToAcls.get(protocol);\n    MachineList[] hosts \u003d protocolToMachineLists.get(protocol);\n    if (acls \u003d\u003d null || hosts \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.isEmpty()) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n       acls.length !\u003d 2  || !acls[0].isUserAllowed(user) || acls[1].isUserAllowed(user)) {\n      String cause \u003d clientPrincipal !\u003d null ?\n          \": this service is only accessible by \" + clientPrincipal :\n          \": denied by configured ACL\";\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user\n          + \" for protocol\u003d\" + protocol + cause);\n      throw new AuthorizationException(\"User \" + user +\n          \" is not authorized for protocol \" + protocol + cause);\n    }\n    if (addr !\u003d null) {\n      String hostAddress \u003d addr.getHostAddress();\n      if (hosts.length !\u003d 2 || !hosts[0].includes(hostAddress) ||\n          hosts[1].includes(hostAddress)) {\n        AUDITLOG.warn(AUTHZ_FAILED_FOR + \" for protocol\u003d\" + protocol\n            + \" from host \u003d \" +  hostAddress);\n        throw new AuthorizationException(\"Host \" + hostAddress +\n            \" is not authorized for protocol \" + protocol) ;\n      }\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "20625c8f048701c9516da159b24c0b33983e4bb7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10651. Add ability to restrict service access using IP addresses and hostnames. (Benoy Antony)\n",
      "commitDate": "08/01/15 10:06 AM",
      "commitName": "20625c8f048701c9516da159b24c0b33983e4bb7",
      "commitAuthor": "Benoy Antony",
      "commitDateOld": "17/08/14 10:06 AM",
      "commitNameOld": "c1cd41cc49ad99e733dc6b4e90cf29bb8020be06",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 144.04,
      "commitsBetweenForRepo": 1216,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,49 @@\n   public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                InetAddress addr\n                                ) throws AuthorizationException {\n     AccessControlList[] acls \u003d protocolToAcls.get(protocol);\n-    if (acls \u003d\u003d null) {\n+    MachineList[] hosts \u003d protocolToMachineLists.get(protocol);\n+    if (acls \u003d\u003d null || hosts \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.isEmpty()) {\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n               conf.get(clientKey), addr);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n                   + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n     if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        acls.length !\u003d 2  || !acls[0].isUserAllowed(user) || acls[1].isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n           + \", expected client Kerberos principal is \" + clientPrincipal);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + protocol + \n           \", expected client Kerberos principal is \" + clientPrincipal);\n     }\n+    if (addr !\u003d null) {\n+      String hostAddress \u003d addr.getHostAddress();\n+      if (hosts.length !\u003d 2 || !hosts[0].includes(hostAddress) ||\n+          hosts[1].includes(hostAddress)) {\n+        AUDITLOG.warn(AUTHZ_FAILED_FOR + \" for protocol\u003d\" + protocol\n+            + \" from host \u003d \" +  hostAddress);\n+        throw new AuthorizationException(\"Host \" + hostAddress +\n+            \" is not authorized for protocol \" + protocol) ;\n+      }\n+    }\n     AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList[] acls \u003d protocolToAcls.get(protocol);\n    MachineList[] hosts \u003d protocolToMachineLists.get(protocol);\n    if (acls \u003d\u003d null || hosts \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.isEmpty()) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n       acls.length !\u003d 2  || !acls[0].isUserAllowed(user) || acls[1].isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n          + \", expected client Kerberos principal is \" + clientPrincipal);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + protocol + \n          \", expected client Kerberos principal is \" + clientPrincipal);\n    }\n    if (addr !\u003d null) {\n      String hostAddress \u003d addr.getHostAddress();\n      if (hosts.length !\u003d 2 || !hosts[0].includes(hostAddress) ||\n          hosts[1].includes(hostAddress)) {\n        AUDITLOG.warn(AUTHZ_FAILED_FOR + \" for protocol\u003d\" + protocol\n            + \" from host \u003d \" +  hostAddress);\n        throw new AuthorizationException(\"Host \" + hostAddress +\n            \" is not authorized for protocol \" + protocol) ;\n      }\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "c1cd41cc49ad99e733dc6b4e90cf29bb8020be06": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10650. Add ability to specify a reverse ACL (black list) of users and groups. (Contributed by Benoy Antony)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1618482 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/08/14 10:06 AM",
      "commitName": "c1cd41cc49ad99e733dc6b4e90cf29bb8020be06",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "27/06/14 11:43 AM",
      "commitNameOld": "bbbbd270c7ff0fba55ecd863104ced4c27a8478b",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 50.93,
      "commitsBetweenForRepo": 367,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                InetAddress addr\n                                ) throws AuthorizationException {\n-    AccessControlList acl \u003d protocolToAcl.get(protocol);\n-    if (acl \u003d\u003d null) {\n+    AccessControlList[] acls \u003d protocolToAcls.get(protocol);\n+    if (acls \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.isEmpty()) {\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n               conf.get(clientKey), addr);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n                   + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n     if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n-        !acl.isUserAllowed(user)) {\n+       acls.length !\u003d 2  || !acls[0].isUserAllowed(user) || acls[1].isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n           + \", expected client Kerberos principal is \" + clientPrincipal);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + protocol + \n           \", expected client Kerberos principal is \" + clientPrincipal);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList[] acls \u003d protocolToAcls.get(protocol);\n    if (acls \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.isEmpty()) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n       acls.length !\u003d 2  || !acls[0].isUserAllowed(user) || acls[1].isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n          + \", expected client Kerberos principal is \" + clientPrincipal);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + protocol + \n          \", expected client Kerberos principal is \" + clientPrincipal);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "4c56bccf5ee1d6ec1fcef0804eacae785c4d7c18": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8814. Replace string equals  by String#isEmpty(). Contributed by Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1387853 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/09/12 9:06 PM",
      "commitName": "4c56bccf5ee1d6ec1fcef0804eacae785c4d7c18",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "02/05/12 11:35 PM",
      "commitNameOld": "d94899877709836153244c2f0c5f14c37c9d4795",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 139.9,
      "commitsBetweenForRepo": 747,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                InetAddress addr\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n-      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n+      if (clientKey !\u003d null \u0026\u0026 !clientKey.isEmpty()) {\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n               conf.get(clientKey), addr);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n                   + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n     if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n         !acl.isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n           + \", expected client Kerberos principal is \" + clientPrincipal);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + protocol + \n           \", expected client Kerberos principal is \" + clientPrincipal);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.isEmpty()) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n          + \", expected client Kerberos principal is \" + clientPrincipal);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + protocol + \n          \", expected client Kerberos principal is \" + clientPrincipal);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "d94899877709836153244c2f0c5f14c37c9d4795": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8347. Hadoop Common logs misspell \u0027successful\u0027. Contributed by Philip Zeyliger\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1333321 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/05/12 11:35 PM",
      "commitName": "d94899877709836153244c2f0c5f14c37c9d4795",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 252.26,
      "commitsBetweenForRepo": 1806,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                InetAddress addr\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n               conf.get(clientKey), addr);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n                   + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n     if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n         !acl.isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n           + \", expected client Kerberos principal is \" + clientPrincipal);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + protocol + \n           \", expected client Kerberos principal is \" + clientPrincipal);\n     }\n-    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n+    AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n          + \", expected client Kerberos principal is \" + clientPrincipal);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + protocol + \n          \", expected client Kerberos principal is \" + clientPrincipal);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n          + \", expected client Kerberos principal is \" + clientPrincipal);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + protocol + \n          \", expected client Kerberos principal is \" + clientPrincipal);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n          + \", expected client Kerberos principal is \" + clientPrincipal);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + protocol + \n          \", expected client Kerberos principal is \" + clientPrincipal);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java"
      }
    },
    "85461fb0fa36c82a85b7787162541cdc83e9c237": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7463. Adding a configuration parameter to SecurityInfo interface. (mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1150565 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/07/11 12:48 AM",
      "commitName": "85461fb0fa36c82a85b7787162541cdc83e9c237",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "15/06/11 4:38 PM",
      "commitNameOld": "f5c604f49c5559c402e682e5f15a6e9053ff68cf",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 39.34,
      "commitsBetweenForRepo": 120,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                InetAddress addr\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n-    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol);\n+    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n               conf.get(clientKey), addr);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n                   + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n     if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n         !acl.isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n           + \", expected client Kerberos principal is \" + clientPrincipal);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + protocol + \n           \", expected client Kerberos principal is \" + clientPrincipal);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol, conf);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n          + \", expected client Kerberos principal is \" + clientPrincipal);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + protocol + \n          \", expected client Kerberos principal is \" + clientPrincipal);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "common/src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "f5c604f49c5559c402e682e5f15a6e9053ff68cf": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6929. RPC should have a way to pass Security information other than protocol annotations. (sharad and omalley via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1136249 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/06/11 4:38 PM",
      "commitName": "f5c604f49c5559c402e682e5f15a6e9053ff68cf",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "12/06/11 3:00 PM",
      "commitNameOld": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 3.07,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                InetAddress addr\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n-    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n+    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n               conf.get(clientKey), addr);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n                   + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n     if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n         !acl.isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n           + \", expected client Kerberos principal is \" + clientPrincipal);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + protocol + \n           \", expected client Kerberos principal is \" + clientPrincipal);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d SecurityUtil.getKerberosInfo(protocol);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n          + \", expected client Kerberos principal is \" + clientPrincipal);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + protocol + \n          \", expected client Kerberos principal is \" + clientPrincipal);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "common/src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n          + \", expected client Kerberos principal is \" + clientPrincipal);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + protocol + \n          \", expected client Kerberos principal is \" + clientPrincipal);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "common/src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
        "newPath": "common/src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java"
      }
    },
    "c3fdd289cf26fa3bb9c0d2d9f906eba769ddd789": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-7104. Remove unnecessary DNS reverse lookups from RPC layer. Contributed by Kan Zhang\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1059235 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/01/11 6:40 PM",
      "commitName": "c3fdd289cf26fa3bb9c0d2d9f906eba769ddd789",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-7104. Remove unnecessary DNS reverse lookups from RPC layer. Contributed by Kan Zhang\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1059235 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "14/01/11 6:40 PM",
          "commitName": "c3fdd289cf26fa3bb9c0d2d9f906eba769ddd789",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "29/09/10 4:49 PM",
          "commitNameOld": "642ed17a4808e36f1458546cc66d52e212cc5acf",
          "commitAuthorOld": "Thomas White",
          "daysBetweenCommits": 107.12,
          "commitsBetweenForRepo": 92,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,38 @@\n   public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n-                               String hostname\n+                               InetAddress addr\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n-        if (hostname \u003d\u003d null) {\n-          throw new AuthorizationException(\n-              \"Can\u0027t authorize client when client hostname is null\");\n-        }\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n-              conf.get(clientKey), hostname);\n+              conf.get(clientKey), addr);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n-                  + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n+                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n-    // when authorizing use the short name only\n-    String shortName \u003d clientPrincipal;\n-    if(clientPrincipal !\u003d null ) {\n-      try {\n-        shortName \u003d new KerberosName(clientPrincipal).getShortName();\n-      } catch (IOException e) {\n-        LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n-        // just keep going\n-      }\n-    }\n-    if(LOG.isDebugEnabled()) {\n-      LOG.debug(\"for protocol authorization compare (\" + clientPrincipal +\n-          \"): \" + shortName + \" with \" + user.getShortUserName());\n-    }\n-    if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n+    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n         !acl.isUserAllowed(user)) {\n-      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n+      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n+          + \", expected client Kerberos principal is \" + clientPrincipal);\n       throw new AuthorizationException(\"User \" + user + \n-          \" is not authorized for protocol \" + \n-          protocol);\n+          \" is not authorized for protocol \" + protocol + \n+          \", expected client Kerberos principal is \" + clientPrincipal);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n          + \", expected client Kerberos principal is \" + clientPrincipal);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + protocol + \n          \", expected client Kerberos principal is \" + clientPrincipal);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
          "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
          "extendedDetails": {
            "oldValue": "[user-UserGroupInformation, protocol-Class\u003c?\u003e, conf-Configuration, hostname-String]",
            "newValue": "[user-UserGroupInformation, protocol-Class\u003c?\u003e, conf-Configuration, addr-InetAddress]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-7104. Remove unnecessary DNS reverse lookups from RPC layer. Contributed by Kan Zhang\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1059235 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "14/01/11 6:40 PM",
          "commitName": "c3fdd289cf26fa3bb9c0d2d9f906eba769ddd789",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "29/09/10 4:49 PM",
          "commitNameOld": "642ed17a4808e36f1458546cc66d52e212cc5acf",
          "commitAuthorOld": "Thomas White",
          "daysBetweenCommits": 107.12,
          "commitsBetweenForRepo": 92,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,38 @@\n   public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n-                               String hostname\n+                               InetAddress addr\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n-        if (hostname \u003d\u003d null) {\n-          throw new AuthorizationException(\n-              \"Can\u0027t authorize client when client hostname is null\");\n-        }\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n-              conf.get(clientKey), hostname);\n+              conf.get(clientKey), addr);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n-                  + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n+                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n-    // when authorizing use the short name only\n-    String shortName \u003d clientPrincipal;\n-    if(clientPrincipal !\u003d null ) {\n-      try {\n-        shortName \u003d new KerberosName(clientPrincipal).getShortName();\n-      } catch (IOException e) {\n-        LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n-        // just keep going\n-      }\n-    }\n-    if(LOG.isDebugEnabled()) {\n-      LOG.debug(\"for protocol authorization compare (\" + clientPrincipal +\n-          \"): \" + shortName + \" with \" + user.getShortUserName());\n-    }\n-    if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n+    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n         !acl.isUserAllowed(user)) {\n-      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n+      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n+          + \", expected client Kerberos principal is \" + clientPrincipal);\n       throw new AuthorizationException(\"User \" + user + \n-          \" is not authorized for protocol \" + \n-          protocol);\n+          \" is not authorized for protocol \" + protocol + \n+          \", expected client Kerberos principal is \" + clientPrincipal);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               InetAddress addr\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), addr);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + addr + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\" + protocol\n          + \", expected client Kerberos principal is \" + clientPrincipal);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + protocol + \n          \", expected client Kerberos principal is \" + clientPrincipal);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
          "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "642ed17a4808e36f1458546cc66d52e212cc5acf": {
      "type": "Ymodifierchange",
      "commitMessage": "HADOOP-6951.  Distinct minicluster services (e.g. NN and JT) overwrite each other\u0027s service policies.  Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1002896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/09/10 4:49 PM",
      "commitName": "642ed17a4808e36f1458546cc66d52e212cc5acf",
      "commitAuthor": "Thomas White",
      "commitDateOld": "24/09/10 7:41 PM",
      "commitNameOld": "47d4ebebaca1d023342a93bc87dedbb00a60b2fa",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 4.88,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n-  public static void authorize(UserGroupInformation user, \n+  public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                String hostname\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n         if (hostname \u003d\u003d null) {\n           throw new AuthorizationException(\n               \"Can\u0027t authorize client when client hostname is null\");\n         }\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n               conf.get(clientKey), hostname);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n                   + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n     // when authorizing use the short name only\n     String shortName \u003d clientPrincipal;\n     if(clientPrincipal !\u003d null ) {\n       try {\n         shortName \u003d new KerberosName(clientPrincipal).getShortName();\n       } catch (IOException e) {\n         LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n         // just keep going\n       }\n     }\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"for protocol authorization compare (\" + clientPrincipal +\n           \"): \" + shortName + \" with \" + user.getShortUserName());\n     }\n     if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n         !acl.isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + \n           protocol);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               String hostname\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        if (hostname \u003d\u003d null) {\n          throw new AuthorizationException(\n              \"Can\u0027t authorize client when client hostname is null\");\n        }\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), hostname);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    // when authorizing use the short name only\n    String shortName \u003d clientPrincipal;\n    if(clientPrincipal !\u003d null ) {\n      try {\n        shortName \u003d new KerberosName(clientPrincipal).getShortName();\n      } catch (IOException e) {\n        LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n        // just keep going\n      }\n    }\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"for protocol authorization compare (\" + clientPrincipal +\n          \"): \" + shortName + \" with \" + user.getShortUserName());\n    }\n    if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + \n          protocol);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {
        "oldValue": "[public, static]",
        "newValue": "[public]"
      }
    },
    "47d4ebebaca1d023342a93bc87dedbb00a60b2fa": {
      "type": "Ymodifierchange",
      "commitMessage": "Reverting commit 1001067 while related HDFS and MR JIRAs are tested (HADOOP-6951).\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1001127 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/09/10 7:41 PM",
      "commitName": "47d4ebebaca1d023342a93bc87dedbb00a60b2fa",
      "commitAuthor": "Thomas White",
      "commitDateOld": "24/09/10 1:48 PM",
      "commitNameOld": "0fd49b35370e3c0c72abaf2007d34d4207347693",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n-  public void authorize(UserGroupInformation user, \n+  public static void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                String hostname\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n         if (hostname \u003d\u003d null) {\n           throw new AuthorizationException(\n               \"Can\u0027t authorize client when client hostname is null\");\n         }\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n               conf.get(clientKey), hostname);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n                   + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n     // when authorizing use the short name only\n     String shortName \u003d clientPrincipal;\n     if(clientPrincipal !\u003d null ) {\n       try {\n         shortName \u003d new KerberosName(clientPrincipal).getShortName();\n       } catch (IOException e) {\n         LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n         // just keep going\n       }\n     }\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"for protocol authorization compare (\" + clientPrincipal +\n           \"): \" + shortName + \" with \" + user.getShortUserName());\n     }\n     if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n         !acl.isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + \n           protocol);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               String hostname\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        if (hostname \u003d\u003d null) {\n          throw new AuthorizationException(\n              \"Can\u0027t authorize client when client hostname is null\");\n        }\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), hostname);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    // when authorizing use the short name only\n    String shortName \u003d clientPrincipal;\n    if(clientPrincipal !\u003d null ) {\n      try {\n        shortName \u003d new KerberosName(clientPrincipal).getShortName();\n      } catch (IOException e) {\n        LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n        // just keep going\n      }\n    }\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"for protocol authorization compare (\" + clientPrincipal +\n          \"): \" + shortName + \" with \" + user.getShortUserName());\n    }\n    if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + \n          protocol);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[public, static]"
      }
    },
    "0fd49b35370e3c0c72abaf2007d34d4207347693": {
      "type": "Ymodifierchange",
      "commitMessage": "HADOOP-6951. Distinct minicluster services (e.g. NN and JT) overwrite each other\u0027s service policies. Contributed by Aaron T. Myers\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1001067 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/09/10 1:48 PM",
      "commitName": "0fd49b35370e3c0c72abaf2007d34d4207347693",
      "commitAuthor": "Thomas White",
      "commitDateOld": "28/08/10 3:44 PM",
      "commitNameOld": "7efb9640be26aabe3878310e82248a1b6b767a9a",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 26.92,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n-  public static void authorize(UserGroupInformation user, \n+  public void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                String hostname\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n         if (hostname \u003d\u003d null) {\n           throw new AuthorizationException(\n               \"Can\u0027t authorize client when client hostname is null\");\n         }\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n               conf.get(clientKey), hostname);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n                   + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n     // when authorizing use the short name only\n     String shortName \u003d clientPrincipal;\n     if(clientPrincipal !\u003d null ) {\n       try {\n         shortName \u003d new KerberosName(clientPrincipal).getShortName();\n       } catch (IOException e) {\n         LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n         // just keep going\n       }\n     }\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"for protocol authorization compare (\" + clientPrincipal +\n           \"): \" + shortName + \" with \" + user.getShortUserName());\n     }\n     if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n         !acl.isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + \n           protocol);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               String hostname\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        if (hostname \u003d\u003d null) {\n          throw new AuthorizationException(\n              \"Can\u0027t authorize client when client hostname is null\");\n        }\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), hostname);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    // when authorizing use the short name only\n    String shortName \u003d clientPrincipal;\n    if(clientPrincipal !\u003d null ) {\n      try {\n        shortName \u003d new KerberosName(clientPrincipal).getShortName();\n      } catch (IOException e) {\n        LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n        // just keep going\n      }\n    }\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"for protocol authorization compare (\" + clientPrincipal +\n          \"): \" + shortName + \" with \" + user.getShortUserName());\n    }\n    if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + \n          protocol);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {
        "oldValue": "[public, static]",
        "newValue": "[public]"
      }
    },
    "7efb9640be26aabe3878310e82248a1b6b767a9a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6884. Add LOG.isDebugEnabled() guard for each LOG.debug(..).  Contributed by Erik Steffl\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@990460 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/08/10 3:44 PM",
      "commitName": "7efb9640be26aabe3878310e82248a1b6b767a9a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "19/07/10 5:46 PM",
      "commitNameOld": "fa3a3bf5d8f3167f9725a3f91a0f4ae0481f24ea",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 39.92,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,55 @@\n   public static void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf,\n                                String hostname\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n         if (hostname \u003d\u003d null) {\n           throw new AuthorizationException(\n               \"Can\u0027t authorize client when client hostname is null\");\n         }\n         try {\n           clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n               conf.get(clientKey), hostname);\n         } catch (IOException e) {\n           throw (AuthorizationException) new AuthorizationException(\n               \"Can\u0027t figure out Kerberos principal name for connection from \"\n                   + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n               .initCause(e);\n         }\n       }\n     }\n     // when authorizing use the short name only\n     String shortName \u003d clientPrincipal;\n     if(clientPrincipal !\u003d null ) {\n       try {\n         shortName \u003d new KerberosName(clientPrincipal).getShortName();\n       } catch (IOException e) {\n         LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n         // just keep going\n       }\n     }\n-    LOG.debug(\"for protocol authorization compare (\" + clientPrincipal + \"): \" \n-        + shortName + \" with \" + user.getShortUserName());\n+    if(LOG.isDebugEnabled()) {\n+      LOG.debug(\"for protocol authorization compare (\" + clientPrincipal +\n+          \"): \" + shortName + \" with \" + user.getShortUserName());\n+    }\n     if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n         !acl.isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + \n           protocol);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               String hostname\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        if (hostname \u003d\u003d null) {\n          throw new AuthorizationException(\n              \"Can\u0027t authorize client when client hostname is null\");\n        }\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), hostname);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    // when authorizing use the short name only\n    String shortName \u003d clientPrincipal;\n    if(clientPrincipal !\u003d null ) {\n      try {\n        shortName \u003d new KerberosName(clientPrincipal).getShortName();\n      } catch (IOException e) {\n        LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n        // just keep going\n      }\n    }\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"for protocol authorization compare (\" + clientPrincipal +\n          \"): \" + shortName + \" with \" + user.getShortUserName());\n    }\n    if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + \n          protocol);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "fa3a3bf5d8f3167f9725a3f91a0f4ae0481f24ea": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-6632. Adds support for using different keytabs for different servers in a Hadoop cluster. In the earier implementation, all servers of a certain type \\(like TaskTracker\\), would have the same keytab and the same principal. Now the principal name is a pattern that has _HOST in it. Contributed by Kan Zhang \u0026 Jitendra Pandey.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@965696 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/07/10 5:46 PM",
      "commitName": "fa3a3bf5d8f3167f9725a3f91a0f4ae0481f24ea",
      "commitAuthor": "Devaraj Das",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-6632. Adds support for using different keytabs for different servers in a Hadoop cluster. In the earier implementation, all servers of a certain type \\(like TaskTracker\\), would have the same keytab and the same principal. Now the principal name is a pattern that has _HOST in it. Contributed by Kan Zhang \u0026 Jitendra Pandey.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@965696 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/07/10 5:46 PM",
          "commitName": "fa3a3bf5d8f3167f9725a3f91a0f4ae0481f24ea",
          "commitAuthor": "Devaraj Das",
          "commitDateOld": "12/07/10 2:18 PM",
          "commitNameOld": "6ba9b70d85a89f1a28c5b159ad553ab6ffef80b2",
          "commitAuthorOld": "Boris Shkolnik",
          "daysBetweenCommits": 7.14,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,53 @@\n   public static void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n-                               Configuration conf\n+                               Configuration conf,\n+                               String hostname\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n-        clientPrincipal \u003d conf.get(clientKey);\n+        if (hostname \u003d\u003d null) {\n+          throw new AuthorizationException(\n+              \"Can\u0027t authorize client when client hostname is null\");\n+        }\n+        try {\n+          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n+              conf.get(clientKey), hostname);\n+        } catch (IOException e) {\n+          throw (AuthorizationException) new AuthorizationException(\n+              \"Can\u0027t figure out Kerberos principal name for connection from \"\n+                  + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n+              .initCause(e);\n+        }\n       }\n     }\n     // when authorizing use the short name only\n     String shortName \u003d clientPrincipal;\n     if(clientPrincipal !\u003d null ) {\n       try {\n         shortName \u003d new KerberosName(clientPrincipal).getShortName();\n       } catch (IOException e) {\n         LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n         // just keep going\n       }\n     }\n     LOG.debug(\"for protocol authorization compare (\" + clientPrincipal + \"): \" \n         + shortName + \" with \" + user.getShortUserName());\n     if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n         !acl.isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + \n           protocol);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               String hostname\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        if (hostname \u003d\u003d null) {\n          throw new AuthorizationException(\n              \"Can\u0027t authorize client when client hostname is null\");\n        }\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), hostname);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    // when authorizing use the short name only\n    String shortName \u003d clientPrincipal;\n    if(clientPrincipal !\u003d null ) {\n      try {\n        shortName \u003d new KerberosName(clientPrincipal).getShortName();\n      } catch (IOException e) {\n        LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n        // just keep going\n      }\n    }\n    LOG.debug(\"for protocol authorization compare (\" + clientPrincipal + \"): \" \n        + shortName + \" with \" + user.getShortUserName());\n    if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + \n          protocol);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
          "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
          "extendedDetails": {
            "oldValue": "[user-UserGroupInformation, protocol-Class\u003c?\u003e, conf-Configuration]",
            "newValue": "[user-UserGroupInformation, protocol-Class\u003c?\u003e, conf-Configuration, hostname-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-6632. Adds support for using different keytabs for different servers in a Hadoop cluster. In the earier implementation, all servers of a certain type \\(like TaskTracker\\), would have the same keytab and the same principal. Now the principal name is a pattern that has _HOST in it. Contributed by Kan Zhang \u0026 Jitendra Pandey.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@965696 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/07/10 5:46 PM",
          "commitName": "fa3a3bf5d8f3167f9725a3f91a0f4ae0481f24ea",
          "commitAuthor": "Devaraj Das",
          "commitDateOld": "12/07/10 2:18 PM",
          "commitNameOld": "6ba9b70d85a89f1a28c5b159ad553ab6ffef80b2",
          "commitAuthorOld": "Boris Shkolnik",
          "daysBetweenCommits": 7.14,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,53 @@\n   public static void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n-                               Configuration conf\n+                               Configuration conf,\n+                               String hostname\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n-        clientPrincipal \u003d conf.get(clientKey);\n+        if (hostname \u003d\u003d null) {\n+          throw new AuthorizationException(\n+              \"Can\u0027t authorize client when client hostname is null\");\n+        }\n+        try {\n+          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n+              conf.get(clientKey), hostname);\n+        } catch (IOException e) {\n+          throw (AuthorizationException) new AuthorizationException(\n+              \"Can\u0027t figure out Kerberos principal name for connection from \"\n+                  + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n+              .initCause(e);\n+        }\n       }\n     }\n     // when authorizing use the short name only\n     String shortName \u003d clientPrincipal;\n     if(clientPrincipal !\u003d null ) {\n       try {\n         shortName \u003d new KerberosName(clientPrincipal).getShortName();\n       } catch (IOException e) {\n         LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n         // just keep going\n       }\n     }\n     LOG.debug(\"for protocol authorization compare (\" + clientPrincipal + \"): \" \n         + shortName + \" with \" + user.getShortUserName());\n     if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n         !acl.isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + \n           protocol);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf,\n                               String hostname\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        if (hostname \u003d\u003d null) {\n          throw new AuthorizationException(\n              \"Can\u0027t authorize client when client hostname is null\");\n        }\n        try {\n          clientPrincipal \u003d SecurityUtil.getServerPrincipal(\n              conf.get(clientKey), hostname);\n        } catch (IOException e) {\n          throw (AuthorizationException) new AuthorizationException(\n              \"Can\u0027t figure out Kerberos principal name for connection from \"\n                  + hostname + \" for user\u003d\" + user + \" protocol\u003d\" + protocol)\n              .initCause(e);\n        }\n      }\n    }\n    // when authorizing use the short name only\n    String shortName \u003d clientPrincipal;\n    if(clientPrincipal !\u003d null ) {\n      try {\n        shortName \u003d new KerberosName(clientPrincipal).getShortName();\n      } catch (IOException e) {\n        LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n        // just keep going\n      }\n    }\n    LOG.debug(\"for protocol authorization compare (\" + clientPrincipal + \"): \" \n        + shortName + \" with \" + user.getShortUserName());\n    if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + \n          protocol);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
          "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "6ba9b70d85a89f1a28c5b159ad553ab6ffef80b2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6647. balancer fails with \"is not authorized for protocol interface NamenodeProtocol\" in secure environment\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@963490 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/10 2:18 PM",
      "commitName": "6ba9b70d85a89f1a28c5b159ad553ab6ffef80b2",
      "commitAuthor": "Boris Shkolnik",
      "commitDateOld": "09/07/10 1:07 PM",
      "commitNameOld": "d2ade6aec54681270ac6f741a04414911c73f61d",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 3.05,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,40 @@\n   public static void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n         clientPrincipal \u003d conf.get(clientKey);\n       }\n     }\n-    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n+    // when authorizing use the short name only\n+    String shortName \u003d clientPrincipal;\n+    if(clientPrincipal !\u003d null ) {\n+      try {\n+        shortName \u003d new KerberosName(clientPrincipal).getShortName();\n+      } catch (IOException e) {\n+        LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n+        // just keep going\n+      }\n+    }\n+    LOG.debug(\"for protocol authorization compare (\" + clientPrincipal + \"): \" \n+        + shortName + \" with \" + user.getShortUserName());\n+    if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n         !acl.isUserAllowed(user)) {\n       AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + \n           protocol);\n     }\n     AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        clientPrincipal \u003d conf.get(clientKey);\n      }\n    }\n    // when authorizing use the short name only\n    String shortName \u003d clientPrincipal;\n    if(clientPrincipal !\u003d null ) {\n      try {\n        shortName \u003d new KerberosName(clientPrincipal).getShortName();\n      } catch (IOException e) {\n        LOG.warn(\"couldn\u0027t get short name from \" + clientPrincipal, e);\n        // just keep going\n      }\n    }\n    LOG.debug(\"for protocol authorization compare (\" + clientPrincipal + \"): \" \n        + shortName + \" with \" + user.getShortUserName());\n    if((shortName !\u003d null \u0026\u0026  !shortName.equals(user.getShortUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + \n          protocol);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "e346c2f4e08a38a80c7f505d8a8f3554b408e997": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6644. util.Shell getGROUPS_FOR_USER_COMMAND method name - should use common naming convention\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@948528 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/05/10 11:35 AM",
      "commitName": "e346c2f4e08a38a80c7f505d8a8f3554b408e997",
      "commitAuthor": "Boris Shkolnik",
      "commitDateOld": "13/05/10 1:52 PM",
      "commitNameOld": "d9b6103f8f63f66c254a7bd3a423a2a5fb6672e3",
      "commitAuthorOld": "Boris Shkolnik",
      "daysBetweenCommits": 12.9,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n   public static void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol,\n                                Configuration conf\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     \n     // get client principal key to verify (if available)\n     KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n     String clientPrincipal \u003d null; \n     if (krbInfo !\u003d null) {\n       String clientKey \u003d krbInfo.clientPrincipal();\n       if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n         clientPrincipal \u003d conf.get(clientKey);\n       }\n     }\n     if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n         !acl.isUserAllowed(user)) {\n-      auditLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n+      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n       throw new AuthorizationException(\"User \" + user + \n           \" is not authorized for protocol \" + \n           protocol);\n     }\n-    auditLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n+    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        clientPrincipal \u003d conf.get(clientKey);\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      AUDITLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + \n          protocol);\n    }\n    AUDITLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "d9b6103f8f63f66c254a7bd3a423a2a5fb6672e3": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-6600. mechanism for authorization check for inter-server protocols\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@944012 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/10 1:52 PM",
      "commitName": "d9b6103f8f63f66c254a7bd3a423a2a5fb6672e3",
      "commitAuthor": "Boris Shkolnik",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-6600. mechanism for authorization check for inter-server protocols\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@944012 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/05/10 1:52 PM",
          "commitName": "d9b6103f8f63f66c254a7bd3a423a2a5fb6672e3",
          "commitAuthor": "Boris Shkolnik",
          "commitDateOld": "26/02/10 10:35 AM",
          "commitNameOld": "c4c122a0def592136e03a653c9fdc4f464ed0854",
          "commitAuthorOld": "Boris Shkolnik",
          "daysBetweenCommits": 76.1,
          "commitsBetweenForRepo": 68,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,28 @@\n   public static void authorize(UserGroupInformation user, \n-                               Class\u003c?\u003e protocol\n+                               Class\u003c?\u003e protocol,\n+                               Configuration conf\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n-    if (!acl.isUserAllowed(user)) {\n+    \n+    // get client principal key to verify (if available)\n+    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n+    String clientPrincipal \u003d null; \n+    if (krbInfo !\u003d null) {\n+      String clientKey \u003d krbInfo.clientPrincipal();\n+      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n+        clientPrincipal \u003d conf.get(clientKey);\n+      }\n+    }\n+    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n+        !acl.isUserAllowed(user)) {\n       auditLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n       throw new AuthorizationException(\"User \" + user + \n-                                       \" is not authorized for protocol \" + \n-                                       protocol);\n+          \" is not authorized for protocol \" + \n+          protocol);\n     }\n     auditLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        clientPrincipal \u003d conf.get(clientKey);\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      auditLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + \n          protocol);\n    }\n    auditLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
          "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
          "extendedDetails": {
            "oldValue": "[user-UserGroupInformation, protocol-Class\u003c?\u003e]",
            "newValue": "[user-UserGroupInformation, protocol-Class\u003c?\u003e, conf-Configuration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-6600. mechanism for authorization check for inter-server protocols\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@944012 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/05/10 1:52 PM",
          "commitName": "d9b6103f8f63f66c254a7bd3a423a2a5fb6672e3",
          "commitAuthor": "Boris Shkolnik",
          "commitDateOld": "26/02/10 10:35 AM",
          "commitNameOld": "c4c122a0def592136e03a653c9fdc4f464ed0854",
          "commitAuthorOld": "Boris Shkolnik",
          "daysBetweenCommits": 76.1,
          "commitsBetweenForRepo": 68,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,28 @@\n   public static void authorize(UserGroupInformation user, \n-                               Class\u003c?\u003e protocol\n+                               Class\u003c?\u003e protocol,\n+                               Configuration conf\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n-    if (!acl.isUserAllowed(user)) {\n+    \n+    // get client principal key to verify (if available)\n+    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n+    String clientPrincipal \u003d null; \n+    if (krbInfo !\u003d null) {\n+      String clientKey \u003d krbInfo.clientPrincipal();\n+      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n+        clientPrincipal \u003d conf.get(clientKey);\n+      }\n+    }\n+    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n+        !acl.isUserAllowed(user)) {\n       auditLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n       throw new AuthorizationException(\"User \" + user + \n-                                       \" is not authorized for protocol \" + \n-                                       protocol);\n+          \" is not authorized for protocol \" + \n+          protocol);\n     }\n     auditLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol,\n                               Configuration conf\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    \n    // get client principal key to verify (if available)\n    KerberosInfo krbInfo \u003d protocol.getAnnotation(KerberosInfo.class);\n    String clientPrincipal \u003d null; \n    if (krbInfo !\u003d null) {\n      String clientKey \u003d krbInfo.clientPrincipal();\n      if (clientKey !\u003d null \u0026\u0026 !clientKey.equals(\"\")) {\n        clientPrincipal \u003d conf.get(clientKey);\n      }\n    }\n    if((clientPrincipal !\u003d null \u0026\u0026 !clientPrincipal.equals(user.getUserName())) || \n        !acl.isUserAllowed(user)) {\n      auditLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n      throw new AuthorizationException(\"User \" + user + \n          \" is not authorized for protocol \" + \n          protocol);\n    }\n    auditLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
          "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "c4c122a0def592136e03a653c9fdc4f464ed0854": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6586. Log authentication and authorization failures and successes for RPC\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@916779 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/02/10 10:35 AM",
      "commitName": "c4c122a0def592136e03a653c9fdc4f464ed0854",
      "commitAuthor": "Boris Shkolnik",
      "commitDateOld": "25/02/10 1:39 PM",
      "commitNameOld": "7785232da5a1db2d06f5d208ce3258c342a4d19c",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,14 +1,16 @@\n   public static void authorize(UserGroupInformation user, \n                                Class\u003c?\u003e protocol\n                                ) throws AuthorizationException {\n     AccessControlList acl \u003d protocolToAcl.get(protocol);\n     if (acl \u003d\u003d null) {\n       throw new AuthorizationException(\"Protocol \" + protocol + \n                                        \" is not known.\");\n     }\n     if (!acl.isUserAllowed(user)) {\n-      throw new AuthorizationException(\"User \" + user.toString() + \n+      auditLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n+      throw new AuthorizationException(\"User \" + user + \n                                        \" is not authorized for protocol \" + \n                                        protocol);\n     }\n+    auditLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    if (!acl.isUserAllowed(user)) {\n      auditLOG.warn(AUTHZ_FAILED_FOR + user + \" for protocol\u003d\"+protocol);\n      throw new AuthorizationException(\"User \" + user + \n                                       \" is not authorized for protocol \" + \n                                       protocol);\n    }\n    auditLOG.info(AUTHZ_SUCCESSFULL_FOR + user + \" for protocol\u003d\"+protocol);\n  }",
      "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
      "extendedDetails": {}
    },
    "0c5734e4aca873f405fbf994e5fe7061e31731c8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-6299. Reimplement the UserGroupInformation to use the OS\nspecific and Kerberos JAAS login. (omalley)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@903560 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/01/10 12:08 AM",
      "commitName": "0c5734e4aca873f405fbf994e5fe7061e31731c8",
      "commitAuthor": "Owen O\u0027Malley",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-6299. Reimplement the UserGroupInformation to use the OS\nspecific and Kerberos JAAS login. (omalley)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@903560 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/01/10 12:08 AM",
          "commitName": "0c5734e4aca873f405fbf994e5fe7061e31731c8",
          "commitAuthor": "Owen O\u0027Malley",
          "commitDateOld": "18/05/09 9:20 PM",
          "commitNameOld": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
          "commitAuthorOld": "Owen O\u0027Malley",
          "daysBetweenCommits": 253.16,
          "commitsBetweenForRepo": 225,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,10 +1,14 @@\n-  public static void authorize(Subject user, Class\u003c?\u003e protocol) \n-  throws AuthorizationException {\n-    Permission permission \u003d protocolToPermissionMap.get(protocol);\n-    if (permission \u003d\u003d null) {\n-      permission \u003d new ConnectionPermission(protocol);\n-      protocolToPermissionMap.put(protocol, permission);\n+  public static void authorize(UserGroupInformation user, \n+                               Class\u003c?\u003e protocol\n+                               ) throws AuthorizationException {\n+    AccessControlList acl \u003d protocolToAcl.get(protocol);\n+    if (acl \u003d\u003d null) {\n+      throw new AuthorizationException(\"Protocol \" + protocol + \n+                                       \" is not known.\");\n     }\n-    \n-    checkPermission(user, permission);\n+    if (!acl.isUserAllowed(user)) {\n+      throw new AuthorizationException(\"User \" + user.toString() + \n+                                       \" is not authorized for protocol \" + \n+                                       protocol);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    if (!acl.isUserAllowed(user)) {\n      throw new AuthorizationException(\"User \" + user.toString() + \n                                       \" is not authorized for protocol \" + \n                                       protocol);\n    }\n  }",
          "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
          "extendedDetails": {
            "oldValue": "[user-Subject, protocol-Class\u003c?\u003e]",
            "newValue": "[user-UserGroupInformation, protocol-Class\u003c?\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-6299. Reimplement the UserGroupInformation to use the OS\nspecific and Kerberos JAAS login. (omalley)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@903560 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/01/10 12:08 AM",
          "commitName": "0c5734e4aca873f405fbf994e5fe7061e31731c8",
          "commitAuthor": "Owen O\u0027Malley",
          "commitDateOld": "18/05/09 9:20 PM",
          "commitNameOld": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
          "commitAuthorOld": "Owen O\u0027Malley",
          "daysBetweenCommits": 253.16,
          "commitsBetweenForRepo": 225,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,10 +1,14 @@\n-  public static void authorize(Subject user, Class\u003c?\u003e protocol) \n-  throws AuthorizationException {\n-    Permission permission \u003d protocolToPermissionMap.get(protocol);\n-    if (permission \u003d\u003d null) {\n-      permission \u003d new ConnectionPermission(protocol);\n-      protocolToPermissionMap.put(protocol, permission);\n+  public static void authorize(UserGroupInformation user, \n+                               Class\u003c?\u003e protocol\n+                               ) throws AuthorizationException {\n+    AccessControlList acl \u003d protocolToAcl.get(protocol);\n+    if (acl \u003d\u003d null) {\n+      throw new AuthorizationException(\"Protocol \" + protocol + \n+                                       \" is not known.\");\n     }\n-    \n-    checkPermission(user, permission);\n+    if (!acl.isUserAllowed(user)) {\n+      throw new AuthorizationException(\"User \" + user.toString() + \n+                                       \" is not authorized for protocol \" + \n+                                       protocol);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void authorize(UserGroupInformation user, \n                               Class\u003c?\u003e protocol\n                               ) throws AuthorizationException {\n    AccessControlList acl \u003d protocolToAcl.get(protocol);\n    if (acl \u003d\u003d null) {\n      throw new AuthorizationException(\"Protocol \" + protocol + \n                                       \" is not known.\");\n    }\n    if (!acl.isUserAllowed(user)) {\n      throw new AuthorizationException(\"User \" + user.toString() + \n                                       \" is not authorized for protocol \" + \n                                       protocol);\n    }\n  }",
          "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,10 @@\n+  public static void authorize(Subject user, Class\u003c?\u003e protocol) \n+  throws AuthorizationException {\n+    Permission permission \u003d protocolToPermissionMap.get(protocol);\n+    if (permission \u003d\u003d null) {\n+      permission \u003d new ConnectionPermission(protocol);\n+      protocolToPermissionMap.put(protocol, permission);\n+    }\n+    \n+    checkPermission(user, permission);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static void authorize(Subject user, Class\u003c?\u003e protocol) \n  throws AuthorizationException {\n    Permission permission \u003d protocolToPermissionMap.get(protocol);\n    if (permission \u003d\u003d null) {\n      permission \u003d new ConnectionPermission(protocol);\n      protocolToPermissionMap.put(protocol, permission);\n    }\n    \n    checkPermission(user, permission);\n  }",
      "path": "src/java/org/apache/hadoop/security/authorize/ServiceAuthorizationManager.java"
    }
  }
}