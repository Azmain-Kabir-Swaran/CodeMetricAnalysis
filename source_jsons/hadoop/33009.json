{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AppLogAggregatorImpl.java",
  "functionName": "uploadLogsForContainers",
  "functionId": "uploadLogsForContainers___appFinished-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
  "functionStartLine": 275,
  "functionEndLine": 411,
  "numCommitsSeen": 82,
  "timeTaken": 15875,
  "changeHistory": [
    "2a05e0ff3b5ab3be8654e9e96c6556865ef26096",
    "c89bdfacc8715fa6d72acd85437ab8cd257c8aad",
    "54ac80176e8487b7a18cd9e16a11efa289d0b7df",
    "b22f56c4719e63bd4f6edc2a075e0bcdb9442255",
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
    "547f18cb96aeda55cc19b38be2be4d631b3a5f4f",
    "1b081ca27e05e97d8b7d284ca24200d43763e481",
    "5dfc38ff57669cba9078146e91ed990a1d25a3f0",
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa",
    "948b75807068c304ffe789e32f2b850c0d653e0a",
    "7f3139e54da2c496327446a5eac43f8421fc8839",
    "8c1cdb17a03fec91bfab172fe92b67bdeb9ebfba",
    "37e1c3d82a96d781e1c9982988b7de4aa5242d0c",
    "b5cdf78e8e6cd6c5c1fb7286207dac72be32c0d6",
    "03a293aed6de101b0cae1a294f506903addcaa75",
    "15ccd967ee3e7046a50522089f67ba01f36ec76a",
    "1db355a875c3ecc40a244045c6812e00c8d36ef1",
    "92431c961741747b5d6442f4025016d48d9a6863",
    "d81109e588493cef31e68508a3d671203bd23e12",
    "863079bb874ba77918ca1c0741eae10e245995c8",
    "f56c65bb3eb9436b67de2df63098e26589e70e56",
    "be7bf956e96dd0fd9b521ca71df9124b9cc5ebd0",
    "5c0381c96aa79196829edbca497c649eb6776944",
    "cb81bac0029fce3a9726df3523f0b692cd3375b8",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
    "5420f287ccc83df69b6725942754c82b89e46b3e",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "2a05e0ff3b5ab3be8654e9e96c6556865ef26096": "Ybodychange",
    "c89bdfacc8715fa6d72acd85437ab8cd257c8aad": "Ybodychange",
    "54ac80176e8487b7a18cd9e16a11efa289d0b7df": "Ybodychange",
    "b22f56c4719e63bd4f6edc2a075e0bcdb9442255": "Ymultichange(Yexceptionschange,Ybodychange)",
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f": "Ybodychange",
    "547f18cb96aeda55cc19b38be2be4d631b3a5f4f": "Ybodychange",
    "1b081ca27e05e97d8b7d284ca24200d43763e481": "Ybodychange",
    "5dfc38ff57669cba9078146e91ed990a1d25a3f0": "Ybodychange",
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa": "Ybodychange",
    "948b75807068c304ffe789e32f2b850c0d653e0a": "Ybodychange",
    "7f3139e54da2c496327446a5eac43f8421fc8839": "Ybodychange",
    "8c1cdb17a03fec91bfab172fe92b67bdeb9ebfba": "Ybodychange",
    "37e1c3d82a96d781e1c9982988b7de4aa5242d0c": "Ybodychange",
    "b5cdf78e8e6cd6c5c1fb7286207dac72be32c0d6": "Ybodychange",
    "03a293aed6de101b0cae1a294f506903addcaa75": "Ybodychange",
    "15ccd967ee3e7046a50522089f67ba01f36ec76a": "Ybodychange",
    "1db355a875c3ecc40a244045c6812e00c8d36ef1": "Ybodychange",
    "92431c961741747b5d6442f4025016d48d9a6863": "Ybodychange",
    "d81109e588493cef31e68508a3d671203bd23e12": "Ybodychange",
    "863079bb874ba77918ca1c0741eae10e245995c8": "Ymultichange(Yparameterchange,Ybodychange)",
    "f56c65bb3eb9436b67de2df63098e26589e70e56": "Ybodychange",
    "be7bf956e96dd0fd9b521ca71df9124b9cc5ebd0": "Ybodychange",
    "5c0381c96aa79196829edbca497c649eb6776944": "Ybodychange",
    "cb81bac0029fce3a9726df3523f0b692cd3375b8": "Ybodychange",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "5420f287ccc83df69b6725942754c82b89e46b3e": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": "Ybodychange",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2a05e0ff3b5ab3be8654e9e96c6556865ef26096": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9749. TestAppLogAggregatorImpl#testDFSQuotaExceeded fails on trunk. Contributed by Adam Antal\n",
      "commitDate": "15/08/19 11:52 PM",
      "commitName": "2a05e0ff3b5ab3be8654e9e96c6556865ef26096",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "14/08/19 8:35 AM",
      "commitNameOld": "c89bdfacc8715fa6d72acd85437ab8cd257c8aad",
      "commitAuthorOld": "Adam Antal",
      "daysBetweenCommits": 1.64,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,137 @@\n   private void uploadLogsForContainers(boolean appFinished)\n       throws LogAggregationDFSException {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     addCredentials();\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     if (pendingContainerInThisCycle.isEmpty()) {\n       LOG.debug(\"No pending container in this cycle\");\n       sendLogAggregationReport(true, \"\", appFinished);\n       return;\n     }\n \n     logAggregationTimes++;\n     LOG.debug(\"Cycle #{} of log aggregator\", logAggregationTimes);\n     String diagnosticMessage \u003d \"\";\n     boolean logAggregationSucceedInThisCycle \u003d true;\n     DeletionTask deletionTask \u003d null;\n     try {\n       try {\n         logAggregationFileController.initializeWriter(logControllerContext);\n       } catch (IOException e1) {\n         logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(logAggregationFileController,\n             appFinished, finishedContainers.contains(container));\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           LOG.trace(\"Uploaded the following files for {}: {}\",\n               container, uploadedFilePathsInThisCycle.toString());\n           List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n           uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n           if (LOG.isDebugEnabled()) {\n             for (Path uploadedFilePath : uploadedFilePathsInThisCycleList) {\n               try {\n                 long fileSize \u003d lfs.getFileStatus(uploadedFilePath).getLen();\n                 if (fileSize \u003e\u003d logFileSizeThreshold) {\n                   LOG.debug(\"Log File \" + uploadedFilePath\n                       + \" size is \" + fileSize + \" bytes\");\n                 }\n               } catch (Exception e1) {\n                 LOG.error(\"Failed to get log file size \" + e1);\n               }\n             }\n           }\n           deletionTask \u003d new FileDeletionTask(delService,\n               this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycleList);\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n       logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n       logControllerContext.increLogAggregationTimes();\n       try {\n         this.logAggregationFileController.postWrite(logControllerContext);\n         diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n             + appId + \" in NodeManager: \"\n             + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n             + Times.format(logControllerContext.getLogUploadTimeStamp())\n             + \"\\n\";\n       } catch (Exception e) {\n         diagnosticMessage \u003d e.getMessage();\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n     } finally {\n       LogAggregationDFSException exc \u003d null;\n       try {\n         this.logAggregationFileController.closeWriter();\n       } catch (LogAggregationDFSException e) {\n         diagnosticMessage \u003d e.getMessage();\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n         exc \u003d e;\n       }\n       if (logAggregationSucceedInThisCycle \u0026\u0026 deletionTask !\u003d null) {\n         delService.delete(deletionTask);\n       }\n-      if (!diagnosticMessage.isEmpty()) {\n+      if (diagnosticMessage !\u003d null \u0026\u0026 !diagnosticMessage.isEmpty()) {\n         LOG.debug(\"Sending log aggregation report along with the \" +\n             \"following diagnostic message:\\\"{}\\\"\", diagnosticMessage);\n       }\n       if (!logAggregationSucceedInThisCycle) {\n         LOG.warn(\"Log aggregation did not succeed in this cycle\");\n       }\n       sendLogAggregationReport(logAggregationSucceedInThisCycle,\n           diagnosticMessage, appFinished);\n       if (exc !\u003d null) {\n         throw exc;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished)\n      throws LogAggregationDFSException {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    addCredentials();\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    if (pendingContainerInThisCycle.isEmpty()) {\n      LOG.debug(\"No pending container in this cycle\");\n      sendLogAggregationReport(true, \"\", appFinished);\n      return;\n    }\n\n    logAggregationTimes++;\n    LOG.debug(\"Cycle #{} of log aggregator\", logAggregationTimes);\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    DeletionTask deletionTask \u003d null;\n    try {\n      try {\n        logAggregationFileController.initializeWriter(logControllerContext);\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(logAggregationFileController,\n            appFinished, finishedContainers.contains(container));\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          LOG.trace(\"Uploaded the following files for {}: {}\",\n              container, uploadedFilePathsInThisCycle.toString());\n          List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n          uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n          if (LOG.isDebugEnabled()) {\n            for (Path uploadedFilePath : uploadedFilePathsInThisCycleList) {\n              try {\n                long fileSize \u003d lfs.getFileStatus(uploadedFilePath).getLen();\n                if (fileSize \u003e\u003d logFileSizeThreshold) {\n                  LOG.debug(\"Log File \" + uploadedFilePath\n                      + \" size is \" + fileSize + \" bytes\");\n                }\n              } catch (Exception e1) {\n                LOG.error(\"Failed to get log file size \" + e1);\n              }\n            }\n          }\n          deletionTask \u003d new FileDeletionTask(delService,\n              this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycleList);\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n      logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n      logControllerContext.increLogAggregationTimes();\n      try {\n        this.logAggregationFileController.postWrite(logControllerContext);\n        diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n            + appId + \" in NodeManager: \"\n            + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n            + Times.format(logControllerContext.getLogUploadTimeStamp())\n            + \"\\n\";\n      } catch (Exception e) {\n        diagnosticMessage \u003d e.getMessage();\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      LogAggregationDFSException exc \u003d null;\n      try {\n        this.logAggregationFileController.closeWriter();\n      } catch (LogAggregationDFSException e) {\n        diagnosticMessage \u003d e.getMessage();\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n        exc \u003d e;\n      }\n      if (logAggregationSucceedInThisCycle \u0026\u0026 deletionTask !\u003d null) {\n        delService.delete(deletionTask);\n      }\n      if (diagnosticMessage !\u003d null \u0026\u0026 !diagnosticMessage.isEmpty()) {\n        LOG.debug(\"Sending log aggregation report along with the \" +\n            \"following diagnostic message:\\\"{}\\\"\", diagnosticMessage);\n      }\n      if (!logAggregationSucceedInThisCycle) {\n        LOG.warn(\"Log aggregation did not succeed in this cycle\");\n      }\n      sendLogAggregationReport(logAggregationSucceedInThisCycle,\n          diagnosticMessage, appFinished);\n      if (exc !\u003d null) {\n        throw exc;\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "c89bdfacc8715fa6d72acd85437ab8cd257c8aad": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9676. Add DEBUG and TRACE level messages to AppLogAggregatorImplâ€¦ (#1261)\n\n* YARN-9676. Add DEBUG and TRACE level messages to AppLogAggregatorImpl and connected classes\r\n\r\n* Using {} placeholder, and increasing loglevel if log aggregation failed.\r\n",
      "commitDate": "14/08/19 8:35 AM",
      "commitName": "c89bdfacc8715fa6d72acd85437ab8cd257c8aad",
      "commitAuthor": "Adam Antal",
      "commitDateOld": "02/08/19 4:38 AM",
      "commitNameOld": "54ac80176e8487b7a18cd9e16a11efa289d0b7df",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 12.16,
      "commitsBetweenForRepo": 134,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,137 @@\n   private void uploadLogsForContainers(boolean appFinished)\n       throws LogAggregationDFSException {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     addCredentials();\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     if (pendingContainerInThisCycle.isEmpty()) {\n+      LOG.debug(\"No pending container in this cycle\");\n       sendLogAggregationReport(true, \"\", appFinished);\n       return;\n     }\n \n     logAggregationTimes++;\n+    LOG.debug(\"Cycle #{} of log aggregator\", logAggregationTimes);\n     String diagnosticMessage \u003d \"\";\n     boolean logAggregationSucceedInThisCycle \u003d true;\n     DeletionTask deletionTask \u003d null;\n     try {\n       try {\n         logAggregationFileController.initializeWriter(logControllerContext);\n       } catch (IOException e1) {\n         logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(logAggregationFileController,\n             appFinished, finishedContainers.contains(container));\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n+          LOG.trace(\"Uploaded the following files for {}: {}\",\n+              container, uploadedFilePathsInThisCycle.toString());\n           List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n           uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n           if (LOG.isDebugEnabled()) {\n             for (Path uploadedFilePath : uploadedFilePathsInThisCycleList) {\n               try {\n                 long fileSize \u003d lfs.getFileStatus(uploadedFilePath).getLen();\n                 if (fileSize \u003e\u003d logFileSizeThreshold) {\n                   LOG.debug(\"Log File \" + uploadedFilePath\n                       + \" size is \" + fileSize + \" bytes\");\n                 }\n               } catch (Exception e1) {\n                 LOG.error(\"Failed to get log file size \" + e1);\n               }\n             }\n           }\n           deletionTask \u003d new FileDeletionTask(delService,\n               this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycleList);\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n       logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n       logControllerContext.increLogAggregationTimes();\n       try {\n         this.logAggregationFileController.postWrite(logControllerContext);\n         diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n             + appId + \" in NodeManager: \"\n             + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n             + Times.format(logControllerContext.getLogUploadTimeStamp())\n             + \"\\n\";\n       } catch (Exception e) {\n         diagnosticMessage \u003d e.getMessage();\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n     } finally {\n       LogAggregationDFSException exc \u003d null;\n       try {\n         this.logAggregationFileController.closeWriter();\n       } catch (LogAggregationDFSException e) {\n         diagnosticMessage \u003d e.getMessage();\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n         exc \u003d e;\n       }\n       if (logAggregationSucceedInThisCycle \u0026\u0026 deletionTask !\u003d null) {\n         delService.delete(deletionTask);\n       }\n+      if (!diagnosticMessage.isEmpty()) {\n+        LOG.debug(\"Sending log aggregation report along with the \" +\n+            \"following diagnostic message:\\\"{}\\\"\", diagnosticMessage);\n+      }\n+      if (!logAggregationSucceedInThisCycle) {\n+        LOG.warn(\"Log aggregation did not succeed in this cycle\");\n+      }\n       sendLogAggregationReport(logAggregationSucceedInThisCycle,\n           diagnosticMessage, appFinished);\n       if (exc !\u003d null) {\n         throw exc;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished)\n      throws LogAggregationDFSException {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    addCredentials();\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    if (pendingContainerInThisCycle.isEmpty()) {\n      LOG.debug(\"No pending container in this cycle\");\n      sendLogAggregationReport(true, \"\", appFinished);\n      return;\n    }\n\n    logAggregationTimes++;\n    LOG.debug(\"Cycle #{} of log aggregator\", logAggregationTimes);\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    DeletionTask deletionTask \u003d null;\n    try {\n      try {\n        logAggregationFileController.initializeWriter(logControllerContext);\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(logAggregationFileController,\n            appFinished, finishedContainers.contains(container));\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          LOG.trace(\"Uploaded the following files for {}: {}\",\n              container, uploadedFilePathsInThisCycle.toString());\n          List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n          uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n          if (LOG.isDebugEnabled()) {\n            for (Path uploadedFilePath : uploadedFilePathsInThisCycleList) {\n              try {\n                long fileSize \u003d lfs.getFileStatus(uploadedFilePath).getLen();\n                if (fileSize \u003e\u003d logFileSizeThreshold) {\n                  LOG.debug(\"Log File \" + uploadedFilePath\n                      + \" size is \" + fileSize + \" bytes\");\n                }\n              } catch (Exception e1) {\n                LOG.error(\"Failed to get log file size \" + e1);\n              }\n            }\n          }\n          deletionTask \u003d new FileDeletionTask(delService,\n              this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycleList);\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n      logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n      logControllerContext.increLogAggregationTimes();\n      try {\n        this.logAggregationFileController.postWrite(logControllerContext);\n        diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n            + appId + \" in NodeManager: \"\n            + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n            + Times.format(logControllerContext.getLogUploadTimeStamp())\n            + \"\\n\";\n      } catch (Exception e) {\n        diagnosticMessage \u003d e.getMessage();\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      LogAggregationDFSException exc \u003d null;\n      try {\n        this.logAggregationFileController.closeWriter();\n      } catch (LogAggregationDFSException e) {\n        diagnosticMessage \u003d e.getMessage();\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n        exc \u003d e;\n      }\n      if (logAggregationSucceedInThisCycle \u0026\u0026 deletionTask !\u003d null) {\n        delService.delete(deletionTask);\n      }\n      if (!diagnosticMessage.isEmpty()) {\n        LOG.debug(\"Sending log aggregation report along with the \" +\n            \"following diagnostic message:\\\"{}\\\"\", diagnosticMessage);\n      }\n      if (!logAggregationSucceedInThisCycle) {\n        LOG.warn(\"Log aggregation did not succeed in this cycle\");\n      }\n      sendLogAggregationReport(logAggregationSucceedInThisCycle,\n          diagnosticMessage, appFinished);\n      if (exc !\u003d null) {\n        throw exc;\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "54ac80176e8487b7a18cd9e16a11efa289d0b7df": {
      "type": "Ybodychange",
      "commitMessage": "Logging fileSize of log files under NM Local Dir. Contributed by Prabhu Joseph\n",
      "commitDate": "02/08/19 4:38 AM",
      "commitName": "54ac80176e8487b7a18cd9e16a11efa289d0b7df",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 139.51,
      "commitsBetweenForRepo": 978,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,126 @@\n   private void uploadLogsForContainers(boolean appFinished)\n       throws LogAggregationDFSException {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     addCredentials();\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     if (pendingContainerInThisCycle.isEmpty()) {\n       sendLogAggregationReport(true, \"\", appFinished);\n       return;\n     }\n \n     logAggregationTimes++;\n     String diagnosticMessage \u003d \"\";\n     boolean logAggregationSucceedInThisCycle \u003d true;\n     DeletionTask deletionTask \u003d null;\n     try {\n       try {\n         logAggregationFileController.initializeWriter(logControllerContext);\n       } catch (IOException e1) {\n         logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(logAggregationFileController,\n             appFinished, finishedContainers.contains(container));\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n           uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n+          if (LOG.isDebugEnabled()) {\n+            for (Path uploadedFilePath : uploadedFilePathsInThisCycleList) {\n+              try {\n+                long fileSize \u003d lfs.getFileStatus(uploadedFilePath).getLen();\n+                if (fileSize \u003e\u003d logFileSizeThreshold) {\n+                  LOG.debug(\"Log File \" + uploadedFilePath\n+                      + \" size is \" + fileSize + \" bytes\");\n+                }\n+              } catch (Exception e1) {\n+                LOG.error(\"Failed to get log file size \" + e1);\n+              }\n+            }\n+          }\n           deletionTask \u003d new FileDeletionTask(delService,\n               this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycleList);\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n       logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n       logControllerContext.increLogAggregationTimes();\n       try {\n         this.logAggregationFileController.postWrite(logControllerContext);\n         diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n             + appId + \" in NodeManager: \"\n             + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n             + Times.format(logControllerContext.getLogUploadTimeStamp())\n             + \"\\n\";\n       } catch (Exception e) {\n         diagnosticMessage \u003d e.getMessage();\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n     } finally {\n       LogAggregationDFSException exc \u003d null;\n       try {\n         this.logAggregationFileController.closeWriter();\n       } catch (LogAggregationDFSException e) {\n         diagnosticMessage \u003d e.getMessage();\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n         exc \u003d e;\n       }\n       if (logAggregationSucceedInThisCycle \u0026\u0026 deletionTask !\u003d null) {\n         delService.delete(deletionTask);\n       }\n       sendLogAggregationReport(logAggregationSucceedInThisCycle,\n           diagnosticMessage, appFinished);\n       if (exc !\u003d null) {\n         throw exc;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished)\n      throws LogAggregationDFSException {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    addCredentials();\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    if (pendingContainerInThisCycle.isEmpty()) {\n      sendLogAggregationReport(true, \"\", appFinished);\n      return;\n    }\n\n    logAggregationTimes++;\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    DeletionTask deletionTask \u003d null;\n    try {\n      try {\n        logAggregationFileController.initializeWriter(logControllerContext);\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(logAggregationFileController,\n            appFinished, finishedContainers.contains(container));\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n          uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n          if (LOG.isDebugEnabled()) {\n            for (Path uploadedFilePath : uploadedFilePathsInThisCycleList) {\n              try {\n                long fileSize \u003d lfs.getFileStatus(uploadedFilePath).getLen();\n                if (fileSize \u003e\u003d logFileSizeThreshold) {\n                  LOG.debug(\"Log File \" + uploadedFilePath\n                      + \" size is \" + fileSize + \" bytes\");\n                }\n              } catch (Exception e1) {\n                LOG.error(\"Failed to get log file size \" + e1);\n              }\n            }\n          }\n          deletionTask \u003d new FileDeletionTask(delService,\n              this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycleList);\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n      logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n      logControllerContext.increLogAggregationTimes();\n      try {\n        this.logAggregationFileController.postWrite(logControllerContext);\n        diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n            + appId + \" in NodeManager: \"\n            + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n            + Times.format(logControllerContext.getLogUploadTimeStamp())\n            + \"\\n\";\n      } catch (Exception e) {\n        diagnosticMessage \u003d e.getMessage();\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      LogAggregationDFSException exc \u003d null;\n      try {\n        this.logAggregationFileController.closeWriter();\n      } catch (LogAggregationDFSException e) {\n        diagnosticMessage \u003d e.getMessage();\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n        exc \u003d e;\n      }\n      if (logAggregationSucceedInThisCycle \u0026\u0026 deletionTask !\u003d null) {\n        delService.delete(deletionTask);\n      }\n      sendLogAggregationReport(logAggregationSucceedInThisCycle,\n          diagnosticMessage, appFinished);\n      if (exc !\u003d null) {\n        throw exc;\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "b22f56c4719e63bd4f6edc2a075e0bcdb9442255": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-8273. Log aggregation does not warn if HDFS quota in target directory is exceeded (grepas via rkanter)\n",
      "commitDate": "22/05/18 2:24 PM",
      "commitName": "b22f56c4719e63bd4f6edc2a075e0bcdb9442255",
      "commitAuthor": "Robert Kanter",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-8273. Log aggregation does not warn if HDFS quota in target directory is exceeded (grepas via rkanter)\n",
          "commitDate": "22/05/18 2:24 PM",
          "commitName": "b22f56c4719e63bd4f6edc2a075e0bcdb9442255",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "15/03/18 1:26 PM",
          "commitNameOld": "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 68.04,
          "commitsBetweenForRepo": 1090,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,98 +1,113 @@\n-  private void uploadLogsForContainers(boolean appFinished) {\n+  private void uploadLogsForContainers(boolean appFinished)\n+      throws LogAggregationDFSException {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     addCredentials();\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     if (pendingContainerInThisCycle.isEmpty()) {\n       sendLogAggregationReport(true, \"\", appFinished);\n       return;\n     }\n \n     logAggregationTimes++;\n     String diagnosticMessage \u003d \"\";\n     boolean logAggregationSucceedInThisCycle \u003d true;\n+    DeletionTask deletionTask \u003d null;\n     try {\n       try {\n         logAggregationFileController.initializeWriter(logControllerContext);\n       } catch (IOException e1) {\n         logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(logAggregationFileController,\n             appFinished, finishedContainers.contains(container));\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n           uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n-          DeletionTask deletionTask \u003d new FileDeletionTask(delService,\n+          deletionTask \u003d new FileDeletionTask(delService,\n               this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycleList);\n-          delService.delete(deletionTask);\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n       logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n       logControllerContext.increLogAggregationTimes();\n       try {\n         this.logAggregationFileController.postWrite(logControllerContext);\n         diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n             + appId + \" in NodeManager: \"\n             + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n             + Times.format(logControllerContext.getLogUploadTimeStamp())\n             + \"\\n\";\n       } catch (Exception e) {\n         diagnosticMessage \u003d e.getMessage();\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n     } finally {\n+      LogAggregationDFSException exc \u003d null;\n+      try {\n+        this.logAggregationFileController.closeWriter();\n+      } catch (LogAggregationDFSException e) {\n+        diagnosticMessage \u003d e.getMessage();\n+        renameTemporaryLogFileFailed \u003d true;\n+        logAggregationSucceedInThisCycle \u003d false;\n+        exc \u003d e;\n+      }\n+      if (logAggregationSucceedInThisCycle \u0026\u0026 deletionTask !\u003d null) {\n+        delService.delete(deletionTask);\n+      }\n       sendLogAggregationReport(logAggregationSucceedInThisCycle,\n           diagnosticMessage, appFinished);\n-      logAggregationFileController.closeWriter();\n+      if (exc !\u003d null) {\n+        throw exc;\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void uploadLogsForContainers(boolean appFinished)\n      throws LogAggregationDFSException {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    addCredentials();\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    if (pendingContainerInThisCycle.isEmpty()) {\n      sendLogAggregationReport(true, \"\", appFinished);\n      return;\n    }\n\n    logAggregationTimes++;\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    DeletionTask deletionTask \u003d null;\n    try {\n      try {\n        logAggregationFileController.initializeWriter(logControllerContext);\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(logAggregationFileController,\n            appFinished, finishedContainers.contains(container));\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n          uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n          deletionTask \u003d new FileDeletionTask(delService,\n              this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycleList);\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n      logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n      logControllerContext.increLogAggregationTimes();\n      try {\n        this.logAggregationFileController.postWrite(logControllerContext);\n        diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n            + appId + \" in NodeManager: \"\n            + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n            + Times.format(logControllerContext.getLogUploadTimeStamp())\n            + \"\\n\";\n      } catch (Exception e) {\n        diagnosticMessage \u003d e.getMessage();\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      LogAggregationDFSException exc \u003d null;\n      try {\n        this.logAggregationFileController.closeWriter();\n      } catch (LogAggregationDFSException e) {\n        diagnosticMessage \u003d e.getMessage();\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n        exc \u003d e;\n      }\n      if (logAggregationSucceedInThisCycle \u0026\u0026 deletionTask !\u003d null) {\n        delService.delete(deletionTask);\n      }\n      sendLogAggregationReport(logAggregationSucceedInThisCycle,\n          diagnosticMessage, appFinished);\n      if (exc !\u003d null) {\n        throw exc;\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[LogAggregationDFSException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8273. Log aggregation does not warn if HDFS quota in target directory is exceeded (grepas via rkanter)\n",
          "commitDate": "22/05/18 2:24 PM",
          "commitName": "b22f56c4719e63bd4f6edc2a075e0bcdb9442255",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "15/03/18 1:26 PM",
          "commitNameOld": "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 68.04,
          "commitsBetweenForRepo": 1090,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,98 +1,113 @@\n-  private void uploadLogsForContainers(boolean appFinished) {\n+  private void uploadLogsForContainers(boolean appFinished)\n+      throws LogAggregationDFSException {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     addCredentials();\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     if (pendingContainerInThisCycle.isEmpty()) {\n       sendLogAggregationReport(true, \"\", appFinished);\n       return;\n     }\n \n     logAggregationTimes++;\n     String diagnosticMessage \u003d \"\";\n     boolean logAggregationSucceedInThisCycle \u003d true;\n+    DeletionTask deletionTask \u003d null;\n     try {\n       try {\n         logAggregationFileController.initializeWriter(logControllerContext);\n       } catch (IOException e1) {\n         logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(logAggregationFileController,\n             appFinished, finishedContainers.contains(container));\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n           uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n-          DeletionTask deletionTask \u003d new FileDeletionTask(delService,\n+          deletionTask \u003d new FileDeletionTask(delService,\n               this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycleList);\n-          delService.delete(deletionTask);\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n       logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n       logControllerContext.increLogAggregationTimes();\n       try {\n         this.logAggregationFileController.postWrite(logControllerContext);\n         diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n             + appId + \" in NodeManager: \"\n             + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n             + Times.format(logControllerContext.getLogUploadTimeStamp())\n             + \"\\n\";\n       } catch (Exception e) {\n         diagnosticMessage \u003d e.getMessage();\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n     } finally {\n+      LogAggregationDFSException exc \u003d null;\n+      try {\n+        this.logAggregationFileController.closeWriter();\n+      } catch (LogAggregationDFSException e) {\n+        diagnosticMessage \u003d e.getMessage();\n+        renameTemporaryLogFileFailed \u003d true;\n+        logAggregationSucceedInThisCycle \u003d false;\n+        exc \u003d e;\n+      }\n+      if (logAggregationSucceedInThisCycle \u0026\u0026 deletionTask !\u003d null) {\n+        delService.delete(deletionTask);\n+      }\n       sendLogAggregationReport(logAggregationSucceedInThisCycle,\n           diagnosticMessage, appFinished);\n-      logAggregationFileController.closeWriter();\n+      if (exc !\u003d null) {\n+        throw exc;\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void uploadLogsForContainers(boolean appFinished)\n      throws LogAggregationDFSException {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    addCredentials();\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    if (pendingContainerInThisCycle.isEmpty()) {\n      sendLogAggregationReport(true, \"\", appFinished);\n      return;\n    }\n\n    logAggregationTimes++;\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    DeletionTask deletionTask \u003d null;\n    try {\n      try {\n        logAggregationFileController.initializeWriter(logControllerContext);\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(logAggregationFileController,\n            appFinished, finishedContainers.contains(container));\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n          uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n          deletionTask \u003d new FileDeletionTask(delService,\n              this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycleList);\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n      logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n      logControllerContext.increLogAggregationTimes();\n      try {\n        this.logAggregationFileController.postWrite(logControllerContext);\n        diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n            + appId + \" in NodeManager: \"\n            + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n            + Times.format(logControllerContext.getLogUploadTimeStamp())\n            + \"\\n\";\n      } catch (Exception e) {\n        diagnosticMessage \u003d e.getMessage();\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      LogAggregationDFSException exc \u003d null;\n      try {\n        this.logAggregationFileController.closeWriter();\n      } catch (LogAggregationDFSException e) {\n        diagnosticMessage \u003d e.getMessage();\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n        exc \u003d e;\n      }\n      if (logAggregationSucceedInThisCycle \u0026\u0026 deletionTask !\u003d null) {\n        delService.delete(deletionTask);\n      }\n      sendLogAggregationReport(logAggregationSucceedInThisCycle,\n          diagnosticMessage, appFinished);\n      if (exc !\u003d null) {\n        throw exc;\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6876. Create an abstract log writer for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "24/08/17 1:36 PM",
      "commitName": "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
      "commitAuthor": "Junping Du",
      "commitDateOld": "22/08/17 1:14 AM",
      "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 2.52,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,98 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     addCredentials();\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     if (pendingContainerInThisCycle.isEmpty()) {\n       sendLogAggregationReport(true, \"\", appFinished);\n       return;\n     }\n \n     logAggregationTimes++;\n     String diagnosticMessage \u003d \"\";\n     boolean logAggregationSucceedInThisCycle \u003d true;\n-    try (LogWriter writer \u003d createLogWriter()) {\n+    try {\n       try {\n-        writer.initialize(this.conf, this.remoteNodeTmpLogFileForApp,\n-            this.userUgi);\n-        // Write ACLs once when the writer is created.\n-        writer.writeApplicationACLs(appAcls);\n-        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n-\n+        logAggregationFileController.initializeWriter(logControllerContext);\n       } catch (IOException e1) {\n         logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n-            aggregator.doContainerLogAggregation(writer, appFinished,\n-            finishedContainers.contains(container));\n+            aggregator.doContainerLogAggregation(logAggregationFileController,\n+            appFinished, finishedContainers.contains(container));\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n           uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n           DeletionTask deletionTask \u003d new FileDeletionTask(delService,\n               this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycleList);\n           delService.delete(deletionTask);\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n-      // Before upload logs, make sure the number of existing logs\n-      // is smaller than the configured NM log aggregation retention size.\n-      if (uploadedLogsInThisCycle \u0026\u0026 logAggregationInRolling) {\n-        cleanOldLogs();\n-        cleanupOldLogTimes++;\n-      }\n-\n-      long currentTime \u003d System.currentTimeMillis();\n-      final Path renamedPath \u003d getRenamedPath(currentTime);\n-\n-      final boolean rename \u003d uploadedLogsInThisCycle;\n+      logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n+      logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n+      logControllerContext.increLogAggregationTimes();\n       try {\n-        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n-          @Override\n-          public Object run() throws Exception {\n-            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n-            if (rename) {\n-              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n-            } else {\n-              remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n-            }\n-            return null;\n-          }\n-        });\n-        diagnosticMessage \u003d\n-            \"Log uploaded successfully for Application: \" + appId\n-                + \" in NodeManager: \"\n-                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n-                + Times.format(currentTime) + \"\\n\";\n+        this.logAggregationFileController.postWrite(logControllerContext);\n+        diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n+            + appId + \" in NodeManager: \"\n+            + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n+            + Times.format(logControllerContext.getLogUploadTimeStamp())\n+            + \"\\n\";\n       } catch (Exception e) {\n-        LOG.error(\n-          \"Failed to move temporary log file to final location: [\"\n-              + remoteNodeTmpLogFileForApp + \"] to [\"\n-              + renamedPath + \"]\", e);\n-        diagnosticMessage \u003d\n-            \"Log uploaded failed for Application: \" + appId\n-                + \" in NodeManager: \"\n-                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n-                + Times.format(currentTime) + \"\\n\";\n+        diagnosticMessage \u003d e.getMessage();\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n     } finally {\n       sendLogAggregationReport(logAggregationSucceedInThisCycle,\n           diagnosticMessage, appFinished);\n+      logAggregationFileController.closeWriter();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    addCredentials();\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    if (pendingContainerInThisCycle.isEmpty()) {\n      sendLogAggregationReport(true, \"\", appFinished);\n      return;\n    }\n\n    logAggregationTimes++;\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    try {\n      try {\n        logAggregationFileController.initializeWriter(logControllerContext);\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(logAggregationFileController,\n            appFinished, finishedContainers.contains(container));\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n          uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n          DeletionTask deletionTask \u003d new FileDeletionTask(delService,\n              this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycleList);\n          delService.delete(deletionTask);\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      logControllerContext.setUploadedLogsInThisCycle(uploadedLogsInThisCycle);\n      logControllerContext.setLogUploadTimeStamp(System.currentTimeMillis());\n      logControllerContext.increLogAggregationTimes();\n      try {\n        this.logAggregationFileController.postWrite(logControllerContext);\n        diagnosticMessage \u003d \"Log uploaded successfully for Application: \"\n            + appId + \" in NodeManager: \"\n            + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n            + Times.format(logControllerContext.getLogUploadTimeStamp())\n            + \"\\n\";\n      } catch (Exception e) {\n        diagnosticMessage \u003d e.getMessage();\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      sendLogAggregationReport(logAggregationSucceedInThisCycle,\n          diagnosticMessage, appFinished);\n      logAggregationFileController.closeWriter();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "547f18cb96aeda55cc19b38be2be4d631b3a5f4f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6366. Refactor the NodeManager DeletionService to support additional DeletionTask types. Contributed by Shane Kumpf.\n",
      "commitDate": "31/05/17 3:45 AM",
      "commitName": "547f18cb96aeda55cc19b38be2be4d631b3a5f4f",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "06/04/17 2:24 PM",
      "commitNameOld": "1b081ca27e05e97d8b7d284ca24200d43763e481",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 54.56,
      "commitsBetweenForRepo": 288,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,129 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n-    if (UserGroupInformation.isSecurityEnabled()) {\n-      Credentials systemCredentials \u003d\n-          context.getSystemCredentialsForApps().get(appId);\n-      if (systemCredentials !\u003d null) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Adding new framework-token for \" + appId\n-              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n-              + \"; userUgi\u003d\" + userUgi);\n-        }\n-        // this will replace old token\n-        userUgi.addCredentials(systemCredentials);\n-      }\n-    }\n+    addCredentials();\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     if (pendingContainerInThisCycle.isEmpty()) {\n       sendLogAggregationReport(true, \"\", appFinished);\n       return;\n     }\n \n     logAggregationTimes++;\n     String diagnosticMessage \u003d \"\";\n     boolean logAggregationSucceedInThisCycle \u003d true;\n     try (LogWriter writer \u003d createLogWriter()) {\n       try {\n         writer.initialize(this.conf, this.remoteNodeTmpLogFileForApp,\n             this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished,\n             finishedContainers.contains(container));\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n-          this.delService.delete(this.userUgi.getShortUserName(), null,\n-              uploadedFilePathsInThisCycle\n-                  .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n+          List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n+          uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n+          DeletionTask deletionTask \u003d new FileDeletionTask(delService,\n+              this.userUgi.getShortUserName(), null,\n+              uploadedFilePathsInThisCycleList);\n+          delService.delete(deletionTask);\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle \u0026\u0026 logAggregationInRolling) {\n         cleanOldLogs();\n         cleanupOldLogTimes++;\n       }\n \n       long currentTime \u003d System.currentTimeMillis();\n-      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n-              ? remoteNodeLogFileForApp : new Path(\n-                remoteNodeLogFileForApp.getParent(),\n-                remoteNodeLogFileForApp.getName() + \"_\"\n-                    + currentTime);\n+      final Path renamedPath \u003d getRenamedPath(currentTime);\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (rename) {\n               remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n             } else {\n               remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n     } finally {\n       sendLogAggregationReport(logAggregationSucceedInThisCycle,\n           diagnosticMessage, appFinished);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    addCredentials();\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    if (pendingContainerInThisCycle.isEmpty()) {\n      sendLogAggregationReport(true, \"\", appFinished);\n      return;\n    }\n\n    logAggregationTimes++;\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    try (LogWriter writer \u003d createLogWriter()) {\n      try {\n        writer.initialize(this.conf, this.remoteNodeTmpLogFileForApp,\n            this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished,\n            finishedContainers.contains(container));\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          List\u003cPath\u003e uploadedFilePathsInThisCycleList \u003d new ArrayList\u003c\u003e();\n          uploadedFilePathsInThisCycleList.addAll(uploadedFilePathsInThisCycle);\n          DeletionTask deletionTask \u003d new FileDeletionTask(delService,\n              this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycleList);\n          delService.delete(deletionTask);\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle \u0026\u0026 logAggregationInRolling) {\n        cleanOldLogs();\n        cleanupOldLogTimes++;\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d getRenamedPath(currentTime);\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (rename) {\n              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n            } else {\n              remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      sendLogAggregationReport(logAggregationSucceedInThisCycle,\n          diagnosticMessage, appFinished);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "1b081ca27e05e97d8b7d284ca24200d43763e481": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6288. Exceptions during aggregated log writes are mishandled. Contributed by Akira Ajisaka\n",
      "commitDate": "06/04/17 2:24 PM",
      "commitName": "1b081ca27e05e97d8b7d284ca24200d43763e481",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "28/03/17 6:36 PM",
      "commitNameOld": "82fb9ce8df7a534a4cbcec624d7b6c0b33e79123",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 8.83,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,142 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n-    LogWriter writer \u003d null;\n+    if (pendingContainerInThisCycle.isEmpty()) {\n+      sendLogAggregationReport(true, \"\", appFinished);\n+      return;\n+    }\n+\n+    logAggregationTimes++;\n     String diagnosticMessage \u003d \"\";\n     boolean logAggregationSucceedInThisCycle \u003d true;\n-    try {\n-      if (pendingContainerInThisCycle.isEmpty()) {\n-        return;\n-      }\n-\n-      logAggregationTimes++;\n-\n+    try (LogWriter writer \u003d createLogWriter()) {\n       try {\n-        writer \u003d createLogWriter();\n+        writer.initialize(this.conf, this.remoteNodeTmpLogFileForApp,\n+            this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished,\n             finishedContainers.contains(container));\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           this.delService.delete(this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycle\n                   .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle \u0026\u0026 logAggregationInRolling) {\n         cleanOldLogs();\n         cleanupOldLogTimes++;\n       }\n \n-      if (writer !\u003d null) {\n-        writer.close();\n-        writer \u003d null;\n-      }\n-\n       long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + currentTime);\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (rename) {\n               remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n             } else {\n               remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n     } finally {\n-      LogAggregationStatus logAggregationStatus \u003d\n-          logAggregationSucceedInThisCycle\n-              ? LogAggregationStatus.RUNNING\n-              : LogAggregationStatus.RUNNING_WITH_FAILURE;\n-      sendLogAggregationReport(logAggregationStatus, diagnosticMessage);\n-      if (appFinished) {\n-        // If the app is finished, one extra final report with log aggregation\n-        // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n-        // that the log aggregation in this NM is completed.\n-        LogAggregationStatus finalLogAggregationStatus \u003d\n-            renameTemporaryLogFileFailed || !logAggregationSucceedInThisCycle\n-                ? LogAggregationStatus.FAILED\n-                : LogAggregationStatus.SUCCEEDED;\n-        sendLogAggregationReport(finalLogAggregationStatus, \"\");\n-      }\n-\n-      if (writer !\u003d null) {\n-        writer.close();\n-      }\n+      sendLogAggregationReport(logAggregationSucceedInThisCycle,\n+          diagnosticMessage, appFinished);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    if (pendingContainerInThisCycle.isEmpty()) {\n      sendLogAggregationReport(true, \"\", appFinished);\n      return;\n    }\n\n    logAggregationTimes++;\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    try (LogWriter writer \u003d createLogWriter()) {\n      try {\n        writer.initialize(this.conf, this.remoteNodeTmpLogFileForApp,\n            this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished,\n            finishedContainers.contains(container));\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          this.delService.delete(this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycle\n                  .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle \u0026\u0026 logAggregationInRolling) {\n        cleanOldLogs();\n        cleanupOldLogTimes++;\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (rename) {\n              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n            } else {\n              remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      sendLogAggregationReport(logAggregationSucceedInThisCycle,\n          diagnosticMessage, appFinished);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "5dfc38ff57669cba9078146e91ed990a1d25a3f0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5237. Fix missing log files issue in rolling log aggregation. Contributed by Xuan Gong.\n",
      "commitDate": "15/06/16 4:17 PM",
      "commitName": "5dfc38ff57669cba9078146e91ed990a1d25a3f0",
      "commitAuthor": "Junping Du",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 1.05,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,163 +1,164 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     String diagnosticMessage \u003d \"\";\n     boolean logAggregationSucceedInThisCycle \u003d true;\n     try {\n       if (pendingContainerInThisCycle.isEmpty()) {\n         return;\n       }\n \n       logAggregationTimes++;\n \n       try {\n         writer \u003d createLogWriter();\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n-            aggregator.doContainerLogAggregation(writer, appFinished);\n+            aggregator.doContainerLogAggregation(writer, appFinished,\n+            finishedContainers.contains(container));\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           this.delService.delete(this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycle\n                   .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle \u0026\u0026 logAggregationInRolling) {\n         cleanOldLogs();\n         cleanupOldLogTimes++;\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n         writer \u003d null;\n       }\n \n       long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + currentTime);\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (rename) {\n               remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n             } else {\n               remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n     } finally {\n       LogAggregationStatus logAggregationStatus \u003d\n           logAggregationSucceedInThisCycle\n               ? LogAggregationStatus.RUNNING\n               : LogAggregationStatus.RUNNING_WITH_FAILURE;\n       sendLogAggregationReport(logAggregationStatus, diagnosticMessage);\n       if (appFinished) {\n         // If the app is finished, one extra final report with log aggregation\n         // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n         // that the log aggregation in this NM is completed.\n         LogAggregationStatus finalLogAggregationStatus \u003d\n             renameTemporaryLogFileFailed || !logAggregationSucceedInThisCycle\n                 ? LogAggregationStatus.FAILED\n                 : LogAggregationStatus.SUCCEEDED;\n         sendLogAggregationReport(finalLogAggregationStatus, \"\");\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    try {\n      if (pendingContainerInThisCycle.isEmpty()) {\n        return;\n      }\n\n      logAggregationTimes++;\n\n      try {\n        writer \u003d createLogWriter();\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished,\n            finishedContainers.contains(container));\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          this.delService.delete(this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycle\n                  .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle \u0026\u0026 logAggregationInRolling) {\n        cleanOldLogs();\n        cleanupOldLogTimes++;\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n        writer \u003d null;\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (rename) {\n              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n            } else {\n              remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      LogAggregationStatus logAggregationStatus \u003d\n          logAggregationSucceedInThisCycle\n              ? LogAggregationStatus.RUNNING\n              : LogAggregationStatus.RUNNING_WITH_FAILURE;\n      sendLogAggregationReport(logAggregationStatus, diagnosticMessage);\n      if (appFinished) {\n        // If the app is finished, one extra final report with log aggregation\n        // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n        // that the log aggregation in this NM is completed.\n        LogAggregationStatus finalLogAggregationStatus \u003d\n            renameTemporaryLogFileFailed || !logAggregationSucceedInThisCycle\n                ? LogAggregationStatus.FAILED\n                : LogAggregationStatus.SUCCEEDED;\n        sendLogAggregationReport(finalLogAggregationStatus, \"\");\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4766. NM should not aggregate logs older than the retention policy (haibochen via rkanter)\n",
      "commitDate": "25/05/16 10:25 AM",
      "commitName": "e07519b8dbb96d73c48e910a4de12563c5c2f8aa",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "22/05/16 4:04 PM",
      "commitNameOld": "6161d9ba5230f553db5f5490dce67e2afd1e29ca",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,165 +1,163 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     String diagnosticMessage \u003d \"\";\n     boolean logAggregationSucceedInThisCycle \u003d true;\n     try {\n       if (pendingContainerInThisCycle.isEmpty()) {\n         return;\n       }\n \n       logAggregationTimes++;\n \n       try {\n-        writer \u003d\n-            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n-              this.userUgi);\n+        writer \u003d createLogWriter();\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           this.delService.delete(this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycle\n                   .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle \u0026\u0026 logAggregationInRolling) {\n         cleanOldLogs();\n         cleanupOldLogTimes++;\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n         writer \u003d null;\n       }\n \n       long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + currentTime);\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (rename) {\n               remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n             } else {\n               remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n     } finally {\n       LogAggregationStatus logAggregationStatus \u003d\n           logAggregationSucceedInThisCycle\n               ? LogAggregationStatus.RUNNING\n               : LogAggregationStatus.RUNNING_WITH_FAILURE;\n       sendLogAggregationReport(logAggregationStatus, diagnosticMessage);\n       if (appFinished) {\n         // If the app is finished, one extra final report with log aggregation\n         // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n         // that the log aggregation in this NM is completed.\n         LogAggregationStatus finalLogAggregationStatus \u003d\n             renameTemporaryLogFileFailed || !logAggregationSucceedInThisCycle\n                 ? LogAggregationStatus.FAILED\n                 : LogAggregationStatus.SUCCEEDED;\n         sendLogAggregationReport(finalLogAggregationStatus, \"\");\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    try {\n      if (pendingContainerInThisCycle.isEmpty()) {\n        return;\n      }\n\n      logAggregationTimes++;\n\n      try {\n        writer \u003d createLogWriter();\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          this.delService.delete(this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycle\n                  .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle \u0026\u0026 logAggregationInRolling) {\n        cleanOldLogs();\n        cleanupOldLogTimes++;\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n        writer \u003d null;\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (rename) {\n              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n            } else {\n              remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      LogAggregationStatus logAggregationStatus \u003d\n          logAggregationSucceedInThisCycle\n              ? LogAggregationStatus.RUNNING\n              : LogAggregationStatus.RUNNING_WITH_FAILURE;\n      sendLogAggregationReport(logAggregationStatus, diagnosticMessage);\n      if (appFinished) {\n        // If the app is finished, one extra final report with log aggregation\n        // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n        // that the log aggregation in this NM is completed.\n        LogAggregationStatus finalLogAggregationStatus \u003d\n            renameTemporaryLogFileFailed || !logAggregationSucceedInThisCycle\n                ? LogAggregationStatus.FAILED\n                : LogAggregationStatus.SUCCEEDED;\n        sendLogAggregationReport(finalLogAggregationStatus, \"\");\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "948b75807068c304ffe789e32f2b850c0d653e0a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4773. Log aggregation performs extraneous filesystem operations when rolling log aggregation is disabled. Contributed by Jun Gong\n",
      "commitDate": "28/03/16 4:00 PM",
      "commitName": "948b75807068c304ffe789e32f2b850c0d653e0a",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "26/02/16 8:40 AM",
      "commitNameOld": "7f3139e54da2c496327446a5eac43f8421fc8839",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 31.26,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,165 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     String diagnosticMessage \u003d \"\";\n     boolean logAggregationSucceedInThisCycle \u003d true;\n     try {\n       if (pendingContainerInThisCycle.isEmpty()) {\n         return;\n       }\n \n       logAggregationTimes++;\n \n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           this.delService.delete(this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycle\n                   .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n-      if (uploadedLogsInThisCycle) {\n+      if (uploadedLogsInThisCycle \u0026\u0026 logAggregationInRolling) {\n         cleanOldLogs();\n+        cleanupOldLogTimes++;\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n         writer \u003d null;\n       }\n \n       long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + currentTime);\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (rename) {\n               remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n             } else {\n               remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n     } finally {\n       LogAggregationStatus logAggregationStatus \u003d\n           logAggregationSucceedInThisCycle\n               ? LogAggregationStatus.RUNNING\n               : LogAggregationStatus.RUNNING_WITH_FAILURE;\n       sendLogAggregationReport(logAggregationStatus, diagnosticMessage);\n       if (appFinished) {\n         // If the app is finished, one extra final report with log aggregation\n         // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n         // that the log aggregation in this NM is completed.\n         LogAggregationStatus finalLogAggregationStatus \u003d\n             renameTemporaryLogFileFailed || !logAggregationSucceedInThisCycle\n                 ? LogAggregationStatus.FAILED\n                 : LogAggregationStatus.SUCCEEDED;\n         sendLogAggregationReport(finalLogAggregationStatus, \"\");\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    try {\n      if (pendingContainerInThisCycle.isEmpty()) {\n        return;\n      }\n\n      logAggregationTimes++;\n\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          this.delService.delete(this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycle\n                  .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle \u0026\u0026 logAggregationInRolling) {\n        cleanOldLogs();\n        cleanupOldLogTimes++;\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n        writer \u003d null;\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (rename) {\n              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n            } else {\n              remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      LogAggregationStatus logAggregationStatus \u003d\n          logAggregationSucceedInThisCycle\n              ? LogAggregationStatus.RUNNING\n              : LogAggregationStatus.RUNNING_WITH_FAILURE;\n      sendLogAggregationReport(logAggregationStatus, diagnosticMessage);\n      if (appFinished) {\n        // If the app is finished, one extra final report with log aggregation\n        // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n        // that the log aggregation in this NM is completed.\n        LogAggregationStatus finalLogAggregationStatus \u003d\n            renameTemporaryLogFileFailed || !logAggregationSucceedInThisCycle\n                ? LogAggregationStatus.FAILED\n                : LogAggregationStatus.SUCCEEDED;\n        sendLogAggregationReport(finalLogAggregationStatus, \"\");\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "7f3139e54da2c496327446a5eac43f8421fc8839": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4720. Skip unnecessary NN operations in log aggregation. (Jun Gong via mingma)\n",
      "commitDate": "26/02/16 8:40 AM",
      "commitName": "7f3139e54da2c496327446a5eac43f8421fc8839",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "07/01/16 8:12 AM",
      "commitNameOld": "52b77577c44538c26fb9d0144f0b280be3593a38",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 50.02,
      "commitsBetweenForRepo": 355,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,163 +1,164 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n+    String diagnosticMessage \u003d \"\";\n+    boolean logAggregationSucceedInThisCycle \u003d true;\n     try {\n+      if (pendingContainerInThisCycle.isEmpty()) {\n+        return;\n+      }\n+\n+      logAggregationTimes++;\n+\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n+        logAggregationSucceedInThisCycle \u003d false;\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           this.delService.delete(this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycle\n                   .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n         writer \u003d null;\n       }\n \n       long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + currentTime);\n \n-      String diagnosticMessage \u003d \"\";\n-      boolean logAggregationSucceedInThisCycle \u003d true;\n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n-            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n-              if (rename) {\n-                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n-              } else {\n-                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n-              }\n+            if (rename) {\n+              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n+            } else {\n+              remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n-\n-      LogAggregationReport report \u003d\n-          Records.newRecord(LogAggregationReport.class);\n-      report.setApplicationId(appId);\n-      report.setDiagnosticMessage(diagnosticMessage);\n-      report.setLogAggregationStatus(logAggregationSucceedInThisCycle\n-          ? LogAggregationStatus.RUNNING\n-          : LogAggregationStatus.RUNNING_WITH_FAILURE);\n-      this.context.getLogAggregationStatusForApps().add(report);\n+    } finally {\n+      LogAggregationStatus logAggregationStatus \u003d\n+          logAggregationSucceedInThisCycle\n+              ? LogAggregationStatus.RUNNING\n+              : LogAggregationStatus.RUNNING_WITH_FAILURE;\n+      sendLogAggregationReport(logAggregationStatus, diagnosticMessage);\n       if (appFinished) {\n         // If the app is finished, one extra final report with log aggregation\n         // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n         // that the log aggregation in this NM is completed.\n-        LogAggregationReport finalReport \u003d\n-            Records.newRecord(LogAggregationReport.class);\n-        finalReport.setApplicationId(appId);\n-        finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed\n-            ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n-        this.context.getLogAggregationStatusForApps().add(finalReport);\n+        LogAggregationStatus finalLogAggregationStatus \u003d\n+            renameTemporaryLogFileFailed || !logAggregationSucceedInThisCycle\n+                ? LogAggregationStatus.FAILED\n+                : LogAggregationStatus.SUCCEEDED;\n+        sendLogAggregationReport(finalLogAggregationStatus, \"\");\n       }\n-    } finally {\n+\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    String diagnosticMessage \u003d \"\";\n    boolean logAggregationSucceedInThisCycle \u003d true;\n    try {\n      if (pendingContainerInThisCycle.isEmpty()) {\n        return;\n      }\n\n      logAggregationTimes++;\n\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        logAggregationSucceedInThisCycle \u003d false;\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          this.delService.delete(this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycle\n                  .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n        writer \u003d null;\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (rename) {\n              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n            } else {\n              remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n    } finally {\n      LogAggregationStatus logAggregationStatus \u003d\n          logAggregationSucceedInThisCycle\n              ? LogAggregationStatus.RUNNING\n              : LogAggregationStatus.RUNNING_WITH_FAILURE;\n      sendLogAggregationReport(logAggregationStatus, diagnosticMessage);\n      if (appFinished) {\n        // If the app is finished, one extra final report with log aggregation\n        // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n        // that the log aggregation in this NM is completed.\n        LogAggregationStatus finalLogAggregationStatus \u003d\n            renameTemporaryLogFileFailed || !logAggregationSucceedInThisCycle\n                ? LogAggregationStatus.FAILED\n                : LogAggregationStatus.SUCCEEDED;\n        sendLogAggregationReport(finalLogAggregationStatus, \"\");\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "8c1cdb17a03fec91bfab172fe92b67bdeb9ebfba": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4158. Remove duplicate close for LogWriter in AppLogAggregatorImpl#uploadLogsForContainers. Contributed by Zhihai Xu\n",
      "commitDate": "15/09/15 1:21 PM",
      "commitName": "8c1cdb17a03fec91bfab172fe92b67bdeb9ebfba",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "08/09/15 12:29 PM",
      "commitNameOld": "16b9037dc1300b8bdbe54ba7cd47c53fe16e93d8",
      "commitAuthorOld": "Zhihai Xu",
      "daysBetweenCommits": 7.04,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,162 +1,163 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n     //    we use exitCode of 0 to find those which satisfy the\n     //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (Container container : this.context.getApplications()\n         .get(this.appId).getContainers().values()) {\n         ContainerType containerType \u003d\n             container.getContainerTokenIdentifier().getContainerType();\n         if (shouldUploadLogs(new ContainerLogContext(\n             container.getContainerId(), containerType, 0))) {\n           pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           this.delService.delete(this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycle\n                   .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n+        writer \u003d null;\n       }\n \n       long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + currentTime);\n \n       String diagnosticMessage \u003d \"\";\n       boolean logAggregationSucceedInThisCycle \u003d true;\n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n \n       LogAggregationReport report \u003d\n           Records.newRecord(LogAggregationReport.class);\n       report.setApplicationId(appId);\n       report.setDiagnosticMessage(diagnosticMessage);\n       report.setLogAggregationStatus(logAggregationSucceedInThisCycle\n           ? LogAggregationStatus.RUNNING\n           : LogAggregationStatus.RUNNING_WITH_FAILURE);\n       this.context.getLogAggregationStatusForApps().add(report);\n       if (appFinished) {\n         // If the app is finished, one extra final report with log aggregation\n         // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n         // that the log aggregation in this NM is completed.\n         LogAggregationReport finalReport \u003d\n             Records.newRecord(LogAggregationReport.class);\n         finalReport.setApplicationId(appId);\n         finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed\n             ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n         this.context.getLogAggregationStatusForApps().add(finalReport);\n       }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          this.delService.delete(this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycle\n                  .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n        writer \u003d null;\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      String diagnosticMessage \u003d \"\";\n      boolean logAggregationSucceedInThisCycle \u003d true;\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n\n      LogAggregationReport report \u003d\n          Records.newRecord(LogAggregationReport.class);\n      report.setApplicationId(appId);\n      report.setDiagnosticMessage(diagnosticMessage);\n      report.setLogAggregationStatus(logAggregationSucceedInThisCycle\n          ? LogAggregationStatus.RUNNING\n          : LogAggregationStatus.RUNNING_WITH_FAILURE);\n      this.context.getLogAggregationStatusForApps().add(report);\n      if (appFinished) {\n        // If the app is finished, one extra final report with log aggregation\n        // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n        // that the log aggregation in this NM is completed.\n        LogAggregationReport finalReport \u003d\n            Records.newRecord(LogAggregationReport.class);\n        finalReport.setApplicationId(appId);\n        finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed\n            ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n        this.context.getLogAggregationStatusForApps().add(finalReport);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "37e1c3d82a96d781e1c9982988b7de4aa5242d0c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-221. NM should provide a way for AM to tell it not to aggregate\nlogs. Contributed by Ming Ma\n",
      "commitDate": "22/08/15 4:25 PM",
      "commitName": "37e1c3d82a96d781e1c9982988b7de4aa5242d0c",
      "commitAuthor": "Xuan",
      "commitDateOld": "01/07/15 2:13 PM",
      "commitNameOld": "b5cdf78e8e6cd6c5c1fb7286207dac72be32c0d6",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 52.09,
      "commitsBetweenForRepo": 287,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,161 +1,162 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n-    //    and satisfy the retentionPolicy.\n+    //    and satisfy the ContainerLogAggregationPolicy.\n     // b) some set of running containers: For all the Running containers,\n-    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n-    // so simply set wasContainerSuccessful as true to\n-    // bypass FAILED_CONTAINERS check and find the running containers \n-    // which satisfy the retentionPolicy.\n+    //    we use exitCode of 0 to find those which satisfy the\n+    //    ContainerLogAggregationPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n-      for (ContainerId container : this.context.getApplications()\n-        .get(this.appId).getContainers().keySet()) {\n-        if (shouldUploadLogs(container, true)) {\n-          pendingContainerInThisCycle.add(container);\n+      for (Container container : this.context.getApplications()\n+        .get(this.appId).getContainers().values()) {\n+        ContainerType containerType \u003d\n+            container.getContainerTokenIdentifier().getContainerType();\n+        if (shouldUploadLogs(new ContainerLogContext(\n+            container.getContainerId(), containerType, 0))) {\n+          pendingContainerInThisCycle.add(container.getContainerId());\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n           this.delService.delete(this.userUgi.getShortUserName(), null,\n               uploadedFilePathsInThisCycle\n                   .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n         }\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n       long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + currentTime);\n \n       String diagnosticMessage \u003d \"\";\n       boolean logAggregationSucceedInThisCycle \u003d true;\n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n \n       LogAggregationReport report \u003d\n           Records.newRecord(LogAggregationReport.class);\n       report.setApplicationId(appId);\n       report.setDiagnosticMessage(diagnosticMessage);\n       report.setLogAggregationStatus(logAggregationSucceedInThisCycle\n           ? LogAggregationStatus.RUNNING\n           : LogAggregationStatus.RUNNING_WITH_FAILURE);\n       this.context.getLogAggregationStatusForApps().add(report);\n       if (appFinished) {\n         // If the app is finished, one extra final report with log aggregation\n         // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n         // that the log aggregation in this NM is completed.\n         LogAggregationReport finalReport \u003d\n             Records.newRecord(LogAggregationReport.class);\n         finalReport.setApplicationId(appId);\n         finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed\n             ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n         this.context.getLogAggregationStatusForApps().add(finalReport);\n       }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the ContainerLogAggregationPolicy.\n    // b) some set of running containers: For all the Running containers,\n    //    we use exitCode of 0 to find those which satisfy the\n    //    ContainerLogAggregationPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (Container container : this.context.getApplications()\n        .get(this.appId).getContainers().values()) {\n        ContainerType containerType \u003d\n            container.getContainerTokenIdentifier().getContainerType();\n        if (shouldUploadLogs(new ContainerLogContext(\n            container.getContainerId(), containerType, 0))) {\n          pendingContainerInThisCycle.add(container.getContainerId());\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          this.delService.delete(this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycle\n                  .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      String diagnosticMessage \u003d \"\";\n      boolean logAggregationSucceedInThisCycle \u003d true;\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n\n      LogAggregationReport report \u003d\n          Records.newRecord(LogAggregationReport.class);\n      report.setApplicationId(appId);\n      report.setDiagnosticMessage(diagnosticMessage);\n      report.setLogAggregationStatus(logAggregationSucceedInThisCycle\n          ? LogAggregationStatus.RUNNING\n          : LogAggregationStatus.RUNNING_WITH_FAILURE);\n      this.context.getLogAggregationStatusForApps().add(report);\n      if (appFinished) {\n        // If the app is finished, one extra final report with log aggregation\n        // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n        // that the log aggregation in this NM is completed.\n        LogAggregationReport finalReport \u003d\n            Records.newRecord(LogAggregationReport.class);\n        finalReport.setApplicationId(appId);\n        finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed\n            ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n        this.context.getLogAggregationStatusForApps().add(finalReport);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "b5cdf78e8e6cd6c5c1fb7286207dac72be32c0d6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3793. Several NPEs when deleting local files on NM recovery. Contributed by Varun Saxena\n",
      "commitDate": "01/07/15 2:13 PM",
      "commitName": "b5cdf78e8e6cd6c5c1fb7286207dac72be32c0d6",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "26/06/15 8:47 AM",
      "commitNameOld": "40b256949ad6f6e0dbdd248f2d257b05899f4332",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 5.23,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,161 +1,161 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n+          this.delService.delete(this.userUgi.getShortUserName(), null,\n+              uploadedFilePathsInThisCycle\n+                  .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n         }\n-        this.delService.delete(this.userUgi.getShortUserName(), null,\n-          uploadedFilePathsInThisCycle\n-            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n       long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + currentTime);\n \n       String diagnosticMessage \u003d \"\";\n       boolean logAggregationSucceedInThisCycle \u003d true;\n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n \n       LogAggregationReport report \u003d\n           Records.newRecord(LogAggregationReport.class);\n       report.setApplicationId(appId);\n       report.setDiagnosticMessage(diagnosticMessage);\n       report.setLogAggregationStatus(logAggregationSucceedInThisCycle\n           ? LogAggregationStatus.RUNNING\n           : LogAggregationStatus.RUNNING_WITH_FAILURE);\n       this.context.getLogAggregationStatusForApps().add(report);\n       if (appFinished) {\n         // If the app is finished, one extra final report with log aggregation\n         // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n         // that the log aggregation in this NM is completed.\n         LogAggregationReport finalReport \u003d\n             Records.newRecord(LogAggregationReport.class);\n         finalReport.setApplicationId(appId);\n         finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed\n             ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n         this.context.getLogAggregationStatusForApps().add(finalReport);\n       }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n          this.delService.delete(this.userUgi.getShortUserName(), null,\n              uploadedFilePathsInThisCycle\n                  .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n        }\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      String diagnosticMessage \u003d \"\";\n      boolean logAggregationSucceedInThisCycle \u003d true;\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n\n      LogAggregationReport report \u003d\n          Records.newRecord(LogAggregationReport.class);\n      report.setApplicationId(appId);\n      report.setDiagnosticMessage(diagnosticMessage);\n      report.setLogAggregationStatus(logAggregationSucceedInThisCycle\n          ? LogAggregationStatus.RUNNING\n          : LogAggregationStatus.RUNNING_WITH_FAILURE);\n      this.context.getLogAggregationStatusForApps().add(report);\n      if (appFinished) {\n        // If the app is finished, one extra final report with log aggregation\n        // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n        // that the log aggregation in this NM is completed.\n        LogAggregationReport finalReport \u003d\n            Records.newRecord(LogAggregationReport.class);\n        finalReport.setApplicationId(appId);\n        finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed\n            ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n        this.context.getLogAggregationStatusForApps().add(finalReport);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "03a293aed6de101b0cae1a294f506903addcaa75": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3505 addendum: fix an issue in previous patch.\n",
      "commitDate": "15/05/15 6:39 AM",
      "commitName": "03a293aed6de101b0cae1a294f506903addcaa75",
      "commitAuthor": "Junping Du",
      "commitDateOld": "14/05/15 10:58 AM",
      "commitNameOld": "15ccd967ee3e7046a50522089f67ba01f36ec76a",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.82,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,161 +1,161 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n         }\n         this.delService.delete(this.userUgi.getShortUserName(), null,\n           uploadedFilePathsInThisCycle\n             .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n       long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + currentTime);\n \n       String diagnosticMessage \u003d \"\";\n       boolean logAggregationSucceedInThisCycle \u003d true;\n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n         logAggregationSucceedInThisCycle \u003d false;\n       }\n \n       LogAggregationReport report \u003d\n           Records.newRecord(LogAggregationReport.class);\n       report.setApplicationId(appId);\n       report.setDiagnosticMessage(diagnosticMessage);\n       report.setLogAggregationStatus(logAggregationSucceedInThisCycle\n           ? LogAggregationStatus.RUNNING\n           : LogAggregationStatus.RUNNING_WITH_FAILURE);\n       this.context.getLogAggregationStatusForApps().add(report);\n       if (appFinished) {\n         // If the app is finished, one extra final report with log aggregation\n         // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n         // that the log aggregation in this NM is completed.\n         LogAggregationReport finalReport \u003d\n             Records.newRecord(LogAggregationReport.class);\n         finalReport.setApplicationId(appId);\n         finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed\n             ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n-        this.context.getLogAggregationStatusForApps().add(report);\n+        this.context.getLogAggregationStatusForApps().add(finalReport);\n       }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      String diagnosticMessage \u003d \"\";\n      boolean logAggregationSucceedInThisCycle \u003d true;\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n\n      LogAggregationReport report \u003d\n          Records.newRecord(LogAggregationReport.class);\n      report.setApplicationId(appId);\n      report.setDiagnosticMessage(diagnosticMessage);\n      report.setLogAggregationStatus(logAggregationSucceedInThisCycle\n          ? LogAggregationStatus.RUNNING\n          : LogAggregationStatus.RUNNING_WITH_FAILURE);\n      this.context.getLogAggregationStatusForApps().add(report);\n      if (appFinished) {\n        // If the app is finished, one extra final report with log aggregation\n        // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n        // that the log aggregation in this NM is completed.\n        LogAggregationReport finalReport \u003d\n            Records.newRecord(LogAggregationReport.class);\n        finalReport.setApplicationId(appId);\n        finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed\n            ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n        this.context.getLogAggregationStatusForApps().add(finalReport);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "15ccd967ee3e7046a50522089f67ba01f36ec76a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3505. Node\u0027s Log Aggregation Report with SUCCEED should not cached in RMApps. Contributed by Xuan Gong.\n",
      "commitDate": "14/05/15 10:58 AM",
      "commitName": "15ccd967ee3e7046a50522089f67ba01f36ec76a",
      "commitAuthor": "Junping Du",
      "commitDateOld": "08/05/15 3:45 PM",
      "commitNameOld": "25e2b02122c4ed760227ab33c49d3445c23b9276",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 5.8,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,152 +1,161 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n         }\n         this.delService.delete(this.userUgi.getShortUserName(), null,\n           uploadedFilePathsInThisCycle\n             .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n       long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + currentTime);\n \n       String diagnosticMessage \u003d \"\";\n+      boolean logAggregationSucceedInThisCycle \u003d true;\n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n+        logAggregationSucceedInThisCycle \u003d false;\n       }\n \n       LogAggregationReport report \u003d\n           Records.newRecord(LogAggregationReport.class);\n       report.setApplicationId(appId);\n-      report.setNodeId(nodeId);\n       report.setDiagnosticMessage(diagnosticMessage);\n-      if (appFinished) {\n-        report.setLogAggregationStatus(renameTemporaryLogFileFailed\n-            ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n-      } else {\n-        report.setLogAggregationStatus(LogAggregationStatus.RUNNING);\n-      }\n+      report.setLogAggregationStatus(logAggregationSucceedInThisCycle\n+          ? LogAggregationStatus.RUNNING\n+          : LogAggregationStatus.RUNNING_WITH_FAILURE);\n       this.context.getLogAggregationStatusForApps().add(report);\n+      if (appFinished) {\n+        // If the app is finished, one extra final report with log aggregation\n+        // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n+        // that the log aggregation in this NM is completed.\n+        LogAggregationReport finalReport \u003d\n+            Records.newRecord(LogAggregationReport.class);\n+        finalReport.setApplicationId(appId);\n+        finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed\n+            ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n+        this.context.getLogAggregationStatusForApps().add(report);\n+      }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      String diagnosticMessage \u003d \"\";\n      boolean logAggregationSucceedInThisCycle \u003d true;\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n        logAggregationSucceedInThisCycle \u003d false;\n      }\n\n      LogAggregationReport report \u003d\n          Records.newRecord(LogAggregationReport.class);\n      report.setApplicationId(appId);\n      report.setDiagnosticMessage(diagnosticMessage);\n      report.setLogAggregationStatus(logAggregationSucceedInThisCycle\n          ? LogAggregationStatus.RUNNING\n          : LogAggregationStatus.RUNNING_WITH_FAILURE);\n      this.context.getLogAggregationStatusForApps().add(report);\n      if (appFinished) {\n        // If the app is finished, one extra final report with log aggregation\n        // status SUCCEEDED/FAILED will be sent to RM to inform the RM\n        // that the log aggregation in this NM is completed.\n        LogAggregationReport finalReport \u003d\n            Records.newRecord(LogAggregationReport.class);\n        finalReport.setApplicationId(appId);\n        finalReport.setLogAggregationStatus(renameTemporaryLogFileFailed\n            ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n        this.context.getLogAggregationStatusForApps().add(report);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "1db355a875c3ecc40a244045c6812e00c8d36ef1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1402. Update related Web UI and CLI with exposing client API to check log aggregation status. Contributed by Xuan Gong.\n",
      "commitDate": "17/04/15 1:18 PM",
      "commitName": "1db355a875c3ecc40a244045c6812e00c8d36ef1",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/04/15 8:56 AM",
      "commitNameOld": "92431c961741747b5d6442f4025016d48d9a6863",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 7.18,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,152 +1,152 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n         }\n         this.delService.delete(this.userUgi.getShortUserName(), null,\n           uploadedFilePathsInThisCycle\n             .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n       long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + currentTime);\n \n       String diagnosticMessage \u003d \"\";\n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n         diagnosticMessage \u003d\n             \"Log uploaded successfully for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n         diagnosticMessage \u003d\n             \"Log uploaded failed for Application: \" + appId\n                 + \" in NodeManager: \"\n                 + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                 + Times.format(currentTime) + \"\\n\";\n         renameTemporaryLogFileFailed \u003d true;\n       }\n \n       LogAggregationReport report \u003d\n           Records.newRecord(LogAggregationReport.class);\n       report.setApplicationId(appId);\n       report.setNodeId(nodeId);\n       report.setDiagnosticMessage(diagnosticMessage);\n       if (appFinished) {\n         report.setLogAggregationStatus(renameTemporaryLogFileFailed\n-            ? LogAggregationStatus.FAILED : LogAggregationStatus.FINISHED);\n+            ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n       } else {\n         report.setLogAggregationStatus(LogAggregationStatus.RUNNING);\n       }\n       this.context.getLogAggregationStatusForApps().add(report);\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      String diagnosticMessage \u003d \"\";\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n      }\n\n      LogAggregationReport report \u003d\n          Records.newRecord(LogAggregationReport.class);\n      report.setApplicationId(appId);\n      report.setNodeId(nodeId);\n      report.setDiagnosticMessage(diagnosticMessage);\n      if (appFinished) {\n        report.setLogAggregationStatus(renameTemporaryLogFileFailed\n            ? LogAggregationStatus.FAILED : LogAggregationStatus.SUCCEEDED);\n      } else {\n        report.setLogAggregationStatus(LogAggregationStatus.RUNNING);\n      }\n      this.context.getLogAggregationStatusForApps().add(report);\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "92431c961741747b5d6442f4025016d48d9a6863": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1376. NM need to notify the log aggregation status to RM through Node heartbeat. Contributed by Xuan Gong.\n",
      "commitDate": "10/04/15 8:56 AM",
      "commitName": "92431c961741747b5d6442f4025016d48d9a6863",
      "commitAuthor": "Junping Du",
      "commitDateOld": "20/03/15 1:41 PM",
      "commitNameOld": "d81109e588493cef31e68508a3d671203bd23e12",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 20.8,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,152 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n         }\n         this.delService.delete(this.userUgi.getShortUserName(), null,\n           uploadedFilePathsInThisCycle\n             .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n+      long currentTime \u003d System.currentTimeMillis();\n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n-                    + System.currentTimeMillis());\n+                    + currentTime);\n \n+      String diagnosticMessage \u003d \"\";\n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n+        diagnosticMessage \u003d\n+            \"Log uploaded successfully for Application: \" + appId\n+                + \" in NodeManager: \"\n+                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n+                + Times.format(currentTime) + \"\\n\";\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n+        diagnosticMessage \u003d\n+            \"Log uploaded failed for Application: \" + appId\n+                + \" in NodeManager: \"\n+                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n+                + Times.format(currentTime) + \"\\n\";\n+        renameTemporaryLogFileFailed \u003d true;\n       }\n+\n+      LogAggregationReport report \u003d\n+          Records.newRecord(LogAggregationReport.class);\n+      report.setApplicationId(appId);\n+      report.setNodeId(nodeId);\n+      report.setDiagnosticMessage(diagnosticMessage);\n+      if (appFinished) {\n+        report.setLogAggregationStatus(renameTemporaryLogFileFailed\n+            ? LogAggregationStatus.FAILED : LogAggregationStatus.FINISHED);\n+      } else {\n+        report.setLogAggregationStatus(LogAggregationStatus.RUNNING);\n+      }\n+      this.context.getLogAggregationStatusForApps().add(report);\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      long currentTime \u003d System.currentTimeMillis();\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + currentTime);\n\n      String diagnosticMessage \u003d \"\";\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n        diagnosticMessage \u003d\n            \"Log uploaded successfully for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n        diagnosticMessage \u003d\n            \"Log uploaded failed for Application: \" + appId\n                + \" in NodeManager: \"\n                + LogAggregationUtils.getNodeString(nodeId) + \" at \"\n                + Times.format(currentTime) + \"\\n\";\n        renameTemporaryLogFileFailed \u003d true;\n      }\n\n      LogAggregationReport report \u003d\n          Records.newRecord(LogAggregationReport.class);\n      report.setApplicationId(appId);\n      report.setNodeId(nodeId);\n      report.setDiagnosticMessage(diagnosticMessage);\n      if (appFinished) {\n        report.setLogAggregationStatus(renameTemporaryLogFileFailed\n            ? LogAggregationStatus.FAILED : LogAggregationStatus.FINISHED);\n      } else {\n        report.setLogAggregationStatus(LogAggregationStatus.RUNNING);\n      }\n      this.context.getLogAggregationStatusForApps().add(report);\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "d81109e588493cef31e68508a3d671203bd23e12": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3269. Yarn.nodemanager.remote-app-log-dir could not be configured to fully qualified path. Contributed by Xuan Gong\n",
      "commitDate": "20/03/15 1:41 PM",
      "commitName": "d81109e588493cef31e68508a3d671203bd23e12",
      "commitAuthor": "Junping Du",
      "commitDateOld": "12/03/15 1:32 PM",
      "commitNameOld": "863079bb874ba77918ca1c0741eae10e245995c8",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.01,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,126 @@\n   private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n         }\n         this.delService.delete(this.userUgi.getShortUserName(), null,\n           uploadedFilePathsInThisCycle\n             .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + System.currentTimeMillis());\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n-            FileSystem remoteFS \u003d FileSystem.get(conf);\n+            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n       }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + System.currentTimeMillis());\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d remoteNodeLogFileForApp.getFileSystem(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "863079bb874ba77918ca1c0741eae10e245995c8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3154. Added additional APIs in LogAggregationContext to avoid aggregating running logs of application when rolling is enabled. Contributed by Xuan Gong.\n",
      "commitDate": "12/03/15 1:32 PM",
      "commitName": "863079bb874ba77918ca1c0741eae10e245995c8",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3154. Added additional APIs in LogAggregationContext to avoid aggregating running logs of application when rolling is enabled. Contributed by Xuan Gong.\n",
          "commitDate": "12/03/15 1:32 PM",
          "commitName": "863079bb874ba77918ca1c0741eae10e245995c8",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "20/02/15 2:02 PM",
          "commitNameOld": "f56c65bb3eb9436b67de2df63098e26589e70e56",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 19.94,
          "commitsBetweenForRepo": 149,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,126 +1,126 @@\n-  private void uploadLogsForContainers() {\n+  private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n-            aggregator.doContainerLogAggregation(writer);\n+            aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n         }\n         this.delService.delete(this.userUgi.getShortUserName(), null,\n           uploadedFilePathsInThisCycle\n             .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + System.currentTimeMillis());\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d FileSystem.get(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n       }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + System.currentTimeMillis());\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d FileSystem.get(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[appFinished-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3154. Added additional APIs in LogAggregationContext to avoid aggregating running logs of application when rolling is enabled. Contributed by Xuan Gong.\n",
          "commitDate": "12/03/15 1:32 PM",
          "commitName": "863079bb874ba77918ca1c0741eae10e245995c8",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "20/02/15 2:02 PM",
          "commitNameOld": "f56c65bb3eb9436b67de2df63098e26589e70e56",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 19.94,
          "commitsBetweenForRepo": 149,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,126 +1,126 @@\n-  private void uploadLogsForContainers() {\n+  private void uploadLogsForContainers(boolean appFinished) {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n-            aggregator.doContainerLogAggregation(writer);\n+            aggregator.doContainerLogAggregation(writer, appFinished);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n         }\n         this.delService.delete(this.userUgi.getShortUserName(), null,\n           uploadedFilePathsInThisCycle\n             .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + System.currentTimeMillis());\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d FileSystem.get(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n       }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void uploadLogsForContainers(boolean appFinished) {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer, appFinished);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + System.currentTimeMillis());\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d FileSystem.get(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "f56c65bb3eb9436b67de2df63098e26589e70e56": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3237. AppLogAggregatorImpl fails to log error cause. Contributed by\nRushabh S Shah\n",
      "commitDate": "20/02/15 2:02 PM",
      "commitName": "f56c65bb3eb9436b67de2df63098e26589e70e56",
      "commitAuthor": "Xuan",
      "commitDateOld": "15/02/15 6:46 AM",
      "commitNameOld": "ab0b958a522d502426b91b6e4ab6dd29caccc372",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 5.3,
      "commitsBetweenForRepo": 54,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,126 @@\n   private void uploadLogsForContainers() {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Adding new framework-token for \" + appId\n               + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n               + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n-            + \". Skip log upload this time. \");\n+            + \". Skip log upload this time. \", e1);\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n         }\n         this.delService.delete(this.userUgi.getShortUserName(), null,\n           uploadedFilePathsInThisCycle\n             .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + System.currentTimeMillis());\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d FileSystem.get(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n       }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers() {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \", e1);\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + System.currentTimeMillis());\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d FileSystem.get(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "be7bf956e96dd0fd9b521ca71df9124b9cc5ebd0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2794. Fixed log messages about distributing system-credentials. Contributed by Jian He.\n",
      "commitDate": "12/11/14 11:07 AM",
      "commitName": "be7bf956e96dd0fd9b521ca71df9124b9cc5ebd0",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "01/11/14 4:32 PM",
      "commitNameOld": "5c0381c96aa79196829edbca497c649eb6776944",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 10.82,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,126 @@\n   private void uploadLogsForContainers() {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials systemCredentials \u003d\n           context.getSystemCredentialsForApps().get(appId);\n       if (systemCredentials !\u003d null) {\n-        for (Token\u003c?\u003e token : systemCredentials.getAllTokens()) {\n-          LOG.info(\"Adding new framework-token for \" + appId\n-              + \" for log-aggregation: \" + token + \" user\u003d\" + userUgi);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Adding new framework-token for \" + appId\n+              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n+              + \"; userUgi\u003d\" + userUgi);\n         }\n         // this will replace old token\n         userUgi.addCredentials(systemCredentials);\n       }\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \");\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n         }\n         this.delService.delete(this.userUgi.getShortUserName(), null,\n           uploadedFilePathsInThisCycle\n             .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + System.currentTimeMillis());\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d FileSystem.get(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n       }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers() {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + systemCredentials.getAllTokens()\n              + \"; userUgi\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \");\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + System.currentTimeMillis());\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d FileSystem.get(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "5c0381c96aa79196829edbca497c649eb6776944": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2790. Fixed a NodeManager bug that was causing log-aggregation to fail beyond HFDS delegation-token expiry even when RM is a proxy-user (YARN-2704). Contributed by Jian He.\n",
      "commitDate": "01/11/14 4:32 PM",
      "commitName": "5c0381c96aa79196829edbca497c649eb6776944",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "21/10/14 10:31 AM",
      "commitNameOld": "6f2028bd1514d90b831f889fd0ee7f2ba5c15000",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 11.25,
      "commitsBetweenForRepo": 131,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,125 @@\n   private void uploadLogsForContainers() {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      Credentials systemCredentials \u003d\n+          context.getSystemCredentialsForApps().get(appId);\n+      if (systemCredentials !\u003d null) {\n+        for (Token\u003c?\u003e token : systemCredentials.getAllTokens()) {\n+          LOG.info(\"Adding new framework-token for \" + appId\n+              + \" for log-aggregation: \" + token + \" user\u003d\" + userUgi);\n+        }\n+        // this will replace old token\n+        userUgi.addCredentials(systemCredentials);\n+      }\n+    }\n+\n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \");\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n         }\n         this.delService.delete(this.userUgi.getShortUserName(), null,\n           uploadedFilePathsInThisCycle\n             .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n       // Before upload logs, make sure the number of existing logs\n       // is smaller than the configured NM log aggregation retention size.\n       if (uploadedLogsInThisCycle) {\n         cleanOldLogs();\n       }\n \n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n       final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + System.currentTimeMillis());\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d FileSystem.get(conf);\n             if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n               if (rename) {\n                 remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n               } else {\n                 remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n               }\n             }\n             return null;\n           }\n         });\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n       }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers() {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        for (Token\u003c?\u003e token : systemCredentials.getAllTokens()) {\n          LOG.info(\"Adding new framework-token for \" + appId\n              + \" for log-aggregation: \" + token + \" user\u003d\" + userUgi);\n        }\n        // this will replace old token\n        userUgi.addCredentials(systemCredentials);\n      }\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \");\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + System.currentTimeMillis());\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d FileSystem.get(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "cb81bac0029fce3a9726df3523f0b692cd3375b8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2583. Modified AggregatedLogDeletionService to be able to delete rolling aggregated logs. Contributed by Xuan Gong.\n",
      "commitDate": "10/10/14 12:11 AM",
      "commitName": "cb81bac0029fce3a9726df3523f0b692cd3375b8",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "03/10/14 12:15 PM",
      "commitNameOld": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.5,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,112 @@\n   private void uploadLogsForContainers() {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     // Create a set of Containers whose logs will be uploaded in this cycle.\n     // It includes:\n     // a) all containers in pendingContainers: those containers are finished\n     //    and satisfy the retentionPolicy.\n     // b) some set of running containers: For all the Running containers,\n     // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n     // so simply set wasContainerSuccessful as true to\n     // bypass FAILED_CONTAINERS check and find the running containers \n     // which satisfy the retentionPolicy.\n     Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n     this.pendingContainers.drainTo(pendingContainerInThisCycle);\n     Set\u003cContainerId\u003e finishedContainers \u003d\n         new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n     if (this.context.getApplications().get(this.appId) !\u003d null) {\n       for (ContainerId container : this.context.getApplications()\n         .get(this.appId).getContainers().keySet()) {\n         if (shouldUploadLogs(container, true)) {\n           pendingContainerInThisCycle.add(container);\n         }\n       }\n     }\n \n     LogWriter writer \u003d null;\n     try {\n       try {\n         writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n               this.userUgi);\n         // Write ACLs once when the writer is created.\n         writer.writeApplicationACLs(appAcls);\n         writer.writeApplicationOwner(this.userUgi.getShortUserName());\n \n       } catch (IOException e1) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Skip log upload this time. \");\n         return;\n       }\n \n       boolean uploadedLogsInThisCycle \u003d false;\n       for (ContainerId container : pendingContainerInThisCycle) {\n         ContainerLogAggregator aggregator \u003d null;\n         if (containerLogAggregators.containsKey(container)) {\n           aggregator \u003d containerLogAggregators.get(container);\n         } else {\n           aggregator \u003d new ContainerLogAggregator(container);\n           containerLogAggregators.put(container, aggregator);\n         }\n         Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n             aggregator.doContainerLogAggregation(writer);\n         if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n           uploadedLogsInThisCycle \u003d true;\n         }\n         this.delService.delete(this.userUgi.getShortUserName(), null,\n           uploadedFilePathsInThisCycle\n             .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n \n         // This container is finished, and all its logs have been uploaded,\n         // remove it from containerLogAggregators.\n         if (finishedContainers.contains(container)) {\n           containerLogAggregators.remove(container);\n         }\n       }\n \n+      // Before upload logs, make sure the number of existing logs\n+      // is smaller than the configured NM log aggregation retention size.\n+      if (uploadedLogsInThisCycle) {\n+        cleanOldLogs();\n+      }\n+\n       if (writer !\u003d null) {\n         writer.close();\n       }\n \n-      final Path renamedPath \u003d logAggregationContext \u003d\u003d null ||\n-          logAggregationContext.getRollingIntervalSeconds() \u003c\u003d 0\n+      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n               ? remoteNodeLogFileForApp : new Path(\n                 remoteNodeLogFileForApp.getParent(),\n                 remoteNodeLogFileForApp.getName() + \"_\"\n                     + System.currentTimeMillis());\n \n       final boolean rename \u003d uploadedLogsInThisCycle;\n       try {\n         userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n           @Override\n           public Object run() throws Exception {\n             FileSystem remoteFS \u003d FileSystem.get(conf);\n-            if (remoteFS.exists(remoteNodeTmpLogFileForApp)\n-                \u0026\u0026 rename) {\n-              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n+            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n+              if (rename) {\n+                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n+              } else {\n+                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n+              }\n             }\n             return null;\n           }\n         });\n       } catch (Exception e) {\n         LOG.error(\n           \"Failed to move temporary log file to final location: [\"\n               + remoteNodeTmpLogFileForApp + \"] to [\"\n               + renamedPath + \"]\", e);\n       }\n     } finally {\n       if (writer !\u003d null) {\n         writer.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainers() {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \");\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      // Before upload logs, make sure the number of existing logs\n      // is smaller than the configured NM log aggregation retention size.\n      if (uploadedLogsInThisCycle) {\n        cleanOldLogs();\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      final Path renamedPath \u003d this.rollingMonitorInterval \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + System.currentTimeMillis());\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d FileSystem.get(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)) {\n              if (rename) {\n                remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n              } else {\n                remoteFS.delete(remoteNodeTmpLogFileForApp, false);\n              }\n            }\n            return null;\n          }\n        });\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
      "commitDate": "03/10/14 12:15 PM",
      "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
          "commitDate": "03/10/14 12:15 PM",
          "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/08/14 3:56 AM",
          "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 52.35,
          "commitsBetweenForRepo": 563,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,104 @@\n-  private void uploadLogsForContainer(ContainerId containerId) {\n-\n+  private void uploadLogsForContainers() {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n-    // Lazy creation of the writer\n-    if (this.writer \u003d\u003d null) {\n-      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId\n-          + \" at \" + this.remoteNodeTmpLogFileForApp);\n-      try {\n-        this.writer \u003d\n-            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n-                this.userUgi);\n-        //Write ACLs once when and if the writer is created.\n-        this.writer.writeApplicationACLs(appAcls);\n-        this.writer.writeApplicationOwner(this.userUgi.getShortUserName());\n-      } catch (IOException e) {\n-        LOG.error(\"Cannot create writer for app \" + this.applicationId\n-            + \". Disabling log-aggregation for this app.\", e);\n-        this.logAggregationDisabled \u003d true;\n-        return;\n+    // Create a set of Containers whose logs will be uploaded in this cycle.\n+    // It includes:\n+    // a) all containers in pendingContainers: those containers are finished\n+    //    and satisfy the retentionPolicy.\n+    // b) some set of running containers: For all the Running containers,\n+    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n+    // so simply set wasContainerSuccessful as true to\n+    // bypass FAILED_CONTAINERS check and find the running containers \n+    // which satisfy the retentionPolicy.\n+    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n+    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n+    Set\u003cContainerId\u003e finishedContainers \u003d\n+        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n+    if (this.context.getApplications().get(this.appId) !\u003d null) {\n+      for (ContainerId container : this.context.getApplications()\n+        .get(this.appId).getContainers().keySet()) {\n+        if (shouldUploadLogs(container, true)) {\n+          pendingContainerInThisCycle.add(container);\n+        }\n       }\n     }\n \n-    LOG.info(\"Uploading logs for container \" + containerId\n-        + \". Current good log dirs are \"\n-        + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n-    LogKey logKey \u003d new LogKey(containerId);\n-    LogValue logValue \u003d\n-        new LogValue(dirsHandler.getLogDirs(), containerId,\n-          userUgi.getShortUserName());\n+    LogWriter writer \u003d null;\n     try {\n-      this.writer.append(logKey, logValue);\n-    } catch (IOException e) {\n-      LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n-          + \". Skipping this container.\");\n+      try {\n+        writer \u003d\n+            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n+              this.userUgi);\n+        // Write ACLs once when the writer is created.\n+        writer.writeApplicationACLs(appAcls);\n+        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n+\n+      } catch (IOException e1) {\n+        LOG.error(\"Cannot create writer for app \" + this.applicationId\n+            + \". Skip log upload this time. \");\n+        return;\n+      }\n+\n+      boolean uploadedLogsInThisCycle \u003d false;\n+      for (ContainerId container : pendingContainerInThisCycle) {\n+        ContainerLogAggregator aggregator \u003d null;\n+        if (containerLogAggregators.containsKey(container)) {\n+          aggregator \u003d containerLogAggregators.get(container);\n+        } else {\n+          aggregator \u003d new ContainerLogAggregator(container);\n+          containerLogAggregators.put(container, aggregator);\n+        }\n+        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n+            aggregator.doContainerLogAggregation(writer);\n+        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n+          uploadedLogsInThisCycle \u003d true;\n+        }\n+        this.delService.delete(this.userUgi.getShortUserName(), null,\n+          uploadedFilePathsInThisCycle\n+            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n+\n+        // This container is finished, and all its logs have been uploaded,\n+        // remove it from containerLogAggregators.\n+        if (finishedContainers.contains(container)) {\n+          containerLogAggregators.remove(container);\n+        }\n+      }\n+\n+      if (writer !\u003d null) {\n+        writer.close();\n+      }\n+\n+      final Path renamedPath \u003d logAggregationContext \u003d\u003d null ||\n+          logAggregationContext.getRollingIntervalSeconds() \u003c\u003d 0\n+              ? remoteNodeLogFileForApp : new Path(\n+                remoteNodeLogFileForApp.getParent(),\n+                remoteNodeLogFileForApp.getName() + \"_\"\n+                    + System.currentTimeMillis());\n+\n+      final boolean rename \u003d uploadedLogsInThisCycle;\n+      try {\n+        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+          @Override\n+          public Object run() throws Exception {\n+            FileSystem remoteFS \u003d FileSystem.get(conf);\n+            if (remoteFS.exists(remoteNodeTmpLogFileForApp)\n+                \u0026\u0026 rename) {\n+              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n+            }\n+            return null;\n+          }\n+        });\n+      } catch (Exception e) {\n+        LOG.error(\n+          \"Failed to move temporary log file to final location: [\"\n+              + remoteNodeTmpLogFileForApp + \"] to [\"\n+              + renamedPath + \"]\", e);\n+      }\n+    } finally {\n+      if (writer !\u003d null) {\n+        writer.close();\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void uploadLogsForContainers() {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \");\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      final Path renamedPath \u003d logAggregationContext \u003d\u003d null ||\n          logAggregationContext.getRollingIntervalSeconds() \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + System.currentTimeMillis());\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d FileSystem.get(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)\n                \u0026\u0026 rename) {\n              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n            }\n            return null;\n          }\n        });\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "uploadLogsForContainer",
            "newValue": "uploadLogsForContainers"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
          "commitDate": "03/10/14 12:15 PM",
          "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/08/14 3:56 AM",
          "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 52.35,
          "commitsBetweenForRepo": 563,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,104 @@\n-  private void uploadLogsForContainer(ContainerId containerId) {\n-\n+  private void uploadLogsForContainers() {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n-    // Lazy creation of the writer\n-    if (this.writer \u003d\u003d null) {\n-      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId\n-          + \" at \" + this.remoteNodeTmpLogFileForApp);\n-      try {\n-        this.writer \u003d\n-            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n-                this.userUgi);\n-        //Write ACLs once when and if the writer is created.\n-        this.writer.writeApplicationACLs(appAcls);\n-        this.writer.writeApplicationOwner(this.userUgi.getShortUserName());\n-      } catch (IOException e) {\n-        LOG.error(\"Cannot create writer for app \" + this.applicationId\n-            + \". Disabling log-aggregation for this app.\", e);\n-        this.logAggregationDisabled \u003d true;\n-        return;\n+    // Create a set of Containers whose logs will be uploaded in this cycle.\n+    // It includes:\n+    // a) all containers in pendingContainers: those containers are finished\n+    //    and satisfy the retentionPolicy.\n+    // b) some set of running containers: For all the Running containers,\n+    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n+    // so simply set wasContainerSuccessful as true to\n+    // bypass FAILED_CONTAINERS check and find the running containers \n+    // which satisfy the retentionPolicy.\n+    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n+    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n+    Set\u003cContainerId\u003e finishedContainers \u003d\n+        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n+    if (this.context.getApplications().get(this.appId) !\u003d null) {\n+      for (ContainerId container : this.context.getApplications()\n+        .get(this.appId).getContainers().keySet()) {\n+        if (shouldUploadLogs(container, true)) {\n+          pendingContainerInThisCycle.add(container);\n+        }\n       }\n     }\n \n-    LOG.info(\"Uploading logs for container \" + containerId\n-        + \". Current good log dirs are \"\n-        + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n-    LogKey logKey \u003d new LogKey(containerId);\n-    LogValue logValue \u003d\n-        new LogValue(dirsHandler.getLogDirs(), containerId,\n-          userUgi.getShortUserName());\n+    LogWriter writer \u003d null;\n     try {\n-      this.writer.append(logKey, logValue);\n-    } catch (IOException e) {\n-      LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n-          + \". Skipping this container.\");\n+      try {\n+        writer \u003d\n+            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n+              this.userUgi);\n+        // Write ACLs once when the writer is created.\n+        writer.writeApplicationACLs(appAcls);\n+        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n+\n+      } catch (IOException e1) {\n+        LOG.error(\"Cannot create writer for app \" + this.applicationId\n+            + \". Skip log upload this time. \");\n+        return;\n+      }\n+\n+      boolean uploadedLogsInThisCycle \u003d false;\n+      for (ContainerId container : pendingContainerInThisCycle) {\n+        ContainerLogAggregator aggregator \u003d null;\n+        if (containerLogAggregators.containsKey(container)) {\n+          aggregator \u003d containerLogAggregators.get(container);\n+        } else {\n+          aggregator \u003d new ContainerLogAggregator(container);\n+          containerLogAggregators.put(container, aggregator);\n+        }\n+        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n+            aggregator.doContainerLogAggregation(writer);\n+        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n+          uploadedLogsInThisCycle \u003d true;\n+        }\n+        this.delService.delete(this.userUgi.getShortUserName(), null,\n+          uploadedFilePathsInThisCycle\n+            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n+\n+        // This container is finished, and all its logs have been uploaded,\n+        // remove it from containerLogAggregators.\n+        if (finishedContainers.contains(container)) {\n+          containerLogAggregators.remove(container);\n+        }\n+      }\n+\n+      if (writer !\u003d null) {\n+        writer.close();\n+      }\n+\n+      final Path renamedPath \u003d logAggregationContext \u003d\u003d null ||\n+          logAggregationContext.getRollingIntervalSeconds() \u003c\u003d 0\n+              ? remoteNodeLogFileForApp : new Path(\n+                remoteNodeLogFileForApp.getParent(),\n+                remoteNodeLogFileForApp.getName() + \"_\"\n+                    + System.currentTimeMillis());\n+\n+      final boolean rename \u003d uploadedLogsInThisCycle;\n+      try {\n+        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+          @Override\n+          public Object run() throws Exception {\n+            FileSystem remoteFS \u003d FileSystem.get(conf);\n+            if (remoteFS.exists(remoteNodeTmpLogFileForApp)\n+                \u0026\u0026 rename) {\n+              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n+            }\n+            return null;\n+          }\n+        });\n+      } catch (Exception e) {\n+        LOG.error(\n+          \"Failed to move temporary log file to final location: [\"\n+              + remoteNodeTmpLogFileForApp + \"] to [\"\n+              + renamedPath + \"]\", e);\n+      }\n+    } finally {\n+      if (writer !\u003d null) {\n+        writer.close();\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void uploadLogsForContainers() {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \");\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      final Path renamedPath \u003d logAggregationContext \u003d\u003d null ||\n          logAggregationContext.getRollingIntervalSeconds() \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + System.currentTimeMillis());\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d FileSystem.get(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)\n                \u0026\u0026 rename) {\n              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n            }\n            return null;\n          }\n        });\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {
            "oldValue": "[containerId-ContainerId]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
          "commitDate": "03/10/14 12:15 PM",
          "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/08/14 3:56 AM",
          "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 52.35,
          "commitsBetweenForRepo": 563,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,104 @@\n-  private void uploadLogsForContainer(ContainerId containerId) {\n-\n+  private void uploadLogsForContainers() {\n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n-    // Lazy creation of the writer\n-    if (this.writer \u003d\u003d null) {\n-      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId\n-          + \" at \" + this.remoteNodeTmpLogFileForApp);\n-      try {\n-        this.writer \u003d\n-            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n-                this.userUgi);\n-        //Write ACLs once when and if the writer is created.\n-        this.writer.writeApplicationACLs(appAcls);\n-        this.writer.writeApplicationOwner(this.userUgi.getShortUserName());\n-      } catch (IOException e) {\n-        LOG.error(\"Cannot create writer for app \" + this.applicationId\n-            + \". Disabling log-aggregation for this app.\", e);\n-        this.logAggregationDisabled \u003d true;\n-        return;\n+    // Create a set of Containers whose logs will be uploaded in this cycle.\n+    // It includes:\n+    // a) all containers in pendingContainers: those containers are finished\n+    //    and satisfy the retentionPolicy.\n+    // b) some set of running containers: For all the Running containers,\n+    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n+    // so simply set wasContainerSuccessful as true to\n+    // bypass FAILED_CONTAINERS check and find the running containers \n+    // which satisfy the retentionPolicy.\n+    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n+    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n+    Set\u003cContainerId\u003e finishedContainers \u003d\n+        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n+    if (this.context.getApplications().get(this.appId) !\u003d null) {\n+      for (ContainerId container : this.context.getApplications()\n+        .get(this.appId).getContainers().keySet()) {\n+        if (shouldUploadLogs(container, true)) {\n+          pendingContainerInThisCycle.add(container);\n+        }\n       }\n     }\n \n-    LOG.info(\"Uploading logs for container \" + containerId\n-        + \". Current good log dirs are \"\n-        + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n-    LogKey logKey \u003d new LogKey(containerId);\n-    LogValue logValue \u003d\n-        new LogValue(dirsHandler.getLogDirs(), containerId,\n-          userUgi.getShortUserName());\n+    LogWriter writer \u003d null;\n     try {\n-      this.writer.append(logKey, logValue);\n-    } catch (IOException e) {\n-      LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n-          + \". Skipping this container.\");\n+      try {\n+        writer \u003d\n+            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n+              this.userUgi);\n+        // Write ACLs once when the writer is created.\n+        writer.writeApplicationACLs(appAcls);\n+        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n+\n+      } catch (IOException e1) {\n+        LOG.error(\"Cannot create writer for app \" + this.applicationId\n+            + \". Skip log upload this time. \");\n+        return;\n+      }\n+\n+      boolean uploadedLogsInThisCycle \u003d false;\n+      for (ContainerId container : pendingContainerInThisCycle) {\n+        ContainerLogAggregator aggregator \u003d null;\n+        if (containerLogAggregators.containsKey(container)) {\n+          aggregator \u003d containerLogAggregators.get(container);\n+        } else {\n+          aggregator \u003d new ContainerLogAggregator(container);\n+          containerLogAggregators.put(container, aggregator);\n+        }\n+        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n+            aggregator.doContainerLogAggregation(writer);\n+        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n+          uploadedLogsInThisCycle \u003d true;\n+        }\n+        this.delService.delete(this.userUgi.getShortUserName(), null,\n+          uploadedFilePathsInThisCycle\n+            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n+\n+        // This container is finished, and all its logs have been uploaded,\n+        // remove it from containerLogAggregators.\n+        if (finishedContainers.contains(container)) {\n+          containerLogAggregators.remove(container);\n+        }\n+      }\n+\n+      if (writer !\u003d null) {\n+        writer.close();\n+      }\n+\n+      final Path renamedPath \u003d logAggregationContext \u003d\u003d null ||\n+          logAggregationContext.getRollingIntervalSeconds() \u003c\u003d 0\n+              ? remoteNodeLogFileForApp : new Path(\n+                remoteNodeLogFileForApp.getParent(),\n+                remoteNodeLogFileForApp.getName() + \"_\"\n+                    + System.currentTimeMillis());\n+\n+      final boolean rename \u003d uploadedLogsInThisCycle;\n+      try {\n+        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+          @Override\n+          public Object run() throws Exception {\n+            FileSystem remoteFS \u003d FileSystem.get(conf);\n+            if (remoteFS.exists(remoteNodeTmpLogFileForApp)\n+                \u0026\u0026 rename) {\n+              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n+            }\n+            return null;\n+          }\n+        });\n+      } catch (Exception e) {\n+        LOG.error(\n+          \"Failed to move temporary log file to final location: [\"\n+              + remoteNodeTmpLogFileForApp + \"] to [\"\n+              + renamedPath + \"]\", e);\n+      }\n+    } finally {\n+      if (writer !\u003d null) {\n+        writer.close();\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void uploadLogsForContainers() {\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    // Create a set of Containers whose logs will be uploaded in this cycle.\n    // It includes:\n    // a) all containers in pendingContainers: those containers are finished\n    //    and satisfy the retentionPolicy.\n    // b) some set of running containers: For all the Running containers,\n    // we have ContainerLogsRetentionPolicy.AM_AND_FAILED_CONTAINERS_ONLY,\n    // so simply set wasContainerSuccessful as true to\n    // bypass FAILED_CONTAINERS check and find the running containers \n    // which satisfy the retentionPolicy.\n    Set\u003cContainerId\u003e pendingContainerInThisCycle \u003d new HashSet\u003cContainerId\u003e();\n    this.pendingContainers.drainTo(pendingContainerInThisCycle);\n    Set\u003cContainerId\u003e finishedContainers \u003d\n        new HashSet\u003cContainerId\u003e(pendingContainerInThisCycle);\n    if (this.context.getApplications().get(this.appId) !\u003d null) {\n      for (ContainerId container : this.context.getApplications()\n        .get(this.appId).getContainers().keySet()) {\n        if (shouldUploadLogs(container, true)) {\n          pendingContainerInThisCycle.add(container);\n        }\n      }\n    }\n\n    LogWriter writer \u003d null;\n    try {\n      try {\n        writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n              this.userUgi);\n        // Write ACLs once when the writer is created.\n        writer.writeApplicationACLs(appAcls);\n        writer.writeApplicationOwner(this.userUgi.getShortUserName());\n\n      } catch (IOException e1) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Skip log upload this time. \");\n        return;\n      }\n\n      boolean uploadedLogsInThisCycle \u003d false;\n      for (ContainerId container : pendingContainerInThisCycle) {\n        ContainerLogAggregator aggregator \u003d null;\n        if (containerLogAggregators.containsKey(container)) {\n          aggregator \u003d containerLogAggregators.get(container);\n        } else {\n          aggregator \u003d new ContainerLogAggregator(container);\n          containerLogAggregators.put(container, aggregator);\n        }\n        Set\u003cPath\u003e uploadedFilePathsInThisCycle \u003d\n            aggregator.doContainerLogAggregation(writer);\n        if (uploadedFilePathsInThisCycle.size() \u003e 0) {\n          uploadedLogsInThisCycle \u003d true;\n        }\n        this.delService.delete(this.userUgi.getShortUserName(), null,\n          uploadedFilePathsInThisCycle\n            .toArray(new Path[uploadedFilePathsInThisCycle.size()]));\n\n        // This container is finished, and all its logs have been uploaded,\n        // remove it from containerLogAggregators.\n        if (finishedContainers.contains(container)) {\n          containerLogAggregators.remove(container);\n        }\n      }\n\n      if (writer !\u003d null) {\n        writer.close();\n      }\n\n      final Path renamedPath \u003d logAggregationContext \u003d\u003d null ||\n          logAggregationContext.getRollingIntervalSeconds() \u003c\u003d 0\n              ? remoteNodeLogFileForApp : new Path(\n                remoteNodeLogFileForApp.getParent(),\n                remoteNodeLogFileForApp.getName() + \"_\"\n                    + System.currentTimeMillis());\n\n      final boolean rename \u003d uploadedLogsInThisCycle;\n      try {\n        userUgi.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n          @Override\n          public Object run() throws Exception {\n            FileSystem remoteFS \u003d FileSystem.get(conf);\n            if (remoteFS.exists(remoteNodeTmpLogFileForApp)\n                \u0026\u0026 rename) {\n              remoteFS.rename(remoteNodeTmpLogFileForApp, renamedPath);\n            }\n            return null;\n          }\n        });\n      } catch (Exception e) {\n        LOG.error(\n          \"Failed to move temporary log file to final location: [\"\n              + remoteNodeTmpLogFileForApp + \"] to [\"\n              + renamedPath + \"]\", e);\n      }\n    } finally {\n      if (writer !\u003d null) {\n        writer.close();\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "5420f287ccc83df69b6725942754c82b89e46b3e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-578. Fixed NM to use SecureIOUtils for reading and aggregating logs. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1487672 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/05/13 4:14 PM",
      "commitName": "5420f287ccc83df69b6725942754c82b89e46b3e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "19/11/12 8:41 AM",
      "commitNameOld": "f0a6d06485102ae6a58c46ee0b3b0aac8fcc0d74",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 191.27,
      "commitsBetweenForRepo": 998,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,39 @@\n   private void uploadLogsForContainer(ContainerId containerId) {\n \n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     // Lazy creation of the writer\n     if (this.writer \u003d\u003d null) {\n       LOG.info(\"Starting aggregate log-file for app \" + this.applicationId\n           + \" at \" + this.remoteNodeTmpLogFileForApp);\n       try {\n         this.writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n                 this.userUgi);\n         //Write ACLs once when and if the writer is created.\n         this.writer.writeApplicationACLs(appAcls);\n         this.writer.writeApplicationOwner(this.userUgi.getShortUserName());\n       } catch (IOException e) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Disabling log-aggregation for this app.\", e);\n         this.logAggregationDisabled \u003d true;\n         return;\n       }\n     }\n \n     LOG.info(\"Uploading logs for container \" + containerId\n         + \". Current good log dirs are \"\n         + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n     LogKey logKey \u003d new LogKey(containerId);\n-    LogValue logValue \u003d new LogValue(dirsHandler.getLogDirs(), containerId);\n+    LogValue logValue \u003d\n+        new LogValue(dirsHandler.getLogDirs(), containerId,\n+          userUgi.getShortUserName());\n     try {\n       this.writer.append(logKey, logValue);\n     } catch (IOException e) {\n       LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n           + \". Skipping this container.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainer(ContainerId containerId) {\n\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    // Lazy creation of the writer\n    if (this.writer \u003d\u003d null) {\n      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId\n          + \" at \" + this.remoteNodeTmpLogFileForApp);\n      try {\n        this.writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n                this.userUgi);\n        //Write ACLs once when and if the writer is created.\n        this.writer.writeApplicationACLs(appAcls);\n        this.writer.writeApplicationOwner(this.userUgi.getShortUserName());\n      } catch (IOException e) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Disabling log-aggregation for this app.\", e);\n        this.logAggregationDisabled \u003d true;\n        return;\n      }\n    }\n\n    LOG.info(\"Uploading logs for container \" + containerId\n        + \". Current good log dirs are \"\n        + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n    LogKey logKey \u003d new LogKey(containerId);\n    LogValue logValue \u003d\n        new LogValue(dirsHandler.getLogDirs(), containerId,\n          userUgi.getShortUserName());\n    try {\n      this.writer.append(logKey, logValue);\n    } catch (IOException e) {\n      LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n          + \". Skipping this container.\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void uploadLogsForContainer(ContainerId containerId) {\n\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    // Lazy creation of the writer\n    if (this.writer \u003d\u003d null) {\n      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId\n          + \" at \" + this.remoteNodeTmpLogFileForApp);\n      try {\n        this.writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n                this.userUgi);\n        //Write ACLs once when and if the writer is created.\n        this.writer.writeApplicationACLs(appAcls);\n        this.writer.writeApplicationOwner(this.userUgi.getShortUserName());\n      } catch (IOException e) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Disabling log-aggregation for this app.\", e);\n        this.logAggregationDisabled \u003d true;\n        return;\n      }\n    }\n\n    LOG.info(\"Uploading logs for container \" + containerId\n        + \". Current good log dirs are \"\n        + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n    LogKey logKey \u003d new LogKey(containerId);\n    LogValue logValue \u003d new LogValue(dirsHandler.getLogDirs(), containerId);\n    try {\n      this.writer.append(logKey, logValue);\n    } catch (IOException e) {\n      LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n          + \". Skipping this container.\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java"
      }
    },
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/11 3:17 PM",
      "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "03/11/11 1:02 AM",
      "commitNameOld": "c27601fefebd0af887a12d684bfc6f90d9fc0321",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 26.64,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,37 @@\n   private void uploadLogsForContainer(ContainerId containerId) {\n \n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     // Lazy creation of the writer\n     if (this.writer \u003d\u003d null) {\n       LOG.info(\"Starting aggregate log-file for app \" + this.applicationId\n           + \" at \" + this.remoteNodeTmpLogFileForApp);\n       try {\n         this.writer \u003d\n             new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n                 this.userUgi);\n         //Write ACLs once when and if the writer is created.\n         this.writer.writeApplicationACLs(appAcls);\n         this.writer.writeApplicationOwner(this.userUgi.getShortUserName());\n       } catch (IOException e) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Disabling log-aggregation for this app.\", e);\n         this.logAggregationDisabled \u003d true;\n         return;\n       }\n     }\n \n-    LOG.info(\"Uploading logs for container \" + containerId);\n+    LOG.info(\"Uploading logs for container \" + containerId\n+        + \". Current good log dirs are \"\n+        + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n     LogKey logKey \u003d new LogKey(containerId);\n-    LogValue logValue \u003d new LogValue(this.rootLogDirs, containerId);\n+    LogValue logValue \u003d new LogValue(dirsHandler.getLogDirs(), containerId);\n     try {\n       this.writer.append(logKey, logValue);\n     } catch (IOException e) {\n       LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n           + \". Skipping this container.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainer(ContainerId containerId) {\n\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    // Lazy creation of the writer\n    if (this.writer \u003d\u003d null) {\n      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId\n          + \" at \" + this.remoteNodeTmpLogFileForApp);\n      try {\n        this.writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n                this.userUgi);\n        //Write ACLs once when and if the writer is created.\n        this.writer.writeApplicationACLs(appAcls);\n        this.writer.writeApplicationOwner(this.userUgi.getShortUserName());\n      } catch (IOException e) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Disabling log-aggregation for this app.\", e);\n        this.logAggregationDisabled \u003d true;\n        return;\n      }\n    }\n\n    LOG.info(\"Uploading logs for container \" + containerId\n        + \". Current good log dirs are \"\n        + StringUtils.join(\",\", dirsHandler.getLogDirs()));\n    LogKey logKey \u003d new LogKey(containerId);\n    LogValue logValue \u003d new LogValue(dirsHandler.getLogDirs(), containerId);\n    try {\n      this.writer.append(logKey, logValue);\n    } catch (IOException e) {\n      LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n          + \". Skipping this container.\");\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2989. Modified JobHistory to link to task and AM logs from the JobHistoryServer. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 11:45 PM",
      "commitName": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 64.27,
      "commitsBetweenForRepo": 481,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,35 @@\n   private void uploadLogsForContainer(ContainerId containerId) {\n \n     if (this.logAggregationDisabled) {\n       return;\n     }\n \n     // Lazy creation of the writer\n     if (this.writer \u003d\u003d null) {\n-      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId);\n+      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId\n+          + \" at \" + this.remoteNodeTmpLogFileForApp);\n       try {\n         this.writer \u003d\n-            new LogWriter(this.conf, this.remoteNodeLogFileForApp,\n+            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n                 this.userUgi);\n+        //Write ACLs once when and if the writer is created.\n+        this.writer.writeApplicationACLs(appAcls);\n+        this.writer.writeApplicationOwner(this.userUgi.getShortUserName());\n       } catch (IOException e) {\n         LOG.error(\"Cannot create writer for app \" + this.applicationId\n             + \". Disabling log-aggregation for this app.\", e);\n         this.logAggregationDisabled \u003d true;\n         return;\n       }\n     }\n \n     LOG.info(\"Uploading logs for container \" + containerId);\n     LogKey logKey \u003d new LogKey(containerId);\n     LogValue logValue \u003d new LogValue(this.rootLogDirs, containerId);\n     try {\n       this.writer.append(logKey, logValue);\n     } catch (IOException e) {\n       LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n           + \". Skipping this container.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainer(ContainerId containerId) {\n\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    // Lazy creation of the writer\n    if (this.writer \u003d\u003d null) {\n      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId\n          + \" at \" + this.remoteNodeTmpLogFileForApp);\n      try {\n        this.writer \u003d\n            new LogWriter(this.conf, this.remoteNodeTmpLogFileForApp,\n                this.userUgi);\n        //Write ACLs once when and if the writer is created.\n        this.writer.writeApplicationACLs(appAcls);\n        this.writer.writeApplicationOwner(this.userUgi.getShortUserName());\n      } catch (IOException e) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Disabling log-aggregation for this app.\", e);\n        this.logAggregationDisabled \u003d true;\n        return;\n      }\n    }\n\n    LOG.info(\"Uploading logs for container \" + containerId);\n    LogKey logKey \u003d new LogKey(containerId);\n    LogValue logValue \u003d new LogValue(this.rootLogDirs, containerId);\n    try {\n      this.writer.append(logKey, logValue);\n    } catch (IOException e) {\n      LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n          + \". Skipping this container.\");\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void uploadLogsForContainer(ContainerId containerId) {\n\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    // Lazy creation of the writer\n    if (this.writer \u003d\u003d null) {\n      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId);\n      try {\n        this.writer \u003d\n            new LogWriter(this.conf, this.remoteNodeLogFileForApp,\n                this.userUgi);\n      } catch (IOException e) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Disabling log-aggregation for this app.\", e);\n        this.logAggregationDisabled \u003d true;\n        return;\n      }\n    }\n\n    LOG.info(\"Uploading logs for container \" + containerId);\n    LogKey logKey \u003d new LogKey(containerId);\n    LogValue logValue \u003d new LogValue(this.rootLogDirs, containerId);\n    try {\n      this.writer.append(logKey, logValue);\n    } catch (IOException e) {\n      LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n          + \". Skipping this container.\");\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,31 @@\n+  private void uploadLogsForContainer(ContainerId containerId) {\n+\n+    if (this.logAggregationDisabled) {\n+      return;\n+    }\n+\n+    // Lazy creation of the writer\n+    if (this.writer \u003d\u003d null) {\n+      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId);\n+      try {\n+        this.writer \u003d\n+            new LogWriter(this.conf, this.remoteNodeLogFileForApp,\n+                this.userUgi);\n+      } catch (IOException e) {\n+        LOG.error(\"Cannot create writer for app \" + this.applicationId\n+            + \". Disabling log-aggregation for this app.\", e);\n+        this.logAggregationDisabled \u003d true;\n+        return;\n+      }\n+    }\n+\n+    LOG.info(\"Uploading logs for container \" + containerId);\n+    LogKey logKey \u003d new LogKey(containerId);\n+    LogValue logValue \u003d new LogValue(this.rootLogDirs, containerId);\n+    try {\n+      this.writer.append(logKey, logValue);\n+    } catch (IOException e) {\n+      LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n+          + \". Skipping this container.\");\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void uploadLogsForContainer(ContainerId containerId) {\n\n    if (this.logAggregationDisabled) {\n      return;\n    }\n\n    // Lazy creation of the writer\n    if (this.writer \u003d\u003d null) {\n      LOG.info(\"Starting aggregate log-file for app \" + this.applicationId);\n      try {\n        this.writer \u003d\n            new LogWriter(this.conf, this.remoteNodeLogFileForApp,\n                this.userUgi);\n      } catch (IOException e) {\n        LOG.error(\"Cannot create writer for app \" + this.applicationId\n            + \". Disabling log-aggregation for this app.\", e);\n        this.logAggregationDisabled \u003d true;\n        return;\n      }\n    }\n\n    LOG.info(\"Uploading logs for container \" + containerId);\n    LogKey logKey \u003d new LogKey(containerId);\n    LogValue logValue \u003d new LogValue(this.rootLogDirs, containerId);\n    try {\n      this.writer.append(logKey, logValue);\n    } catch (IOException e) {\n      LOG.error(\"Couldn\u0027t upload logs for \" + containerId\n          + \". Skipping this container.\");\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java"
    }
  }
}