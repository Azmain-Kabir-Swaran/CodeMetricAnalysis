{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FastByteComparisons.java",
  "functionName": "compareTo",
  "functionId": "compareTo___buffer1-byte[]__offset1-int__length1-int__buffer2-byte[]__offset2-int__length2-int",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/FastByteComparisons.java",
  "functionStartLine": 189,
  "functionEndLine": 242,
  "numCommitsSeen": 5,
  "timeTaken": 1251,
  "changeHistory": [
    "ddbff7c8d3f1851e5c5fa9bc33637e859d7d8ccf",
    "0e75187199076b7fc5a448bb8a143d3ae32838d3"
  ],
  "changeHistoryShort": {
    "ddbff7c8d3f1851e5c5fa9bc33637e859d7d8ccf": "Ybodychange",
    "0e75187199076b7fc5a448bb8a143d3ae32838d3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ddbff7c8d3f1851e5c5fa9bc33637e859d7d8ccf": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14313. Replace/improve Hadoop\u0027s byte[] comparator. Contributed by Vikas Vishwakarma.\n",
      "commitDate": "27/06/18 10:58 PM",
      "commitName": "ddbff7c8d3f1851e5c5fa9bc33637e859d7d8ccf",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "17/07/17 9:32 PM",
      "commitNameOld": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 345.06,
      "commitsBetweenForRepo": 3145,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,54 @@\n       public int compareTo(byte[] buffer1, int offset1, int length1,\n           byte[] buffer2, int offset2, int length2) {\n         // Short circuit equal case\n         if (buffer1 \u003d\u003d buffer2 \u0026\u0026\n             offset1 \u003d\u003d offset2 \u0026\u0026\n             length1 \u003d\u003d length2) {\n           return 0;\n         }\n+        final int stride \u003d 8;\n         int minLength \u003d Math.min(length1, length2);\n-        int minWords \u003d minLength / Longs.BYTES;\n+        int strideLimit \u003d minLength \u0026 ~(stride - 1);\n         int offset1Adj \u003d offset1 + BYTE_ARRAY_BASE_OFFSET;\n         int offset2Adj \u003d offset2 + BYTE_ARRAY_BASE_OFFSET;\n+        int i;\n \n         /*\n          * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes at a\n          * time is no slower than comparing 4 bytes at a time even on 32-bit.\n          * On the other hand, it is substantially faster on 64-bit.\n          */\n-        for (int i \u003d 0; i \u003c minWords * Longs.BYTES; i +\u003d Longs.BYTES) {\n+        for (i \u003d 0; i \u003c strideLimit; i +\u003d stride) {\n           long lw \u003d theUnsafe.getLong(buffer1, offset1Adj + (long) i);\n           long rw \u003d theUnsafe.getLong(buffer2, offset2Adj + (long) i);\n-          long diff \u003d lw ^ rw;\n \n-          if (diff !\u003d 0) {\n+          if (lw !\u003d rw) {\n             if (!littleEndian) {\n               return lessThanUnsigned(lw, rw) ? -1 : 1;\n             }\n \n-            // Use binary search\n-            int n \u003d 0;\n-            int y;\n-            int x \u003d (int) diff;\n-            if (x \u003d\u003d 0) {\n-              x \u003d (int) (diff \u003e\u003e\u003e 32);\n-              n \u003d 32;\n-            }\n-\n-            y \u003d x \u003c\u003c 16;\n-            if (y \u003d\u003d 0) {\n-              n +\u003d 16;\n-            } else {\n-              x \u003d y;\n-            }\n-\n-            y \u003d x \u003c\u003c 8;\n-            if (y \u003d\u003d 0) {\n-              n +\u003d 8;\n-            }\n-            return (int) (((lw \u003e\u003e\u003e n) \u0026 0xFFL) - ((rw \u003e\u003e\u003e n) \u0026 0xFFL));\n+            /*\n+             * We want to compare only the first index where left[index] !\u003d\n+             * right[index]. This corresponds to the least significant nonzero\n+             * byte in lw ^ rw, since lw and rw are little-endian.\n+             * Long.numberOfTrailingZeros(diff) tells us the least significant\n+             * nonzero bit, and zeroing out the first three bits of L.nTZ gives\n+             * us the shift to get that least significant nonzero byte. This\n+             * comparison logic is based on UnsignedBytes from Guava v21\n+             */\n+            int n \u003d Long.numberOfTrailingZeros(lw ^ rw) \u0026 ~0x7;\n+            return ((int) ((lw \u003e\u003e\u003e n) \u0026 0xFF)) - ((int) ((rw \u003e\u003e\u003e n) \u0026 0xFF));\n           }\n         }\n \n         // The epilogue to cover the last (minLength % 8) elements.\n-        for (int i \u003d minWords * Longs.BYTES; i \u003c minLength; i++) {\n+        for (; i \u003c minLength; i++) {\n           int result \u003d UnsignedBytes.compare(\n               buffer1[offset1 + i],\n               buffer2[offset2 + i]);\n           if (result !\u003d 0) {\n             return result;\n           }\n         }\n         return length1 - length2;\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public int compareTo(byte[] buffer1, int offset1, int length1,\n          byte[] buffer2, int offset2, int length2) {\n        // Short circuit equal case\n        if (buffer1 \u003d\u003d buffer2 \u0026\u0026\n            offset1 \u003d\u003d offset2 \u0026\u0026\n            length1 \u003d\u003d length2) {\n          return 0;\n        }\n        final int stride \u003d 8;\n        int minLength \u003d Math.min(length1, length2);\n        int strideLimit \u003d minLength \u0026 ~(stride - 1);\n        int offset1Adj \u003d offset1 + BYTE_ARRAY_BASE_OFFSET;\n        int offset2Adj \u003d offset2 + BYTE_ARRAY_BASE_OFFSET;\n        int i;\n\n        /*\n         * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes at a\n         * time is no slower than comparing 4 bytes at a time even on 32-bit.\n         * On the other hand, it is substantially faster on 64-bit.\n         */\n        for (i \u003d 0; i \u003c strideLimit; i +\u003d stride) {\n          long lw \u003d theUnsafe.getLong(buffer1, offset1Adj + (long) i);\n          long rw \u003d theUnsafe.getLong(buffer2, offset2Adj + (long) i);\n\n          if (lw !\u003d rw) {\n            if (!littleEndian) {\n              return lessThanUnsigned(lw, rw) ? -1 : 1;\n            }\n\n            /*\n             * We want to compare only the first index where left[index] !\u003d\n             * right[index]. This corresponds to the least significant nonzero\n             * byte in lw ^ rw, since lw and rw are little-endian.\n             * Long.numberOfTrailingZeros(diff) tells us the least significant\n             * nonzero bit, and zeroing out the first three bits of L.nTZ gives\n             * us the shift to get that least significant nonzero byte. This\n             * comparison logic is based on UnsignedBytes from Guava v21\n             */\n            int n \u003d Long.numberOfTrailingZeros(lw ^ rw) \u0026 ~0x7;\n            return ((int) ((lw \u003e\u003e\u003e n) \u0026 0xFF)) - ((int) ((rw \u003e\u003e\u003e n) \u0026 0xFF));\n          }\n        }\n\n        // The epilogue to cover the last (minLength % 8) elements.\n        for (; i \u003c minLength; i++) {\n          int result \u003d UnsignedBytes.compare(\n              buffer1[offset1 + i],\n              buffer2[offset2 + i]);\n          if (result !\u003d 0) {\n            return result;\n          }\n        }\n        return length1 - length2;\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/FastByteComparisons.java",
      "extendedDetails": {}
    },
    "0e75187199076b7fc5a448bb8a143d3ae32838d3": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7761. Improve the performance of raw comparisons. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189613 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/11 10:59 PM",
      "commitName": "0e75187199076b7fc5a448bb8a143d3ae32838d3",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,63 @@\n+      public int compareTo(byte[] buffer1, int offset1, int length1,\n+          byte[] buffer2, int offset2, int length2) {\n+        // Short circuit equal case\n+        if (buffer1 \u003d\u003d buffer2 \u0026\u0026\n+            offset1 \u003d\u003d offset2 \u0026\u0026\n+            length1 \u003d\u003d length2) {\n+          return 0;\n+        }\n+        int minLength \u003d Math.min(length1, length2);\n+        int minWords \u003d minLength / Longs.BYTES;\n+        int offset1Adj \u003d offset1 + BYTE_ARRAY_BASE_OFFSET;\n+        int offset2Adj \u003d offset2 + BYTE_ARRAY_BASE_OFFSET;\n+\n+        /*\n+         * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes at a\n+         * time is no slower than comparing 4 bytes at a time even on 32-bit.\n+         * On the other hand, it is substantially faster on 64-bit.\n+         */\n+        for (int i \u003d 0; i \u003c minWords * Longs.BYTES; i +\u003d Longs.BYTES) {\n+          long lw \u003d theUnsafe.getLong(buffer1, offset1Adj + (long) i);\n+          long rw \u003d theUnsafe.getLong(buffer2, offset2Adj + (long) i);\n+          long diff \u003d lw ^ rw;\n+\n+          if (diff !\u003d 0) {\n+            if (!littleEndian) {\n+              return lessThanUnsigned(lw, rw) ? -1 : 1;\n+            }\n+\n+            // Use binary search\n+            int n \u003d 0;\n+            int y;\n+            int x \u003d (int) diff;\n+            if (x \u003d\u003d 0) {\n+              x \u003d (int) (diff \u003e\u003e\u003e 32);\n+              n \u003d 32;\n+            }\n+\n+            y \u003d x \u003c\u003c 16;\n+            if (y \u003d\u003d 0) {\n+              n +\u003d 16;\n+            } else {\n+              x \u003d y;\n+            }\n+\n+            y \u003d x \u003c\u003c 8;\n+            if (y \u003d\u003d 0) {\n+              n +\u003d 8;\n+            }\n+            return (int) (((lw \u003e\u003e\u003e n) \u0026 0xFFL) - ((rw \u003e\u003e\u003e n) \u0026 0xFFL));\n+          }\n+        }\n+\n+        // The epilogue to cover the last (minLength % 8) elements.\n+        for (int i \u003d minWords * Longs.BYTES; i \u003c minLength; i++) {\n+          int result \u003d UnsignedBytes.compare(\n+              buffer1[offset1 + i],\n+              buffer2[offset2 + i]);\n+          if (result !\u003d 0) {\n+            return result;\n+          }\n+        }\n+        return length1 - length2;\n+      }\n\\ No newline at end of file\n",
      "actualSource": "      public int compareTo(byte[] buffer1, int offset1, int length1,\n          byte[] buffer2, int offset2, int length2) {\n        // Short circuit equal case\n        if (buffer1 \u003d\u003d buffer2 \u0026\u0026\n            offset1 \u003d\u003d offset2 \u0026\u0026\n            length1 \u003d\u003d length2) {\n          return 0;\n        }\n        int minLength \u003d Math.min(length1, length2);\n        int minWords \u003d minLength / Longs.BYTES;\n        int offset1Adj \u003d offset1 + BYTE_ARRAY_BASE_OFFSET;\n        int offset2Adj \u003d offset2 + BYTE_ARRAY_BASE_OFFSET;\n\n        /*\n         * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes at a\n         * time is no slower than comparing 4 bytes at a time even on 32-bit.\n         * On the other hand, it is substantially faster on 64-bit.\n         */\n        for (int i \u003d 0; i \u003c minWords * Longs.BYTES; i +\u003d Longs.BYTES) {\n          long lw \u003d theUnsafe.getLong(buffer1, offset1Adj + (long) i);\n          long rw \u003d theUnsafe.getLong(buffer2, offset2Adj + (long) i);\n          long diff \u003d lw ^ rw;\n\n          if (diff !\u003d 0) {\n            if (!littleEndian) {\n              return lessThanUnsigned(lw, rw) ? -1 : 1;\n            }\n\n            // Use binary search\n            int n \u003d 0;\n            int y;\n            int x \u003d (int) diff;\n            if (x \u003d\u003d 0) {\n              x \u003d (int) (diff \u003e\u003e\u003e 32);\n              n \u003d 32;\n            }\n\n            y \u003d x \u003c\u003c 16;\n            if (y \u003d\u003d 0) {\n              n +\u003d 16;\n            } else {\n              x \u003d y;\n            }\n\n            y \u003d x \u003c\u003c 8;\n            if (y \u003d\u003d 0) {\n              n +\u003d 8;\n            }\n            return (int) (((lw \u003e\u003e\u003e n) \u0026 0xFFL) - ((rw \u003e\u003e\u003e n) \u0026 0xFFL));\n          }\n        }\n\n        // The epilogue to cover the last (minLength % 8) elements.\n        for (int i \u003d minWords * Longs.BYTES; i \u003c minLength; i++) {\n          int result \u003d UnsignedBytes.compare(\n              buffer1[offset1 + i],\n              buffer2[offset2 + i]);\n          if (result !\u003d 0) {\n            return result;\n          }\n        }\n        return length1 - length2;\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/FastByteComparisons.java"
    }
  }
}