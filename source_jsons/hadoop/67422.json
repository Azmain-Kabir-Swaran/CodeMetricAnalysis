{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "HadoopArchives.java",
  "functionName": "run",
  "functionId": "run___args-String[]",
  "sourceFilePath": "hadoop-tools/hadoop-archives/src/main/java/org/apache/hadoop/tools/HadoopArchives.java",
  "functionStartLine": 820,
  "functionEndLine": 915,
  "numCommitsSeen": 18,
  "timeTaken": 5307,
  "changeHistory": [
    "87f29c6b8acc07cc011713a79554d51945e265ac",
    "92c38e41e1fffb9d60d4fa5d4d2212777af9e9a5",
    "ea1c6f31c2d2ea5b38ed57e2aa241d122103a721",
    "594dd9eb259220f6e18acfd939f1b95fbdb04c37",
    "0201be46c298e94176ec6297e9d9cdba3afc2bbd",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "87f29c6b8acc07cc011713a79554d51945e265ac": "Ybodychange",
    "92c38e41e1fffb9d60d4fa5d4d2212777af9e9a5": "Ybodychange",
    "ea1c6f31c2d2ea5b38ed57e2aa241d122103a721": "Ybodychange",
    "594dd9eb259220f6e18acfd939f1b95fbdb04c37": "Ybodychange",
    "0201be46c298e94176ec6297e9d9cdba3afc2bbd": "Yfilerename",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "87f29c6b8acc07cc011713a79554d51945e265ac": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12214. Parse \u0027HadoopArchive\u0027 commandline using cli Options. (Contributed by Vinayakumar B)\n",
      "commitDate": "21/07/15 12:42 AM",
      "commitName": "87f29c6b8acc07cc011713a79554d51945e265ac",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "13/05/15 1:28 AM",
      "commitNameOld": "92c38e41e1fffb9d60d4fa5d4d2212777af9e9a5",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 68.97,
      "commitsBetweenForRepo": 470,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,96 @@\n   public int run(String[] args) throws Exception {\n     try {\n-      Path parentPath \u003d null;\n-      List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n-      Path destPath \u003d null;\n-      String archiveName \u003d null;\n-      if (args.length \u003c 5) {\n-        System.out.println(usage);\n-        throw new IOException(\"Invalid usage.\");\n+      // Parse CLI options\n+      Options options \u003d new Options();\n+      options.addOption(ARCHIVE_NAME, true,\n+          \"Name of the Archive. This is mandatory option\");\n+      options.addOption(PARENT_PATH, true,\n+          \"Parent path of sources. This is mandatory option\");\n+      options.addOption(REPLICATION, true, \"Replication factor archive files\");\n+      options.addOption(HELP, false, \"Show the usage\");\n+      Parser parser \u003d new GnuParser();\n+      CommandLine commandLine \u003d parser.parse(options, args, true);\n+\n+      if (commandLine.hasOption(HELP)) {\n+        printUsage(options, true);\n+        return 0;\n       }\n-      if (!\"-archiveName\".equals(args[0])) {\n-        System.out.println(usage);\n+      if (!commandLine.hasOption(ARCHIVE_NAME)) {\n+        printUsage(options, false);\n         throw new IOException(\"Archive Name not specified.\");\n       }\n-      archiveName \u003d args[1];\n+      String archiveName \u003d commandLine.getOptionValue(ARCHIVE_NAME);\n       if (!checkValidName(archiveName)) {\n-        System.out.println(usage);\n+        printUsage(options, false);\n         throw new IOException(\"Invalid name for archives. \" + archiveName);\n       }\n-      int i \u003d 2;\n       //check to see if relative parent has been provided or not\n       //this is a required parameter. \n-      if (! \"-p\".equals(args[i])) {\n-        System.out.println(usage);\n+      if (!commandLine.hasOption(PARENT_PATH)) {\n+        printUsage(options, false);\n         throw new IOException(\"Parent path not specified.\");\n       }\n-      parentPath \u003d new Path(args[i+1]);\n+      Path parentPath \u003d new Path(commandLine.getOptionValue(PARENT_PATH));\n       if (!parentPath.isAbsolute()) {\n-        parentPath\u003d parentPath.getFileSystem(getConf()).makeQualified(parentPath);\n+        parentPath \u003d parentPath.getFileSystem(getConf()).makeQualified(\n+            parentPath);\n       }\n \n-      i+\u003d2;\n-\n-      if (\"-r\".equals(args[i])) {\n-        repl \u003d Short.parseShort(args[i+1]);\n-        i+\u003d2;\n+      if (commandLine.hasOption(REPLICATION)) {\n+        repl \u003d Short.parseShort(commandLine.getOptionValue(REPLICATION));\n       }\n+      // Remaining args\n+      args \u003d commandLine.getArgs();\n+      List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n+      Path destPath \u003d null;\n       //read the rest of the paths\n-      for (; i \u003c args.length; i++) {\n+      for (int i \u003d 0; i \u003c args.length; i++) {\n         if (i \u003d\u003d (args.length - 1)) {\n           destPath \u003d new Path(args[i]);\n           if (!destPath.isAbsolute()) {\n             destPath \u003d destPath.getFileSystem(getConf()).makeQualified(destPath);\n           }\n         }\n         else {\n           Path argPath \u003d new Path(args[i]);\n           if (argPath.isAbsolute()) {\n-            System.out.println(usage);\n+            printUsage(options, false);\n             throw new IOException(\"Source path \" + argPath +\n                 \" is not relative to \"+ parentPath);\n           }\n           srcPaths.add(new Path(parentPath, argPath));\n         }\n       }\n+      if (destPath \u003d\u003d null) {\n+        printUsage(options, false);\n+        throw new IOException(\"Destination path not specified.\");\n+      }\n       if (srcPaths.size() \u003d\u003d 0) {\n         // assuming if the user does not specify path for sources\n         // the whole parent directory needs to be archived. \n         srcPaths.add(parentPath);\n       }\n       // do a glob on the srcPaths and then pass it on\n       List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n       for (Path p: srcPaths) {\n         FileSystem fs \u003d p.getFileSystem(getConf());\n         FileStatus[] statuses \u003d fs.globStatus(p);\n         if (statuses !\u003d null) {\n           for (FileStatus status: statuses) {\n             globPaths.add(fs.makeQualified(status.getPath()));\n           }\n         }\n       }\n       if (globPaths.isEmpty()) {\n         throw new IOException(\"The resolved paths set is empty.\"\n             + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n             + srcPaths);\n       }\n \n       archive(parentPath, globPaths, archiveName, destPath);\n     } catch(IOException ie) {\n       System.err.println(ie.getLocalizedMessage());\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      // Parse CLI options\n      Options options \u003d new Options();\n      options.addOption(ARCHIVE_NAME, true,\n          \"Name of the Archive. This is mandatory option\");\n      options.addOption(PARENT_PATH, true,\n          \"Parent path of sources. This is mandatory option\");\n      options.addOption(REPLICATION, true, \"Replication factor archive files\");\n      options.addOption(HELP, false, \"Show the usage\");\n      Parser parser \u003d new GnuParser();\n      CommandLine commandLine \u003d parser.parse(options, args, true);\n\n      if (commandLine.hasOption(HELP)) {\n        printUsage(options, true);\n        return 0;\n      }\n      if (!commandLine.hasOption(ARCHIVE_NAME)) {\n        printUsage(options, false);\n        throw new IOException(\"Archive Name not specified.\");\n      }\n      String archiveName \u003d commandLine.getOptionValue(ARCHIVE_NAME);\n      if (!checkValidName(archiveName)) {\n        printUsage(options, false);\n        throw new IOException(\"Invalid name for archives. \" + archiveName);\n      }\n      //check to see if relative parent has been provided or not\n      //this is a required parameter. \n      if (!commandLine.hasOption(PARENT_PATH)) {\n        printUsage(options, false);\n        throw new IOException(\"Parent path not specified.\");\n      }\n      Path parentPath \u003d new Path(commandLine.getOptionValue(PARENT_PATH));\n      if (!parentPath.isAbsolute()) {\n        parentPath \u003d parentPath.getFileSystem(getConf()).makeQualified(\n            parentPath);\n      }\n\n      if (commandLine.hasOption(REPLICATION)) {\n        repl \u003d Short.parseShort(commandLine.getOptionValue(REPLICATION));\n      }\n      // Remaining args\n      args \u003d commandLine.getArgs();\n      List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n      Path destPath \u003d null;\n      //read the rest of the paths\n      for (int i \u003d 0; i \u003c args.length; i++) {\n        if (i \u003d\u003d (args.length - 1)) {\n          destPath \u003d new Path(args[i]);\n          if (!destPath.isAbsolute()) {\n            destPath \u003d destPath.getFileSystem(getConf()).makeQualified(destPath);\n          }\n        }\n        else {\n          Path argPath \u003d new Path(args[i]);\n          if (argPath.isAbsolute()) {\n            printUsage(options, false);\n            throw new IOException(\"Source path \" + argPath +\n                \" is not relative to \"+ parentPath);\n          }\n          srcPaths.add(new Path(parentPath, argPath));\n        }\n      }\n      if (destPath \u003d\u003d null) {\n        printUsage(options, false);\n        throw new IOException(\"Destination path not specified.\");\n      }\n      if (srcPaths.size() \u003d\u003d 0) {\n        // assuming if the user does not specify path for sources\n        // the whole parent directory needs to be archived. \n        srcPaths.add(parentPath);\n      }\n      // do a glob on the srcPaths and then pass it on\n      List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n      for (Path p: srcPaths) {\n        FileSystem fs \u003d p.getFileSystem(getConf());\n        FileStatus[] statuses \u003d fs.globStatus(p);\n        if (statuses !\u003d null) {\n          for (FileStatus status: statuses) {\n            globPaths.add(fs.makeQualified(status.getPath()));\n          }\n        }\n      }\n      if (globPaths.isEmpty()) {\n        throw new IOException(\"The resolved paths set is empty.\"\n            + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n            + srcPaths);\n      }\n\n      archive(parentPath, globPaths, archiveName, destPath);\n    } catch(IOException ie) {\n      System.err.println(ie.getLocalizedMessage());\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-tools/hadoop-archives/src/main/java/org/apache/hadoop/tools/HadoopArchives.java",
      "extendedDetails": {}
    },
    "92c38e41e1fffb9d60d4fa5d4d2212777af9e9a5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9723. Improve error message when hadoop archive output path already exists. Contributed by Jean-Baptiste Onofr√© and Yongjun Zhang.\n",
      "commitDate": "13/05/15 1:28 AM",
      "commitName": "92c38e41e1fffb9d60d4fa5d4d2212777af9e9a5",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "27/03/15 11:28 PM",
      "commitNameOld": "27d49e6714ad7fc6038bc001e70ff5be3755f1ef",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 46.08,
      "commitsBetweenForRepo": 467,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n   public int run(String[] args) throws Exception {\n     try {\n       Path parentPath \u003d null;\n       List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n       Path destPath \u003d null;\n       String archiveName \u003d null;\n       if (args.length \u003c 5) {\n         System.out.println(usage);\n         throw new IOException(\"Invalid usage.\");\n       }\n       if (!\"-archiveName\".equals(args[0])) {\n         System.out.println(usage);\n         throw new IOException(\"Archive Name not specified.\");\n       }\n       archiveName \u003d args[1];\n       if (!checkValidName(archiveName)) {\n         System.out.println(usage);\n         throw new IOException(\"Invalid name for archives. \" + archiveName);\n       }\n       int i \u003d 2;\n       //check to see if relative parent has been provided or not\n       //this is a required parameter. \n       if (! \"-p\".equals(args[i])) {\n         System.out.println(usage);\n         throw new IOException(\"Parent path not specified.\");\n       }\n       parentPath \u003d new Path(args[i+1]);\n       if (!parentPath.isAbsolute()) {\n         parentPath\u003d parentPath.getFileSystem(getConf()).makeQualified(parentPath);\n       }\n \n       i+\u003d2;\n \n       if (\"-r\".equals(args[i])) {\n         repl \u003d Short.parseShort(args[i+1]);\n         i+\u003d2;\n       }\n       //read the rest of the paths\n       for (; i \u003c args.length; i++) {\n         if (i \u003d\u003d (args.length - 1)) {\n           destPath \u003d new Path(args[i]);\n           if (!destPath.isAbsolute()) {\n             destPath \u003d destPath.getFileSystem(getConf()).makeQualified(destPath);\n           }\n         }\n         else {\n           Path argPath \u003d new Path(args[i]);\n           if (argPath.isAbsolute()) {\n             System.out.println(usage);\n-            throw new IOException(\"source path \" + argPath +\n-                \" is not relative  to \"+ parentPath);\n+            throw new IOException(\"Source path \" + argPath +\n+                \" is not relative to \"+ parentPath);\n           }\n           srcPaths.add(new Path(parentPath, argPath));\n         }\n       }\n       if (srcPaths.size() \u003d\u003d 0) {\n         // assuming if the user does not specify path for sources\n         // the whole parent directory needs to be archived. \n         srcPaths.add(parentPath);\n       }\n       // do a glob on the srcPaths and then pass it on\n       List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n       for (Path p: srcPaths) {\n         FileSystem fs \u003d p.getFileSystem(getConf());\n         FileStatus[] statuses \u003d fs.globStatus(p);\n         if (statuses !\u003d null) {\n           for (FileStatus status: statuses) {\n             globPaths.add(fs.makeQualified(status.getPath()));\n           }\n         }\n       }\n       if (globPaths.isEmpty()) {\n         throw new IOException(\"The resolved paths set is empty.\"\n             + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n             + srcPaths);\n       }\n \n       archive(parentPath, globPaths, archiveName, destPath);\n     } catch(IOException ie) {\n       System.err.println(ie.getLocalizedMessage());\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      Path parentPath \u003d null;\n      List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n      Path destPath \u003d null;\n      String archiveName \u003d null;\n      if (args.length \u003c 5) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid usage.\");\n      }\n      if (!\"-archiveName\".equals(args[0])) {\n        System.out.println(usage);\n        throw new IOException(\"Archive Name not specified.\");\n      }\n      archiveName \u003d args[1];\n      if (!checkValidName(archiveName)) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid name for archives. \" + archiveName);\n      }\n      int i \u003d 2;\n      //check to see if relative parent has been provided or not\n      //this is a required parameter. \n      if (! \"-p\".equals(args[i])) {\n        System.out.println(usage);\n        throw new IOException(\"Parent path not specified.\");\n      }\n      parentPath \u003d new Path(args[i+1]);\n      if (!parentPath.isAbsolute()) {\n        parentPath\u003d parentPath.getFileSystem(getConf()).makeQualified(parentPath);\n      }\n\n      i+\u003d2;\n\n      if (\"-r\".equals(args[i])) {\n        repl \u003d Short.parseShort(args[i+1]);\n        i+\u003d2;\n      }\n      //read the rest of the paths\n      for (; i \u003c args.length; i++) {\n        if (i \u003d\u003d (args.length - 1)) {\n          destPath \u003d new Path(args[i]);\n          if (!destPath.isAbsolute()) {\n            destPath \u003d destPath.getFileSystem(getConf()).makeQualified(destPath);\n          }\n        }\n        else {\n          Path argPath \u003d new Path(args[i]);\n          if (argPath.isAbsolute()) {\n            System.out.println(usage);\n            throw new IOException(\"Source path \" + argPath +\n                \" is not relative to \"+ parentPath);\n          }\n          srcPaths.add(new Path(parentPath, argPath));\n        }\n      }\n      if (srcPaths.size() \u003d\u003d 0) {\n        // assuming if the user does not specify path for sources\n        // the whole parent directory needs to be archived. \n        srcPaths.add(parentPath);\n      }\n      // do a glob on the srcPaths and then pass it on\n      List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n      for (Path p: srcPaths) {\n        FileSystem fs \u003d p.getFileSystem(getConf());\n        FileStatus[] statuses \u003d fs.globStatus(p);\n        if (statuses !\u003d null) {\n          for (FileStatus status: statuses) {\n            globPaths.add(fs.makeQualified(status.getPath()));\n          }\n        }\n      }\n      if (globPaths.isEmpty()) {\n        throw new IOException(\"The resolved paths set is empty.\"\n            + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n            + srcPaths);\n      }\n\n      archive(parentPath, globPaths, archiveName, destPath);\n    } catch(IOException ie) {\n      System.err.println(ie.getLocalizedMessage());\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-tools/hadoop-archives/src/main/java/org/apache/hadoop/tools/HadoopArchives.java",
      "extendedDetails": {}
    },
    "ea1c6f31c2d2ea5b38ed57e2aa241d122103a721": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11021. Configurable replication factor in the hadoop archive command. Contributed by Zhe Zhang.\n",
      "commitDate": "29/08/14 2:44 PM",
      "commitName": "ea1c6f31c2d2ea5b38ed57e2aa241d122103a721",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "14/08/14 1:28 PM",
      "commitNameOld": "399e428deb6a4aafff20bfff6a2fd0acfd21366a",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 15.05,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,84 @@\n   public int run(String[] args) throws Exception {\n     try {\n       Path parentPath \u003d null;\n       List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n       Path destPath \u003d null;\n       String archiveName \u003d null;\n       if (args.length \u003c 5) {\n         System.out.println(usage);\n         throw new IOException(\"Invalid usage.\");\n       }\n       if (!\"-archiveName\".equals(args[0])) {\n         System.out.println(usage);\n         throw new IOException(\"Archive Name not specified.\");\n       }\n       archiveName \u003d args[1];\n       if (!checkValidName(archiveName)) {\n         System.out.println(usage);\n         throw new IOException(\"Invalid name for archives. \" + archiveName);\n       }\n       int i \u003d 2;\n       //check to see if relative parent has been provided or not\n       //this is a required parameter. \n       if (! \"-p\".equals(args[i])) {\n         System.out.println(usage);\n         throw new IOException(\"Parent path not specified.\");\n       }\n       parentPath \u003d new Path(args[i+1]);\n       if (!parentPath.isAbsolute()) {\n         parentPath\u003d parentPath.getFileSystem(getConf()).makeQualified(parentPath);\n       }\n \n       i+\u003d2;\n+\n+      if (\"-r\".equals(args[i])) {\n+        repl \u003d Short.parseShort(args[i+1]);\n+        i+\u003d2;\n+      }\n       //read the rest of the paths\n       for (; i \u003c args.length; i++) {\n         if (i \u003d\u003d (args.length - 1)) {\n           destPath \u003d new Path(args[i]);\n           if (!destPath.isAbsolute()) {\n             destPath \u003d destPath.getFileSystem(getConf()).makeQualified(destPath);\n           }\n         }\n         else {\n           Path argPath \u003d new Path(args[i]);\n           if (argPath.isAbsolute()) {\n             System.out.println(usage);\n             throw new IOException(\"source path \" + argPath +\n                 \" is not relative  to \"+ parentPath);\n           }\n           srcPaths.add(new Path(parentPath, argPath));\n         }\n       }\n       if (srcPaths.size() \u003d\u003d 0) {\n         // assuming if the user does not specify path for sources\n         // the whole parent directory needs to be archived. \n         srcPaths.add(parentPath);\n       }\n       // do a glob on the srcPaths and then pass it on\n       List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n       for (Path p: srcPaths) {\n         FileSystem fs \u003d p.getFileSystem(getConf());\n         FileStatus[] statuses \u003d fs.globStatus(p);\n         if (statuses !\u003d null) {\n           for (FileStatus status: statuses) {\n             globPaths.add(fs.makeQualified(status.getPath()));\n           }\n         }\n       }\n       if (globPaths.isEmpty()) {\n         throw new IOException(\"The resolved paths set is empty.\"\n             + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n             + srcPaths);\n       }\n \n       archive(parentPath, globPaths, archiveName, destPath);\n     } catch(IOException ie) {\n       System.err.println(ie.getLocalizedMessage());\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      Path parentPath \u003d null;\n      List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n      Path destPath \u003d null;\n      String archiveName \u003d null;\n      if (args.length \u003c 5) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid usage.\");\n      }\n      if (!\"-archiveName\".equals(args[0])) {\n        System.out.println(usage);\n        throw new IOException(\"Archive Name not specified.\");\n      }\n      archiveName \u003d args[1];\n      if (!checkValidName(archiveName)) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid name for archives. \" + archiveName);\n      }\n      int i \u003d 2;\n      //check to see if relative parent has been provided or not\n      //this is a required parameter. \n      if (! \"-p\".equals(args[i])) {\n        System.out.println(usage);\n        throw new IOException(\"Parent path not specified.\");\n      }\n      parentPath \u003d new Path(args[i+1]);\n      if (!parentPath.isAbsolute()) {\n        parentPath\u003d parentPath.getFileSystem(getConf()).makeQualified(parentPath);\n      }\n\n      i+\u003d2;\n\n      if (\"-r\".equals(args[i])) {\n        repl \u003d Short.parseShort(args[i+1]);\n        i+\u003d2;\n      }\n      //read the rest of the paths\n      for (; i \u003c args.length; i++) {\n        if (i \u003d\u003d (args.length - 1)) {\n          destPath \u003d new Path(args[i]);\n          if (!destPath.isAbsolute()) {\n            destPath \u003d destPath.getFileSystem(getConf()).makeQualified(destPath);\n          }\n        }\n        else {\n          Path argPath \u003d new Path(args[i]);\n          if (argPath.isAbsolute()) {\n            System.out.println(usage);\n            throw new IOException(\"source path \" + argPath +\n                \" is not relative  to \"+ parentPath);\n          }\n          srcPaths.add(new Path(parentPath, argPath));\n        }\n      }\n      if (srcPaths.size() \u003d\u003d 0) {\n        // assuming if the user does not specify path for sources\n        // the whole parent directory needs to be archived. \n        srcPaths.add(parentPath);\n      }\n      // do a glob on the srcPaths and then pass it on\n      List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n      for (Path p: srcPaths) {\n        FileSystem fs \u003d p.getFileSystem(getConf());\n        FileStatus[] statuses \u003d fs.globStatus(p);\n        if (statuses !\u003d null) {\n          for (FileStatus status: statuses) {\n            globPaths.add(fs.makeQualified(status.getPath()));\n          }\n        }\n      }\n      if (globPaths.isEmpty()) {\n        throw new IOException(\"The resolved paths set is empty.\"\n            + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n            + srcPaths);\n      }\n\n      archive(parentPath, globPaths, archiveName, destPath);\n    } catch(IOException ie) {\n      System.err.println(ie.getLocalizedMessage());\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-tools/hadoop-archives/src/main/java/org/apache/hadoop/tools/HadoopArchives.java",
      "extendedDetails": {}
    },
    "594dd9eb259220f6e18acfd939f1b95fbdb04c37": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3082. Archive command take wrong path for input file with current directory (John George via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1309453 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/04/12 8:28 AM",
      "commitName": "594dd9eb259220f6e18acfd939f1b95fbdb04c37",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "13/12/11 12:17 PM",
      "commitNameOld": "0201be46c298e94176ec6297e9d9cdba3afc2bbd",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 112.8,
      "commitsBetweenForRepo": 811,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,79 @@\n   public int run(String[] args) throws Exception {\n     try {\n       Path parentPath \u003d null;\n       List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n       Path destPath \u003d null;\n       String archiveName \u003d null;\n       if (args.length \u003c 5) {\n         System.out.println(usage);\n         throw new IOException(\"Invalid usage.\");\n       }\n       if (!\"-archiveName\".equals(args[0])) {\n         System.out.println(usage);\n         throw new IOException(\"Archive Name not specified.\");\n       }\n       archiveName \u003d args[1];\n       if (!checkValidName(archiveName)) {\n         System.out.println(usage);\n         throw new IOException(\"Invalid name for archives. \" + archiveName);\n       }\n       int i \u003d 2;\n       //check to see if relative parent has been provided or not\n       //this is a required parameter. \n       if (! \"-p\".equals(args[i])) {\n         System.out.println(usage);\n         throw new IOException(\"Parent path not specified.\");\n       }\n       parentPath \u003d new Path(args[i+1]);\n+      if (!parentPath.isAbsolute()) {\n+        parentPath\u003d parentPath.getFileSystem(getConf()).makeQualified(parentPath);\n+      }\n+\n       i+\u003d2;\n       //read the rest of the paths\n       for (; i \u003c args.length; i++) {\n         if (i \u003d\u003d (args.length - 1)) {\n           destPath \u003d new Path(args[i]);\n+          if (!destPath.isAbsolute()) {\n+            destPath \u003d destPath.getFileSystem(getConf()).makeQualified(destPath);\n+          }\n         }\n         else {\n           Path argPath \u003d new Path(args[i]);\n           if (argPath.isAbsolute()) {\n             System.out.println(usage);\n             throw new IOException(\"source path \" + argPath +\n                 \" is not relative  to \"+ parentPath);\n           }\n           srcPaths.add(new Path(parentPath, argPath));\n         }\n       }\n       if (srcPaths.size() \u003d\u003d 0) {\n         // assuming if the user does not specify path for sources\n         // the whole parent directory needs to be archived. \n         srcPaths.add(parentPath);\n       }\n       // do a glob on the srcPaths and then pass it on\n       List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n       for (Path p: srcPaths) {\n         FileSystem fs \u003d p.getFileSystem(getConf());\n         FileStatus[] statuses \u003d fs.globStatus(p);\n         if (statuses !\u003d null) {\n           for (FileStatus status: statuses) {\n             globPaths.add(fs.makeQualified(status.getPath()));\n           }\n         }\n       }\n       if (globPaths.isEmpty()) {\n         throw new IOException(\"The resolved paths set is empty.\"\n             + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n             + srcPaths);\n       }\n \n       archive(parentPath, globPaths, archiveName, destPath);\n     } catch(IOException ie) {\n       System.err.println(ie.getLocalizedMessage());\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      Path parentPath \u003d null;\n      List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n      Path destPath \u003d null;\n      String archiveName \u003d null;\n      if (args.length \u003c 5) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid usage.\");\n      }\n      if (!\"-archiveName\".equals(args[0])) {\n        System.out.println(usage);\n        throw new IOException(\"Archive Name not specified.\");\n      }\n      archiveName \u003d args[1];\n      if (!checkValidName(archiveName)) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid name for archives. \" + archiveName);\n      }\n      int i \u003d 2;\n      //check to see if relative parent has been provided or not\n      //this is a required parameter. \n      if (! \"-p\".equals(args[i])) {\n        System.out.println(usage);\n        throw new IOException(\"Parent path not specified.\");\n      }\n      parentPath \u003d new Path(args[i+1]);\n      if (!parentPath.isAbsolute()) {\n        parentPath\u003d parentPath.getFileSystem(getConf()).makeQualified(parentPath);\n      }\n\n      i+\u003d2;\n      //read the rest of the paths\n      for (; i \u003c args.length; i++) {\n        if (i \u003d\u003d (args.length - 1)) {\n          destPath \u003d new Path(args[i]);\n          if (!destPath.isAbsolute()) {\n            destPath \u003d destPath.getFileSystem(getConf()).makeQualified(destPath);\n          }\n        }\n        else {\n          Path argPath \u003d new Path(args[i]);\n          if (argPath.isAbsolute()) {\n            System.out.println(usage);\n            throw new IOException(\"source path \" + argPath +\n                \" is not relative  to \"+ parentPath);\n          }\n          srcPaths.add(new Path(parentPath, argPath));\n        }\n      }\n      if (srcPaths.size() \u003d\u003d 0) {\n        // assuming if the user does not specify path for sources\n        // the whole parent directory needs to be archived. \n        srcPaths.add(parentPath);\n      }\n      // do a glob on the srcPaths and then pass it on\n      List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n      for (Path p: srcPaths) {\n        FileSystem fs \u003d p.getFileSystem(getConf());\n        FileStatus[] statuses \u003d fs.globStatus(p);\n        if (statuses !\u003d null) {\n          for (FileStatus status: statuses) {\n            globPaths.add(fs.makeQualified(status.getPath()));\n          }\n        }\n      }\n      if (globPaths.isEmpty()) {\n        throw new IOException(\"The resolved paths set is empty.\"\n            + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n            + srcPaths);\n      }\n\n      archive(parentPath, globPaths, archiveName, destPath);\n    } catch(IOException ie) {\n      System.err.println(ie.getLocalizedMessage());\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-tools/hadoop-archives/src/main/java/org/apache/hadoop/tools/HadoopArchives.java",
      "extendedDetails": {}
    },
    "0201be46c298e94176ec6297e9d9cdba3afc2bbd": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7810. move hadoop archive to core from tools. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1213907 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 12:17 PM",
      "commitName": "0201be46c298e94176ec6297e9d9cdba3afc2bbd",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "13/12/11 10:07 AM",
      "commitNameOld": "f2f4e9341387199e04679ebc8de5e05c0fdbd437",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      Path parentPath \u003d null;\n      List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n      Path destPath \u003d null;\n      String archiveName \u003d null;\n      if (args.length \u003c 5) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid usage.\");\n      }\n      if (!\"-archiveName\".equals(args[0])) {\n        System.out.println(usage);\n        throw new IOException(\"Archive Name not specified.\");\n      }\n      archiveName \u003d args[1];\n      if (!checkValidName(archiveName)) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid name for archives. \" + archiveName);\n      }\n      int i \u003d 2;\n      //check to see if relative parent has been provided or not\n      //this is a required parameter. \n      if (! \"-p\".equals(args[i])) {\n        System.out.println(usage);\n        throw new IOException(\"Parent path not specified.\");\n      }\n      parentPath \u003d new Path(args[i+1]);\n      i+\u003d2;\n      //read the rest of the paths\n      for (; i \u003c args.length; i++) {\n        if (i \u003d\u003d (args.length - 1)) {\n          destPath \u003d new Path(args[i]);\n        }\n        else {\n          Path argPath \u003d new Path(args[i]);\n          if (argPath.isAbsolute()) {\n            System.out.println(usage);\n            throw new IOException(\"source path \" + argPath +\n                \" is not relative  to \"+ parentPath);\n          }\n          srcPaths.add(new Path(parentPath, argPath));\n        }\n      }\n      if (srcPaths.size() \u003d\u003d 0) {\n        // assuming if the user does not specify path for sources\n        // the whole parent directory needs to be archived. \n        srcPaths.add(parentPath);\n      }\n      // do a glob on the srcPaths and then pass it on\n      List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n      for (Path p: srcPaths) {\n        FileSystem fs \u003d p.getFileSystem(getConf());\n        FileStatus[] statuses \u003d fs.globStatus(p);\n        if (statuses !\u003d null) {\n          for (FileStatus status: statuses) {\n            globPaths.add(fs.makeQualified(status.getPath()));\n          }\n        }\n      }\n      if (globPaths.isEmpty()) {\n        throw new IOException(\"The resolved paths set is empty.\"\n            + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n            + srcPaths);\n      }\n\n      archive(parentPath, globPaths, archiveName, destPath);\n    } catch(IOException ie) {\n      System.err.println(ie.getLocalizedMessage());\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-tools/hadoop-archives/src/main/java/org/apache/hadoop/tools/HadoopArchives.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/src/tools/org/apache/hadoop/tools/HadoopArchives.java",
        "newPath": "hadoop-tools/hadoop-archives/src/main/java/org/apache/hadoop/tools/HadoopArchives.java"
      }
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      Path parentPath \u003d null;\n      List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n      Path destPath \u003d null;\n      String archiveName \u003d null;\n      if (args.length \u003c 5) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid usage.\");\n      }\n      if (!\"-archiveName\".equals(args[0])) {\n        System.out.println(usage);\n        throw new IOException(\"Archive Name not specified.\");\n      }\n      archiveName \u003d args[1];\n      if (!checkValidName(archiveName)) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid name for archives. \" + archiveName);\n      }\n      int i \u003d 2;\n      //check to see if relative parent has been provided or not\n      //this is a required parameter. \n      if (! \"-p\".equals(args[i])) {\n        System.out.println(usage);\n        throw new IOException(\"Parent path not specified.\");\n      }\n      parentPath \u003d new Path(args[i+1]);\n      i+\u003d2;\n      //read the rest of the paths\n      for (; i \u003c args.length; i++) {\n        if (i \u003d\u003d (args.length - 1)) {\n          destPath \u003d new Path(args[i]);\n        }\n        else {\n          Path argPath \u003d new Path(args[i]);\n          if (argPath.isAbsolute()) {\n            System.out.println(usage);\n            throw new IOException(\"source path \" + argPath +\n                \" is not relative  to \"+ parentPath);\n          }\n          srcPaths.add(new Path(parentPath, argPath));\n        }\n      }\n      if (srcPaths.size() \u003d\u003d 0) {\n        // assuming if the user does not specify path for sources\n        // the whole parent directory needs to be archived. \n        srcPaths.add(parentPath);\n      }\n      // do a glob on the srcPaths and then pass it on\n      List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n      for (Path p: srcPaths) {\n        FileSystem fs \u003d p.getFileSystem(getConf());\n        FileStatus[] statuses \u003d fs.globStatus(p);\n        if (statuses !\u003d null) {\n          for (FileStatus status: statuses) {\n            globPaths.add(fs.makeQualified(status.getPath()));\n          }\n        }\n      }\n      if (globPaths.isEmpty()) {\n        throw new IOException(\"The resolved paths set is empty.\"\n            + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n            + srcPaths);\n      }\n\n      archive(parentPath, globPaths, archiveName, destPath);\n    } catch(IOException ie) {\n      System.err.println(ie.getLocalizedMessage());\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/src/tools/org/apache/hadoop/tools/HadoopArchives.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/src/tools/org/apache/hadoop/tools/HadoopArchives.java",
        "newPath": "hadoop-mapreduce-project/src/tools/org/apache/hadoop/tools/HadoopArchives.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yfilerename",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/08/11 8:02 PM",
      "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      Path parentPath \u003d null;\n      List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n      Path destPath \u003d null;\n      String archiveName \u003d null;\n      if (args.length \u003c 5) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid usage.\");\n      }\n      if (!\"-archiveName\".equals(args[0])) {\n        System.out.println(usage);\n        throw new IOException(\"Archive Name not specified.\");\n      }\n      archiveName \u003d args[1];\n      if (!checkValidName(archiveName)) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid name for archives. \" + archiveName);\n      }\n      int i \u003d 2;\n      //check to see if relative parent has been provided or not\n      //this is a required parameter. \n      if (! \"-p\".equals(args[i])) {\n        System.out.println(usage);\n        throw new IOException(\"Parent path not specified.\");\n      }\n      parentPath \u003d new Path(args[i+1]);\n      i+\u003d2;\n      //read the rest of the paths\n      for (; i \u003c args.length; i++) {\n        if (i \u003d\u003d (args.length - 1)) {\n          destPath \u003d new Path(args[i]);\n        }\n        else {\n          Path argPath \u003d new Path(args[i]);\n          if (argPath.isAbsolute()) {\n            System.out.println(usage);\n            throw new IOException(\"source path \" + argPath +\n                \" is not relative  to \"+ parentPath);\n          }\n          srcPaths.add(new Path(parentPath, argPath));\n        }\n      }\n      if (srcPaths.size() \u003d\u003d 0) {\n        // assuming if the user does not specify path for sources\n        // the whole parent directory needs to be archived. \n        srcPaths.add(parentPath);\n      }\n      // do a glob on the srcPaths and then pass it on\n      List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n      for (Path p: srcPaths) {\n        FileSystem fs \u003d p.getFileSystem(getConf());\n        FileStatus[] statuses \u003d fs.globStatus(p);\n        if (statuses !\u003d null) {\n          for (FileStatus status: statuses) {\n            globPaths.add(fs.makeQualified(status.getPath()));\n          }\n        }\n      }\n      if (globPaths.isEmpty()) {\n        throw new IOException(\"The resolved paths set is empty.\"\n            + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n            + srcPaths);\n      }\n\n      archive(parentPath, globPaths, archiveName, destPath);\n    } catch(IOException ie) {\n      System.err.println(ie.getLocalizedMessage());\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce/src/tools/org/apache/hadoop/tools/HadoopArchives.java",
      "extendedDetails": {
        "oldPath": "mapreduce/src/tools/org/apache/hadoop/tools/HadoopArchives.java",
        "newPath": "hadoop-mapreduce/src/tools/org/apache/hadoop/tools/HadoopArchives.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,72 @@\n+  public int run(String[] args) throws Exception {\n+    try {\n+      Path parentPath \u003d null;\n+      List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n+      Path destPath \u003d null;\n+      String archiveName \u003d null;\n+      if (args.length \u003c 5) {\n+        System.out.println(usage);\n+        throw new IOException(\"Invalid usage.\");\n+      }\n+      if (!\"-archiveName\".equals(args[0])) {\n+        System.out.println(usage);\n+        throw new IOException(\"Archive Name not specified.\");\n+      }\n+      archiveName \u003d args[1];\n+      if (!checkValidName(archiveName)) {\n+        System.out.println(usage);\n+        throw new IOException(\"Invalid name for archives. \" + archiveName);\n+      }\n+      int i \u003d 2;\n+      //check to see if relative parent has been provided or not\n+      //this is a required parameter. \n+      if (! \"-p\".equals(args[i])) {\n+        System.out.println(usage);\n+        throw new IOException(\"Parent path not specified.\");\n+      }\n+      parentPath \u003d new Path(args[i+1]);\n+      i+\u003d2;\n+      //read the rest of the paths\n+      for (; i \u003c args.length; i++) {\n+        if (i \u003d\u003d (args.length - 1)) {\n+          destPath \u003d new Path(args[i]);\n+        }\n+        else {\n+          Path argPath \u003d new Path(args[i]);\n+          if (argPath.isAbsolute()) {\n+            System.out.println(usage);\n+            throw new IOException(\"source path \" + argPath +\n+                \" is not relative  to \"+ parentPath);\n+          }\n+          srcPaths.add(new Path(parentPath, argPath));\n+        }\n+      }\n+      if (srcPaths.size() \u003d\u003d 0) {\n+        // assuming if the user does not specify path for sources\n+        // the whole parent directory needs to be archived. \n+        srcPaths.add(parentPath);\n+      }\n+      // do a glob on the srcPaths and then pass it on\n+      List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n+      for (Path p: srcPaths) {\n+        FileSystem fs \u003d p.getFileSystem(getConf());\n+        FileStatus[] statuses \u003d fs.globStatus(p);\n+        if (statuses !\u003d null) {\n+          for (FileStatus status: statuses) {\n+            globPaths.add(fs.makeQualified(status.getPath()));\n+          }\n+        }\n+      }\n+      if (globPaths.isEmpty()) {\n+        throw new IOException(\"The resolved paths set is empty.\"\n+            + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n+            + srcPaths);\n+      }\n+\n+      archive(parentPath, globPaths, archiveName, destPath);\n+    } catch(IOException ie) {\n+      System.err.println(ie.getLocalizedMessage());\n+      return -1;\n+    }\n+    return 0;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      Path parentPath \u003d null;\n      List\u003cPath\u003e srcPaths \u003d new ArrayList\u003cPath\u003e();\n      Path destPath \u003d null;\n      String archiveName \u003d null;\n      if (args.length \u003c 5) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid usage.\");\n      }\n      if (!\"-archiveName\".equals(args[0])) {\n        System.out.println(usage);\n        throw new IOException(\"Archive Name not specified.\");\n      }\n      archiveName \u003d args[1];\n      if (!checkValidName(archiveName)) {\n        System.out.println(usage);\n        throw new IOException(\"Invalid name for archives. \" + archiveName);\n      }\n      int i \u003d 2;\n      //check to see if relative parent has been provided or not\n      //this is a required parameter. \n      if (! \"-p\".equals(args[i])) {\n        System.out.println(usage);\n        throw new IOException(\"Parent path not specified.\");\n      }\n      parentPath \u003d new Path(args[i+1]);\n      i+\u003d2;\n      //read the rest of the paths\n      for (; i \u003c args.length; i++) {\n        if (i \u003d\u003d (args.length - 1)) {\n          destPath \u003d new Path(args[i]);\n        }\n        else {\n          Path argPath \u003d new Path(args[i]);\n          if (argPath.isAbsolute()) {\n            System.out.println(usage);\n            throw new IOException(\"source path \" + argPath +\n                \" is not relative  to \"+ parentPath);\n          }\n          srcPaths.add(new Path(parentPath, argPath));\n        }\n      }\n      if (srcPaths.size() \u003d\u003d 0) {\n        // assuming if the user does not specify path for sources\n        // the whole parent directory needs to be archived. \n        srcPaths.add(parentPath);\n      }\n      // do a glob on the srcPaths and then pass it on\n      List\u003cPath\u003e globPaths \u003d new ArrayList\u003cPath\u003e();\n      for (Path p: srcPaths) {\n        FileSystem fs \u003d p.getFileSystem(getConf());\n        FileStatus[] statuses \u003d fs.globStatus(p);\n        if (statuses !\u003d null) {\n          for (FileStatus status: statuses) {\n            globPaths.add(fs.makeQualified(status.getPath()));\n          }\n        }\n      }\n      if (globPaths.isEmpty()) {\n        throw new IOException(\"The resolved paths set is empty.\"\n            + \"  Please check whether the srcPaths exist, where srcPaths \u003d \"\n            + srcPaths);\n      }\n\n      archive(parentPath, globPaths, archiveName, destPath);\n    } catch(IOException ie) {\n      System.err.println(ie.getLocalizedMessage());\n      return -1;\n    }\n    return 0;\n  }",
      "path": "mapreduce/src/tools/org/apache/hadoop/tools/HadoopArchives.java"
    }
  }
}