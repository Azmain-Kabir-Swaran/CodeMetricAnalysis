{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SubApplicationEntityReader.java",
  "functionName": "parseEntity",
  "functionId": "parseEntity___result-Result",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-client/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/SubApplicationEntityReader.java",
  "functionStartLine": 403,
  "functionEndLine": 496,
  "numCommitsSeen": 3,
  "timeTaken": 1671,
  "changeHistory": [
    "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2",
    "b2efebdd077ecb7b6ffe7fb8a957dadb0e78290f"
  ],
  "changeHistoryShort": {
    "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2": "Ymultichange(Yfilerename,Ybodychange)",
    "b2efebdd077ecb7b6ffe7fb8a957dadb0e78290f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "YARN-7919. Refactor timelineservice-hbase module into submodules. Contributed by Haibo Chen.\n",
      "commitDate": "17/02/18 7:00 AM",
      "commitName": "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2",
      "commitAuthor": "Rohith Sharma K S",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "YARN-7919. Refactor timelineservice-hbase module into submodules. Contributed by Haibo Chen.\n",
          "commitDate": "17/02/18 7:00 AM",
          "commitName": "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2",
          "commitAuthor": "Rohith Sharma K S",
          "commitDateOld": "17/02/18 3:24 AM",
          "commitNameOld": "a1e56a62863d8d494af309ec5f476c4b7e4d5ef9",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,94 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     SubApplicationRowKey parseRowKey \u003d\n         SubApplicationRowKey.parseRowKey(result.getRow());\n     entity.setType(parseRowKey.getEntityType());\n     entity.setId(parseRowKey.getEntityId());\n     entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n \n     TimelineEntityFilters filters \u003d getFilters();\n     // fetch created time\n-    Long createdTime \u003d\n-        (Long) SubApplicationColumn.CREATED_TIME.readResult(result);\n+    Long createdTime \u003d (Long) ColumnRWHelper.readResult(result,\n+        SubApplicationColumn.CREATED_TIME);\n     entity.setCreatedTime(createdTime);\n \n     EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n     // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // isRelatedTo are not set in HBase scan.\n     boolean checkIsRelatedTo \u003d\n         filters.getIsRelatedTo() !\u003d null\n             \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n       readRelationship(entity, result, SubApplicationColumnPrefix.IS_RELATED_TO,\n           true);\n       if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n           filters.getIsRelatedTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities and match relatesTo filter. If relatesTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // relatesTo are not set in HBase scan.\n     boolean checkRelatesTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n             \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.RELATES_TO) || checkRelatesTo) {\n       readRelationship(entity, result, SubApplicationColumnPrefix.RELATES_TO,\n           false);\n       if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n           filters.getRelatesTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info if fieldsToRetrieve contains INFO or ALL.\n     if (hasField(fieldsToRetrieve, Field.INFO)) {\n       readKeyValuePairs(entity, result, SubApplicationColumnPrefix.INFO, false);\n     }\n \n     // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n     if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n       readKeyValuePairs(entity, result, SubApplicationColumnPrefix.CONFIG,\n           true);\n     }\n \n     // fetch events and match event filters if they exist. If event filters do\n     // not match, entity would be dropped. We have to match filters locally\n     // as relevant HBase filters to filter out rows on the basis of events\n     // are not set in HBase scan.\n     boolean checkEvents \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n             \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n       readEvents(entity, result, SubApplicationColumnPrefix.EVENT);\n       if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n           filters.getEventFilters())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n     if (hasField(fieldsToRetrieve, Field.METRICS)) {\n       readMetrics(entity, result, SubApplicationColumnPrefix.METRIC);\n     }\n \n     entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n         parseRowKey.getRowKeyAsString());\n     return entity;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    SubApplicationRowKey parseRowKey \u003d\n        SubApplicationRowKey.parseRowKey(result.getRow());\n    entity.setType(parseRowKey.getEntityType());\n    entity.setId(parseRowKey.getEntityId());\n    entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Long createdTime \u003d (Long) ColumnRWHelper.readResult(result,\n        SubApplicationColumn.CREATED_TIME);\n    entity.setCreatedTime(createdTime);\n\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // isRelatedTo are not set in HBase scan.\n    boolean checkIsRelatedTo \u003d\n        filters.getIsRelatedTo() !\u003d null\n            \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, SubApplicationColumnPrefix.IS_RELATED_TO,\n          true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n          filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities and match relatesTo filter. If relatesTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // relatesTo are not set in HBase scan.\n    boolean checkRelatesTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n            \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, SubApplicationColumnPrefix.RELATES_TO,\n          false);\n      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n          filters.getRelatesTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info if fieldsToRetrieve contains INFO or ALL.\n    if (hasField(fieldsToRetrieve, Field.INFO)) {\n      readKeyValuePairs(entity, result, SubApplicationColumnPrefix.INFO, false);\n    }\n\n    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n    if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n      readKeyValuePairs(entity, result, SubApplicationColumnPrefix.CONFIG,\n          true);\n    }\n\n    // fetch events and match event filters if they exist. If event filters do\n    // not match, entity would be dropped. We have to match filters locally\n    // as relevant HBase filters to filter out rows on the basis of events\n    // are not set in HBase scan.\n    boolean checkEvents \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n            \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, SubApplicationColumnPrefix.EVENT);\n      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n          filters.getEventFilters())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n    if (hasField(fieldsToRetrieve, Field.METRICS)) {\n      readMetrics(entity, result, SubApplicationColumnPrefix.METRIC);\n    }\n\n    entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n        parseRowKey.getRowKeyAsString());\n    return entity;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-client/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/SubApplicationEntityReader.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/SubApplicationEntityReader.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-client/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/SubApplicationEntityReader.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7919. Refactor timelineservice-hbase module into submodules. Contributed by Haibo Chen.\n",
          "commitDate": "17/02/18 7:00 AM",
          "commitName": "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2",
          "commitAuthor": "Rohith Sharma K S",
          "commitDateOld": "17/02/18 3:24 AM",
          "commitNameOld": "a1e56a62863d8d494af309ec5f476c4b7e4d5ef9",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,94 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     SubApplicationRowKey parseRowKey \u003d\n         SubApplicationRowKey.parseRowKey(result.getRow());\n     entity.setType(parseRowKey.getEntityType());\n     entity.setId(parseRowKey.getEntityId());\n     entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n \n     TimelineEntityFilters filters \u003d getFilters();\n     // fetch created time\n-    Long createdTime \u003d\n-        (Long) SubApplicationColumn.CREATED_TIME.readResult(result);\n+    Long createdTime \u003d (Long) ColumnRWHelper.readResult(result,\n+        SubApplicationColumn.CREATED_TIME);\n     entity.setCreatedTime(createdTime);\n \n     EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n     // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // isRelatedTo are not set in HBase scan.\n     boolean checkIsRelatedTo \u003d\n         filters.getIsRelatedTo() !\u003d null\n             \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n       readRelationship(entity, result, SubApplicationColumnPrefix.IS_RELATED_TO,\n           true);\n       if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n           filters.getIsRelatedTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities and match relatesTo filter. If relatesTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // relatesTo are not set in HBase scan.\n     boolean checkRelatesTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n             \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.RELATES_TO) || checkRelatesTo) {\n       readRelationship(entity, result, SubApplicationColumnPrefix.RELATES_TO,\n           false);\n       if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n           filters.getRelatesTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info if fieldsToRetrieve contains INFO or ALL.\n     if (hasField(fieldsToRetrieve, Field.INFO)) {\n       readKeyValuePairs(entity, result, SubApplicationColumnPrefix.INFO, false);\n     }\n \n     // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n     if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n       readKeyValuePairs(entity, result, SubApplicationColumnPrefix.CONFIG,\n           true);\n     }\n \n     // fetch events and match event filters if they exist. If event filters do\n     // not match, entity would be dropped. We have to match filters locally\n     // as relevant HBase filters to filter out rows on the basis of events\n     // are not set in HBase scan.\n     boolean checkEvents \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n             \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n       readEvents(entity, result, SubApplicationColumnPrefix.EVENT);\n       if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n           filters.getEventFilters())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n     if (hasField(fieldsToRetrieve, Field.METRICS)) {\n       readMetrics(entity, result, SubApplicationColumnPrefix.METRIC);\n     }\n \n     entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n         parseRowKey.getRowKeyAsString());\n     return entity;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    SubApplicationRowKey parseRowKey \u003d\n        SubApplicationRowKey.parseRowKey(result.getRow());\n    entity.setType(parseRowKey.getEntityType());\n    entity.setId(parseRowKey.getEntityId());\n    entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Long createdTime \u003d (Long) ColumnRWHelper.readResult(result,\n        SubApplicationColumn.CREATED_TIME);\n    entity.setCreatedTime(createdTime);\n\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // isRelatedTo are not set in HBase scan.\n    boolean checkIsRelatedTo \u003d\n        filters.getIsRelatedTo() !\u003d null\n            \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, SubApplicationColumnPrefix.IS_RELATED_TO,\n          true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n          filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities and match relatesTo filter. If relatesTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // relatesTo are not set in HBase scan.\n    boolean checkRelatesTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n            \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, SubApplicationColumnPrefix.RELATES_TO,\n          false);\n      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n          filters.getRelatesTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info if fieldsToRetrieve contains INFO or ALL.\n    if (hasField(fieldsToRetrieve, Field.INFO)) {\n      readKeyValuePairs(entity, result, SubApplicationColumnPrefix.INFO, false);\n    }\n\n    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n    if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n      readKeyValuePairs(entity, result, SubApplicationColumnPrefix.CONFIG,\n          true);\n    }\n\n    // fetch events and match event filters if they exist. If event filters do\n    // not match, entity would be dropped. We have to match filters locally\n    // as relevant HBase filters to filter out rows on the basis of events\n    // are not set in HBase scan.\n    boolean checkEvents \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n            \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, SubApplicationColumnPrefix.EVENT);\n      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n          filters.getEventFilters())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n    if (hasField(fieldsToRetrieve, Field.METRICS)) {\n      readMetrics(entity, result, SubApplicationColumnPrefix.METRIC);\n    }\n\n    entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n        parseRowKey.getRowKeyAsString());\n    return entity;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-client/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/SubApplicationEntityReader.java",
          "extendedDetails": {}
        }
      ]
    },
    "b2efebdd077ecb7b6ffe7fb8a957dadb0e78290f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6861. Reader API for sub application entities (Rohith Sharma K S via Varun Saxena)\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "b2efebdd077ecb7b6ffe7fb8a957dadb0e78290f",
      "commitAuthor": "Varun Saxena",
      "diff": "@@ -0,0 +1,94 @@\n+  protected TimelineEntity parseEntity(Result result) throws IOException {\n+    if (result \u003d\u003d null || result.isEmpty()) {\n+      return null;\n+    }\n+    TimelineEntity entity \u003d new TimelineEntity();\n+    SubApplicationRowKey parseRowKey \u003d\n+        SubApplicationRowKey.parseRowKey(result.getRow());\n+    entity.setType(parseRowKey.getEntityType());\n+    entity.setId(parseRowKey.getEntityId());\n+    entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n+\n+    TimelineEntityFilters filters \u003d getFilters();\n+    // fetch created time\n+    Long createdTime \u003d\n+        (Long) SubApplicationColumn.CREATED_TIME.readResult(result);\n+    entity.setCreatedTime(createdTime);\n+\n+    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n+    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n+    // filters do not match, entity would be dropped. We have to match filters\n+    // locally as relevant HBase filters to filter out rows on the basis of\n+    // isRelatedTo are not set in HBase scan.\n+    boolean checkIsRelatedTo \u003d\n+        filters.getIsRelatedTo() !\u003d null\n+            \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n+    if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n+      readRelationship(entity, result, SubApplicationColumnPrefix.IS_RELATED_TO,\n+          true);\n+      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n+          filters.getIsRelatedTo())) {\n+        return null;\n+      }\n+      if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n+        entity.getIsRelatedToEntities().clear();\n+      }\n+    }\n+\n+    // fetch relates to entities and match relatesTo filter. If relatesTo\n+    // filters do not match, entity would be dropped. We have to match filters\n+    // locally as relevant HBase filters to filter out rows on the basis of\n+    // relatesTo are not set in HBase scan.\n+    boolean checkRelatesTo \u003d\n+        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n+            \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n+    if (hasField(fieldsToRetrieve, Field.RELATES_TO) || checkRelatesTo) {\n+      readRelationship(entity, result, SubApplicationColumnPrefix.RELATES_TO,\n+          false);\n+      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n+          filters.getRelatesTo())) {\n+        return null;\n+      }\n+      if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n+        entity.getRelatesToEntities().clear();\n+      }\n+    }\n+\n+    // fetch info if fieldsToRetrieve contains INFO or ALL.\n+    if (hasField(fieldsToRetrieve, Field.INFO)) {\n+      readKeyValuePairs(entity, result, SubApplicationColumnPrefix.INFO, false);\n+    }\n+\n+    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n+    if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n+      readKeyValuePairs(entity, result, SubApplicationColumnPrefix.CONFIG,\n+          true);\n+    }\n+\n+    // fetch events and match event filters if they exist. If event filters do\n+    // not match, entity would be dropped. We have to match filters locally\n+    // as relevant HBase filters to filter out rows on the basis of events\n+    // are not set in HBase scan.\n+    boolean checkEvents \u003d\n+        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n+            \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n+    if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n+      readEvents(entity, result, SubApplicationColumnPrefix.EVENT);\n+      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n+          filters.getEventFilters())) {\n+        return null;\n+      }\n+      if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n+        entity.getEvents().clear();\n+      }\n+    }\n+\n+    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n+    if (hasField(fieldsToRetrieve, Field.METRICS)) {\n+      readMetrics(entity, result, SubApplicationColumnPrefix.METRIC);\n+    }\n+\n+    entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n+        parseRowKey.getRowKeyAsString());\n+    return entity;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    SubApplicationRowKey parseRowKey \u003d\n        SubApplicationRowKey.parseRowKey(result.getRow());\n    entity.setType(parseRowKey.getEntityType());\n    entity.setId(parseRowKey.getEntityId());\n    entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Long createdTime \u003d\n        (Long) SubApplicationColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime);\n\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // isRelatedTo are not set in HBase scan.\n    boolean checkIsRelatedTo \u003d\n        filters.getIsRelatedTo() !\u003d null\n            \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, SubApplicationColumnPrefix.IS_RELATED_TO,\n          true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n          filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities and match relatesTo filter. If relatesTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // relatesTo are not set in HBase scan.\n    boolean checkRelatesTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n            \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, SubApplicationColumnPrefix.RELATES_TO,\n          false);\n      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n          filters.getRelatesTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info if fieldsToRetrieve contains INFO or ALL.\n    if (hasField(fieldsToRetrieve, Field.INFO)) {\n      readKeyValuePairs(entity, result, SubApplicationColumnPrefix.INFO, false);\n    }\n\n    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n    if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n      readKeyValuePairs(entity, result, SubApplicationColumnPrefix.CONFIG,\n          true);\n    }\n\n    // fetch events and match event filters if they exist. If event filters do\n    // not match, entity would be dropped. We have to match filters locally\n    // as relevant HBase filters to filter out rows on the basis of events\n    // are not set in HBase scan.\n    boolean checkEvents \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n            \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, SubApplicationColumnPrefix.EVENT);\n      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n          filters.getEventFilters())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n    if (hasField(fieldsToRetrieve, Field.METRICS)) {\n      readMetrics(entity, result, SubApplicationColumnPrefix.METRIC);\n    }\n\n    entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n        parseRowKey.getRowKeyAsString());\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/SubApplicationEntityReader.java"
    }
  }
}