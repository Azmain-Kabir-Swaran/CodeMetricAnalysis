{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirRenameOp.java",
  "functionName": "unprotectedRenameTo",
  "functionId": "unprotectedRenameTo___fsd-FSDirectory__srcIIP-INodesInPath(modifiers-final)__dstIIP-INodesInPath(modifiers-final)__timestamp-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
  "functionStartLine": 154,
  "functionEndLine": 234,
  "numCommitsSeen": 284,
  "timeTaken": 20293,
  "changeHistory": [
    "de6b8b0c0b1933aab2af3e8adc50a2091d428238",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
    "44f48ee96ee6b2a3909911c37bfddb0c963d5ffc",
    "5f34402adae191232fe78e62990396ca07f314bb",
    "f62237bc2f02afe11ce185e13aa51a60b5960037",
    "1af8c148626effe1b41fc536019fd3349f485d59",
    "5dae97a584d30cef3e34141edfaca49c4ec57913",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
    "5776a41da08af653206bb94d7c76c9c4dcce059a",
    "26d8dec756da1d9bd3df3b41a4dd5d8ff03bc5b2",
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
    "ceed0f6c46736323bd1b077125ff4e217c649208",
    "c38665282884122d3c82b6f68376cce036aee748",
    "31617733aca2025cff1ffb841a533a5b1de016a5",
    "08986fdbed5a15bcdc57d142922911759b97e9d1",
    "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf",
    "0689363343a281a6f7f6f395227668bddc2663eb",
    "2b03ae94216a76a477f3d6250d076ebbf61e998a",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823",
    "d46e1608626c64400d2b6c7693a4c035783c55b4",
    "bf99961d67bf59dad6a861655407f9e0a5f21aa5",
    "59801391400f3fa0ed1f029b7af75627d3288f22",
    "3a3e0f573129c8308332d4b301a9319ee579d85a",
    "9da386584142df9bcc335843674e0d7a905f2230",
    "0fa5cad0b27780c27a284c23101b1099d4886506",
    "6bda1f20ad396918edde211f709f5819a361b51e",
    "9c6a7bebe23ffb85d7fd95607f3b7bb4fe82dbe4",
    "ca848beb533790ae8abb6498f5d4676594fbae4c",
    "1096917649fd951be633e5619518764f23cca645",
    "25aab4203c465403ae0c4ad62ec948094e023489",
    "9701555899315c94584b24d8717c1d7540a4a491",
    "b1333e5b561d01a010e2e1311e8501879f377bdc",
    "2372e394dd99d69d396327d5a5e172953a8b8c6a",
    "b9f965de120b5278ac84a7e98aecb32aafde4c16",
    "cbbaa93ae09bf5cf643263faf78f99315c4f3a8d",
    "9821af9ce8a56a2c583f1ed938902c20e897048f",
    "88eea2157275d4c7e1bf70cac98fe52c326f3585",
    "9047eb516261b8c9c380d140a43dfdd5d701dee5",
    "d66f9e8269424f588180f2659c8cf132a2a7dfc9",
    "2116d0520e528c44fa280f2a5b28594c6d6fc28a",
    "34413c2000d9262faa37fde88a72939587edc776",
    "7ee5ce3176a74d217551b5981f809a56c719424b",
    "d174f574bafcfefc635c64a47f258b1ce5d5c84e",
    "1b3b09d94794622e8336220d897a1f10c4654677",
    "10dc6b09272dbf2022907681e134104e7d418021",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "de6b8b0c0b1933aab2af3e8adc50a2091d428238": "Ybodychange",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": "Ybodychange",
    "44f48ee96ee6b2a3909911c37bfddb0c963d5ffc": "Ybodychange",
    "5f34402adae191232fe78e62990396ca07f314bb": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "f62237bc2f02afe11ce185e13aa51a60b5960037": "Ybodychange",
    "1af8c148626effe1b41fc536019fd3349f485d59": "Ybodychange",
    "5dae97a584d30cef3e34141edfaca49c4ec57913": "Ybodychange",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": "Ybodychange",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": "Ymultichange(Yparameterchange,Ybodychange)",
    "5776a41da08af653206bb94d7c76c9c4dcce059a": "Ybodychange",
    "26d8dec756da1d9bd3df3b41a4dd5d8ff03bc5b2": "Ybodychange",
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7": "Ymultichange(Ymovefromfile,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
    "ceed0f6c46736323bd1b077125ff4e217c649208": "Ybodychange",
    "c38665282884122d3c82b6f68376cce036aee748": "Ybodychange",
    "31617733aca2025cff1ffb841a533a5b1de016a5": "Ybodychange",
    "08986fdbed5a15bcdc57d142922911759b97e9d1": "Ybodychange",
    "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf": "Ybodychange",
    "0689363343a281a6f7f6f395227668bddc2663eb": "Ybodychange",
    "2b03ae94216a76a477f3d6250d076ebbf61e998a": "Ybodychange",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": "Ybodychange",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": "Ybodychange",
    "d46e1608626c64400d2b6c7693a4c035783c55b4": "Ybodychange",
    "bf99961d67bf59dad6a861655407f9e0a5f21aa5": "Ybodychange",
    "59801391400f3fa0ed1f029b7af75627d3288f22": "Ybodychange",
    "3a3e0f573129c8308332d4b301a9319ee579d85a": "Ybodychange",
    "9da386584142df9bcc335843674e0d7a905f2230": "Ybodychange",
    "0fa5cad0b27780c27a284c23101b1099d4886506": "Ybodychange",
    "6bda1f20ad396918edde211f709f5819a361b51e": "Ybodychange",
    "9c6a7bebe23ffb85d7fd95607f3b7bb4fe82dbe4": "Ymultichange(Yexceptionschange,Ybodychange)",
    "ca848beb533790ae8abb6498f5d4676594fbae4c": "Ybodychange",
    "1096917649fd951be633e5619518764f23cca645": "Ybodychange",
    "25aab4203c465403ae0c4ad62ec948094e023489": "Ybodychange",
    "9701555899315c94584b24d8717c1d7540a4a491": "Ybodychange",
    "b1333e5b561d01a010e2e1311e8501879f377bdc": "Ybodychange",
    "2372e394dd99d69d396327d5a5e172953a8b8c6a": "Ybodychange",
    "b9f965de120b5278ac84a7e98aecb32aafde4c16": "Ybodychange",
    "cbbaa93ae09bf5cf643263faf78f99315c4f3a8d": "Ybodychange",
    "9821af9ce8a56a2c583f1ed938902c20e897048f": "Ybodychange",
    "88eea2157275d4c7e1bf70cac98fe52c326f3585": "Ybodychange",
    "9047eb516261b8c9c380d140a43dfdd5d701dee5": "Ybodychange",
    "d66f9e8269424f588180f2659c8cf132a2a7dfc9": "Ybodychange",
    "2116d0520e528c44fa280f2a5b28594c6d6fc28a": "Ymultichange(Yexceptionschange,Ybodychange)",
    "34413c2000d9262faa37fde88a72939587edc776": "Ybodychange",
    "7ee5ce3176a74d217551b5981f809a56c719424b": "Ybodychange",
    "d174f574bafcfefc635c64a47f258b1ce5d5c84e": "Ybodychange",
    "1b3b09d94794622e8336220d897a1f10c4654677": "Ybodychange",
    "10dc6b09272dbf2022907681e134104e7d418021": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "de6b8b0c0b1933aab2af3e8adc50a2091d428238": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14925. Rename operation should check nest snapshot (#1670)\n\nIf the src directory or any of its descendant is snapshottable\r\nand the dst directory or any of its ancestors is snapshottable,\r\nwe consider this as nested snapshot, which should be denied.\r\n\r\nReviewed-by: Shashikant Banerjee \u003cshashikant@apache.org\u003e",
      "commitDate": "01/11/19 4:37 PM",
      "commitName": "de6b8b0c0b1933aab2af3e8adc50a2091d428238",
      "commitAuthor": "Zhao Junwang",
      "commitDateOld": "03/09/19 9:29 AM",
      "commitNameOld": "3c117163a343d7da7ac958e22789b461c24efa5f",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 59.3,
      "commitsBetweenForRepo": 392,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,81 @@\n   static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     final INode srcInode \u003d srcIIP.getLastINode();\n+    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n     try {\n-      validateRenameSource(fsd, srcIIP);\n+      validateRenameSource(fsd, srcIIP, snapshottableDirs);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return null;\n     }\n \n     String src \u003d srcIIP.getPath();\n     String dst \u003d dstIIP.getPath();\n     // validate the destination\n     if (dst.equals(src)) {\n       return dstIIP;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return null;\n     }\n \n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n       return null;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n       return null;\n     }\n \n+    validateNestSnapshot(fsd, src, dstParent.asDirectory(), snapshottableDirs);\n+\n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     INodesInPath renamedIIP \u003d null;\n     try {\n       // remove src\n       if (!tx.removeSrc4OldRename()) {\n         return null;\n       }\n \n       renamedIIP \u003d tx.addSourceToDestination();\n       added \u003d (renamedIIP !\u003d null);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n \n         return renamedIIP;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003c\u003e();\n    try {\n      validateRenameSource(fsd, srcIIP, snapshottableDirs);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    String src \u003d srcIIP.getPath();\n    String dst \u003d dstIIP.getPath();\n    // validate the destination\n    if (dst.equals(src)) {\n      return dstIIP;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return null;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return null;\n    }\n\n    validateNestSnapshot(fsd, src, dstParent.asDirectory(), snapshottableDirs);\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    INodesInPath renamedIIP \u003d null;\n    try {\n      // remove src\n      if (!tx.removeSrc4OldRename()) {\n        return null;\n      }\n\n      renamedIIP \u003d tx.addSourceToDestination();\n      added \u003d (renamedIIP !\u003d null);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n\n        return renamedIIP;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10939. Reduce performance penalty of encryption zones. Contributed by Daryn sharp.\n",
      "commitDate": "06/10/16 1:11 PM",
      "commitName": "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/10/16 1:05 PM",
      "commitNameOld": "44f48ee96ee6b2a3909911c37bfddb0c963d5ffc",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 2.0,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,78 @@\n   static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(fsd, srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return null;\n     }\n \n     String src \u003d srcIIP.getPath();\n     String dst \u003d dstIIP.getPath();\n     // validate the destination\n     if (dst.equals(src)) {\n       return dstIIP;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return null;\n     }\n \n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n       return null;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n       return null;\n     }\n \n-    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     INodesInPath renamedIIP \u003d null;\n     try {\n       // remove src\n       if (!tx.removeSrc4OldRename()) {\n         return null;\n       }\n \n       renamedIIP \u003d tx.addSourceToDestination();\n       added \u003d (renamedIIP !\u003d null);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n \n         return renamedIIP;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(fsd, srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    String src \u003d srcIIP.getPath();\n    String dst \u003d dstIIP.getPath();\n    // validate the destination\n    if (dst.equals(src)) {\n      return dstIIP;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return null;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return null;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    INodesInPath renamedIIP \u003d null;\n    try {\n      // remove src\n      if (!tx.removeSrc4OldRename()) {\n        return null;\n      }\n\n      renamedIIP \u003d tx.addSourceToDestination();\n      added \u003d (renamedIIP !\u003d null);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n\n        return renamedIIP;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "44f48ee96ee6b2a3909911c37bfddb0c963d5ffc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10956. Remove rename/delete performance penalty when not using snapshots. Contributed by Daryn Sharp.\n",
      "commitDate": "04/10/16 1:05 PM",
      "commitName": "44f48ee96ee6b2a3909911c37bfddb0c963d5ffc",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "28/09/16 3:57 PM",
      "commitNameOld": "5f34402adae191232fe78e62990396ca07f314bb",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 5.88,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,78 @@\n   static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n-      validateRenameSource(srcIIP);\n+      validateRenameSource(fsd, srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return null;\n     }\n \n     String src \u003d srcIIP.getPath();\n     String dst \u003d dstIIP.getPath();\n     // validate the destination\n     if (dst.equals(src)) {\n       return dstIIP;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return null;\n     }\n \n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n       return null;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n       return null;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     INodesInPath renamedIIP \u003d null;\n     try {\n       // remove src\n       if (!tx.removeSrc4OldRename()) {\n         return null;\n       }\n \n       renamedIIP \u003d tx.addSourceToDestination();\n       added \u003d (renamedIIP !\u003d null);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n \n         return renamedIIP;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(fsd, srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    String src \u003d srcIIP.getPath();\n    String dst \u003d dstIIP.getPath();\n    // validate the destination\n    if (dst.equals(src)) {\n      return dstIIP;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return null;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return null;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    INodesInPath renamedIIP \u003d null;\n    try {\n      // remove src\n      if (!tx.removeSrc4OldRename()) {\n        return null;\n      }\n\n      renamedIIP \u003d tx.addSourceToDestination();\n      added \u003d (renamedIIP !\u003d null);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n\n        return renamedIIP;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "5f34402adae191232fe78e62990396ca07f314bb": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
      "commitDate": "28/09/16 3:57 PM",
      "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
          "commitDate": "28/09/16 3:57 PM",
          "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "22/08/16 6:29 PM",
          "commitNameOld": "c49333becfa7652460976a61eb86522010bcfeed",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 36.89,
          "commitsBetweenForRepo": 212,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,78 @@\n-  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n+  static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n-      return false;\n+      return null;\n     }\n \n+    String src \u003d srcIIP.getPath();\n+    String dst \u003d dstIIP.getPath();\n     // validate the destination\n     if (dst.equals(src)) {\n-      return true;\n+      return dstIIP;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n-      return false;\n+      return null;\n     }\n \n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n-      return false;\n+      return null;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n-      return false;\n+      return null;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n-    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n+    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n+    INodesInPath renamedIIP \u003d null;\n     try {\n       // remove src\n       if (!tx.removeSrc4OldRename()) {\n-        return false;\n+        return null;\n       }\n \n-      added \u003d tx.addSourceToDestination();\n+      renamedIIP \u003d tx.addSourceToDestination();\n+      added \u003d (renamedIIP !\u003d null);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n \n-        return true;\n+        return renamedIIP;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n-    return false;\n+    return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    String src \u003d srcIIP.getPath();\n    String dst \u003d dstIIP.getPath();\n    // validate the destination\n    if (dst.equals(src)) {\n      return dstIIP;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return null;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return null;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    INodesInPath renamedIIP \u003d null;\n    try {\n      // remove src\n      if (!tx.removeSrc4OldRename()) {\n        return null;\n      }\n\n      renamedIIP \u003d tx.addSourceToDestination();\n      added \u003d (renamedIIP !\u003d null);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n\n        return renamedIIP;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return null;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, src-String, dst-String, srcIIP-INodesInPath(modifiers-final), dstIIP-INodesInPath(modifiers-final), timestamp-long]",
            "newValue": "[fsd-FSDirectory, srcIIP-INodesInPath(modifiers-final), dstIIP-INodesInPath(modifiers-final), timestamp-long]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
          "commitDate": "28/09/16 3:57 PM",
          "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "22/08/16 6:29 PM",
          "commitNameOld": "c49333becfa7652460976a61eb86522010bcfeed",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 36.89,
          "commitsBetweenForRepo": 212,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,78 @@\n-  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n+  static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n-      return false;\n+      return null;\n     }\n \n+    String src \u003d srcIIP.getPath();\n+    String dst \u003d dstIIP.getPath();\n     // validate the destination\n     if (dst.equals(src)) {\n-      return true;\n+      return dstIIP;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n-      return false;\n+      return null;\n     }\n \n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n-      return false;\n+      return null;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n-      return false;\n+      return null;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n-    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n+    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n+    INodesInPath renamedIIP \u003d null;\n     try {\n       // remove src\n       if (!tx.removeSrc4OldRename()) {\n-        return false;\n+        return null;\n       }\n \n-      added \u003d tx.addSourceToDestination();\n+      renamedIIP \u003d tx.addSourceToDestination();\n+      added \u003d (renamedIIP !\u003d null);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n \n-        return true;\n+        return renamedIIP;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n-    return false;\n+    return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    String src \u003d srcIIP.getPath();\n    String dst \u003d dstIIP.getPath();\n    // validate the destination\n    if (dst.equals(src)) {\n      return dstIIP;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return null;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return null;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    INodesInPath renamedIIP \u003d null;\n    try {\n      // remove src\n      if (!tx.removeSrc4OldRename()) {\n        return null;\n      }\n\n      renamedIIP \u003d tx.addSourceToDestination();\n      added \u003d (renamedIIP !\u003d null);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n\n        return renamedIIP;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return null;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "INodesInPath"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
          "commitDate": "28/09/16 3:57 PM",
          "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "22/08/16 6:29 PM",
          "commitNameOld": "c49333becfa7652460976a61eb86522010bcfeed",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 36.89,
          "commitsBetweenForRepo": 212,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,78 @@\n-  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n+  static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n-      return false;\n+      return null;\n     }\n \n+    String src \u003d srcIIP.getPath();\n+    String dst \u003d dstIIP.getPath();\n     // validate the destination\n     if (dst.equals(src)) {\n-      return true;\n+      return dstIIP;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n-      return false;\n+      return null;\n     }\n \n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n-      return false;\n+      return null;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n-      return false;\n+      return null;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n-    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n+    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n+    INodesInPath renamedIIP \u003d null;\n     try {\n       // remove src\n       if (!tx.removeSrc4OldRename()) {\n-        return false;\n+        return null;\n       }\n \n-      added \u003d tx.addSourceToDestination();\n+      renamedIIP \u003d tx.addSourceToDestination();\n+      added \u003d (renamedIIP !\u003d null);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n \n-        return true;\n+        return renamedIIP;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n-    return false;\n+    return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath unprotectedRenameTo(FSDirectory fsd,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    String src \u003d srcIIP.getPath();\n    String dst \u003d dstIIP.getPath();\n    // validate the destination\n    if (dst.equals(src)) {\n      return dstIIP;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return null;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return null;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return null;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    INodesInPath renamedIIP \u003d null;\n    try {\n      // remove src\n      if (!tx.removeSrc4OldRename()) {\n        return null;\n      }\n\n      renamedIIP \u003d tx.addSourceToDestination();\n      added \u003d (renamedIIP !\u003d null);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n\n        return renamedIIP;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return null;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "f62237bc2f02afe11ce185e13aa51a60b5960037": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8833. Erasure coding: store EC schema and cell size in INodeFile and eliminate notion of EC zones.\n",
      "commitDate": "09/09/15 11:07 PM",
      "commitName": "f62237bc2f02afe11ce185e13aa51a60b5960037",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "01/09/15 2:30 PM",
      "commitNameOld": "ab56fcdb1219d03713b408dd3a95d7405635254d",
      "commitAuthorOld": "",
      "daysBetweenCommits": 8.36,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,74 @@\n   static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n       return false;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n-    fsd.ecZoneManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n       if (!tx.removeSrc4OldRename()) {\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n \n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      if (!tx.removeSrc4OldRename()) {\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "1af8c148626effe1b41fc536019fd3349f485d59": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7839. Erasure coding: implement facilities in NameNode to create and manage EC zones. Contributed by Zhe Zhang\n",
      "commitDate": "26/05/15 11:55 AM",
      "commitName": "1af8c148626effe1b41fc536019fd3349f485d59",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "13/05/15 9:50 PM",
      "commitNameOld": "b2c85db86c9a62b0a03ee87547265077f664970a",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 12.59,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,75 @@\n   static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n       return false;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    fsd.ecZoneManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n       if (!tx.removeSrc4OldRename()) {\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n \n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    fsd.ecZoneManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      if (!tx.removeSrc4OldRename()) {\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "5dae97a584d30cef3e34141edfaca49c4ec57913": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7723. Quota By Storage Type namenode implemenation. (Contributed by Xiaoyu Yao)\n",
      "commitDate": "11/02/15 10:41 AM",
      "commitName": "5dae97a584d30cef3e34141edfaca49c4ec57913",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "02/02/15 4:32 PM",
      "commitNameOld": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 8.76,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n       return false;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n       if (!tx.removeSrc4OldRename()) {\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n-        tx.updateQuotasInSourceTree();\n+        tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n \n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      if (!tx.removeSrc4OldRename()) {\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree(fsd.getBlockStoragePolicySuite());\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7484. Make FSDirectory#addINode take existing INodes as its parameter. Contributed by Jing Zhao.\n",
      "commitDate": "22/12/14 11:19 PM",
      "commitName": "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "18/12/14 11:25 AM",
      "commitNameOld": "65f2a4ee600dfffa5203450261da3c1989de25a9",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 4.5,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,74 @@\n   static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n       final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n       return false;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n-      final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n-      if (removedSrc \u003d\u003d -1) {\n-        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n-            \" can not be removed\");\n+      if (!tx.removeSrc4OldRename()) {\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree();\n \n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      if (!tx.removeSrc4OldRename()) {\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
      "commitDate": "12/12/14 3:13 PM",
      "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "11/12/14 12:36 PM",
          "commitNameOld": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 1.11,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,78 @@\n-  static boolean unprotectedRenameTo(\n-      FSDirectory fsd, String src, String dst, long timestamp)\n+  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n+      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n-    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n-      validateRenameSource(src, srcIIP);\n+      validateRenameSource(srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    if (fsd.isDir(dst)) {\n-      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n-    }\n-\n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n       return false;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n       final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n             \" can not be removed\");\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree();\n \n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n            \" can not be removed\");\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, src-String, dst-String, timestamp-long]",
            "newValue": "[fsd-FSDirectory, src-String, dst-String, srcIIP-INodesInPath(modifiers-final), dstIIP-INodesInPath(modifiers-final), timestamp-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "11/12/14 12:36 PM",
          "commitNameOld": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 1.11,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,78 @@\n-  static boolean unprotectedRenameTo(\n-      FSDirectory fsd, String src, String dst, long timestamp)\n+  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n+      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n-    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n-      validateRenameSource(src, srcIIP);\n+      validateRenameSource(srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    if (fsd.isDir(dst)) {\n-      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n-    }\n-\n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n       return false;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n     verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n       final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n             \" can not be removed\");\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree();\n \n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(FSDirectory fsd, String src, String dst,\n      final INodesInPath srcIIP, final INodesInPath dstIIP, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n            \" can not be removed\");\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "5776a41da08af653206bb94d7c76c9c4dcce059a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7498. Simplify the logic in INodesInPath. Contributed by Jing Zhao.\n",
      "commitDate": "09/12/14 11:37 AM",
      "commitName": "5776a41da08af653206bb94d7c76c9c4dcce059a",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "05/12/14 2:17 PM",
      "commitNameOld": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 3.89,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n   static boolean unprotectedRenameTo(\n       FSDirectory fsd, String src, String dst, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(src, srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     if (fsd.isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n       return false;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n-    verifyQuotaForRename(fsd, srcIIP.getINodes(), dstIIP.getINodes());\n+    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n-      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n+      final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n             \" can not be removed\");\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree();\n \n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(src, srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (fsd.isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP, dstIIP);\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      final long removedSrc \u003d fsd.removeLastINode(tx.srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n            \" can not be removed\");\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "26d8dec756da1d9bd3df3b41a4dd5d8ff03bc5b2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7468. Moving verify* functions to corresponding classes. Contributed by Li Lu.\n",
      "commitDate": "04/12/14 2:09 PM",
      "commitName": "26d8dec756da1d9bd3df3b41a4dd5d8ff03bc5b2",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "01/12/14 9:48 PM",
      "commitNameOld": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 2.68,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n   static boolean unprotectedRenameTo(\n       FSDirectory fsd, String src, String dst, long timestamp)\n       throws IOException {\n     assert fsd.hasWriteLock();\n     INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(src, srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     if (fsd.isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n       validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n           \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n           \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n           \"parent does not exist\");\n       return false;\n     }\n \n     fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n-    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n-    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n+    verifyQuotaForRename(fsd, srcIIP.getINodes(), dstIIP.getINodes());\n \n     RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n       final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n             \" can not be removed\");\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n               \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree();\n \n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n         \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(src, srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (fsd.isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(fsd, srcIIP, dstIIP);\n    verifyQuotaForRename(fsd, srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n            \" can not be removed\");\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "01/12/14 9:48 PM",
      "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,84 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n-    throws QuotaExceededException, UnresolvedLinkException, \n-    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n-    assert hasWriteLock();\n-    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp)\n+      throws IOException {\n+    assert fsd.hasWriteLock();\n+    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(src, srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    if (isDir(dst)) {\n+    if (fsd.isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n-      validateRenameDestination(src, dst, srcInode);\n+      validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getLastINode() !\u003d null) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-                                   +\"failed to rename \"+src+\" to \"+dst+ \n-                                   \" because destination exists\");\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n+          \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          +\"failed to rename \"+src+\" to \"+dst+ \n-          \" because destination\u0027s parent does not exist\");\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n+          \"parent does not exist\");\n       return false;\n     }\n-    \n-    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n-    // Ensure dst has quota to accommodate rename\n-    verifyFsLimitsForRename(srcIIP, dstIIP);\n-    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n-    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    // Ensure dst has quota to accommodate rename\n+    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n+    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+\n+    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n-      final long removedSrc \u003d removeLastINode(srcIIP);\n+      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-            + \"failed to rename \" + src + \" to \" + dst\n-            + \" because the source can not be removed\");\n+            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n+            \" can not be removed\");\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n-          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n-              + src + \" is renamed to \" + dst);\n+          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n+              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree();\n-        \n+\n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n-    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-        +\"failed to rename \"+src+\" to \"+dst);\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+        \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(src, srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (fsd.isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n            \" can not be removed\");\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
            "oldMethodName": "unprotectedRenameTo",
            "newMethodName": "unprotectedRenameTo"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,84 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n-    throws QuotaExceededException, UnresolvedLinkException, \n-    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n-    assert hasWriteLock();\n-    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp)\n+      throws IOException {\n+    assert fsd.hasWriteLock();\n+    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(src, srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    if (isDir(dst)) {\n+    if (fsd.isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n-      validateRenameDestination(src, dst, srcInode);\n+      validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getLastINode() !\u003d null) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-                                   +\"failed to rename \"+src+\" to \"+dst+ \n-                                   \" because destination exists\");\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n+          \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          +\"failed to rename \"+src+\" to \"+dst+ \n-          \" because destination\u0027s parent does not exist\");\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n+          \"parent does not exist\");\n       return false;\n     }\n-    \n-    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n-    // Ensure dst has quota to accommodate rename\n-    verifyFsLimitsForRename(srcIIP, dstIIP);\n-    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n-    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    // Ensure dst has quota to accommodate rename\n+    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n+    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+\n+    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n-      final long removedSrc \u003d removeLastINode(srcIIP);\n+      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-            + \"failed to rename \" + src + \" to \" + dst\n-            + \" because the source can not be removed\");\n+            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n+            \" can not be removed\");\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n-          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n-              + src + \" is renamed to \" + dst);\n+          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n+              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree();\n-        \n+\n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n-    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-        +\"failed to rename \"+src+\" to \"+dst);\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+        \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(src, srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (fsd.isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n            \" can not be removed\");\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,84 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n-    throws QuotaExceededException, UnresolvedLinkException, \n-    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n-    assert hasWriteLock();\n-    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp)\n+      throws IOException {\n+    assert fsd.hasWriteLock();\n+    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(src, srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    if (isDir(dst)) {\n+    if (fsd.isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n-      validateRenameDestination(src, dst, srcInode);\n+      validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getLastINode() !\u003d null) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-                                   +\"failed to rename \"+src+\" to \"+dst+ \n-                                   \" because destination exists\");\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n+          \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          +\"failed to rename \"+src+\" to \"+dst+ \n-          \" because destination\u0027s parent does not exist\");\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n+          \"parent does not exist\");\n       return false;\n     }\n-    \n-    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n-    // Ensure dst has quota to accommodate rename\n-    verifyFsLimitsForRename(srcIIP, dstIIP);\n-    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n-    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    // Ensure dst has quota to accommodate rename\n+    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n+    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+\n+    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n-      final long removedSrc \u003d removeLastINode(srcIIP);\n+      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-            + \"failed to rename \" + src + \" to \" + dst\n-            + \" because the source can not be removed\");\n+            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n+            \" can not be removed\");\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n-          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n-              + src + \" is renamed to \" + dst);\n+          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n+              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree();\n-        \n+\n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n-    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-        +\"failed to rename \"+src+\" to \"+dst);\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+        \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(src, srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (fsd.isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n            \" can not be removed\");\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[QuotaExceededException, UnresolvedLinkException, FileAlreadyExistsException, SnapshotAccessControlException, IOException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,84 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n-    throws QuotaExceededException, UnresolvedLinkException, \n-    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n-    assert hasWriteLock();\n-    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp)\n+      throws IOException {\n+    assert fsd.hasWriteLock();\n+    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(src, srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    if (isDir(dst)) {\n+    if (fsd.isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n-      validateRenameDestination(src, dst, srcInode);\n+      validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getLastINode() !\u003d null) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-                                   +\"failed to rename \"+src+\" to \"+dst+ \n-                                   \" because destination exists\");\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n+          \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          +\"failed to rename \"+src+\" to \"+dst+ \n-          \" because destination\u0027s parent does not exist\");\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n+          \"parent does not exist\");\n       return false;\n     }\n-    \n-    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n-    // Ensure dst has quota to accommodate rename\n-    verifyFsLimitsForRename(srcIIP, dstIIP);\n-    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n-    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    // Ensure dst has quota to accommodate rename\n+    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n+    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+\n+    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n-      final long removedSrc \u003d removeLastINode(srcIIP);\n+      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-            + \"failed to rename \" + src + \" to \" + dst\n-            + \" because the source can not be removed\");\n+            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n+            \" can not be removed\");\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n-          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n-              + src + \" is renamed to \" + dst);\n+          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n+              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree();\n-        \n+\n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n-    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-        +\"failed to rename \"+src+\" to \"+dst);\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+        \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(src, srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (fsd.isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n            \" can not be removed\");\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,84 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n-    throws QuotaExceededException, UnresolvedLinkException, \n-    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n-    assert hasWriteLock();\n-    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp)\n+      throws IOException {\n+    assert fsd.hasWriteLock();\n+    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(src, srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    if (isDir(dst)) {\n+    if (fsd.isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n-      validateRenameDestination(src, dst, srcInode);\n+      validateDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n-    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     if (dstIIP.getLastINode() !\u003d null) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-                                   +\"failed to rename \"+src+\" to \"+dst+ \n-                                   \" because destination exists\");\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n+          \"exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          +\"failed to rename \"+src+\" to \"+dst+ \n-          \" because destination\u0027s parent does not exist\");\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n+          \"parent does not exist\");\n       return false;\n     }\n-    \n-    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n-    // Ensure dst has quota to accommodate rename\n-    verifyFsLimitsForRename(srcIIP, dstIIP);\n-    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n-    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n+    // Ensure dst has quota to accommodate rename\n+    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n+    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+\n+    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n-      final long removedSrc \u003d removeLastINode(srcIIP);\n+      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-            + \"failed to rename \" + src + \" to \" + dst\n-            + \" because the source can not be removed\");\n+            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n+            \" can not be removed\");\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n-          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n-              + src + \" is renamed to \" + dst);\n+          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n+              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree();\n-        \n+\n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n-    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-        +\"failed to rename \"+src+\" to \"+dst);\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n+        \"failed to rename \" + src + \" to \" + dst);\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp)\n      throws IOException {\n    assert fsd.hasWriteLock();\n    INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(src, srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (fsd.isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination \" +\n          \"exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n          \"failed to rename \" + src + \" to \" + dst + \" because destination\u0027s \" +\n          \"parent does not exist\");\n      return false;\n    }\n\n    fsd.ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    fsd.verifyFsLimitsForRename(srcIIP, dstIIP);\n    fsd.verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(fsd, src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      final long removedSrc \u003d fsd.removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst + \" because the source\" +\n            \" can not be removed\");\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory\" +\n              \".unprotectedRenameTo: \" + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \" +\n        \"failed to rename \" + src + \" to \" + dst);\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[src-String, dst-String, timestamp-long]",
            "newValue": "[fsd-FSDirectory, src-String, dst-String, timestamp-long]"
          }
        }
      ]
    },
    "ceed0f6c46736323bd1b077125ff4e217c649208": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6635. Refactor encryption zone functionality into new EncryptionZoneManager class. (wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1608657 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/07/14 9:34 PM",
      "commitName": "ceed0f6c46736323bd1b077125ff4e217c649208",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "07/07/14 1:43 PM",
      "commitNameOld": "dda85637df2c970d905b550c89208ac6ca63994d",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     try {\n       validateRenameSource(src, srcIIP);\n     } catch (SnapshotException e) {\n       throw e;\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n \n     try {\n       validateRenameDestination(src, dst, srcInode);\n     } catch (IOException ignored) {\n       return false;\n     }\n \n     INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n-    checkEncryptionZoneMoveValidity(srcIIP, dstIIP, src);\n+    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n \n     boolean added \u003d false;\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n \n       added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n         tx.updateQuotasInSourceTree();\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(src, srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateRenameDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "c38665282884122d3c82b6f68376cce036aee748": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6516. List of Encryption Zones should be based on inodes (clamb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1607770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/07/14 5:24 PM",
      "commitName": "c38665282884122d3c82b6f68376cce036aee748",
      "commitAuthor": "Charles Lamb",
      "commitDateOld": "02/07/14 5:58 PM",
      "commitNameOld": "2a3bccddd939ee0d6941aa2d22edc67dea85fe35",
      "commitAuthorOld": "Charles Lamb",
      "daysBetweenCommits": 0.98,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,203 +1,203 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n-    checkEncryptionZoneMoveValidity(src, dst);\n+    checkEncryptionZoneMoveValidity(srcIIP, dstIIP, src);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d \n           srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n               srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n         toDst \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount, dstSnapshotId);\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           srcChild \u003d withCount.getReferredINode();\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           srcChild \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (isSrcInSnapshot) {\n           // srcParent must have snapshot feature since isSrcInSnapshot is true\n           // and src node has been removed from srcParent \n           srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // original srcChild is not in latest snapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    checkEncryptionZoneMoveValidity(srcIIP, dstIIP, src);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d \n          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n              srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        toDst \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount, dstSnapshotId);\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          srcChild \u003d withCount.getReferredINode();\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          srcChild \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must have snapshot feature since isSrcInSnapshot is true\n          // and src node has been removed from srcParent \n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // original srcChild is not in latest snapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "31617733aca2025cff1ffb841a533a5b1de016a5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6389. Rename restrictions for encryption zones. (clamb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1606253 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/06/14 2:45 PM",
      "commitName": "31617733aca2025cff1ffb841a533a5b1de016a5",
      "commitAuthor": "Charles Lamb",
      "commitDateOld": "27/06/14 1:43 PM",
      "commitNameOld": "2efea952139b30dd1c881eed0b443ffa72be6dce",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,202 +1,203 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n+    checkEncryptionZoneMoveValidity(src, dst);\n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d \n           srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n               srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n         toDst \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount, dstSnapshotId);\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           srcChild \u003d withCount.getReferredINode();\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           srcChild \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (isSrcInSnapshot) {\n           // srcParent must have snapshot feature since isSrcInSnapshot is true\n           // and src node has been removed from srcParent \n           srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // original srcChild is not in latest snapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    checkEncryptionZoneMoveValidity(src, dst);\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d \n          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n              srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        toDst \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount, dstSnapshotId);\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          srcChild \u003d withCount.getReferredINode();\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          srcChild \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must have snapshot feature since isSrcInSnapshot is true\n          // and src node has been removed from srcParent \n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // original srcChild is not in latest snapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "08986fdbed5a15bcdc57d142922911759b97e9d1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6562. Refactor rename() in FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605016 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/06/14 11:56 PM",
      "commitName": "08986fdbed5a15bcdc57d142922911759b97e9d1",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "22/06/14 12:39 AM",
      "commitNameOld": "1e89eba47d0f291b33fc26f9406231fc70b63a87",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.97,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,202 +1,83 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n-    \n-    // check the validation of the source\n-    if (srcInode \u003d\u003d null) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + \"failed to rename \" + src + \" to \" + dst\n-          + \" because source does not exist\");\n-      return false;\n-    } \n-    if (srcIIP.getINodes().length \u003d\u003d 1) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n+    try {\n+      validateRenameSource(src, srcIIP);\n+    } catch (SnapshotException e) {\n+      throw e;\n+    } catch (IOException ignored) {\n       return false;\n     }\n-    \n-    // srcInode and its subtree cannot contain snapshottable directories with\n-    // snapshots\n-    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n-        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n-    checkSnapshot(srcInode, snapshottableDirs);\n-    \n+\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n-    \n-    // check the validity of the destination\n+\n+    // validate the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n-    if (srcInode.isSymlink() \u0026\u0026 \n-        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n-      throw new FileAlreadyExistsException(\n-          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n-    }\n-    \n-    // dst cannot be directory or a file under src\n-    if (dst.startsWith(src) \u0026\u0026 \n-        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + \"failed to rename \" + src + \" to \" + dst\n-          + \" because destination starts with src\");\n+\n+    try {\n+      validateRenameDestination(src, dst, srcInode);\n+    } catch (IOException ignored) {\n       return false;\n     }\n-    \n-    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n-    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n-    if (dstIIP.isSnapshot()) {\n-      throw new SnapshotAccessControlException(\n-          \"Modification on RO snapshot is disallowed\");\n-    }\n+\n+    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n-    \n+\n+    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+\n     boolean added \u003d false;\n-    INode srcChild \u003d srcIIP.getLastINode();\n-    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n-    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n-        srcIIP.getLatestSnapshotId());\n-    final boolean srcChildIsReference \u003d srcChild.isReference();\n-    \n-    // Record the snapshot on srcChild. After the rename, before any new \n-    // snapshot is taken on the dst tree, changes will be recorded in the latest\n-    // snapshot of the src tree.\n-    if (isSrcInSnapshot) {\n-      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n-      srcIIP.setLastINode(srcChild);\n-    }\n-    \n-    // check srcChild for reference\n-    final INodeReference.WithCount withCount;\n-    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n-    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n-        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n-    if (isSrcInSnapshot) {\n-      final INodeReference.WithName withName \u003d \n-          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n-              srcChild, srcIIP.getLatestSnapshotId()); \n-      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n-      srcChild \u003d withName;\n-      srcIIP.setLastINode(srcChild);\n-      // get the counts before rename\n-      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n-    } else if (srcChildIsReference) {\n-      // srcChild is reference but srcChild is not in latest snapshot\n-      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n-    } else {\n-      withCount \u003d null;\n-    }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n-      \n-      if (dstParent.getParent() \u003d\u003d null) {\n-        // src and dst file/dir are in the same directory, and the dstParent has\n-        // been replaced when we removed the src. Refresh the dstIIP and\n-        // dstParent.\n-        dstIIP \u003d getExistingPathINodes(dstComponents);\n-        dstParent \u003d dstIIP.getINode(-2);\n-      }\n-      \n-      // add src to the destination\n-      \n-      srcChild \u003d srcIIP.getLastINode();\n-      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n-      final INode toDst;\n-      if (withCount \u003d\u003d null) {\n-        srcChild.setLocalName(dstChildName);\n-        toDst \u003d srcChild;\n-      } else {\n-        withCount.getReferredINode().setLocalName(dstChildName);\n-        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n-        toDst \u003d new INodeReference.DstReference(\n-            dstParent.asDirectory(), withCount, dstSnapshotId);\n-      }\n-      \n-      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n+\n+      added \u003d tx.addSourceToDestination();\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n-        // update modification time of dst and the parent of src\n-        final INode srcParent \u003d srcIIP.getINode(-2);\n-        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n-        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n-        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n-        // update moved leases with new filename\n-        getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n-        // update the quota usage in src tree\n-        if (isSrcInSnapshot) {\n-          // get the counts after rename\n-          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n-              Quota.Counts.newInstance(), false);\n-          newSrcCounts.subtract(oldSrcCounts);\n-          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n-              newSrcCounts.get(Quota.DISKSPACE), false);\n-        }\n+        tx.updateMtimeAndLease(timestamp);\n+        tx.updateQuotasInSourceTree();\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n-        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n-        final INode oldSrcChild \u003d srcChild;\n-        // put it back\n-        if (withCount \u003d\u003d null) {\n-          srcChild.setLocalName(srcChildName);\n-        } else if (!srcChildIsReference) { // src must be in snapshot\n-          // the withCount node will no longer be used thus no need to update\n-          // its reference number here\n-          srcChild \u003d withCount.getReferredINode();\n-          srcChild.setLocalName(srcChildName);\n-        } else {\n-          withCount.removeReference(oldSrcChild.asReference());\n-          srcChild \u003d new INodeReference.DstReference(\n-              srcParent, withCount, srcRefDstSnapshot);\n-          withCount.getReferredINode().setLocalName(srcChildName);\n-        }\n-        \n-        if (isSrcInSnapshot) {\n-          // srcParent must have snapshot feature since isSrcInSnapshot is true\n-          // and src node has been removed from srcParent \n-          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n-        } else {\n-          // original srcChild is not in latest snapshot, we only need to add\n-          // the srcChild back\n-          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n-        }\n+        tx.restoreSource();\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    try {\n      validateRenameSource(src, srcIIP);\n    } catch (SnapshotException e) {\n      throw e;\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n\n    try {\n      validateRenameDestination(src, dst, srcInode);\n    } catch (IOException ignored) {\n      return false;\n    }\n\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n\n    boolean added \u003d false;\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n\n      added \u003d tx.addSourceToDestination();\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n        tx.updateQuotasInSourceTree();\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        tx.restoreSource();\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6328. Clean up dead code in FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593755 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/14 10:06 PM",
      "commitName": "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "30/04/14 10:44 AM",
      "commitNameOld": "0689363343a281a6f7f6f395227668bddc2663eb",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 10.47,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,205 +1,202 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d \n           srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n               srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n-        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n+        toDst \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount, dstSnapshotId);\n-        toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n-          final INode originalChild \u003d withCount.getReferredINode();\n-          srcChild \u003d originalChild;\n+          srcChild \u003d withCount.getReferredINode();\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n-          final INodeReference originalRef \u003d new INodeReference.DstReference(\n+          srcChild \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n-          srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (isSrcInSnapshot) {\n           // srcParent must have snapshot feature since isSrcInSnapshot is true\n           // and src node has been removed from srcParent \n           srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // original srcChild is not in latest snapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d \n          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n              srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        toDst \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount, dstSnapshotId);\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          srcChild \u003d withCount.getReferredINode();\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          srcChild \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must have snapshot feature since isSrcInSnapshot is true\n          // and src node has been removed from srcParent \n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // original srcChild is not in latest snapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "0689363343a281a6f7f6f395227668bddc2663eb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6304. Consolidate the logic of path resolution in FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1591411 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/04/14 10:44 AM",
      "commitName": "0689363343a281a6f7f6f395227668bddc2663eb",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "24/04/14 7:05 PM",
      "commitNameOld": "10a037cccb00c9f791da394bf2dc05985fb80612",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,205 +1,205 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n-    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n+    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d \n           srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n               srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount, dstSnapshotId);\n         toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (isSrcInSnapshot) {\n           // srcParent must have snapshot feature since isSrcInSnapshot is true\n           // and src node has been removed from srcParent \n           srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // original srcChild is not in latest snapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d \n          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n              srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount, dstSnapshotId);\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must have snapshot feature since isSrcInSnapshot is true\n          // and src node has been removed from srcParent \n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // original srcChild is not in latest snapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "2b03ae94216a76a477f3d6250d076ebbf61e998a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6099. HDFS file system limits not enforced on renames. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1579122 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/03/14 8:46 PM",
      "commitName": "2b03ae94216a76a477f3d6250d076ebbf61e998a",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "13/03/14 9:52 PM",
      "commitNameOld": "d37c31a2dbb85f6b58baae27db106fabe629a3cd",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.95,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,204 +1,205 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n+    verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d \n           srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n               srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount, dstSnapshotId);\n         toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (isSrcInSnapshot) {\n           // srcParent must have snapshot feature since isSrcInSnapshot is true\n           // and src node has been removed from srcParent \n           srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // original srcChild is not in latest snapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d \n          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n              srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount, dstSnapshotId);\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must have snapshot feature since isSrcInSnapshot is true\n          // and src node has been removed from srcParent \n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // original srcChild is not in latest snapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/14 12:52 PM",
      "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "14/12/13 2:13 AM",
      "commitNameOld": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 24.44,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,207 +1,204 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n-        srcIIP.getLatestSnapshot());\n+        srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n-      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n+      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n-        .getDstSnapshotId() : Snapshot.INVALID_ID;\n+        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d \n           srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n-              srcChild, srcIIP.getLatestSnapshot()); \n+              srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n-      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n-          Snapshot.INVALID_ID);\n+      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n-        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n+        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n-            dstParent.asDirectory(), withCount,\n-            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n+            dstParent.asDirectory(), withCount, dstSnapshotId);\n         toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n-        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n+        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n-        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n+        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n-              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n+              Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (isSrcInSnapshot) {\n           // srcParent must have snapshot feature since isSrcInSnapshot is true\n           // and src node has been removed from srcParent \n-          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild,\n-              srcIIP.getLatestSnapshot());\n+          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // original srcChild is not in latest snapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d \n          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n              srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount, dstSnapshotId);\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must have snapshot feature since isSrcInSnapshot is true\n          // and src node has been removed from srcParent \n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // original srcChild is not in latest snapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5632. Flatten INodeDirectory hierarchy: Replace INodeDirectoryWithSnapshot with DirectoryWithSnapshotFeature.  Contributed by jing9 \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550917 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/12/13 2:13 AM",
      "commitName": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "02/12/13 9:41 AM",
      "commitNameOld": "18159be495f96bde4bd4fa2cacb14aafb87e87bc",
      "commitAuthorOld": "",
      "daysBetweenCommits": 11.69,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,211 +1,207 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n-      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n-          inodeMap);\n+      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d \n           srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n               srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n           Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n-        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n-            inodeMap);\n+        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n-        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n-            inodeMap);\n+        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (isSrcInSnapshot) {\n-          // srcParent must be an INodeDirectoryWithSnapshot instance since\n-          // isSrcInSnapshot is true and src node has been removed from \n-          // srcParent \n-          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n-              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n+          // srcParent must have snapshot feature since isSrcInSnapshot is true\n+          // and src node has been removed from srcParent \n+          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild,\n+              srcIIP.getLatestSnapshot());\n         } else {\n           // original srcChild is not in latest snapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d \n          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n              srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must have snapshot feature since isSrcInSnapshot is true\n          // and src node has been removed from srcParent \n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild,\n              srcIIP.getLatestSnapshot());\n        } else {\n          // original srcChild is not in latest snapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "d46e1608626c64400d2b6c7693a4c035783c55b4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4877. Snapshot: fix the scenario where a directory is renamed under its prior descendant. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490421 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/13 1:15 PM",
      "commitName": "d46e1608626c64400d2b6c7693a4c035783c55b4",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "30/05/13 10:26 AM",
      "commitNameOld": "bf99961d67bf59dad6a861655407f9e0a5f21aa5",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 7.12,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,211 +1,211 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n           inodeMap);\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d \n           srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n               srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n           Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n             inodeMap);\n         dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n             inodeMap);\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n-              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n+              newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (isSrcInSnapshot) {\n           // srcParent must be an INodeDirectoryWithSnapshot instance since\n           // isSrcInSnapshot is true and src node has been removed from \n           // srcParent \n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n           // original srcChild is not in latest snapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n          inodeMap);\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d \n          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n              srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n            inodeMap);\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n            inodeMap);\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must be an INodeDirectoryWithSnapshot instance since\n          // isSrcInSnapshot is true and src node has been removed from \n          // srcParent \n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // original srcChild is not in latest snapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "bf99961d67bf59dad6a861655407f9e0a5f21aa5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4848. copyFromLocal and renaming a file to .snapshot should output that .snapshot is a reserved name. Contributed by Jing Zhao\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1487942 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/13 10:26 AM",
      "commitName": "bf99961d67bf59dad6a861655407f9e0a5f21aa5",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "29/05/13 2:25 PM",
      "commitNameOld": "719034c12c1105e3ab2e033bce30798750e38e2d",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 0.83,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,209 +1,211 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n           inodeMap);\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d \n           srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n               srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n           Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n             inodeMap);\n         dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n             inodeMap);\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n+          srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n+          withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (isSrcInSnapshot) {\n           // srcParent must be an INodeDirectoryWithSnapshot instance since\n           // isSrcInSnapshot is true and src node has been removed from \n           // srcParent \n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n           // original srcChild is not in latest snapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n          inodeMap);\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d \n          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n              srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n            inodeMap);\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n            inodeMap);\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must be an INodeDirectoryWithSnapshot instance since\n          // isSrcInSnapshot is true and src node has been removed from \n          // srcParent \n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // original srcChild is not in latest snapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "59801391400f3fa0ed1f029b7af75627d3288f22": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4809. When a QuotaExceededException is thrown during rename, the quota usage should be subtracted back.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1480508 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/13 5:23 PM",
      "commitName": "59801391400f3fa0ed1f029b7af75627d3288f22",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "06/05/13 5:17 PM",
      "commitNameOld": "393188c445b2fe2c8c674dc982a6ce1070f7d17d",
      "commitAuthorOld": "",
      "daysBetweenCommits": 2.0,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,209 +1,209 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n           inodeMap);\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d \n           srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n               srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n           Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n             inodeMap);\n         dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n             inodeMap);\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n         }\n         \n         if (isSrcInSnapshot) {\n           // srcParent must be an INodeDirectoryWithSnapshot instance since\n           // isSrcInSnapshot is true and src node has been removed from \n           // srcParent \n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n-          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n+          // original srcChild is not in latest snapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n          inodeMap);\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d \n          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n              srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n            inodeMap);\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n            inodeMap);\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must be an INodeDirectoryWithSnapshot instance since\n          // isSrcInSnapshot is true and src node has been removed from \n          // srcParent \n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // original srcChild is not in latest snapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "3a3e0f573129c8308332d4b301a9319ee579d85a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4760. Update inodeMap after node replacement.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1477827 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/04/13 2:05 PM",
      "commitName": "3a3e0f573129c8308332d4b301a9319ee579d85a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "26/04/13 5:05 PM",
      "commitNameOld": "5276f4e04dbeabe4dbcddafaa1cd386b912f6345",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.87,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,205 +1,209 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n-      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n+      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n+          inodeMap);\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     if (isSrcInSnapshot) {\n-      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n-          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n+      final INodeReference.WithName withName \u003d \n+          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n+              srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n           Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n-        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n+        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n+            inodeMap);\n         dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n-        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n+        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n+            inodeMap);\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n         }\n         \n         if (isSrcInSnapshot) {\n           // srcParent must be an INodeDirectoryWithSnapshot instance since\n           // isSrcInSnapshot is true and src node has been removed from \n           // srcParent \n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n          inodeMap);\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d \n          srcIIP.getINode(-2).asDirectory().replaceChild4ReferenceWithName(\n              srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n            inodeMap);\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n            inodeMap);\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must be an INodeDirectoryWithSnapshot instance since\n          // isSrcInSnapshot is true and src node has been removed from \n          // srcParent \n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "9da386584142df9bcc335843674e0d7a905f2230": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4650. Fix a bug in FSDirectory and add more unit tests for rename with existence of snapshottable directories and snapshots.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1476012 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/04/13 6:31 PM",
      "commitName": "9da386584142df9bcc335843674e0d7a905f2230",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "25/04/13 6:19 PM",
      "commitNameOld": "fa500825fab5fcdba20cb2b940c9ee94ccdfa1dd",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,204 +1,205 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n           Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n+        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n         }\n         \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n         }\n         \n         if (isSrcInSnapshot) {\n           // srcParent must be an INodeDirectoryWithSnapshot instance since\n           // isSrcInSnapshot is true and src node has been removed from \n           // srcParent \n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent \u003d dstIIP.getINode(-2); // refresh dstParent\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must be an INodeDirectoryWithSnapshot instance since\n          // isSrcInSnapshot is true and src node has been removed from \n          // srcParent \n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "0fa5cad0b27780c27a284c23101b1099d4886506": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4686. Update quota computation for rename and INodeReference.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1471647 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/04/13 1:31 PM",
      "commitName": "0fa5cad0b27780c27a284c23101b1099d4886506",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "22/04/13 5:00 PM",
      "commitNameOld": "92e0416ced279a910616985bf11fa3f8b1b1de9b",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 1.85,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,187 +1,204 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n+    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n-          .replaceChild4ReferenceWithName(srcChild); \n+          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n+      // get the counts before rename\n+      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n+          Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n       // add src to the destination\n       \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n-        withCount.setParentReference(ref);\n-        withCount.incrementReferenceCount();\n         toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved leases with new filename\n-        getFSNamesystem().unprotectedChangeLease(src, dst);        \n+        getFSNamesystem().unprotectedChangeLease(src, dst);     \n \n+        // update the quota usage in src tree\n+        if (isSrcInSnapshot) {\n+          // get the counts after rename\n+          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n+              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n+          newSrcCounts.subtract(oldSrcCounts);\n+          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n+              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n+        }\n+        \n         return true;\n       }\n     } finally {\n       if (!added) {\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n+          // the withCount node will no longer be used thus no need to update\n+          // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n         } else {\n+          withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n-          withCount.setParentReference(originalRef);\n           srcChild \u003d originalRef;\n         }\n         \n         if (isSrcInSnapshot) {\n+          // srcParent must be an INodeDirectoryWithSnapshot instance since\n+          // isSrcInSnapshot is true and src node has been removed from \n+          // srcParent \n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);     \n\n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n        }\n        \n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n        }\n        \n        if (isSrcInSnapshot) {\n          // srcParent must be an INodeDirectoryWithSnapshot instance since\n          // isSrcInSnapshot is true and src node has been removed from \n          // srcParent \n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "6bda1f20ad396918edde211f709f5819a361b51e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4700. Fix the undo section of rename with snapshots.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1468632 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/04/13 3:03 PM",
      "commitName": "6bda1f20ad396918edde211f709f5819a361b51e",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "15/04/13 2:42 PM",
      "commitNameOld": "d13f6ebe20aaf5ec31c4298db3e2e761f72e906e",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 1.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,187 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     \n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     checkSnapshot(srcInode, snapshottableDirs);\n     \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n-    if (srcChildIsReference || isSrcInSnapshot) {\n+    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n+        .getDstSnapshotId() : Snapshot.INVALID_ID;\n+    if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild); \n-      withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n+      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n+    } else if (srcChildIsReference) {\n+      // srcChild is reference but srcChild is not in latest snapshot\n+      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n-      // add src to the destination\n       if (dstParent.getParent() \u003d\u003d null) {\n         // src and dst file/dir are in the same directory, and the dstParent has\n         // been replaced when we removed the src. Refresh the dstIIP and\n         // dstParent.\n         dstIIP \u003d getExistingPathINodes(dstComponents);\n         dstParent \u003d dstIIP.getINode(-2);\n       }\n       \n+      // add src to the destination\n+      \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstParent.asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         withCount.setParentReference(ref);\n         withCount.incrementReferenceCount();\n         toDst \u003d ref;\n       }\n       \n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);        \n \n         return true;\n       }\n     } finally {\n       if (!added) {\n+        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n+        final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n-          final INodeDirectoryWithSnapshot srcParent \u003d \n-              (INodeDirectoryWithSnapshot) srcIIP.getINode(-2).asDirectory();\n           final INode originalChild \u003d withCount.getReferredINode();\n-          srcParent.replaceRemovedChild(srcChild, originalChild);\n           srcChild \u003d originalChild;\n+        } else {\n+          final INodeReference originalRef \u003d new INodeReference.DstReference(\n+              srcParent, withCount, srcRefDstSnapshot);\n+          withCount.setParentReference(originalRef);\n+          srcChild \u003d originalRef;\n         }\n-        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n+        \n+        if (isSrcInSnapshot) {\n+          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n+              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n+        } else {\n+          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n+          // the srcChild back\n+          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n+        }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      // add src to the destination\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        withCount.setParentReference(ref);\n        withCount.incrementReferenceCount();\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n        } else {\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          withCount.setParentReference(originalRef);\n          srcChild \u003d originalRef;\n        }\n        \n        if (isSrcInSnapshot) {\n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "9c6a7bebe23ffb85d7fd95607f3b7bb4fe82dbe4": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-4675. Fix rename across snapshottable directories.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1467540 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/04/13 7:48 PM",
      "commitName": "9c6a7bebe23ffb85d7fd95607f3b7bb4fe82dbe4",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-4675. Fix rename across snapshottable directories.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1467540 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/04/13 7:48 PM",
          "commitName": "9c6a7bebe23ffb85d7fd95607f3b7bb4fe82dbe4",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "10/04/13 1:17 PM",
          "commitNameOld": "3209d4a3c4d4c227ca50bbcd1ab3e939beceec35",
          "commitAuthorOld": "",
          "daysBetweenCommits": 2.27,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,143 +1,169 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n-    FileAlreadyExistsException, SnapshotAccessControlException {\n+    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n+    \n+    // srcInode and its subtree cannot contain snapshottable directories with\n+    // snapshots\n+    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n+        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n+    checkSnapshot(srcInode, snapshottableDirs);\n+    \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n-    final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n+    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n-    final INode dstParent \u003d dstIIP.getINode(-2);\n+    INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n+    // Record the snapshot on srcChild. After the rename, before any new \n+    // snapshot is taken on the dst tree, changes will be recorded in the latest\n+    // snapshot of the src tree.\n+    if (isSrcInSnapshot) {\n+      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n+      srcIIP.setLastINode(srcChild);\n+    }\n+    \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     if (srcChildIsReference || isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild); \n       withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n+      // add src to the destination\n+      if (dstParent.getParent() \u003d\u003d null) {\n+        // src and dst file/dir are in the same directory, and the dstParent has\n+        // been replaced when we removed the src. Refresh the dstIIP and\n+        // dstParent.\n+        dstIIP \u003d getExistingPathINodes(dstComponents);\n+        dstParent \u003d dstIIP.getINode(-2);\n+      }\n+      \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n-        final INodeReference ref \u003d new INodeReference(dstIIP.getINode(-2), withCount);\n+        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n+        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n+            dstParent.asDirectory(), withCount,\n+            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         withCount.setParentReference(ref);\n         withCount.incrementReferenceCount();\n         toDst \u003d ref;\n       }\n       \n-      // add src to the destination\n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);        \n \n         return true;\n       }\n     } finally {\n       if (!added) {\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           final INodeDirectoryWithSnapshot srcParent \u003d \n               (INodeDirectoryWithSnapshot) srcIIP.getINode(-2).asDirectory();\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcParent.replaceRemovedChild(srcChild, originalChild);\n           srcChild \u003d originalChild;\n         }\n         addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    if (srcChildIsReference || isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild); \n      withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      // add src to the destination\n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        withCount.setParentReference(ref);\n        withCount.incrementReferenceCount();\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          final INodeDirectoryWithSnapshot srcParent \u003d \n              (INodeDirectoryWithSnapshot) srcIIP.getINode(-2).asDirectory();\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcParent.replaceRemovedChild(srcChild, originalChild);\n          srcChild \u003d originalChild;\n        }\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {
            "oldValue": "[QuotaExceededException, UnresolvedLinkException, FileAlreadyExistsException, SnapshotAccessControlException]",
            "newValue": "[QuotaExceededException, UnresolvedLinkException, FileAlreadyExistsException, SnapshotAccessControlException, IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-4675. Fix rename across snapshottable directories.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1467540 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/04/13 7:48 PM",
          "commitName": "9c6a7bebe23ffb85d7fd95607f3b7bb4fe82dbe4",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "10/04/13 1:17 PM",
          "commitNameOld": "3209d4a3c4d4c227ca50bbcd1ab3e939beceec35",
          "commitAuthorOld": "",
          "daysBetweenCommits": 2.27,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,143 +1,169 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n-    FileAlreadyExistsException, SnapshotAccessControlException {\n+    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n+    \n+    // srcInode and its subtree cannot contain snapshottable directories with\n+    // snapshots\n+    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n+        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n+    checkSnapshot(srcInode, snapshottableDirs);\n+    \n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n-    final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n+    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n-    final INode dstParent \u003d dstIIP.getINode(-2);\n+    INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n+    // Record the snapshot on srcChild. After the rename, before any new \n+    // snapshot is taken on the dst tree, changes will be recorded in the latest\n+    // snapshot of the src tree.\n+    if (isSrcInSnapshot) {\n+      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n+      srcIIP.setLastINode(srcChild);\n+    }\n+    \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     if (srcChildIsReference || isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild); \n       withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n     } else {\n       withCount \u003d null;\n     }\n \n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       \n+      // add src to the destination\n+      if (dstParent.getParent() \u003d\u003d null) {\n+        // src and dst file/dir are in the same directory, and the dstParent has\n+        // been replaced when we removed the src. Refresh the dstIIP and\n+        // dstParent.\n+        dstIIP \u003d getExistingPathINodes(dstComponents);\n+        dstParent \u003d dstIIP.getINode(-2);\n+      }\n+      \n       srcChild \u003d srcIIP.getLastINode();\n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n-        final INodeReference ref \u003d new INodeReference(dstIIP.getINode(-2), withCount);\n+        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n+        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n+            dstParent.asDirectory(), withCount,\n+            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         withCount.setParentReference(ref);\n         withCount.incrementReferenceCount();\n         toDst \u003d ref;\n       }\n       \n-      // add src to the destination\n       added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);        \n \n         return true;\n       }\n     } finally {\n       if (!added) {\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           final INodeDirectoryWithSnapshot srcParent \u003d \n               (INodeDirectoryWithSnapshot) srcIIP.getINode(-2).asDirectory();\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcParent.replaceRemovedChild(srcChild, originalChild);\n           srcChild \u003d originalChild;\n         }\n         addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException, IOException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    \n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    checkSnapshot(srcInode, snapshottableDirs);\n    \n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    if (srcChildIsReference || isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild); \n      withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      // add src to the destination\n      if (dstParent.getParent() \u003d\u003d null) {\n        // src and dst file/dir are in the same directory, and the dstParent has\n        // been replaced when we removed the src. Refresh the dstIIP and\n        // dstParent.\n        dstIIP \u003d getExistingPathINodes(dstComponents);\n        dstParent \u003d dstIIP.getINode(-2);\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstParent.asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        withCount.setParentReference(ref);\n        withCount.incrementReferenceCount();\n        toDst \u003d ref;\n      }\n      \n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          final INodeDirectoryWithSnapshot srcParent \u003d \n              (INodeDirectoryWithSnapshot) srcIIP.getINode(-2).asDirectory();\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcParent.replaceRemovedChild(srcChild, originalChild);\n          srcChild \u003d originalChild;\n        }\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {}
        }
      ]
    },
    "ca848beb533790ae8abb6498f5d4676594fbae4c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4647. Rename should call setLocalName after an inode is removed from snapshots.  Contributed by Arpit Agarwal\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1464795 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/04/13 4:52 PM",
      "commitName": "ca848beb533790ae8abb6498f5d4676594fbae4c",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "01/04/13 4:24 PM",
      "commitNameOld": "1096917649fd951be633e5619518764f23cca645",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,143 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     final INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n-    final INode srcChild \u003d srcIIP.getLastINode();\n+    INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n+    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n+        srcIIP.getLatestSnapshot());\n+    final boolean srcChildIsReference \u003d srcChild.isReference();\n+    \n+    // check srcChild for reference\n+    final INodeReference.WithCount withCount;\n+    if (srcChildIsReference || isSrcInSnapshot) {\n+      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n+          .replaceChild4ReferenceWithName(srcChild); \n+      withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n+      srcChild \u003d withName;\n+      srcIIP.setLastINode(srcChild);\n+    } else {\n+      withCount \u003d null;\n+    }\n+\n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n-      //TODO: setLocalName breaks created/deleted lists\n-      srcChild.setLocalName(dstIIP.getLastLocalName());\n+      \n+      srcChild \u003d srcIIP.getLastINode();\n+      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n+      final INode toDst;\n+      if (withCount \u003d\u003d null) {\n+        srcChild.setLocalName(dstChildName);\n+        toDst \u003d srcChild;\n+      } else {\n+        withCount.getReferredINode().setLocalName(dstChildName);\n+        final INodeReference ref \u003d new INodeReference(dstIIP.getINode(-2), withCount);\n+        withCount.setParentReference(ref);\n+        withCount.incrementReferenceCount();\n+        toDst \u003d ref;\n+      }\n       \n       // add src to the destination\n-      added \u003d addLastINodeNoQuotaCheck(dstIIP, srcChild);\n+      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);        \n \n-        if (srcIIP.getLatestSnapshot() !\u003d null) {\n-          createReferences4Rename(srcChild, srcChildName,\n-              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n-              dstParent.asDirectory());\n-        }\n         return true;\n       }\n     } finally {\n       if (!added) {\n         // put it back\n-        srcChild.setLocalName(srcChildName);\n+        if (withCount \u003d\u003d null) {\n+          srcChild.setLocalName(srcChildName);\n+        } else if (!srcChildIsReference) { // src must be in snapshot\n+          final INodeDirectoryWithSnapshot srcParent \u003d \n+              (INodeDirectoryWithSnapshot) srcIIP.getINode(-2).asDirectory();\n+          final INode originalChild \u003d withCount.getReferredINode();\n+          srcParent.replaceRemovedChild(srcChild, originalChild);\n+          srcChild \u003d originalChild;\n+        }\n         addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    final INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    if (srcChildIsReference || isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild); \n      withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n    } else {\n      withCount \u003d null;\n    }\n\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        final INodeReference ref \u003d new INodeReference(dstIIP.getINode(-2), withCount);\n        withCount.setParentReference(ref);\n        withCount.incrementReferenceCount();\n        toDst \u003d ref;\n      }\n      \n      // add src to the destination\n      added \u003d addLastINodeNoQuotaCheck(dstIIP, toDst);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n\n        return true;\n      }\n    } finally {\n      if (!added) {\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          final INodeDirectoryWithSnapshot srcParent \u003d \n              (INodeDirectoryWithSnapshot) srcIIP.getINode(-2).asDirectory();\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcParent.replaceRemovedChild(srcChild, originalChild);\n          srcChild \u003d originalChild;\n        }\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "1096917649fd951be633e5619518764f23cca645": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4611. Update FSImage for INodeReference.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1463332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/04/13 4:24 PM",
      "commitName": "1096917649fd951be633e5619518764f23cca645",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "28/03/13 9:18 AM",
      "commitNameOld": "25aab4203c465403ae0c4ad62ec948094e023489",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.3,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,112 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     final INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     final INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     try {\n       // remove src\n       final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n-      srcChild.setLocalName(dstComponents[dstComponents.length - 1]);\n+      //TODO: setLocalName breaks created/deleted lists\n+      srcChild.setLocalName(dstIIP.getLastLocalName());\n       \n       // add src to the destination\n       added \u003d addLastINodeNoQuotaCheck(dstIIP, srcChild);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);        \n \n         if (srcIIP.getLatestSnapshot() !\u003d null) {\n           createReferences4Rename(srcChild, srcChildName,\n               (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n               dstParent.asDirectory());\n         }\n         return true;\n       }\n     } finally {\n       if (!added) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    final INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    final INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      //TODO: setLocalName breaks created/deleted lists\n      srcChild.setLocalName(dstIIP.getLastLocalName());\n      \n      // add src to the destination\n      added \u003d addLastINodeNoQuotaCheck(dstIIP, srcChild);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n\n        if (srcIIP.getLatestSnapshot() !\u003d null) {\n          createReferences4Rename(srcChild, srcChildName,\n              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n              dstParent.asDirectory());\n        }\n        return true;\n      }\n    } finally {\n      if (!added) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "25aab4203c465403ae0c4ad62ec948094e023489": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4636. Update quota usage when deleting files/dirs that were created after taking the latest snapshot. Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1462192 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/03/13 9:18 AM",
      "commitName": "25aab4203c465403ae0c4ad62ec948094e023489",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "25/03/13 3:21 AM",
      "commitNameOld": "cc2f96f655d0fd4121125fc801056571f4a20a2a",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.25,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,111 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     final INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     final INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     try {\n       // remove src\n-      final int removedSrc \u003d removeLastINode(srcIIP);\n+      final long removedSrc \u003d removeLastINode(srcIIP);\n       if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChild.setLocalName(dstComponents[dstComponents.length - 1]);\n       \n       // add src to the destination\n       added \u003d addLastINodeNoQuotaCheck(dstIIP, srcChild);\n       if (added) {\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);        \n \n         if (srcIIP.getLatestSnapshot() !\u003d null) {\n           createReferences4Rename(srcChild, srcChildName,\n               (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n               dstParent.asDirectory());\n         }\n         return true;\n       }\n     } finally {\n       if (!added) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    final INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    final INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    try {\n      // remove src\n      final long removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChild.setLocalName(dstComponents[dstComponents.length - 1]);\n      \n      // add src to the destination\n      added \u003d addLastINodeNoQuotaCheck(dstIIP, srcChild);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n\n        if (srcIIP.getLatestSnapshot() !\u003d null) {\n          createReferences4Rename(srcChild, srcChildName,\n              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n              dstParent.asDirectory());\n        }\n        return true;\n      }\n    } finally {\n      if (!added) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "9701555899315c94584b24d8717c1d7540a4a491": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4534. Add INodeReference in order to support rename with snapshots.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1458164 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/03/13 11:27 PM",
      "commitName": "9701555899315c94584b24d8717c1d7540a4a491",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "11/03/13 7:41 PM",
      "commitNameOld": "3b3ea5c4220e674064c7603a449f63904c10bac1",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 7.16,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,111 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException {\n     assert hasWriteLock();\n     INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n     if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     final INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n-    INode srcChild \u003d null;\n-    byte[] srcChildName \u003d null;\n+    final INode srcChild \u003d srcIIP.getLastINode();\n+    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     try {\n       // remove src\n-      srcChild \u003d removeLastINode(srcIIP);\n-      if (srcChild \u003d\u003d null) {\n+      final int removedSrc \u003d removeLastINode(srcIIP);\n+      if (removedSrc \u003d\u003d -1) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n-      srcChildName \u003d srcChild.getLocalNameBytes();\n       srcChild.setLocalName(dstComponents[dstComponents.length - 1]);\n       \n       // add src to the destination\n       added \u003d addLastINodeNoQuotaCheck(dstIIP, srcChild);\n       if (added) {\n-        srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);        \n+\n+        if (srcIIP.getLatestSnapshot() !\u003d null) {\n+          createReferences4Rename(srcChild, srcChildName,\n+              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n+              dstParent.asDirectory());\n+        }\n         return true;\n       }\n     } finally {\n-      if (!added \u0026\u0026 srcChild !\u003d null) {\n+      if (!added) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    final INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    final INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    try {\n      // remove src\n      final int removedSrc \u003d removeLastINode(srcIIP);\n      if (removedSrc \u003d\u003d -1) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChild.setLocalName(dstComponents[dstComponents.length - 1]);\n      \n      // add src to the destination\n      added \u003d addLastINodeNoQuotaCheck(dstIIP, srcChild);\n      if (added) {\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n\n        if (srcIIP.getLatestSnapshot() !\u003d null) {\n          createReferences4Rename(srcChild, srcChildName,\n              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n              dstParent.asDirectory());\n        }\n        return true;\n      }\n    } finally {\n      if (!added) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "b1333e5b561d01a010e2e1311e8501879f377bdc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4545. With snapshots, FSDirectory.unprotectedSetReplication(..) always changes file replication but it may or may not changes block replication.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1452636 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/03/13 6:23 PM",
      "commitName": "b1333e5b561d01a010e2e1311e8501879f377bdc",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "27/02/13 7:08 PM",
      "commitNameOld": "c7cf85ccb4ff2f58839e113f1baf903a468b606d",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.97,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,107 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException {\n     assert hasWriteLock();\n-    INodesInPath srcInodesInPath \u003d rootDir.getINodesInPath4Write(src, false);\n-    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n-    INode srcInode \u003d srcInodes[srcInodes.length-1];\n+    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n+    final INode srcInode \u003d srcIIP.getLastINode();\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n-    if (srcInodes.length \u003d\u003d 1) {\n+    if (srcIIP.getINodes().length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n-        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n+        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n-    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n-        dstComponents.length, false);\n-    if (dstInodesInPath.isSnapshot()) {\n+    final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n+    if (dstIIP.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n-    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n-    if (dstInodes[dstInodes.length-1] !\u003d null) {\n+    if (dstIIP.getLastINode() !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n-    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n+    final INode dstParent \u003d dstIIP.getINode(-2);\n+    if (dstParent \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n-    verifyQuotaForRename(srcInodes, dstInodes);\n+    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     \n     boolean added \u003d false;\n     INode srcChild \u003d null;\n     byte[] srcChildName \u003d null;\n     try {\n       // remove src\n-      srcChild \u003d removeLastINode(srcInodesInPath);\n+      srcChild \u003d removeLastINode(srcIIP);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalNameBytes();\n-      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n+      srcChild.setLocalName(dstComponents[dstComponents.length - 1]);\n       \n       // add src to the destination\n-      added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n+      added \u003d addLastINodeNoQuotaCheck(dstIIP, srcChild);\n       if (added) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n-        srcInodes[srcInodes.length-2].updateModificationTime(timestamp,\n-            srcInodesInPath.getLatestSnapshot());\n-        dstInodes[dstInodes.length-2].updateModificationTime(timestamp,\n-            dstInodesInPath.getLatestSnapshot());\n+        final INode srcParent \u003d srcIIP.getINode(-2);\n+        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n+        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);        \n         return true;\n       }\n     } finally {\n       if (!added \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n-        addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n+        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException {\n    assert hasWriteLock();\n    INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INodesInPath dstIIP \u003d getExistingPathINodes(dstComponents);\n    if (dstIIP.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    if (dstIIP.getLastINode() !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    final INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    \n    boolean added \u003d false;\n    INode srcChild \u003d null;\n    byte[] srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeLastINode(srcIIP);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalNameBytes();\n      srcChild.setLocalName(dstComponents[dstComponents.length - 1]);\n      \n      // add src to the destination\n      added \u003d addLastINodeNoQuotaCheck(dstIIP, srcChild);\n      if (added) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n        return true;\n      }\n    } finally {\n      if (!added \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "2372e394dd99d69d396327d5a5e172953a8b8c6a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4189. Renames the getMutableXxx methods to getXxx4Write and fix a bug that some getExistingPathINodes calls should be getINodesInPath4Write.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1441193 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/01/13 1:13 PM",
      "commitName": "2372e394dd99d69d396327d5a5e172953a8b8c6a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "25/01/13 4:01 PM",
      "commitNameOld": "a3bf2083867db5d848ea14f145d120f02b820af2",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 5.88,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException {\n     assert hasWriteLock();\n-    INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src, false);\n+    INodesInPath srcInodesInPath \u003d rootDir.getINodesInPath4Write(src, false);\n     INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     if (dstInodesInPath.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n     boolean added \u003d false;\n     INode srcChild \u003d null;\n     byte[] srcChildName \u003d null;\n     try {\n       // remove src\n       srcChild \u003d removeLastINode(srcInodesInPath);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalNameBytes();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n       added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n       if (added) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         srcInodes[srcInodes.length-2].updateModificationTime(timestamp,\n             srcInodesInPath.getLatestSnapshot());\n         dstInodes[dstInodes.length-2].updateModificationTime(timestamp,\n             dstInodesInPath.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);        \n         return true;\n       }\n     } finally {\n       if (!added \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException {\n    assert hasWriteLock();\n    INodesInPath srcInodesInPath \u003d rootDir.getINodesInPath4Write(src, false);\n    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    if (dstInodesInPath.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    boolean added \u003d false;\n    INode srcChild \u003d null;\n    byte[] srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeLastINode(srcInodesInPath);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalNameBytes();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n      if (added) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].updateModificationTime(timestamp,\n            srcInodesInPath.getLatestSnapshot());\n        dstInodes[dstInodes.length-2].updateModificationTime(timestamp,\n            dstInodesInPath.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n        return true;\n      }\n    } finally {\n      if (!added \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "b9f965de120b5278ac84a7e98aecb32aafde4c16": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4103. Support O(1) snapshot creation.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1424782 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/12/12 5:30 PM",
      "commitName": "b9f965de120b5278ac84a7e98aecb32aafde4c16",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "16/12/12 7:40 PM",
      "commitNameOld": "cbbaa93ae09bf5cf643263faf78f99315c4f3a8d",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.91,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,110 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException {\n     assert hasWriteLock();\n     INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src, false);\n     INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     if (dstInodesInPath.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n     boolean added \u003d false;\n     INode srcChild \u003d null;\n-    String srcChildName \u003d null;\n+    byte[] srcChildName \u003d null;\n     try {\n       // remove src\n       srcChild \u003d removeLastINode(srcInodesInPath);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n-      srcChildName \u003d srcChild.getLocalName();\n+      srcChildName \u003d srcChild.getLocalNameBytes();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n       added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n       if (added) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n-        srcInodes[srcInodes.length-2].updateModificationTime(timestamp);\n-        dstInodes[dstInodes.length-2].updateModificationTime(timestamp);\n+        srcInodes[srcInodes.length-2].updateModificationTime(timestamp,\n+            srcInodesInPath.getLatestSnapshot());\n+        dstInodes[dstInodes.length-2].updateModificationTime(timestamp,\n+            dstInodesInPath.getLatestSnapshot());\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);        \n         return true;\n       }\n     } finally {\n       if (!added \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException {\n    assert hasWriteLock();\n    INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src, false);\n    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    if (dstInodesInPath.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    boolean added \u003d false;\n    INode srcChild \u003d null;\n    byte[] srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeLastINode(srcInodesInPath);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalNameBytes();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n      if (added) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].updateModificationTime(timestamp,\n            srcInodesInPath.getLatestSnapshot());\n        dstInodes[dstInodes.length-2].updateModificationTime(timestamp,\n            dstInodesInPath.getLatestSnapshot());\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n        return true;\n      }\n    } finally {\n      if (!added \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "cbbaa93ae09bf5cf643263faf78f99315c4f3a8d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4317. Change INode and its subclasses to support HDFS-4103.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1422748 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/12/12 7:40 PM",
      "commitName": "cbbaa93ae09bf5cf643263faf78f99315c4f3a8d",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "10/12/12 3:54 PM",
      "commitNameOld": "39d25fbac331ede57196f7a2d2d5e26e2fbc1c9f",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 6.16,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,108 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException {\n     assert hasWriteLock();\n     INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src, false);\n     INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     if (dstInodesInPath.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n     boolean added \u003d false;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n       srcChild \u003d removeLastINode(srcInodesInPath);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n       added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n       if (added) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n-        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n-        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n+        srcInodes[srcInodes.length-2].updateModificationTime(timestamp);\n+        dstInodes[dstInodes.length-2].updateModificationTime(timestamp);\n         // update moved leases with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);        \n         return true;\n       }\n     } finally {\n       if (!added \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException {\n    assert hasWriteLock();\n    INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src, false);\n    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    if (dstInodesInPath.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    boolean added \u003d false;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeLastINode(srcInodesInPath);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n      if (added) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].updateModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].updateModificationTime(timestamp);\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n        return true;\n      }\n    } finally {\n      if (!added \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "9821af9ce8a56a2c583f1ed938902c20e897048f": {
      "type": "Ybodychange",
      "commitMessage": "Reverting the previous merge r1416603 which committed some extra changes\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1416712 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/12/12 2:43 PM",
      "commitName": "9821af9ce8a56a2c583f1ed938902c20e897048f",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "03/12/12 10:04 AM",
      "commitNameOld": "d500d59cbef51f1b0b0291995893b85a139bcec9",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,106 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException, SnapshotAccessControlException {\n     assert hasWriteLock();\n     INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src, false);\n     INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     if (dstInodesInPath.isSnapshot()) {\n       throw new SnapshotAccessControlException(\n           \"Modification on RO snapshot is disallowed\");\n     }\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n     boolean added \u003d false;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n       srcChild \u003d removeLastINode(srcInodesInPath);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n       added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n       if (added) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n-        srcInodes[srcInodes.length-2].updateModificationTime(timestamp);\n-        dstInodes[dstInodes.length-2].updateModificationTime(timestamp);\n-        // update moved leases with new filename\n-        getFSNamesystem().unprotectedChangeLease(src, dst);        \n+        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n+        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n         return true;\n       }\n     } finally {\n       if (!added \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException {\n    assert hasWriteLock();\n    INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src, false);\n    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    if (dstInodesInPath.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    boolean added \u003d false;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeLastINode(srcInodesInPath);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n      if (added) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (!added \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "88eea2157275d4c7e1bf70cac98fe52c326f3585": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4248. Renaming directories may incorrectly remove the paths in leases under the tree.  Contributed by daryn\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1416064 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/12/12 2:29 PM",
      "commitName": "88eea2157275d4c7e1bf70cac98fe52c326f3585",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "27/11/12 2:36 PM",
      "commitNameOld": "9047eb516261b8c9c380d140a43dfdd5d701dee5",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.0,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,104 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException {\n     assert hasWriteLock();\n     INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n     INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n     boolean added \u003d false;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n       srcChild \u003d removeLastINode(srcInodesInPath);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n       added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n       if (added) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n+        // update moved leases with new filename\n+        getFSNamesystem().unprotectedChangeLease(src, dst);        \n         return true;\n       }\n     } finally {\n       if (!added \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException {\n    assert hasWriteLock();\n    INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    boolean added \u003d false;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeLastINode(srcInodesInPath);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n      if (added) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        // update moved leases with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);        \n        return true;\n      }\n    } finally {\n      if (!added \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "9047eb516261b8c9c380d140a43dfdd5d701dee5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4209. Clean up the addNode/addChild/addChildNoQuotaCheck methods in FSDirectory and INodeDirectory.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1414447 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/12 2:36 PM",
      "commitName": "9047eb516261b8c9c380d140a43dfdd5d701dee5",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "21/11/12 11:27 AM",
      "commitNameOld": "0f1899ee19ab13d5128801063b0ce17612c0e96f",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 6.13,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,102 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException {\n     assert hasWriteLock();\n     INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n     INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n-    INode dstChild \u003d null;\n+    boolean added \u003d false;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n-      srcChild \u003d removeChild(srcInodesInPath, srcInodes.length-1);\n+      srcChild \u003d removeLastINode(srcInodesInPath);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n-      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length-1,\n-          srcChild, UNKNOWN_DISK_SPACE);\n-      if (dstChild !\u003d null) {\n+      added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n+      if (added) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n         return true;\n       }\n     } finally {\n-      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n+      if (!added \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n-        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, srcChild, \n-            UNKNOWN_DISK_SPACE);\n+        addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException {\n    assert hasWriteLock();\n    INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    boolean added \u003d false;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeLastINode(srcInodesInPath);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      added \u003d addLastINodeNoQuotaCheck(dstInodesInPath, srcChild);\n      if (added) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (!added \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, srcChild);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "d66f9e8269424f588180f2659c8cf132a2a7dfc9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4206. Change the fields in INode and its subclasses to private.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1410996 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/12 2:03 PM",
      "commitName": "d66f9e8269424f588180f2659c8cf132a2a7dfc9",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "14/11/12 11:21 AM",
      "commitNameOld": "59e4199d842d8590d2c73c6dba805a9746e1ef4a",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 4.11,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,104 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException {\n     assert hasWriteLock();\n     INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n     INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n-        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n+        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n     INode dstChild \u003d null;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n       srcChild \u003d removeChild(srcInodesInPath, srcInodes.length-1);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n       dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length-1,\n           srcChild, UNKNOWN_DISK_SPACE);\n       if (dstChild !\u003d null) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n         return true;\n       }\n     } finally {\n       if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, srcChild, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException {\n    assert hasWriteLock();\n    INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    INode dstChild \u003d null;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeChild(srcInodesInPath, srcInodes.length-1);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length-1,\n          srcChild, UNKNOWN_DISK_SPACE);\n      if (dstChild !\u003d null) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, srcChild, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "2116d0520e528c44fa280f2a5b28594c6d6fc28a": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-4148. Disallow write/modify operations on files and directories in a snapshot. Contributed by Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1409023 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/11/12 3:26 PM",
      "commitName": "2116d0520e528c44fa280f2a5b28594c6d6fc28a",
      "commitAuthor": "Suresh Srinivas",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-4148. Disallow write/modify operations on files and directories in a snapshot. Contributed by Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1409023 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/11/12 3:26 PM",
          "commitName": "2116d0520e528c44fa280f2a5b28594c6d6fc28a",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "13/11/12 11:59 AM",
          "commitNameOld": "099762a0bc960066f8157fdd1e495b6752a6f802",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,104 +1,108 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n-    FileAlreadyExistsException {\n+    FileAlreadyExistsException, SnapshotAccessControlException {\n     assert hasWriteLock();\n-    INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n+    INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src, false);\n     INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n+    if (dstInodesInPath.isSnapshot()) {\n+      throw new SnapshotAccessControlException(\n+          \"Modification on RO snapshot is disallowed\");\n+    }\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n     INode dstChild \u003d null;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n       srcChild \u003d removeChild(srcInodesInPath, srcInodes.length-1);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n       dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length-1,\n           srcChild, UNKNOWN_DISK_SPACE);\n       if (dstChild !\u003d null) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n         return true;\n       }\n     } finally {\n       if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, srcChild, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException {\n    assert hasWriteLock();\n    INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src, false);\n    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    if (dstInodesInPath.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    INode dstChild \u003d null;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeChild(srcInodesInPath, srcInodes.length-1);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length-1,\n          srcChild, UNKNOWN_DISK_SPACE);\n      if (dstChild !\u003d null) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, srcChild, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {
            "oldValue": "[QuotaExceededException, UnresolvedLinkException, FileAlreadyExistsException]",
            "newValue": "[QuotaExceededException, UnresolvedLinkException, FileAlreadyExistsException, SnapshotAccessControlException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-4148. Disallow write/modify operations on files and directories in a snapshot. Contributed by Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1409023 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/11/12 3:26 PM",
          "commitName": "2116d0520e528c44fa280f2a5b28594c6d6fc28a",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "13/11/12 11:59 AM",
          "commitNameOld": "099762a0bc960066f8157fdd1e495b6752a6f802",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,104 +1,108 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n-    FileAlreadyExistsException {\n+    FileAlreadyExistsException, SnapshotAccessControlException {\n     assert hasWriteLock();\n-    INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n+    INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src, false);\n     INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n+    if (dstInodesInPath.isSnapshot()) {\n+      throw new SnapshotAccessControlException(\n+          \"Modification on RO snapshot is disallowed\");\n+    }\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n     INode dstChild \u003d null;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n       srcChild \u003d removeChild(srcInodesInPath, srcInodes.length-1);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n       dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length-1,\n           srcChild, UNKNOWN_DISK_SPACE);\n       if (dstChild !\u003d null) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n         return true;\n       }\n     } finally {\n       if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, srcChild, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException, SnapshotAccessControlException {\n    assert hasWriteLock();\n    INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src, false);\n    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    if (dstInodesInPath.isSnapshot()) {\n      throw new SnapshotAccessControlException(\n          \"Modification on RO snapshot is disallowed\");\n    }\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    INode dstChild \u003d null;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeChild(srcInodesInPath, srcInodes.length-1);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length-1,\n          srcChild, UNKNOWN_DISK_SPACE);\n      if (dstChild !\u003d null) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, srcChild, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {}
        }
      ]
    },
    "34413c2000d9262faa37fde88a72939587edc776": {
      "type": "Ybodychange",
      "commitMessage": "svn merge -c 1406006 from trunk for HDFS-4151. Change the methods in FSDirectory to pass INodesInPath instead of INode[] as a parameter.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1406014 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/11/12 3:56 PM",
      "commitName": "34413c2000d9262faa37fde88a72939587edc776",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "04/11/12 5:22 PM",
      "commitNameOld": "b3bc2fb76e1aca8e7327d1d1a6e4c8a013c575de",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,104 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException {\n     assert hasWriteLock();\n-    INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n+    INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n+    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n     INode dstChild \u003d null;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n-      srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n+      srcChild \u003d removeChild(srcInodesInPath, srcInodes.length-1);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n-      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n+      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length-1,\n           srcChild, UNKNOWN_DISK_SPACE);\n       if (dstChild !\u003d null) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n         return true;\n       }\n     } finally {\n       if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n-        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n+        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, srcChild, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException {\n    assert hasWriteLock();\n    INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    INode dstChild \u003d null;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeChild(srcInodesInPath, srcInodes.length-1);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length-1,\n          srcChild, UNKNOWN_DISK_SPACE);\n      if (dstChild !\u003d null) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, srcChild, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "7ee5ce3176a74d217551b5981f809a56c719424b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4151. Change the methods in FSDirectory to pass INodesInPath instead of INode[] as a parameter.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1406006 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/11/12 3:26 PM",
      "commitName": "7ee5ce3176a74d217551b5981f809a56c719424b",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "02/11/12 5:20 PM",
      "commitNameOld": "d174f574bafcfefc635c64a47f258b1ce5d5c84e",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 2.96,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,104 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException {\n     assert hasWriteLock();\n-    INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n+    INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n+    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n     INode dstChild \u003d null;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n-      srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n+      srcChild \u003d removeChild(srcInodesInPath, srcInodes.length-1);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n-      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n+      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length-1,\n           srcChild, UNKNOWN_DISK_SPACE);\n       if (dstChild !\u003d null) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n         return true;\n       }\n     } finally {\n       if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n-        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n+        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, srcChild, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException {\n    assert hasWriteLock();\n    INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    INode dstChild \u003d null;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeChild(srcInodesInPath, srcInodes.length-1);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length-1,\n          srcChild, UNKNOWN_DISK_SPACE);\n      if (dstChild !\u003d null) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, srcChild, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "d174f574bafcfefc635c64a47f258b1ce5d5c84e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4143. Change blocks to private in INodeFile and renames isLink() to isSymlink() in INode.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1405237 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/11/12 5:20 PM",
      "commitName": "d174f574bafcfefc635c64a47f258b1ce5d5c84e",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "29/10/12 7:11 AM",
      "commitNameOld": "1b3b09d94794622e8336220d897a1f10c4654677",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 4.42,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException {\n     assert hasWriteLock();\n     INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n-    if (srcInode.isLink() \u0026\u0026 \n+    if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     \n     INode dstChild \u003d null;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n       srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n       dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n           srcChild, UNKNOWN_DISK_SPACE);\n       if (dstChild !\u003d null) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n         return true;\n       }\n     } finally {\n       if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException {\n    assert hasWriteLock();\n    INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    INode dstChild \u003d null;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          srcChild, UNKNOWN_DISK_SPACE);\n      if (dstChild !\u003d null) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "1b3b09d94794622e8336220d897a1f10c4654677": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4124. Refactor INodeDirectory#getExistingPathINodes() to enable returningmore than INode array. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1403304 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/10/12 7:11 AM",
      "commitName": "1b3b09d94794622e8336220d897a1f10c4654677",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "28/10/12 4:10 PM",
      "commitNameOld": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.63,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,103 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException {\n     assert hasWriteLock();\n     INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isLink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n-    INode[] dstInodes \u003d new INode[dstComponents.length];\n-    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n+    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n+        dstComponents.length, false);\n+    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n-    verifyQuotaForRename(srcInodes,dstInodes);\n+    verifyQuotaForRename(srcInodes, dstInodes);\n     \n     INode dstChild \u003d null;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n       srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n       dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n           srcChild, UNKNOWN_DISK_SPACE);\n       if (dstChild !\u003d null) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n         return true;\n       }\n     } finally {\n       if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException {\n    assert hasWriteLock();\n    INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isLink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    \n    INode dstChild \u003d null;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          srcChild, UNKNOWN_DISK_SPACE);\n      if (dstChild !\u003d null) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "10dc6b09272dbf2022907681e134104e7d418021": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1869. mkdirs should use the supplied permission for all of the created directories.  Contributed by Daryn Sharp\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189546 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/11 5:02 PM",
      "commitName": "10dc6b09272dbf2022907681e134104e7d418021",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "22/09/11 1:25 AM",
      "commitNameOld": "d773bf0fb57bf6fb77dbdd52e1c186833c17361c",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 34.65,
      "commitsBetweenForRepo": 266,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp)\n     throws QuotaExceededException, UnresolvedLinkException, \n     FileAlreadyExistsException {\n     assert hasWriteLock();\n     INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n     INode srcInode \u003d srcInodes[srcInodes.length-1];\n     \n     // check the validation of the source\n     if (srcInode \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because source does not exist\");\n       return false;\n     } \n     if (srcInodes.length \u003d\u003d 1) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n       return false;\n     }\n     if (isDir(dst)) {\n       dst +\u003d Path.SEPARATOR + new Path(src).getName();\n     }\n     \n     // check the validity of the destination\n     if (dst.equals(src)) {\n       return true;\n     }\n     if (srcInode.isLink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     \n     // dst cannot be directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + \"failed to rename \" + src + \" to \" + dst\n           + \" because destination starts with src\");\n       return false;\n     }\n     \n     byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INode[] dstInodes \u003d new INode[dstComponents.length];\n     rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n     if (dstInodes[dstInodes.length-1] !\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                    +\"failed to rename \"+src+\" to \"+dst+ \n                                    \" because destination exists\");\n       return false;\n     }\n     if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           +\"failed to rename \"+src+\" to \"+dst+ \n           \" because destination\u0027s parent does not exist\");\n       return false;\n     }\n     \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes,dstInodes);\n     \n     INode dstChild \u003d null;\n     INode srcChild \u003d null;\n     String srcChildName \u003d null;\n     try {\n       // remove src\n       srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n       if (srcChild \u003d\u003d null) {\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + \"failed to rename \" + src + \" to \" + dst\n             + \" because the source can not be removed\");\n         return false;\n       }\n       srcChildName \u003d srcChild.getLocalName();\n       srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n       \n       // add src to the destination\n       dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n-          srcChild, UNKNOWN_DISK_SPACE, false);\n+          srcChild, UNKNOWN_DISK_SPACE);\n       if (dstChild !\u003d null) {\n         srcChild \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n               + src + \" is renamed to \" + dst);\n         }\n         // update modification time of dst and the parent of src\n         srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n         return true;\n       }\n     } finally {\n       if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n         // put it back\n         srcChild.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n-            UNKNOWN_DISK_SPACE, false);\n+            UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         +\"failed to rename \"+src+\" to \"+dst);\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException {\n    assert hasWriteLock();\n    INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isLink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INode[] dstInodes \u003d new INode[dstComponents.length];\n    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes,dstInodes);\n    \n    INode dstChild \u003d null;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          srcChild, UNKNOWN_DISK_SPACE);\n      if (dstChild !\u003d null) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException {\n    assert hasWriteLock();\n    INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isLink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INode[] dstInodes \u003d new INode[dstComponents.length];\n    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes,dstInodes);\n    \n    INode dstChild \u003d null;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          srcChild, UNKNOWN_DISK_SPACE, false);\n      if (dstChild !\u003d null) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n            UNKNOWN_DISK_SPACE, false);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException {\n    assert hasWriteLock();\n    INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isLink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INode[] dstInodes \u003d new INode[dstComponents.length];\n    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes,dstInodes);\n    \n    INode dstChild \u003d null;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          srcChild, UNKNOWN_DISK_SPACE, false);\n      if (dstChild !\u003d null) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n            UNKNOWN_DISK_SPACE, false);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,102 @@\n+  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n+    throws QuotaExceededException, UnresolvedLinkException, \n+    FileAlreadyExistsException {\n+    assert hasWriteLock();\n+    INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n+    INode srcInode \u003d srcInodes[srcInodes.length-1];\n+    \n+    // check the validation of the source\n+    if (srcInode \u003d\u003d null) {\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + \"failed to rename \" + src + \" to \" + dst\n+          + \" because source does not exist\");\n+      return false;\n+    } \n+    if (srcInodes.length \u003d\u003d 1) {\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n+      return false;\n+    }\n+    if (isDir(dst)) {\n+      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n+    }\n+    \n+    // check the validity of the destination\n+    if (dst.equals(src)) {\n+      return true;\n+    }\n+    if (srcInode.isLink() \u0026\u0026 \n+        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n+      throw new FileAlreadyExistsException(\n+          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n+    }\n+    \n+    // dst cannot be directory or a file under src\n+    if (dst.startsWith(src) \u0026\u0026 \n+        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + \"failed to rename \" + src + \" to \" + dst\n+          + \" because destination starts with src\");\n+      return false;\n+    }\n+    \n+    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n+    INode[] dstInodes \u003d new INode[dstComponents.length];\n+    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n+    if (dstInodes[dstInodes.length-1] !\u003d null) {\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+                                   +\"failed to rename \"+src+\" to \"+dst+ \n+                                   \" because destination exists\");\n+      return false;\n+    }\n+    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          +\"failed to rename \"+src+\" to \"+dst+ \n+          \" because destination\u0027s parent does not exist\");\n+      return false;\n+    }\n+    \n+    // Ensure dst has quota to accommodate rename\n+    verifyQuotaForRename(srcInodes,dstInodes);\n+    \n+    INode dstChild \u003d null;\n+    INode srcChild \u003d null;\n+    String srcChildName \u003d null;\n+    try {\n+      // remove src\n+      srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n+      if (srcChild \u003d\u003d null) {\n+        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+            + \"failed to rename \" + src + \" to \" + dst\n+            + \" because the source can not be removed\");\n+        return false;\n+      }\n+      srcChildName \u003d srcChild.getLocalName();\n+      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n+      \n+      // add src to the destination\n+      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n+          srcChild, UNKNOWN_DISK_SPACE, false);\n+      if (dstChild !\u003d null) {\n+        srcChild \u003d null;\n+        if (NameNode.stateChangeLog.isDebugEnabled()) {\n+          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n+              + src + \" is renamed to \" + dst);\n+        }\n+        // update modification time of dst and the parent of src\n+        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n+        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n+        return true;\n+      }\n+    } finally {\n+      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n+        // put it back\n+        srcChild.setLocalName(srcChildName);\n+        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n+            UNKNOWN_DISK_SPACE, false);\n+      }\n+    }\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+        +\"failed to rename \"+src+\" to \"+dst);\n+    return false;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp)\n    throws QuotaExceededException, UnresolvedLinkException, \n    FileAlreadyExistsException {\n    assert hasWriteLock();\n    INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    INode srcInode \u003d srcInodes[srcInodes.length-1];\n    \n    // check the validation of the source\n    if (srcInode \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because source does not exist\");\n      return false;\n    } \n    if (srcInodes.length \u003d\u003d 1) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \" because source is the root\");\n      return false;\n    }\n    if (isDir(dst)) {\n      dst +\u003d Path.SEPARATOR + new Path(src).getName();\n    }\n    \n    // check the validity of the destination\n    if (dst.equals(src)) {\n      return true;\n    }\n    if (srcInode.isLink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    \n    // dst cannot be directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + \"failed to rename \" + src + \" to \" + dst\n          + \" because destination starts with src\");\n      return false;\n    }\n    \n    byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INode[] dstInodes \u003d new INode[dstComponents.length];\n    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n    if (dstInodes[dstInodes.length-1] !\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n                                   +\"failed to rename \"+src+\" to \"+dst+ \n                                   \" because destination exists\");\n      return false;\n    }\n    if (dstInodes[dstInodes.length-2] \u003d\u003d null) {\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          +\"failed to rename \"+src+\" to \"+dst+ \n          \" because destination\u0027s parent does not exist\");\n      return false;\n    }\n    \n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes,dstInodes);\n    \n    INode dstChild \u003d null;\n    INode srcChild \u003d null;\n    String srcChildName \u003d null;\n    try {\n      // remove src\n      srcChild \u003d removeChild(srcInodes, srcInodes.length-1);\n      if (srcChild \u003d\u003d null) {\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + \"failed to rename \" + src + \" to \" + dst\n            + \" because the source can not be removed\");\n        return false;\n      }\n      srcChildName \u003d srcChild.getLocalName();\n      srcChild.setLocalName(dstComponents[dstInodes.length-1]);\n      \n      // add src to the destination\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          srcChild, UNKNOWN_DISK_SPACE, false);\n      if (dstChild !\u003d null) {\n        srcChild \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedRenameTo: \" \n              + src + \" is renamed to \" + dst);\n        }\n        // update modification time of dst and the parent of src\n        srcInodes[srcInodes.length-2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length-2].setModificationTime(timestamp);\n        return true;\n      }\n    } finally {\n      if (dstChild \u003d\u003d null \u0026\u0026 srcChild !\u003d null) {\n        // put it back\n        srcChild.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, srcChild, \n            UNKNOWN_DISK_SPACE, false);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        +\"failed to rename \"+src+\" to \"+dst);\n    return false;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java"
    }
  }
}