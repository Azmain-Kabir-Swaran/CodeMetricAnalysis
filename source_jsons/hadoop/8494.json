{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImage.java",
  "functionName": "recoverTransitionRead",
  "functionId": "recoverTransitionRead___startOpt-StartupOption__target-FSNamesystem__recovery-MetaRecoveryContext",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
  "functionStartLine": 223,
  "functionEndLine": 339,
  "numCommitsSeen": 159,
  "timeTaken": 9874,
  "changeHistory": [
    "07e3cf952eac9e47e7bd5e195b0f9fc28c468313",
    "4cfc8664362ed04b01872e854715a36dad9408a6",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846",
    "5f9e52f7459d3dc4ac3a5febd1dc6e00829d30ed",
    "280bdb9a16a898118421aee16db11f52eed9bdae",
    "b2f4e53e2bf1808762669628fb9cdbc13beb4790",
    "58d49cecd5be7474e0d83fd600fb1eb6f88389dc",
    "98983b2788508936ad489e61ff61cacfe73ab1b9",
    "1bab14bb49ec2b1a93f7d0763fb823b2ac715174",
    "00067895a01c66d53715b50bbcb3605efd6425f2",
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
    "d8bc523754181b4c1321bcfab886ebf228d9c98f",
    "06406d705677845e1e303550e3bb0e2d4ccdbf70",
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
    "706394d03992b394e9f907aff2155df493e4ea4e",
    "8d4842383ede2aceec11c33f6314aa50b0c5ae55",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
    "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "07e3cf952eac9e47e7bd5e195b0f9fc28c468313": "Ybodychange",
    "4cfc8664362ed04b01872e854715a36dad9408a6": "Ybodychange",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846": "Ybodychange",
    "5f9e52f7459d3dc4ac3a5febd1dc6e00829d30ed": "Ybodychange",
    "280bdb9a16a898118421aee16db11f52eed9bdae": "Ybodychange",
    "b2f4e53e2bf1808762669628fb9cdbc13beb4790": "Ybodychange",
    "58d49cecd5be7474e0d83fd600fb1eb6f88389dc": "Ybodychange",
    "98983b2788508936ad489e61ff61cacfe73ab1b9": "Ybodychange",
    "1bab14bb49ec2b1a93f7d0763fb823b2ac715174": "Ybodychange",
    "00067895a01c66d53715b50bbcb3605efd6425f2": "Ybodychange",
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de": "Ybodychange",
    "d8bc523754181b4c1321bcfab886ebf228d9c98f": "Ybodychange",
    "06406d705677845e1e303550e3bb0e2d4ccdbf70": "Ybodychange",
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8": "Ybodychange",
    "706394d03992b394e9f907aff2155df493e4ea4e": "Ymultichange(Yparameterchange,Ybodychange)",
    "8d4842383ede2aceec11c33f6314aa50b0c5ae55": "Ybodychange",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": "Ymultichange(Yparameterchange,Ybodychange)",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": "Ymultichange(Yparameterchange,Ybodychange)",
    "ffbe9e5972bf3eee9037e2602c1330e0dc744646": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "07e3cf952eac9e47e7bd5e195b0f9fc28c468313": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2470. NN should automatically set permissions on dfs.namenode.*.dir. Contributed by Siddharth Wagle.\n",
      "commitDate": "26/08/19 3:57 PM",
      "commitName": "07e3cf952eac9e47e7bd5e195b0f9fc28c468313",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "23/08/19 12:18 PM",
      "commitNameOld": "ebef99dcf41a7538d44db6c8d14d5376c7a065f8",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 3.15,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,117 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, storage, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n       System.out.println(\"HDFS Image Version: \" + layoutVersion);\n       System.out.println(\"Software format version: \" +\n         HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n       return false;\n     }\n \n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 startOpt !\u003d StartupOption.UPGRADEONLY\n         \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with the \\\"\"\n           + RollingUpgradeStartupOption.STARTED.getOptionString()\n           + \"\\\" option if a rolling upgrade is already started;\"\n           + \" or restart NameNode with the \\\"\"\n           + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n           + \" a new upgrade.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         // Create a dir structure, but not the VERSION file. The presence of\n         // VERSION is checked in the inspector\u0027s needToSave() method and\n         // saveNamespace is triggered if it is absent. This will bring\n         // the storage state uptodate along with a new VERSION file.\n         // If HA is enabled, NNs start up as standby so saveNamespace is not\n         // triggered.\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n-        sd.clearDirectory(); // create empty currrent dir\n+        sd.clearDirectory(); // create empty current dir\n         // For non-HA, no further action is needed here, as saveNamespace will\n         // take care of the rest.\n         if (!target.isHaEnabled()) {\n           continue;\n         }\n         // If HA is enabled, save the dirs to create a version file later when\n         // a checkpoint image is saved.\n         if (newDirs \u003d\u003d null) {\n           newDirs \u003d new HashSet\u003cStorageDirectory\u003e();\n         }\n         newDirs.add(sd);\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n     case UPGRADEONLY:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       throw new AssertionError(\"Rollback is now a standalone command, \" +\n           \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, storage, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n      System.out.println(\"HDFS Image Version: \" + layoutVersion);\n      System.out.println(\"Software format version: \" +\n        HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n      return false;\n    }\n\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 startOpt !\u003d StartupOption.UPGRADEONLY\n        \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with the \\\"\"\n          + RollingUpgradeStartupOption.STARTED.getOptionString()\n          + \"\\\" option if a rolling upgrade is already started;\"\n          + \" or restart NameNode with the \\\"\"\n          + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n          + \" a new upgrade.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        // Create a dir structure, but not the VERSION file. The presence of\n        // VERSION is checked in the inspector\u0027s needToSave() method and\n        // saveNamespace is triggered if it is absent. This will bring\n        // the storage state uptodate along with a new VERSION file.\n        // If HA is enabled, NNs start up as standby so saveNamespace is not\n        // triggered.\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty current dir\n        // For non-HA, no further action is needed here, as saveNamespace will\n        // take care of the rest.\n        if (!target.isHaEnabled()) {\n          continue;\n        }\n        // If HA is enabled, save the dirs to create a version file later when\n        // a checkpoint image is saved.\n        if (newDirs \u003d\u003d null) {\n          newDirs \u003d new HashSet\u003cStorageDirectory\u003e();\n        }\n        newDirs.add(sd);\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n    case UPGRADEONLY:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "4cfc8664362ed04b01872e854715a36dad9408a6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11714. Newly added NN storage directory won\u0027t get initialized and cause space exhaustion. Contributed by Kihwal Lee.\n",
      "commitDate": "01/05/17 3:29 PM",
      "commitName": "4cfc8664362ed04b01872e854715a36dad9408a6",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "17/01/17 2:33 PM",
      "commitNameOld": "b1fce2b8b14c4ce43f7098a269ac2b95304db0ce",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 104.0,
      "commitsBetweenForRepo": 578,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,117 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, storage, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n       System.out.println(\"HDFS Image Version: \" + layoutVersion);\n       System.out.println(\"Software format version: \" +\n         HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n       return false;\n     }\n \n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 startOpt !\u003d StartupOption.UPGRADEONLY\n         \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with the \\\"\"\n           + RollingUpgradeStartupOption.STARTED.getOptionString()\n           + \"\\\" option if a rolling upgrade is already started;\"\n           + \" or restart NameNode with the \\\"\"\n           + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n           + \" a new upgrade.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n+        // Create a dir structure, but not the VERSION file. The presence of\n+        // VERSION is checked in the inspector\u0027s needToSave() method and\n+        // saveNamespace is triggered if it is absent. This will bring\n+        // the storage state uptodate along with a new VERSION file.\n+        // If HA is enabled, NNs start up as standby so saveNamespace is not\n+        // triggered.\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n+        // For non-HA, no further action is needed here, as saveNamespace will\n+        // take care of the rest.\n+        if (!target.isHaEnabled()) {\n+          continue;\n+        }\n+        // If HA is enabled, save the dirs to create a version file later when\n+        // a checkpoint image is saved.\n+        if (newDirs \u003d\u003d null) {\n+          newDirs \u003d new HashSet\u003cStorageDirectory\u003e();\n+        }\n+        newDirs.add(sd);\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n     case UPGRADEONLY:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       throw new AssertionError(\"Rollback is now a standalone command, \" +\n           \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, storage, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n      System.out.println(\"HDFS Image Version: \" + layoutVersion);\n      System.out.println(\"Software format version: \" +\n        HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n      return false;\n    }\n\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 startOpt !\u003d StartupOption.UPGRADEONLY\n        \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with the \\\"\"\n          + RollingUpgradeStartupOption.STARTED.getOptionString()\n          + \"\\\" option if a rolling upgrade is already started;\"\n          + \" or restart NameNode with the \\\"\"\n          + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n          + \" a new upgrade.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        // Create a dir structure, but not the VERSION file. The presence of\n        // VERSION is checked in the inspector\u0027s needToSave() method and\n        // saveNamespace is triggered if it is absent. This will bring\n        // the storage state uptodate along with a new VERSION file.\n        // If HA is enabled, NNs start up as standby so saveNamespace is not\n        // triggered.\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        // For non-HA, no further action is needed here, as saveNamespace will\n        // take care of the rest.\n        if (!target.isHaEnabled()) {\n          continue;\n        }\n        // If HA is enabled, save the dirs to create a version file later when\n        // a checkpoint image is saved.\n        if (newDirs \u003d\u003d null) {\n          newDirs \u003d new HashSet\u003cStorageDirectory\u003e();\n        }\n        newDirs.add(sd);\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n    case UPGRADEONLY:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "14/04/15 3:05 PM",
      "commitNameOld": "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 17.79,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,100 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, storage, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n       System.out.println(\"HDFS Image Version: \" + layoutVersion);\n       System.out.println(\"Software format version: \" +\n-        HdfsConstants.NAMENODE_LAYOUT_VERSION);\n+        HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n       return false;\n     }\n \n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 startOpt !\u003d StartupOption.UPGRADEONLY\n         \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n-        \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n+        \u0026\u0026 layoutVersion !\u003d HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n-          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n+          + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with the \\\"\"\n           + RollingUpgradeStartupOption.STARTED.getOptionString()\n           + \"\\\" option if a rolling upgrade is already started;\"\n           + \" or restart NameNode with the \\\"\"\n           + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n           + \" a new upgrade.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n     case UPGRADEONLY:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       throw new AssertionError(\"Rollback is now a standalone command, \" +\n           \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, storage, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n      System.out.println(\"HDFS Image Version: \" + layoutVersion);\n      System.out.println(\"Software format version: \" +\n        HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n      return false;\n    }\n\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 startOpt !\u003d StartupOption.UPGRADEONLY\n        \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsServerConstants.NAMENODE_LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with the \\\"\"\n          + RollingUpgradeStartupOption.STARTED.getOptionString()\n          + \"\\\" option if a rolling upgrade is already started;\"\n          + \" or restart NameNode with the \\\"\"\n          + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n          + \" a new upgrade.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n    case UPGRADEONLY:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8127. NameNode Failover during HA upgrade can cause DataNode to finalize upgrade. Contributed by Jing Zhao.\n",
      "commitDate": "14/04/15 3:05 PM",
      "commitName": "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "09/04/15 10:42 PM",
      "commitNameOld": "987c9e12e184b35a5abab49f4188e22509ad63a5",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 4.68,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,100 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n-    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n+    boolean isFormatted \u003d recoverStorageDirs(startOpt, storage, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n       System.out.println(\"HDFS Image Version: \" + layoutVersion);\n       System.out.println(\"Software format version: \" +\n         HdfsConstants.NAMENODE_LAYOUT_VERSION);\n       return false;\n     }\n \n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 startOpt !\u003d StartupOption.UPGRADEONLY\n         \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with the \\\"\"\n           + RollingUpgradeStartupOption.STARTED.getOptionString()\n           + \"\\\" option if a rolling upgrade is already started;\"\n           + \" or restart NameNode with the \\\"\"\n           + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n           + \" a new upgrade.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n     case UPGRADEONLY:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       throw new AssertionError(\"Rollback is now a standalone command, \" +\n           \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, storage, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n      System.out.println(\"HDFS Image Version: \" + layoutVersion);\n      System.out.println(\"Software format version: \" +\n        HdfsConstants.NAMENODE_LAYOUT_VERSION);\n      return false;\n    }\n\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 startOpt !\u003d StartupOption.UPGRADEONLY\n        \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with the \\\"\"\n          + RollingUpgradeStartupOption.STARTED.getOptionString()\n          + \"\\\" option if a rolling upgrade is already started;\"\n          + \" or restart NameNode with the \\\"\"\n          + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n          + \" a new upgrade.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n    case UPGRADEONLY:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "5f9e52f7459d3dc4ac3a5febd1dc6e00829d30ed": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6597. Add a new option to NN upgrade to terminate the process after upgrade on NN is completed. Contributed by Danilo Vunjak.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611723 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/14 10:14 AM",
      "commitName": "5f9e52f7459d3dc4ac3a5febd1dc6e00829d30ed",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "28/06/14 8:21 AM",
      "commitNameOld": "94a1462bd55ad5c71d776d22b9150003fe9ae30d",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 20.08,
      "commitsBetweenForRepo": 133,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,100 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n       System.out.println(\"HDFS Image Version: \" + layoutVersion);\n       System.out.println(\"Software format version: \" +\n         HdfsConstants.NAMENODE_LAYOUT_VERSION);\n       return false;\n     }\n \n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n+        \u0026\u0026 startOpt !\u003d StartupOption.UPGRADEONLY\n         \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with the \\\"\"\n           + RollingUpgradeStartupOption.STARTED.getOptionString()\n           + \"\\\" option if a rolling upgrade is already started;\"\n           + \" or restart NameNode with the \\\"\"\n           + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n           + \" a new upgrade.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n+    case UPGRADEONLY:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       throw new AssertionError(\"Rollback is now a standalone command, \" +\n           \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n      System.out.println(\"HDFS Image Version: \" + layoutVersion);\n      System.out.println(\"Software format version: \" +\n        HdfsConstants.NAMENODE_LAYOUT_VERSION);\n      return false;\n    }\n\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 startOpt !\u003d StartupOption.UPGRADEONLY\n        \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with the \\\"\"\n          + RollingUpgradeStartupOption.STARTED.getOptionString()\n          + \"\\\" option if a rolling upgrade is already started;\"\n          + \" or restart NameNode with the \\\"\"\n          + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n          + \" a new upgrade.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n    case UPGRADEONLY:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "280bdb9a16a898118421aee16db11f52eed9bdae": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6572. Add an option to the NameNode that prints the software and on-disk image versions. Contributed by Charles Lamb.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605928 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/06/14 4:12 PM",
      "commitName": "280bdb9a16a898118421aee16db11f52eed9bdae",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "20/06/14 11:54 AM",
      "commitNameOld": "9ca79e8d327e95845ef9794396afd43a52bc3d40",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 6.18,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,98 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n+    if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n+      System.out.println(\"HDFS Image Version: \" + layoutVersion);\n+      System.out.println(\"Software format version: \" +\n+        HdfsConstants.NAMENODE_LAYOUT_VERSION);\n+      return false;\n+    }\n+\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with the \\\"\"\n           + RollingUpgradeStartupOption.STARTED.getOptionString()\n           + \"\\\" option if a rolling upgrade is already started;\"\n           + \" or restart NameNode with the \\\"\"\n           + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n           + \" a new upgrade.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       throw new AssertionError(\"Rollback is now a standalone command, \" +\n           \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (startOpt \u003d\u003d StartupOption.METADATAVERSION) {\n      System.out.println(\"HDFS Image Version: \" + layoutVersion);\n      System.out.println(\"Software format version: \" +\n        HdfsConstants.NAMENODE_LAYOUT_VERSION);\n      return false;\n    }\n\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with the \\\"\"\n          + RollingUpgradeStartupOption.STARTED.getOptionString()\n          + \"\\\" option if a rolling upgrade is already started;\"\n          + \" or restart NameNode with the \\\"\"\n          + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n          + \" a new upgrade.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "b2f4e53e2bf1808762669628fb9cdbc13beb4790": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6409. Fix typo in log message about NameNode layout version upgrade. Contributed by Chen He.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596739 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 9:38 PM",
      "commitName": "b2f4e53e2bf1808762669628fb9cdbc13beb4790",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "13/05/14 6:15 PM",
      "commitNameOld": "97f58955a6045b373ab73653bf26ab5922b00cf3",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 8.14,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,91 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with the \\\"\"\n           + RollingUpgradeStartupOption.STARTED.getOptionString()\n-          + \"\\\" option if a rolling upgraded is already started;\"\n+          + \"\\\" option if a rolling upgrade is already started;\"\n           + \" or restart NameNode with the \\\"\"\n           + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n           + \" a new upgrade.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       throw new AssertionError(\"Rollback is now a standalone command, \" +\n           \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with the \\\"\"\n          + RollingUpgradeStartupOption.STARTED.getOptionString()\n          + \"\\\" option if a rolling upgrade is already started;\"\n          + \" or restart NameNode with the \\\"\"\n          + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n          + \" a new upgrade.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "58d49cecd5be7474e0d83fd600fb1eb6f88389dc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6215. Wrong error message for upgrade. (Kihwal Lee via jeagles)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1586011 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/14 9:20 AM",
      "commitName": "58d49cecd5be7474e0d83fd600fb1eb6f88389dc",
      "commitAuthor": "Jonathan Turner Eagles",
      "commitDateOld": "24/03/14 11:48 PM",
      "commitNameOld": "56205ca7d7f3b2a7e55f48b9cf444326e1d2b1a7",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 15.4,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,91 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with the \\\"\"\n           + RollingUpgradeStartupOption.STARTED.getOptionString()\n           + \"\\\" option if a rolling upgraded is already started;\"\n           + \" or restart NameNode with the \\\"\"\n-          + StartupOption.UPGRADE + \"\\\" to start a new upgrade.\");\n+          + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n+          + \" a new upgrade.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       throw new AssertionError(\"Rollback is now a standalone command, \" +\n           \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with the \\\"\"\n          + RollingUpgradeStartupOption.STARTED.getOptionString()\n          + \"\\\" option if a rolling upgraded is already started;\"\n          + \" or restart NameNode with the \\\"\"\n          + StartupOption.UPGRADE.getName() + \"\\\" option to start\"\n          + \" a new upgrade.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "98983b2788508936ad489e61ff61cacfe73ab1b9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6042. Fix rolling upgrade documentation and error messages. (Contributed by szetszwo)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1573785 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/03/14 2:31 PM",
      "commitName": "98983b2788508936ad489e61ff61cacfe73ab1b9",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "28/02/14 11:33 AM",
      "commitNameOld": "1bab14bb49ec2b1a93f7d0763fb823b2ac715174",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.12,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,90 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n-        \u0026\u0026 !StartupOption.isRollingUpgradeStarted(startOpt)\n+        \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n-          + \"Please restart NameNode with -upgrade option.\");\n+          + \"Please restart NameNode with the \\\"\"\n+          + RollingUpgradeStartupOption.STARTED.getOptionString()\n+          + \"\\\" option if a rolling upgraded is already started;\"\n+          + \" or restart NameNode with the \\\"\"\n+          + StartupOption.UPGRADE + \"\\\" to start a new upgrade.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       throw new AssertionError(\"Rollback is now a standalone command, \" +\n           \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 !RollingUpgradeStartupOption.STARTED.matches(startOpt)\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with the \\\"\"\n          + RollingUpgradeStartupOption.STARTED.getOptionString()\n          + \"\\\" option if a rolling upgraded is already started;\"\n          + \" or restart NameNode with the \\\"\"\n          + StartupOption.UPGRADE + \"\\\" to start a new upgrade.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "1bab14bb49ec2b1a93f7d0763fb823b2ac715174": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6031. Add back the \"-rollingUpgrade started\" namenode startup option; otherwise, namenode cannot start when the layout version is changed.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1573040 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/02/14 11:33 AM",
      "commitName": "1bab14bb49ec2b1a93f7d0763fb823b2ac715174",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "27/02/14 5:23 PM",
      "commitNameOld": "5409908026dd791cce62a7d71ae56c92a70a9753",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,86 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n+        \u0026\u0026 !StartupOption.isRollingUpgradeStarted(startOpt)\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       throw new AssertionError(\"Rollback is now a standalone command, \" +\n           \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 !StartupOption.isRollingUpgradeStarted(startOpt)\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "00067895a01c66d53715b50bbcb3605efd6425f2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5754. Split LayoutVerion into NameNodeLayoutVersion and DataNodeLayoutVersion. Contributed by Brandon Li\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1563041 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/01/14 7:21 PM",
      "commitName": "00067895a01c66d53715b50bbcb3605efd6425f2",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "26/01/14 8:34 AM",
      "commitNameOld": "a9110e178837bdcd236e528875daa3651e13dacc",
      "commitAuthorOld": "",
      "daysBetweenCommits": 4.45,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,85 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n-        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n+        \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n-          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n+          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       throw new AssertionError(\"Rollback is now a standalone command, \" +\n           \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.NAMENODE_LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.NAMENODE_LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5138. Support HDFS upgrade in HA. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561381 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/14 12:01 PM",
      "commitName": "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "07/01/14 12:52 PM",
      "commitNameOld": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 17.96,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,85 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n-      MetaRecoveryContext recovery) throws IOException {\n+      MetaRecoveryContext recovery)\n+      throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n-      doRollback();\n-      break;\n+      throw new AssertionError(\"Rollback is now a standalone command, \" +\n+          \"NameNode should not be starting with this option.\");\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n-    return loadFSImage(target, recovery);\n+    return loadFSImage(target, recovery, startOpt);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      throw new AssertionError(\"Rollback is now a standalone command, \" +\n          \"NameNode should not be starting with this option.\");\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, recovery, startOpt);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "d8bc523754181b4c1321bcfab886ebf228d9c98f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5753. Add new NN startup options for downgrade and rollback using upgrade marker.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1559907 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/01/14 6:38 PM",
      "commitName": "d8bc523754181b4c1321bcfab886ebf228d9c98f",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "07/01/14 12:52 PM",
      "commitNameOld": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 13.24,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery) throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n     default:\n       // just load the image\n     }\n     \n-    return loadFSImage(target, recovery);\n+    return loadFSImage(target, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery) throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "06406d705677845e1e303550e3bb0e2d4ccdbf70": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1245. Plugable block id generation. Contributed by Konstantin Shvachko.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1432539 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/01/13 5:13 PM",
      "commitName": "06406d705677845e1e303550e3bb0e2d4ccdbf70",
      "commitAuthor": "Konstantin Shvachko",
      "commitDateOld": "19/11/12 6:00 PM",
      "commitNameOld": "573c41c2666e084f3988a288bb40d2305fc23d8f",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 53.97,
      "commitsBetweenForRepo": 205,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,84 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery) throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n+    default:\n       // just load the image\n     }\n     \n     return loadFSImage(target, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery) throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n    default:\n      // just load the image\n    }\n    \n    return loadFSImage(target, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2686. Remove DistributedUpgrade related code. Contributed by Suresh Srinivas\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1375800 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/08/12 2:18 PM",
      "commitName": "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "09/08/12 3:13 PM",
      "commitNameOld": "9d0f8792a9a1d3d2b24adfc2c213247a099e7ad1",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 11.96,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,83 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n       MetaRecoveryContext recovery) throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n-    storage.setUpgradeManager(target.upgradeManager);\n-    \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n-    // check whether distributed upgrade is required and/or should be continued\n-    storage.verifyDistributedUpgradeProgress(startOpt);\n-\n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n       // just load the image\n     }\n     \n     return loadFSImage(target, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery) throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    return loadFSImage(target, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "706394d03992b394e9f907aff2155df493e4ea4e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-3004. Implement Recovery Mode. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1311394 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/12 12:39 PM",
      "commitName": "706394d03992b394e9f907aff2155df493e4ea4e",
      "commitAuthor": "Eli Collins",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-3004. Implement Recovery Mode. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1311394 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/04/12 12:39 PM",
          "commitName": "706394d03992b394e9f907aff2155df493e4ea4e",
          "commitAuthor": "Eli Collins",
          "commitDateOld": "12/03/12 12:41 PM",
          "commitNameOld": "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 28.0,
          "commitsBetweenForRepo": 204,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,88 +1,88 @@\n-  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target)\n-      throws IOException {\n+  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n+      MetaRecoveryContext recovery) throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     storage.setUpgradeManager(target.upgradeManager);\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // check whether distributed upgrade is required and/or should be continued\n     storage.verifyDistributedUpgradeProgress(startOpt);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n       // just load the image\n     }\n     \n-    return loadFSImage(target);\n+    return loadFSImage(target, recovery);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery) throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    storage.setUpgradeManager(target.upgradeManager);\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    return loadFSImage(target, recovery);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[startOpt-StartupOption, target-FSNamesystem]",
            "newValue": "[startOpt-StartupOption, target-FSNamesystem, recovery-MetaRecoveryContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3004. Implement Recovery Mode. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1311394 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/04/12 12:39 PM",
          "commitName": "706394d03992b394e9f907aff2155df493e4ea4e",
          "commitAuthor": "Eli Collins",
          "commitDateOld": "12/03/12 12:41 PM",
          "commitNameOld": "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 28.0,
          "commitsBetweenForRepo": 204,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,88 +1,88 @@\n-  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target)\n-      throws IOException {\n+  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n+      MetaRecoveryContext recovery) throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     storage.setUpgradeManager(target.upgradeManager);\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // check whether distributed upgrade is required and/or should be continued\n     storage.verifyDistributedUpgradeProgress(startOpt);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n       // just load the image\n     }\n     \n-    return loadFSImage(target);\n+    return loadFSImage(target, recovery);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target,\n      MetaRecoveryContext recovery) throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    storage.setUpgradeManager(target.upgradeManager);\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    return loadFSImage(target, recovery);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "8d4842383ede2aceec11c33f6314aa50b0c5ae55": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2188. Make FSEditLog create its journals from a list of URIs rather than NNStorage. Contributed by Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1185354 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/10/11 1:23 PM",
      "commitName": "8d4842383ede2aceec11c33f6314aa50b0c5ae55",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "07/09/11 4:23 PM",
      "commitNameOld": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 39.88,
      "commitsBetweenForRepo": 289,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,88 @@\n   boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n-    Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n-\n+    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     storage.setUpgradeManager(target.upgradeManager);\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // check whether distributed upgrade is required and/or should be continued\n     storage.verifyDistributedUpgradeProgress(startOpt);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n       // just load the image\n     }\n     \n     return loadFSImage(target);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d editLog.getEditURIs();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    storage.setUpgradeManager(target.upgradeManager);\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    return loadFSImage(target);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/09/11 4:23 PM",
      "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/09/11 4:23 PM",
          "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "06/09/11 1:27 PM",
          "commitNameOld": "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15",
          "commitAuthorOld": "Jitendra Nath Pandey",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,89 @@\n-  boolean recoverTransitionRead(StartupOption startOpt)\n+  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n \n+\n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n-    if(startOpt \u003d\u003d StartupOption.IMPORT \n-        \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n-      throw new IOException(\"Cannot import image from a checkpoint. \"\n-                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n-\n-    if(startOpt \u003d\u003d StartupOption.IMPORT \n-        \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n-      throw new IOException(\"Cannot import image from a checkpoint. \"\n-                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n+    storage.setUpgradeManager(target.upgradeManager);\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // check whether distributed upgrade is required and/or should be continued\n     storage.verifyDistributedUpgradeProgress(startOpt);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n-      doUpgrade();\n+      doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n-      doImportCheckpoint();\n+      doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n       // just load the image\n     }\n     \n-    return loadFSImage();\n+    return loadFSImage(target);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    storage.setUpgradeManager(target.upgradeManager);\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    return loadFSImage(target);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[startOpt-StartupOption]",
            "newValue": "[startOpt-StartupOption, target-FSNamesystem]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/09/11 4:23 PM",
          "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "06/09/11 1:27 PM",
          "commitNameOld": "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15",
          "commitAuthorOld": "Jitendra Nath Pandey",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,89 @@\n-  boolean recoverTransitionRead(StartupOption startOpt)\n+  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n \n+\n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n-    if(startOpt \u003d\u003d StartupOption.IMPORT \n-        \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n-      throw new IOException(\"Cannot import image from a checkpoint. \"\n-                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n-\n-    if(startOpt \u003d\u003d StartupOption.IMPORT \n-        \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n-      throw new IOException(\"Cannot import image from a checkpoint. \"\n-                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n+    storage.setUpgradeManager(target.upgradeManager);\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // check whether distributed upgrade is required and/or should be continued\n     storage.verifyDistributedUpgradeProgress(startOpt);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n-      doUpgrade();\n+      doUpgrade(target);\n       return false; // upgrade saved image already\n     case IMPORT:\n-      doImportCheckpoint();\n+      doImportCheckpoint(target);\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n       // just load the image\n     }\n     \n-    return loadFSImage();\n+    return loadFSImage(target);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt, FSNamesystem target)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    storage.setUpgradeManager(target.upgradeManager);\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade(target);\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint(target);\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    return loadFSImage(target);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1620. Rename HdfsConstants -\u003e HdfsServerConstants, FSConstants -\u003e HdfsConstants. (Harsh J Chouraria via atm)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165096 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/11 12:30 PM",
      "commitName": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 10.8,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,96 @@\n   boolean recoverTransitionRead(StartupOption startOpt)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n     Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n \n     // none of the data dirs exist\n     if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     if(startOpt \u003d\u003d StartupOption.IMPORT \n         \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n       throw new IOException(\"Cannot import image from a checkpoint. \"\n                             + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n \n     if(startOpt \u003d\u003d StartupOption.IMPORT \n         \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n       throw new IOException(\"Cannot import image from a checkpoint. \"\n                             + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n     \n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Data dir states:\\n  \" +\n         Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n         .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n       throw new IOException(\"NameNode is not formatted.\");      \n     }\n \n \n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n-        \u0026\u0026 layoutVersion !\u003d FSConstants.LAYOUT_VERSION) {\n+        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n-          + FSConstants.LAYOUT_VERSION + \" is required.\\n\"\n+          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // check whether distributed upgrade is required and/or should be continued\n     storage.verifyDistributedUpgradeProgress(startOpt);\n \n     // 2. Format unformatted dirs.\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade();\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint();\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n       // just load the image\n     }\n     \n     return loadFSImage();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n\n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d HdfsConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + HdfsConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade();\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint();\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    return loadFSImage();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n\n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d FSConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + FSConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade();\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint();\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    return loadFSImage();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n\n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d FSConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + FSConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade();\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint();\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    return loadFSImage();\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
      }
    },
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/11 9:28 AM",
      "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/07/11 9:28 AM",
          "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "27/07/11 8:19 PM",
          "commitNameOld": "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 1.55,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,128 +1,96 @@\n-  boolean recoverTransitionRead(Collection\u003cURI\u003e dataDirs,\n-                                Collection\u003cURI\u003e editsDirs,\n-                                StartupOption startOpt)\n+  boolean recoverTransitionRead(StartupOption startOpt)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n+    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n+    Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n+\n     // none of the data dirs exist\n-    if((dataDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n+    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     if(startOpt \u003d\u003d StartupOption.IMPORT \n         \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n       throw new IOException(\"Cannot import image from a checkpoint. \"\n                             + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n \n     if(startOpt \u003d\u003d StartupOption.IMPORT \n         \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n       throw new IOException(\"Cannot import image from a checkpoint. \"\n                             + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n     \n-    storage.setStorageDirectories(dataDirs, editsDirs);\n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n-    boolean isFormatted \u003d false;\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      StorageState curState;\n-      try {\n-        curState \u003d sd.analyzeStorage(startOpt, storage);\n-        // sd is locked but not opened\n-        switch(curState) {\n-        case NON_EXISTENT:\n-          // name-node fails if any of the configured storage dirs are missing\n-          throw new InconsistentFSStateException(sd.getRoot(),\n-                      \"storage directory does not exist or is not accessible.\");\n-        case NOT_FORMATTED:\n-          break;\n-        case NORMAL:\n-          break;\n-        default:  // recovery is possible\n-          sd.doRecover(curState);      \n-        }\n-        if (curState !\u003d StorageState.NOT_FORMATTED \n-            \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK) {\n-          // read and verify consistency with other directories\n-          storage.readProperties(sd);\n-          isFormatted \u003d true;\n-        }\n-        if (startOpt \u003d\u003d StartupOption.IMPORT \u0026\u0026 isFormatted)\n-          // import of a checkpoint is allowed only into empty image directories\n-          throw new IOException(\"Cannot import image from a checkpoint. \" \n-              + \" NameNode already contains an image in \"+ sd.getRoot());\n-      } catch (IOException ioe) {\n-        sd.unlock();\n-        throw ioe;\n-      }\n-      dataDirStates.put(sd,curState);\n+    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n+\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"Data dir states:\\n  \" +\n+        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n+        .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n-                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)\n-      throw new IOException(\"NameNode is not formatted.\");\n+                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n+      throw new IOException(\"NameNode is not formatted.\");      \n+    }\n+\n+\n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d FSConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + FSConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // check whether distributed upgrade is required and/or should be continued\n     storage.verifyDistributedUpgradeProgress(startOpt);\n \n     // 2. Format unformatted dirs.\n-    storage.setCheckpointTime(0L);\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade();\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint();\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n       // just load the image\n     }\n     \n-    boolean needToSave \u003d loadFSImage();\n-\n-    assert editLog !\u003d null : \"editLog must be initialized\";\n-    if(!editLog.isOpen())\n-      editLog.open();\n-    \n-    return needToSave;\n+    return loadFSImage();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n\n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d FSConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + FSConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade();\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint();\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    return loadFSImage();\n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[dataDirs-Collection\u003cURI\u003e, editsDirs-Collection\u003cURI\u003e, startOpt-StartupOption]",
            "newValue": "[startOpt-StartupOption]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/07/11 9:28 AM",
          "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "27/07/11 8:19 PM",
          "commitNameOld": "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 1.55,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,128 +1,96 @@\n-  boolean recoverTransitionRead(Collection\u003cURI\u003e dataDirs,\n-                                Collection\u003cURI\u003e editsDirs,\n-                                StartupOption startOpt)\n+  boolean recoverTransitionRead(StartupOption startOpt)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n+    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n+    Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n+\n     // none of the data dirs exist\n-    if((dataDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n+    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     if(startOpt \u003d\u003d StartupOption.IMPORT \n         \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n       throw new IOException(\"Cannot import image from a checkpoint. \"\n                             + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n \n     if(startOpt \u003d\u003d StartupOption.IMPORT \n         \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n       throw new IOException(\"Cannot import image from a checkpoint. \"\n                             + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n     \n-    storage.setStorageDirectories(dataDirs, editsDirs);\n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n-    boolean isFormatted \u003d false;\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      StorageState curState;\n-      try {\n-        curState \u003d sd.analyzeStorage(startOpt, storage);\n-        // sd is locked but not opened\n-        switch(curState) {\n-        case NON_EXISTENT:\n-          // name-node fails if any of the configured storage dirs are missing\n-          throw new InconsistentFSStateException(sd.getRoot(),\n-                      \"storage directory does not exist or is not accessible.\");\n-        case NOT_FORMATTED:\n-          break;\n-        case NORMAL:\n-          break;\n-        default:  // recovery is possible\n-          sd.doRecover(curState);      \n-        }\n-        if (curState !\u003d StorageState.NOT_FORMATTED \n-            \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK) {\n-          // read and verify consistency with other directories\n-          storage.readProperties(sd);\n-          isFormatted \u003d true;\n-        }\n-        if (startOpt \u003d\u003d StartupOption.IMPORT \u0026\u0026 isFormatted)\n-          // import of a checkpoint is allowed only into empty image directories\n-          throw new IOException(\"Cannot import image from a checkpoint. \" \n-              + \" NameNode already contains an image in \"+ sd.getRoot());\n-      } catch (IOException ioe) {\n-        sd.unlock();\n-        throw ioe;\n-      }\n-      dataDirStates.put(sd,curState);\n+    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n+\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"Data dir states:\\n  \" +\n+        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n+        .join(dataDirStates));\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n-                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)\n-      throw new IOException(\"NameNode is not formatted.\");\n+                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n+      throw new IOException(\"NameNode is not formatted.\");      \n+    }\n+\n+\n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d FSConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + FSConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // check whether distributed upgrade is required and/or should be continued\n     storage.verifyDistributedUpgradeProgress(startOpt);\n \n     // 2. Format unformatted dirs.\n-    storage.setCheckpointTime(0L);\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade();\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint();\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n       // just load the image\n     }\n     \n-    boolean needToSave \u003d loadFSImage();\n-\n-    assert editLog !\u003d null : \"editLog must be initialized\";\n-    if(!editLog.isOpen())\n-      editLog.open();\n-    \n-    return needToSave;\n+    return loadFSImage();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean recoverTransitionRead(StartupOption startOpt)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    Collection\u003cURI\u003e imageDirs \u003d storage.getImageDirectories();\n    Collection\u003cURI\u003e editsDirs \u003d storage.getEditsDirectories();\n\n    // none of the data dirs exist\n    if((imageDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n\n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n    \n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d recoverStorageDirs(startOpt, dataDirStates);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Data dir states:\\n  \" +\n        Joiner.on(\"\\n  \").withKeyValueSeparator(\": \")\n        .join(dataDirStates));\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT) {\n      throw new IOException(\"NameNode is not formatted.\");      \n    }\n\n\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d FSConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + FSConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade();\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint();\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    return loadFSImage();\n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "ffbe9e5972bf3eee9037e2602c1330e0dc744646": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2195. Refactor StorageDirectory to not be an non-static inner class. Contributed by Todd Lipcon\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1151707 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/07/11 8:19 PM",
      "commitName": "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "27/07/11 4:28 PM",
      "commitNameOld": "6f1ef980ded061dd75d3368b0fc2fbbed14eea9f",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,128 @@\n   boolean recoverTransitionRead(Collection\u003cURI\u003e dataDirs,\n                                 Collection\u003cURI\u003e editsDirs,\n                                 StartupOption startOpt)\n       throws IOException {\n     assert startOpt !\u003d StartupOption.FORMAT : \n       \"NameNode formatting should be performed before reading the image\";\n     \n     // none of the data dirs exist\n     if((dataDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                              \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n       throw new IOException(\n           \"All specified directories are not accessible or do not exist.\");\n     \n     if(startOpt \u003d\u003d StartupOption.IMPORT \n         \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n       throw new IOException(\"Cannot import image from a checkpoint. \"\n                             + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n \n     if(startOpt \u003d\u003d StartupOption.IMPORT \n         \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n       throw new IOException(\"Cannot import image from a checkpoint. \"\n                             + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n     \n     storage.setStorageDirectories(dataDirs, editsDirs);\n     // 1. For each data directory calculate its state and \n     // check whether all is consistent before transitioning.\n     Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n              new HashMap\u003cStorageDirectory, StorageState\u003e();\n     boolean isFormatted \u003d false;\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState;\n       try {\n-        curState \u003d sd.analyzeStorage(startOpt);\n+        curState \u003d sd.analyzeStorage(startOpt, storage);\n         // sd is locked but not opened\n         switch(curState) {\n         case NON_EXISTENT:\n           // name-node fails if any of the configured storage dirs are missing\n           throw new InconsistentFSStateException(sd.getRoot(),\n                       \"storage directory does not exist or is not accessible.\");\n         case NOT_FORMATTED:\n           break;\n         case NORMAL:\n           break;\n         default:  // recovery is possible\n           sd.doRecover(curState);      \n         }\n         if (curState !\u003d StorageState.NOT_FORMATTED \n             \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK) {\n-          sd.read(); // read and verify consistency with other directories\n+          // read and verify consistency with other directories\n+          storage.readProperties(sd);\n           isFormatted \u003d true;\n         }\n         if (startOpt \u003d\u003d StartupOption.IMPORT \u0026\u0026 isFormatted)\n           // import of a checkpoint is allowed only into empty image directories\n           throw new IOException(\"Cannot import image from a checkpoint. \" \n               + \" NameNode already contains an image in \"+ sd.getRoot());\n       } catch (IOException ioe) {\n         sd.unlock();\n         throw ioe;\n       }\n       dataDirStates.put(sd,curState);\n     }\n     \n     if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                      \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)\n       throw new IOException(\"NameNode is not formatted.\");\n     int layoutVersion \u003d storage.getLayoutVersion();\n     if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n       NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n     }\n     if (startOpt !\u003d StartupOption.UPGRADE\n         \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n         \u0026\u0026 layoutVersion !\u003d FSConstants.LAYOUT_VERSION) {\n       throw new IOException(\n           \"\\nFile system image contains an old layout version \" \n           + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n           + FSConstants.LAYOUT_VERSION + \" is required.\\n\"\n           + \"Please restart NameNode with -upgrade option.\");\n     }\n     \n     storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n \n     // check whether distributed upgrade is required and/or should be continued\n     storage.verifyDistributedUpgradeProgress(startOpt);\n \n     // 2. Format unformatted dirs.\n     storage.setCheckpointTime(0L);\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       StorageState curState \u003d dataDirStates.get(sd);\n       switch(curState) {\n       case NON_EXISTENT:\n         throw new IOException(StorageState.NON_EXISTENT + \n                               \" state cannot be here\");\n       case NOT_FORMATTED:\n         LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n         LOG.info(\"Formatting ...\");\n         sd.clearDirectory(); // create empty currrent dir\n         break;\n       default:\n         break;\n       }\n     }\n \n     // 3. Do transitions\n     switch(startOpt) {\n     case UPGRADE:\n       doUpgrade();\n       return false; // upgrade saved image already\n     case IMPORT:\n       doImportCheckpoint();\n       return false; // import checkpoint saved image already\n     case ROLLBACK:\n       doRollback();\n       break;\n     case REGULAR:\n       // just load the image\n     }\n     \n     boolean needToSave \u003d loadFSImage();\n \n     assert editLog !\u003d null : \"editLog must be initialized\";\n     if(!editLog.isOpen())\n       editLog.open();\n     \n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(Collection\u003cURI\u003e dataDirs,\n                                Collection\u003cURI\u003e editsDirs,\n                                StartupOption startOpt)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    // none of the data dirs exist\n    if((dataDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n\n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n    \n    storage.setStorageDirectories(dataDirs, editsDirs);\n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d false;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState;\n      try {\n        curState \u003d sd.analyzeStorage(startOpt, storage);\n        // sd is locked but not opened\n        switch(curState) {\n        case NON_EXISTENT:\n          // name-node fails if any of the configured storage dirs are missing\n          throw new InconsistentFSStateException(sd.getRoot(),\n                      \"storage directory does not exist or is not accessible.\");\n        case NOT_FORMATTED:\n          break;\n        case NORMAL:\n          break;\n        default:  // recovery is possible\n          sd.doRecover(curState);      \n        }\n        if (curState !\u003d StorageState.NOT_FORMATTED \n            \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK) {\n          // read and verify consistency with other directories\n          storage.readProperties(sd);\n          isFormatted \u003d true;\n        }\n        if (startOpt \u003d\u003d StartupOption.IMPORT \u0026\u0026 isFormatted)\n          // import of a checkpoint is allowed only into empty image directories\n          throw new IOException(\"Cannot import image from a checkpoint. \" \n              + \" NameNode already contains an image in \"+ sd.getRoot());\n      } catch (IOException ioe) {\n        sd.unlock();\n        throw ioe;\n      }\n      dataDirStates.put(sd,curState);\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)\n      throw new IOException(\"NameNode is not formatted.\");\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d FSConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + FSConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    storage.setCheckpointTime(0L);\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade();\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint();\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    boolean needToSave \u003d loadFSImage();\n\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    if(!editLog.isOpen())\n      editLog.open();\n    \n    return needToSave;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,127 @@\n+  boolean recoverTransitionRead(Collection\u003cURI\u003e dataDirs,\n+                                Collection\u003cURI\u003e editsDirs,\n+                                StartupOption startOpt)\n+      throws IOException {\n+    assert startOpt !\u003d StartupOption.FORMAT : \n+      \"NameNode formatting should be performed before reading the image\";\n+    \n+    // none of the data dirs exist\n+    if((dataDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n+                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n+      throw new IOException(\n+          \"All specified directories are not accessible or do not exist.\");\n+    \n+    if(startOpt \u003d\u003d StartupOption.IMPORT \n+        \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n+      throw new IOException(\"Cannot import image from a checkpoint. \"\n+                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n+\n+    if(startOpt \u003d\u003d StartupOption.IMPORT \n+        \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n+      throw new IOException(\"Cannot import image from a checkpoint. \"\n+                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n+    \n+    storage.setStorageDirectories(dataDirs, editsDirs);\n+    // 1. For each data directory calculate its state and \n+    // check whether all is consistent before transitioning.\n+    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n+             new HashMap\u003cStorageDirectory, StorageState\u003e();\n+    boolean isFormatted \u003d false;\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      StorageDirectory sd \u003d it.next();\n+      StorageState curState;\n+      try {\n+        curState \u003d sd.analyzeStorage(startOpt);\n+        // sd is locked but not opened\n+        switch(curState) {\n+        case NON_EXISTENT:\n+          // name-node fails if any of the configured storage dirs are missing\n+          throw new InconsistentFSStateException(sd.getRoot(),\n+                      \"storage directory does not exist or is not accessible.\");\n+        case NOT_FORMATTED:\n+          break;\n+        case NORMAL:\n+          break;\n+        default:  // recovery is possible\n+          sd.doRecover(curState);      \n+        }\n+        if (curState !\u003d StorageState.NOT_FORMATTED \n+            \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK) {\n+          sd.read(); // read and verify consistency with other directories\n+          isFormatted \u003d true;\n+        }\n+        if (startOpt \u003d\u003d StartupOption.IMPORT \u0026\u0026 isFormatted)\n+          // import of a checkpoint is allowed only into empty image directories\n+          throw new IOException(\"Cannot import image from a checkpoint. \" \n+              + \" NameNode already contains an image in \"+ sd.getRoot());\n+      } catch (IOException ioe) {\n+        sd.unlock();\n+        throw ioe;\n+      }\n+      dataDirStates.put(sd,curState);\n+    }\n+    \n+    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n+                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)\n+      throw new IOException(\"NameNode is not formatted.\");\n+    int layoutVersion \u003d storage.getLayoutVersion();\n+    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n+      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n+    }\n+    if (startOpt !\u003d StartupOption.UPGRADE\n+        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n+        \u0026\u0026 layoutVersion !\u003d FSConstants.LAYOUT_VERSION) {\n+      throw new IOException(\n+          \"\\nFile system image contains an old layout version \" \n+          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n+          + FSConstants.LAYOUT_VERSION + \" is required.\\n\"\n+          + \"Please restart NameNode with -upgrade option.\");\n+    }\n+    \n+    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n+\n+    // check whether distributed upgrade is required and/or should be continued\n+    storage.verifyDistributedUpgradeProgress(startOpt);\n+\n+    // 2. Format unformatted dirs.\n+    storage.setCheckpointTime(0L);\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      StorageDirectory sd \u003d it.next();\n+      StorageState curState \u003d dataDirStates.get(sd);\n+      switch(curState) {\n+      case NON_EXISTENT:\n+        throw new IOException(StorageState.NON_EXISTENT + \n+                              \" state cannot be here\");\n+      case NOT_FORMATTED:\n+        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n+        LOG.info(\"Formatting ...\");\n+        sd.clearDirectory(); // create empty currrent dir\n+        break;\n+      default:\n+        break;\n+      }\n+    }\n+\n+    // 3. Do transitions\n+    switch(startOpt) {\n+    case UPGRADE:\n+      doUpgrade();\n+      return false; // upgrade saved image already\n+    case IMPORT:\n+      doImportCheckpoint();\n+      return false; // import checkpoint saved image already\n+    case ROLLBACK:\n+      doRollback();\n+      break;\n+    case REGULAR:\n+      // just load the image\n+    }\n+    \n+    boolean needToSave \u003d loadFSImage();\n+\n+    assert editLog !\u003d null : \"editLog must be initialized\";\n+    if(!editLog.isOpen())\n+      editLog.open();\n+    \n+    return needToSave;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  boolean recoverTransitionRead(Collection\u003cURI\u003e dataDirs,\n                                Collection\u003cURI\u003e editsDirs,\n                                StartupOption startOpt)\n      throws IOException {\n    assert startOpt !\u003d StartupOption.FORMAT : \n      \"NameNode formatting should be performed before reading the image\";\n    \n    // none of the data dirs exist\n    if((dataDirs.size() \u003d\u003d 0 || editsDirs.size() \u003d\u003d 0) \n                             \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)  \n      throw new IOException(\n          \"All specified directories are not accessible or do not exist.\");\n    \n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointDirs \u003d\u003d null || checkpointDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n\n    if(startOpt \u003d\u003d StartupOption.IMPORT \n        \u0026\u0026 (checkpointEditsDirs \u003d\u003d null || checkpointEditsDirs.isEmpty()))\n      throw new IOException(\"Cannot import image from a checkpoint. \"\n                            + \"\\\"dfs.namenode.checkpoint.dir\\\" is not set.\" );\n    \n    storage.setStorageDirectories(dataDirs, editsDirs);\n    // 1. For each data directory calculate its state and \n    // check whether all is consistent before transitioning.\n    Map\u003cStorageDirectory, StorageState\u003e dataDirStates \u003d \n             new HashMap\u003cStorageDirectory, StorageState\u003e();\n    boolean isFormatted \u003d false;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState;\n      try {\n        curState \u003d sd.analyzeStorage(startOpt);\n        // sd is locked but not opened\n        switch(curState) {\n        case NON_EXISTENT:\n          // name-node fails if any of the configured storage dirs are missing\n          throw new InconsistentFSStateException(sd.getRoot(),\n                      \"storage directory does not exist or is not accessible.\");\n        case NOT_FORMATTED:\n          break;\n        case NORMAL:\n          break;\n        default:  // recovery is possible\n          sd.doRecover(curState);      \n        }\n        if (curState !\u003d StorageState.NOT_FORMATTED \n            \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK) {\n          sd.read(); // read and verify consistency with other directories\n          isFormatted \u003d true;\n        }\n        if (startOpt \u003d\u003d StartupOption.IMPORT \u0026\u0026 isFormatted)\n          // import of a checkpoint is allowed only into empty image directories\n          throw new IOException(\"Cannot import image from a checkpoint. \" \n              + \" NameNode already contains an image in \"+ sd.getRoot());\n      } catch (IOException ioe) {\n        sd.unlock();\n        throw ioe;\n      }\n      dataDirStates.put(sd,curState);\n    }\n    \n    if (!isFormatted \u0026\u0026 startOpt !\u003d StartupOption.ROLLBACK \n                     \u0026\u0026 startOpt !\u003d StartupOption.IMPORT)\n      throw new IOException(\"NameNode is not formatted.\");\n    int layoutVersion \u003d storage.getLayoutVersion();\n    if (layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION) {\n      NNStorage.checkVersionUpgradable(storage.getLayoutVersion());\n    }\n    if (startOpt !\u003d StartupOption.UPGRADE\n        \u0026\u0026 layoutVersion \u003c Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION\n        \u0026\u0026 layoutVersion !\u003d FSConstants.LAYOUT_VERSION) {\n      throw new IOException(\n          \"\\nFile system image contains an old layout version \" \n          + storage.getLayoutVersion() + \".\\nAn upgrade to version \"\n          + FSConstants.LAYOUT_VERSION + \" is required.\\n\"\n          + \"Please restart NameNode with -upgrade option.\");\n    }\n    \n    storage.processStartupOptionsForUpgrade(startOpt, layoutVersion);\n\n    // check whether distributed upgrade is required and/or should be continued\n    storage.verifyDistributedUpgradeProgress(startOpt);\n\n    // 2. Format unformatted dirs.\n    storage.setCheckpointTime(0L);\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      StorageState curState \u003d dataDirStates.get(sd);\n      switch(curState) {\n      case NON_EXISTENT:\n        throw new IOException(StorageState.NON_EXISTENT + \n                              \" state cannot be here\");\n      case NOT_FORMATTED:\n        LOG.info(\"Storage directory \" + sd.getRoot() + \" is not formatted.\");\n        LOG.info(\"Formatting ...\");\n        sd.clearDirectory(); // create empty currrent dir\n        break;\n      default:\n        break;\n      }\n    }\n\n    // 3. Do transitions\n    switch(startOpt) {\n    case UPGRADE:\n      doUpgrade();\n      return false; // upgrade saved image already\n    case IMPORT:\n      doImportCheckpoint();\n      return false; // import checkpoint saved image already\n    case ROLLBACK:\n      doRollback();\n      break;\n    case REGULAR:\n      // just load the image\n    }\n    \n    boolean needToSave \u003d loadFSImage();\n\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    if(!editLog.isOpen())\n      editLog.open();\n    \n    return needToSave;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
    }
  }
}