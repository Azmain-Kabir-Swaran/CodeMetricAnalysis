{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FileNameIndexUtils.java",
  "functionName": "getIndexInfo",
  "functionId": "getIndexInfo___jhFileName-String",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapreduce/v2/jobhistory/FileNameIndexUtils.java",
  "functionStartLine": 131,
  "functionEndLine": 207,
  "numCommitsSeen": 12,
  "timeTaken": 7122,
  "changeHistory": [
    "cfd9344540d4d0f44fd5b4c450ce3706e60045d4",
    "ee5351bf22e113d39db3839432bc7d6c743cc736",
    "9fe9f42c8fad872f7aab5f9bbdac4a860edb0d43",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "cfd9344540d4d0f44fd5b4c450ce3706e60045d4": "Ybodychange",
    "ee5351bf22e113d39db3839432bc7d6c743cc736": "Ybodychange",
    "9fe9f42c8fad872f7aab5f9bbdac4a860edb0d43": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cfd9344540d4d0f44fd5b4c450ce3706e60045d4": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5939. StartTime showing up as the epoch time in JHS UI after upgrade. Contributed by Chen He\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605892 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/06/14 12:56 PM",
      "commitName": "cfd9344540d4d0f44fd5b4c450ce3706e60045d4",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "10/04/14 9:01 PM",
      "commitNameOld": "8d41b363b85105630623b07b909b83775ffda384",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 76.66,
      "commitsBetweenForRepo": 448,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,74 @@\n   public static JobIndexInfo getIndexInfo(String jhFileName) throws IOException {\n     String fileName \u003d jhFileName.substring(0, jhFileName.indexOf(JobHistoryUtils.JOB_HISTORY_FILE_EXTENSION));\n     JobIndexInfo indexInfo \u003d new JobIndexInfo();\n     \n     String[] jobDetails \u003d fileName.split(DELIMITER);\n     \n     JobID oldJobId \u003d JobID.forName(decodeJobHistoryFileName(jobDetails[JOB_ID_INDEX]));\n     JobId jobId \u003d TypeConverter.toYarn(oldJobId);\n     indexInfo.setJobId(jobId);\n \n     // Do not fail if there are some minor parse errors\n     try {\n       try {\n         indexInfo.setSubmitTime(\n             Long.parseLong(decodeJobHistoryFileName(jobDetails[SUBMIT_TIME_INDEX])));\n       } catch (NumberFormatException e) {\n         LOG.warn(\"Unable to parse submit time from job history file \"\n             + jhFileName + \" : \" + e);\n       }\n \n       indexInfo.setUser(\n           decodeJobHistoryFileName(jobDetails[USER_INDEX]));\n \n       indexInfo.setJobName(\n           decodeJobHistoryFileName(jobDetails[JOB_NAME_INDEX]));\n \n       try {\n         indexInfo.setFinishTime(\n             Long.parseLong(decodeJobHistoryFileName(jobDetails[FINISH_TIME_INDEX])));\n       } catch (NumberFormatException e) {\n         LOG.warn(\"Unable to parse finish time from job history file \"\n             + jhFileName + \" : \" + e);\n       }\n \n       try {\n         indexInfo.setNumMaps(\n             Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_MAPS_INDEX])));\n       } catch (NumberFormatException e) {\n         LOG.warn(\"Unable to parse num maps from job history file \"\n             + jhFileName + \" : \" + e);\n       }\n \n       try {\n         indexInfo.setNumReduces(\n             Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_REDUCES_INDEX])));\n       } catch (NumberFormatException e) {\n         LOG.warn(\"Unable to parse num reduces from job history file \"\n             + jhFileName + \" : \" + e);\n       }\n \n       indexInfo.setJobStatus(\n           decodeJobHistoryFileName(jobDetails[JOB_STATUS_INDEX]));\n \n       indexInfo.setQueueName(\n           decodeJobHistoryFileName(jobDetails[QUEUE_NAME_INDEX]));\n \n       try{\n-        indexInfo.setJobStartTime(\n-          Long.parseLong(decodeJobHistoryFileName(jobDetails[JOB_START_TIME_INDEX])));\n+        if (jobDetails.length \u003c\u003d JOB_START_TIME_INDEX) {\n+          indexInfo.setJobStartTime(indexInfo.getSubmitTime());\n+        } else {\n+          indexInfo.setJobStartTime(\n+              Long.parseLong(decodeJobHistoryFileName(jobDetails[JOB_START_TIME_INDEX])));\n+        }\n       } catch (NumberFormatException e){\n-        LOG.warn(\"Unable to parse launch time from job history file \"\n+        LOG.warn(\"Unable to parse start time from job history file \"\n             + jhFileName + \" : \" + e);\n       }\n     } catch (IndexOutOfBoundsException e) {\n       LOG.warn(\"Parsing job history file with partial data encoded into name: \"\n           + jhFileName);\n     }\n     \n     return indexInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static JobIndexInfo getIndexInfo(String jhFileName) throws IOException {\n    String fileName \u003d jhFileName.substring(0, jhFileName.indexOf(JobHistoryUtils.JOB_HISTORY_FILE_EXTENSION));\n    JobIndexInfo indexInfo \u003d new JobIndexInfo();\n    \n    String[] jobDetails \u003d fileName.split(DELIMITER);\n    \n    JobID oldJobId \u003d JobID.forName(decodeJobHistoryFileName(jobDetails[JOB_ID_INDEX]));\n    JobId jobId \u003d TypeConverter.toYarn(oldJobId);\n    indexInfo.setJobId(jobId);\n\n    // Do not fail if there are some minor parse errors\n    try {\n      try {\n        indexInfo.setSubmitTime(\n            Long.parseLong(decodeJobHistoryFileName(jobDetails[SUBMIT_TIME_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse submit time from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      indexInfo.setUser(\n          decodeJobHistoryFileName(jobDetails[USER_INDEX]));\n\n      indexInfo.setJobName(\n          decodeJobHistoryFileName(jobDetails[JOB_NAME_INDEX]));\n\n      try {\n        indexInfo.setFinishTime(\n            Long.parseLong(decodeJobHistoryFileName(jobDetails[FINISH_TIME_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse finish time from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      try {\n        indexInfo.setNumMaps(\n            Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_MAPS_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse num maps from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      try {\n        indexInfo.setNumReduces(\n            Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_REDUCES_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse num reduces from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      indexInfo.setJobStatus(\n          decodeJobHistoryFileName(jobDetails[JOB_STATUS_INDEX]));\n\n      indexInfo.setQueueName(\n          decodeJobHistoryFileName(jobDetails[QUEUE_NAME_INDEX]));\n\n      try{\n        if (jobDetails.length \u003c\u003d JOB_START_TIME_INDEX) {\n          indexInfo.setJobStartTime(indexInfo.getSubmitTime());\n        } else {\n          indexInfo.setJobStartTime(\n              Long.parseLong(decodeJobHistoryFileName(jobDetails[JOB_START_TIME_INDEX])));\n        }\n      } catch (NumberFormatException e){\n        LOG.warn(\"Unable to parse start time from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n    } catch (IndexOutOfBoundsException e) {\n      LOG.warn(\"Parsing job history file with partial data encoded into name: \"\n          + jhFileName);\n    }\n    \n    return indexInfo;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapreduce/v2/jobhistory/FileNameIndexUtils.java",
      "extendedDetails": {}
    },
    "ee5351bf22e113d39db3839432bc7d6c743cc736": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5052. Job History UI and web services confusing job start time and job submit time (Chen He via jeagles)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1549896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/12/13 9:17 AM",
      "commitName": "ee5351bf22e113d39db3839432bc7d6c743cc736",
      "commitAuthor": "Jonathan Turner Eagles",
      "commitDateOld": "07/11/11 11:28 PM",
      "commitNameOld": "9fe9f42c8fad872f7aab5f9bbdac4a860edb0d43",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 763.41,
      "commitsBetweenForRepo": 4643,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,70 @@\n   public static JobIndexInfo getIndexInfo(String jhFileName) throws IOException {\n     String fileName \u003d jhFileName.substring(0, jhFileName.indexOf(JobHistoryUtils.JOB_HISTORY_FILE_EXTENSION));\n     JobIndexInfo indexInfo \u003d new JobIndexInfo();\n     \n     String[] jobDetails \u003d fileName.split(DELIMITER);\n     \n     JobID oldJobId \u003d JobID.forName(decodeJobHistoryFileName(jobDetails[JOB_ID_INDEX]));\n     JobId jobId \u003d TypeConverter.toYarn(oldJobId);\n     indexInfo.setJobId(jobId);\n \n     // Do not fail if there are some minor parse errors\n     try {\n       try {\n         indexInfo.setSubmitTime(\n             Long.parseLong(decodeJobHistoryFileName(jobDetails[SUBMIT_TIME_INDEX])));\n       } catch (NumberFormatException e) {\n         LOG.warn(\"Unable to parse submit time from job history file \"\n             + jhFileName + \" : \" + e);\n       }\n \n       indexInfo.setUser(\n           decodeJobHistoryFileName(jobDetails[USER_INDEX]));\n \n       indexInfo.setJobName(\n           decodeJobHistoryFileName(jobDetails[JOB_NAME_INDEX]));\n \n       try {\n         indexInfo.setFinishTime(\n             Long.parseLong(decodeJobHistoryFileName(jobDetails[FINISH_TIME_INDEX])));\n       } catch (NumberFormatException e) {\n         LOG.warn(\"Unable to parse finish time from job history file \"\n             + jhFileName + \" : \" + e);\n       }\n \n       try {\n         indexInfo.setNumMaps(\n             Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_MAPS_INDEX])));\n       } catch (NumberFormatException e) {\n         LOG.warn(\"Unable to parse num maps from job history file \"\n             + jhFileName + \" : \" + e);\n       }\n \n       try {\n         indexInfo.setNumReduces(\n             Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_REDUCES_INDEX])));\n       } catch (NumberFormatException e) {\n         LOG.warn(\"Unable to parse num reduces from job history file \"\n             + jhFileName + \" : \" + e);\n       }\n \n       indexInfo.setJobStatus(\n           decodeJobHistoryFileName(jobDetails[JOB_STATUS_INDEX]));\n \n       indexInfo.setQueueName(\n           decodeJobHistoryFileName(jobDetails[QUEUE_NAME_INDEX]));\n+\n+      try{\n+        indexInfo.setJobStartTime(\n+          Long.parseLong(decodeJobHistoryFileName(jobDetails[JOB_START_TIME_INDEX])));\n+      } catch (NumberFormatException e){\n+        LOG.warn(\"Unable to parse launch time from job history file \"\n+            + jhFileName + \" : \" + e);\n+      }\n     } catch (IndexOutOfBoundsException e) {\n       LOG.warn(\"Parsing job history file with partial data encoded into name: \"\n           + jhFileName);\n     }\n     \n     return indexInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static JobIndexInfo getIndexInfo(String jhFileName) throws IOException {\n    String fileName \u003d jhFileName.substring(0, jhFileName.indexOf(JobHistoryUtils.JOB_HISTORY_FILE_EXTENSION));\n    JobIndexInfo indexInfo \u003d new JobIndexInfo();\n    \n    String[] jobDetails \u003d fileName.split(DELIMITER);\n    \n    JobID oldJobId \u003d JobID.forName(decodeJobHistoryFileName(jobDetails[JOB_ID_INDEX]));\n    JobId jobId \u003d TypeConverter.toYarn(oldJobId);\n    indexInfo.setJobId(jobId);\n\n    // Do not fail if there are some minor parse errors\n    try {\n      try {\n        indexInfo.setSubmitTime(\n            Long.parseLong(decodeJobHistoryFileName(jobDetails[SUBMIT_TIME_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse submit time from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      indexInfo.setUser(\n          decodeJobHistoryFileName(jobDetails[USER_INDEX]));\n\n      indexInfo.setJobName(\n          decodeJobHistoryFileName(jobDetails[JOB_NAME_INDEX]));\n\n      try {\n        indexInfo.setFinishTime(\n            Long.parseLong(decodeJobHistoryFileName(jobDetails[FINISH_TIME_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse finish time from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      try {\n        indexInfo.setNumMaps(\n            Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_MAPS_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse num maps from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      try {\n        indexInfo.setNumReduces(\n            Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_REDUCES_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse num reduces from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      indexInfo.setJobStatus(\n          decodeJobHistoryFileName(jobDetails[JOB_STATUS_INDEX]));\n\n      indexInfo.setQueueName(\n          decodeJobHistoryFileName(jobDetails[QUEUE_NAME_INDEX]));\n\n      try{\n        indexInfo.setJobStartTime(\n          Long.parseLong(decodeJobHistoryFileName(jobDetails[JOB_START_TIME_INDEX])));\n      } catch (NumberFormatException e){\n        LOG.warn(\"Unable to parse launch time from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n    } catch (IndexOutOfBoundsException e) {\n      LOG.warn(\"Parsing job history file with partial data encoded into name: \"\n          + jhFileName);\n    }\n    \n    return indexInfo;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapreduce/v2/jobhistory/FileNameIndexUtils.java",
      "extendedDetails": {}
    },
    "9fe9f42c8fad872f7aab5f9bbdac4a860edb0d43": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3342. Fixed JobHistoryServer to also show the job\u0027s queue name. Contributed by Jonathan Eagles.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1199133 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/11/11 11:28 PM",
      "commitName": "9fe9f42c8fad872f7aab5f9bbdac4a860edb0d43",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "07/10/11 1:44 PM",
      "commitNameOld": "047b175aac0c8431d3d1f31665b9f8c4569e6c64",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 31.45,
      "commitsBetweenForRepo": 272,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,62 @@\n   public static JobIndexInfo getIndexInfo(String jhFileName) throws IOException {\n     String fileName \u003d jhFileName.substring(0, jhFileName.indexOf(JobHistoryUtils.JOB_HISTORY_FILE_EXTENSION));\n     JobIndexInfo indexInfo \u003d new JobIndexInfo();\n     \n     String[] jobDetails \u003d fileName.split(DELIMITER);\n-    if (jobDetails.length !\u003d MAX_INDEX +1) {\n-      throw new IOException(\"Failed to parse file: [\" + jhFileName + \"]. Expected \" + (MAX_INDEX + 1) + \"parts.\");  \n-    }\n     \n     JobID oldJobId \u003d JobID.forName(decodeJobHistoryFileName(jobDetails[JOB_ID_INDEX]));\n     JobId jobId \u003d TypeConverter.toYarn(oldJobId);\n     indexInfo.setJobId(jobId);\n-    //TODO Catch NumberFormatException - Do not fail if there\u0027s only a few fields missing.\n-    indexInfo.setSubmitTime(Long.parseLong(decodeJobHistoryFileName(jobDetails[SUBMIT_TIME_INDEX])));\n-    \n-    indexInfo.setUser(decodeJobHistoryFileName(jobDetails[USER_INDEX]));\n-    \n-    indexInfo.setJobName(decodeJobHistoryFileName(jobDetails[JOB_NAME_INDEX]));\n-    \n-    indexInfo.setFinishTime(Long.parseLong(decodeJobHistoryFileName(jobDetails[FINISH_TIME_INDEX])));\n-    \n-    indexInfo.setNumMaps(Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_MAPS_INDEX])));\n-    \n-    indexInfo.setNumReduces(Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_REDUCES_INDEX])));\n-    \n-    indexInfo.setJobStatus(decodeJobHistoryFileName(jobDetails[JOB_STATUS_INDEX]));\n+\n+    // Do not fail if there are some minor parse errors\n+    try {\n+      try {\n+        indexInfo.setSubmitTime(\n+            Long.parseLong(decodeJobHistoryFileName(jobDetails[SUBMIT_TIME_INDEX])));\n+      } catch (NumberFormatException e) {\n+        LOG.warn(\"Unable to parse submit time from job history file \"\n+            + jhFileName + \" : \" + e);\n+      }\n+\n+      indexInfo.setUser(\n+          decodeJobHistoryFileName(jobDetails[USER_INDEX]));\n+\n+      indexInfo.setJobName(\n+          decodeJobHistoryFileName(jobDetails[JOB_NAME_INDEX]));\n+\n+      try {\n+        indexInfo.setFinishTime(\n+            Long.parseLong(decodeJobHistoryFileName(jobDetails[FINISH_TIME_INDEX])));\n+      } catch (NumberFormatException e) {\n+        LOG.warn(\"Unable to parse finish time from job history file \"\n+            + jhFileName + \" : \" + e);\n+      }\n+\n+      try {\n+        indexInfo.setNumMaps(\n+            Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_MAPS_INDEX])));\n+      } catch (NumberFormatException e) {\n+        LOG.warn(\"Unable to parse num maps from job history file \"\n+            + jhFileName + \" : \" + e);\n+      }\n+\n+      try {\n+        indexInfo.setNumReduces(\n+            Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_REDUCES_INDEX])));\n+      } catch (NumberFormatException e) {\n+        LOG.warn(\"Unable to parse num reduces from job history file \"\n+            + jhFileName + \" : \" + e);\n+      }\n+\n+      indexInfo.setJobStatus(\n+          decodeJobHistoryFileName(jobDetails[JOB_STATUS_INDEX]));\n+\n+      indexInfo.setQueueName(\n+          decodeJobHistoryFileName(jobDetails[QUEUE_NAME_INDEX]));\n+    } catch (IndexOutOfBoundsException e) {\n+      LOG.warn(\"Parsing job history file with partial data encoded into name: \"\n+          + jhFileName);\n+    }\n     \n     return indexInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static JobIndexInfo getIndexInfo(String jhFileName) throws IOException {\n    String fileName \u003d jhFileName.substring(0, jhFileName.indexOf(JobHistoryUtils.JOB_HISTORY_FILE_EXTENSION));\n    JobIndexInfo indexInfo \u003d new JobIndexInfo();\n    \n    String[] jobDetails \u003d fileName.split(DELIMITER);\n    \n    JobID oldJobId \u003d JobID.forName(decodeJobHistoryFileName(jobDetails[JOB_ID_INDEX]));\n    JobId jobId \u003d TypeConverter.toYarn(oldJobId);\n    indexInfo.setJobId(jobId);\n\n    // Do not fail if there are some minor parse errors\n    try {\n      try {\n        indexInfo.setSubmitTime(\n            Long.parseLong(decodeJobHistoryFileName(jobDetails[SUBMIT_TIME_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse submit time from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      indexInfo.setUser(\n          decodeJobHistoryFileName(jobDetails[USER_INDEX]));\n\n      indexInfo.setJobName(\n          decodeJobHistoryFileName(jobDetails[JOB_NAME_INDEX]));\n\n      try {\n        indexInfo.setFinishTime(\n            Long.parseLong(decodeJobHistoryFileName(jobDetails[FINISH_TIME_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse finish time from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      try {\n        indexInfo.setNumMaps(\n            Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_MAPS_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse num maps from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      try {\n        indexInfo.setNumReduces(\n            Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_REDUCES_INDEX])));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Unable to parse num reduces from job history file \"\n            + jhFileName + \" : \" + e);\n      }\n\n      indexInfo.setJobStatus(\n          decodeJobHistoryFileName(jobDetails[JOB_STATUS_INDEX]));\n\n      indexInfo.setQueueName(\n          decodeJobHistoryFileName(jobDetails[QUEUE_NAME_INDEX]));\n    } catch (IndexOutOfBoundsException e) {\n      LOG.warn(\"Parsing job history file with partial data encoded into name: \"\n          + jhFileName);\n    }\n    \n    return indexInfo;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapreduce/v2/jobhistory/FileNameIndexUtils.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public static JobIndexInfo getIndexInfo(String jhFileName) throws IOException {\n    String fileName \u003d jhFileName.substring(0, jhFileName.indexOf(JobHistoryUtils.JOB_HISTORY_FILE_EXTENSION));\n    JobIndexInfo indexInfo \u003d new JobIndexInfo();\n    \n    String[] jobDetails \u003d fileName.split(DELIMITER);\n    if (jobDetails.length !\u003d MAX_INDEX +1) {\n      throw new IOException(\"Failed to parse file: [\" + jhFileName + \"]. Expected \" + (MAX_INDEX + 1) + \"parts.\");  \n    }\n    \n    JobID oldJobId \u003d JobID.forName(decodeJobHistoryFileName(jobDetails[JOB_ID_INDEX]));\n    JobId jobId \u003d TypeConverter.toYarn(oldJobId);\n    indexInfo.setJobId(jobId);\n    //TODO Catch NumberFormatException - Do not fail if there\u0027s only a few fields missing.\n    indexInfo.setSubmitTime(Long.parseLong(decodeJobHistoryFileName(jobDetails[SUBMIT_TIME_INDEX])));\n    \n    indexInfo.setUser(decodeJobHistoryFileName(jobDetails[USER_INDEX]));\n    \n    indexInfo.setJobName(decodeJobHistoryFileName(jobDetails[JOB_NAME_INDEX]));\n    \n    indexInfo.setFinishTime(Long.parseLong(decodeJobHistoryFileName(jobDetails[FINISH_TIME_INDEX])));\n    \n    indexInfo.setNumMaps(Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_MAPS_INDEX])));\n    \n    indexInfo.setNumReduces(Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_REDUCES_INDEX])));\n    \n    indexInfo.setJobStatus(decodeJobHistoryFileName(jobDetails[JOB_STATUS_INDEX]));\n    \n    return indexInfo;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapreduce/v2/jobhistory/FileNameIndexUtils.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapreduce/v2/jobhistory/FileNameIndexUtils.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapreduce/v2/jobhistory/FileNameIndexUtils.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,29 @@\n+  public static JobIndexInfo getIndexInfo(String jhFileName) throws IOException {\n+    String fileName \u003d jhFileName.substring(0, jhFileName.indexOf(JobHistoryUtils.JOB_HISTORY_FILE_EXTENSION));\n+    JobIndexInfo indexInfo \u003d new JobIndexInfo();\n+    \n+    String[] jobDetails \u003d fileName.split(DELIMITER);\n+    if (jobDetails.length !\u003d MAX_INDEX +1) {\n+      throw new IOException(\"Failed to parse file: [\" + jhFileName + \"]. Expected \" + (MAX_INDEX + 1) + \"parts.\");  \n+    }\n+    \n+    JobID oldJobId \u003d JobID.forName(decodeJobHistoryFileName(jobDetails[JOB_ID_INDEX]));\n+    JobId jobId \u003d TypeConverter.toYarn(oldJobId);\n+    indexInfo.setJobId(jobId);\n+    //TODO Catch NumberFormatException - Do not fail if there\u0027s only a few fields missing.\n+    indexInfo.setSubmitTime(Long.parseLong(decodeJobHistoryFileName(jobDetails[SUBMIT_TIME_INDEX])));\n+    \n+    indexInfo.setUser(decodeJobHistoryFileName(jobDetails[USER_INDEX]));\n+    \n+    indexInfo.setJobName(decodeJobHistoryFileName(jobDetails[JOB_NAME_INDEX]));\n+    \n+    indexInfo.setFinishTime(Long.parseLong(decodeJobHistoryFileName(jobDetails[FINISH_TIME_INDEX])));\n+    \n+    indexInfo.setNumMaps(Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_MAPS_INDEX])));\n+    \n+    indexInfo.setNumReduces(Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_REDUCES_INDEX])));\n+    \n+    indexInfo.setJobStatus(decodeJobHistoryFileName(jobDetails[JOB_STATUS_INDEX]));\n+    \n+    return indexInfo;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static JobIndexInfo getIndexInfo(String jhFileName) throws IOException {\n    String fileName \u003d jhFileName.substring(0, jhFileName.indexOf(JobHistoryUtils.JOB_HISTORY_FILE_EXTENSION));\n    JobIndexInfo indexInfo \u003d new JobIndexInfo();\n    \n    String[] jobDetails \u003d fileName.split(DELIMITER);\n    if (jobDetails.length !\u003d MAX_INDEX +1) {\n      throw new IOException(\"Failed to parse file: [\" + jhFileName + \"]. Expected \" + (MAX_INDEX + 1) + \"parts.\");  \n    }\n    \n    JobID oldJobId \u003d JobID.forName(decodeJobHistoryFileName(jobDetails[JOB_ID_INDEX]));\n    JobId jobId \u003d TypeConverter.toYarn(oldJobId);\n    indexInfo.setJobId(jobId);\n    //TODO Catch NumberFormatException - Do not fail if there\u0027s only a few fields missing.\n    indexInfo.setSubmitTime(Long.parseLong(decodeJobHistoryFileName(jobDetails[SUBMIT_TIME_INDEX])));\n    \n    indexInfo.setUser(decodeJobHistoryFileName(jobDetails[USER_INDEX]));\n    \n    indexInfo.setJobName(decodeJobHistoryFileName(jobDetails[JOB_NAME_INDEX]));\n    \n    indexInfo.setFinishTime(Long.parseLong(decodeJobHistoryFileName(jobDetails[FINISH_TIME_INDEX])));\n    \n    indexInfo.setNumMaps(Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_MAPS_INDEX])));\n    \n    indexInfo.setNumReduces(Integer.parseInt(decodeJobHistoryFileName(jobDetails[NUM_REDUCES_INDEX])));\n    \n    indexInfo.setJobStatus(decodeJobHistoryFileName(jobDetails[JOB_STATUS_INDEX]));\n    \n    return indexInfo;\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapreduce/v2/jobhistory/FileNameIndexUtils.java"
    }
  }
}