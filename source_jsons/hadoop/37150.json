{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SimpleCapacityReplanner.java",
  "functionName": "plan",
  "functionId": "plan___plan-Plan__contracts-List__ReservationDefinition__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/SimpleCapacityReplanner.java",
  "functionStartLine": 79,
  "functionEndLine": 117,
  "numCommitsSeen": 7,
  "timeTaken": 1053,
  "changeHistory": [
    "156f24ead00436faad5d4aeef327a546392cd265",
    "1c6950354f3c35a7824770dc251d5aec3be4876a"
  ],
  "changeHistoryShort": {
    "156f24ead00436faad5d4aeef327a546392cd265": "Yfilerename",
    "1c6950354f3c35a7824770dc251d5aec3be4876a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "156f24ead00436faad5d4aeef327a546392cd265": {
      "type": "Yfilerename",
      "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
      "commitDate": "25/07/15 7:39 AM",
      "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
      "commitAuthor": "ccurino",
      "commitDateOld": "24/07/15 6:31 PM",
      "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 0.55,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,39 @@\n   public void plan(Plan plan, List\u003cReservationDefinition\u003e contracts)\n       throws PlanningException {\n \n     if (contracts !\u003d null) {\n       throw new RuntimeException(\n           \"SimpleCapacityReplanner cannot handle new reservation contracts\");\n     }\n \n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource totCap \u003d plan.getTotalCapacity();\n     long now \u003d clock.getTime();\n \n     // loop on all moment in time from now to the end of the check Zone\n     // or the end of the planned sessions whichever comes first\n-    for (long t \u003d now; (t \u003c plan.getLastEndTime() \u0026\u0026 t \u003c (now + lengthOfCheckZone)); t +\u003d\n-        plan.getStep()) {\n+    for (long t \u003d now; \n+         (t \u003c plan.getLastEndTime() \u0026\u0026 t \u003c (now + lengthOfCheckZone)); \n+         t +\u003d plan.getStep()) {\n       Resource excessCap \u003d\n           Resources.subtract(plan.getTotalCommittedResources(t), totCap);\n       // if we are violating\n       if (Resources.greaterThan(resCalc, totCap, excessCap, ZERO_RESOURCE)) {\n         // sorted on reverse order of acceptance, so newest reservations first\n         Set\u003cReservationAllocation\u003e curReservations \u003d\n             new TreeSet\u003cReservationAllocation\u003e(plan.getReservationsAtTime(t));\n         for (Iterator\u003cReservationAllocation\u003e resIter \u003d\n             curReservations.iterator(); resIter.hasNext()\n-            \u0026\u0026 Resources.greaterThan(resCalc, totCap, excessCap, ZERO_RESOURCE);) {\n+            \u0026\u0026 Resources.greaterThan(resCalc, totCap, excessCap, \n+                ZERO_RESOURCE);) {\n           ReservationAllocation reservation \u003d resIter.next();\n           plan.deleteReservation(reservation.getReservationId());\n           excessCap \u003d\n               Resources.subtract(excessCap, reservation.getResourcesAtTime(t));\n           LOG.info(\"Removing reservation \" + reservation.getReservationId()\n               + \" to repair physical-resource constraints in the plan: \"\n               + plan.getQueueName());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void plan(Plan plan, List\u003cReservationDefinition\u003e contracts)\n      throws PlanningException {\n\n    if (contracts !\u003d null) {\n      throw new RuntimeException(\n          \"SimpleCapacityReplanner cannot handle new reservation contracts\");\n    }\n\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource totCap \u003d plan.getTotalCapacity();\n    long now \u003d clock.getTime();\n\n    // loop on all moment in time from now to the end of the check Zone\n    // or the end of the planned sessions whichever comes first\n    for (long t \u003d now; \n         (t \u003c plan.getLastEndTime() \u0026\u0026 t \u003c (now + lengthOfCheckZone)); \n         t +\u003d plan.getStep()) {\n      Resource excessCap \u003d\n          Resources.subtract(plan.getTotalCommittedResources(t), totCap);\n      // if we are violating\n      if (Resources.greaterThan(resCalc, totCap, excessCap, ZERO_RESOURCE)) {\n        // sorted on reverse order of acceptance, so newest reservations first\n        Set\u003cReservationAllocation\u003e curReservations \u003d\n            new TreeSet\u003cReservationAllocation\u003e(plan.getReservationsAtTime(t));\n        for (Iterator\u003cReservationAllocation\u003e resIter \u003d\n            curReservations.iterator(); resIter.hasNext()\n            \u0026\u0026 Resources.greaterThan(resCalc, totCap, excessCap, \n                ZERO_RESOURCE);) {\n          ReservationAllocation reservation \u003d resIter.next();\n          plan.deleteReservation(reservation.getReservationId());\n          excessCap \u003d\n              Resources.subtract(excessCap, reservation.getResourcesAtTime(t));\n          LOG.info(\"Removing reservation \" + reservation.getReservationId()\n              + \" to repair physical-resource constraints in the plan: \"\n              + plan.getQueueName());\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/SimpleCapacityReplanner.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/SimpleCapacityReplanner.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/SimpleCapacityReplanner.java"
      }
    },
    "1c6950354f3c35a7824770dc251d5aec3be4876a": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2475. Logic for responding to capacity drops for the ReservationSystem. Contributed by Carlo Curino and Subru Krishnan.\n(cherry picked from commit f83a07f266f2c5e6eead554d8a331ed7e75e10d5)\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "1c6950354f3c35a7824770dc251d5aec3be4876a",
      "commitAuthor": "carlo curino",
      "diff": "@@ -0,0 +1,37 @@\n+  public void plan(Plan plan, List\u003cReservationDefinition\u003e contracts)\n+      throws PlanningException {\n+\n+    if (contracts !\u003d null) {\n+      throw new RuntimeException(\n+          \"SimpleCapacityReplanner cannot handle new reservation contracts\");\n+    }\n+\n+    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n+    Resource totCap \u003d plan.getTotalCapacity();\n+    long now \u003d clock.getTime();\n+\n+    // loop on all moment in time from now to the end of the check Zone\n+    // or the end of the planned sessions whichever comes first\n+    for (long t \u003d now; (t \u003c plan.getLastEndTime() \u0026\u0026 t \u003c (now + lengthOfCheckZone)); t +\u003d\n+        plan.getStep()) {\n+      Resource excessCap \u003d\n+          Resources.subtract(plan.getTotalCommittedResources(t), totCap);\n+      // if we are violating\n+      if (Resources.greaterThan(resCalc, totCap, excessCap, ZERO_RESOURCE)) {\n+        // sorted on reverse order of acceptance, so newest reservations first\n+        Set\u003cReservationAllocation\u003e curReservations \u003d\n+            new TreeSet\u003cReservationAllocation\u003e(plan.getReservationsAtTime(t));\n+        for (Iterator\u003cReservationAllocation\u003e resIter \u003d\n+            curReservations.iterator(); resIter.hasNext()\n+            \u0026\u0026 Resources.greaterThan(resCalc, totCap, excessCap, ZERO_RESOURCE);) {\n+          ReservationAllocation reservation \u003d resIter.next();\n+          plan.deleteReservation(reservation.getReservationId());\n+          excessCap \u003d\n+              Resources.subtract(excessCap, reservation.getResourcesAtTime(t));\n+          LOG.info(\"Removing reservation \" + reservation.getReservationId()\n+              + \" to repair physical-resource constraints in the plan: \"\n+              + plan.getQueueName());\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void plan(Plan plan, List\u003cReservationDefinition\u003e contracts)\n      throws PlanningException {\n\n    if (contracts !\u003d null) {\n      throw new RuntimeException(\n          \"SimpleCapacityReplanner cannot handle new reservation contracts\");\n    }\n\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource totCap \u003d plan.getTotalCapacity();\n    long now \u003d clock.getTime();\n\n    // loop on all moment in time from now to the end of the check Zone\n    // or the end of the planned sessions whichever comes first\n    for (long t \u003d now; (t \u003c plan.getLastEndTime() \u0026\u0026 t \u003c (now + lengthOfCheckZone)); t +\u003d\n        plan.getStep()) {\n      Resource excessCap \u003d\n          Resources.subtract(plan.getTotalCommittedResources(t), totCap);\n      // if we are violating\n      if (Resources.greaterThan(resCalc, totCap, excessCap, ZERO_RESOURCE)) {\n        // sorted on reverse order of acceptance, so newest reservations first\n        Set\u003cReservationAllocation\u003e curReservations \u003d\n            new TreeSet\u003cReservationAllocation\u003e(plan.getReservationsAtTime(t));\n        for (Iterator\u003cReservationAllocation\u003e resIter \u003d\n            curReservations.iterator(); resIter.hasNext()\n            \u0026\u0026 Resources.greaterThan(resCalc, totCap, excessCap, ZERO_RESOURCE);) {\n          ReservationAllocation reservation \u003d resIter.next();\n          plan.deleteReservation(reservation.getReservationId());\n          excessCap \u003d\n              Resources.subtract(excessCap, reservation.getResourcesAtTime(t));\n          LOG.info(\"Removing reservation \" + reservation.getReservationId()\n              + \" to repair physical-resource constraints in the plan: \"\n              + plan.getQueueName());\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/SimpleCapacityReplanner.java"
    }
  }
}