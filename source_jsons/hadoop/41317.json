{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSAppAttempt.java",
  "functionName": "assignContainer",
  "functionId": "assignContainer___node-FSSchedulerNode__pendingAsk-PendingAsk__type-NodeType__reserved-boolean__schedulerKey-SchedulerRequestKey",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
  "functionStartLine": 847,
  "functionEndLine": 921,
  "numCommitsSeen": 145,
  "timeTaken": 8306,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "f48fec83d0f2d1a781a141ad7216463c5526321f",
    "45535f8afae4e5bf4f60597fc29ba94b4e7743f3",
    "4db9cc70d0178703fb28f451eb84d97f2bf63af8",
    "2977bc6a141041ef7579efc416e93fc55e0c2a1a",
    "59ee8b7a88603e94b5661a8d5d088f7aa99fe049",
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
    "5279af7cd4afb090da742a96b5786d9dee6224bc",
    "f9692770a58af0ab082eb7f15da9cbdcd177605b",
    "e88422df45550f788ae8dd73aec84bde28012aeb",
    "7e2837f830382835838c82398db6fc9823d612a7",
    "94dec5a9164cd9bc573fbf74e76bcff9e7c5c637",
    "bd69ea408f8fdd8293836ce1089fe9b01616f2f7",
    "6a6a59db7f1bfda47c3c14fb49676a7b22d2eb06",
    "b6466deac6d5d6344f693144290b46e2bef83a02",
    "486e718fc1f5befd231494e2ec06bb360484f191"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "f48fec83d0f2d1a781a141ad7216463c5526321f": "Ybodychange",
    "45535f8afae4e5bf4f60597fc29ba94b4e7743f3": "Ybodychange",
    "4db9cc70d0178703fb28f451eb84d97f2bf63af8": "Ybodychange",
    "2977bc6a141041ef7579efc416e93fc55e0c2a1a": "Ymultichange(Yparameterchange,Ybodychange)",
    "59ee8b7a88603e94b5661a8d5d088f7aa99fe049": "Ybodychange",
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828": "Ymultichange(Yparameterchange,Ybodychange)",
    "5279af7cd4afb090da742a96b5786d9dee6224bc": "Ybodychange",
    "f9692770a58af0ab082eb7f15da9cbdcd177605b": "Ybodychange",
    "e88422df45550f788ae8dd73aec84bde28012aeb": "Ybodychange",
    "7e2837f830382835838c82398db6fc9823d612a7": "Ybodychange",
    "94dec5a9164cd9bc573fbf74e76bcff9e7c5c637": "Ybodychange",
    "bd69ea408f8fdd8293836ce1089fe9b01616f2f7": "Ybodychange",
    "6a6a59db7f1bfda47c3c14fb49676a7b22d2eb06": "Ybodychange",
    "b6466deac6d5d6344f693144290b46e2bef83a02": "Ybodychange",
    "486e718fc1f5befd231494e2ec06bb360484f191": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,75 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n       boolean reserved, SchedulerRequestKey schedulerKey) {\n \n     // How much does this request need?\n     Resource capability \u003d pendingAsk.getPerAllocationResource();\n \n     // How much does the node have?\n     Resource available \u003d node.getUnallocatedResource();\n \n     Container reservedContainer \u003d null;\n     if (reserved) {\n       reservedContainer \u003d node.getReservedContainer().getContainer();\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, schedulerKey, pendingAsk,\n               reservedContainer);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(schedulerKey, node);\n         }\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(String.format(\n-              \"Resource ask %s fits in available node resources %s, \" +\n-                      \"but no container was allocated\",\n-              capability, available));\n-        }\n+        LOG.debug(\"Resource ask {} fits in available node resources {},\"\n+            + \" but no container was allocated\", capability, available);\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(schedulerKey, node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(capability);\n         getQueue().addAMResourceUsage(capability);\n         setAmRunning(true);\n       }\n \n       return capability;\n     }\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Resource request: \" + capability + \" exceeds the available\"\n-          + \" resources of the node.\");\n-    }\n+    LOG.debug(\"Resource request: {} exceeds the available\"\n+          + \" resources of the node.\", capability);\n \n     // The desired container won\u0027t fit here, so reserve\n     // Reserve only, if app does not wait for preempted resources on the node,\n     // otherwise we may end up with duplicate reservations\n     if (isReservable(capability) \u0026\u0026\n         !node.isPreemptedForApp(this) \u0026\u0026\n         reserve(pendingAsk.getPerAllocationResource(), node, reservedContainer,\n             type, schedulerKey)) {\n       updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n           + \"the node and the request is reserved)\");\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(getName() + \"\u0027s resource request is reserved.\");\n-      }\n+      LOG.debug(\"{}\u0027s resource request is reserved.\", getName());\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n       updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n           + \"the node and the request cannot be reserved)\");\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Couldn\u0027t create reservation for app:  \" + getName()\n             + \", at priority \" +  schedulerKey.getPriority());\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n      boolean reserved, SchedulerRequestKey schedulerKey) {\n\n    // How much does this request need?\n    Resource capability \u003d pendingAsk.getPerAllocationResource();\n\n    // How much does the node have?\n    Resource available \u003d node.getUnallocatedResource();\n\n    Container reservedContainer \u003d null;\n    if (reserved) {\n      reservedContainer \u003d node.getReservedContainer().getContainer();\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, schedulerKey, pendingAsk,\n              reservedContainer);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(schedulerKey, node);\n        }\n        LOG.debug(\"Resource ask {} fits in available node resources {},\"\n            + \" but no container was allocated\", capability, available);\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(schedulerKey, node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(capability);\n        getQueue().addAMResourceUsage(capability);\n        setAmRunning(true);\n      }\n\n      return capability;\n    }\n\n    LOG.debug(\"Resource request: {} exceeds the available\"\n          + \" resources of the node.\", capability);\n\n    // The desired container won\u0027t fit here, so reserve\n    // Reserve only, if app does not wait for preempted resources on the node,\n    // otherwise we may end up with duplicate reservations\n    if (isReservable(capability) \u0026\u0026\n        !node.isPreemptedForApp(this) \u0026\u0026\n        reserve(pendingAsk.getPerAllocationResource(), node, reservedContainer,\n            type, schedulerKey)) {\n      updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n          + \"the node and the request is reserved)\");\n      LOG.debug(\"{}\u0027s resource request is reserved.\", getName());\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n          + \"the node and the request cannot be reserved)\");\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t create reservation for app:  \" + getName()\n            + \", at priority \" +  schedulerKey.getPriority());\n      }\n      return Resources.none();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "f48fec83d0f2d1a781a141ad7216463c5526321f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8248. Job hangs when a job requests a resource that its queue does not have. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "21/05/18 8:10 AM",
      "commitName": "f48fec83d0f2d1a781a141ad7216463c5526321f",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "16/01/18 2:46 PM",
      "commitNameOld": "370f1c6283813dc1c7d001f44930e3c79c140c54",
      "commitAuthorOld": "Yufei Gu",
      "daysBetweenCommits": 124.68,
      "commitsBetweenForRepo": 1482,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,83 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n       boolean reserved, SchedulerRequestKey schedulerKey) {\n \n     // How much does this request need?\n     Resource capability \u003d pendingAsk.getPerAllocationResource();\n \n     // How much does the node have?\n     Resource available \u003d node.getUnallocatedResource();\n \n     Container reservedContainer \u003d null;\n     if (reserved) {\n       reservedContainer \u003d node.getReservedContainer().getContainer();\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, schedulerKey, pendingAsk,\n               reservedContainer);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(schedulerKey, node);\n         }\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(String.format(\n+              \"Resource ask %s fits in available node resources %s, \" +\n+                      \"but no container was allocated\",\n+              capability, available));\n+        }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(schedulerKey, node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(capability);\n         getQueue().addAMResourceUsage(capability);\n         setAmRunning(true);\n       }\n \n       return capability;\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Resource request: \" + capability + \" exceeds the available\"\n           + \" resources of the node.\");\n     }\n \n     // The desired container won\u0027t fit here, so reserve\n     // Reserve only, if app does not wait for preempted resources on the node,\n     // otherwise we may end up with duplicate reservations\n     if (isReservable(capability) \u0026\u0026\n         !node.isPreemptedForApp(this) \u0026\u0026\n         reserve(pendingAsk.getPerAllocationResource(), node, reservedContainer,\n             type, schedulerKey)) {\n       updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n           + \"the node and the request is reserved)\");\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(getName() + \"\u0027s resource request is reserved.\");\n       }\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n       updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n           + \"the node and the request cannot be reserved)\");\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Couldn\u0027t create reservation for app:  \" + getName()\n             + \", at priority \" +  schedulerKey.getPriority());\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n      boolean reserved, SchedulerRequestKey schedulerKey) {\n\n    // How much does this request need?\n    Resource capability \u003d pendingAsk.getPerAllocationResource();\n\n    // How much does the node have?\n    Resource available \u003d node.getUnallocatedResource();\n\n    Container reservedContainer \u003d null;\n    if (reserved) {\n      reservedContainer \u003d node.getReservedContainer().getContainer();\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, schedulerKey, pendingAsk,\n              reservedContainer);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(schedulerKey, node);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(String.format(\n              \"Resource ask %s fits in available node resources %s, \" +\n                      \"but no container was allocated\",\n              capability, available));\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(schedulerKey, node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(capability);\n        getQueue().addAMResourceUsage(capability);\n        setAmRunning(true);\n      }\n\n      return capability;\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Resource request: \" + capability + \" exceeds the available\"\n          + \" resources of the node.\");\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    // Reserve only, if app does not wait for preempted resources on the node,\n    // otherwise we may end up with duplicate reservations\n    if (isReservable(capability) \u0026\u0026\n        !node.isPreemptedForApp(this) \u0026\u0026\n        reserve(pendingAsk.getPerAllocationResource(), node, reservedContainer,\n            type, schedulerKey)) {\n      updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n          + \"the node and the request is reserved)\");\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(getName() + \"\u0027s resource request is reserved.\");\n      }\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n          + \"the node and the request cannot be reserved)\");\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t create reservation for app:  \" + getName()\n            + \", at priority \" +  schedulerKey.getPriority());\n      }\n      return Resources.none();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "45535f8afae4e5bf4f60597fc29ba94b4e7743f3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6895. [FairScheduler] Preemption reservation may cause regular reservation leaks. (Miklos Szegedi via Yufei Gu)\n",
      "commitDate": "02/08/17 9:25 AM",
      "commitName": "45535f8afae4e5bf4f60597fc29ba94b4e7743f3",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "19/06/17 9:01 AM",
      "commitNameOld": "e9c2aa1bc383cb08784846534415bf17667d6e41",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 44.02,
      "commitsBetweenForRepo": 281,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,77 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n       boolean reserved, SchedulerRequestKey schedulerKey) {\n \n     // How much does this request need?\n     Resource capability \u003d pendingAsk.getPerAllocationResource();\n \n     // How much does the node have?\n     Resource available \u003d node.getUnallocatedResource();\n \n     Container reservedContainer \u003d null;\n     if (reserved) {\n       reservedContainer \u003d node.getReservedContainer().getContainer();\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, schedulerKey, pendingAsk,\n               reservedContainer);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(schedulerKey, node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(schedulerKey, node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(capability);\n         getQueue().addAMResourceUsage(capability);\n         setAmRunning(true);\n       }\n \n       return capability;\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Resource request: \" + capability + \" exceeds the available\"\n           + \" resources of the node.\");\n     }\n \n     // The desired container won\u0027t fit here, so reserve\n+    // Reserve only, if app does not wait for preempted resources on the node,\n+    // otherwise we may end up with duplicate reservations\n     if (isReservable(capability) \u0026\u0026\n+        !node.isPreemptedForApp(this) \u0026\u0026\n         reserve(pendingAsk.getPerAllocationResource(), node, reservedContainer,\n             type, schedulerKey)) {\n       updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n           + \"the node and the request is reserved)\");\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(getName() + \"\u0027s resource request is reserved.\");\n       }\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n       updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n           + \"the node and the request cannot be reserved)\");\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Couldn\u0027t create reservation for app:  \" + getName()\n             + \", at priority \" +  schedulerKey.getPriority());\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n      boolean reserved, SchedulerRequestKey schedulerKey) {\n\n    // How much does this request need?\n    Resource capability \u003d pendingAsk.getPerAllocationResource();\n\n    // How much does the node have?\n    Resource available \u003d node.getUnallocatedResource();\n\n    Container reservedContainer \u003d null;\n    if (reserved) {\n      reservedContainer \u003d node.getReservedContainer().getContainer();\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, schedulerKey, pendingAsk,\n              reservedContainer);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(schedulerKey, node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(schedulerKey, node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(capability);\n        getQueue().addAMResourceUsage(capability);\n        setAmRunning(true);\n      }\n\n      return capability;\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Resource request: \" + capability + \" exceeds the available\"\n          + \" resources of the node.\");\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    // Reserve only, if app does not wait for preempted resources on the node,\n    // otherwise we may end up with duplicate reservations\n    if (isReservable(capability) \u0026\u0026\n        !node.isPreemptedForApp(this) \u0026\u0026\n        reserve(pendingAsk.getPerAllocationResource(), node, reservedContainer,\n            type, schedulerKey)) {\n      updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n          + \"the node and the request is reserved)\");\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(getName() + \"\u0027s resource request is reserved.\");\n      }\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n          + \"the node and the request cannot be reserved)\");\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t create reservation for app:  \" + getName()\n            + \", at priority \" +  schedulerKey.getPriority());\n      }\n      return Resources.none();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "4db9cc70d0178703fb28f451eb84d97f2bf63af8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6042. Dump scheduler and queue state information into FairScheduler DEBUG log. (Yufei Gu via rchiang)\n",
      "commitDate": "10/03/17 4:13 PM",
      "commitName": "4db9cc70d0178703fb28f451eb84d97f2bf63af8",
      "commitAuthor": "Ray Chiang",
      "commitDateOld": "09/03/17 5:51 PM",
      "commitNameOld": "846a0cd678fba743220f28cef844ac9011a3f934",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,74 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n       boolean reserved, SchedulerRequestKey schedulerKey) {\n \n     // How much does this request need?\n     Resource capability \u003d pendingAsk.getPerAllocationResource();\n \n     // How much does the node have?\n     Resource available \u003d node.getUnallocatedResource();\n \n     Container reservedContainer \u003d null;\n     if (reserved) {\n       reservedContainer \u003d node.getReservedContainer().getContainer();\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, schedulerKey, pendingAsk,\n               reservedContainer);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(schedulerKey, node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(schedulerKey, node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(capability);\n         getQueue().addAMResourceUsage(capability);\n         setAmRunning(true);\n       }\n \n       return capability;\n     }\n \n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Resource request: \" + capability + \" exceeds the available\"\n+          + \" resources of the node.\");\n+    }\n+\n     // The desired container won\u0027t fit here, so reserve\n     if (isReservable(capability) \u0026\u0026\n         reserve(pendingAsk.getPerAllocationResource(), node, reservedContainer,\n             type, schedulerKey)) {\n-      if (isWaitingForAMContainer()) {\n-        updateAMDiagnosticMsg(capability,\n-            \" exceed the available resources of the node and the request is\"\n-                + \" reserved\");\n+      updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n+          + \"the node and the request is reserved)\");\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(getName() + \"\u0027s resource request is reserved.\");\n       }\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n-      if (isWaitingForAMContainer()) {\n-        updateAMDiagnosticMsg(capability,\n-            \" exceed the available resources of the node and the request cannot\"\n-                + \" be reserved\");\n-      }\n+      updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n+          + \"the node and the request cannot be reserved)\");\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Couldn\u0027t creating reservation for \" +\n-            getName() + \",at priority \" +  schedulerKey.getPriority());\n+        LOG.debug(\"Couldn\u0027t create reservation for app:  \" + getName()\n+            + \", at priority \" +  schedulerKey.getPriority());\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n      boolean reserved, SchedulerRequestKey schedulerKey) {\n\n    // How much does this request need?\n    Resource capability \u003d pendingAsk.getPerAllocationResource();\n\n    // How much does the node have?\n    Resource available \u003d node.getUnallocatedResource();\n\n    Container reservedContainer \u003d null;\n    if (reserved) {\n      reservedContainer \u003d node.getReservedContainer().getContainer();\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, schedulerKey, pendingAsk,\n              reservedContainer);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(schedulerKey, node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(schedulerKey, node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(capability);\n        getQueue().addAMResourceUsage(capability);\n        setAmRunning(true);\n      }\n\n      return capability;\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Resource request: \" + capability + \" exceeds the available\"\n          + \" resources of the node.\");\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    if (isReservable(capability) \u0026\u0026\n        reserve(pendingAsk.getPerAllocationResource(), node, reservedContainer,\n            type, schedulerKey)) {\n      updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n          + \"the node and the request is reserved)\");\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(getName() + \"\u0027s resource request is reserved.\");\n      }\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      updateAMDiagnosticMsg(capability, \" exceeds the available resources of \"\n          + \"the node and the request cannot be reserved)\");\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t create reservation for app:  \" + getName()\n            + \", at priority \" +  schedulerKey.getPriority());\n      }\n      return Resources.none();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "2977bc6a141041ef7579efc416e93fc55e0c2a1a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6040. Introduce api independent PendingAsk to replace usage of ResourceRequest within Scheduler classes. (Wangda Tan via asuresh)\n",
      "commitDate": "06/01/17 9:59 AM",
      "commitName": "2977bc6a141041ef7579efc416e93fc55e0c2a1a",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6040. Introduce api independent PendingAsk to replace usage of ResourceRequest within Scheduler classes. (Wangda Tan via asuresh)\n",
          "commitDate": "06/01/17 9:59 AM",
          "commitName": "2977bc6a141041ef7579efc416e93fc55e0c2a1a",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "05/01/17 10:31 AM",
          "commitNameOld": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.98,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,72 @@\n   private Resource assignContainer(\n-      FSSchedulerNode node, ResourceRequest request, NodeType type,\n+      FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n       boolean reserved, SchedulerRequestKey schedulerKey) {\n \n     // How much does this request need?\n-    Resource capability \u003d request.getCapability();\n+    Resource capability \u003d pendingAsk.getPerAllocationResource();\n \n     // How much does the node have?\n     Resource available \u003d node.getUnallocatedResource();\n \n     Container reservedContainer \u003d null;\n     if (reserved) {\n       reservedContainer \u003d node.getReservedContainer().getContainer();\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n-          allocate(type, node, schedulerKey, request,\n+          allocate(type, node, schedulerKey, pendingAsk,\n               reservedContainer);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(schedulerKey, node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(schedulerKey, node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(capability);\n         getQueue().addAMResourceUsage(capability);\n         setAmRunning(true);\n       }\n \n       return capability;\n     }\n \n     // The desired container won\u0027t fit here, so reserve\n-    if (isReservable(capability) \u0026\u0026\n-        reserve(request, node, reservedContainer, type, schedulerKey)) {\n+    if (isReservable(capability) \u0026\u0026 reserve(\n+        pendingAsk.getPerAllocationResource(), node, reservedContainer, type,\n+        schedulerKey)) {\n       if (isWaitingForAMContainer()) {\n         updateAMDiagnosticMsg(capability,\n             \" exceed the available resources of the node and the request is\"\n                 + \" reserved\");\n       }\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n       if (isWaitingForAMContainer()) {\n         updateAMDiagnosticMsg(capability,\n             \" exceed the available resources of the node and the request cannot\"\n                 + \" be reserved\");\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Couldn\u0027t creating reservation for \" +\n-            getName() + \",at priority \" +  request.getPriority());\n+            getName() + \",at priority \" +  schedulerKey.getPriority());\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n      boolean reserved, SchedulerRequestKey schedulerKey) {\n\n    // How much does this request need?\n    Resource capability \u003d pendingAsk.getPerAllocationResource();\n\n    // How much does the node have?\n    Resource available \u003d node.getUnallocatedResource();\n\n    Container reservedContainer \u003d null;\n    if (reserved) {\n      reservedContainer \u003d node.getReservedContainer().getContainer();\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, schedulerKey, pendingAsk,\n              reservedContainer);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(schedulerKey, node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(schedulerKey, node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(capability);\n        getQueue().addAMResourceUsage(capability);\n        setAmRunning(true);\n      }\n\n      return capability;\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    if (isReservable(capability) \u0026\u0026 reserve(\n        pendingAsk.getPerAllocationResource(), node, reservedContainer, type,\n        schedulerKey)) {\n      if (isWaitingForAMContainer()) {\n        updateAMDiagnosticMsg(capability,\n            \" exceed the available resources of the node and the request is\"\n                + \" reserved\");\n      }\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      if (isWaitingForAMContainer()) {\n        updateAMDiagnosticMsg(capability,\n            \" exceed the available resources of the node and the request cannot\"\n                + \" be reserved\");\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t creating reservation for \" +\n            getName() + \",at priority \" +  schedulerKey.getPriority());\n      }\n      return Resources.none();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
          "extendedDetails": {
            "oldValue": "[node-FSSchedulerNode, request-ResourceRequest, type-NodeType, reserved-boolean, schedulerKey-SchedulerRequestKey]",
            "newValue": "[node-FSSchedulerNode, pendingAsk-PendingAsk, type-NodeType, reserved-boolean, schedulerKey-SchedulerRequestKey]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6040. Introduce api independent PendingAsk to replace usage of ResourceRequest within Scheduler classes. (Wangda Tan via asuresh)\n",
          "commitDate": "06/01/17 9:59 AM",
          "commitName": "2977bc6a141041ef7579efc416e93fc55e0c2a1a",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "05/01/17 10:31 AM",
          "commitNameOld": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.98,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,72 @@\n   private Resource assignContainer(\n-      FSSchedulerNode node, ResourceRequest request, NodeType type,\n+      FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n       boolean reserved, SchedulerRequestKey schedulerKey) {\n \n     // How much does this request need?\n-    Resource capability \u003d request.getCapability();\n+    Resource capability \u003d pendingAsk.getPerAllocationResource();\n \n     // How much does the node have?\n     Resource available \u003d node.getUnallocatedResource();\n \n     Container reservedContainer \u003d null;\n     if (reserved) {\n       reservedContainer \u003d node.getReservedContainer().getContainer();\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n-          allocate(type, node, schedulerKey, request,\n+          allocate(type, node, schedulerKey, pendingAsk,\n               reservedContainer);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(schedulerKey, node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(schedulerKey, node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(capability);\n         getQueue().addAMResourceUsage(capability);\n         setAmRunning(true);\n       }\n \n       return capability;\n     }\n \n     // The desired container won\u0027t fit here, so reserve\n-    if (isReservable(capability) \u0026\u0026\n-        reserve(request, node, reservedContainer, type, schedulerKey)) {\n+    if (isReservable(capability) \u0026\u0026 reserve(\n+        pendingAsk.getPerAllocationResource(), node, reservedContainer, type,\n+        schedulerKey)) {\n       if (isWaitingForAMContainer()) {\n         updateAMDiagnosticMsg(capability,\n             \" exceed the available resources of the node and the request is\"\n                 + \" reserved\");\n       }\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n       if (isWaitingForAMContainer()) {\n         updateAMDiagnosticMsg(capability,\n             \" exceed the available resources of the node and the request cannot\"\n                 + \" be reserved\");\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Couldn\u0027t creating reservation for \" +\n-            getName() + \",at priority \" +  request.getPriority());\n+            getName() + \",at priority \" +  schedulerKey.getPriority());\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, PendingAsk pendingAsk, NodeType type,\n      boolean reserved, SchedulerRequestKey schedulerKey) {\n\n    // How much does this request need?\n    Resource capability \u003d pendingAsk.getPerAllocationResource();\n\n    // How much does the node have?\n    Resource available \u003d node.getUnallocatedResource();\n\n    Container reservedContainer \u003d null;\n    if (reserved) {\n      reservedContainer \u003d node.getReservedContainer().getContainer();\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, schedulerKey, pendingAsk,\n              reservedContainer);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(schedulerKey, node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(schedulerKey, node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(capability);\n        getQueue().addAMResourceUsage(capability);\n        setAmRunning(true);\n      }\n\n      return capability;\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    if (isReservable(capability) \u0026\u0026 reserve(\n        pendingAsk.getPerAllocationResource(), node, reservedContainer, type,\n        schedulerKey)) {\n      if (isWaitingForAMContainer()) {\n        updateAMDiagnosticMsg(capability,\n            \" exceed the available resources of the node and the request is\"\n                + \" reserved\");\n      }\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      if (isWaitingForAMContainer()) {\n        updateAMDiagnosticMsg(capability,\n            \" exceed the available resources of the node and the request cannot\"\n                + \" be reserved\");\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t creating reservation for \" +\n            getName() + \",at priority \" +  schedulerKey.getPriority());\n      }\n      return Resources.none();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
          "extendedDetails": {}
        }
      ]
    },
    "59ee8b7a88603e94b5661a8d5d088f7aa99fe049": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4329. [YARN-5437] Allow fetching exact reason as to why a submitted app\nis in ACCEPTED state in Fair Scheduler (Contributed by Yufei Gu)\n",
      "commitDate": "09/11/16 1:11 PM",
      "commitName": "59ee8b7a88603e94b5661a8d5d088f7aa99fe049",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "31/10/16 1:34 PM",
      "commitNameOld": "2528bea67ff80fae597f10e26c5f70d601af9fb1",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 9.03,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,71 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, ResourceRequest request, NodeType type,\n       boolean reserved, SchedulerRequestKey schedulerKey) {\n \n     // How much does this request need?\n     Resource capability \u003d request.getCapability();\n \n     // How much does the node have?\n     Resource available \u003d node.getUnallocatedResource();\n \n     Container reservedContainer \u003d null;\n     if (reserved) {\n       reservedContainer \u003d node.getReservedContainer().getContainer();\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, schedulerKey, request,\n               reservedContainer);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(schedulerKey, node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(schedulerKey, node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(capability);\n         getQueue().addAMResourceUsage(capability);\n         setAmRunning(true);\n       }\n \n       return capability;\n     }\n \n     // The desired container won\u0027t fit here, so reserve\n     if (isReservable(capability) \u0026\u0026\n         reserve(request, node, reservedContainer, type, schedulerKey)) {\n+      if (isWaitingForAMContainer()) {\n+        updateAMDiagnosticMsg(capability,\n+            \" exceed the available resources of the node and the request is\"\n+                + \" reserved\");\n+      }\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n+      if (isWaitingForAMContainer()) {\n+        updateAMDiagnosticMsg(capability,\n+            \" exceed the available resources of the node and the request cannot\"\n+                + \" be reserved\");\n+      }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Couldn\u0027t creating reservation for \" +\n             getName() + \",at priority \" +  request.getPriority());\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved, SchedulerRequestKey schedulerKey) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getUnallocatedResource();\n\n    Container reservedContainer \u003d null;\n    if (reserved) {\n      reservedContainer \u003d node.getReservedContainer().getContainer();\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, schedulerKey, request,\n              reservedContainer);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(schedulerKey, node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(schedulerKey, node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(capability);\n        getQueue().addAMResourceUsage(capability);\n        setAmRunning(true);\n      }\n\n      return capability;\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    if (isReservable(capability) \u0026\u0026\n        reserve(request, node, reservedContainer, type, schedulerKey)) {\n      if (isWaitingForAMContainer()) {\n        updateAMDiagnosticMsg(capability,\n            \" exceed the available resources of the node and the request is\"\n                + \" reserved\");\n      }\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      if (isWaitingForAMContainer()) {\n        updateAMDiagnosticMsg(capability,\n            \" exceed the available resources of the node and the request cannot\"\n                + \" be reserved\");\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t creating reservation for \" +\n            getName() + \",at priority \" +  request.getPriority());\n      }\n      return Resources.none();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
      "commitDate": "26/07/16 2:54 PM",
      "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
          "commitDate": "26/07/16 2:54 PM",
          "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "11/07/16 10:36 PM",
          "commitNameOld": "819224dcf9c683aa52f58633ac8e13663f1916d8",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 14.68,
          "commitsBetweenForRepo": 98,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,61 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, ResourceRequest request, NodeType type,\n-      boolean reserved) {\n+      boolean reserved, SchedulerRequestKey schedulerKey) {\n \n     // How much does this request need?\n     Resource capability \u003d request.getCapability();\n \n     // How much does the node have?\n     Resource available \u003d node.getUnallocatedResource();\n \n     Container reservedContainer \u003d null;\n     if (reserved) {\n       reservedContainer \u003d node.getReservedContainer().getContainer();\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n-          allocate(type, node, request.getPriority(), request,\n+          allocate(type, node, schedulerKey, request,\n               reservedContainer);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n-          unreserve(request.getPriority(), node);\n+          unreserve(schedulerKey, node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n-        unreserve(request.getPriority(), node);\n+        unreserve(schedulerKey, node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(capability);\n         getQueue().addAMResourceUsage(capability);\n         setAmRunning(true);\n       }\n \n       return capability;\n     }\n \n     // The desired container won\u0027t fit here, so reserve\n     if (isReservable(capability) \u0026\u0026\n-        reserve(request, node, reservedContainer, type)) {\n+        reserve(request, node, reservedContainer, type, schedulerKey)) {\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Couldn\u0027t creating reservation for \" +\n             getName() + \",at priority \" +  request.getPriority());\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved, SchedulerRequestKey schedulerKey) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getUnallocatedResource();\n\n    Container reservedContainer \u003d null;\n    if (reserved) {\n      reservedContainer \u003d node.getReservedContainer().getContainer();\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, schedulerKey, request,\n              reservedContainer);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(schedulerKey, node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(schedulerKey, node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(capability);\n        getQueue().addAMResourceUsage(capability);\n        setAmRunning(true);\n      }\n\n      return capability;\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    if (isReservable(capability) \u0026\u0026\n        reserve(request, node, reservedContainer, type, schedulerKey)) {\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t creating reservation for \" +\n            getName() + \",at priority \" +  request.getPriority());\n      }\n      return Resources.none();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
          "extendedDetails": {
            "oldValue": "[node-FSSchedulerNode, request-ResourceRequest, type-NodeType, reserved-boolean]",
            "newValue": "[node-FSSchedulerNode, request-ResourceRequest, type-NodeType, reserved-boolean, schedulerKey-SchedulerRequestKey]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
          "commitDate": "26/07/16 2:54 PM",
          "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "11/07/16 10:36 PM",
          "commitNameOld": "819224dcf9c683aa52f58633ac8e13663f1916d8",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 14.68,
          "commitsBetweenForRepo": 98,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,61 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, ResourceRequest request, NodeType type,\n-      boolean reserved) {\n+      boolean reserved, SchedulerRequestKey schedulerKey) {\n \n     // How much does this request need?\n     Resource capability \u003d request.getCapability();\n \n     // How much does the node have?\n     Resource available \u003d node.getUnallocatedResource();\n \n     Container reservedContainer \u003d null;\n     if (reserved) {\n       reservedContainer \u003d node.getReservedContainer().getContainer();\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n-          allocate(type, node, request.getPriority(), request,\n+          allocate(type, node, schedulerKey, request,\n               reservedContainer);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n-          unreserve(request.getPriority(), node);\n+          unreserve(schedulerKey, node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n-        unreserve(request.getPriority(), node);\n+        unreserve(schedulerKey, node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(capability);\n         getQueue().addAMResourceUsage(capability);\n         setAmRunning(true);\n       }\n \n       return capability;\n     }\n \n     // The desired container won\u0027t fit here, so reserve\n     if (isReservable(capability) \u0026\u0026\n-        reserve(request, node, reservedContainer, type)) {\n+        reserve(request, node, reservedContainer, type, schedulerKey)) {\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Couldn\u0027t creating reservation for \" +\n             getName() + \",at priority \" +  request.getPriority());\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved, SchedulerRequestKey schedulerKey) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getUnallocatedResource();\n\n    Container reservedContainer \u003d null;\n    if (reserved) {\n      reservedContainer \u003d node.getReservedContainer().getContainer();\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, schedulerKey, request,\n              reservedContainer);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(schedulerKey, node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(schedulerKey, node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(capability);\n        getQueue().addAMResourceUsage(capability);\n        setAmRunning(true);\n      }\n\n      return capability;\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    if (isReservable(capability) \u0026\u0026\n        reserve(request, node, reservedContainer, type, schedulerKey)) {\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t creating reservation for \" +\n            getName() + \",at priority \" +  request.getPriority());\n      }\n      return Resources.none();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
          "extendedDetails": {}
        }
      ]
    },
    "5279af7cd4afb090da742a96b5786d9dee6224bc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5082. Limit ContainerId increase in fair scheduler if the num of node app reserved reached the limit (sandflee via asuresh)\n",
      "commitDate": "10/06/16 10:33 PM",
      "commitName": "5279af7cd4afb090da742a96b5786d9dee6224bc",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "29/05/16 8:54 AM",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 12.57,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,61 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, ResourceRequest request, NodeType type,\n       boolean reserved) {\n \n     // How much does this request need?\n     Resource capability \u003d request.getCapability();\n \n     // How much does the node have?\n     Resource available \u003d node.getUnallocatedResource();\n \n-    Container container \u003d null;\n+    Container reservedContainer \u003d null;\n     if (reserved) {\n-      container \u003d node.getReservedContainer().getContainer();\n-    } else {\n-      container \u003d createContainer(node, capability, request.getPriority());\n+      reservedContainer \u003d node.getReservedContainer().getContainer();\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n-          allocate(type, node, request.getPriority(), request, container);\n+          allocate(type, node, request.getPriority(), request,\n+              reservedContainer);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(request.getPriority(), node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(request.getPriority(), node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n-        setAMResource(container.getResource());\n-        getQueue().addAMResourceUsage(container.getResource());\n+        setAMResource(capability);\n+        getQueue().addAMResourceUsage(capability);\n         setAmRunning(true);\n       }\n \n-      return container.getResource();\n+      return capability;\n     }\n \n     // The desired container won\u0027t fit here, so reserve\n-    if (isReservable(container) \u0026\u0026\n-        reserve(request.getPriority(), node, container, type, reserved)) {\n+    if (isReservable(capability) \u0026\u0026\n+        reserve(request, node, reservedContainer, type)) {\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Not creating reservation as container \" + container.getId()\n-            + \" is not reservable\");\n+        LOG.debug(\"Couldn\u0027t creating reservation for \" +\n+            getName() + \",at priority \" +  request.getPriority());\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getUnallocatedResource();\n\n    Container reservedContainer \u003d null;\n    if (reserved) {\n      reservedContainer \u003d node.getReservedContainer().getContainer();\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, request.getPriority(), request,\n              reservedContainer);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(request.getPriority(), node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(request.getPriority(), node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(capability);\n        getQueue().addAMResourceUsage(capability);\n        setAmRunning(true);\n      }\n\n      return capability;\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    if (isReservable(capability) \u0026\u0026\n        reserve(request, node, reservedContainer, type)) {\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Couldn\u0027t creating reservation for \" +\n            getName() + \",at priority \" +  request.getPriority());\n      }\n      return Resources.none();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "f9692770a58af0ab082eb7f15da9cbdcd177605b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4718. Rename variables in SchedulerNode to reduce ambiguity post YARN-1011. (Inigo Goiri via kasha)\n",
      "commitDate": "28/02/16 9:35 AM",
      "commitName": "f9692770a58af0ab082eb7f15da9cbdcd177605b",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "17/02/16 8:55 PM",
      "commitNameOld": "7de70680fe44967e2afc92ba4c92f8e7afa7b151",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 10.53,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, ResourceRequest request, NodeType type,\n       boolean reserved) {\n \n     // How much does this request need?\n     Resource capability \u003d request.getCapability();\n \n     // How much does the node have?\n-    Resource available \u003d node.getAvailableResource();\n+    Resource available \u003d node.getUnallocatedResource();\n \n     Container container \u003d null;\n     if (reserved) {\n       container \u003d node.getReservedContainer().getContainer();\n     } else {\n       container \u003d createContainer(node, capability, request.getPriority());\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, request.getPriority(), request, container);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(request.getPriority(), node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(request.getPriority(), node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(container.getResource());\n         getQueue().addAMResourceUsage(container.getResource());\n         setAmRunning(true);\n       }\n \n       return container.getResource();\n     }\n \n     // The desired container won\u0027t fit here, so reserve\n     if (isReservable(container) \u0026\u0026\n         reserve(request.getPriority(), node, container, type, reserved)) {\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Not creating reservation as container \" + container.getId()\n             + \" is not reservable\");\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getUnallocatedResource();\n\n    Container container \u003d null;\n    if (reserved) {\n      container \u003d node.getReservedContainer().getContainer();\n    } else {\n      container \u003d createContainer(node, capability, request.getPriority());\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, request.getPriority(), request, container);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(request.getPriority(), node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(request.getPriority(), node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(container.getResource());\n        getQueue().addAMResourceUsage(container.getResource());\n        setAmRunning(true);\n      }\n\n      return container.getResource();\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    if (isReservable(container) \u0026\u0026\n        reserve(request.getPriority(), node, container, type, reserved)) {\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Not creating reservation as container \" + container.getId()\n            + \" is not reservable\");\n      }\n      return Resources.none();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "e88422df45550f788ae8dd73aec84bde28012aeb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4477. FairScheduler: Handle condition which can result in an infinite loop in attemptScheduling. (Tao Jie via asuresh)\n",
      "commitDate": "21/12/15 10:41 PM",
      "commitName": "e88422df45550f788ae8dd73aec84bde28012aeb",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "15/12/15 12:17 AM",
      "commitNameOld": "2aaed1032719e978660d1f14a8ed299e83b5f65e",
      "commitAuthorOld": "Zhihai Xu",
      "daysBetweenCommits": 6.93,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,62 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, ResourceRequest request, NodeType type,\n       boolean reserved) {\n \n     // How much does this request need?\n     Resource capability \u003d request.getCapability();\n \n     // How much does the node have?\n     Resource available \u003d node.getAvailableResource();\n \n     Container container \u003d null;\n     if (reserved) {\n       container \u003d node.getReservedContainer().getContainer();\n     } else {\n       container \u003d createContainer(node, capability, request.getPriority());\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, request.getPriority(), request, container);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(request.getPriority(), node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(request.getPriority(), node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(container.getResource());\n         getQueue().addAMResourceUsage(container.getResource());\n         setAmRunning(true);\n       }\n \n       return container.getResource();\n     }\n \n-    if (isReservable(container)) {\n-      // The desired container won\u0027t fit here, so reserve\n-      reserve(request.getPriority(), node, container, type, reserved);\n-\n+    // The desired container won\u0027t fit here, so reserve\n+    if (isReservable(container) \u0026\u0026\n+        reserve(request.getPriority(), node, container, type, reserved)) {\n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Not creating reservation as container \" + container.getId()\n             + \" is not reservable\");\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getAvailableResource();\n\n    Container container \u003d null;\n    if (reserved) {\n      container \u003d node.getReservedContainer().getContainer();\n    } else {\n      container \u003d createContainer(node, capability, request.getPriority());\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, request.getPriority(), request, container);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(request.getPriority(), node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(request.getPriority(), node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(container.getResource());\n        getQueue().addAMResourceUsage(container.getResource());\n        setAmRunning(true);\n      }\n\n      return container.getResource();\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    if (isReservable(container) \u0026\u0026\n        reserve(request.getPriority(), node, container, type, reserved)) {\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Not creating reservation as container \" + container.getId()\n            + \" is not reservable\");\n      }\n      return Resources.none();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "7e2837f830382835838c82398db6fc9823d612a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4270. Limit application resource reservation on nodes for non-node/rack specific requests (asuresh)\n",
      "commitDate": "19/10/15 8:00 PM",
      "commitName": "7e2837f830382835838c82398db6fc9823d612a7",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "18/09/15 2:02 PM",
      "commitNameOld": "94dec5a9164cd9bc573fbf74e76bcff9e7c5c637",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 31.25,
      "commitsBetweenForRepo": 225,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, ResourceRequest request, NodeType type,\n       boolean reserved) {\n \n     // How much does this request need?\n     Resource capability \u003d request.getCapability();\n \n     // How much does the node have?\n     Resource available \u003d node.getAvailableResource();\n \n     Container container \u003d null;\n     if (reserved) {\n       container \u003d node.getReservedContainer().getContainer();\n     } else {\n       container \u003d createContainer(node, capability, request.getPriority());\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, request.getPriority(), request, container);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(request.getPriority(), node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(request.getPriority(), node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(container.getResource());\n         getQueue().addAMResourceUsage(container.getResource());\n         setAmRunning(true);\n       }\n \n       return container.getResource();\n     }\n \n     if (isReservable(container)) {\n       // The desired container won\u0027t fit here, so reserve\n-      reserve(request.getPriority(), node, container, reserved);\n+      reserve(request.getPriority(), node, container, type, reserved);\n \n       return FairScheduler.CONTAINER_RESERVED;\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Not creating reservation as container \" + container.getId()\n             + \" is not reservable\");\n       }\n       return Resources.none();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getAvailableResource();\n\n    Container container \u003d null;\n    if (reserved) {\n      container \u003d node.getReservedContainer().getContainer();\n    } else {\n      container \u003d createContainer(node, capability, request.getPriority());\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, request.getPriority(), request, container);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(request.getPriority(), node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(request.getPriority(), node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(container.getResource());\n        getQueue().addAMResourceUsage(container.getResource());\n        setAmRunning(true);\n      }\n\n      return container.getResource();\n    }\n\n    if (isReservable(container)) {\n      // The desired container won\u0027t fit here, so reserve\n      reserve(request.getPriority(), node, container, type, reserved);\n\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Not creating reservation as container \" + container.getId()\n            + \" is not reservable\");\n      }\n      return Resources.none();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "94dec5a9164cd9bc573fbf74e76bcff9e7c5c637": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3920. FairScheduler container reservation on a node should be configurable to limit it to large containers (adhoot via asuresh)\n",
      "commitDate": "18/09/15 2:02 PM",
      "commitName": "94dec5a9164cd9bc573fbf74e76bcff9e7c5c637",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "29/07/15 9:42 AM",
      "commitNameOld": "5205a330b387d2e133ee790b9fe7d5af3cd8bccc",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 51.18,
      "commitsBetweenForRepo": 290,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,63 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, ResourceRequest request, NodeType type,\n       boolean reserved) {\n \n     // How much does this request need?\n     Resource capability \u003d request.getCapability();\n \n     // How much does the node have?\n     Resource available \u003d node.getAvailableResource();\n \n     Container container \u003d null;\n     if (reserved) {\n       container \u003d node.getReservedContainer().getContainer();\n     } else {\n       container \u003d createContainer(node, capability, request.getPriority());\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, request.getPriority(), request, container);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(request.getPriority(), node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(request.getPriority(), node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(container.getResource());\n         getQueue().addAMResourceUsage(container.getResource());\n         setAmRunning(true);\n       }\n \n       return container.getResource();\n     }\n \n-    // The desired container won\u0027t fit here, so reserve\n-    reserve(request.getPriority(), node, container, reserved);\n+    if (isReservable(container)) {\n+      // The desired container won\u0027t fit here, so reserve\n+      reserve(request.getPriority(), node, container, reserved);\n \n-    return FairScheduler.CONTAINER_RESERVED;\n+      return FairScheduler.CONTAINER_RESERVED;\n+    } else {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Not creating reservation as container \" + container.getId()\n+            + \" is not reservable\");\n+      }\n+      return Resources.none();\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getAvailableResource();\n\n    Container container \u003d null;\n    if (reserved) {\n      container \u003d node.getReservedContainer().getContainer();\n    } else {\n      container \u003d createContainer(node, capability, request.getPriority());\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, request.getPriority(), request, container);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(request.getPriority(), node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(request.getPriority(), node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(container.getResource());\n        getQueue().addAMResourceUsage(container.getResource());\n        setAmRunning(true);\n      }\n\n      return container.getResource();\n    }\n\n    if (isReservable(container)) {\n      // The desired container won\u0027t fit here, so reserve\n      reserve(request.getPriority(), node, container, reserved);\n\n      return FairScheduler.CONTAINER_RESERVED;\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Not creating reservation as container \" + container.getId()\n            + \" is not reservable\");\n      }\n      return Resources.none();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "bd69ea408f8fdd8293836ce1089fe9b01616f2f7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3655. FairScheduler: potential livelock due to maxAMShare limitation and container reservation. (Zhihai Xu via kasha)\n",
      "commitDate": "07/06/15 11:37 AM",
      "commitName": "bd69ea408f8fdd8293836ce1089fe9b01616f2f7",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "28/04/15 9:00 PM",
      "commitNameOld": "8f82970e0c247b37b2bf33aa21f6a39afa07efde",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 39.61,
      "commitsBetweenForRepo": 397,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,55 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, ResourceRequest request, NodeType type,\n       boolean reserved) {\n \n     // How much does this request need?\n     Resource capability \u003d request.getCapability();\n \n     // How much does the node have?\n     Resource available \u003d node.getAvailableResource();\n \n     Container container \u003d null;\n     if (reserved) {\n       container \u003d node.getReservedContainer().getContainer();\n     } else {\n       container \u003d createContainer(node, capability, request.getPriority());\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, request.getPriority(), request, container);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(request.getPriority(), node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(request.getPriority(), node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If not running unmanaged, the first container we allocate is always\n       // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n       // usage\n       if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n         setAMResource(container.getResource());\n         getQueue().addAMResourceUsage(container.getResource());\n         setAmRunning(true);\n       }\n \n       return container.getResource();\n-    } else {\n-      if (!FairScheduler.fitsInMaxShare(getQueue(), capability)) {\n-        return Resources.none();\n-      }\n-\n-      // The desired container won\u0027t fit here, so reserve\n-      reserve(request.getPriority(), node, container, reserved);\n-\n-      return FairScheduler.CONTAINER_RESERVED;\n     }\n+\n+    // The desired container won\u0027t fit here, so reserve\n+    reserve(request.getPriority(), node, container, reserved);\n+\n+    return FairScheduler.CONTAINER_RESERVED;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getAvailableResource();\n\n    Container container \u003d null;\n    if (reserved) {\n      container \u003d node.getReservedContainer().getContainer();\n    } else {\n      container \u003d createContainer(node, capability, request.getPriority());\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, request.getPriority(), request, container);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(request.getPriority(), node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(request.getPriority(), node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(container.getResource());\n        getQueue().addAMResourceUsage(container.getResource());\n        setAmRunning(true);\n      }\n\n      return container.getResource();\n    }\n\n    // The desired container won\u0027t fit here, so reserve\n    reserve(request.getPriority(), node, container, reserved);\n\n    return FairScheduler.CONTAINER_RESERVED;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "6a6a59db7f1bfda47c3c14fb49676a7b22d2eb06": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3415. Non-AM containers can be counted towards amResourceUsage of a fairscheduler queue (Zhihai Xu via Sandy Ryza)\n",
      "commitDate": "02/04/15 1:56 PM",
      "commitName": "6a6a59db7f1bfda47c3c14fb49676a7b22d2eb06",
      "commitAuthor": "Sandy Ryza",
      "commitDateOld": "31/03/15 1:42 AM",
      "commitNameOld": "b5a22e983832d4843b5df1d07858988e8bbf37e3",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 2.51,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,59 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, ResourceRequest request, NodeType type,\n       boolean reserved) {\n \n     // How much does this request need?\n     Resource capability \u003d request.getCapability();\n \n     // How much does the node have?\n     Resource available \u003d node.getAvailableResource();\n \n     Container container \u003d null;\n     if (reserved) {\n       container \u003d node.getReservedContainer().getContainer();\n     } else {\n       container \u003d createContainer(node, capability, request.getPriority());\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, request.getPriority(), request, container);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(request.getPriority(), node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(request.getPriority(), node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n-      // If this container is used to run AM, update the leaf queue\u0027s AM usage\n-      if (getLiveContainers().size() \u003d\u003d 1 \u0026\u0026 !getUnmanagedAM()) {\n+      // If not running unmanaged, the first container we allocate is always\n+      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n+      // usage\n+      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n+        setAMResource(container.getResource());\n         getQueue().addAMResourceUsage(container.getResource());\n         setAmRunning(true);\n       }\n \n       return container.getResource();\n     } else {\n       if (!FairScheduler.fitsInMaxShare(getQueue(), capability)) {\n         return Resources.none();\n       }\n \n       // The desired container won\u0027t fit here, so reserve\n       reserve(request.getPriority(), node, container, reserved);\n \n       return FairScheduler.CONTAINER_RESERVED;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getAvailableResource();\n\n    Container container \u003d null;\n    if (reserved) {\n      container \u003d node.getReservedContainer().getContainer();\n    } else {\n      container \u003d createContainer(node, capability, request.getPriority());\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, request.getPriority(), request, container);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(request.getPriority(), node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(request.getPriority(), node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If not running unmanaged, the first container we allocate is always\n      // the AM. Set the amResource for this app and update the leaf queue\u0027s AM\n      // usage\n      if (!isAmRunning() \u0026\u0026 !getUnmanagedAM()) {\n        setAMResource(container.getResource());\n        getQueue().addAMResourceUsage(container.getResource());\n        setAmRunning(true);\n      }\n\n      return container.getResource();\n    } else {\n      if (!FairScheduler.fitsInMaxShare(getQueue(), capability)) {\n        return Resources.none();\n      }\n\n      // The desired container won\u0027t fit here, so reserve\n      reserve(request.getPriority(), node, container, reserved);\n\n      return FairScheduler.CONTAINER_RESERVED;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "b6466deac6d5d6344f693144290b46e2bef83a02": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3101. In Fair Scheduler, fix canceling of reservations for exceeding max share (Anubhav Dhoot via Sandy Ryza)\n",
      "commitDate": "05/02/15 9:39 AM",
      "commitName": "b6466deac6d5d6344f693144290b46e2bef83a02",
      "commitAuthor": "Sandy Ryza",
      "commitDateOld": "09/12/14 2:00 PM",
      "commitNameOld": "a2e07a54561a57a83b943628ebbc53ed5ba52718",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 57.82,
      "commitsBetweenForRepo": 370,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,56 @@\n   private Resource assignContainer(\n       FSSchedulerNode node, ResourceRequest request, NodeType type,\n       boolean reserved) {\n \n     // How much does this request need?\n     Resource capability \u003d request.getCapability();\n \n     // How much does the node have?\n     Resource available \u003d node.getAvailableResource();\n \n     Container container \u003d null;\n     if (reserved) {\n       container \u003d node.getReservedContainer().getContainer();\n     } else {\n       container \u003d createContainer(node, capability, request.getPriority());\n     }\n \n     // Can we allocate a container on this node?\n     if (Resources.fitsIn(capability, available)) {\n       // Inform the application of the new container for this request\n       RMContainer allocatedContainer \u003d\n           allocate(type, node, request.getPriority(), request, container);\n       if (allocatedContainer \u003d\u003d null) {\n         // Did the application need this resource?\n         if (reserved) {\n           unreserve(request.getPriority(), node);\n         }\n         return Resources.none();\n       }\n \n       // If we had previously made a reservation, delete it\n       if (reserved) {\n         unreserve(request.getPriority(), node);\n       }\n \n       // Inform the node\n       node.allocateContainer(allocatedContainer);\n \n       // If this container is used to run AM, update the leaf queue\u0027s AM usage\n       if (getLiveContainers().size() \u003d\u003d 1 \u0026\u0026 !getUnmanagedAM()) {\n         getQueue().addAMResourceUsage(container.getResource());\n         setAmRunning(true);\n       }\n \n       return container.getResource();\n     } else {\n+      if (!FairScheduler.fitsInMaxShare(getQueue(), capability)) {\n+        return Resources.none();\n+      }\n+\n       // The desired container won\u0027t fit here, so reserve\n       reserve(request.getPriority(), node, container, reserved);\n \n       return FairScheduler.CONTAINER_RESERVED;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getAvailableResource();\n\n    Container container \u003d null;\n    if (reserved) {\n      container \u003d node.getReservedContainer().getContainer();\n    } else {\n      container \u003d createContainer(node, capability, request.getPriority());\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, request.getPriority(), request, container);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(request.getPriority(), node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(request.getPriority(), node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If this container is used to run AM, update the leaf queue\u0027s AM usage\n      if (getLiveContainers().size() \u003d\u003d 1 \u0026\u0026 !getUnmanagedAM()) {\n        getQueue().addAMResourceUsage(container.getResource());\n        setAmRunning(true);\n      }\n\n      return container.getResource();\n    } else {\n      if (!FairScheduler.fitsInMaxShare(getQueue(), capability)) {\n        return Resources.none();\n      }\n\n      // The desired container won\u0027t fit here, so reserve\n      reserve(request.getPriority(), node, container, reserved);\n\n      return FairScheduler.CONTAINER_RESERVED;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java",
      "extendedDetails": {}
    },
    "486e718fc1f5befd231494e2ec06bb360484f191": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2399. FairScheduler: Merge AppSchedulable and FSSchedulerApp into FSAppAttempt. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617600 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 2:43 PM",
      "commitName": "486e718fc1f5befd231494e2ec06bb360484f191",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,52 @@\n+  private Resource assignContainer(\n+      FSSchedulerNode node, ResourceRequest request, NodeType type,\n+      boolean reserved) {\n+\n+    // How much does this request need?\n+    Resource capability \u003d request.getCapability();\n+\n+    // How much does the node have?\n+    Resource available \u003d node.getAvailableResource();\n+\n+    Container container \u003d null;\n+    if (reserved) {\n+      container \u003d node.getReservedContainer().getContainer();\n+    } else {\n+      container \u003d createContainer(node, capability, request.getPriority());\n+    }\n+\n+    // Can we allocate a container on this node?\n+    if (Resources.fitsIn(capability, available)) {\n+      // Inform the application of the new container for this request\n+      RMContainer allocatedContainer \u003d\n+          allocate(type, node, request.getPriority(), request, container);\n+      if (allocatedContainer \u003d\u003d null) {\n+        // Did the application need this resource?\n+        if (reserved) {\n+          unreserve(request.getPriority(), node);\n+        }\n+        return Resources.none();\n+      }\n+\n+      // If we had previously made a reservation, delete it\n+      if (reserved) {\n+        unreserve(request.getPriority(), node);\n+      }\n+\n+      // Inform the node\n+      node.allocateContainer(allocatedContainer);\n+\n+      // If this container is used to run AM, update the leaf queue\u0027s AM usage\n+      if (getLiveContainers().size() \u003d\u003d 1 \u0026\u0026 !getUnmanagedAM()) {\n+        getQueue().addAMResourceUsage(container.getResource());\n+        setAmRunning(true);\n+      }\n+\n+      return container.getResource();\n+    } else {\n+      // The desired container won\u0027t fit here, so reserve\n+      reserve(request.getPriority(), node, container, reserved);\n+\n+      return FairScheduler.CONTAINER_RESERVED;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource assignContainer(\n      FSSchedulerNode node, ResourceRequest request, NodeType type,\n      boolean reserved) {\n\n    // How much does this request need?\n    Resource capability \u003d request.getCapability();\n\n    // How much does the node have?\n    Resource available \u003d node.getAvailableResource();\n\n    Container container \u003d null;\n    if (reserved) {\n      container \u003d node.getReservedContainer().getContainer();\n    } else {\n      container \u003d createContainer(node, capability, request.getPriority());\n    }\n\n    // Can we allocate a container on this node?\n    if (Resources.fitsIn(capability, available)) {\n      // Inform the application of the new container for this request\n      RMContainer allocatedContainer \u003d\n          allocate(type, node, request.getPriority(), request, container);\n      if (allocatedContainer \u003d\u003d null) {\n        // Did the application need this resource?\n        if (reserved) {\n          unreserve(request.getPriority(), node);\n        }\n        return Resources.none();\n      }\n\n      // If we had previously made a reservation, delete it\n      if (reserved) {\n        unreserve(request.getPriority(), node);\n      }\n\n      // Inform the node\n      node.allocateContainer(allocatedContainer);\n\n      // If this container is used to run AM, update the leaf queue\u0027s AM usage\n      if (getLiveContainers().size() \u003d\u003d 1 \u0026\u0026 !getUnmanagedAM()) {\n        getQueue().addAMResourceUsage(container.getResource());\n        setAmRunning(true);\n      }\n\n      return container.getResource();\n    } else {\n      // The desired container won\u0027t fit here, so reserve\n      reserve(request.getPriority(), node, container, reserved);\n\n      return FairScheduler.CONTAINER_RESERVED;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java"
    }
  }
}