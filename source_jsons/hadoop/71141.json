{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Client.java",
  "functionName": "setupRemoteResource",
  "functionId": "setupRemoteResource___appId-ApplicationId__resource-DynoResource__env-Map__String,String____srcPaths-String",
  "sourceFilePath": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-infra/src/main/java/org/apache/hadoop/tools/dynamometer/Client.java",
  "functionStartLine": 738,
  "functionEndLine": 840,
  "numCommitsSeen": 7,
  "timeTaken": 576,
  "changeHistory": [
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91"
  ],
  "changeHistoryShort": {
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-12345 Add Dynamometer to hadoop-tools, a tool for scale testing the HDFS NameNode with real metadata and workloads. Contributed by Erik Krogen.\n",
      "commitDate": "25/06/19 8:07 AM",
      "commitName": "ab0b180ddb5d0775a2452d5eeb7badd252aadb91",
      "commitAuthor": "Erik Krogen",
      "diff": "@@ -0,0 +1,103 @@\n+  private void setupRemoteResource(ApplicationId appId, DynoResource resource,\n+      Map\u003cString, String\u003e env, String... srcPaths) throws IOException {\n+\n+    FileStatus remoteFileStatus;\n+    Path dstPath;\n+\n+    Preconditions.checkArgument(srcPaths.length \u003e 0,\n+        \"Must supply at least one source path\");\n+    Preconditions.checkArgument(\n+        resource.getType() \u003d\u003d LocalResourceType.ARCHIVE || srcPaths.length \u003d\u003d 1,\n+        \"Can only specify multiple source paths if using an ARCHIVE type\");\n+\n+    List\u003cURI\u003e srcURIs \u003d Arrays.stream(srcPaths).map(URI::create)\n+        .collect(Collectors.toList());\n+    Set\u003cString\u003e srcSchemes \u003d srcURIs.stream().map(URI::getScheme)\n+        .collect(Collectors.toSet());\n+    Preconditions.checkArgument(srcSchemes.size() \u003d\u003d 1,\n+        \"All source paths must have the same scheme\");\n+    String srcScheme \u003d srcSchemes.iterator().next();\n+\n+    String srcPathString \u003d \"[\" + Joiner.on(\",\").join(srcPaths) + \"]\";\n+\n+    if (srcScheme \u003d\u003d null\n+        || srcScheme.equals(FileSystem.getLocal(getConf()).getScheme())\n+        || srcScheme.equals(\"jar\")) {\n+      // Need to upload this resource to remote storage\n+      List\u003cFile\u003e srcFiles \u003d srcURIs.stream().map(URI::getSchemeSpecificPart)\n+          .map(File::new).collect(Collectors.toList());\n+      Path dstPathBase \u003d getRemoteStoragePath(getConf(), appId);\n+      boolean shouldArchive \u003d srcFiles.size() \u003e 1\n+          || srcFiles.get(0).isDirectory()\n+          || (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE\n+              \u0026\u0026 Arrays.stream(ARCHIVE_FILE_TYPES).noneMatch(\n+                  suffix -\u003e srcFiles.get(0).getName().endsWith(suffix)));\n+      if (shouldArchive) {\n+        if (\"jar\".equals(srcScheme)) {\n+          throw new IllegalArgumentException(String.format(\"Resources in JARs \"\n+                  + \"can\u0027t be zipped; resource %s is ARCHIVE and src is: %s\",\n+              resource.getResourcePath(), srcPathString));\n+        } else if (resource.getType() !\u003d LocalResourceType.ARCHIVE) {\n+          throw new IllegalArgumentException(\n+              String.format(\"Resource type is %s but srcPaths were: %s\",\n+                  resource.getType(), srcPathString));\n+        }\n+        dstPath \u003d new Path(dstPathBase, resource.getResourcePath())\n+            .suffix(\".zip\");\n+      } else {\n+        dstPath \u003d new Path(dstPathBase, srcFiles.get(0).getName());\n+      }\n+      FileSystem remoteFS \u003d dstPath.getFileSystem(getConf());\n+      LOG.info(\"Uploading resource \" + resource + \" from \" + srcPathString\n+          + \" to \" + dstPath);\n+      try (OutputStream outputStream \u003d remoteFS.create(dstPath, true)) {\n+        if (\"jar\".equals(srcScheme)) {\n+          try (InputStream inputStream \u003d new URL(srcPaths[0]).openStream()) {\n+            IOUtils.copyBytes(inputStream, outputStream, getConf());\n+          }\n+        } else if (shouldArchive) {\n+          List\u003cFile\u003e filesToZip;\n+          if (srcFiles.size() \u003d\u003d 1 \u0026\u0026 srcFiles.get(0).isDirectory()) {\n+            File[] childFiles \u003d srcFiles.get(0).listFiles();\n+            if (childFiles \u003d\u003d null || childFiles.length \u003d\u003d 0) {\n+              throw new IllegalArgumentException(\n+                  \"Specified a directory to archive with no contents\");\n+            }\n+            filesToZip \u003d Lists.newArrayList(childFiles);\n+          } else {\n+            filesToZip \u003d srcFiles;\n+          }\n+          ZipOutputStream zout \u003d new ZipOutputStream(outputStream);\n+          for (File fileToZip : filesToZip) {\n+            addFileToZipRecursively(fileToZip.getParentFile(), fileToZip, zout);\n+          }\n+          zout.close();\n+        } else {\n+          try (InputStream inputStream \u003d new FileInputStream(srcFiles.get(0))) {\n+            IOUtils.copyBytes(inputStream, outputStream, getConf());\n+          }\n+        }\n+      }\n+      remoteFileStatus \u003d remoteFS.getFileStatus(dstPath);\n+    } else {\n+      if (srcPaths.length \u003e 1) {\n+        throw new IllegalArgumentException(\"If resource is on remote, must be \"\n+            + \"a single file: \" + srcPathString);\n+      }\n+      LOG.info(\"Using resource {} directly from current location: {}\",\n+          resource, srcPaths[0]);\n+      dstPath \u003d new Path(srcPaths[0]);\n+      // non-local file system; we can just use it directly from where it is\n+      remoteFileStatus \u003d FileSystem.get(dstPath.toUri(), getConf())\n+          .getFileStatus(dstPath);\n+      if (remoteFileStatus.isDirectory()) {\n+        throw new IllegalArgumentException(\"If resource is on remote \"\n+            + \"filesystem, must be a file: \" + srcPaths[0]);\n+      }\n+    }\n+    env.put(resource.getLocationEnvVar(), dstPath.toString());\n+    env.put(resource.getTimestampEnvVar(),\n+        String.valueOf(remoteFileStatus.getModificationTime()));\n+    env.put(resource.getLengthEnvVar(),\n+        String.valueOf(remoteFileStatus.getLen()));\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupRemoteResource(ApplicationId appId, DynoResource resource,\n      Map\u003cString, String\u003e env, String... srcPaths) throws IOException {\n\n    FileStatus remoteFileStatus;\n    Path dstPath;\n\n    Preconditions.checkArgument(srcPaths.length \u003e 0,\n        \"Must supply at least one source path\");\n    Preconditions.checkArgument(\n        resource.getType() \u003d\u003d LocalResourceType.ARCHIVE || srcPaths.length \u003d\u003d 1,\n        \"Can only specify multiple source paths if using an ARCHIVE type\");\n\n    List\u003cURI\u003e srcURIs \u003d Arrays.stream(srcPaths).map(URI::create)\n        .collect(Collectors.toList());\n    Set\u003cString\u003e srcSchemes \u003d srcURIs.stream().map(URI::getScheme)\n        .collect(Collectors.toSet());\n    Preconditions.checkArgument(srcSchemes.size() \u003d\u003d 1,\n        \"All source paths must have the same scheme\");\n    String srcScheme \u003d srcSchemes.iterator().next();\n\n    String srcPathString \u003d \"[\" + Joiner.on(\",\").join(srcPaths) + \"]\";\n\n    if (srcScheme \u003d\u003d null\n        || srcScheme.equals(FileSystem.getLocal(getConf()).getScheme())\n        || srcScheme.equals(\"jar\")) {\n      // Need to upload this resource to remote storage\n      List\u003cFile\u003e srcFiles \u003d srcURIs.stream().map(URI::getSchemeSpecificPart)\n          .map(File::new).collect(Collectors.toList());\n      Path dstPathBase \u003d getRemoteStoragePath(getConf(), appId);\n      boolean shouldArchive \u003d srcFiles.size() \u003e 1\n          || srcFiles.get(0).isDirectory()\n          || (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE\n              \u0026\u0026 Arrays.stream(ARCHIVE_FILE_TYPES).noneMatch(\n                  suffix -\u003e srcFiles.get(0).getName().endsWith(suffix)));\n      if (shouldArchive) {\n        if (\"jar\".equals(srcScheme)) {\n          throw new IllegalArgumentException(String.format(\"Resources in JARs \"\n                  + \"can\u0027t be zipped; resource %s is ARCHIVE and src is: %s\",\n              resource.getResourcePath(), srcPathString));\n        } else if (resource.getType() !\u003d LocalResourceType.ARCHIVE) {\n          throw new IllegalArgumentException(\n              String.format(\"Resource type is %s but srcPaths were: %s\",\n                  resource.getType(), srcPathString));\n        }\n        dstPath \u003d new Path(dstPathBase, resource.getResourcePath())\n            .suffix(\".zip\");\n      } else {\n        dstPath \u003d new Path(dstPathBase, srcFiles.get(0).getName());\n      }\n      FileSystem remoteFS \u003d dstPath.getFileSystem(getConf());\n      LOG.info(\"Uploading resource \" + resource + \" from \" + srcPathString\n          + \" to \" + dstPath);\n      try (OutputStream outputStream \u003d remoteFS.create(dstPath, true)) {\n        if (\"jar\".equals(srcScheme)) {\n          try (InputStream inputStream \u003d new URL(srcPaths[0]).openStream()) {\n            IOUtils.copyBytes(inputStream, outputStream, getConf());\n          }\n        } else if (shouldArchive) {\n          List\u003cFile\u003e filesToZip;\n          if (srcFiles.size() \u003d\u003d 1 \u0026\u0026 srcFiles.get(0).isDirectory()) {\n            File[] childFiles \u003d srcFiles.get(0).listFiles();\n            if (childFiles \u003d\u003d null || childFiles.length \u003d\u003d 0) {\n              throw new IllegalArgumentException(\n                  \"Specified a directory to archive with no contents\");\n            }\n            filesToZip \u003d Lists.newArrayList(childFiles);\n          } else {\n            filesToZip \u003d srcFiles;\n          }\n          ZipOutputStream zout \u003d new ZipOutputStream(outputStream);\n          for (File fileToZip : filesToZip) {\n            addFileToZipRecursively(fileToZip.getParentFile(), fileToZip, zout);\n          }\n          zout.close();\n        } else {\n          try (InputStream inputStream \u003d new FileInputStream(srcFiles.get(0))) {\n            IOUtils.copyBytes(inputStream, outputStream, getConf());\n          }\n        }\n      }\n      remoteFileStatus \u003d remoteFS.getFileStatus(dstPath);\n    } else {\n      if (srcPaths.length \u003e 1) {\n        throw new IllegalArgumentException(\"If resource is on remote, must be \"\n            + \"a single file: \" + srcPathString);\n      }\n      LOG.info(\"Using resource {} directly from current location: {}\",\n          resource, srcPaths[0]);\n      dstPath \u003d new Path(srcPaths[0]);\n      // non-local file system; we can just use it directly from where it is\n      remoteFileStatus \u003d FileSystem.get(dstPath.toUri(), getConf())\n          .getFileStatus(dstPath);\n      if (remoteFileStatus.isDirectory()) {\n        throw new IllegalArgumentException(\"If resource is on remote \"\n            + \"filesystem, must be a file: \" + srcPaths[0]);\n      }\n    }\n    env.put(resource.getLocationEnvVar(), dstPath.toString());\n    env.put(resource.getTimestampEnvVar(),\n        String.valueOf(remoteFileStatus.getModificationTime()));\n    env.put(resource.getLengthEnvVar(),\n        String.valueOf(remoteFileStatus.getLen()));\n  }",
      "path": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-infra/src/main/java/org/apache/hadoop/tools/dynamometer/Client.java"
    }
  }
}