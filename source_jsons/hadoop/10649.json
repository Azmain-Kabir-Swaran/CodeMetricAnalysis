{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractFuture.java",
  "functionName": "cancel",
  "functionId": "cancel___mayInterruptIfRunning-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/checker/AbstractFuture.java",
  "functionStartLine": 114,
  "functionEndLine": 116,
  "numCommitsSeen": 4,
  "timeTaken": 766,
  "changeHistory": [
    "d69a82c89c1e857a2a86ff614ae11fb5df993614"
  ],
  "changeHistoryShort": {
    "d69a82c89c1e857a2a86ff614ae11fb5df993614": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d69a82c89c1e857a2a86ff614ae11fb5df993614": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-11511. Support Timeout when checking single disk. Contributed by Hanisha Koneru.\n",
      "commitDate": "15/03/17 6:01 PM",
      "commitName": "d69a82c89c1e857a2a86ff614ae11fb5df993614",
      "commitAuthor": "Hanisha Koneru",
      "diff": "@@ -0,0 +1,63 @@\n+  public boolean cancel(boolean mayInterruptIfRunning) {\n+    Object localValue \u003d value;\n+    boolean rValue \u003d false;\n+    if (localValue \u003d\u003d null | localValue instanceof SetFuture) {\n+      // Try to delay allocating the exception. At this point we may still\n+      // lose the CAS, but it is certainly less likely.\n+      Throwable cause \u003d\n+          GENERATE_CANCELLATION_CAUSES\n+              ? new CancellationException(\"Future.cancel() was called.\")\n+              : null;\n+      Object valueToSet \u003d new Cancellation(mayInterruptIfRunning, cause);\n+      AbstractFuture\u003c?\u003e abstractFuture \u003d this;\n+      while (true) {\n+        if (ATOMIC_HELPER.casValue(abstractFuture, localValue, valueToSet)) {\n+          rValue \u003d true;\n+          // We call interuptTask before calling complete(), which is\n+          // consistent with FutureTask\n+          if (mayInterruptIfRunning) {\n+            abstractFuture.interruptTask();\n+          }\n+          complete(abstractFuture);\n+          if (localValue instanceof SetFuture) {\n+            // propagate cancellation to the future set in setfuture, this is\n+            // racy, and we don\u0027t care if we are successful or not.\n+            ListenableFuture\u003c?\u003e futureToPropagateTo \u003d ((SetFuture) localValue)\n+                .future;\n+            if (futureToPropagateTo instanceof TrustedFuture) {\n+              // If the future is a TrustedFuture then we specifically avoid\n+              // calling cancel() this has 2 benefits\n+              // 1. for long chains of futures strung together with setFuture\n+              // we consume less stack\n+              // 2. we avoid allocating Cancellation objects at every level of\n+              // the cancellation chain\n+              // We can only do this for TrustedFuture, because\n+              // TrustedFuture.cancel is final and does nothing but delegate\n+              // to this method.\n+              AbstractFuture\u003c?\u003e trusted \u003d (AbstractFuture\u003c?\u003e)\n+                  futureToPropagateTo;\n+              localValue \u003d trusted.value;\n+              if (localValue \u003d\u003d null | localValue instanceof SetFuture) {\n+                abstractFuture \u003d trusted;\n+                continue;  // loop back up and try to complete the new future\n+              }\n+            } else {\n+              // not a TrustedFuture, call cancel directly.\n+              futureToPropagateTo.cancel(mayInterruptIfRunning);\n+            }\n+          }\n+          break;\n+        }\n+        // obj changed, reread\n+        localValue \u003d abstractFuture.value;\n+        if (!(localValue instanceof SetFuture)) {\n+          // obj cannot be null at this point, because value can only change\n+          // from null to non-null. So if value changed (and it did since we\n+          // lost the CAS), then it cannot be null and since it isn\u0027t a\n+          // SetFuture, then the future must be done and we should exit the loop\n+          break;\n+        }\n+      }\n+    }\n+    return rValue;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean cancel(boolean mayInterruptIfRunning) {\n    Object localValue \u003d value;\n    boolean rValue \u003d false;\n    if (localValue \u003d\u003d null | localValue instanceof SetFuture) {\n      // Try to delay allocating the exception. At this point we may still\n      // lose the CAS, but it is certainly less likely.\n      Throwable cause \u003d\n          GENERATE_CANCELLATION_CAUSES\n              ? new CancellationException(\"Future.cancel() was called.\")\n              : null;\n      Object valueToSet \u003d new Cancellation(mayInterruptIfRunning, cause);\n      AbstractFuture\u003c?\u003e abstractFuture \u003d this;\n      while (true) {\n        if (ATOMIC_HELPER.casValue(abstractFuture, localValue, valueToSet)) {\n          rValue \u003d true;\n          // We call interuptTask before calling complete(), which is\n          // consistent with FutureTask\n          if (mayInterruptIfRunning) {\n            abstractFuture.interruptTask();\n          }\n          complete(abstractFuture);\n          if (localValue instanceof SetFuture) {\n            // propagate cancellation to the future set in setfuture, this is\n            // racy, and we don\u0027t care if we are successful or not.\n            ListenableFuture\u003c?\u003e futureToPropagateTo \u003d ((SetFuture) localValue)\n                .future;\n            if (futureToPropagateTo instanceof TrustedFuture) {\n              // If the future is a TrustedFuture then we specifically avoid\n              // calling cancel() this has 2 benefits\n              // 1. for long chains of futures strung together with setFuture\n              // we consume less stack\n              // 2. we avoid allocating Cancellation objects at every level of\n              // the cancellation chain\n              // We can only do this for TrustedFuture, because\n              // TrustedFuture.cancel is final and does nothing but delegate\n              // to this method.\n              AbstractFuture\u003c?\u003e trusted \u003d (AbstractFuture\u003c?\u003e)\n                  futureToPropagateTo;\n              localValue \u003d trusted.value;\n              if (localValue \u003d\u003d null | localValue instanceof SetFuture) {\n                abstractFuture \u003d trusted;\n                continue;  // loop back up and try to complete the new future\n              }\n            } else {\n              // not a TrustedFuture, call cancel directly.\n              futureToPropagateTo.cancel(mayInterruptIfRunning);\n            }\n          }\n          break;\n        }\n        // obj changed, reread\n        localValue \u003d abstractFuture.value;\n        if (!(localValue instanceof SetFuture)) {\n          // obj cannot be null at this point, because value can only change\n          // from null to non-null. So if value changed (and it did since we\n          // lost the CAS), then it cannot be null and since it isn\u0027t a\n          // SetFuture, then the future must be done and we should exit the loop\n          break;\n        }\n      }\n    }\n    return rValue;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/checker/AbstractFuture.java"
    }
  }
}