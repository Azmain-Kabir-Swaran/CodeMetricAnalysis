{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AFileSystem.java",
  "functionName": "listStatus",
  "functionId": "listStatus___f-Path",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
  "functionStartLine": 2536,
  "functionEndLine": 2539,
  "numCommitsSeen": 141,
  "timeTaken": 5289,
  "changeHistory": [
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
    "39ec1515a205952eda7e171408a8b83eceb4abde",
    "27c4e90efce04e1b1302f668b5eb22412e00d033",
    "0ecdd4cffa51e34997321c384496efc249e3d8ff",
    "709ff99cff4124823bde631e272af7be9a22f83b",
    "6ba52d88ec11444cbac946ffadbc645acd0657de",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0"
  ],
  "changeHistoryShort": {
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Ybodychange",
    "39ec1515a205952eda7e171408a8b83eceb4abde": "Ybodychange",
    "27c4e90efce04e1b1302f668b5eb22412e00d033": "Ybodychange",
    "0ecdd4cffa51e34997321c384496efc249e3d8ff": "Ybodychange",
    "709ff99cff4124823bde631e272af7be9a22f83b": "Ybodychange",
    "6ba52d88ec11444cbac946ffadbc645acd0657de": "Ybodychange",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "25/09/17 3:59 PM",
      "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 57.69,
      "commitsBetweenForRepo": 477,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,8 +1,4 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n       IOException {\n-    try {\n-      return innerListStatus(f);\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"listStatus\", f, e);\n-    }\n+    return once(\"listStatus\", f.toString(), () -\u003e innerListStatus(f));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n      IOException {\n    return once(\"listStatus\", f.toString(), () -\u003e innerListStatus(f));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "39ec1515a205952eda7e171408a8b83eceb4abde": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
      "commitDate": "21/05/16 8:39 AM",
      "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/05/16 5:52 AM",
      "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,8 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n       IOException {\n-    String key \u003d pathToKey(f);\n-    LOG.debug(\"List status for path: {}\", f);\n-\n-    final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n-    final FileStatus fileStatus \u003d  getFileStatus(f);\n-\n-    if (fileStatus.isDirectory()) {\n-      if (!key.isEmpty()) {\n-        key \u003d key + \"/\";\n-      }\n-\n-      ListObjectsRequest request \u003d new ListObjectsRequest();\n-      request.setBucketName(bucket);\n-      request.setPrefix(key);\n-      request.setDelimiter(\"/\");\n-      request.setMaxKeys(maxKeys);\n-\n-      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n-\n-      ObjectListing objects \u003d s3.listObjects(request);\n-      statistics.incrementReadOps(1);\n-\n-      Path fQualified \u003d f.makeQualified(uri, workingDir);\n-\n-      while (true) {\n-        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n-          Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n-          // Skip over keys that are ourselves and old S3N _$folder$ files\n-          if (keyPath.equals(fQualified) ||\n-              summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n-            LOG.debug(\"Ignoring: {}\", keyPath);\n-            continue;\n-          }\n-\n-          if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n-            result.add(new S3AFileStatus(true, true, keyPath));\n-            LOG.debug(\"Adding: fd: {}\", keyPath);\n-          } else {\n-            result.add(new S3AFileStatus(summary.getSize(),\n-                dateToLong(summary.getLastModified()), keyPath,\n-                getDefaultBlockSize(fQualified)));\n-            LOG.debug(\"Adding: fi: {}\", keyPath);\n-          }\n-        }\n-\n-        for (String prefix : objects.getCommonPrefixes()) {\n-          Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n-          if (keyPath.equals(f)) {\n-            continue;\n-          }\n-          result.add(new S3AFileStatus(true, false, keyPath));\n-          LOG.debug(\"Adding: rd: {}\", keyPath);\n-        }\n-\n-        if (objects.isTruncated()) {\n-          LOG.debug(\"listStatus: list truncated - getting next batch\");\n-          objects \u003d s3.listNextBatchOfObjects(objects);\n-          statistics.incrementReadOps(1);\n-        } else {\n-          break;\n-        }\n-      }\n-    } else {\n-      LOG.debug(\"Adding: rd (not a dir): {}\", f);\n-      result.add(fileStatus);\n+    try {\n+      return innerListStatus(f);\n+    } catch (AmazonClientException e) {\n+      throw translateException(\"listStatus\", f, e);\n     }\n-\n-    return result.toArray(new FileStatus[result.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n      IOException {\n    try {\n      return innerListStatus(f);\n    } catch (AmazonClientException e) {\n      throw translateException(\"listStatus\", f, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "27c4e90efce04e1b1302f668b5eb22412e00d033": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
      "commitDate": "12/05/16 11:24 AM",
      "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/05/16 5:57 AM",
      "commitNameOld": "def2a6d3856452d5c804f04e5bf485541a3bc53a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,71 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n       IOException {\n     String key \u003d pathToKey(f);\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"List status for path: \" + f);\n-    }\n+    LOG.debug(\"List status for path: {}\", f);\n \n     final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n     final FileStatus fileStatus \u003d  getFileStatus(f);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \"/\";\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(maxKeys);\n \n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"listStatus: doing listObjects for directory \" + key);\n-      }\n+      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       Path fQualified \u003d f.makeQualified(uri, workingDir);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n           // Skip over keys that are ourselves and old S3N _$folder$ files\n           if (keyPath.equals(fQualified) ||\n               summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Ignoring: \" + keyPath);\n-            }\n+            LOG.debug(\"Ignoring: {}\", keyPath);\n             continue;\n           }\n \n           if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n             result.add(new S3AFileStatus(true, true, keyPath));\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Adding: fd: \" + keyPath);\n-            }\n+            LOG.debug(\"Adding: fd: {}\", keyPath);\n           } else {\n             result.add(new S3AFileStatus(summary.getSize(),\n                 dateToLong(summary.getLastModified()), keyPath,\n                 getDefaultBlockSize(fQualified)));\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Adding: fi: \" + keyPath);\n-            }\n+            LOG.debug(\"Adding: fi: {}\", keyPath);\n           }\n         }\n \n         for (String prefix : objects.getCommonPrefixes()) {\n           Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n           if (keyPath.equals(f)) {\n             continue;\n           }\n           result.add(new S3AFileStatus(true, false, keyPath));\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Adding: rd: \" + keyPath);\n-          }\n+          LOG.debug(\"Adding: rd: {}\", keyPath);\n         }\n \n         if (objects.isTruncated()) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"listStatus: list truncated - getting next batch\");\n-          }\n-\n+          LOG.debug(\"listStatus: list truncated - getting next batch\");\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           break;\n         }\n       }\n     } else {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Adding: rd (not a dir): \" + f);\n-      }\n+      LOG.debug(\"Adding: rd (not a dir): {}\", f);\n       result.add(fileStatus);\n     }\n \n     return result.toArray(new FileStatus[result.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n      IOException {\n    String key \u003d pathToKey(f);\n    LOG.debug(\"List status for path: {}\", f);\n\n    final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n    final FileStatus fileStatus \u003d  getFileStatus(f);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \"/\";\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(maxKeys);\n\n      LOG.debug(\"listStatus: doing listObjects for directory {}\", key);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      Path fQualified \u003d f.makeQualified(uri, workingDir);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n          // Skip over keys that are ourselves and old S3N _$folder$ files\n          if (keyPath.equals(fQualified) ||\n              summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n            LOG.debug(\"Ignoring: {}\", keyPath);\n            continue;\n          }\n\n          if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n            result.add(new S3AFileStatus(true, true, keyPath));\n            LOG.debug(\"Adding: fd: {}\", keyPath);\n          } else {\n            result.add(new S3AFileStatus(summary.getSize(),\n                dateToLong(summary.getLastModified()), keyPath,\n                getDefaultBlockSize(fQualified)));\n            LOG.debug(\"Adding: fi: {}\", keyPath);\n          }\n        }\n\n        for (String prefix : objects.getCommonPrefixes()) {\n          Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n          if (keyPath.equals(f)) {\n            continue;\n          }\n          result.add(new S3AFileStatus(true, false, keyPath));\n          LOG.debug(\"Adding: rd: {}\", keyPath);\n        }\n\n        if (objects.isTruncated()) {\n          LOG.debug(\"listStatus: list truncated - getting next batch\");\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          break;\n        }\n      }\n    } else {\n      LOG.debug(\"Adding: rd (not a dir): {}\", f);\n      result.add(fileStatus);\n    }\n\n    return result.toArray(new FileStatus[result.size()]);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "0ecdd4cffa51e34997321c384496efc249e3d8ff": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12169 ListStatus on empty dir in S3A lists itself instead of returning an empty list. author: Pieter Reuse.\n",
      "commitDate": "03/04/16 8:40 AM",
      "commitName": "0ecdd4cffa51e34997321c384496efc249e3d8ff",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "01/04/16 1:48 AM",
      "commitNameOld": "256c82fe2981748cd0befc5490d8118d139908f9",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 2.29,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,88 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n       IOException {\n     String key \u003d pathToKey(f);\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"List status for path: \" + f);\n     }\n \n     final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n     final FileStatus fileStatus \u003d  getFileStatus(f);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \"/\";\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(maxKeys);\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"listStatus: doing listObjects for directory \" + key);\n       }\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n+      Path fQualified \u003d f.makeQualified(uri, workingDir);\n+\n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n           // Skip over keys that are ourselves and old S3N _$folder$ files\n-          if (keyPath.equals(f) || summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n+          if (keyPath.equals(fQualified) ||\n+              summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Ignoring: \" + keyPath);\n             }\n             continue;\n           }\n \n           if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n             result.add(new S3AFileStatus(true, true, keyPath));\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Adding: fd: \" + keyPath);\n             }\n           } else {\n             result.add(new S3AFileStatus(summary.getSize(),\n                 dateToLong(summary.getLastModified()), keyPath,\n-                getDefaultBlockSize(f.makeQualified(uri, workingDir))));\n+                getDefaultBlockSize(fQualified)));\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Adding: fi: \" + keyPath);\n             }\n           }\n         }\n \n         for (String prefix : objects.getCommonPrefixes()) {\n           Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n           if (keyPath.equals(f)) {\n             continue;\n           }\n           result.add(new S3AFileStatus(true, false, keyPath));\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Adding: rd: \" + keyPath);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"listStatus: list truncated - getting next batch\");\n           }\n \n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           break;\n         }\n       }\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Adding: rd (not a dir): \" + f);\n       }\n       result.add(fileStatus);\n     }\n \n     return result.toArray(new FileStatus[result.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n      IOException {\n    String key \u003d pathToKey(f);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"List status for path: \" + f);\n    }\n\n    final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n    final FileStatus fileStatus \u003d  getFileStatus(f);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \"/\";\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(maxKeys);\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"listStatus: doing listObjects for directory \" + key);\n      }\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      Path fQualified \u003d f.makeQualified(uri, workingDir);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n          // Skip over keys that are ourselves and old S3N _$folder$ files\n          if (keyPath.equals(fQualified) ||\n              summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Ignoring: \" + keyPath);\n            }\n            continue;\n          }\n\n          if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n            result.add(new S3AFileStatus(true, true, keyPath));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Adding: fd: \" + keyPath);\n            }\n          } else {\n            result.add(new S3AFileStatus(summary.getSize(),\n                dateToLong(summary.getLastModified()), keyPath,\n                getDefaultBlockSize(fQualified)));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Adding: fi: \" + keyPath);\n            }\n          }\n        }\n\n        for (String prefix : objects.getCommonPrefixes()) {\n          Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n          if (keyPath.equals(f)) {\n            continue;\n          }\n          result.add(new S3AFileStatus(true, false, keyPath));\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding: rd: \" + keyPath);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"listStatus: list truncated - getting next batch\");\n          }\n\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          break;\n        }\n      }\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Adding: rd (not a dir): \" + f);\n      }\n      result.add(fileStatus);\n    }\n\n    return result.toArray(new FileStatus[result.size()]);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "709ff99cff4124823bde631e272af7be9a22f83b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11584 s3a file block size set to 0 in getFileStatus. (Brahma Reddy Battula via stevel)\n",
      "commitDate": "21/02/15 4:03 AM",
      "commitName": "709ff99cff4124823bde631e272af7be9a22f83b",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/02/15 12:51 PM",
      "commitNameOld": "aa1c437b6a806de612f030a68984c606c623f1d9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.63,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,85 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n       IOException {\n     String key \u003d pathToKey(f);\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"List status for path: \" + f);\n     }\n \n     final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n     final FileStatus fileStatus \u003d  getFileStatus(f);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \"/\";\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(maxKeys);\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"listStatus: doing listObjects for directory \" + key);\n       }\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n           // Skip over keys that are ourselves and old S3N _$folder$ files\n           if (keyPath.equals(f) || summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Ignoring: \" + keyPath);\n             }\n             continue;\n           }\n \n           if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n             result.add(new S3AFileStatus(true, true, keyPath));\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Adding: fd: \" + keyPath);\n             }\n           } else {\n             result.add(new S3AFileStatus(summary.getSize(), \n-              dateToLong(summary.getLastModified()), keyPath));\n+                dateToLong(summary.getLastModified()), keyPath,\n+                getDefaultBlockSize(f.makeQualified(uri, workingDir))));\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Adding: fi: \" + keyPath);\n             }\n           }\n         }\n \n         for (String prefix : objects.getCommonPrefixes()) {\n           Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n           if (keyPath.equals(f)) {\n             continue;\n           }\n           result.add(new S3AFileStatus(true, false, keyPath));\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Adding: rd: \" + keyPath);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"listStatus: list truncated - getting next batch\");\n           }\n \n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           break;\n         }\n       }\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Adding: rd (not a dir): \" + f);\n       }\n       result.add(fileStatus);\n     }\n \n     return result.toArray(new FileStatus[result.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n      IOException {\n    String key \u003d pathToKey(f);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"List status for path: \" + f);\n    }\n\n    final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n    final FileStatus fileStatus \u003d  getFileStatus(f);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \"/\";\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(maxKeys);\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"listStatus: doing listObjects for directory \" + key);\n      }\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n          // Skip over keys that are ourselves and old S3N _$folder$ files\n          if (keyPath.equals(f) || summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Ignoring: \" + keyPath);\n            }\n            continue;\n          }\n\n          if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n            result.add(new S3AFileStatus(true, true, keyPath));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Adding: fd: \" + keyPath);\n            }\n          } else {\n            result.add(new S3AFileStatus(summary.getSize(), \n                dateToLong(summary.getLastModified()), keyPath,\n                getDefaultBlockSize(f.makeQualified(uri, workingDir))));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Adding: fi: \" + keyPath);\n            }\n          }\n        }\n\n        for (String prefix : objects.getCommonPrefixes()) {\n          Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n          if (keyPath.equals(f)) {\n            continue;\n          }\n          result.add(new S3AFileStatus(true, false, keyPath));\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding: rd: \" + keyPath);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"listStatus: list truncated - getting next batch\");\n          }\n\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          break;\n        }\n      }\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Adding: rd (not a dir): \" + f);\n      }\n      result.add(fileStatus);\n    }\n\n    return result.toArray(new FileStatus[result.size()]);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "6ba52d88ec11444cbac946ffadbc645acd0657de": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10714. AmazonS3Client.deleteObjects() need to be limited to 1000 entries per call. Contributed by Juan Yu.\n",
      "commitDate": "05/11/14 5:17 PM",
      "commitName": "6ba52d88ec11444cbac946ffadbc645acd0657de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "15/09/14 4:49 PM",
      "commitNameOld": "0ac760a58d96b36ab30e9d60679bbea6365ef120",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 51.06,
      "commitsBetweenForRepo": 536,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,84 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n       IOException {\n     String key \u003d pathToKey(f);\n-    LOG.info(\"List status for path: \" + f);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"List status for path: \" + f);\n+    }\n \n     final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n     final FileStatus fileStatus \u003d  getFileStatus(f);\n \n     if (fileStatus.isDirectory()) {\n       if (!key.isEmpty()) {\n         key \u003d key + \"/\";\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(key);\n       request.setDelimiter(\"/\");\n       request.setMaxKeys(maxKeys);\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"listStatus: doing listObjects for directory \" + key);\n       }\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n           // Skip over keys that are ourselves and old S3N _$folder$ files\n           if (keyPath.equals(f) || summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Ignoring: \" + keyPath);\n             }\n             continue;\n           }\n \n           if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n             result.add(new S3AFileStatus(true, true, keyPath));\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Adding: fd: \" + keyPath);\n             }\n           } else {\n             result.add(new S3AFileStatus(summary.getSize(), \n               dateToLong(summary.getLastModified()), keyPath));\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Adding: fi: \" + keyPath);\n             }\n           }\n         }\n \n         for (String prefix : objects.getCommonPrefixes()) {\n           Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n           if (keyPath.equals(f)) {\n             continue;\n           }\n           result.add(new S3AFileStatus(true, false, keyPath));\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Adding: rd: \" + keyPath);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"listStatus: list truncated - getting next batch\");\n           }\n \n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           break;\n         }\n       }\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Adding: rd (not a dir): \" + f);\n       }\n       result.add(fileStatus);\n     }\n \n     return result.toArray(new FileStatus[result.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n      IOException {\n    String key \u003d pathToKey(f);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"List status for path: \" + f);\n    }\n\n    final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n    final FileStatus fileStatus \u003d  getFileStatus(f);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \"/\";\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(maxKeys);\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"listStatus: doing listObjects for directory \" + key);\n      }\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n          // Skip over keys that are ourselves and old S3N _$folder$ files\n          if (keyPath.equals(f) || summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Ignoring: \" + keyPath);\n            }\n            continue;\n          }\n\n          if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n            result.add(new S3AFileStatus(true, true, keyPath));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Adding: fd: \" + keyPath);\n            }\n          } else {\n            result.add(new S3AFileStatus(summary.getSize(), \n              dateToLong(summary.getLastModified()), keyPath));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Adding: fi: \" + keyPath);\n            }\n          }\n        }\n\n        for (String prefix : objects.getCommonPrefixes()) {\n          Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n          if (keyPath.equals(f)) {\n            continue;\n          }\n          result.add(new S3AFileStatus(true, false, keyPath));\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding: rd: \" + keyPath);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"listStatus: list truncated - getting next batch\");\n          }\n\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          break;\n        }\n      }\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Adding: rd (not a dir): \" + f);\n      }\n      result.add(fileStatus);\n    }\n\n    return result.toArray(new FileStatus[result.size()]);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10400. Incorporate new S3A FileSystem implementation. Contributed by Jordan Mendelson and Dave Wang.\n",
      "commitDate": "15/09/14 8:27 AM",
      "commitName": "24d920b80eb3626073925a1d0b6dcf148add8cc0",
      "commitAuthor": "Aaron T. Myers",
      "diff": "@@ -0,0 +1,82 @@\n+  public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n+      IOException {\n+    String key \u003d pathToKey(f);\n+    LOG.info(\"List status for path: \" + f);\n+\n+    final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n+    final FileStatus fileStatus \u003d  getFileStatus(f);\n+\n+    if (fileStatus.isDirectory()) {\n+      if (!key.isEmpty()) {\n+        key \u003d key + \"/\";\n+      }\n+\n+      ListObjectsRequest request \u003d new ListObjectsRequest();\n+      request.setBucketName(bucket);\n+      request.setPrefix(key);\n+      request.setDelimiter(\"/\");\n+      request.setMaxKeys(maxKeys);\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"listStatus: doing listObjects for directory \" + key);\n+      }\n+\n+      ObjectListing objects \u003d s3.listObjects(request);\n+      statistics.incrementReadOps(1);\n+\n+      while (true) {\n+        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n+          Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n+          // Skip over keys that are ourselves and old S3N _$folder$ files\n+          if (keyPath.equals(f) || summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Ignoring: \" + keyPath);\n+            }\n+            continue;\n+          }\n+\n+          if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n+            result.add(new S3AFileStatus(true, true, keyPath));\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Adding: fd: \" + keyPath);\n+            }\n+          } else {\n+            result.add(new S3AFileStatus(summary.getSize(), \n+              dateToLong(summary.getLastModified()), keyPath));\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Adding: fi: \" + keyPath);\n+            }\n+          }\n+        }\n+\n+        for (String prefix : objects.getCommonPrefixes()) {\n+          Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n+          if (keyPath.equals(f)) {\n+            continue;\n+          }\n+          result.add(new S3AFileStatus(true, false, keyPath));\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Adding: rd: \" + keyPath);\n+          }\n+        }\n+\n+        if (objects.isTruncated()) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"listStatus: list truncated - getting next batch\");\n+          }\n+\n+          objects \u003d s3.listNextBatchOfObjects(objects);\n+          statistics.incrementReadOps(1);\n+        } else {\n+          break;\n+        }\n+      }\n+    } else {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Adding: rd (not a dir): \" + f);\n+      }\n+      result.add(fileStatus);\n+    }\n+\n+    return result.toArray(new FileStatus[result.size()]);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException,\n      IOException {\n    String key \u003d pathToKey(f);\n    LOG.info(\"List status for path: \" + f);\n\n    final List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n    final FileStatus fileStatus \u003d  getFileStatus(f);\n\n    if (fileStatus.isDirectory()) {\n      if (!key.isEmpty()) {\n        key \u003d key + \"/\";\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(key);\n      request.setDelimiter(\"/\");\n      request.setMaxKeys(maxKeys);\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"listStatus: doing listObjects for directory \" + key);\n      }\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          Path keyPath \u003d keyToPath(summary.getKey()).makeQualified(uri, workingDir);\n          // Skip over keys that are ourselves and old S3N _$folder$ files\n          if (keyPath.equals(f) || summary.getKey().endsWith(S3N_FOLDER_SUFFIX)) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Ignoring: \" + keyPath);\n            }\n            continue;\n          }\n\n          if (objectRepresentsDirectory(summary.getKey(), summary.getSize())) {\n            result.add(new S3AFileStatus(true, true, keyPath));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Adding: fd: \" + keyPath);\n            }\n          } else {\n            result.add(new S3AFileStatus(summary.getSize(), \n              dateToLong(summary.getLastModified()), keyPath));\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Adding: fi: \" + keyPath);\n            }\n          }\n        }\n\n        for (String prefix : objects.getCommonPrefixes()) {\n          Path keyPath \u003d keyToPath(prefix).makeQualified(uri, workingDir);\n          if (keyPath.equals(f)) {\n            continue;\n          }\n          result.add(new S3AFileStatus(true, false, keyPath));\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding: rd: \" + keyPath);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"listStatus: list truncated - getting next batch\");\n          }\n\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          break;\n        }\n      }\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Adding: rd (not a dir): \" + f);\n      }\n      result.add(fileStatus);\n    }\n\n    return result.toArray(new FileStatus[result.size()]);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java"
    }
  }
}