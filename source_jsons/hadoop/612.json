{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockReaderFactory.java",
  "functionName": "getBlockReaderLocal",
  "functionId": "getBlockReaderLocal",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
  "functionStartLine": 467,
  "functionEndLine": 505,
  "numCommitsSeen": 63,
  "timeTaken": 6522,
  "changeHistory": [
    "2abcf7762ae74b936e1cedb60d5d2b4cc4ee86ea",
    "4525292d41482330a86f1cc3935e072f9f67c308",
    "86e6aa8eec538e142044e2b6415ec1caff5e9cbd",
    "5d748bd056a32f2c6922514cd0c5b31d866a9919",
    "b061215ecfebe476bf58f70788113d1af816f553",
    "f308561f1d885491b88db73ac63003202056d661",
    "39285e6a1978ea5e53bdc1b0aef62421382124a8",
    "6ee0539ede78b640f01c5eac18ded161182a7835",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
    "892ade689f9bcce76daae8f66fc00a49bee8548e",
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
    "2cc9514ad643ae49d30524743420ee9744e571bd",
    "ed72daa5df97669906234e8ac9a406d78136b206",
    "463aec11718e47d4aabb86a7a539cb973460aae6",
    "225569ece229cec32f852f831fd337a139c44b1e",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
    "f0d64a078da7e932b9509734f75170e3e525e68c",
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be"
  ],
  "changeHistoryShort": {
    "2abcf7762ae74b936e1cedb60d5d2b4cc4ee86ea": "Ybodychange",
    "4525292d41482330a86f1cc3935e072f9f67c308": "Ybodychange",
    "86e6aa8eec538e142044e2b6415ec1caff5e9cbd": "Ybodychange",
    "5d748bd056a32f2c6922514cd0c5b31d866a9919": "Ybodychange",
    "b061215ecfebe476bf58f70788113d1af816f553": "Yexceptionschange",
    "f308561f1d885491b88db73ac63003202056d661": "Yfilerename",
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": "Ybodychange",
    "6ee0539ede78b640f01c5eac18ded161182a7835": "Ybodychange",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": "Ybodychange",
    "892ade689f9bcce76daae8f66fc00a49bee8548e": "Ybodychange",
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c": "Yfilerename",
    "2cc9514ad643ae49d30524743420ee9744e571bd": "Ybodychange",
    "ed72daa5df97669906234e8ac9a406d78136b206": "Ybodychange",
    "463aec11718e47d4aabb86a7a539cb973460aae6": "Ybodychange",
    "225569ece229cec32f852f831fd337a139c44b1e": "Ybodychange",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": "Ybodychange",
    "f0d64a078da7e932b9509734f75170e3e525e68c": "Ybodychange",
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2abcf7762ae74b936e1cedb60d5d2b4cc4ee86ea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15202 Boost short circuit cache (rebase PR-1884) (#2016)\n",
      "commitDate": "18/05/20 9:23 AM",
      "commitName": "2abcf7762ae74b936e1cedb60d5d2b4cc4ee86ea",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "18/05/20 9:22 AM",
      "commitNameOld": "4525292d41482330a86f1cc3935e072f9f67c308",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,39 @@\n   private BlockReader getBlockReaderLocal() throws IOException {\n     LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n         + \" reads.\", this);\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory()\n           .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n               \"giving up on BlockReaderLocal.\", this, pathInfo);\n       return null;\n     }\n-    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n+    ShortCircuitCache cache \u003d\n+        clientContext.getShortCircuitCache(block.getBlockId());\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(),\n         block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n           + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n           \"ShortCircuitReplica. Cannot construct \" +\n           \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         setStorageType(storageType).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws IOException {\n    LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n        + \" reads.\", this);\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d\n        clientContext.getShortCircuitCache(block.getBlockId());\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(),\n        block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n          + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "4525292d41482330a86f1cc3935e072f9f67c308": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-15202 Boost short circuit cache (rebase PR-1884) (#2016)\"\n\nThis reverts commit 86e6aa8eec538e142044e2b6415ec1caff5e9cbd.\n",
      "commitDate": "18/05/20 9:22 AM",
      "commitName": "4525292d41482330a86f1cc3935e072f9f67c308",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "18/05/20 7:04 AM",
      "commitNameOld": "86e6aa8eec538e142044e2b6415ec1caff5e9cbd",
      "commitAuthorOld": "pustota2009",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,38 @@\n   private BlockReader getBlockReaderLocal() throws IOException {\n     LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n         + \" reads.\", this);\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory()\n           .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n               \"giving up on BlockReaderLocal.\", this, pathInfo);\n       return null;\n     }\n-    ShortCircuitCache cache \u003d\n-        clientContext.getShortCircuitCache(block.getBlockId());\n+    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(),\n         block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n           + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n           \"ShortCircuitReplica. Cannot construct \" +\n           \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         setStorageType(storageType).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws IOException {\n    LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n        + \" reads.\", this);\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(),\n        block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n          + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "86e6aa8eec538e142044e2b6415ec1caff5e9cbd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15202 Boost short circuit cache (rebase PR-1884) (#2016)\n\nAdded parameter dfs.client.short.circuit.num improving HDFS-client\u0027s massive reading performance by create few instances ShortCircuit caches instead of one. It helps avoid locks and lets CPU do job.",
      "commitDate": "18/05/20 7:04 AM",
      "commitName": "86e6aa8eec538e142044e2b6415ec1caff5e9cbd",
      "commitAuthor": "pustota2009",
      "commitDateOld": "09/05/20 11:13 PM",
      "commitNameOld": "aab9e0b16ecc8fa00228c00c7ab90e55195cf5f4",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 8.33,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,39 @@\n   private BlockReader getBlockReaderLocal() throws IOException {\n     LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n         + \" reads.\", this);\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory()\n           .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n               \"giving up on BlockReaderLocal.\", this, pathInfo);\n       return null;\n     }\n-    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n+    ShortCircuitCache cache \u003d\n+        clientContext.getShortCircuitCache(block.getBlockId());\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(),\n         block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n           + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n           \"ShortCircuitReplica. Cannot construct \" +\n           \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         setStorageType(storageType).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws IOException {\n    LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n        + \" reads.\", this);\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d\n        clientContext.getShortCircuitCache(block.getBlockId());\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(),\n        block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n          + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "5d748bd056a32f2c6922514cd0c5b31d866a9919": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13702. Remove HTrace hooks from DFSClient to reduce CPU usage. Contributed by Todd Lipcon.\n",
      "commitDate": "02/07/18 3:11 AM",
      "commitName": "5d748bd056a32f2c6922514cd0c5b31d866a9919",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "18/06/18 10:17 AM",
      "commitNameOld": "fba9d7cd746cd7b659d2fd9d2bfa23266be9009b",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 13.7,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,38 @@\n   private BlockReader getBlockReaderLocal() throws IOException {\n     LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n         + \" reads.\", this);\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory()\n           .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n               \"giving up on BlockReaderLocal.\", this, pathInfo);\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(),\n         block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n           + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n           \"ShortCircuitReplica. Cannot construct \" +\n           \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         setStorageType(storageType).\n-        setTracer(tracer).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws IOException {\n    LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n        + \" reads.\", this);\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(),\n        block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n          + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "b061215ecfebe476bf58f70788113d1af816f553": {
      "type": "Yexceptionschange",
      "commitMessage": "HDFS-11701. NPE from Unresolved Host causes permanent DFSInputStream failures. Contributed by Lokesh Jain.\n",
      "commitDate": "07/02/18 11:22 AM",
      "commitName": "b061215ecfebe476bf58f70788113d1af816f553",
      "commitAuthor": "Jitendra Pandey",
      "commitDateOld": "30/01/18 3:25 PM",
      "commitNameOld": "2e7331ca264dd366b975f3c8e610cf84eb8cc155",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 7.83,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n-  private BlockReader getBlockReaderLocal() throws InvalidToken {\n+  private BlockReader getBlockReaderLocal() throws IOException {\n     LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n         + \" reads.\", this);\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory()\n           .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n               \"giving up on BlockReaderLocal.\", this, pathInfo);\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(),\n         block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n           + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n           \"ShortCircuitReplica. Cannot construct \" +\n           \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         setStorageType(storageType).\n         setTracer(tracer).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws IOException {\n    LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n        + \" reads.\", this);\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(),\n        block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n          + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        setTracer(tracer).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {
        "oldValue": "[InvalidToken]",
        "newValue": "[IOException]"
      }
    },
    "f308561f1d885491b88db73ac63003202056d661": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8057 Move BlockReader implementation to the client implementation package.  Contributed by Takanobu Asanuma\n",
      "commitDate": "25/04/16 12:01 PM",
      "commitName": "f308561f1d885491b88db73ac63003202056d661",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "25/04/16 9:38 AM",
      "commitNameOld": "10f0f7851a3255caab775777e8fb6c2781d97062",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n        + \" reads.\", this);\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(),\n        block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n          + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        setTracer(tracer).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java"
      }
    },
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8971. Remove guards when calling LOG.debug() and LOG.trace() in client package. Contributed by Mingliang Liu.\n",
      "commitDate": "29/09/15 5:52 PM",
      "commitName": "39285e6a1978ea5e53bdc1b0aef62421382124a8",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:51 PM",
      "commitNameOld": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,38 @@\n   private BlockReader getBlockReaderLocal() throws InvalidToken {\n-    if (LOG.isTraceEnabled()) {\n-      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n-          \"for short-circuit reads.\");\n-    }\n+    LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n+        + \" reads.\", this);\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory()\n           .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n               \"giving up on BlockReaderLocal.\", this, pathInfo);\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n-      if (LOG.isTraceEnabled()) {\n-        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n-            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n-      }\n+      LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n+          + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n           \"ShortCircuitReplica. Cannot construct \" +\n           \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         setStorageType(storageType).\n         setTracer(tracer).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n        + \" reads.\", this);\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n          + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        setTracer(tracer).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "6ee0539ede78b640f01c5eac18ded161182a7835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\"\n\nThis reverts commit d5a9a3daa0224249221ffa7b8bd5751ab2feca56.\n",
      "commitDate": "29/09/15 5:51 PM",
      "commitName": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:48 PM",
      "commitNameOld": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,42 @@\n   private BlockReader getBlockReaderLocal() throws InvalidToken {\n-    LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n-        + \" reads.\", this);\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n+          \"for short-circuit reads.\");\n+    }\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory()\n           .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n               \"giving up on BlockReaderLocal.\", this, pathInfo);\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n-      LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n-          + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n+            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n+      }\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n           \"ShortCircuitReplica. Cannot construct \" +\n           \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         setStorageType(storageType).\n         setTracer(tracer).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n          \"for short-circuit reads.\");\n    }\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        setTracer(tracer).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\n",
      "commitDate": "29/09/15 5:48 PM",
      "commitName": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "28/09/15 1:39 PM",
      "commitNameOld": "e5992ef4df63fbc6a6b8e357b32c647e7837c662",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,38 @@\n   private BlockReader getBlockReaderLocal() throws InvalidToken {\n-    if (LOG.isTraceEnabled()) {\n-      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n-          \"for short-circuit reads.\");\n-    }\n+    LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n+        + \" reads.\", this);\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory()\n           .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n               \"giving up on BlockReaderLocal.\", this, pathInfo);\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n-      if (LOG.isTraceEnabled()) {\n-        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n-            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n-      }\n+      LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n+          + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n           \"ShortCircuitReplica. Cannot construct \" +\n           \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         setStorageType(storageType).\n         setTracer(tracer).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    LOG.trace(\"{}: trying to construct a BlockReaderLocal for short-circuit \"\n        + \" reads.\", this);\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      LOG.trace(\"{}: got InvalidToken exception while trying to construct \"\n          + \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        setTracer(tracer).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "892ade689f9bcce76daae8f66fc00a49bee8548e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9080. Update htrace version to 4.0.1 (cmccabe)\n",
      "commitDate": "28/09/15 7:42 AM",
      "commitName": "892ade689f9bcce76daae8f66fc00a49bee8548e",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "26/09/15 11:08 AM",
      "commitNameOld": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.86,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,42 @@\n   private BlockReader getBlockReaderLocal() throws InvalidToken {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n           \"for short-circuit reads.\");\n     }\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory()\n           .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n               \"giving up on BlockReaderLocal.\", this, pathInfo);\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": got InvalidToken exception while trying to \" +\n             \"construct BlockReaderLocal via \" + pathInfo.getPath());\n       }\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n           \"ShortCircuitReplica. Cannot construct \" +\n           \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         setStorageType(storageType).\n+        setTracer(tracer).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n          \"for short-circuit reads.\");\n    }\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        setTracer(tracer).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8053. Move DFSIn/OutputStream and related classes to hadoop-hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "26/09/15 11:08 AM",
      "commitName": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "26/09/15 9:06 AM",
      "commitNameOld": "861b52db242f238d7e36ad75c158025be959a696",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n          \"for short-circuit reads.\");\n    }\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java"
      }
    },
    "2cc9514ad643ae49d30524743420ee9744e571bd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8100. Refactor DFSClient.Conf to a standalone class and separates short-circuit related conf to ShortCircuitConf.\n",
      "commitDate": "10/04/15 2:48 PM",
      "commitName": "2cc9514ad643ae49d30524743420ee9744e571bd",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "01/04/15 12:54 PM",
      "commitNameOld": "ed72daa5df97669906234e8ac9a406d78136b206",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 9.08,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private BlockReader getBlockReaderLocal() throws InvalidToken {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n           \"for short-circuit reads.\");\n     }\n     if (pathInfo \u003d\u003d null) {\n-      pathInfo \u003d clientContext.getDomainSocketFactory().\n-                      getPathInfo(inetSocketAddress, conf);\n+      pathInfo \u003d clientContext.getDomainSocketFactory()\n+          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n               \"giving up on BlockReaderLocal.\", this, pathInfo);\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": got InvalidToken exception while trying to \" +\n             \"construct BlockReaderLocal via \" + pathInfo.getPath());\n       }\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n           \"ShortCircuitReplica. Cannot construct \" +\n           \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       return null;\n     }\n-    return new BlockReaderLocal.Builder(conf).\n+    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         setStorageType(storageType).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n          \"for short-circuit reads.\");\n    }\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory()\n          .getPathInfo(inetSocketAddress, conf.getShortCircuitConf());\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf.getShortCircuitConf()).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "ed72daa5df97669906234e8ac9a406d78136b206": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7978. Add LOG.isDebugEnabled() guard for some LOG.debug(..). Contributed by Walter Su.\n",
      "commitDate": "01/04/15 12:54 PM",
      "commitName": "ed72daa5df97669906234e8ac9a406d78136b206",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "14/03/15 10:36 PM",
      "commitNameOld": "bc9cb3e271b22069a15ca110cd60c860250aaab2",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 17.6,
      "commitsBetweenForRepo": 175,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,41 @@\n   private BlockReader getBlockReaderLocal() throws InvalidToken {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n           \"for short-circuit reads.\");\n     }\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory().\n                       getPathInfo(inetSocketAddress, conf);\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n-      PerformanceAdvisory.LOG.debug(this + \": \" + pathInfo + \" is not \" +\n-          \"usable for short circuit; giving up on BlockReaderLocal.\");\n+      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n+              \"giving up on BlockReaderLocal.\", this, pathInfo);\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": got InvalidToken exception while trying to \" +\n             \"construct BlockReaderLocal via \" + pathInfo.getPath());\n       }\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n-      if (LOG.isTraceEnabled()) {\n-        PerformanceAdvisory.LOG.debug(this + \": failed to get \" +\n-            \"ShortCircuitReplica. Cannot construct \" +\n-            \"BlockReaderLocal via \" + pathInfo.getPath());\n-      }\n+      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n+          \"ShortCircuitReplica. Cannot construct \" +\n+          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         setStorageType(storageType).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n          \"for short-circuit reads.\");\n    }\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory().\n                      getPathInfo(inetSocketAddress, conf);\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(\"{}: {} is not usable for short circuit; \" +\n              \"giving up on BlockReaderLocal.\", this, pathInfo);\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      PerformanceAdvisory.LOG.debug(\"{}: failed to get \" +\n          \"ShortCircuitReplica. Cannot construct \" +\n          \"BlockReaderLocal via {}\", this, pathInfo.getPath());\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "463aec11718e47d4aabb86a7a539cb973460aae6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6934. Move checksum computation off the hot path when writing to RAM disk. Contributed by Chris Nauroth.\n",
      "commitDate": "27/10/14 9:38 AM",
      "commitName": "463aec11718e47d4aabb86a7a539cb973460aae6",
      "commitAuthor": "cnauroth",
      "commitDateOld": "27/08/14 1:39 PM",
      "commitNameOld": "225569ece229cec32f852f831fd337a139c44b1e",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 60.83,
      "commitsBetweenForRepo": 616,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,43 @@\n   private BlockReader getBlockReaderLocal() throws InvalidToken {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n           \"for short-circuit reads.\");\n     }\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory().\n                       getPathInfo(inetSocketAddress, conf);\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       PerformanceAdvisory.LOG.debug(this + \": \" + pathInfo + \" is not \" +\n           \"usable for short circuit; giving up on BlockReaderLocal.\");\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": got InvalidToken exception while trying to \" +\n             \"construct BlockReaderLocal via \" + pathInfo.getPath());\n       }\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       if (LOG.isTraceEnabled()) {\n         PerformanceAdvisory.LOG.debug(this + \": failed to get \" +\n             \"ShortCircuitReplica. Cannot construct \" +\n             \"BlockReaderLocal via \" + pathInfo.getPath());\n       }\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n+        setStorageType(storageType).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n          \"for short-circuit reads.\");\n    }\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory().\n                      getPathInfo(inetSocketAddress, conf);\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(this + \": \" + pathInfo + \" is not \" +\n          \"usable for short circuit; giving up on BlockReaderLocal.\");\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        PerformanceAdvisory.LOG.debug(this + \": failed to get \" +\n            \"ShortCircuitReplica. Cannot construct \" +\n            \"BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        setStorageType(storageType).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "225569ece229cec32f852f831fd337a139c44b1e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4486. Add log category for long-running DFSClient notices.  Contributed by Zhe Zhang.\n",
      "commitDate": "27/08/14 1:39 PM",
      "commitName": "225569ece229cec32f852f831fd337a139c44b1e",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "14/07/14 11:10 AM",
      "commitNameOld": "3b54223c0f32d42a84436c670d80b791a8e9696d",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 44.1,
      "commitsBetweenForRepo": 375,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,42 @@\n   private BlockReader getBlockReaderLocal() throws InvalidToken {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n           \"for short-circuit reads.\");\n     }\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory().\n                       getPathInfo(inetSocketAddress, conf);\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n-      if (LOG.isTraceEnabled()) {\n-        LOG.trace(this + \": \" + pathInfo + \" is not \" +\n-            \"usable for short circuit; giving up on BlockReaderLocal.\");\n-      }\n+      PerformanceAdvisory.LOG.debug(this + \": \" + pathInfo + \" is not \" +\n+          \"usable for short circuit; giving up on BlockReaderLocal.\");\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": got InvalidToken exception while trying to \" +\n             \"construct BlockReaderLocal via \" + pathInfo.getPath());\n       }\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       if (LOG.isTraceEnabled()) {\n-        LOG.trace(this + \": failed to get ShortCircuitReplica.  \" +\n-            \"Cannot construct BlockReaderLocal via \" + pathInfo.getPath());\n+        PerformanceAdvisory.LOG.debug(this + \": failed to get \" +\n+            \"ShortCircuitReplica. Cannot construct \" +\n+            \"BlockReaderLocal via \" + pathInfo.getPath());\n       }\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n          \"for short-circuit reads.\");\n    }\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory().\n                      getPathInfo(inetSocketAddress, conf);\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      PerformanceAdvisory.LOG.debug(this + \": \" + pathInfo + \" is not \" +\n          \"usable for short circuit; giving up on BlockReaderLocal.\");\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        PerformanceAdvisory.LOG.debug(this + \": failed to get \" +\n            \"ShortCircuitReplica. Cannot construct \" +\n            \"BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/03/14 7:58 PM",
      "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "12/02/14 7:10 PM",
      "commitNameOld": "f0d64a078da7e932b9509734f75170e3e525e68c",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 18.03,
      "commitsBetweenForRepo": 129,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,43 @@\n   private BlockReader getBlockReaderLocal() throws InvalidToken {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n           \"for short-circuit reads.\");\n     }\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory().\n                       getPathInfo(inetSocketAddress, conf);\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": \" + pathInfo + \" is not \" +\n             \"usable for short circuit; giving up on BlockReaderLocal.\");\n       }\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": got InvalidToken exception while trying to \" +\n             \"construct BlockReaderLocal via \" + pathInfo.getPath());\n       }\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": failed to get ShortCircuitReplica.  \" +\n             \"Cannot construct BlockReaderLocal via \" + pathInfo.getPath());\n       }\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n-        setDatanodeID(datanode).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n          \"for short-circuit reads.\");\n    }\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory().\n                      getPathInfo(inetSocketAddress, conf);\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": \" + pathInfo + \" is not \" +\n            \"usable for short circuit; giving up on BlockReaderLocal.\");\n      }\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": failed to get ShortCircuitReplica.  \" +\n            \"Cannot construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "f0d64a078da7e932b9509734f75170e3e525e68c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5940.  Minor cleanups to ShortCircuitReplica, FsDatasetCache, and DomainSocketWatcher (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567835 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 7:10 PM",
      "commitName": "f0d64a078da7e932b9509734f75170e3e525e68c",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "12/02/14 2:01 PM",
      "commitNameOld": "b3af8edc26191ac708208bc9543847dc62eca763",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n   private BlockReader getBlockReaderLocal() throws InvalidToken {\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n           \"for short-circuit reads.\");\n     }\n     if (pathInfo \u003d\u003d null) {\n       pathInfo \u003d clientContext.getDomainSocketFactory().\n                       getPathInfo(inetSocketAddress, conf);\n     }\n     if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": \" + pathInfo + \" is not \" +\n             \"usable for short circuit; giving up on BlockReaderLocal.\");\n       }\n       return null;\n     }\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n-    Key key \u003d new Key(block.getBlockId(), block.getBlockPoolId());\n+    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n     ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n     InvalidToken exc \u003d info.getInvalidTokenException();\n     if (exc !\u003d null) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": got InvalidToken exception while trying to \" +\n             \"construct BlockReaderLocal via \" + pathInfo.getPath());\n       }\n       throw exc;\n     }\n     if (info.getReplica() \u003d\u003d null) {\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": failed to get ShortCircuitReplica.  \" +\n             \"Cannot construct BlockReaderLocal via \" + pathInfo.getPath());\n       }\n       return null;\n     }\n     return new BlockReaderLocal.Builder(conf).\n         setFilename(fileName).\n         setBlock(block).\n         setStartOffset(startOffset).\n         setShortCircuitReplica(info.getReplica()).\n         setDatanodeID(datanode).\n         setVerifyChecksum(verifyChecksum).\n         setCachingStrategy(cachingStrategy).\n         build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n          \"for short-circuit reads.\");\n    }\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory().\n                      getPathInfo(inetSocketAddress, conf);\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": \" + pathInfo + \" is not \" +\n            \"usable for short circuit; giving up on BlockReaderLocal.\");\n      }\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": failed to get ShortCircuitReplica.  \" +\n            \"Cannot construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setDatanodeID(datanode).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5810. Unify mmap cache and short-circuit file descriptor cache (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567720 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 11:08 AM",
      "commitName": "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be",
      "commitAuthor": "Colin McCabe",
      "diff": "@@ -0,0 +1,44 @@\n+  private BlockReader getBlockReaderLocal() throws InvalidToken {\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n+          \"for short-circuit reads.\");\n+    }\n+    if (pathInfo \u003d\u003d null) {\n+      pathInfo \u003d clientContext.getDomainSocketFactory().\n+                      getPathInfo(inetSocketAddress, conf);\n+    }\n+    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": \" + pathInfo + \" is not \" +\n+            \"usable for short circuit; giving up on BlockReaderLocal.\");\n+      }\n+      return null;\n+    }\n+    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n+    Key key \u003d new Key(block.getBlockId(), block.getBlockPoolId());\n+    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n+    InvalidToken exc \u003d info.getInvalidTokenException();\n+    if (exc !\u003d null) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n+            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n+      }\n+      throw exc;\n+    }\n+    if (info.getReplica() \u003d\u003d null) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": failed to get ShortCircuitReplica.  \" +\n+            \"Cannot construct BlockReaderLocal via \" + pathInfo.getPath());\n+      }\n+      return null;\n+    }\n+    return new BlockReaderLocal.Builder(conf).\n+        setFilename(fileName).\n+        setBlock(block).\n+        setStartOffset(startOffset).\n+        setShortCircuitReplica(info.getReplica()).\n+        setDatanodeID(datanode).\n+        setVerifyChecksum(verifyChecksum).\n+        setCachingStrategy(cachingStrategy).\n+        build();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader getBlockReaderLocal() throws InvalidToken {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(this + \": trying to construct a BlockReaderLocal \" +\n          \"for short-circuit reads.\");\n    }\n    if (pathInfo \u003d\u003d null) {\n      pathInfo \u003d clientContext.getDomainSocketFactory().\n                      getPathInfo(inetSocketAddress, conf);\n    }\n    if (!pathInfo.getPathState().getUsableForShortCircuit()) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": \" + pathInfo + \" is not \" +\n            \"usable for short circuit; giving up on BlockReaderLocal.\");\n      }\n      return null;\n    }\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    Key key \u003d new Key(block.getBlockId(), block.getBlockPoolId());\n    ShortCircuitReplicaInfo info \u003d cache.fetchOrCreate(key, this);\n    InvalidToken exc \u003d info.getInvalidTokenException();\n    if (exc !\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": got InvalidToken exception while trying to \" +\n            \"construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      throw exc;\n    }\n    if (info.getReplica() \u003d\u003d null) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": failed to get ShortCircuitReplica.  \" +\n            \"Cannot construct BlockReaderLocal via \" + pathInfo.getPath());\n      }\n      return null;\n    }\n    return new BlockReaderLocal.Builder(conf).\n        setFilename(fileName).\n        setBlock(block).\n        setStartOffset(startOffset).\n        setShortCircuitReplica(info.getReplica()).\n        setDatanodeID(datanode).\n        setVerifyChecksum(verifyChecksum).\n        setCachingStrategy(cachingStrategy).\n        build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java"
    }
  }
}