{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FileInputFormat.java",
  "functionName": "singleThreadedListStatus",
  "functionId": "singleThreadedListStatus___job-JobContext__dirs-Path[]__inputFilter-PathFilter__recursive-boolean",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.java",
  "functionStartLine": 304,
  "functionEndLine": 343,
  "numCommitsSeen": 20,
  "timeTaken": 1958,
  "changeHistory": [
    "c613296dc85ac7b22c171c84f578106b315cc012",
    "396c6c63a26b098fd0221e830f79be13b7e97432"
  ],
  "changeHistoryShort": {
    "c613296dc85ac7b22c171c84f578106b315cc012": "Ybodychange",
    "396c6c63a26b098fd0221e830f79be13b7e97432": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c613296dc85ac7b22c171c84f578106b315cc012": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7241. FileInputFormat listStatus with less memory footprint. Contributed by Zhihua Deng\n",
      "commitDate": "01/04/20 5:46 AM",
      "commitName": "c613296dc85ac7b22c171c84f578106b315cc012",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "01/10/19 10:11 AM",
      "commitNameOld": "1921e94292f0820985a0cfbf8922a2a1a67fe921",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 182.82,
      "commitsBetweenForRepo": 690,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   private List\u003cFileStatus\u003e singleThreadedListStatus(JobContext job, Path[] dirs,\n       PathFilter inputFilter, boolean recursive) throws IOException {\n     List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n     List\u003cIOException\u003e errors \u003d new ArrayList\u003cIOException\u003e();\n     for (int i\u003d0; i \u003c dirs.length; ++i) {\n       Path p \u003d dirs[i];\n       FileSystem fs \u003d p.getFileSystem(job.getConfiguration()); \n       FileStatus[] matches \u003d fs.globStatus(p, inputFilter);\n       if (matches \u003d\u003d null) {\n         errors.add(new IOException(\"Input path does not exist: \" + p));\n       } else if (matches.length \u003d\u003d 0) {\n         errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n       } else {\n         for (FileStatus globStat: matches) {\n           if (globStat.isDirectory()) {\n             RemoteIterator\u003cLocatedFileStatus\u003e iter \u003d\n                 fs.listLocatedStatus(globStat.getPath());\n             while (iter.hasNext()) {\n               LocatedFileStatus stat \u003d iter.next();\n               if (inputFilter.accept(stat.getPath())) {\n                 if (recursive \u0026\u0026 stat.isDirectory()) {\n                   addInputPathRecursively(result, fs, stat.getPath(),\n                       inputFilter);\n                 } else {\n-                  result.add(stat);\n+                  result.add(shrinkStatus(stat));\n                 }\n               }\n             }\n           } else {\n             result.add(globStat);\n           }\n         }\n       }\n     }\n \n     if (!errors.isEmpty()) {\n       throw new InvalidInputException(errors);\n     }\n     return result;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cFileStatus\u003e singleThreadedListStatus(JobContext job, Path[] dirs,\n      PathFilter inputFilter, boolean recursive) throws IOException {\n    List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n    List\u003cIOException\u003e errors \u003d new ArrayList\u003cIOException\u003e();\n    for (int i\u003d0; i \u003c dirs.length; ++i) {\n      Path p \u003d dirs[i];\n      FileSystem fs \u003d p.getFileSystem(job.getConfiguration()); \n      FileStatus[] matches \u003d fs.globStatus(p, inputFilter);\n      if (matches \u003d\u003d null) {\n        errors.add(new IOException(\"Input path does not exist: \" + p));\n      } else if (matches.length \u003d\u003d 0) {\n        errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n      } else {\n        for (FileStatus globStat: matches) {\n          if (globStat.isDirectory()) {\n            RemoteIterator\u003cLocatedFileStatus\u003e iter \u003d\n                fs.listLocatedStatus(globStat.getPath());\n            while (iter.hasNext()) {\n              LocatedFileStatus stat \u003d iter.next();\n              if (inputFilter.accept(stat.getPath())) {\n                if (recursive \u0026\u0026 stat.isDirectory()) {\n                  addInputPathRecursively(result, fs, stat.getPath(),\n                      inputFilter);\n                } else {\n                  result.add(shrinkStatus(stat));\n                }\n              }\n            }\n          } else {\n            result.add(globStat);\n          }\n        }\n      }\n    }\n\n    if (!errors.isEmpty()) {\n      throw new InvalidInputException(errors);\n    }\n    return result;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.java",
      "extendedDetails": {}
    },
    "396c6c63a26b098fd0221e830f79be13b7e97432": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2349. Modified FileInputFormat to be able to issue file and block location calls in parallel. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1579515 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/03/14 7:46 PM",
      "commitName": "396c6c63a26b098fd0221e830f79be13b7e97432",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,40 @@\n+  private List\u003cFileStatus\u003e singleThreadedListStatus(JobContext job, Path[] dirs,\n+      PathFilter inputFilter, boolean recursive) throws IOException {\n+    List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n+    List\u003cIOException\u003e errors \u003d new ArrayList\u003cIOException\u003e();\n+    for (int i\u003d0; i \u003c dirs.length; ++i) {\n+      Path p \u003d dirs[i];\n+      FileSystem fs \u003d p.getFileSystem(job.getConfiguration()); \n+      FileStatus[] matches \u003d fs.globStatus(p, inputFilter);\n+      if (matches \u003d\u003d null) {\n+        errors.add(new IOException(\"Input path does not exist: \" + p));\n+      } else if (matches.length \u003d\u003d 0) {\n+        errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n+      } else {\n+        for (FileStatus globStat: matches) {\n+          if (globStat.isDirectory()) {\n+            RemoteIterator\u003cLocatedFileStatus\u003e iter \u003d\n+                fs.listLocatedStatus(globStat.getPath());\n+            while (iter.hasNext()) {\n+              LocatedFileStatus stat \u003d iter.next();\n+              if (inputFilter.accept(stat.getPath())) {\n+                if (recursive \u0026\u0026 stat.isDirectory()) {\n+                  addInputPathRecursively(result, fs, stat.getPath(),\n+                      inputFilter);\n+                } else {\n+                  result.add(stat);\n+                }\n+              }\n+            }\n+          } else {\n+            result.add(globStat);\n+          }\n+        }\n+      }\n+    }\n+\n+    if (!errors.isEmpty()) {\n+      throw new InvalidInputException(errors);\n+    }\n+    return result;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cFileStatus\u003e singleThreadedListStatus(JobContext job, Path[] dirs,\n      PathFilter inputFilter, boolean recursive) throws IOException {\n    List\u003cFileStatus\u003e result \u003d new ArrayList\u003cFileStatus\u003e();\n    List\u003cIOException\u003e errors \u003d new ArrayList\u003cIOException\u003e();\n    for (int i\u003d0; i \u003c dirs.length; ++i) {\n      Path p \u003d dirs[i];\n      FileSystem fs \u003d p.getFileSystem(job.getConfiguration()); \n      FileStatus[] matches \u003d fs.globStatus(p, inputFilter);\n      if (matches \u003d\u003d null) {\n        errors.add(new IOException(\"Input path does not exist: \" + p));\n      } else if (matches.length \u003d\u003d 0) {\n        errors.add(new IOException(\"Input Pattern \" + p + \" matches 0 files\"));\n      } else {\n        for (FileStatus globStat: matches) {\n          if (globStat.isDirectory()) {\n            RemoteIterator\u003cLocatedFileStatus\u003e iter \u003d\n                fs.listLocatedStatus(globStat.getPath());\n            while (iter.hasNext()) {\n              LocatedFileStatus stat \u003d iter.next();\n              if (inputFilter.accept(stat.getPath())) {\n                if (recursive \u0026\u0026 stat.isDirectory()) {\n                  addInputPathRecursively(result, fs, stat.getPath(),\n                      inputFilter);\n                } else {\n                  result.add(stat);\n                }\n              }\n            }\n          } else {\n            result.add(globStat);\n          }\n        }\n      }\n    }\n\n    if (!errors.isEmpty()) {\n      throw new InvalidInputException(errors);\n    }\n    return result;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.java"
    }
  }
}