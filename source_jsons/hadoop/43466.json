{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Component.java",
  "functionName": "requestContainers",
  "functionId": "requestContainers___count-long",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java",
  "functionStartLine": 733,
  "functionEndLine": 863,
  "numCommitsSeen": 36,
  "timeTaken": 4160,
  "changeHistory": [
    "c791b0e90e0d9c7cb05d162d605e0679942bcbfb",
    "f4906ac01960c78ff0c91797eaa4b36d80f6826d",
    "42f3a7082a90bc71f0e86dc1e50b0c77b05489cf",
    "778a4a24be176382a5704f709c00bdfcfe6ddc8c",
    "28e2244390c990877dc2ee2733cf9b8d2c75128e",
    "a0bde7d525911680f9e5fb0a939604865eb8e164",
    "7467e8fe5a95230986fed9d748769304af3f2b61",
    "438c1d333ebc0a3071bb556532ed959a4bd1e6d6",
    "40ab068eabe50875449d601471619a4e82fff86d",
    "1888318c89776f0bf354c1b13e3ee169e14ff638"
  ],
  "changeHistoryShort": {
    "c791b0e90e0d9c7cb05d162d605e0679942bcbfb": "Ybodychange",
    "f4906ac01960c78ff0c91797eaa4b36d80f6826d": "Ybodychange",
    "42f3a7082a90bc71f0e86dc1e50b0c77b05489cf": "Ybodychange",
    "778a4a24be176382a5704f709c00bdfcfe6ddc8c": "Ybodychange",
    "28e2244390c990877dc2ee2733cf9b8d2c75128e": "Ybodychange",
    "a0bde7d525911680f9e5fb0a939604865eb8e164": "Ybodychange",
    "7467e8fe5a95230986fed9d748769304af3f2b61": "Ybodychange",
    "438c1d333ebc0a3071bb556532ed959a4bd1e6d6": "Ybodychange",
    "40ab068eabe50875449d601471619a4e82fff86d": "Yfilerename",
    "1888318c89776f0bf354c1b13e3ee169e14ff638": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c791b0e90e0d9c7cb05d162d605e0679942bcbfb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10219. Fix YARN Native Service Placement Constraints with Node Attributes.\n\nContributed by Eric Yang.\n",
      "commitDate": "14/04/20 12:04 AM",
      "commitName": "c791b0e90e0d9c7cb05d162d605e0679942bcbfb",
      "commitAuthor": "Prabhu Joseph",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 403.39,
      "commitsBetweenForRepo": 2316,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,131 @@\n   public void requestContainers(long count) {\n     LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n         componentSpec.getName(), count);\n     org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n         componentSpec.getResource();\n \n     Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n         componentResource.getCpus());\n \n     if (componentResource.getAdditional() !\u003d null) {\n       for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n           .getAdditional().entrySet()) {\n \n         String resourceName \u003d entry.getKey();\n \n         // Avoid setting memory/cpu under \"additional\"\n         if (resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n             || resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n           LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n               + \"ignoring this entry\u003d\" + resourceName);\n           continue;\n         }\n \n         ResourceInformation specInfo \u003d entry.getValue();\n         org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n             org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                 entry.getKey(),\n                 specInfo.getUnit(),\n                 specInfo.getValue(),\n                 specInfo.getTags(),\n                 specInfo.getAttributes());\n         resource.setResourceInformation(resourceName, ri);\n       }\n     }\n \n     if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n       for (int i \u003d 0; i \u003c count; i++) {\n         ContainerRequest request \u003d ContainerRequest.newBuilder()\n             .capability(resource).priority(priority)\n             .allocationRequestId(allocateId).relaxLocality(true).build();\n         LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n             componentSpec.getName(), request);\n         amrmClient.addContainerRequest(request);\n       }\n     } else {\n       // Schedule placement requests. Validation of non-null target tags and\n       // that they refer to existing component names are already done. So, no\n       // need to validate here.\n       PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n       Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n       // We prepare an AND-ed composite constraint to be the final composite\n       // constraint. If placement expressions are specified to create advanced\n       // composite constraints then this AND-ed composite constraint is not\n       // used.\n       PlacementConstraint finalConstraint \u003d null;\n       if (placementPolicy !\u003d null) {\n         for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n             yarnServiceConstraint : placementPolicy.getConstraints()) {\n           List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n           // Currently only intra-application allocation tags are supported.\n           if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n             targetExpressions.add(PlacementTargets.allocationTag(\n                 yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n           }\n           // Add all node attributes\n           for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n               .getNodeAttributes().entrySet()) {\n             targetExpressions\n                 .add(PlacementTargets.nodeAttribute(attribute.getKey(),\n                     attribute.getValue().toArray(new String[0])));\n           }\n           // Add all node partitions\n           if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n             targetExpressions\n                 .add(PlacementTargets.nodePartition(yarnServiceConstraint\n                     .getNodePartitions().toArray(new String[0])));\n           }\n           PlacementConstraint constraint \u003d null;\n           switch (yarnServiceConstraint.getType()) {\n           case AFFINITY:\n-            constraint \u003d PlacementConstraints\n-                .targetIn(yarnServiceConstraint.getScope().getValue(),\n-                    targetExpressions.toArray(new TargetExpression[0]))\n-                .build();\n+            constraint \u003d getAffinityConstraint(yarnServiceConstraint,\n+              targetExpressions);\n             break;\n           case ANTI_AFFINITY:\n-            constraint \u003d PlacementConstraints\n-                .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n-                    targetExpressions.toArray(new TargetExpression[0]))\n-                .build();\n+            constraint \u003d getAntiAffinityConstraint(yarnServiceConstraint,\n+              targetExpressions);\n             break;\n           case AFFINITY_WITH_CARDINALITY:\n             constraint \u003d PlacementConstraints.targetCardinality(\n                 yarnServiceConstraint.getScope().name().toLowerCase(),\n                 yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n                     : yarnServiceConstraint.getMinCardinality().intValue(),\n                 yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n                     ? Integer.MAX_VALUE\n                     : yarnServiceConstraint.getMaxCardinality().intValue(),\n                 targetExpressions.toArray(new TargetExpression[0])).build();\n             break;\n           }\n           // The default AND-ed final composite constraint\n           if (finalConstraint !\u003d null) {\n             finalConstraint \u003d PlacementConstraints\n                 .and(constraint.getConstraintExpr(),\n                     finalConstraint.getConstraintExpr())\n                 .build();\n           } else {\n             finalConstraint \u003d constraint;\n           }\n           LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n               componentSpec.getName(),\n               constraint.getConstraintExpr().toString());\n         }\n       }\n       ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n           resource);\n       LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n           resourceSizing);\n       SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n           .priority(priority).allocationRequestId(allocateId)\n           .allocationTags(Collections.singleton(componentSpec.getName()))\n           .executionType(\n               ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n           .placementConstraintExpression(finalConstraint)\n           .resourceSizing(resourceSizing).build();\n       LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n           componentSpec.getName(), request);\n       schedulingRequests.add(request);\n       amrmClient.addSchedulingRequests(schedulingRequests);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestContainers(long count) {\n    LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n        componentSpec.getName(), count);\n    org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n        componentSpec.getResource();\n\n    Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n        componentResource.getCpus());\n\n    if (componentResource.getAdditional() !\u003d null) {\n      for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n          .getAdditional().entrySet()) {\n\n        String resourceName \u003d entry.getKey();\n\n        // Avoid setting memory/cpu under \"additional\"\n        if (resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n            || resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n          LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n              + \"ignoring this entry\u003d\" + resourceName);\n          continue;\n        }\n\n        ResourceInformation specInfo \u003d entry.getValue();\n        org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n            org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                entry.getKey(),\n                specInfo.getUnit(),\n                specInfo.getValue(),\n                specInfo.getTags(),\n                specInfo.getAttributes());\n        resource.setResourceInformation(resourceName, ri);\n      }\n    }\n\n    if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n      for (int i \u003d 0; i \u003c count; i++) {\n        ContainerRequest request \u003d ContainerRequest.newBuilder()\n            .capability(resource).priority(priority)\n            .allocationRequestId(allocateId).relaxLocality(true).build();\n        LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n            componentSpec.getName(), request);\n        amrmClient.addContainerRequest(request);\n      }\n    } else {\n      // Schedule placement requests. Validation of non-null target tags and\n      // that they refer to existing component names are already done. So, no\n      // need to validate here.\n      PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n      Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n      // We prepare an AND-ed composite constraint to be the final composite\n      // constraint. If placement expressions are specified to create advanced\n      // composite constraints then this AND-ed composite constraint is not\n      // used.\n      PlacementConstraint finalConstraint \u003d null;\n      if (placementPolicy !\u003d null) {\n        for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n            yarnServiceConstraint : placementPolicy.getConstraints()) {\n          List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n          // Currently only intra-application allocation tags are supported.\n          if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n            targetExpressions.add(PlacementTargets.allocationTag(\n                yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n          }\n          // Add all node attributes\n          for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n              .getNodeAttributes().entrySet()) {\n            targetExpressions\n                .add(PlacementTargets.nodeAttribute(attribute.getKey(),\n                    attribute.getValue().toArray(new String[0])));\n          }\n          // Add all node partitions\n          if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n            targetExpressions\n                .add(PlacementTargets.nodePartition(yarnServiceConstraint\n                    .getNodePartitions().toArray(new String[0])));\n          }\n          PlacementConstraint constraint \u003d null;\n          switch (yarnServiceConstraint.getType()) {\n          case AFFINITY:\n            constraint \u003d getAffinityConstraint(yarnServiceConstraint,\n              targetExpressions);\n            break;\n          case ANTI_AFFINITY:\n            constraint \u003d getAntiAffinityConstraint(yarnServiceConstraint,\n              targetExpressions);\n            break;\n          case AFFINITY_WITH_CARDINALITY:\n            constraint \u003d PlacementConstraints.targetCardinality(\n                yarnServiceConstraint.getScope().name().toLowerCase(),\n                yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n                    : yarnServiceConstraint.getMinCardinality().intValue(),\n                yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n                    ? Integer.MAX_VALUE\n                    : yarnServiceConstraint.getMaxCardinality().intValue(),\n                targetExpressions.toArray(new TargetExpression[0])).build();\n            break;\n          }\n          // The default AND-ed final composite constraint\n          if (finalConstraint !\u003d null) {\n            finalConstraint \u003d PlacementConstraints\n                .and(constraint.getConstraintExpr(),\n                    finalConstraint.getConstraintExpr())\n                .build();\n          } else {\n            finalConstraint \u003d constraint;\n          }\n          LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n              componentSpec.getName(),\n              constraint.getConstraintExpr().toString());\n        }\n      }\n      ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n          resource);\n      LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n          resourceSizing);\n      SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n          .priority(priority).allocationRequestId(allocateId)\n          .allocationTags(Collections.singleton(componentSpec.getName()))\n          .executionType(\n              ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n          .placementConstraintExpression(finalConstraint)\n          .resourceSizing(resourceSizing).build();\n      LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n          componentSpec.getName(), request);\n      schedulingRequests.add(request);\n      amrmClient.addSchedulingRequests(schedulingRequests);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java",
      "extendedDetails": {}
    },
    "f4906ac01960c78ff0c91797eaa4b36d80f6826d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9038. [CSI] Add ability to publish/unpublish volumes on node managers. Contributed by Weiwei Yang.\n",
      "commitDate": "03/01/19 10:40 PM",
      "commitName": "f4906ac01960c78ff0c91797eaa4b36d80f6826d",
      "commitAuthor": "Sunil G",
      "commitDateOld": "27/11/18 3:36 PM",
      "commitNameOld": "f657a2a661ed7470915fa33ea4bbda2f4980c8b2",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 37.29,
      "commitsBetweenForRepo": 227,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,135 @@\n   public void requestContainers(long count) {\n     LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n         componentSpec.getName(), count);\n     org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n         componentSpec.getResource();\n \n     Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n         componentResource.getCpus());\n \n     if (componentResource.getAdditional() !\u003d null) {\n       for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n           .getAdditional().entrySet()) {\n \n         String resourceName \u003d entry.getKey();\n \n         // Avoid setting memory/cpu under \"additional\"\n         if (resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n             || resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n           LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n               + \"ignoring this entry\u003d\" + resourceName);\n           continue;\n         }\n \n         ResourceInformation specInfo \u003d entry.getValue();\n         org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n             org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                 entry.getKey(),\n                 specInfo.getUnit(),\n                 specInfo.getValue(),\n+                specInfo.getTags(),\n                 specInfo.getAttributes());\n         resource.setResourceInformation(resourceName, ri);\n       }\n     }\n \n     if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n       for (int i \u003d 0; i \u003c count; i++) {\n         ContainerRequest request \u003d ContainerRequest.newBuilder()\n             .capability(resource).priority(priority)\n             .allocationRequestId(allocateId).relaxLocality(true).build();\n         LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n             componentSpec.getName(), request);\n         amrmClient.addContainerRequest(request);\n       }\n     } else {\n       // Schedule placement requests. Validation of non-null target tags and\n       // that they refer to existing component names are already done. So, no\n       // need to validate here.\n       PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n       Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n       // We prepare an AND-ed composite constraint to be the final composite\n       // constraint. If placement expressions are specified to create advanced\n       // composite constraints then this AND-ed composite constraint is not\n       // used.\n       PlacementConstraint finalConstraint \u003d null;\n       if (placementPolicy !\u003d null) {\n         for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n             yarnServiceConstraint : placementPolicy.getConstraints()) {\n           List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n           // Currently only intra-application allocation tags are supported.\n           if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n             targetExpressions.add(PlacementTargets.allocationTag(\n                 yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n           }\n           // Add all node attributes\n           for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n               .getNodeAttributes().entrySet()) {\n             targetExpressions\n                 .add(PlacementTargets.nodeAttribute(attribute.getKey(),\n                     attribute.getValue().toArray(new String[0])));\n           }\n           // Add all node partitions\n           if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n             targetExpressions\n                 .add(PlacementTargets.nodePartition(yarnServiceConstraint\n                     .getNodePartitions().toArray(new String[0])));\n           }\n           PlacementConstraint constraint \u003d null;\n           switch (yarnServiceConstraint.getType()) {\n           case AFFINITY:\n             constraint \u003d PlacementConstraints\n                 .targetIn(yarnServiceConstraint.getScope().getValue(),\n                     targetExpressions.toArray(new TargetExpression[0]))\n                 .build();\n             break;\n           case ANTI_AFFINITY:\n             constraint \u003d PlacementConstraints\n                 .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n                     targetExpressions.toArray(new TargetExpression[0]))\n                 .build();\n             break;\n           case AFFINITY_WITH_CARDINALITY:\n             constraint \u003d PlacementConstraints.targetCardinality(\n                 yarnServiceConstraint.getScope().name().toLowerCase(),\n                 yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n                     : yarnServiceConstraint.getMinCardinality().intValue(),\n                 yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n                     ? Integer.MAX_VALUE\n                     : yarnServiceConstraint.getMaxCardinality().intValue(),\n                 targetExpressions.toArray(new TargetExpression[0])).build();\n             break;\n           }\n           // The default AND-ed final composite constraint\n           if (finalConstraint !\u003d null) {\n             finalConstraint \u003d PlacementConstraints\n                 .and(constraint.getConstraintExpr(),\n                     finalConstraint.getConstraintExpr())\n                 .build();\n           } else {\n             finalConstraint \u003d constraint;\n           }\n           LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n               componentSpec.getName(),\n               constraint.getConstraintExpr().toString());\n         }\n       }\n       ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n           resource);\n       LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n           resourceSizing);\n       SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n           .priority(priority).allocationRequestId(allocateId)\n           .allocationTags(Collections.singleton(componentSpec.getName()))\n           .executionType(\n               ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n           .placementConstraintExpression(finalConstraint)\n           .resourceSizing(resourceSizing).build();\n       LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n           componentSpec.getName(), request);\n       schedulingRequests.add(request);\n       amrmClient.addSchedulingRequests(schedulingRequests);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestContainers(long count) {\n    LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n        componentSpec.getName(), count);\n    org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n        componentSpec.getResource();\n\n    Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n        componentResource.getCpus());\n\n    if (componentResource.getAdditional() !\u003d null) {\n      for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n          .getAdditional().entrySet()) {\n\n        String resourceName \u003d entry.getKey();\n\n        // Avoid setting memory/cpu under \"additional\"\n        if (resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n            || resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n          LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n              + \"ignoring this entry\u003d\" + resourceName);\n          continue;\n        }\n\n        ResourceInformation specInfo \u003d entry.getValue();\n        org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n            org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                entry.getKey(),\n                specInfo.getUnit(),\n                specInfo.getValue(),\n                specInfo.getTags(),\n                specInfo.getAttributes());\n        resource.setResourceInformation(resourceName, ri);\n      }\n    }\n\n    if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n      for (int i \u003d 0; i \u003c count; i++) {\n        ContainerRequest request \u003d ContainerRequest.newBuilder()\n            .capability(resource).priority(priority)\n            .allocationRequestId(allocateId).relaxLocality(true).build();\n        LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n            componentSpec.getName(), request);\n        amrmClient.addContainerRequest(request);\n      }\n    } else {\n      // Schedule placement requests. Validation of non-null target tags and\n      // that they refer to existing component names are already done. So, no\n      // need to validate here.\n      PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n      Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n      // We prepare an AND-ed composite constraint to be the final composite\n      // constraint. If placement expressions are specified to create advanced\n      // composite constraints then this AND-ed composite constraint is not\n      // used.\n      PlacementConstraint finalConstraint \u003d null;\n      if (placementPolicy !\u003d null) {\n        for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n            yarnServiceConstraint : placementPolicy.getConstraints()) {\n          List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n          // Currently only intra-application allocation tags are supported.\n          if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n            targetExpressions.add(PlacementTargets.allocationTag(\n                yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n          }\n          // Add all node attributes\n          for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n              .getNodeAttributes().entrySet()) {\n            targetExpressions\n                .add(PlacementTargets.nodeAttribute(attribute.getKey(),\n                    attribute.getValue().toArray(new String[0])));\n          }\n          // Add all node partitions\n          if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n            targetExpressions\n                .add(PlacementTargets.nodePartition(yarnServiceConstraint\n                    .getNodePartitions().toArray(new String[0])));\n          }\n          PlacementConstraint constraint \u003d null;\n          switch (yarnServiceConstraint.getType()) {\n          case AFFINITY:\n            constraint \u003d PlacementConstraints\n                .targetIn(yarnServiceConstraint.getScope().getValue(),\n                    targetExpressions.toArray(new TargetExpression[0]))\n                .build();\n            break;\n          case ANTI_AFFINITY:\n            constraint \u003d PlacementConstraints\n                .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n                    targetExpressions.toArray(new TargetExpression[0]))\n                .build();\n            break;\n          case AFFINITY_WITH_CARDINALITY:\n            constraint \u003d PlacementConstraints.targetCardinality(\n                yarnServiceConstraint.getScope().name().toLowerCase(),\n                yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n                    : yarnServiceConstraint.getMinCardinality().intValue(),\n                yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n                    ? Integer.MAX_VALUE\n                    : yarnServiceConstraint.getMaxCardinality().intValue(),\n                targetExpressions.toArray(new TargetExpression[0])).build();\n            break;\n          }\n          // The default AND-ed final composite constraint\n          if (finalConstraint !\u003d null) {\n            finalConstraint \u003d PlacementConstraints\n                .and(constraint.getConstraintExpr(),\n                    finalConstraint.getConstraintExpr())\n                .build();\n          } else {\n            finalConstraint \u003d constraint;\n          }\n          LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n              componentSpec.getName(),\n              constraint.getConstraintExpr().toString());\n        }\n      }\n      ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n          resource);\n      LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n          resourceSizing);\n      SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n          .priority(priority).allocationRequestId(allocateId)\n          .allocationTags(Collections.singleton(componentSpec.getName()))\n          .executionType(\n              ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n          .placementConstraintExpression(finalConstraint)\n          .resourceSizing(resourceSizing).build();\n      LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n          componentSpec.getName(), request);\n      schedulingRequests.add(request);\n      amrmClient.addSchedulingRequests(schedulingRequests);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java",
      "extendedDetails": {}
    },
    "42f3a7082a90bc71f0e86dc1e50b0c77b05489cf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8877. [CSI] Extend service spec to allow setting resource attributes. Contributed by Weiwei Yang.\n",
      "commitDate": "12/11/18 7:39 AM",
      "commitName": "42f3a7082a90bc71f0e86dc1e50b0c77b05489cf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "26/09/18 11:51 AM",
      "commitNameOld": "913f87dada27776c539dfb352400ecf8d40e7943",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 46.87,
      "commitsBetweenForRepo": 412,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,134 @@\n   public void requestContainers(long count) {\n     LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n         componentSpec.getName(), count);\n     org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n         componentSpec.getResource();\n \n     Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n         componentResource.getCpus());\n \n     if (componentResource.getAdditional() !\u003d null) {\n       for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n           .getAdditional().entrySet()) {\n \n         String resourceName \u003d entry.getKey();\n \n         // Avoid setting memory/cpu under \"additional\"\n         if (resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n             || resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n           LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n               + \"ignoring this entry\u003d\" + resourceName);\n           continue;\n         }\n \n         ResourceInformation specInfo \u003d entry.getValue();\n         org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n             org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                 entry.getKey(),\n                 specInfo.getUnit(),\n-                specInfo.getValue());\n+                specInfo.getValue(),\n+                specInfo.getAttributes());\n         resource.setResourceInformation(resourceName, ri);\n       }\n     }\n \n     if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n       for (int i \u003d 0; i \u003c count; i++) {\n         ContainerRequest request \u003d ContainerRequest.newBuilder()\n             .capability(resource).priority(priority)\n             .allocationRequestId(allocateId).relaxLocality(true).build();\n         LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n             componentSpec.getName(), request);\n         amrmClient.addContainerRequest(request);\n       }\n     } else {\n       // Schedule placement requests. Validation of non-null target tags and\n       // that they refer to existing component names are already done. So, no\n       // need to validate here.\n       PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n       Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n       // We prepare an AND-ed composite constraint to be the final composite\n       // constraint. If placement expressions are specified to create advanced\n       // composite constraints then this AND-ed composite constraint is not\n       // used.\n       PlacementConstraint finalConstraint \u003d null;\n       if (placementPolicy !\u003d null) {\n         for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n             yarnServiceConstraint : placementPolicy.getConstraints()) {\n           List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n           // Currently only intra-application allocation tags are supported.\n           if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n             targetExpressions.add(PlacementTargets.allocationTag(\n                 yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n           }\n           // Add all node attributes\n           for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n               .getNodeAttributes().entrySet()) {\n             targetExpressions\n                 .add(PlacementTargets.nodeAttribute(attribute.getKey(),\n                     attribute.getValue().toArray(new String[0])));\n           }\n           // Add all node partitions\n           if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n             targetExpressions\n                 .add(PlacementTargets.nodePartition(yarnServiceConstraint\n                     .getNodePartitions().toArray(new String[0])));\n           }\n           PlacementConstraint constraint \u003d null;\n           switch (yarnServiceConstraint.getType()) {\n           case AFFINITY:\n             constraint \u003d PlacementConstraints\n                 .targetIn(yarnServiceConstraint.getScope().getValue(),\n                     targetExpressions.toArray(new TargetExpression[0]))\n                 .build();\n             break;\n           case ANTI_AFFINITY:\n             constraint \u003d PlacementConstraints\n                 .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n                     targetExpressions.toArray(new TargetExpression[0]))\n                 .build();\n             break;\n           case AFFINITY_WITH_CARDINALITY:\n             constraint \u003d PlacementConstraints.targetCardinality(\n                 yarnServiceConstraint.getScope().name().toLowerCase(),\n                 yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n                     : yarnServiceConstraint.getMinCardinality().intValue(),\n                 yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n                     ? Integer.MAX_VALUE\n                     : yarnServiceConstraint.getMaxCardinality().intValue(),\n                 targetExpressions.toArray(new TargetExpression[0])).build();\n             break;\n           }\n           // The default AND-ed final composite constraint\n           if (finalConstraint !\u003d null) {\n             finalConstraint \u003d PlacementConstraints\n                 .and(constraint.getConstraintExpr(),\n                     finalConstraint.getConstraintExpr())\n                 .build();\n           } else {\n             finalConstraint \u003d constraint;\n           }\n           LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n               componentSpec.getName(),\n               constraint.getConstraintExpr().toString());\n         }\n       }\n       ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n           resource);\n       LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n           resourceSizing);\n       SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n           .priority(priority).allocationRequestId(allocateId)\n           .allocationTags(Collections.singleton(componentSpec.getName()))\n           .executionType(\n               ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n           .placementConstraintExpression(finalConstraint)\n           .resourceSizing(resourceSizing).build();\n       LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n           componentSpec.getName(), request);\n       schedulingRequests.add(request);\n       amrmClient.addSchedulingRequests(schedulingRequests);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestContainers(long count) {\n    LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n        componentSpec.getName(), count);\n    org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n        componentSpec.getResource();\n\n    Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n        componentResource.getCpus());\n\n    if (componentResource.getAdditional() !\u003d null) {\n      for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n          .getAdditional().entrySet()) {\n\n        String resourceName \u003d entry.getKey();\n\n        // Avoid setting memory/cpu under \"additional\"\n        if (resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n            || resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n          LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n              + \"ignoring this entry\u003d\" + resourceName);\n          continue;\n        }\n\n        ResourceInformation specInfo \u003d entry.getValue();\n        org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n            org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                entry.getKey(),\n                specInfo.getUnit(),\n                specInfo.getValue(),\n                specInfo.getAttributes());\n        resource.setResourceInformation(resourceName, ri);\n      }\n    }\n\n    if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n      for (int i \u003d 0; i \u003c count; i++) {\n        ContainerRequest request \u003d ContainerRequest.newBuilder()\n            .capability(resource).priority(priority)\n            .allocationRequestId(allocateId).relaxLocality(true).build();\n        LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n            componentSpec.getName(), request);\n        amrmClient.addContainerRequest(request);\n      }\n    } else {\n      // Schedule placement requests. Validation of non-null target tags and\n      // that they refer to existing component names are already done. So, no\n      // need to validate here.\n      PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n      Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n      // We prepare an AND-ed composite constraint to be the final composite\n      // constraint. If placement expressions are specified to create advanced\n      // composite constraints then this AND-ed composite constraint is not\n      // used.\n      PlacementConstraint finalConstraint \u003d null;\n      if (placementPolicy !\u003d null) {\n        for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n            yarnServiceConstraint : placementPolicy.getConstraints()) {\n          List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n          // Currently only intra-application allocation tags are supported.\n          if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n            targetExpressions.add(PlacementTargets.allocationTag(\n                yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n          }\n          // Add all node attributes\n          for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n              .getNodeAttributes().entrySet()) {\n            targetExpressions\n                .add(PlacementTargets.nodeAttribute(attribute.getKey(),\n                    attribute.getValue().toArray(new String[0])));\n          }\n          // Add all node partitions\n          if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n            targetExpressions\n                .add(PlacementTargets.nodePartition(yarnServiceConstraint\n                    .getNodePartitions().toArray(new String[0])));\n          }\n          PlacementConstraint constraint \u003d null;\n          switch (yarnServiceConstraint.getType()) {\n          case AFFINITY:\n            constraint \u003d PlacementConstraints\n                .targetIn(yarnServiceConstraint.getScope().getValue(),\n                    targetExpressions.toArray(new TargetExpression[0]))\n                .build();\n            break;\n          case ANTI_AFFINITY:\n            constraint \u003d PlacementConstraints\n                .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n                    targetExpressions.toArray(new TargetExpression[0]))\n                .build();\n            break;\n          case AFFINITY_WITH_CARDINALITY:\n            constraint \u003d PlacementConstraints.targetCardinality(\n                yarnServiceConstraint.getScope().name().toLowerCase(),\n                yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n                    : yarnServiceConstraint.getMinCardinality().intValue(),\n                yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n                    ? Integer.MAX_VALUE\n                    : yarnServiceConstraint.getMaxCardinality().intValue(),\n                targetExpressions.toArray(new TargetExpression[0])).build();\n            break;\n          }\n          // The default AND-ed final composite constraint\n          if (finalConstraint !\u003d null) {\n            finalConstraint \u003d PlacementConstraints\n                .and(constraint.getConstraintExpr(),\n                    finalConstraint.getConstraintExpr())\n                .build();\n          } else {\n            finalConstraint \u003d constraint;\n          }\n          LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n              componentSpec.getName(),\n              constraint.getConstraintExpr().toString());\n        }\n      }\n      ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n          resource);\n      LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n          resourceSizing);\n      SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n          .priority(priority).allocationRequestId(allocateId)\n          .allocationTags(Collections.singleton(componentSpec.getName()))\n          .executionType(\n              ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n          .placementConstraintExpression(finalConstraint)\n          .resourceSizing(resourceSizing).build();\n      LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n          componentSpec.getName(), request);\n      schedulingRequests.add(request);\n      amrmClient.addSchedulingRequests(schedulingRequests);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java",
      "extendedDetails": {}
    },
    "778a4a24be176382a5704f709c00bdfcfe6ddc8c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8350. NPE in service AM related to placement policy. Contributed by Gour Saha\n",
      "commitDate": "30/05/18 1:19 PM",
      "commitName": "778a4a24be176382a5704f709c00bdfcfe6ddc8c",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "17/05/18 2:16 PM",
      "commitNameOld": "7f083ed8699a720d3fb82e4ec310356902a6ac30",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 12.96,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,133 @@\n   public void requestContainers(long count) {\n     LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n         componentSpec.getName(), count);\n     org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n         componentSpec.getResource();\n \n     Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n         componentResource.getCpus());\n \n     if (componentResource.getAdditional() !\u003d null) {\n       for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n           .getAdditional().entrySet()) {\n \n         String resourceName \u003d entry.getKey();\n \n         // Avoid setting memory/cpu under \"additional\"\n         if (resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n             || resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n           LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n               + \"ignoring this entry\u003d\" + resourceName);\n           continue;\n         }\n \n         ResourceInformation specInfo \u003d entry.getValue();\n         org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n             org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                 entry.getKey(),\n                 specInfo.getUnit(),\n                 specInfo.getValue());\n         resource.setResourceInformation(resourceName, ri);\n       }\n     }\n \n     if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n       for (int i \u003d 0; i \u003c count; i++) {\n         ContainerRequest request \u003d ContainerRequest.newBuilder()\n             .capability(resource).priority(priority)\n             .allocationRequestId(allocateId).relaxLocality(true).build();\n         LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n             componentSpec.getName(), request);\n         amrmClient.addContainerRequest(request);\n       }\n     } else {\n       // Schedule placement requests. Validation of non-null target tags and\n       // that they refer to existing component names are already done. So, no\n       // need to validate here.\n       PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n       Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n       // We prepare an AND-ed composite constraint to be the final composite\n       // constraint. If placement expressions are specified to create advanced\n       // composite constraints then this AND-ed composite constraint is not\n       // used.\n       PlacementConstraint finalConstraint \u003d null;\n-      for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n-          yarnServiceConstraint : placementPolicy.getConstraints()) {\n-        List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n-        // Currently only intra-application allocation tags are supported.\n-        if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n-          targetExpressions.add(PlacementTargets.allocationTag(\n-              yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n+      if (placementPolicy !\u003d null) {\n+        for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n+            yarnServiceConstraint : placementPolicy.getConstraints()) {\n+          List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n+          // Currently only intra-application allocation tags are supported.\n+          if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n+            targetExpressions.add(PlacementTargets.allocationTag(\n+                yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n+          }\n+          // Add all node attributes\n+          for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n+              .getNodeAttributes().entrySet()) {\n+            targetExpressions\n+                .add(PlacementTargets.nodeAttribute(attribute.getKey(),\n+                    attribute.getValue().toArray(new String[0])));\n+          }\n+          // Add all node partitions\n+          if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n+            targetExpressions\n+                .add(PlacementTargets.nodePartition(yarnServiceConstraint\n+                    .getNodePartitions().toArray(new String[0])));\n+          }\n+          PlacementConstraint constraint \u003d null;\n+          switch (yarnServiceConstraint.getType()) {\n+          case AFFINITY:\n+            constraint \u003d PlacementConstraints\n+                .targetIn(yarnServiceConstraint.getScope().getValue(),\n+                    targetExpressions.toArray(new TargetExpression[0]))\n+                .build();\n+            break;\n+          case ANTI_AFFINITY:\n+            constraint \u003d PlacementConstraints\n+                .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n+                    targetExpressions.toArray(new TargetExpression[0]))\n+                .build();\n+            break;\n+          case AFFINITY_WITH_CARDINALITY:\n+            constraint \u003d PlacementConstraints.targetCardinality(\n+                yarnServiceConstraint.getScope().name().toLowerCase(),\n+                yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n+                    : yarnServiceConstraint.getMinCardinality().intValue(),\n+                yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n+                    ? Integer.MAX_VALUE\n+                    : yarnServiceConstraint.getMaxCardinality().intValue(),\n+                targetExpressions.toArray(new TargetExpression[0])).build();\n+            break;\n+          }\n+          // The default AND-ed final composite constraint\n+          if (finalConstraint !\u003d null) {\n+            finalConstraint \u003d PlacementConstraints\n+                .and(constraint.getConstraintExpr(),\n+                    finalConstraint.getConstraintExpr())\n+                .build();\n+          } else {\n+            finalConstraint \u003d constraint;\n+          }\n+          LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n+              componentSpec.getName(),\n+              constraint.getConstraintExpr().toString());\n         }\n-        // Add all node attributes\n-        for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n-            .getNodeAttributes().entrySet()) {\n-          targetExpressions.add(PlacementTargets.nodeAttribute(\n-              attribute.getKey(), attribute.getValue().toArray(new String[0])));\n-        }\n-        // Add all node partitions\n-        if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n-          targetExpressions\n-              .add(PlacementTargets.nodePartition(yarnServiceConstraint\n-                  .getNodePartitions().toArray(new String[0])));\n-        }\n-        PlacementConstraint constraint \u003d null;\n-        switch (yarnServiceConstraint.getType()) {\n-        case AFFINITY:\n-          constraint \u003d PlacementConstraints\n-              .targetIn(yarnServiceConstraint.getScope().getValue(),\n-                  targetExpressions.toArray(new TargetExpression[0]))\n-              .build();\n-          break;\n-        case ANTI_AFFINITY:\n-          constraint \u003d PlacementConstraints\n-              .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n-                  targetExpressions.toArray(new TargetExpression[0]))\n-              .build();\n-          break;\n-        case AFFINITY_WITH_CARDINALITY:\n-          constraint \u003d PlacementConstraints.targetCardinality(\n-              yarnServiceConstraint.getScope().name().toLowerCase(),\n-              yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n-                  : yarnServiceConstraint.getMinCardinality().intValue(),\n-              yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n-                  ? Integer.MAX_VALUE\n-                  : yarnServiceConstraint.getMaxCardinality().intValue(),\n-              targetExpressions.toArray(new TargetExpression[0])).build();\n-          break;\n-        }\n-        // The default AND-ed final composite constraint\n-        if (finalConstraint !\u003d null) {\n-          finalConstraint \u003d PlacementConstraints\n-              .and(constraint.getConstraintExpr(),\n-                  finalConstraint.getConstraintExpr())\n-              .build();\n-        } else {\n-          finalConstraint \u003d constraint;\n-        }\n-        LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n-            componentSpec.getName(), constraint.getConstraintExpr().toString());\n       }\n       ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n           resource);\n       LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n           resourceSizing);\n       SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n           .priority(priority).allocationRequestId(allocateId)\n           .allocationTags(Collections.singleton(componentSpec.getName()))\n           .executionType(\n               ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n           .placementConstraintExpression(finalConstraint)\n           .resourceSizing(resourceSizing).build();\n       LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n           componentSpec.getName(), request);\n       schedulingRequests.add(request);\n       amrmClient.addSchedulingRequests(schedulingRequests);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestContainers(long count) {\n    LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n        componentSpec.getName(), count);\n    org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n        componentSpec.getResource();\n\n    Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n        componentResource.getCpus());\n\n    if (componentResource.getAdditional() !\u003d null) {\n      for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n          .getAdditional().entrySet()) {\n\n        String resourceName \u003d entry.getKey();\n\n        // Avoid setting memory/cpu under \"additional\"\n        if (resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n            || resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n          LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n              + \"ignoring this entry\u003d\" + resourceName);\n          continue;\n        }\n\n        ResourceInformation specInfo \u003d entry.getValue();\n        org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n            org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                entry.getKey(),\n                specInfo.getUnit(),\n                specInfo.getValue());\n        resource.setResourceInformation(resourceName, ri);\n      }\n    }\n\n    if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n      for (int i \u003d 0; i \u003c count; i++) {\n        ContainerRequest request \u003d ContainerRequest.newBuilder()\n            .capability(resource).priority(priority)\n            .allocationRequestId(allocateId).relaxLocality(true).build();\n        LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n            componentSpec.getName(), request);\n        amrmClient.addContainerRequest(request);\n      }\n    } else {\n      // Schedule placement requests. Validation of non-null target tags and\n      // that they refer to existing component names are already done. So, no\n      // need to validate here.\n      PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n      Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n      // We prepare an AND-ed composite constraint to be the final composite\n      // constraint. If placement expressions are specified to create advanced\n      // composite constraints then this AND-ed composite constraint is not\n      // used.\n      PlacementConstraint finalConstraint \u003d null;\n      if (placementPolicy !\u003d null) {\n        for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n            yarnServiceConstraint : placementPolicy.getConstraints()) {\n          List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n          // Currently only intra-application allocation tags are supported.\n          if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n            targetExpressions.add(PlacementTargets.allocationTag(\n                yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n          }\n          // Add all node attributes\n          for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n              .getNodeAttributes().entrySet()) {\n            targetExpressions\n                .add(PlacementTargets.nodeAttribute(attribute.getKey(),\n                    attribute.getValue().toArray(new String[0])));\n          }\n          // Add all node partitions\n          if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n            targetExpressions\n                .add(PlacementTargets.nodePartition(yarnServiceConstraint\n                    .getNodePartitions().toArray(new String[0])));\n          }\n          PlacementConstraint constraint \u003d null;\n          switch (yarnServiceConstraint.getType()) {\n          case AFFINITY:\n            constraint \u003d PlacementConstraints\n                .targetIn(yarnServiceConstraint.getScope().getValue(),\n                    targetExpressions.toArray(new TargetExpression[0]))\n                .build();\n            break;\n          case ANTI_AFFINITY:\n            constraint \u003d PlacementConstraints\n                .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n                    targetExpressions.toArray(new TargetExpression[0]))\n                .build();\n            break;\n          case AFFINITY_WITH_CARDINALITY:\n            constraint \u003d PlacementConstraints.targetCardinality(\n                yarnServiceConstraint.getScope().name().toLowerCase(),\n                yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n                    : yarnServiceConstraint.getMinCardinality().intValue(),\n                yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n                    ? Integer.MAX_VALUE\n                    : yarnServiceConstraint.getMaxCardinality().intValue(),\n                targetExpressions.toArray(new TargetExpression[0])).build();\n            break;\n          }\n          // The default AND-ed final composite constraint\n          if (finalConstraint !\u003d null) {\n            finalConstraint \u003d PlacementConstraints\n                .and(constraint.getConstraintExpr(),\n                    finalConstraint.getConstraintExpr())\n                .build();\n          } else {\n            finalConstraint \u003d constraint;\n          }\n          LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n              componentSpec.getName(),\n              constraint.getConstraintExpr().toString());\n        }\n      }\n      ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n          resource);\n      LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n          resourceSizing);\n      SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n          .priority(priority).allocationRequestId(allocateId)\n          .allocationTags(Collections.singleton(componentSpec.getName()))\n          .executionType(\n              ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n          .placementConstraintExpression(finalConstraint)\n          .resourceSizing(resourceSizing).build();\n      LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n          componentSpec.getName(), request);\n      schedulingRequests.add(request);\n      amrmClient.addSchedulingRequests(schedulingRequests);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java",
      "extendedDetails": {}
    },
    "28e2244390c990877dc2ee2733cf9b8d2c75128e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8111. Simplify PlacementConstraints API by removing allocationTagToIntraApp. Contributed by Weiwei Yang.\n",
      "commitDate": "20/04/18 12:24 PM",
      "commitName": "28e2244390c990877dc2ee2733cf9b8d2c75128e",
      "commitAuthor": "Konstantinos Karanasos",
      "commitDateOld": "16/04/18 11:24 AM",
      "commitNameOld": "2d0662cfd57bd438421f912dc172e79a15835442",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 4.04,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,129 @@\n   public void requestContainers(long count) {\n     LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n         componentSpec.getName(), count);\n     org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n         componentSpec.getResource();\n \n     Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n         componentResource.getCpus());\n \n     if (componentResource.getAdditional() !\u003d null) {\n       for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n           .getAdditional().entrySet()) {\n \n         String resourceName \u003d entry.getKey();\n \n         // Avoid setting memory/cpu under \"additional\"\n         if (resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n             || resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n           LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n               + \"ignoring this entry\u003d\" + resourceName);\n           continue;\n         }\n \n         ResourceInformation specInfo \u003d entry.getValue();\n         org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n             org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                 entry.getKey(),\n                 specInfo.getUnit(),\n                 specInfo.getValue());\n         resource.setResourceInformation(resourceName, ri);\n       }\n     }\n \n     if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n       for (int i \u003d 0; i \u003c count; i++) {\n         ContainerRequest request \u003d ContainerRequest.newBuilder()\n             .capability(resource).priority(priority)\n             .allocationRequestId(allocateId).relaxLocality(true).build();\n         LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n             componentSpec.getName(), request);\n         amrmClient.addContainerRequest(request);\n       }\n     } else {\n       // Schedule placement requests. Validation of non-null target tags and\n       // that they refer to existing component names are already done. So, no\n       // need to validate here.\n       PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n       Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n       // We prepare an AND-ed composite constraint to be the final composite\n       // constraint. If placement expressions are specified to create advanced\n       // composite constraints then this AND-ed composite constraint is not\n       // used.\n       PlacementConstraint finalConstraint \u003d null;\n       for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n           yarnServiceConstraint : placementPolicy.getConstraints()) {\n         List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n         // Currently only intra-application allocation tags are supported.\n         if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n-          targetExpressions.add(PlacementTargets.allocationTagToIntraApp(\n+          targetExpressions.add(PlacementTargets.allocationTag(\n               yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n         }\n         // Add all node attributes\n         for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n             .getNodeAttributes().entrySet()) {\n           targetExpressions.add(PlacementTargets.nodeAttribute(\n               attribute.getKey(), attribute.getValue().toArray(new String[0])));\n         }\n         // Add all node partitions\n         if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n           targetExpressions\n               .add(PlacementTargets.nodePartition(yarnServiceConstraint\n                   .getNodePartitions().toArray(new String[0])));\n         }\n         PlacementConstraint constraint \u003d null;\n         switch (yarnServiceConstraint.getType()) {\n         case AFFINITY:\n           constraint \u003d PlacementConstraints\n               .targetIn(yarnServiceConstraint.getScope().getValue(),\n                   targetExpressions.toArray(new TargetExpression[0]))\n               .build();\n           break;\n         case ANTI_AFFINITY:\n           constraint \u003d PlacementConstraints\n               .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n                   targetExpressions.toArray(new TargetExpression[0]))\n               .build();\n           break;\n         case AFFINITY_WITH_CARDINALITY:\n           constraint \u003d PlacementConstraints.targetCardinality(\n               yarnServiceConstraint.getScope().name().toLowerCase(),\n               yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n                   : yarnServiceConstraint.getMinCardinality().intValue(),\n               yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n                   ? Integer.MAX_VALUE\n                   : yarnServiceConstraint.getMaxCardinality().intValue(),\n               targetExpressions.toArray(new TargetExpression[0])).build();\n           break;\n         }\n         // The default AND-ed final composite constraint\n         if (finalConstraint !\u003d null) {\n           finalConstraint \u003d PlacementConstraints\n               .and(constraint.getConstraintExpr(),\n                   finalConstraint.getConstraintExpr())\n               .build();\n         } else {\n           finalConstraint \u003d constraint;\n         }\n         LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n             componentSpec.getName(), constraint.getConstraintExpr().toString());\n       }\n       ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n           resource);\n       LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n           resourceSizing);\n       SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n           .priority(priority).allocationRequestId(allocateId)\n           .allocationTags(Collections.singleton(componentSpec.getName()))\n           .executionType(\n               ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n           .placementConstraintExpression(finalConstraint)\n           .resourceSizing(resourceSizing).build();\n       LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n           componentSpec.getName(), request);\n       schedulingRequests.add(request);\n       amrmClient.addSchedulingRequests(schedulingRequests);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestContainers(long count) {\n    LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n        componentSpec.getName(), count);\n    org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n        componentSpec.getResource();\n\n    Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n        componentResource.getCpus());\n\n    if (componentResource.getAdditional() !\u003d null) {\n      for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n          .getAdditional().entrySet()) {\n\n        String resourceName \u003d entry.getKey();\n\n        // Avoid setting memory/cpu under \"additional\"\n        if (resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n            || resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n          LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n              + \"ignoring this entry\u003d\" + resourceName);\n          continue;\n        }\n\n        ResourceInformation specInfo \u003d entry.getValue();\n        org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n            org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                entry.getKey(),\n                specInfo.getUnit(),\n                specInfo.getValue());\n        resource.setResourceInformation(resourceName, ri);\n      }\n    }\n\n    if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n      for (int i \u003d 0; i \u003c count; i++) {\n        ContainerRequest request \u003d ContainerRequest.newBuilder()\n            .capability(resource).priority(priority)\n            .allocationRequestId(allocateId).relaxLocality(true).build();\n        LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n            componentSpec.getName(), request);\n        amrmClient.addContainerRequest(request);\n      }\n    } else {\n      // Schedule placement requests. Validation of non-null target tags and\n      // that they refer to existing component names are already done. So, no\n      // need to validate here.\n      PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n      Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n      // We prepare an AND-ed composite constraint to be the final composite\n      // constraint. If placement expressions are specified to create advanced\n      // composite constraints then this AND-ed composite constraint is not\n      // used.\n      PlacementConstraint finalConstraint \u003d null;\n      for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n          yarnServiceConstraint : placementPolicy.getConstraints()) {\n        List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n        // Currently only intra-application allocation tags are supported.\n        if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n          targetExpressions.add(PlacementTargets.allocationTag(\n              yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n        }\n        // Add all node attributes\n        for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n            .getNodeAttributes().entrySet()) {\n          targetExpressions.add(PlacementTargets.nodeAttribute(\n              attribute.getKey(), attribute.getValue().toArray(new String[0])));\n        }\n        // Add all node partitions\n        if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n          targetExpressions\n              .add(PlacementTargets.nodePartition(yarnServiceConstraint\n                  .getNodePartitions().toArray(new String[0])));\n        }\n        PlacementConstraint constraint \u003d null;\n        switch (yarnServiceConstraint.getType()) {\n        case AFFINITY:\n          constraint \u003d PlacementConstraints\n              .targetIn(yarnServiceConstraint.getScope().getValue(),\n                  targetExpressions.toArray(new TargetExpression[0]))\n              .build();\n          break;\n        case ANTI_AFFINITY:\n          constraint \u003d PlacementConstraints\n              .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n                  targetExpressions.toArray(new TargetExpression[0]))\n              .build();\n          break;\n        case AFFINITY_WITH_CARDINALITY:\n          constraint \u003d PlacementConstraints.targetCardinality(\n              yarnServiceConstraint.getScope().name().toLowerCase(),\n              yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n                  : yarnServiceConstraint.getMinCardinality().intValue(),\n              yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n                  ? Integer.MAX_VALUE\n                  : yarnServiceConstraint.getMaxCardinality().intValue(),\n              targetExpressions.toArray(new TargetExpression[0])).build();\n          break;\n        }\n        // The default AND-ed final composite constraint\n        if (finalConstraint !\u003d null) {\n          finalConstraint \u003d PlacementConstraints\n              .and(constraint.getConstraintExpr(),\n                  finalConstraint.getConstraintExpr())\n              .build();\n        } else {\n          finalConstraint \u003d constraint;\n        }\n        LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n            componentSpec.getName(), constraint.getConstraintExpr().toString());\n      }\n      ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n          resource);\n      LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n          resourceSizing);\n      SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n          .priority(priority).allocationRequestId(allocateId)\n          .allocationTags(Collections.singleton(componentSpec.getName()))\n          .executionType(\n              ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n          .placementConstraintExpression(finalConstraint)\n          .resourceSizing(resourceSizing).build();\n      LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n          componentSpec.getName(), request);\n      schedulingRequests.add(request);\n      amrmClient.addSchedulingRequests(schedulingRequests);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java",
      "extendedDetails": {}
    },
    "a0bde7d525911680f9e5fb0a939604865eb8e164": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7142. Support placement policy in yarn native services. (Gour Saha via wangda)\n\nChange-Id: I166c67a7a34430627c17365f60bac75b6da1b434\n",
      "commitDate": "02/04/18 7:26 AM",
      "commitName": "a0bde7d525911680f9e5fb0a939604865eb8e164",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/03/18 3:46 PM",
      "commitNameOld": "27d60a16342fd39973d43b61008f54a8815a6237",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 6.65,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,129 @@\n   public void requestContainers(long count) {\n+    LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n+        componentSpec.getName(), count);\n     org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n         componentSpec.getResource();\n \n     Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n         componentResource.getCpus());\n \n     if (componentResource.getAdditional() !\u003d null) {\n       for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n           .getAdditional().entrySet()) {\n \n         String resourceName \u003d entry.getKey();\n \n         // Avoid setting memory/cpu under \"additional\"\n         if (resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n             || resourceName.equals(\n             org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n           LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n               + \"ignoring this entry\u003d\" + resourceName);\n           continue;\n         }\n \n         ResourceInformation specInfo \u003d entry.getValue();\n         org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n             org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                 entry.getKey(),\n                 specInfo.getUnit(),\n                 specInfo.getValue());\n         resource.setResourceInformation(resourceName, ri);\n       }\n     }\n \n-    for (int i \u003d 0; i \u003c count; i++) {\n-      //TODO Once YARN-5468 is done, use that for anti-affinity\n-      ContainerRequest request \u003d\n-          ContainerRequest.newBuilder().capability(resource).priority(priority)\n-              .allocationRequestId(allocateId).relaxLocality(true).build();\n-      amrmClient.addContainerRequest(request);\n+    if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n+      for (int i \u003d 0; i \u003c count; i++) {\n+        ContainerRequest request \u003d ContainerRequest.newBuilder()\n+            .capability(resource).priority(priority)\n+            .allocationRequestId(allocateId).relaxLocality(true).build();\n+        LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n+            componentSpec.getName(), request);\n+        amrmClient.addContainerRequest(request);\n+      }\n+    } else {\n+      // Schedule placement requests. Validation of non-null target tags and\n+      // that they refer to existing component names are already done. So, no\n+      // need to validate here.\n+      PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n+      Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n+      // We prepare an AND-ed composite constraint to be the final composite\n+      // constraint. If placement expressions are specified to create advanced\n+      // composite constraints then this AND-ed composite constraint is not\n+      // used.\n+      PlacementConstraint finalConstraint \u003d null;\n+      for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n+          yarnServiceConstraint : placementPolicy.getConstraints()) {\n+        List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n+        // Currently only intra-application allocation tags are supported.\n+        if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n+          targetExpressions.add(PlacementTargets.allocationTagToIntraApp(\n+              yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n+        }\n+        // Add all node attributes\n+        for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n+            .getNodeAttributes().entrySet()) {\n+          targetExpressions.add(PlacementTargets.nodeAttribute(\n+              attribute.getKey(), attribute.getValue().toArray(new String[0])));\n+        }\n+        // Add all node partitions\n+        if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n+          targetExpressions\n+              .add(PlacementTargets.nodePartition(yarnServiceConstraint\n+                  .getNodePartitions().toArray(new String[0])));\n+        }\n+        PlacementConstraint constraint \u003d null;\n+        switch (yarnServiceConstraint.getType()) {\n+        case AFFINITY:\n+          constraint \u003d PlacementConstraints\n+              .targetIn(yarnServiceConstraint.getScope().getValue(),\n+                  targetExpressions.toArray(new TargetExpression[0]))\n+              .build();\n+          break;\n+        case ANTI_AFFINITY:\n+          constraint \u003d PlacementConstraints\n+              .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n+                  targetExpressions.toArray(new TargetExpression[0]))\n+              .build();\n+          break;\n+        case AFFINITY_WITH_CARDINALITY:\n+          constraint \u003d PlacementConstraints.targetCardinality(\n+              yarnServiceConstraint.getScope().name().toLowerCase(),\n+              yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n+                  : yarnServiceConstraint.getMinCardinality().intValue(),\n+              yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n+                  ? Integer.MAX_VALUE\n+                  : yarnServiceConstraint.getMaxCardinality().intValue(),\n+              targetExpressions.toArray(new TargetExpression[0])).build();\n+          break;\n+        }\n+        // The default AND-ed final composite constraint\n+        if (finalConstraint !\u003d null) {\n+          finalConstraint \u003d PlacementConstraints\n+              .and(constraint.getConstraintExpr(),\n+                  finalConstraint.getConstraintExpr())\n+              .build();\n+        } else {\n+          finalConstraint \u003d constraint;\n+        }\n+        LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n+            componentSpec.getName(), constraint.getConstraintExpr().toString());\n+      }\n+      ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n+          resource);\n+      LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n+          resourceSizing);\n+      SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n+          .priority(priority).allocationRequestId(allocateId)\n+          .allocationTags(Collections.singleton(componentSpec.getName()))\n+          .executionType(\n+              ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n+          .placementConstraintExpression(finalConstraint)\n+          .resourceSizing(resourceSizing).build();\n+      LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n+          componentSpec.getName(), request);\n+      schedulingRequests.add(request);\n+      amrmClient.addSchedulingRequests(schedulingRequests);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestContainers(long count) {\n    LOG.info(\"[COMPONENT {}] Requesting for {} container(s)\",\n        componentSpec.getName(), count);\n    org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n        componentSpec.getResource();\n\n    Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n        componentResource.getCpus());\n\n    if (componentResource.getAdditional() !\u003d null) {\n      for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n          .getAdditional().entrySet()) {\n\n        String resourceName \u003d entry.getKey();\n\n        // Avoid setting memory/cpu under \"additional\"\n        if (resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n            || resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n          LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n              + \"ignoring this entry\u003d\" + resourceName);\n          continue;\n        }\n\n        ResourceInformation specInfo \u003d entry.getValue();\n        org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n            org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                entry.getKey(),\n                specInfo.getUnit(),\n                specInfo.getValue());\n        resource.setResourceInformation(resourceName, ri);\n      }\n    }\n\n    if (!scheduler.hasAtLeastOnePlacementConstraint()) {\n      for (int i \u003d 0; i \u003c count; i++) {\n        ContainerRequest request \u003d ContainerRequest.newBuilder()\n            .capability(resource).priority(priority)\n            .allocationRequestId(allocateId).relaxLocality(true).build();\n        LOG.info(\"[COMPONENT {}] Submitting container request : {}\",\n            componentSpec.getName(), request);\n        amrmClient.addContainerRequest(request);\n      }\n    } else {\n      // Schedule placement requests. Validation of non-null target tags and\n      // that they refer to existing component names are already done. So, no\n      // need to validate here.\n      PlacementPolicy placementPolicy \u003d componentSpec.getPlacementPolicy();\n      Collection\u003cSchedulingRequest\u003e schedulingRequests \u003d new HashSet\u003c\u003e();\n      // We prepare an AND-ed composite constraint to be the final composite\n      // constraint. If placement expressions are specified to create advanced\n      // composite constraints then this AND-ed composite constraint is not\n      // used.\n      PlacementConstraint finalConstraint \u003d null;\n      for (org.apache.hadoop.yarn.service.api.records.PlacementConstraint\n          yarnServiceConstraint : placementPolicy.getConstraints()) {\n        List\u003cTargetExpression\u003e targetExpressions \u003d new ArrayList\u003c\u003e();\n        // Currently only intra-application allocation tags are supported.\n        if (!yarnServiceConstraint.getTargetTags().isEmpty()) {\n          targetExpressions.add(PlacementTargets.allocationTagToIntraApp(\n              yarnServiceConstraint.getTargetTags().toArray(new String[0])));\n        }\n        // Add all node attributes\n        for (Map.Entry\u003cString, List\u003cString\u003e\u003e attribute : yarnServiceConstraint\n            .getNodeAttributes().entrySet()) {\n          targetExpressions.add(PlacementTargets.nodeAttribute(\n              attribute.getKey(), attribute.getValue().toArray(new String[0])));\n        }\n        // Add all node partitions\n        if (!yarnServiceConstraint.getNodePartitions().isEmpty()) {\n          targetExpressions\n              .add(PlacementTargets.nodePartition(yarnServiceConstraint\n                  .getNodePartitions().toArray(new String[0])));\n        }\n        PlacementConstraint constraint \u003d null;\n        switch (yarnServiceConstraint.getType()) {\n        case AFFINITY:\n          constraint \u003d PlacementConstraints\n              .targetIn(yarnServiceConstraint.getScope().getValue(),\n                  targetExpressions.toArray(new TargetExpression[0]))\n              .build();\n          break;\n        case ANTI_AFFINITY:\n          constraint \u003d PlacementConstraints\n              .targetNotIn(yarnServiceConstraint.getScope().getValue(),\n                  targetExpressions.toArray(new TargetExpression[0]))\n              .build();\n          break;\n        case AFFINITY_WITH_CARDINALITY:\n          constraint \u003d PlacementConstraints.targetCardinality(\n              yarnServiceConstraint.getScope().name().toLowerCase(),\n              yarnServiceConstraint.getMinCardinality() \u003d\u003d null ? 0\n                  : yarnServiceConstraint.getMinCardinality().intValue(),\n              yarnServiceConstraint.getMaxCardinality() \u003d\u003d null\n                  ? Integer.MAX_VALUE\n                  : yarnServiceConstraint.getMaxCardinality().intValue(),\n              targetExpressions.toArray(new TargetExpression[0])).build();\n          break;\n        }\n        // The default AND-ed final composite constraint\n        if (finalConstraint !\u003d null) {\n          finalConstraint \u003d PlacementConstraints\n              .and(constraint.getConstraintExpr(),\n                  finalConstraint.getConstraintExpr())\n              .build();\n        } else {\n          finalConstraint \u003d constraint;\n        }\n        LOG.debug(\"[COMPONENT {}] Placement constraint: {}\",\n            componentSpec.getName(), constraint.getConstraintExpr().toString());\n      }\n      ResourceSizing resourceSizing \u003d ResourceSizing.newInstance((int) count,\n          resource);\n      LOG.debug(\"[COMPONENT {}] Resource sizing: {}\", componentSpec.getName(),\n          resourceSizing);\n      SchedulingRequest request \u003d SchedulingRequest.newBuilder()\n          .priority(priority).allocationRequestId(allocateId)\n          .allocationTags(Collections.singleton(componentSpec.getName()))\n          .executionType(\n              ExecutionTypeRequest.newInstance(ExecutionType.GUARANTEED, true))\n          .placementConstraintExpression(finalConstraint)\n          .resourceSizing(resourceSizing).build();\n      LOG.info(\"[COMPONENT {}] Submitting scheduling request: {}\",\n          componentSpec.getName(), request);\n      schedulingRequests.add(request);\n      amrmClient.addSchedulingRequests(schedulingRequests);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java",
      "extendedDetails": {}
    },
    "7467e8fe5a95230986fed9d748769304af3f2b61": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7555. Support multiple resource types in YARN native services. (wangda)\n\nChange-Id: I330e6ee17a73962dcaadd766a3e72d2888681731\n",
      "commitDate": "29/12/17 3:34 PM",
      "commitName": "7467e8fe5a95230986fed9d748769304af3f2b61",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "19/12/17 4:14 PM",
      "commitNameOld": "41b581012a83a17db785343362c718363e13e8f5",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 9.97,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,41 @@\n   public void requestContainers(long count) {\n-    Resource resource \u003d Resource\n-        .newInstance(componentSpec.getResource().calcMemoryMB(),\n-            componentSpec.getResource().getCpus());\n+    org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n+        componentSpec.getResource();\n+\n+    Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n+        componentResource.getCpus());\n+\n+    if (componentResource.getAdditional() !\u003d null) {\n+      for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n+          .getAdditional().entrySet()) {\n+\n+        String resourceName \u003d entry.getKey();\n+\n+        // Avoid setting memory/cpu under \"additional\"\n+        if (resourceName.equals(\n+            org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n+            || resourceName.equals(\n+            org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n+          LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n+              + \"ignoring this entry\u003d\" + resourceName);\n+          continue;\n+        }\n+\n+        ResourceInformation specInfo \u003d entry.getValue();\n+        org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n+            org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n+                entry.getKey(),\n+                specInfo.getUnit(),\n+                specInfo.getValue());\n+        resource.setResourceInformation(resourceName, ri);\n+      }\n+    }\n \n     for (int i \u003d 0; i \u003c count; i++) {\n       //TODO Once YARN-5468 is done, use that for anti-affinity\n       ContainerRequest request \u003d\n           ContainerRequest.newBuilder().capability(resource).priority(priority)\n               .allocationRequestId(allocateId).relaxLocality(true).build();\n       amrmClient.addContainerRequest(request);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestContainers(long count) {\n    org.apache.hadoop.yarn.service.api.records.Resource componentResource \u003d\n        componentSpec.getResource();\n\n    Resource resource \u003d Resource.newInstance(componentResource.calcMemoryMB(),\n        componentResource.getCpus());\n\n    if (componentResource.getAdditional() !\u003d null) {\n      for (Map.Entry\u003cString, ResourceInformation\u003e entry : componentResource\n          .getAdditional().entrySet()) {\n\n        String resourceName \u003d entry.getKey();\n\n        // Avoid setting memory/cpu under \"additional\"\n        if (resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.MEMORY_URI)\n            || resourceName.equals(\n            org.apache.hadoop.yarn.api.records.ResourceInformation.VCORES_URI)) {\n          LOG.warn(\"Please set memory/vcore in the main section of resource, \"\n              + \"ignoring this entry\u003d\" + resourceName);\n          continue;\n        }\n\n        ResourceInformation specInfo \u003d entry.getValue();\n        org.apache.hadoop.yarn.api.records.ResourceInformation ri \u003d\n            org.apache.hadoop.yarn.api.records.ResourceInformation.newInstance(\n                entry.getKey(),\n                specInfo.getUnit(),\n                specInfo.getValue());\n        resource.setResourceInformation(resourceName, ri);\n      }\n    }\n\n    for (int i \u003d 0; i \u003c count; i++) {\n      //TODO Once YARN-5468 is done, use that for anti-affinity\n      ContainerRequest request \u003d\n          ContainerRequest.newBuilder().capability(resource).priority(priority)\n              .allocationRequestId(allocateId).relaxLocality(true).build();\n      amrmClient.addContainerRequest(request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java",
      "extendedDetails": {}
    },
    "438c1d333ebc0a3071bb556532ed959a4bd1e6d6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7540.  Route YARN service CLI function through YARN Service API. (Contributed by Eric Yang)\n",
      "commitDate": "13/12/17 4:29 PM",
      "commitName": "438c1d333ebc0a3071bb556532ed959a4bd1e6d6",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "12/12/17 1:35 PM",
      "commitNameOld": "3ebe6a7819292ce6bd557e36137531b59890c845",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,13 @@\n   public void requestContainers(long count) {\n     Resource resource \u003d Resource\n-        .newInstance(componentSpec.getResource().getMemoryMB(),\n+        .newInstance(componentSpec.getResource().calcMemoryMB(),\n             componentSpec.getResource().getCpus());\n \n     for (int i \u003d 0; i \u003c count; i++) {\n       //TODO Once YARN-5468 is done, use that for anti-affinity\n       ContainerRequest request \u003d\n           ContainerRequest.newBuilder().capability(resource).priority(priority)\n               .allocationRequestId(allocateId).relaxLocality(true).build();\n       amrmClient.addContainerRequest(request);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestContainers(long count) {\n    Resource resource \u003d Resource\n        .newInstance(componentSpec.getResource().calcMemoryMB(),\n            componentSpec.getResource().getCpus());\n\n    for (int i \u003d 0; i \u003c count; i++) {\n      //TODO Once YARN-5468 is done, use that for anti-affinity\n      ContainerRequest request \u003d\n          ContainerRequest.newBuilder().capability(resource).priority(priority)\n              .allocationRequestId(allocateId).relaxLocality(true).build();\n      amrmClient.addContainerRequest(request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java",
      "extendedDetails": {}
    },
    "40ab068eabe50875449d601471619a4e82fff86d": {
      "type": "Yfilerename",
      "commitMessage": "YARN-7091. Rename application to service in yarn-native-services. Contributed by Jian He\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "40ab068eabe50875449d601471619a4e82fff86d",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "06/11/17 1:30 PM",
      "commitNameOld": "2ba38ce8ecb1cf3836fab48cdb2c5ae7e1b5427d",
      "commitAuthorOld": "Gour Saha",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void requestContainers(long count) {\n    Resource resource \u003d Resource\n        .newInstance(componentSpec.getResource().getMemoryMB(),\n            componentSpec.getResource().getCpus());\n\n    for (int i \u003d 0; i \u003c count; i++) {\n      //TODO Once YARN-5468 is done, use that for anti-affinity\n      ContainerRequest request \u003d\n          ContainerRequest.newBuilder().capability(resource).priority(priority)\n              .allocationRequestId(allocateId).relaxLocality(true).build();\n      amrmClient.addContainerRequest(request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java"
      }
    },
    "1888318c89776f0bf354c1b13e3ee169e14ff638": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6903. Yarn-native-service framework core rewrite. Contributed by Jian He\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "1888318c89776f0bf354c1b13e3ee169e14ff638",
      "commitAuthor": "Billie Rinaldi",
      "diff": "@@ -0,0 +1,13 @@\n+  public void requestContainers(long count) {\n+    Resource resource \u003d Resource\n+        .newInstance(componentSpec.getResource().getMemoryMB(),\n+            componentSpec.getResource().getCpus());\n+\n+    for (int i \u003d 0; i \u003c count; i++) {\n+      //TODO Once YARN-5468 is done, use that for anti-affinity\n+      ContainerRequest request \u003d\n+          ContainerRequest.newBuilder().capability(resource).priority(priority)\n+              .allocationRequestId(allocateId).relaxLocality(true).build();\n+      amrmClient.addContainerRequest(request);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestContainers(long count) {\n    Resource resource \u003d Resource\n        .newInstance(componentSpec.getResource().getMemoryMB(),\n            componentSpec.getResource().getCpus());\n\n    for (int i \u003d 0; i \u003c count; i++) {\n      //TODO Once YARN-5468 is done, use that for anti-affinity\n      ContainerRequest request \u003d\n          ContainerRequest.newBuilder().capability(resource).priority(priority)\n              .allocationRequestId(allocateId).relaxLocality(true).build();\n      amrmClient.addContainerRequest(request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/hadoop/yarn/service/component/Component.java"
    }
  }
}