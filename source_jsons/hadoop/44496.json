{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ApplicationMaster.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
  "functionStartLine": 1880,
  "functionEndLine": 1883,
  "numCommitsSeen": 121,
  "timeTaken": 6690,
  "changeHistory": [
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
    "0d02ab8729630ad3cfb4300702927333b1d349e3",
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
    "f291d82cd49c04a81380bc45c97c279d791b571c",
    "f385851141522633184ce394899c659af5ace92a",
    "1d4612f5ad9678c952b416e798dccd20c88f96ef",
    "6c2a0ce30b8bc54998ec40551bc14f478a353e10",
    "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb",
    "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f",
    "f104665f7ed8749e563b7512e5846f910676a324",
    "42c3cd3d137ba1de1c0573c0bb655fa380ed9412",
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a",
    "b503b6a07d7210c94657131dcd97239012ecb313",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "2692675fc3b5046d2ec88542c30203c87e135b70",
    "259edf8dca44de54033e96f7eb65a83aaa6096f2",
    "9eb53b9c841233538a51e4e854b261536c0b85d4",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
    "55865f42c43c8e8c6282952722a06f2a58f0c264",
    "f5551bf8091c11586d402cdd4a0b09aa0498b673",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "daa28cc6ce23ef5c8db8b9f896f342cb770dd092",
    "4e1d5a0d71d4bdde0d8b7b4c2a9571279496daaa",
    "fad230a49d0d4cdbb2062b10c3dea6c755737db5"
  ],
  "changeHistoryShort": {
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": "Ybodychange",
    "0d02ab8729630ad3cfb4300702927333b1d349e3": "Ybodychange",
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
    "f291d82cd49c04a81380bc45c97c279d791b571c": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
    "f385851141522633184ce394899c659af5ace92a": "Ybodychange",
    "1d4612f5ad9678c952b416e798dccd20c88f96ef": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
    "6c2a0ce30b8bc54998ec40551bc14f478a353e10": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
    "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb": "Ybodychange",
    "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f": "Ybodychange",
    "f104665f7ed8749e563b7512e5846f910676a324": "Ybodychange",
    "42c3cd3d137ba1de1c0573c0bb655fa380ed9412": "Ybodychange",
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a": "Ybodychange",
    "b503b6a07d7210c94657131dcd97239012ecb313": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Ybodychange",
    "2692675fc3b5046d2ec88542c30203c87e135b70": "Ybodychange",
    "259edf8dca44de54033e96f7eb65a83aaa6096f2": "Ybodychange",
    "9eb53b9c841233538a51e4e854b261536c0b85d4": "Ybodychange",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": "Ybodychange",
    "55865f42c43c8e8c6282952722a06f2a58f0c264": "Ybodychange",
    "f5551bf8091c11586d402cdd4a0b09aa0498b673": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "daa28cc6ce23ef5c8db8b9f896f342cb770dd092": "Ybodychange",
    "4e1d5a0d71d4bdde0d8b7b4c2a9571279496daaa": "Ybodychange",
    "fad230a49d0d4cdbb2062b10c3dea6c755737db5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4675. Reorganize TimelineClient and TimelineClientImpl into separate classes for ATSv1.x and ATSv2. Contributed by Naganarasimha G R.\n",
      "commitDate": "16/02/17 11:41 AM",
      "commitName": "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "06/01/17 2:26 PM",
      "commitNameOld": "71a4acf74bc9ca34f0e57835c9d6e3efbe7c0567",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 40.89,
      "commitsBetweenForRepo": 204,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,4 +1,4 @@\n         public TimelinePutResponse run() throws Exception {\n-          timelineClient.putEntitiesAsync(entity);\n+          timelineV2Client.putEntitiesAsync(entity);\n           return null;\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public TimelinePutResponse run() throws Exception {\n          timelineV2Client.putEntitiesAsync(entity);\n          return null;\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "0d02ab8729630ad3cfb4300702927333b1d349e3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3367. Replace starting a separate thread for post entity with event loop in TimelineClient (Naganarasimha G R via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "0d02ab8729630ad3cfb4300702927333b1d349e3",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,4 +1,4 @@\n         public TimelinePutResponse run() throws Exception {\n-          timelineClient.putEntities(entity);\n+          timelineClient.putEntitiesAsync(entity);\n           return null;\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public TimelinePutResponse run() throws Exception {\n          timelineClient.putEntitiesAsync(entity);\n          return null;\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c": {
      "type": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-3125. Made the distributed shell use timeline service next gen and add an integration test for it. Contributed by Junping Du and Li Lu.\n\n(cherry picked from commit bf08f7f0ed4900ce52f98137297dd1a47ba2a536)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
      "commitAuthor": "Zhijie Shen",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-3125. Made the distributed shell use timeline service next gen and add an integration test for it. Contributed by Junping Du and Li Lu.\n\n(cherry picked from commit bf08f7f0ed4900ce52f98137297dd1a47ba2a536)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "09/07/16 5:09 AM",
          "commitNameOld": "9bdb5bebea1183ec2f697ee3e55392df4fe697bb",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 1.15,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,4 @@\n-      public Void run() throws IOException {\n-        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n-        fs.rename(new Path(scriptPath), renamedScriptPath);\n-        return null;\n-      }\n\\ No newline at end of file\n+        public TimelinePutResponse run() throws Exception {\n+          timelineClient.putEntities(entity);\n+          return null;\n+        }\n\\ No newline at end of file\n",
          "actualSource": "        public TimelinePutResponse run() throws Exception {\n          timelineClient.putEntities(entity);\n          return null;\n        }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {
            "oldValue": "Void",
            "newValue": "TimelinePutResponse"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-3125. Made the distributed shell use timeline service next gen and add an integration test for it. Contributed by Junping Du and Li Lu.\n\n(cherry picked from commit bf08f7f0ed4900ce52f98137297dd1a47ba2a536)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "09/07/16 5:09 AM",
          "commitNameOld": "9bdb5bebea1183ec2f697ee3e55392df4fe697bb",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 1.15,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,4 @@\n-      public Void run() throws IOException {\n-        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n-        fs.rename(new Path(scriptPath), renamedScriptPath);\n-        return null;\n-      }\n\\ No newline at end of file\n+        public TimelinePutResponse run() throws Exception {\n+          timelineClient.putEntities(entity);\n+          return null;\n+        }\n\\ No newline at end of file\n",
          "actualSource": "        public TimelinePutResponse run() throws Exception {\n          timelineClient.putEntities(entity);\n          return null;\n        }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[Exception]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3125. Made the distributed shell use timeline service next gen and add an integration test for it. Contributed by Junping Du and Li Lu.\n\n(cherry picked from commit bf08f7f0ed4900ce52f98137297dd1a47ba2a536)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "09/07/16 5:09 AM",
          "commitNameOld": "9bdb5bebea1183ec2f697ee3e55392df4fe697bb",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 1.15,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,4 @@\n-      public Void run() throws IOException {\n-        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n-        fs.rename(new Path(scriptPath), renamedScriptPath);\n-        return null;\n-      }\n\\ No newline at end of file\n+        public TimelinePutResponse run() throws Exception {\n+          timelineClient.putEntities(entity);\n+          return null;\n+        }\n\\ No newline at end of file\n",
          "actualSource": "        public TimelinePutResponse run() throws Exception {\n          timelineClient.putEntities(entity);\n          return null;\n        }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {}
        }
      ]
    },
    "f291d82cd49c04a81380bc45c97c279d791b571c": {
      "type": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-4545. Allow YARN distributed shell to use ATS v1.5 APIs. Li Lu via junping_du\n",
      "commitDate": "14/03/16 8:28 AM",
      "commitName": "f291d82cd49c04a81380bc45c97c279d791b571c",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-4545. Allow YARN distributed shell to use ATS v1.5 APIs. Li Lu via junping_du\n",
          "commitDate": "14/03/16 8:28 AM",
          "commitName": "f291d82cd49c04a81380bc45c97c279d791b571c",
          "commitAuthor": "Junping Du",
          "commitDateOld": "18/01/16 4:58 PM",
          "commitNameOld": "f385851141522633184ce394899c659af5ace92a",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 55.6,
          "commitsBetweenForRepo": 377,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,4 +1,5 @@\n-        public TimelinePutResponse run() throws Exception {\n-          return processTimelineResponseErrors(\n-              timelineClient.putEntities(entity));\n-        }\n\\ No newline at end of file\n+      public Void run() throws IOException {\n+        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n+        fs.rename(new Path(scriptPath), renamedScriptPath);\n+        return null;\n+      }\n\\ No newline at end of file\n",
          "actualSource": "      public Void run() throws IOException {\n        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n        fs.rename(new Path(scriptPath), renamedScriptPath);\n        return null;\n      }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {
            "oldValue": "TimelinePutResponse",
            "newValue": "Void"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-4545. Allow YARN distributed shell to use ATS v1.5 APIs. Li Lu via junping_du\n",
          "commitDate": "14/03/16 8:28 AM",
          "commitName": "f291d82cd49c04a81380bc45c97c279d791b571c",
          "commitAuthor": "Junping Du",
          "commitDateOld": "18/01/16 4:58 PM",
          "commitNameOld": "f385851141522633184ce394899c659af5ace92a",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 55.6,
          "commitsBetweenForRepo": 377,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,4 +1,5 @@\n-        public TimelinePutResponse run() throws Exception {\n-          return processTimelineResponseErrors(\n-              timelineClient.putEntities(entity));\n-        }\n\\ No newline at end of file\n+      public Void run() throws IOException {\n+        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n+        fs.rename(new Path(scriptPath), renamedScriptPath);\n+        return null;\n+      }\n\\ No newline at end of file\n",
          "actualSource": "      public Void run() throws IOException {\n        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n        fs.rename(new Path(scriptPath), renamedScriptPath);\n        return null;\n      }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {
            "oldValue": "[Exception]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4545. Allow YARN distributed shell to use ATS v1.5 APIs. Li Lu via junping_du\n",
          "commitDate": "14/03/16 8:28 AM",
          "commitName": "f291d82cd49c04a81380bc45c97c279d791b571c",
          "commitAuthor": "Junping Du",
          "commitDateOld": "18/01/16 4:58 PM",
          "commitNameOld": "f385851141522633184ce394899c659af5ace92a",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 55.6,
          "commitsBetweenForRepo": 377,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,4 +1,5 @@\n-        public TimelinePutResponse run() throws Exception {\n-          return processTimelineResponseErrors(\n-              timelineClient.putEntities(entity));\n-        }\n\\ No newline at end of file\n+      public Void run() throws IOException {\n+        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n+        fs.rename(new Path(scriptPath), renamedScriptPath);\n+        return null;\n+      }\n\\ No newline at end of file\n",
          "actualSource": "      public Void run() throws IOException {\n        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n        fs.rename(new Path(scriptPath), renamedScriptPath);\n        return null;\n      }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {}
        }
      ]
    },
    "f385851141522633184ce394899c659af5ace92a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4596. SystemMetricPublisher should not swallow error messages from TimelineClient#putEntities. Contributed by Li Lu\n",
      "commitDate": "18/01/16 4:58 PM",
      "commitName": "f385851141522633184ce394899c659af5ace92a",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/11/15 11:50 AM",
      "commitNameOld": "7ff280fca9af45b98cee2336e78803da46b0f8a5",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 67.21,
      "commitsBetweenForRepo": 393,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,3 +1,4 @@\n         public TimelinePutResponse run() throws Exception {\n-          return timelineClient.putEntities(entity);\n+          return processTimelineResponseErrors(\n+              timelineClient.putEntities(entity));\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public TimelinePutResponse run() throws Exception {\n          return processTimelineResponseErrors(\n              timelineClient.putEntities(entity));\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "1d4612f5ad9678c952b416e798dccd20c88f96ef": {
      "type": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-2629. Made the distributed shell use the domain-based timeline ACLs. Contributed by Zhijie Shen.\n",
      "commitDate": "09/10/14 12:59 PM",
      "commitName": "1d4612f5ad9678c952b416e798dccd20c88f96ef",
      "commitAuthor": "Zhijie Shen",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-2629. Made the distributed shell use the domain-based timeline ACLs. Contributed by Zhijie Shen.\n",
          "commitDate": "09/10/14 12:59 PM",
          "commitName": "1d4612f5ad9678c952b416e798dccd20c88f96ef",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "01/10/14 3:38 PM",
          "commitNameOld": "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 7.89,
          "commitsBetweenForRepo": 72,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,3 @@\n-      public Void run() throws IOException {\n-        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n-        fs.rename(new Path(scriptPath), renamedScriptPath);\n-        return null;\n-      }\n\\ No newline at end of file\n+        public TimelinePutResponse run() throws Exception {\n+          return timelineClient.putEntities(entity);\n+        }\n\\ No newline at end of file\n",
          "actualSource": "        public TimelinePutResponse run() throws Exception {\n          return timelineClient.putEntities(entity);\n        }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {
            "oldValue": "Void",
            "newValue": "TimelinePutResponse"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-2629. Made the distributed shell use the domain-based timeline ACLs. Contributed by Zhijie Shen.\n",
          "commitDate": "09/10/14 12:59 PM",
          "commitName": "1d4612f5ad9678c952b416e798dccd20c88f96ef",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "01/10/14 3:38 PM",
          "commitNameOld": "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 7.89,
          "commitsBetweenForRepo": 72,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,3 @@\n-      public Void run() throws IOException {\n-        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n-        fs.rename(new Path(scriptPath), renamedScriptPath);\n-        return null;\n-      }\n\\ No newline at end of file\n+        public TimelinePutResponse run() throws Exception {\n+          return timelineClient.putEntities(entity);\n+        }\n\\ No newline at end of file\n",
          "actualSource": "        public TimelinePutResponse run() throws Exception {\n          return timelineClient.putEntities(entity);\n        }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[Exception]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2629. Made the distributed shell use the domain-based timeline ACLs. Contributed by Zhijie Shen.\n",
          "commitDate": "09/10/14 12:59 PM",
          "commitName": "1d4612f5ad9678c952b416e798dccd20c88f96ef",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "01/10/14 3:38 PM",
          "commitNameOld": "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 7.89,
          "commitsBetweenForRepo": 72,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,3 @@\n-      public Void run() throws IOException {\n-        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n-        fs.rename(new Path(scriptPath), renamedScriptPath);\n-        return null;\n-      }\n\\ No newline at end of file\n+        public TimelinePutResponse run() throws Exception {\n+          return timelineClient.putEntities(entity);\n+        }\n\\ No newline at end of file\n",
          "actualSource": "        public TimelinePutResponse run() throws Exception {\n          return timelineClient.putEntities(entity);\n        }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {}
        }
      ]
    },
    "6c2a0ce30b8bc54998ec40551bc14f478a353e10": {
      "type": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-1908. Fixed DistributedShell to not fail in secure clusters. Contributed by Vinod Kumar Vavilapalli and Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1585849 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/04/14 3:11 PM",
      "commitName": "6c2a0ce30b8bc54998ec40551bc14f478a353e10",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-1908. Fixed DistributedShell to not fail in secure clusters. Contributed by Vinod Kumar Vavilapalli and Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1585849 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/04/14 3:11 PM",
          "commitName": "6c2a0ce30b8bc54998ec40551bc14f478a353e10",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "18/03/14 8:49 PM",
          "commitNameOld": "fd1c424548999cb8843f40cb6a342387f98bde6c",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 20.77,
          "commitsBetweenForRepo": 131,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,5 @@\n-    public void run() {\n-      LOG.info(\"Setting up container launch container for containerid\u003d\"\n-          + container.getId());\n-      ContainerLaunchContext ctx \u003d Records\n-          .newRecord(ContainerLaunchContext.class);\n-\n-      // Set the environment\n-      ctx.setEnvironment(shellEnv);\n-\n-      // Set the local resources\n-      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n-\n-      // The container for the eventual shell commands needs its own local\n-      // resources too.\n-      // In this scenario, if a shell script is specified, we need to have it\n-      // copied and made available to the container.\n-      if (!shellScriptPath.isEmpty()) {\n-        Path renamedSchellScriptPath \u003d null;\n-        if (Shell.WINDOWS) {\n-          renamedSchellScriptPath \u003d new Path(shellScriptPath + \".bat\");\n-        } else {\n-          renamedSchellScriptPath \u003d new Path(shellScriptPath + \".sh\");\n-        }\n-        try {\n-          FileSystem fs \u003d renamedSchellScriptPath.getFileSystem(conf);\n-          fs.rename(new Path(shellScriptPath), renamedSchellScriptPath);\n-        } catch (IOException e) {\n-          LOG.warn(\"Not able to add suffix (.bat/.sh) to the shell script filename\");\n-          throw new YarnRuntimeException(e);\n-        }\n-\n-        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n-        shellRsrc.setType(LocalResourceType.FILE);\n-        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n-        try {\n-          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n-            renamedSchellScriptPath.toString())));\n-        } catch (URISyntaxException e) {\n-          LOG.error(\"Error when trying to use shell script path specified\"\n-              + \" in env, path\u003d\" + renamedSchellScriptPath);\n-          e.printStackTrace();\n-\n-          // A failure scenario on bad input such as invalid shell script path\n-          // We know we cannot continue launching the container\n-          // so we should release it.\n-          // TODO\n-          numCompletedContainers.incrementAndGet();\n-          numFailedContainers.incrementAndGet();\n-          return;\n-        }\n-        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n-        shellRsrc.setSize(shellScriptPathLen);\n-        localResources.put(Shell.WINDOWS ? ExecBatScripStringtPath :\n-            ExecShellStringPath, shellRsrc);\n-        shellCommand \u003d Shell.WINDOWS ? windows_command : linux_bash_command;\n-      }\n-      ctx.setLocalResources(localResources);\n-\n-      // Set the necessary command to execute on the allocated container\n-      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n-\n-      // Set executable command\n-      vargs.add(shellCommand);\n-      // Set shell script path\n-      if (!shellScriptPath.isEmpty()) {\n-        vargs.add(Shell.WINDOWS ? ExecBatScripStringtPath\n-            : ExecShellStringPath);\n-      }\n-\n-      // Set args for the shell command if any\n-      vargs.add(shellArgs);\n-      // Add log redirect params\n-      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n-      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n-\n-      // Get final commmand\n-      StringBuilder command \u003d new StringBuilder();\n-      for (CharSequence str : vargs) {\n-        command.append(str).append(\" \");\n-      }\n-\n-      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n-      commands.add(command.toString());\n-      ctx.setCommands(commands);\n-\n-      // Set up tokens for the container too. Today, for normal shell commands,\n-      // the container in distribute-shell doesn\u0027t need any tokens. We are\n-      // populating them mainly for NodeManagers to be able to download any\n-      // files in the distributed file-system. The tokens are otherwise also\n-      // useful in cases, for e.g., when one is running a \"hadoop dfs\" command\n-      // inside the distributed shell.\n-      ctx.setTokens(allTokens.duplicate());\n-\n-      containerListener.addContainer(container.getId(), container);\n-      nmClientAsync.startContainerAsync(container, ctx);\n-    }\n\\ No newline at end of file\n+      public Void run() throws IOException {\n+        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n+        fs.rename(new Path(scriptPath), renamedScriptPath);\n+        return null;\n+      }\n\\ No newline at end of file\n",
          "actualSource": "      public Void run() throws IOException {\n        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n        fs.rename(new Path(scriptPath), renamedScriptPath);\n        return null;\n      }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "Void"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-1908. Fixed DistributedShell to not fail in secure clusters. Contributed by Vinod Kumar Vavilapalli and Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1585849 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/04/14 3:11 PM",
          "commitName": "6c2a0ce30b8bc54998ec40551bc14f478a353e10",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "18/03/14 8:49 PM",
          "commitNameOld": "fd1c424548999cb8843f40cb6a342387f98bde6c",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 20.77,
          "commitsBetweenForRepo": 131,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,5 @@\n-    public void run() {\n-      LOG.info(\"Setting up container launch container for containerid\u003d\"\n-          + container.getId());\n-      ContainerLaunchContext ctx \u003d Records\n-          .newRecord(ContainerLaunchContext.class);\n-\n-      // Set the environment\n-      ctx.setEnvironment(shellEnv);\n-\n-      // Set the local resources\n-      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n-\n-      // The container for the eventual shell commands needs its own local\n-      // resources too.\n-      // In this scenario, if a shell script is specified, we need to have it\n-      // copied and made available to the container.\n-      if (!shellScriptPath.isEmpty()) {\n-        Path renamedSchellScriptPath \u003d null;\n-        if (Shell.WINDOWS) {\n-          renamedSchellScriptPath \u003d new Path(shellScriptPath + \".bat\");\n-        } else {\n-          renamedSchellScriptPath \u003d new Path(shellScriptPath + \".sh\");\n-        }\n-        try {\n-          FileSystem fs \u003d renamedSchellScriptPath.getFileSystem(conf);\n-          fs.rename(new Path(shellScriptPath), renamedSchellScriptPath);\n-        } catch (IOException e) {\n-          LOG.warn(\"Not able to add suffix (.bat/.sh) to the shell script filename\");\n-          throw new YarnRuntimeException(e);\n-        }\n-\n-        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n-        shellRsrc.setType(LocalResourceType.FILE);\n-        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n-        try {\n-          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n-            renamedSchellScriptPath.toString())));\n-        } catch (URISyntaxException e) {\n-          LOG.error(\"Error when trying to use shell script path specified\"\n-              + \" in env, path\u003d\" + renamedSchellScriptPath);\n-          e.printStackTrace();\n-\n-          // A failure scenario on bad input such as invalid shell script path\n-          // We know we cannot continue launching the container\n-          // so we should release it.\n-          // TODO\n-          numCompletedContainers.incrementAndGet();\n-          numFailedContainers.incrementAndGet();\n-          return;\n-        }\n-        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n-        shellRsrc.setSize(shellScriptPathLen);\n-        localResources.put(Shell.WINDOWS ? ExecBatScripStringtPath :\n-            ExecShellStringPath, shellRsrc);\n-        shellCommand \u003d Shell.WINDOWS ? windows_command : linux_bash_command;\n-      }\n-      ctx.setLocalResources(localResources);\n-\n-      // Set the necessary command to execute on the allocated container\n-      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n-\n-      // Set executable command\n-      vargs.add(shellCommand);\n-      // Set shell script path\n-      if (!shellScriptPath.isEmpty()) {\n-        vargs.add(Shell.WINDOWS ? ExecBatScripStringtPath\n-            : ExecShellStringPath);\n-      }\n-\n-      // Set args for the shell command if any\n-      vargs.add(shellArgs);\n-      // Add log redirect params\n-      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n-      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n-\n-      // Get final commmand\n-      StringBuilder command \u003d new StringBuilder();\n-      for (CharSequence str : vargs) {\n-        command.append(str).append(\" \");\n-      }\n-\n-      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n-      commands.add(command.toString());\n-      ctx.setCommands(commands);\n-\n-      // Set up tokens for the container too. Today, for normal shell commands,\n-      // the container in distribute-shell doesn\u0027t need any tokens. We are\n-      // populating them mainly for NodeManagers to be able to download any\n-      // files in the distributed file-system. The tokens are otherwise also\n-      // useful in cases, for e.g., when one is running a \"hadoop dfs\" command\n-      // inside the distributed shell.\n-      ctx.setTokens(allTokens.duplicate());\n-\n-      containerListener.addContainer(container.getId(), container);\n-      nmClientAsync.startContainerAsync(container, ctx);\n-    }\n\\ No newline at end of file\n+      public Void run() throws IOException {\n+        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n+        fs.rename(new Path(scriptPath), renamedScriptPath);\n+        return null;\n+      }\n\\ No newline at end of file\n",
          "actualSource": "      public Void run() throws IOException {\n        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n        fs.rename(new Path(scriptPath), renamedScriptPath);\n        return null;\n      }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1908. Fixed DistributedShell to not fail in secure clusters. Contributed by Vinod Kumar Vavilapalli and Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1585849 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/04/14 3:11 PM",
          "commitName": "6c2a0ce30b8bc54998ec40551bc14f478a353e10",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "18/03/14 8:49 PM",
          "commitNameOld": "fd1c424548999cb8843f40cb6a342387f98bde6c",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 20.77,
          "commitsBetweenForRepo": 131,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,5 @@\n-    public void run() {\n-      LOG.info(\"Setting up container launch container for containerid\u003d\"\n-          + container.getId());\n-      ContainerLaunchContext ctx \u003d Records\n-          .newRecord(ContainerLaunchContext.class);\n-\n-      // Set the environment\n-      ctx.setEnvironment(shellEnv);\n-\n-      // Set the local resources\n-      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n-\n-      // The container for the eventual shell commands needs its own local\n-      // resources too.\n-      // In this scenario, if a shell script is specified, we need to have it\n-      // copied and made available to the container.\n-      if (!shellScriptPath.isEmpty()) {\n-        Path renamedSchellScriptPath \u003d null;\n-        if (Shell.WINDOWS) {\n-          renamedSchellScriptPath \u003d new Path(shellScriptPath + \".bat\");\n-        } else {\n-          renamedSchellScriptPath \u003d new Path(shellScriptPath + \".sh\");\n-        }\n-        try {\n-          FileSystem fs \u003d renamedSchellScriptPath.getFileSystem(conf);\n-          fs.rename(new Path(shellScriptPath), renamedSchellScriptPath);\n-        } catch (IOException e) {\n-          LOG.warn(\"Not able to add suffix (.bat/.sh) to the shell script filename\");\n-          throw new YarnRuntimeException(e);\n-        }\n-\n-        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n-        shellRsrc.setType(LocalResourceType.FILE);\n-        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n-        try {\n-          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n-            renamedSchellScriptPath.toString())));\n-        } catch (URISyntaxException e) {\n-          LOG.error(\"Error when trying to use shell script path specified\"\n-              + \" in env, path\u003d\" + renamedSchellScriptPath);\n-          e.printStackTrace();\n-\n-          // A failure scenario on bad input such as invalid shell script path\n-          // We know we cannot continue launching the container\n-          // so we should release it.\n-          // TODO\n-          numCompletedContainers.incrementAndGet();\n-          numFailedContainers.incrementAndGet();\n-          return;\n-        }\n-        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n-        shellRsrc.setSize(shellScriptPathLen);\n-        localResources.put(Shell.WINDOWS ? ExecBatScripStringtPath :\n-            ExecShellStringPath, shellRsrc);\n-        shellCommand \u003d Shell.WINDOWS ? windows_command : linux_bash_command;\n-      }\n-      ctx.setLocalResources(localResources);\n-\n-      // Set the necessary command to execute on the allocated container\n-      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n-\n-      // Set executable command\n-      vargs.add(shellCommand);\n-      // Set shell script path\n-      if (!shellScriptPath.isEmpty()) {\n-        vargs.add(Shell.WINDOWS ? ExecBatScripStringtPath\n-            : ExecShellStringPath);\n-      }\n-\n-      // Set args for the shell command if any\n-      vargs.add(shellArgs);\n-      // Add log redirect params\n-      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n-      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n-\n-      // Get final commmand\n-      StringBuilder command \u003d new StringBuilder();\n-      for (CharSequence str : vargs) {\n-        command.append(str).append(\" \");\n-      }\n-\n-      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n-      commands.add(command.toString());\n-      ctx.setCommands(commands);\n-\n-      // Set up tokens for the container too. Today, for normal shell commands,\n-      // the container in distribute-shell doesn\u0027t need any tokens. We are\n-      // populating them mainly for NodeManagers to be able to download any\n-      // files in the distributed file-system. The tokens are otherwise also\n-      // useful in cases, for e.g., when one is running a \"hadoop dfs\" command\n-      // inside the distributed shell.\n-      ctx.setTokens(allTokens.duplicate());\n-\n-      containerListener.addContainer(container.getId(), container);\n-      nmClientAsync.startContainerAsync(container, ctx);\n-    }\n\\ No newline at end of file\n+      public Void run() throws IOException {\n+        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n+        fs.rename(new Path(scriptPath), renamedScriptPath);\n+        return null;\n+      }\n\\ No newline at end of file\n",
          "actualSource": "      public Void run() throws IOException {\n        FileSystem fs \u003d renamedScriptPath.getFileSystem(conf);\n        fs.rename(new Path(scriptPath), renamedScriptPath);\n        return null;\n      }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {}
        }
      ]
    },
    "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1824. Improved NodeManager and clients to be able to handle cross platform application submissions. Contributed by Jian He.\nMAPREDUCE-4052. Improved MapReduce clients to use NodeManagers\u0027 ability to handle cross platform application submissions. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1578135 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/03/14 11:32 AM",
      "commitName": "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/02/14 12:20 PM",
      "commitNameOld": "0fbc7fe816007b4e330604e9f8bae6b1e4b448bc",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 17.92,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,96 @@\n     public void run() {\n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n+        Path renamedSchellScriptPath \u003d null;\n+        if (Shell.WINDOWS) {\n+          renamedSchellScriptPath \u003d new Path(shellScriptPath + \".bat\");\n+        } else {\n+          renamedSchellScriptPath \u003d new Path(shellScriptPath + \".sh\");\n+        }\n+        try {\n+          FileSystem fs \u003d renamedSchellScriptPath.getFileSystem(conf);\n+          fs.rename(new Path(shellScriptPath), renamedSchellScriptPath);\n+        } catch (IOException e) {\n+          LOG.warn(\"Not able to add suffix (.bat/.sh) to the shell script filename\");\n+          throw new YarnRuntimeException(e);\n+        }\n+\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n-              shellScriptPath)));\n+            renamedSchellScriptPath.toString())));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n-              + \" in env, path\u003d\" + shellScriptPath);\n+              + \" in env, path\u003d\" + renamedSchellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(Shell.WINDOWS ? ExecBatScripStringtPath :\n             ExecShellStringPath, shellRsrc);\n         shellCommand \u003d Shell.WINDOWS ? windows_command : linux_bash_command;\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(Shell.WINDOWS ? ExecBatScripStringtPath\n             : ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       // Set up tokens for the container too. Today, for normal shell commands,\n       // the container in distribute-shell doesn\u0027t need any tokens. We are\n       // populating them mainly for NodeManagers to be able to download any\n       // files in the distributed file-system. The tokens are otherwise also\n       // useful in cases, for e.g., when one is running a \"hadoop dfs\" command\n       // inside the distributed shell.\n       ctx.setTokens(allTokens.duplicate());\n \n       containerListener.addContainer(container.getId(), container);\n       nmClientAsync.startContainerAsync(container, ctx);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        Path renamedSchellScriptPath \u003d null;\n        if (Shell.WINDOWS) {\n          renamedSchellScriptPath \u003d new Path(shellScriptPath + \".bat\");\n        } else {\n          renamedSchellScriptPath \u003d new Path(shellScriptPath + \".sh\");\n        }\n        try {\n          FileSystem fs \u003d renamedSchellScriptPath.getFileSystem(conf);\n          fs.rename(new Path(shellScriptPath), renamedSchellScriptPath);\n        } catch (IOException e) {\n          LOG.warn(\"Not able to add suffix (.bat/.sh) to the shell script filename\");\n          throw new YarnRuntimeException(e);\n        }\n\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n            renamedSchellScriptPath.toString())));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + renamedSchellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(Shell.WINDOWS ? ExecBatScripStringtPath :\n            ExecShellStringPath, shellRsrc);\n        shellCommand \u003d Shell.WINDOWS ? windows_command : linux_bash_command;\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(Shell.WINDOWS ? ExecBatScripStringtPath\n            : ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      // Set up tokens for the container too. Today, for normal shell commands,\n      // the container in distribute-shell doesn\u0027t need any tokens. We are\n      // populating them mainly for NodeManagers to be able to download any\n      // files in the distributed file-system. The tokens are otherwise also\n      // useful in cases, for e.g., when one is running a \"hadoop dfs\" command\n      // inside the distributed shell.\n      ctx.setTokens(allTokens.duplicate());\n\n      containerListener.addContainer(container.getId(), container);\n      nmClientAsync.startContainerAsync(container, ctx);\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1435. Modified Distributed Shell to accept either the command or the custom script. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550867 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/13 6:00 PM",
      "commitName": "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "25/11/13 5:10 PM",
      "commitNameOld": "c4bdddeab56287c8a8ae314fac238cbbc6c1bcf4",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 18.03,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,82 @@\n     public void run() {\n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n               shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n               + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n-        localResources.put(ExecShellStringPath, shellRsrc);\n+        localResources.put(Shell.WINDOWS ? ExecBatScripStringtPath :\n+            ExecShellStringPath, shellRsrc);\n+        shellCommand \u003d Shell.WINDOWS ? windows_command : linux_bash_command;\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n-        vargs.add(ExecShellStringPath);\n+        vargs.add(Shell.WINDOWS ? ExecBatScripStringtPath\n+            : ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       // Set up tokens for the container too. Today, for normal shell commands,\n       // the container in distribute-shell doesn\u0027t need any tokens. We are\n       // populating them mainly for NodeManagers to be able to download any\n       // files in the distributed file-system. The tokens are otherwise also\n       // useful in cases, for e.g., when one is running a \"hadoop dfs\" command\n       // inside the distributed shell.\n       ctx.setTokens(allTokens.duplicate());\n \n       containerListener.addContainer(container.getId(), container);\n       nmClientAsync.startContainerAsync(container, ctx);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(Shell.WINDOWS ? ExecBatScripStringtPath :\n            ExecShellStringPath, shellRsrc);\n        shellCommand \u003d Shell.WINDOWS ? windows_command : linux_bash_command;\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(Shell.WINDOWS ? ExecBatScripStringtPath\n            : ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      // Set up tokens for the container too. Today, for normal shell commands,\n      // the container in distribute-shell doesn\u0027t need any tokens. We are\n      // populating them mainly for NodeManagers to be able to download any\n      // files in the distributed file-system. The tokens are otherwise also\n      // useful in cases, for e.g., when one is running a \"hadoop dfs\" command\n      // inside the distributed shell.\n      ctx.setTokens(allTokens.duplicate());\n\n      containerListener.addContainer(container.getId(), container);\n      nmClientAsync.startContainerAsync(container, ctx);\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "f104665f7ed8749e563b7512e5846f910676a324": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1251. TestDistributedShell#TestDSShell failed with timeout. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529369 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/10/13 5:48 PM",
      "commitName": "f104665f7ed8749e563b7512e5846f910676a324",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "25/09/13 4:39 PM",
      "commitNameOld": "42c3cd3d137ba1de1c0573c0bb655fa380ed9412",
      "commitAuthorOld": "Hitesh Shah",
      "daysBetweenCommits": 9.05,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n     public void run() {\n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n               shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n               + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       // Set up tokens for the container too. Today, for normal shell commands,\n       // the container in distribute-shell doesn\u0027t need any tokens. We are\n       // populating them mainly for NodeManagers to be able to download any\n       // files in the distributed file-system. The tokens are otherwise also\n       // useful in cases, for e.g., when one is running a \"hadoop dfs\" command\n       // inside the distributed shell.\n-      ctx.setTokens(allTokens);\n+      ctx.setTokens(allTokens.duplicate());\n \n       containerListener.addContainer(container.getId(), container);\n       nmClientAsync.startContainerAsync(container, ctx);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      // Set up tokens for the container too. Today, for normal shell commands,\n      // the container in distribute-shell doesn\u0027t need any tokens. We are\n      // populating them mainly for NodeManagers to be able to download any\n      // files in the distributed file-system. The tokens are otherwise also\n      // useful in cases, for e.g., when one is running a \"hadoop dfs\" command\n      // inside the distributed shell.\n      ctx.setTokens(allTokens.duplicate());\n\n      containerListener.addContainer(container.getId(), container);\n      nmClientAsync.startContainerAsync(container, ctx);\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "42c3cd3d137ba1de1c0573c0bb655fa380ed9412": {
      "type": "Ybodychange",
      "commitMessage": "YARN-49. Improve distributed shell application to work on a secure cluster. Contributed by Vinod Kumar Vavilapalli.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1526330 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/09/13 4:39 PM",
      "commitName": "42c3cd3d137ba1de1c0573c0bb655fa380ed9412",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "24/07/13 3:13 PM",
      "commitNameOld": "9c453d4432a6ce75afab2087017781e614cc320f",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 63.06,
      "commitsBetweenForRepo": 352,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,79 @@\n     public void run() {\n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n               shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n               + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n+      // Set up tokens for the container too. Today, for normal shell commands,\n+      // the container in distribute-shell doesn\u0027t need any tokens. We are\n+      // populating them mainly for NodeManagers to be able to download any\n+      // files in the distributed file-system. The tokens are otherwise also\n+      // useful in cases, for e.g., when one is running a \"hadoop dfs\" command\n+      // inside the distributed shell.\n+      ctx.setTokens(allTokens);\n+\n       containerListener.addContainer(container.getId(), container);\n       nmClientAsync.startContainerAsync(container, ctx);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      // Set up tokens for the container too. Today, for normal shell commands,\n      // the container in distribute-shell doesn\u0027t need any tokens. We are\n      // populating them mainly for NodeManagers to be able to download any\n      // files in the distributed file-system. The tokens are otherwise also\n      // useful in cases, for e.g., when one is running a \"hadoop dfs\" command\n      // inside the distributed shell.\n      ctx.setTokens(allTokens);\n\n      containerListener.addContainer(container.getId(), container);\n      nmClientAsync.startContainerAsync(container, ctx);\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-834. Fixed annotations for yarn-client module, reorganized packages and clearly differentiated *Async apis. Contributed by Arun C Murthy and Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494017 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 9:02 PM",
      "commitName": "7ef54faad4bee4346da082a3f8cc5d6ea405d74a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/13 7:27 PM",
      "commitNameOld": "77e134d13fb87cd098f2e9c23212affe0a7be1be",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.07,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n     public void run() {\n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n               shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n               + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       containerListener.addContainer(container.getId(), container);\n-      nmClientAsync.startContainer(container, ctx);\n+      nmClientAsync.startContainerAsync(container, ctx);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      containerListener.addContainer(container.getId(), container);\n      nmClientAsync.startContainerAsync(container, ctx);\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "b503b6a07d7210c94657131dcd97239012ecb313": {
      "type": "Ybodychange",
      "commitMessage": "YARN-639. Modified Distributed Shell application to start using the new NMClient library. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493280 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/06/13 4:18 PM",
      "commitName": "b503b6a07d7210c94657131dcd97239012ecb313",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/06/13 9:10 AM",
      "commitNameOld": "fdc9412a810564c79fbebf5eb730cb1018a95c6c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,71 @@\n     public void run() {\n-      // Connect to ContainerManager\n-      connectToCM();\n-\n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n               shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n               + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n-      StartContainerRequest startReq \u003d Records\n-          .newRecord(StartContainerRequest.class);\n-      startReq.setContainerLaunchContext(ctx);\n-      startReq.setContainerToken(container.getContainerToken());\n-      try {\n-        cm.startContainer(startReq);\n-      } catch (YarnException e) {\n-        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n-            + container.getId());\n-        e.printStackTrace();\n-        // TODO do we need to release this container?\n-      } catch (IOException e) {\n-        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n-            + container.getId());\n-        e.printStackTrace();\n-      }\n-\n-      // Get container status?\n-      // Left commented out as the shell scripts are short lived\n-      // and we are relying on the status for completed containers\n-      // from RM to detect status\n-\n-      // GetContainerStatusRequest statusReq \u003d\n-      // Records.newRecord(GetContainerStatusRequest.class);\n-      // statusReq.setContainerId(container.getId());\n-      // GetContainerStatusResponse statusResp;\n-      // try {\n-      // statusResp \u003d cm.getContainerStatus(statusReq);\n-      // LOG.info(\"Container Status\"\n-      // + \", id\u003d\" + container.getId()\n-      // + \", status\u003d\" +statusResp.getStatus());\n-      // } catch (YarnException e) {\n-      // e.printStackTrace();\n-      // }\n+      containerListener.addContainer(container.getId(), container);\n+      nmClientAsync.startContainer(container, ctx);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      containerListener.addContainer(container.getId(), container);\n      nmClientAsync.startContainer(container, ctx);\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "01/06/13 1:23 AM",
      "commitNameOld": "3492f5eff1a22aba0d09d72a9dfd3353525c072e",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 2.82,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n     public void run() {\n       // Connect to ContainerManager\n       connectToCM();\n \n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n               shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n               + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       StartContainerRequest startReq \u003d Records\n           .newRecord(StartContainerRequest.class);\n       startReq.setContainerLaunchContext(ctx);\n       startReq.setContainerToken(container.getContainerToken());\n       try {\n         cm.startContainer(startReq);\n-      } catch (YarnRemoteException e) {\n+      } catch (YarnException e) {\n         LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n             + container.getId());\n         e.printStackTrace();\n         // TODO do we need to release this container?\n       } catch (IOException e) {\n         LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n             + container.getId());\n         e.printStackTrace();\n       }\n \n       // Get container status?\n       // Left commented out as the shell scripts are short lived\n       // and we are relying on the status for completed containers\n       // from RM to detect status\n \n       // GetContainerStatusRequest statusReq \u003d\n       // Records.newRecord(GetContainerStatusRequest.class);\n       // statusReq.setContainerId(container.getId());\n       // GetContainerStatusResponse statusResp;\n       // try {\n       // statusResp \u003d cm.getContainerStatus(statusReq);\n       // LOG.info(\"Container Status\"\n       // + \", id\u003d\" + container.getId()\n       // + \", status\u003d\" +statusResp.getStatus());\n-      // } catch (YarnRemoteException e) {\n+      // } catch (YarnException e) {\n       // e.printStackTrace();\n       // }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      // Connect to ContainerManager\n      connectToCM();\n\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      StartContainerRequest startReq \u003d Records\n          .newRecord(StartContainerRequest.class);\n      startReq.setContainerLaunchContext(ctx);\n      startReq.setContainerToken(container.getContainerToken());\n      try {\n        cm.startContainer(startReq);\n      } catch (YarnException e) {\n        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n            + container.getId());\n        e.printStackTrace();\n        // TODO do we need to release this container?\n      } catch (IOException e) {\n        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n            + container.getId());\n        e.printStackTrace();\n      }\n\n      // Get container status?\n      // Left commented out as the shell scripts are short lived\n      // and we are relying on the status for completed containers\n      // from RM to detect status\n\n      // GetContainerStatusRequest statusReq \u003d\n      // Records.newRecord(GetContainerStatusRequest.class);\n      // statusReq.setContainerId(container.getId());\n      // GetContainerStatusResponse statusResp;\n      // try {\n      // statusResp \u003d cm.getContainerStatus(statusReq);\n      // LOG.info(\"Container Status\"\n      // + \", id\u003d\" + container.getId()\n      // + \", status\u003d\" +statusResp.getStatus());\n      // } catch (YarnException e) {\n      // e.printStackTrace();\n      // }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "2692675fc3b5046d2ec88542c30203c87e135b70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-684. ContainerManager.startContainer should use ContainerTokenIdentifier instead of the entire Container. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488085 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/13 9:13 PM",
      "commitName": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "23/05/13 8:22 PM",
      "commitNameOld": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.03,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n     public void run() {\n       // Connect to ContainerManager\n       connectToCM();\n \n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n               shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n               + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       StartContainerRequest startReq \u003d Records\n           .newRecord(StartContainerRequest.class);\n       startReq.setContainerLaunchContext(ctx);\n-      startReq.setContainer(container);\n+      startReq.setContainerToken(container.getContainerToken());\n       try {\n         cm.startContainer(startReq);\n       } catch (YarnRemoteException e) {\n         LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n             + container.getId());\n         e.printStackTrace();\n         // TODO do we need to release this container?\n       } catch (IOException e) {\n         LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n             + container.getId());\n         e.printStackTrace();\n       }\n \n       // Get container status?\n       // Left commented out as the shell scripts are short lived\n       // and we are relying on the status for completed containers\n       // from RM to detect status\n \n       // GetContainerStatusRequest statusReq \u003d\n       // Records.newRecord(GetContainerStatusRequest.class);\n       // statusReq.setContainerId(container.getId());\n       // GetContainerStatusResponse statusResp;\n       // try {\n       // statusResp \u003d cm.getContainerStatus(statusReq);\n       // LOG.info(\"Container Status\"\n       // + \", id\u003d\" + container.getId()\n       // + \", status\u003d\" +statusResp.getStatus());\n       // } catch (YarnRemoteException e) {\n       // e.printStackTrace();\n       // }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      // Connect to ContainerManager\n      connectToCM();\n\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      StartContainerRequest startReq \u003d Records\n          .newRecord(StartContainerRequest.class);\n      startReq.setContainerLaunchContext(ctx);\n      startReq.setContainerToken(container.getContainerToken());\n      try {\n        cm.startContainer(startReq);\n      } catch (YarnRemoteException e) {\n        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n            + container.getId());\n        e.printStackTrace();\n        // TODO do we need to release this container?\n      } catch (IOException e) {\n        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n            + container.getId());\n        e.printStackTrace();\n      }\n\n      // Get container status?\n      // Left commented out as the shell scripts are short lived\n      // and we are relying on the status for completed containers\n      // from RM to detect status\n\n      // GetContainerStatusRequest statusReq \u003d\n      // Records.newRecord(GetContainerStatusRequest.class);\n      // statusReq.setContainerId(container.getId());\n      // GetContainerStatusResponse statusResp;\n      // try {\n      // statusResp \u003d cm.getContainerStatus(statusReq);\n      // LOG.info(\"Container Status\"\n      // + \", id\u003d\" + container.getId()\n      // + \", status\u003d\" +statusResp.getStatus());\n      // } catch (YarnRemoteException e) {\n      // e.printStackTrace();\n      // }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "259edf8dca44de54033e96f7eb65a83aaa6096f2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-571. Remove user from ContainerLaunchContext. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485928 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/13 8:22 PM",
      "commitName": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "22/05/13 10:48 PM",
      "commitNameOld": "8a430d0643a0d7d8580ffd6dbd5adb603489db70",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,106 @@\n     public void run() {\n       // Connect to ContainerManager\n       connectToCM();\n \n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n-      String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n-          .key());\n-      ctx.setUser(jobUserName);\n-      LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n-\n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n               shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n               + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       StartContainerRequest startReq \u003d Records\n           .newRecord(StartContainerRequest.class);\n       startReq.setContainerLaunchContext(ctx);\n       startReq.setContainer(container);\n       try {\n         cm.startContainer(startReq);\n       } catch (YarnRemoteException e) {\n         LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n             + container.getId());\n         e.printStackTrace();\n         // TODO do we need to release this container?\n       } catch (IOException e) {\n         LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n             + container.getId());\n         e.printStackTrace();\n       }\n \n       // Get container status?\n       // Left commented out as the shell scripts are short lived\n       // and we are relying on the status for completed containers\n       // from RM to detect status\n \n       // GetContainerStatusRequest statusReq \u003d\n       // Records.newRecord(GetContainerStatusRequest.class);\n       // statusReq.setContainerId(container.getId());\n       // GetContainerStatusResponse statusResp;\n       // try {\n       // statusResp \u003d cm.getContainerStatus(statusReq);\n       // LOG.info(\"Container Status\"\n       // + \", id\u003d\" + container.getId()\n       // + \", status\u003d\" +statusResp.getStatus());\n       // } catch (YarnRemoteException e) {\n       // e.printStackTrace();\n       // }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      // Connect to ContainerManager\n      connectToCM();\n\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      StartContainerRequest startReq \u003d Records\n          .newRecord(StartContainerRequest.class);\n      startReq.setContainerLaunchContext(ctx);\n      startReq.setContainer(container);\n      try {\n        cm.startContainer(startReq);\n      } catch (YarnRemoteException e) {\n        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n            + container.getId());\n        e.printStackTrace();\n        // TODO do we need to release this container?\n      } catch (IOException e) {\n        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n            + container.getId());\n        e.printStackTrace();\n      }\n\n      // Get container status?\n      // Left commented out as the shell scripts are short lived\n      // and we are relying on the status for completed containers\n      // from RM to detect status\n\n      // GetContainerStatusRequest statusReq \u003d\n      // Records.newRecord(GetContainerStatusRequest.class);\n      // statusReq.setContainerId(container.getId());\n      // GetContainerStatusResponse statusResp;\n      // try {\n      // statusResp \u003d cm.getContainerStatus(statusReq);\n      // LOG.info(\"Container Status\"\n      // + \", id\u003d\" + container.getId()\n      // + \", status\u003d\" +statusResp.getStatus());\n      // } catch (YarnRemoteException e) {\n      // e.printStackTrace();\n      // }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "9eb53b9c841233538a51e4e854b261536c0b85d4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-632. Changed ContainerManager api to throw IOException and YarnRemoteException. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479740 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/05/13 5:42 PM",
      "commitName": "9eb53b9c841233538a51e4e854b261536c0b85d4",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "23/04/13 2:39 PM",
      "commitNameOld": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 13.13,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,111 @@\n     public void run() {\n       // Connect to ContainerManager\n       connectToCM();\n \n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n       String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n           .key());\n       ctx.setUser(jobUserName);\n       LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n \n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n               shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n               + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       StartContainerRequest startReq \u003d Records\n           .newRecord(StartContainerRequest.class);\n       startReq.setContainerLaunchContext(ctx);\n       startReq.setContainer(container);\n       try {\n         cm.startContainer(startReq);\n       } catch (YarnRemoteException e) {\n         LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n             + container.getId());\n         e.printStackTrace();\n         // TODO do we need to release this container?\n+      } catch (IOException e) {\n+        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n+            + container.getId());\n+        e.printStackTrace();\n       }\n \n       // Get container status?\n       // Left commented out as the shell scripts are short lived\n       // and we are relying on the status for completed containers\n       // from RM to detect status\n \n       // GetContainerStatusRequest statusReq \u003d\n       // Records.newRecord(GetContainerStatusRequest.class);\n       // statusReq.setContainerId(container.getId());\n       // GetContainerStatusResponse statusResp;\n       // try {\n       // statusResp \u003d cm.getContainerStatus(statusReq);\n       // LOG.info(\"Container Status\"\n       // + \", id\u003d\" + container.getId()\n       // + \", status\u003d\" +statusResp.getStatus());\n       // } catch (YarnRemoteException e) {\n       // e.printStackTrace();\n       // }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      // Connect to ContainerManager\n      connectToCM();\n\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n          .key());\n      ctx.setUser(jobUserName);\n      LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      StartContainerRequest startReq \u003d Records\n          .newRecord(StartContainerRequest.class);\n      startReq.setContainerLaunchContext(ctx);\n      startReq.setContainer(container);\n      try {\n        cm.startContainer(startReq);\n      } catch (YarnRemoteException e) {\n        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n            + container.getId());\n        e.printStackTrace();\n        // TODO do we need to release this container?\n      } catch (IOException e) {\n        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n            + container.getId());\n        e.printStackTrace();\n      }\n\n      // Get container status?\n      // Left commented out as the shell scripts are short lived\n      // and we are relying on the status for completed containers\n      // from RM to detect status\n\n      // GetContainerStatusRequest statusReq \u003d\n      // Records.newRecord(GetContainerStatusRequest.class);\n      // statusReq.setContainerId(container.getId());\n      // GetContainerStatusResponse statusResp;\n      // try {\n      // statusResp \u003d cm.getContainerStatus(statusReq);\n      // LOG.info(\"Container Status\"\n      // + \", id\u003d\" + container.getId()\n      // + \", status\u003d\" +statusResp.getStatus());\n      // } catch (YarnRemoteException e) {\n      // e.printStackTrace();\n      // }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-486. Changed NM\u0027s startContainer API to accept Container record given by RM as a direct parameter instead of as part of the ContainerLaunchContext record. Contributed by Xuan Gong.\nMAPREDUCE-5139. Update MR AM to use the modified startContainer API after YARN-486. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1467063 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/04/13 12:28 PM",
      "commitName": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "08/04/13 8:26 PM",
      "commitNameOld": "55865f42c43c8e8c6282952722a06f2a58f0c264",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.67,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,107 @@\n     public void run() {\n       // Connect to ContainerManager\n       connectToCM();\n \n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n-      ctx.setContainerId(container.getId());\n-      ctx.setResource(container.getResource());\n-\n       String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n           .key());\n       ctx.setUser(jobUserName);\n       LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n \n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n               shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n               + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       StartContainerRequest startReq \u003d Records\n           .newRecord(StartContainerRequest.class);\n       startReq.setContainerLaunchContext(ctx);\n+      startReq.setContainer(container);\n       try {\n         cm.startContainer(startReq);\n       } catch (YarnRemoteException e) {\n         LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n             + container.getId());\n         e.printStackTrace();\n         // TODO do we need to release this container?\n       }\n \n       // Get container status?\n       // Left commented out as the shell scripts are short lived\n       // and we are relying on the status for completed containers\n       // from RM to detect status\n \n       // GetContainerStatusRequest statusReq \u003d\n       // Records.newRecord(GetContainerStatusRequest.class);\n       // statusReq.setContainerId(container.getId());\n       // GetContainerStatusResponse statusResp;\n       // try {\n       // statusResp \u003d cm.getContainerStatus(statusReq);\n       // LOG.info(\"Container Status\"\n       // + \", id\u003d\" + container.getId()\n       // + \", status\u003d\" +statusResp.getStatus());\n       // } catch (YarnRemoteException e) {\n       // e.printStackTrace();\n       // }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      // Connect to ContainerManager\n      connectToCM();\n\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n          .key());\n      ctx.setUser(jobUserName);\n      LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      StartContainerRequest startReq \u003d Records\n          .newRecord(StartContainerRequest.class);\n      startReq.setContainerLaunchContext(ctx);\n      startReq.setContainer(container);\n      try {\n        cm.startContainer(startReq);\n      } catch (YarnRemoteException e) {\n        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n            + container.getId());\n        e.printStackTrace();\n        // TODO do we need to release this container?\n      }\n\n      // Get container status?\n      // Left commented out as the shell scripts are short lived\n      // and we are relying on the status for completed containers\n      // from RM to detect status\n\n      // GetContainerStatusRequest statusReq \u003d\n      // Records.newRecord(GetContainerStatusRequest.class);\n      // statusReq.setContainerId(container.getId());\n      // GetContainerStatusResponse statusResp;\n      // try {\n      // statusResp \u003d cm.getContainerStatus(statusReq);\n      // LOG.info(\"Container Status\"\n      // + \", id\u003d\" + container.getId()\n      // + \", status\u003d\" +statusResp.getStatus());\n      // } catch (YarnRemoteException e) {\n      // e.printStackTrace();\n      // }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "55865f42c43c8e8c6282952722a06f2a58f0c264": {
      "type": "Ybodychange",
      "commitMessage": "YARN-557. Fix TestUnmanagedAMLauncher failure on Windows. Contributed by Chris Nauroth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1465869 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/04/13 8:26 PM",
      "commitName": "55865f42c43c8e8c6282952722a06f2a58f0c264",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/04/13 8:41 PM",
      "commitNameOld": "1fd462b118664b302c67bcc9543cdccdaaec30e9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.99,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,109 @@\n     public void run() {\n       // Connect to ContainerManager\n       connectToCM();\n \n       LOG.info(\"Setting up container launch container for containerid\u003d\"\n           + container.getId());\n       ContainerLaunchContext ctx \u003d Records\n           .newRecord(ContainerLaunchContext.class);\n \n       ctx.setContainerId(container.getId());\n       ctx.setResource(container.getResource());\n \n       String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n-          .name());\n+          .key());\n       ctx.setUser(jobUserName);\n       LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n \n       // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local\n       // resources too.\n       // In this scenario, if a shell script is specified, we need to have it\n       // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n               shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified\"\n               + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path\n           // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command\n       vargs.add(shellCommand);\n       // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       StartContainerRequest startReq \u003d Records\n           .newRecord(StartContainerRequest.class);\n       startReq.setContainerLaunchContext(ctx);\n       try {\n         cm.startContainer(startReq);\n       } catch (YarnRemoteException e) {\n         LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n             + container.getId());\n         e.printStackTrace();\n         // TODO do we need to release this container?\n       }\n \n       // Get container status?\n       // Left commented out as the shell scripts are short lived\n       // and we are relying on the status for completed containers\n       // from RM to detect status\n \n       // GetContainerStatusRequest statusReq \u003d\n       // Records.newRecord(GetContainerStatusRequest.class);\n       // statusReq.setContainerId(container.getId());\n       // GetContainerStatusResponse statusResp;\n       // try {\n       // statusResp \u003d cm.getContainerStatus(statusReq);\n       // LOG.info(\"Container Status\"\n       // + \", id\u003d\" + container.getId()\n       // + \", status\u003d\" +statusResp.getStatus());\n       // } catch (YarnRemoteException e) {\n       // e.printStackTrace();\n       // }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      // Connect to ContainerManager\n      connectToCM();\n\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      ctx.setContainerId(container.getId());\n      ctx.setResource(container.getResource());\n\n      String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n          .key());\n      ctx.setUser(jobUserName);\n      LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      StartContainerRequest startReq \u003d Records\n          .newRecord(StartContainerRequest.class);\n      startReq.setContainerLaunchContext(ctx);\n      try {\n        cm.startContainer(startReq);\n      } catch (YarnRemoteException e) {\n        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n            + container.getId());\n        e.printStackTrace();\n        // TODO do we need to release this container?\n      }\n\n      // Get container status?\n      // Left commented out as the shell scripts are short lived\n      // and we are relying on the status for completed containers\n      // from RM to detect status\n\n      // GetContainerStatusRequest statusReq \u003d\n      // Records.newRecord(GetContainerStatusRequest.class);\n      // statusReq.setContainerId(container.getId());\n      // GetContainerStatusResponse statusResp;\n      // try {\n      // statusResp \u003d cm.getContainerStatus(statusReq);\n      // LOG.info(\"Container Status\"\n      // + \", id\u003d\" + container.getId()\n      // + \", status\u003d\" +statusResp.getStatus());\n      // } catch (YarnRemoteException e) {\n      // e.printStackTrace();\n      // }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "f5551bf8091c11586d402cdd4a0b09aa0498b673": {
      "type": "Ybodychange",
      "commitMessage": "YARN-277. Use AMRMClient in DistributedShell to exemplify the approach. Contributed by Bikas Saha\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1437156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/01/13 12:49 PM",
      "commitName": "f5551bf8091c11586d402cdd4a0b09aa0498b673",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 167.64,
      "commitsBetweenForRepo": 901,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,109 @@\n     public void run() {\n-      // Connect to ContainerManager \n+      // Connect to ContainerManager\n       connectToCM();\n \n-      LOG.info(\"Setting up container launch container for containerid\u003d\" + container.getId());\n-      ContainerLaunchContext ctx \u003d Records.newRecord(ContainerLaunchContext.class);\n+      LOG.info(\"Setting up container launch container for containerid\u003d\"\n+          + container.getId());\n+      ContainerLaunchContext ctx \u003d Records\n+          .newRecord(ContainerLaunchContext.class);\n \n       ctx.setContainerId(container.getId());\n       ctx.setResource(container.getResource());\n \n       String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n           .name());\n       ctx.setUser(jobUserName);\n       LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n \n-      // Set the environment \n+      // Set the environment\n       ctx.setEnvironment(shellEnv);\n \n-      // Set the local resources \n+      // Set the local resources\n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n-      // The container for the eventual shell commands needs its own local resources too. \n-      // In this scenario, if a shell script is specified, we need to have it copied \n-      // and made available to the container. \n+      // The container for the eventual shell commands needs its own local\n+      // resources too.\n+      // In this scenario, if a shell script is specified, we need to have it\n+      // copied and made available to the container.\n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n-          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(shellScriptPath)));\n+          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n+              shellScriptPath)));\n         } catch (URISyntaxException e) {\n-          LOG.error(\"Error when trying to use shell script path specified in env\"\n-              + \", path\u003d\" + shellScriptPath);\n+          LOG.error(\"Error when trying to use shell script path specified\"\n+              + \" in env, path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n-          // A failure scenario on bad input such as invalid shell script path \n-          // We know we cannot continue launching the container \n+          // A failure scenario on bad input such as invalid shell script path\n+          // We know we cannot continue launching the container\n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n-      // Set the necessary command to execute on the allocated container \n+      // Set the necessary command to execute on the allocated container\n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n-      // Set executable command \n+      // Set executable command\n       vargs.add(shellCommand);\n-      // Set shell script path \n+      // Set shell script path\n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n-      // TODO\n-      // We should redirect the output to hdfs instead of local logs \n-      // so as to be able to look at the final output after the containers \n-      // have been released. \n-      // Could use a path suffixed with /AppId/AppAttempId/ContainerId/std[out|err] \n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n-      StartContainerRequest startReq \u003d Records.newRecord(StartContainerRequest.class);\n+      StartContainerRequest startReq \u003d Records\n+          .newRecord(StartContainerRequest.class);\n       startReq.setContainerLaunchContext(ctx);\n       try {\n         cm.startContainer(startReq);\n       } catch (YarnRemoteException e) {\n-        LOG.info(\"Start container failed for :\"\n-            + \", containerId\u003d\" + container.getId());\n+        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n+            + container.getId());\n         e.printStackTrace();\n-        // TODO do we need to release this container? \n+        // TODO do we need to release this container?\n       }\n \n       // Get container status?\n-      // Left commented out as the shell scripts are short lived \n-      // and we are relying on the status for completed containers from RM to detect status\n+      // Left commented out as the shell scripts are short lived\n+      // and we are relying on the status for completed containers\n+      // from RM to detect status\n \n-      //    GetContainerStatusRequest statusReq \u003d Records.newRecord(GetContainerStatusRequest.class);\n-      //    statusReq.setContainerId(container.getId());\n-      //    GetContainerStatusResponse statusResp;\n-      //try {\n-      //statusResp \u003d cm.getContainerStatus(statusReq);\n-      //    LOG.info(\"Container Status\"\n-      //    + \", id\u003d\" + container.getId()\n-      //    + \", status\u003d\" +statusResp.getStatus());\n-      //} catch (YarnRemoteException e) {\n-      //e.printStackTrace();\n-      //}\n+      // GetContainerStatusRequest statusReq \u003d\n+      // Records.newRecord(GetContainerStatusRequest.class);\n+      // statusReq.setContainerId(container.getId());\n+      // GetContainerStatusResponse statusResp;\n+      // try {\n+      // statusResp \u003d cm.getContainerStatus(statusReq);\n+      // LOG.info(\"Container Status\"\n+      // + \", id\u003d\" + container.getId()\n+      // + \", status\u003d\" +statusResp.getStatus());\n+      // } catch (YarnRemoteException e) {\n+      // e.printStackTrace();\n+      // }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      // Connect to ContainerManager\n      connectToCM();\n\n      LOG.info(\"Setting up container launch container for containerid\u003d\"\n          + container.getId());\n      ContainerLaunchContext ctx \u003d Records\n          .newRecord(ContainerLaunchContext.class);\n\n      ctx.setContainerId(container.getId());\n      ctx.setResource(container.getResource());\n\n      String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n          .name());\n      ctx.setUser(jobUserName);\n      LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n\n      // Set the environment\n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources\n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local\n      // resources too.\n      // In this scenario, if a shell script is specified, we need to have it\n      // copied and made available to the container.\n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(\n              shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified\"\n              + \" in env, path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path\n          // We know we cannot continue launching the container\n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container\n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command\n      vargs.add(shellCommand);\n      // Set shell script path\n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      StartContainerRequest startReq \u003d Records\n          .newRecord(StartContainerRequest.class);\n      startReq.setContainerLaunchContext(ctx);\n      try {\n        cm.startContainer(startReq);\n      } catch (YarnRemoteException e) {\n        LOG.info(\"Start container failed for :\" + \", containerId\u003d\"\n            + container.getId());\n        e.printStackTrace();\n        // TODO do we need to release this container?\n      }\n\n      // Get container status?\n      // Left commented out as the shell scripts are short lived\n      // and we are relying on the status for completed containers\n      // from RM to detect status\n\n      // GetContainerStatusRequest statusReq \u003d\n      // Records.newRecord(GetContainerStatusRequest.class);\n      // statusReq.setContainerId(container.getId());\n      // GetContainerStatusResponse statusResp;\n      // try {\n      // statusResp \u003d cm.getContainerStatus(statusReq);\n      // LOG.info(\"Container Status\"\n      // + \", id\u003d\" + container.getId()\n      // + \", status\u003d\" +statusResp.getStatus());\n      // } catch (YarnRemoteException e) {\n      // e.printStackTrace();\n      // }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n      // Connect to ContainerManager \n      connectToCM();\n\n      LOG.info(\"Setting up container launch container for containerid\u003d\" + container.getId());\n      ContainerLaunchContext ctx \u003d Records.newRecord(ContainerLaunchContext.class);\n\n      ctx.setContainerId(container.getId());\n      ctx.setResource(container.getResource());\n\n      String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n          .name());\n      ctx.setUser(jobUserName);\n      LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n\n      // Set the environment \n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources \n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local resources too. \n      // In this scenario, if a shell script is specified, we need to have it copied \n      // and made available to the container. \n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified in env\"\n              + \", path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path \n          // We know we cannot continue launching the container \n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container \n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command \n      vargs.add(shellCommand);\n      // Set shell script path \n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      // TODO\n      // We should redirect the output to hdfs instead of local logs \n      // so as to be able to look at the final output after the containers \n      // have been released. \n      // Could use a path suffixed with /AppId/AppAttempId/ContainerId/std[out|err] \n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      StartContainerRequest startReq \u003d Records.newRecord(StartContainerRequest.class);\n      startReq.setContainerLaunchContext(ctx);\n      try {\n        cm.startContainer(startReq);\n      } catch (YarnRemoteException e) {\n        LOG.info(\"Start container failed for :\"\n            + \", containerId\u003d\" + container.getId());\n        e.printStackTrace();\n        // TODO do we need to release this container? \n      }\n\n      // Get container status?\n      // Left commented out as the shell scripts are short lived \n      // and we are relying on the status for completed containers from RM to detect status\n\n      //    GetContainerStatusRequest statusReq \u003d Records.newRecord(GetContainerStatusRequest.class);\n      //    statusReq.setContainerId(container.getId());\n      //    GetContainerStatusResponse statusResp;\n      //try {\n      //statusResp \u003d cm.getContainerStatus(statusReq);\n      //    LOG.info(\"Container Status\"\n      //    + \", id\u003d\" + container.getId()\n      //    + \", status\u003d\" +statusResp.getStatus());\n      //} catch (YarnRemoteException e) {\n      //e.printStackTrace();\n      //}\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java"
      }
    },
    "daa28cc6ce23ef5c8db8b9f896f342cb770dd092": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4306. Fix distributed shell to work with users other than the one running the daemons. (Contributed by Ahmed Radwan)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1351876 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/06/12 3:00 PM",
      "commitName": "daa28cc6ce23ef5c8db8b9f896f342cb770dd092",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "18/04/12 11:46 AM",
      "commitNameOld": "32d511065a2612d37591f09e53eed8ec1488587d",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 62.13,
      "commitsBetweenForRepo": 336,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,107 @@\n     public void run() {\n       // Connect to ContainerManager \n       connectToCM();\n \n       LOG.info(\"Setting up container launch container for containerid\u003d\" + container.getId());\n       ContainerLaunchContext ctx \u003d Records.newRecord(ContainerLaunchContext.class);\n \n       ctx.setContainerId(container.getId());\n       ctx.setResource(container.getResource());\n \n-      try {\n-        ctx.setUser(UserGroupInformation.getCurrentUser().getShortUserName());\n-      } catch (IOException e) {\n-        LOG.info(\"Getting current user info failed when trying to launch the container\"\n-            + e.getMessage());\n-      }\n+      String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n+          .name());\n+      ctx.setUser(jobUserName);\n+      LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n \n       // Set the environment \n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources \n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local resources too. \n       // In this scenario, if a shell script is specified, we need to have it copied \n       // and made available to the container. \n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n         shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified in env\"\n               + \", path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path \n           // We know we cannot continue launching the container \n           // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n           return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n       }\n       ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container \n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command \n       vargs.add(shellCommand);\n       // Set shell script path \n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n       // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       // TODO\n       // We should redirect the output to hdfs instead of local logs \n       // so as to be able to look at the final output after the containers \n       // have been released. \n       // Could use a path suffixed with /AppId/AppAttempId/ContainerId/std[out|err] \n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       StartContainerRequest startReq \u003d Records.newRecord(StartContainerRequest.class);\n       startReq.setContainerLaunchContext(ctx);\n       try {\n         cm.startContainer(startReq);\n       } catch (YarnRemoteException e) {\n         LOG.info(\"Start container failed for :\"\n             + \", containerId\u003d\" + container.getId());\n         e.printStackTrace();\n         // TODO do we need to release this container? \n       }\n \n       // Get container status?\n       // Left commented out as the shell scripts are short lived \n       // and we are relying on the status for completed containers from RM to detect status\n \n       //    GetContainerStatusRequest statusReq \u003d Records.newRecord(GetContainerStatusRequest.class);\n       //    statusReq.setContainerId(container.getId());\n       //    GetContainerStatusResponse statusResp;\n       //try {\n       //statusResp \u003d cm.getContainerStatus(statusReq);\n       //    LOG.info(\"Container Status\"\n       //    + \", id\u003d\" + container.getId()\n       //    + \", status\u003d\" +statusResp.getStatus());\n       //} catch (YarnRemoteException e) {\n       //e.printStackTrace();\n       //}\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      // Connect to ContainerManager \n      connectToCM();\n\n      LOG.info(\"Setting up container launch container for containerid\u003d\" + container.getId());\n      ContainerLaunchContext ctx \u003d Records.newRecord(ContainerLaunchContext.class);\n\n      ctx.setContainerId(container.getId());\n      ctx.setResource(container.getResource());\n\n      String jobUserName \u003d System.getenv(ApplicationConstants.Environment.USER\n          .name());\n      ctx.setUser(jobUserName);\n      LOG.info(\"Setting user in ContainerLaunchContext to: \" + jobUserName);\n\n      // Set the environment \n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources \n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local resources too. \n      // In this scenario, if a shell script is specified, we need to have it copied \n      // and made available to the container. \n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified in env\"\n              + \", path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path \n          // We know we cannot continue launching the container \n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container \n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command \n      vargs.add(shellCommand);\n      // Set shell script path \n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      // TODO\n      // We should redirect the output to hdfs instead of local logs \n      // so as to be able to look at the final output after the containers \n      // have been released. \n      // Could use a path suffixed with /AppId/AppAttempId/ContainerId/std[out|err] \n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      StartContainerRequest startReq \u003d Records.newRecord(StartContainerRequest.class);\n      startReq.setContainerLaunchContext(ctx);\n      try {\n        cm.startContainer(startReq);\n      } catch (YarnRemoteException e) {\n        LOG.info(\"Start container failed for :\"\n            + \", containerId\u003d\" + container.getId());\n        e.printStackTrace();\n        // TODO do we need to release this container? \n      }\n\n      // Get container status?\n      // Left commented out as the shell scripts are short lived \n      // and we are relying on the status for completed containers from RM to detect status\n\n      //    GetContainerStatusRequest statusReq \u003d Records.newRecord(GetContainerStatusRequest.class);\n      //    statusReq.setContainerId(container.getId());\n      //    GetContainerStatusResponse statusResp;\n      //try {\n      //statusResp \u003d cm.getContainerStatus(statusReq);\n      //    LOG.info(\"Container Status\"\n      //    + \", id\u003d\" + container.getId()\n      //    + \", status\u003d\" +statusResp.getStatus());\n      //} catch (YarnRemoteException e) {\n      //e.printStackTrace();\n      //}\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "4e1d5a0d71d4bdde0d8b7b4c2a9571279496daaa": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3391. Making a trivial change to correct a log message in DistributedShell app\u0027s AM. Contributed by Subroto Sanyal.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1221516 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/12/11 3:13 PM",
      "commitName": "4e1d5a0d71d4bdde0d8b7b4c2a9571279496daaa",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/11/11 3:02 PM",
      "commitNameOld": "64b5a70a53ff92fc65efdf0f4048c21ea3181c47",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 23.01,
      "commitsBetweenForRepo": 153,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,109 @@\n     public void run() {\n       // Connect to ContainerManager \n-      LOG.info(\"Connecting to container manager for containerid\u003d\" + container.getId());\n       connectToCM();\n \n       LOG.info(\"Setting up container launch container for containerid\u003d\" + container.getId());\n       ContainerLaunchContext ctx \u003d Records.newRecord(ContainerLaunchContext.class);\n \n       ctx.setContainerId(container.getId());\n       ctx.setResource(container.getResource());\n \n       try {\n         ctx.setUser(UserGroupInformation.getCurrentUser().getShortUserName());\n       } catch (IOException e) {\n         LOG.info(\"Getting current user info failed when trying to launch the container\"\n             + e.getMessage());\n       }\n \n       // Set the environment \n       ctx.setEnvironment(shellEnv);\n \n       // Set the local resources \n       Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n \n       // The container for the eventual shell commands needs its own local resources too. \n       // In this scenario, if a shell script is specified, we need to have it copied \n       // and made available to the container. \n       if (!shellScriptPath.isEmpty()) {\n         LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n         shellRsrc.setType(LocalResourceType.FILE);\n-        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\t   \n+        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n         try {\n           shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(shellScriptPath)));\n         } catch (URISyntaxException e) {\n           LOG.error(\"Error when trying to use shell script path specified in env\"\n               + \", path\u003d\" + shellScriptPath);\n           e.printStackTrace();\n \n           // A failure scenario on bad input such as invalid shell script path \n           // We know we cannot continue launching the container \n-          // so we should release it. \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\n+          // so we should release it.\n           // TODO\n           numCompletedContainers.incrementAndGet();\n           numFailedContainers.incrementAndGet();\n-          return;\t\t\t\t\t\n+          return;\n         }\n         shellRsrc.setTimestamp(shellScriptPathTimestamp);\n         shellRsrc.setSize(shellScriptPathLen);\n         localResources.put(ExecShellStringPath, shellRsrc);\n-      }\t\t\t\n-      ctx.setLocalResources(localResources);\t\t\t\n+      }\n+      ctx.setLocalResources(localResources);\n \n       // Set the necessary command to execute on the allocated container \n       Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n \n       // Set executable command \n       vargs.add(shellCommand);\n       // Set shell script path \n       if (!shellScriptPath.isEmpty()) {\n         vargs.add(ExecShellStringPath);\n       }\n \n-      // Set args for the shell command if any\t\t\t\n+      // Set args for the shell command if any\n       vargs.add(shellArgs);\n       // Add log redirect params\n       // TODO\n       // We should redirect the output to hdfs instead of local logs \n       // so as to be able to look at the final output after the containers \n       // have been released. \n       // Could use a path suffixed with /AppId/AppAttempId/ContainerId/std[out|err] \n       vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n       vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n \n       // Get final commmand\n       StringBuilder command \u003d new StringBuilder();\n       for (CharSequence str : vargs) {\n         command.append(str).append(\" \");\n       }\n \n       List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n       commands.add(command.toString());\n       ctx.setCommands(commands);\n \n       StartContainerRequest startReq \u003d Records.newRecord(StartContainerRequest.class);\n       startReq.setContainerLaunchContext(ctx);\n       try {\n         cm.startContainer(startReq);\n       } catch (YarnRemoteException e) {\n         LOG.info(\"Start container failed for :\"\n             + \", containerId\u003d\" + container.getId());\n         e.printStackTrace();\n         // TODO do we need to release this container? \n       }\n \n       // Get container status?\n       // Left commented out as the shell scripts are short lived \n       // and we are relying on the status for completed containers from RM to detect status\n \n-      //\t\t    GetContainerStatusRequest statusReq \u003d Records.newRecord(GetContainerStatusRequest.class);\n-      //\t\t    statusReq.setContainerId(container.getId());\n-      //\t\t    GetContainerStatusResponse statusResp;\n-      //\t\t\ttry {\n-      //\t\t\t\tstatusResp \u003d cm.getContainerStatus(statusReq);\n-      //\t\t\t    LOG.info(\"Container Status\"\n-      //\t\t\t    \t\t+ \", id\u003d\" + container.getId()\n-      //\t\t\t    \t\t+ \", status\u003d\" +statusResp.getStatus());\n-      //\t\t\t} catch (YarnRemoteException e) {\n-      //\t\t\t\te.printStackTrace();\n-      //\t\t\t}\n-    }\t\t\n\\ No newline at end of file\n+      //    GetContainerStatusRequest statusReq \u003d Records.newRecord(GetContainerStatusRequest.class);\n+      //    statusReq.setContainerId(container.getId());\n+      //    GetContainerStatusResponse statusResp;\n+      //try {\n+      //statusResp \u003d cm.getContainerStatus(statusReq);\n+      //    LOG.info(\"Container Status\"\n+      //    + \", id\u003d\" + container.getId()\n+      //    + \", status\u003d\" +statusResp.getStatus());\n+      //} catch (YarnRemoteException e) {\n+      //e.printStackTrace();\n+      //}\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      // Connect to ContainerManager \n      connectToCM();\n\n      LOG.info(\"Setting up container launch container for containerid\u003d\" + container.getId());\n      ContainerLaunchContext ctx \u003d Records.newRecord(ContainerLaunchContext.class);\n\n      ctx.setContainerId(container.getId());\n      ctx.setResource(container.getResource());\n\n      try {\n        ctx.setUser(UserGroupInformation.getCurrentUser().getShortUserName());\n      } catch (IOException e) {\n        LOG.info(\"Getting current user info failed when trying to launch the container\"\n            + e.getMessage());\n      }\n\n      // Set the environment \n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources \n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local resources too. \n      // In this scenario, if a shell script is specified, we need to have it copied \n      // and made available to the container. \n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified in env\"\n              + \", path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path \n          // We know we cannot continue launching the container \n          // so we should release it.\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\n      ctx.setLocalResources(localResources);\n\n      // Set the necessary command to execute on the allocated container \n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command \n      vargs.add(shellCommand);\n      // Set shell script path \n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\n      vargs.add(shellArgs);\n      // Add log redirect params\n      // TODO\n      // We should redirect the output to hdfs instead of local logs \n      // so as to be able to look at the final output after the containers \n      // have been released. \n      // Could use a path suffixed with /AppId/AppAttempId/ContainerId/std[out|err] \n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      StartContainerRequest startReq \u003d Records.newRecord(StartContainerRequest.class);\n      startReq.setContainerLaunchContext(ctx);\n      try {\n        cm.startContainer(startReq);\n      } catch (YarnRemoteException e) {\n        LOG.info(\"Start container failed for :\"\n            + \", containerId\u003d\" + container.getId());\n        e.printStackTrace();\n        // TODO do we need to release this container? \n      }\n\n      // Get container status?\n      // Left commented out as the shell scripts are short lived \n      // and we are relying on the status for completed containers from RM to detect status\n\n      //    GetContainerStatusRequest statusReq \u003d Records.newRecord(GetContainerStatusRequest.class);\n      //    statusReq.setContainerId(container.getId());\n      //    GetContainerStatusResponse statusResp;\n      //try {\n      //statusResp \u003d cm.getContainerStatus(statusReq);\n      //    LOG.info(\"Container Status\"\n      //    + \", id\u003d\" + container.getId()\n      //    + \", status\u003d\" +statusResp.getStatus());\n      //} catch (YarnRemoteException e) {\n      //e.printStackTrace();\n      //}\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "fad230a49d0d4cdbb2062b10c3dea6c755737db5": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2719. Add a simple, DistributedShell, application to illustrate alternate frameworks on YARN. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1177864 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/09/11 3:25 PM",
      "commitName": "fad230a49d0d4cdbb2062b10c3dea6c755737db5",
      "commitAuthor": "Arun Murthy",
      "diff": "@@ -0,0 +1,110 @@\n+    public void run() {\n+      // Connect to ContainerManager \n+      LOG.info(\"Connecting to container manager for containerid\u003d\" + container.getId());\n+      connectToCM();\n+\n+      LOG.info(\"Setting up container launch container for containerid\u003d\" + container.getId());\n+      ContainerLaunchContext ctx \u003d Records.newRecord(ContainerLaunchContext.class);\n+\n+      ctx.setContainerId(container.getId());\n+      ctx.setResource(container.getResource());\n+\n+      try {\n+        ctx.setUser(UserGroupInformation.getCurrentUser().getShortUserName());\n+      } catch (IOException e) {\n+        LOG.info(\"Getting current user info failed when trying to launch the container\"\n+            + e.getMessage());\n+      }\n+\n+      // Set the environment \n+      ctx.setEnvironment(shellEnv);\n+\n+      // Set the local resources \n+      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n+\n+      // The container for the eventual shell commands needs its own local resources too. \n+      // In this scenario, if a shell script is specified, we need to have it copied \n+      // and made available to the container. \n+      if (!shellScriptPath.isEmpty()) {\n+        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n+        shellRsrc.setType(LocalResourceType.FILE);\n+        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\t   \n+        try {\n+          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(shellScriptPath)));\n+        } catch (URISyntaxException e) {\n+          LOG.error(\"Error when trying to use shell script path specified in env\"\n+              + \", path\u003d\" + shellScriptPath);\n+          e.printStackTrace();\n+\n+          // A failure scenario on bad input such as invalid shell script path \n+          // We know we cannot continue launching the container \n+          // so we should release it. \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\n+          // TODO\n+          numCompletedContainers.incrementAndGet();\n+          numFailedContainers.incrementAndGet();\n+          return;\t\t\t\t\t\n+        }\n+        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n+        shellRsrc.setSize(shellScriptPathLen);\n+        localResources.put(ExecShellStringPath, shellRsrc);\n+      }\t\t\t\n+      ctx.setLocalResources(localResources);\t\t\t\n+\n+      // Set the necessary command to execute on the allocated container \n+      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n+\n+      // Set executable command \n+      vargs.add(shellCommand);\n+      // Set shell script path \n+      if (!shellScriptPath.isEmpty()) {\n+        vargs.add(ExecShellStringPath);\n+      }\n+\n+      // Set args for the shell command if any\t\t\t\n+      vargs.add(shellArgs);\n+      // Add log redirect params\n+      // TODO\n+      // We should redirect the output to hdfs instead of local logs \n+      // so as to be able to look at the final output after the containers \n+      // have been released. \n+      // Could use a path suffixed with /AppId/AppAttempId/ContainerId/std[out|err] \n+      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n+      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n+\n+      // Get final commmand\n+      StringBuilder command \u003d new StringBuilder();\n+      for (CharSequence str : vargs) {\n+        command.append(str).append(\" \");\n+      }\n+\n+      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n+      commands.add(command.toString());\n+      ctx.setCommands(commands);\n+\n+      StartContainerRequest startReq \u003d Records.newRecord(StartContainerRequest.class);\n+      startReq.setContainerLaunchContext(ctx);\n+      try {\n+        cm.startContainer(startReq);\n+      } catch (YarnRemoteException e) {\n+        LOG.info(\"Start container failed for :\"\n+            + \", containerId\u003d\" + container.getId());\n+        e.printStackTrace();\n+        // TODO do we need to release this container? \n+      }\n+\n+      // Get container status?\n+      // Left commented out as the shell scripts are short lived \n+      // and we are relying on the status for completed containers from RM to detect status\n+\n+      //\t\t    GetContainerStatusRequest statusReq \u003d Records.newRecord(GetContainerStatusRequest.class);\n+      //\t\t    statusReq.setContainerId(container.getId());\n+      //\t\t    GetContainerStatusResponse statusResp;\n+      //\t\t\ttry {\n+      //\t\t\t\tstatusResp \u003d cm.getContainerStatus(statusReq);\n+      //\t\t\t    LOG.info(\"Container Status\"\n+      //\t\t\t    \t\t+ \", id\u003d\" + container.getId()\n+      //\t\t\t    \t\t+ \", status\u003d\" +statusResp.getStatus());\n+      //\t\t\t} catch (YarnRemoteException e) {\n+      //\t\t\t\te.printStackTrace();\n+      //\t\t\t}\n+    }\t\t\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      // Connect to ContainerManager \n      LOG.info(\"Connecting to container manager for containerid\u003d\" + container.getId());\n      connectToCM();\n\n      LOG.info(\"Setting up container launch container for containerid\u003d\" + container.getId());\n      ContainerLaunchContext ctx \u003d Records.newRecord(ContainerLaunchContext.class);\n\n      ctx.setContainerId(container.getId());\n      ctx.setResource(container.getResource());\n\n      try {\n        ctx.setUser(UserGroupInformation.getCurrentUser().getShortUserName());\n      } catch (IOException e) {\n        LOG.info(\"Getting current user info failed when trying to launch the container\"\n            + e.getMessage());\n      }\n\n      // Set the environment \n      ctx.setEnvironment(shellEnv);\n\n      // Set the local resources \n      Map\u003cString, LocalResource\u003e localResources \u003d new HashMap\u003cString, LocalResource\u003e();\n\n      // The container for the eventual shell commands needs its own local resources too. \n      // In this scenario, if a shell script is specified, we need to have it copied \n      // and made available to the container. \n      if (!shellScriptPath.isEmpty()) {\n        LocalResource shellRsrc \u003d Records.newRecord(LocalResource.class);\n        shellRsrc.setType(LocalResourceType.FILE);\n        shellRsrc.setVisibility(LocalResourceVisibility.APPLICATION);\t   \n        try {\n          shellRsrc.setResource(ConverterUtils.getYarnUrlFromURI(new URI(shellScriptPath)));\n        } catch (URISyntaxException e) {\n          LOG.error(\"Error when trying to use shell script path specified in env\"\n              + \", path\u003d\" + shellScriptPath);\n          e.printStackTrace();\n\n          // A failure scenario on bad input such as invalid shell script path \n          // We know we cannot continue launching the container \n          // so we should release it. \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\n          // TODO\n          numCompletedContainers.incrementAndGet();\n          numFailedContainers.incrementAndGet();\n          return;\t\t\t\t\t\n        }\n        shellRsrc.setTimestamp(shellScriptPathTimestamp);\n        shellRsrc.setSize(shellScriptPathLen);\n        localResources.put(ExecShellStringPath, shellRsrc);\n      }\t\t\t\n      ctx.setLocalResources(localResources);\t\t\t\n\n      // Set the necessary command to execute on the allocated container \n      Vector\u003cCharSequence\u003e vargs \u003d new Vector\u003cCharSequence\u003e(5);\n\n      // Set executable command \n      vargs.add(shellCommand);\n      // Set shell script path \n      if (!shellScriptPath.isEmpty()) {\n        vargs.add(ExecShellStringPath);\n      }\n\n      // Set args for the shell command if any\t\t\t\n      vargs.add(shellArgs);\n      // Add log redirect params\n      // TODO\n      // We should redirect the output to hdfs instead of local logs \n      // so as to be able to look at the final output after the containers \n      // have been released. \n      // Could use a path suffixed with /AppId/AppAttempId/ContainerId/std[out|err] \n      vargs.add(\"1\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");\n      vargs.add(\"2\u003e\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");\n\n      // Get final commmand\n      StringBuilder command \u003d new StringBuilder();\n      for (CharSequence str : vargs) {\n        command.append(str).append(\" \");\n      }\n\n      List\u003cString\u003e commands \u003d new ArrayList\u003cString\u003e();\n      commands.add(command.toString());\n      ctx.setCommands(commands);\n\n      StartContainerRequest startReq \u003d Records.newRecord(StartContainerRequest.class);\n      startReq.setContainerLaunchContext(ctx);\n      try {\n        cm.startContainer(startReq);\n      } catch (YarnRemoteException e) {\n        LOG.info(\"Start container failed for :\"\n            + \", containerId\u003d\" + container.getId());\n        e.printStackTrace();\n        // TODO do we need to release this container? \n      }\n\n      // Get container status?\n      // Left commented out as the shell scripts are short lived \n      // and we are relying on the status for completed containers from RM to detect status\n\n      //\t\t    GetContainerStatusRequest statusReq \u003d Records.newRecord(GetContainerStatusRequest.class);\n      //\t\t    statusReq.setContainerId(container.getId());\n      //\t\t    GetContainerStatusResponse statusResp;\n      //\t\t\ttry {\n      //\t\t\t\tstatusResp \u003d cm.getContainerStatus(statusReq);\n      //\t\t\t    LOG.info(\"Container Status\"\n      //\t\t\t    \t\t+ \", id\u003d\" + container.getId()\n      //\t\t\t    \t\t+ \", status\u003d\" +statusResp.getStatus());\n      //\t\t\t} catch (YarnRemoteException e) {\n      //\t\t\t\te.printStackTrace();\n      //\t\t\t}\n    }\t\t",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java"
    }
  }
}