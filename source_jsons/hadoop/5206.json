{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirAppendOp.java",
  "functionName": "prepareFileForAppend",
  "functionId": "prepareFileForAppend___fsn-FSNamesystem(modifiers-final)__iip-INodesInPath(modifiers-final)__leaseHolder-String(modifiers-final)__clientMachine-String(modifiers-final)__newBlock-boolean(modifiers-final)__writeToEditLog-boolean(modifiers-final)__logRetryCache-boolean(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
  "functionStartLine": 178,
  "functionEndLine": 226,
  "numCommitsSeen": 1568,
  "timeTaken": 22372,
  "changeHistory": [
    "5962a518bd141e0e187342af89f6cab6011e75fb",
    "f940ab242da80a22bae95509d5c282d7e2f7ecdb",
    "31f117138a00794de4951ee8433e304d72b04094",
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
    "c7c71cdba50cb7d8282622cd496cc913c80cff54",
    "5dae97a584d30cef3e34141edfaca49c4ec57913",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "2848db814a98b83e7546f65a2751e56fb5b2dbe0",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
    "05af0ff4be871ddbb4c4cb4f0b5b506ecee36fb8",
    "88209ce181b5ecc55c0ae2bceff4893ab4817e88",
    "6104520369045dfaa4b543cbad21236ed322249b",
    "80691b073fe7c104a8684c0a8900a1657bcdc03f"
  ],
  "changeHistoryShort": {
    "5962a518bd141e0e187342af89f6cab6011e75fb": "Ybodychange",
    "f940ab242da80a22bae95509d5c282d7e2f7ecdb": "Ybodychange",
    "31f117138a00794de4951ee8433e304d72b04094": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparametermetachange,Yparameterchange)",
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63": "Ybodychange",
    "c7c71cdba50cb7d8282622cd496cc913c80cff54": "Ybodychange",
    "5dae97a584d30cef3e34141edfaca49c4ec57913": "Ybodychange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Ybodychange",
    "2848db814a98b83e7546f65a2751e56fb5b2dbe0": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": "Ybodychange",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": "Ymultichange(Yparameterchange,Ybodychange)",
    "05af0ff4be871ddbb4c4cb4f0b5b506ecee36fb8": "Ymodifierchange",
    "88209ce181b5ecc55c0ae2bceff4893ab4817e88": "Ymodifierchange",
    "6104520369045dfaa4b543cbad21236ed322249b": "Ybodychange",
    "80691b073fe7c104a8684c0a8900a1657bcdc03f": "Ybodychange"
  },
  "changeHistoryDetails": {
    "5962a518bd141e0e187342af89f6cab6011e75fb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14581. Appending to EC files crashes NameNode. Contributed by Surendra Singh Lilhore.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "20/06/19 9:40 AM",
      "commitName": "5962a518bd141e0e187342af89f6cab6011e75fb",
      "commitAuthor": "Surendra Singh Lilhore",
      "commitDateOld": "05/03/19 5:56 AM",
      "commitNameOld": "f940ab242da80a22bae95509d5c282d7e2f7ecdb",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 107.11,
      "commitsBetweenForRepo": 728,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,49 @@\n   static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n       final INodesInPath iip, final String leaseHolder,\n       final String clientMachine, final boolean newBlock,\n       final boolean writeToEditLog, final boolean logRetryCache)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     final INodeFile file \u003d iip.getLastINode().asFile();\n     final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n \n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n-      if (file.isStriped()) {\n-        throw new UnsupportedOperationException(\n-            \"Append on EC file without new block is not supported.\");\n-      }\n       FSDirectory fsd \u003d fsn.getFSDirectory();\n       ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n         Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n             + \" a block with size larger than the preferred block size\");\n         fsd.writeLock();\n         try {\n           fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n         } finally {\n           fsd.writeUnlock();\n         }\n       }\n     } else {\n       BlockInfo lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n         ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n       final String path \u003d iip.getPath();\n       if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n           fsn.getEffectiveLayoutVersion())) {\n         fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n       } else {\n         fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n      final INodesInPath iip, final String leaseHolder,\n      final String clientMachine, final boolean newBlock,\n      final boolean writeToEditLog, final boolean logRetryCache)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      FSDirectory fsd \u003d fsn.getFSDirectory();\n      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n            + \" a block with size larger than the preferred block size\");\n        fsd.writeLock();\n        try {\n          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n        } finally {\n          fsd.writeUnlock();\n        }\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      final String path \u003d iip.getPath();\n      if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n          fsn.getEffectiveLayoutVersion())) {\n        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n      } else {\n        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "f940ab242da80a22bae95509d5c282d7e2f7ecdb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7663. Erasure Coding: Append on striped file. Contributed by Ayush Saxena.\n",
      "commitDate": "05/03/19 5:56 AM",
      "commitName": "f940ab242da80a22bae95509d5c282d7e2f7ecdb",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "11/12/17 8:14 PM",
      "commitNameOld": "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 448.4,
      "commitsBetweenForRepo": 3913,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,53 @@\n   static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n       final INodesInPath iip, final String leaseHolder,\n       final String clientMachine, final boolean newBlock,\n       final boolean writeToEditLog, final boolean logRetryCache)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     final INodeFile file \u003d iip.getLastINode().asFile();\n     final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n \n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n+      if (file.isStriped()) {\n+        throw new UnsupportedOperationException(\n+            \"Append on EC file without new block is not supported.\");\n+      }\n       FSDirectory fsd \u003d fsn.getFSDirectory();\n       ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n         Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n             + \" a block with size larger than the preferred block size\");\n         fsd.writeLock();\n         try {\n           fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n         } finally {\n           fsd.writeUnlock();\n         }\n       }\n     } else {\n       BlockInfo lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n         ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n       final String path \u003d iip.getPath();\n       if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n           fsn.getEffectiveLayoutVersion())) {\n         fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n       } else {\n         fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n      final INodesInPath iip, final String leaseHolder,\n      final String clientMachine, final boolean newBlock,\n      final boolean writeToEditLog, final boolean logRetryCache)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      if (file.isStriped()) {\n        throw new UnsupportedOperationException(\n            \"Append on EC file without new block is not supported.\");\n      }\n      FSDirectory fsd \u003d fsn.getFSDirectory();\n      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n            + \" a block with size larger than the preferred block size\");\n        fsd.writeLock();\n        try {\n          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n        } finally {\n          fsd.writeUnlock();\n        }\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      final String path \u003d iip.getPath();\n      if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n          fsn.getEffectiveLayoutVersion())) {\n        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n      } else {\n        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "31f117138a00794de4951ee8433e304d72b04094": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparametermetachange,Yparameterchange)",
      "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
      "commitDate": "21/07/15 5:25 PM",
      "commitName": "31f117138a00794de4951ee8433e304d72b04094",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,49 @@\n-  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n-      String leaseHolder, String clientMachine, boolean newBlock,\n-      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n+  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n+      final INodesInPath iip, final String leaseHolder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean writeToEditLog, final boolean logRetryCache)\n+      throws IOException {\n+    assert fsn.hasWriteLock();\n+\n     final INodeFile file \u003d iip.getLastINode().asFile();\n-    final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n+    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n \n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n-    leaseManager.addLease(\n+    fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n-      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n+      FSDirectory fsd \u003d fsn.getFSDirectory();\n+      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n-        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n-            \"appending to a block with size larger than the preferred block size\");\n-        dir.writeLock();\n+        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n+            + \" a block with size larger than the preferred block size\");\n+        fsd.writeLock();\n         try {\n-          dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n+          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n         } finally {\n-          dir.writeUnlock();\n+          fsd.writeUnlock();\n         }\n       }\n     } else {\n       BlockInfo lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n-        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n+        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n+      final String path \u003d iip.getPath();\n       if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n-          getEffectiveLayoutVersion())) {\n-        getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n+          fsn.getEffectiveLayoutVersion())) {\n+        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n       } else {\n-        getEditLog().logOpenFile(src, file, false, logRetryCache);\n+        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n      final INodesInPath iip, final String leaseHolder,\n      final String clientMachine, final boolean newBlock,\n      final boolean writeToEditLog, final boolean logRetryCache)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      FSDirectory fsd \u003d fsn.getFSDirectory();\n      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n            + \" a block with size larger than the preferred block size\");\n        fsd.writeLock();\n        try {\n          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n        } finally {\n          fsd.writeUnlock();\n        }\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      final String path \u003d iip.getPath();\n      if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n          fsn.getEffectiveLayoutVersion())) {\n        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n      } else {\n        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
            "oldMethodName": "prepareFileForAppend",
            "newMethodName": "prepareFileForAppend"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,49 @@\n-  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n-      String leaseHolder, String clientMachine, boolean newBlock,\n-      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n+  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n+      final INodesInPath iip, final String leaseHolder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean writeToEditLog, final boolean logRetryCache)\n+      throws IOException {\n+    assert fsn.hasWriteLock();\n+\n     final INodeFile file \u003d iip.getLastINode().asFile();\n-    final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n+    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n \n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n-    leaseManager.addLease(\n+    fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n-      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n+      FSDirectory fsd \u003d fsn.getFSDirectory();\n+      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n-        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n-            \"appending to a block with size larger than the preferred block size\");\n-        dir.writeLock();\n+        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n+            + \" a block with size larger than the preferred block size\");\n+        fsd.writeLock();\n         try {\n-          dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n+          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n         } finally {\n-          dir.writeUnlock();\n+          fsd.writeUnlock();\n         }\n       }\n     } else {\n       BlockInfo lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n-        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n+        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n+      final String path \u003d iip.getPath();\n       if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n-          getEffectiveLayoutVersion())) {\n-        getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n+          fsn.getEffectiveLayoutVersion())) {\n+        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n       } else {\n-        getEditLog().logOpenFile(src, file, false, logRetryCache);\n+        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n      final INodesInPath iip, final String leaseHolder,\n      final String clientMachine, final boolean newBlock,\n      final boolean writeToEditLog, final boolean logRetryCache)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      FSDirectory fsd \u003d fsn.getFSDirectory();\n      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n            + \" a block with size larger than the preferred block size\");\n        fsd.writeLock();\n        try {\n          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n        } finally {\n          fsd.writeUnlock();\n        }\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      final String path \u003d iip.getPath();\n      if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n          fsn.getEffectiveLayoutVersion())) {\n        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n      } else {\n        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,49 @@\n-  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n-      String leaseHolder, String clientMachine, boolean newBlock,\n-      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n+  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n+      final INodesInPath iip, final String leaseHolder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean writeToEditLog, final boolean logRetryCache)\n+      throws IOException {\n+    assert fsn.hasWriteLock();\n+\n     final INodeFile file \u003d iip.getLastINode().asFile();\n-    final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n+    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n \n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n-    leaseManager.addLease(\n+    fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n-      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n+      FSDirectory fsd \u003d fsn.getFSDirectory();\n+      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n-        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n-            \"appending to a block with size larger than the preferred block size\");\n-        dir.writeLock();\n+        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n+            + \" a block with size larger than the preferred block size\");\n+        fsd.writeLock();\n         try {\n-          dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n+          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n         } finally {\n-          dir.writeUnlock();\n+          fsd.writeUnlock();\n         }\n       }\n     } else {\n       BlockInfo lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n-        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n+        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n+      final String path \u003d iip.getPath();\n       if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n-          getEffectiveLayoutVersion())) {\n-        getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n+          fsn.getEffectiveLayoutVersion())) {\n+        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n       } else {\n-        getEditLog().logOpenFile(src, file, false, logRetryCache);\n+        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n      final INodesInPath iip, final String leaseHolder,\n      final String clientMachine, final boolean newBlock,\n      final boolean writeToEditLog, final boolean logRetryCache)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      FSDirectory fsd \u003d fsn.getFSDirectory();\n      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n            + \" a block with size larger than the preferred block size\");\n        fsd.writeLock();\n        try {\n          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n        } finally {\n          fsd.writeUnlock();\n        }\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      final String path \u003d iip.getPath();\n      if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n          fsn.getEffectiveLayoutVersion())) {\n        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n      } else {\n        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,49 @@\n-  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n-      String leaseHolder, String clientMachine, boolean newBlock,\n-      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n+  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n+      final INodesInPath iip, final String leaseHolder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean writeToEditLog, final boolean logRetryCache)\n+      throws IOException {\n+    assert fsn.hasWriteLock();\n+\n     final INodeFile file \u003d iip.getLastINode().asFile();\n-    final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n+    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n \n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n-    leaseManager.addLease(\n+    fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n-      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n+      FSDirectory fsd \u003d fsn.getFSDirectory();\n+      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n-        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n-            \"appending to a block with size larger than the preferred block size\");\n-        dir.writeLock();\n+        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n+            + \" a block with size larger than the preferred block size\");\n+        fsd.writeLock();\n         try {\n-          dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n+          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n         } finally {\n-          dir.writeUnlock();\n+          fsd.writeUnlock();\n         }\n       }\n     } else {\n       BlockInfo lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n-        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n+        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n+      final String path \u003d iip.getPath();\n       if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n-          getEffectiveLayoutVersion())) {\n-        getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n+          fsn.getEffectiveLayoutVersion())) {\n+        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n       } else {\n-        getEditLog().logOpenFile(src, file, false, logRetryCache);\n+        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n      final INodesInPath iip, final String leaseHolder,\n      final String clientMachine, final boolean newBlock,\n      final boolean writeToEditLog, final boolean logRetryCache)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      FSDirectory fsd \u003d fsn.getFSDirectory();\n      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n            + \" a block with size larger than the preferred block size\");\n        fsd.writeLock();\n        try {\n          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n        } finally {\n          fsd.writeUnlock();\n        }\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      final String path \u003d iip.getPath();\n      if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n          fsn.getEffectiveLayoutVersion())) {\n        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n      } else {\n        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {
            "oldValue": "[src-String, iip-INodesInPath, leaseHolder-String, clientMachine-String, newBlock-boolean, writeToEditLog-boolean, logRetryCache-boolean]",
            "newValue": "[fsn-FSNamesystem(modifiers-final), iip-INodesInPath(modifiers-final), leaseHolder-String(modifiers-final), clientMachine-String(modifiers-final), newBlock-boolean(modifiers-final), writeToEditLog-boolean(modifiers-final), logRetryCache-boolean(modifiers-final)]"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,49 @@\n-  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n-      String leaseHolder, String clientMachine, boolean newBlock,\n-      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n+  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n+      final INodesInPath iip, final String leaseHolder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean writeToEditLog, final boolean logRetryCache)\n+      throws IOException {\n+    assert fsn.hasWriteLock();\n+\n     final INodeFile file \u003d iip.getLastINode().asFile();\n-    final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n+    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n \n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n-    leaseManager.addLease(\n+    fsn.getLeaseManager().addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n-      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n+      FSDirectory fsd \u003d fsn.getFSDirectory();\n+      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n-        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n-            \"appending to a block with size larger than the preferred block size\");\n-        dir.writeLock();\n+        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n+            + \" a block with size larger than the preferred block size\");\n+        fsd.writeLock();\n         try {\n-          dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n+          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n         } finally {\n-          dir.writeUnlock();\n+          fsd.writeUnlock();\n         }\n       }\n     } else {\n       BlockInfo lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n-        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n+        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n+      final String path \u003d iip.getPath();\n       if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n-          getEffectiveLayoutVersion())) {\n-        getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n+          fsn.getEffectiveLayoutVersion())) {\n+        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n       } else {\n-        getEditLog().logOpenFile(src, file, false, logRetryCache);\n+        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LocatedBlock prepareFileForAppend(final FSNamesystem fsn,\n      final INodesInPath iip, final String leaseHolder,\n      final String clientMachine, final boolean newBlock,\n      final boolean writeToEditLog, final boolean logRetryCache)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    final QuotaCounts delta \u003d verifyQuotaForUCBlock(fsn, file, iip);\n\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    fsn.getLeaseManager().addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      FSDirectory fsd \u003d fsn.getFSDirectory();\n      ret \u003d fsd.getBlockManager().convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0, \"appending to\"\n            + \" a block with size larger than the preferred block size\");\n        fsd.writeLock();\n        try {\n          fsd.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n        } finally {\n          fsd.writeUnlock();\n        }\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(fsn.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      final String path \u003d iip.getPath();\n      if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n          fsn.getEffectiveLayoutVersion())) {\n        fsn.getEditLog().logAppendFile(path, file, newBlock, logRetryCache);\n      } else {\n        fsn.getEditLog().logOpenFile(path, file, false, logRetryCache);\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {
            "oldValue": "[src-String, iip-INodesInPath, leaseHolder-String, clientMachine-String, newBlock-boolean, writeToEditLog-boolean, logRetryCache-boolean]",
            "newValue": "[fsn-FSNamesystem(modifiers-final), iip-INodesInPath(modifiers-final), leaseHolder-String(modifiers-final), clientMachine-String(modifiers-final), newBlock-boolean(modifiers-final), writeToEditLog-boolean(modifiers-final), logRetryCache-boolean(modifiers-final)]"
          }
        }
      ]
    },
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8432. Introduce a minimum compatible layout version to allow downgrade in more rolling upgrade use cases. Contributed by Chris Nauroth.\n",
      "commitDate": "06/06/15 9:43 AM",
      "commitName": "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
      "commitAuthor": "cnauroth",
      "commitDateOld": "05/06/15 3:09 PM",
      "commitNameOld": "3841d09765bab332c9ae4803c5981799585b1f41",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,43 @@\n   LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n       String leaseHolder, String clientMachine, boolean newBlock,\n       boolean writeToEditLog, boolean logRetryCache) throws IOException {\n     final INodeFile file \u003d iip.getLastINode().asFile();\n     final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n \n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n       ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n         Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n             \"appending to a block with size larger than the preferred block size\");\n         dir.writeLock();\n         try {\n           dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n         } finally {\n           dir.writeUnlock();\n         }\n       }\n     } else {\n       BlockInfo lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n         ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n-      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n+      if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n+          getEffectiveLayoutVersion())) {\n+        getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n+      } else {\n+        getEditLog().logOpenFile(src, file, false, logRetryCache);\n+      }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean newBlock,\n      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n            \"appending to a block with size larger than the preferred block size\");\n        dir.writeLock();\n        try {\n          dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n        } finally {\n          dir.writeUnlock();\n        }\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      if (NameNodeLayoutVersion.supports(Feature.APPEND_NEW_BLOCK,\n          getEffectiveLayoutVersion())) {\n        getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n      } else {\n        getEditLog().logOpenFile(src, file, false, logRetryCache);\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/05/15 8:08 AM",
      "commitNameOld": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 6.32,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n       String leaseHolder, String clientMachine, boolean newBlock,\n       boolean writeToEditLog, boolean logRetryCache) throws IOException {\n     final INodeFile file \u003d iip.getLastINode().asFile();\n     final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n \n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), file.getId());\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n       ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n         Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n             \"appending to a block with size larger than the preferred block size\");\n         dir.writeLock();\n         try {\n           dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n         } finally {\n           dir.writeUnlock();\n         }\n       }\n     } else {\n-      BlockInfoContiguous lastBlock \u003d file.getLastBlock();\n+      BlockInfo lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n         ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n       getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean newBlock,\n      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n            \"appending to a block with size larger than the preferred block size\");\n        dir.writeLock();\n        try {\n          dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n        } finally {\n          dir.writeUnlock();\n        }\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6757. Simplify lease manager with INodeID. Contributed by Haohui Mai.\n",
      "commitDate": "08/05/15 11:04 PM",
      "commitName": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "08/05/15 7:30 AM",
      "commitNameOld": "6f622672b62aa8d719060063ef0e47480cdc8655",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.65,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n       String leaseHolder, String clientMachine, boolean newBlock,\n       boolean writeToEditLog, boolean logRetryCache) throws IOException {\n     final INodeFile file \u003d iip.getLastINode().asFile();\n     final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n \n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(\n-        file.getFileUnderConstructionFeature().getClientName(), src);\n+        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n       ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n         Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n             \"appending to a block with size larger than the preferred block size\");\n         dir.writeLock();\n         try {\n           dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n         } finally {\n           dir.writeUnlock();\n         }\n       }\n     } else {\n       BlockInfoContiguous lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n         ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n       getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean newBlock,\n      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), file.getId());\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n            \"appending to a block with size larger than the preferred block size\");\n        dir.writeLock();\n        try {\n          dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n        } finally {\n          dir.writeUnlock();\n        }\n      }\n    } else {\n      BlockInfoContiguous lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "c7c71cdba50cb7d8282622cd496cc913c80cff54": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7587. Edit log corruption can happen if append fails with a quota violation. Contributed by Jing Zhao.\n",
      "commitDate": "18/03/15 6:53 PM",
      "commitName": "c7c71cdba50cb7d8282622cd496cc913c80cff54",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/03/15 10:42 AM",
      "commitNameOld": "f446669afb5c3d31a00c65449f27088b39e11ae3",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 5.34,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,38 @@\n   LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n       String leaseHolder, String clientMachine, boolean newBlock,\n       boolean writeToEditLog, boolean logRetryCache) throws IOException {\n     final INodeFile file \u003d iip.getLastINode().asFile();\n+    final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n+\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), src);\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n       ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n-      if (ret !\u003d null) {\n-        // update the quota: use the preferred block size for UC block\n-        final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n-        dir.updateSpaceConsumed(iip, 0, diff, file.getBlockReplication());\n+      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n+        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n+            \"appending to a block with size larger than the preferred block size\");\n+        dir.writeLock();\n+        try {\n+          dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n+        } finally {\n+          dir.writeUnlock();\n+        }\n       }\n     } else {\n       BlockInfoContiguous lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n         ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n       getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean newBlock,\n      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    final QuotaCounts delta \u003d verifyQuotaForUCBlock(file, iip);\n\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null \u0026\u0026 delta !\u003d null) {\n        Preconditions.checkState(delta.getStorageSpace() \u003e\u003d 0,\n            \"appending to a block with size larger than the preferred block size\");\n        dir.writeLock();\n        try {\n          dir.updateCountNoQuotaCheck(iip, iip.length() - 1, delta);\n        } finally {\n          dir.writeUnlock();\n        }\n      }\n    } else {\n      BlockInfoContiguous lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "5dae97a584d30cef3e34141edfaca49c4ec57913": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7723. Quota By Storage Type namenode implemenation. (Contributed by Xiaoyu Yao)\n",
      "commitDate": "11/02/15 10:41 AM",
      "commitName": "5dae97a584d30cef3e34141edfaca49c4ec57913",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "08/02/15 11:51 AM",
      "commitNameOld": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n   LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n       String leaseHolder, String clientMachine, boolean newBlock,\n       boolean writeToEditLog, boolean logRetryCache) throws IOException {\n     final INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), src);\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n       ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null) {\n         // update the quota: use the preferred block size for UC block\n         final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n-        dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n+        dir.updateSpaceConsumed(iip, 0, diff, file.getBlockReplication());\n       }\n     } else {\n       BlockInfoContiguous lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n         ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n       getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean newBlock,\n      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null) {\n        // update the quota: use the preferred block size for UC block\n        final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n        dir.updateSpaceConsumed(iip, 0, diff, file.getBlockReplication());\n      }\n    } else {\n      BlockInfoContiguous lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "07/02/15 3:21 PM",
      "commitNameOld": "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.85,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n   LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n       String leaseHolder, String clientMachine, boolean newBlock,\n       boolean writeToEditLog, boolean logRetryCache) throws IOException {\n     final INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), src);\n \n     LocatedBlock ret \u003d null;\n     if (!newBlock) {\n       ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n       if (ret !\u003d null) {\n         // update the quota: use the preferred block size for UC block\n         final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n         dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n       }\n     } else {\n-      BlockInfo lastBlock \u003d file.getLastBlock();\n+      BlockInfoContiguous lastBlock \u003d file.getLastBlock();\n       if (lastBlock !\u003d null) {\n         ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n         ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n       }\n     }\n \n     if (writeToEditLog) {\n       getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean newBlock,\n      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null) {\n        // update the quota: use the preferred block size for UC block\n        final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n        dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n      }\n    } else {\n      BlockInfoContiguous lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "2848db814a98b83e7546f65a2751e56fb5b2dbe0": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-3689. Add support for variable length block. Contributed by Jing Zhao.\n",
      "commitDate": "27/01/15 12:58 PM",
      "commitName": "2848db814a98b83e7546f65a2751e56fb5b2dbe0",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-3689. Add support for variable length block. Contributed by Jing Zhao.\n",
          "commitDate": "27/01/15 12:58 PM",
          "commitName": "2848db814a98b83e7546f65a2751e56fb5b2dbe0",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "24/01/15 3:44 PM",
          "commitNameOld": "e9fd46ddbf46954cfda4bb9c33f1789775be9d18",
          "commitAuthorOld": "yliu",
          "daysBetweenCommits": 2.88,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,31 @@\n-  LocatedBlock prepareFileForWrite(String src, INodesInPath iip,\n-      String leaseHolder, String clientMachine, boolean writeToEditLog,\n-      boolean logRetryCache) throws IOException {\n+  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n+      String leaseHolder, String clientMachine, boolean newBlock,\n+      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n     final INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), src);\n-    \n-    LocatedBlock ret \u003d\n-        blockManager.convertLastBlockToUnderConstruction(file, 0);\n-    if (ret !\u003d null) {\n-      // update the quota: use the preferred block size for UC block\n-      final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n-      dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n+\n+    LocatedBlock ret \u003d null;\n+    if (!newBlock) {\n+      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n+      if (ret !\u003d null) {\n+        // update the quota: use the preferred block size for UC block\n+        final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n+        dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n+      }\n+    } else {\n+      BlockInfo lastBlock \u003d file.getLastBlock();\n+      if (lastBlock !\u003d null) {\n+        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n+        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n+      }\n     }\n \n     if (writeToEditLog) {\n-      getEditLog().logOpenFile(src, file, false, logRetryCache);\n+      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean newBlock,\n      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null) {\n        // update the quota: use the preferred block size for UC block\n        final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n        dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "prepareFileForWrite",
            "newValue": "prepareFileForAppend"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-3689. Add support for variable length block. Contributed by Jing Zhao.\n",
          "commitDate": "27/01/15 12:58 PM",
          "commitName": "2848db814a98b83e7546f65a2751e56fb5b2dbe0",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "24/01/15 3:44 PM",
          "commitNameOld": "e9fd46ddbf46954cfda4bb9c33f1789775be9d18",
          "commitAuthorOld": "yliu",
          "daysBetweenCommits": 2.88,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,31 @@\n-  LocatedBlock prepareFileForWrite(String src, INodesInPath iip,\n-      String leaseHolder, String clientMachine, boolean writeToEditLog,\n-      boolean logRetryCache) throws IOException {\n+  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n+      String leaseHolder, String clientMachine, boolean newBlock,\n+      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n     final INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), src);\n-    \n-    LocatedBlock ret \u003d\n-        blockManager.convertLastBlockToUnderConstruction(file, 0);\n-    if (ret !\u003d null) {\n-      // update the quota: use the preferred block size for UC block\n-      final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n-      dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n+\n+    LocatedBlock ret \u003d null;\n+    if (!newBlock) {\n+      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n+      if (ret !\u003d null) {\n+        // update the quota: use the preferred block size for UC block\n+        final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n+        dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n+      }\n+    } else {\n+      BlockInfo lastBlock \u003d file.getLastBlock();\n+      if (lastBlock !\u003d null) {\n+        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n+        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n+      }\n     }\n \n     if (writeToEditLog) {\n-      getEditLog().logOpenFile(src, file, false, logRetryCache);\n+      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean newBlock,\n      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null) {\n        // update the quota: use the preferred block size for UC block\n        final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n        dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[src-String, iip-INodesInPath, leaseHolder-String, clientMachine-String, writeToEditLog-boolean, logRetryCache-boolean]",
            "newValue": "[src-String, iip-INodesInPath, leaseHolder-String, clientMachine-String, newBlock-boolean, writeToEditLog-boolean, logRetryCache-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3689. Add support for variable length block. Contributed by Jing Zhao.\n",
          "commitDate": "27/01/15 12:58 PM",
          "commitName": "2848db814a98b83e7546f65a2751e56fb5b2dbe0",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "24/01/15 3:44 PM",
          "commitNameOld": "e9fd46ddbf46954cfda4bb9c33f1789775be9d18",
          "commitAuthorOld": "yliu",
          "daysBetweenCommits": 2.88,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,31 @@\n-  LocatedBlock prepareFileForWrite(String src, INodesInPath iip,\n-      String leaseHolder, String clientMachine, boolean writeToEditLog,\n-      boolean logRetryCache) throws IOException {\n+  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n+      String leaseHolder, String clientMachine, boolean newBlock,\n+      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n     final INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), src);\n-    \n-    LocatedBlock ret \u003d\n-        blockManager.convertLastBlockToUnderConstruction(file, 0);\n-    if (ret !\u003d null) {\n-      // update the quota: use the preferred block size for UC block\n-      final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n-      dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n+\n+    LocatedBlock ret \u003d null;\n+    if (!newBlock) {\n+      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n+      if (ret !\u003d null) {\n+        // update the quota: use the preferred block size for UC block\n+        final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n+        dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n+      }\n+    } else {\n+      BlockInfo lastBlock \u003d file.getLastBlock();\n+      if (lastBlock !\u003d null) {\n+        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n+        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n+      }\n     }\n \n     if (writeToEditLog) {\n-      getEditLog().logOpenFile(src, file, false, logRetryCache);\n+      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  LocatedBlock prepareFileForAppend(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean newBlock,\n      boolean writeToEditLog, boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n\n    LocatedBlock ret \u003d null;\n    if (!newBlock) {\n      ret \u003d blockManager.convertLastBlockToUnderConstruction(file, 0);\n      if (ret !\u003d null) {\n        // update the quota: use the preferred block size for UC block\n        final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n        dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n      }\n    } else {\n      BlockInfo lastBlock \u003d file.getLastBlock();\n      if (lastBlock !\u003d null) {\n        ExtendedBlock blk \u003d new ExtendedBlock(this.getBlockPoolId(), lastBlock);\n        ret \u003d new LocatedBlock(blk, new DatanodeInfo[0]);\n      }\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logAppendFile(src, file, newBlock, logRetryCache);\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7056. Snapshot support for truncate. Contributed by Konstantin Shvachko and Plamen Jeliazkov.",
      "commitDate": "13/01/15 12:24 AM",
      "commitName": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "12/01/15 10:50 PM",
      "commitNameOld": "7e9358feb326d48b8c4f00249e7af5023cebd2e2",
      "commitAuthorOld": "Plamen Jeliazkov",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,23 @@\n   LocatedBlock prepareFileForWrite(String src, INodesInPath iip,\n       String leaseHolder, String clientMachine, boolean writeToEditLog,\n       boolean logRetryCache) throws IOException {\n     final INodeFile file \u003d iip.getLastINode().asFile();\n     file.recordModification(iip.getLatestSnapshotId());\n     file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(\n         file.getFileUnderConstructionFeature().getClientName(), src);\n     \n-    LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(file);\n+    LocatedBlock ret \u003d\n+        blockManager.convertLastBlockToUnderConstruction(file, 0);\n     if (ret !\u003d null) {\n       // update the quota: use the preferred block size for UC block\n       final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n       dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n     }\n \n     if (writeToEditLog) {\n       getEditLog().logOpenFile(src, file, false, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  LocatedBlock prepareFileForWrite(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean writeToEditLog,\n      boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n    \n    LocatedBlock ret \u003d\n        blockManager.convertLastBlockToUnderConstruction(file, 0);\n    if (ret !\u003d null) {\n      // update the quota: use the preferred block size for UC block\n      final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n      dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logOpenFile(src, file, false, logRetryCache);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
      "commitDate": "12/12/14 3:13 PM",
      "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "12/12/14 11:51 AM",
          "commitNameOld": "46612c7a5135d20b20403780b47dd00654aab057",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,22 @@\n-  LocatedBlock prepareFileForWrite(String src, INodeFile file,\n-                                   String leaseHolder, String clientMachine,\n-                                   boolean writeToEditLog,\n-                                   int latestSnapshot, boolean logRetryCache)\n-      throws IOException {\n-    file.recordModification(latestSnapshot);\n-    final INodeFile cons \u003d file.toUnderConstruction(leaseHolder, clientMachine);\n+  LocatedBlock prepareFileForWrite(String src, INodesInPath iip,\n+      String leaseHolder, String clientMachine, boolean writeToEditLog,\n+      boolean logRetryCache) throws IOException {\n+    final INodeFile file \u003d iip.getLastINode().asFile();\n+    file.recordModification(iip.getLatestSnapshotId());\n+    file.toUnderConstruction(leaseHolder, clientMachine);\n \n-    leaseManager.addLease(cons.getFileUnderConstructionFeature()\n-        .getClientName(), src);\n+    leaseManager.addLease(\n+        file.getFileUnderConstructionFeature().getClientName(), src);\n     \n-    LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(cons);\n+    LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(file);\n     if (ret !\u003d null) {\n       // update the quota: use the preferred block size for UC block\n       final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n-      dir.updateSpaceConsumed(src, 0, diff * file.getBlockReplication());\n+      dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n     }\n \n     if (writeToEditLog) {\n-      getEditLog().logOpenFile(src, cons, false, logRetryCache);\n+      getEditLog().logOpenFile(src, file, false, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  LocatedBlock prepareFileForWrite(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean writeToEditLog,\n      boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n    \n    LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(file);\n    if (ret !\u003d null) {\n      // update the quota: use the preferred block size for UC block\n      final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n      dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logOpenFile(src, file, false, logRetryCache);\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[src-String, file-INodeFile, leaseHolder-String, clientMachine-String, writeToEditLog-boolean, latestSnapshot-int, logRetryCache-boolean]",
            "newValue": "[src-String, iip-INodesInPath, leaseHolder-String, clientMachine-String, writeToEditLog-boolean, logRetryCache-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "12/12/14 11:51 AM",
          "commitNameOld": "46612c7a5135d20b20403780b47dd00654aab057",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,22 @@\n-  LocatedBlock prepareFileForWrite(String src, INodeFile file,\n-                                   String leaseHolder, String clientMachine,\n-                                   boolean writeToEditLog,\n-                                   int latestSnapshot, boolean logRetryCache)\n-      throws IOException {\n-    file.recordModification(latestSnapshot);\n-    final INodeFile cons \u003d file.toUnderConstruction(leaseHolder, clientMachine);\n+  LocatedBlock prepareFileForWrite(String src, INodesInPath iip,\n+      String leaseHolder, String clientMachine, boolean writeToEditLog,\n+      boolean logRetryCache) throws IOException {\n+    final INodeFile file \u003d iip.getLastINode().asFile();\n+    file.recordModification(iip.getLatestSnapshotId());\n+    file.toUnderConstruction(leaseHolder, clientMachine);\n \n-    leaseManager.addLease(cons.getFileUnderConstructionFeature()\n-        .getClientName(), src);\n+    leaseManager.addLease(\n+        file.getFileUnderConstructionFeature().getClientName(), src);\n     \n-    LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(cons);\n+    LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(file);\n     if (ret !\u003d null) {\n       // update the quota: use the preferred block size for UC block\n       final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n-      dir.updateSpaceConsumed(src, 0, diff * file.getBlockReplication());\n+      dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n     }\n \n     if (writeToEditLog) {\n-      getEditLog().logOpenFile(src, cons, false, logRetryCache);\n+      getEditLog().logOpenFile(src, file, false, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  LocatedBlock prepareFileForWrite(String src, INodesInPath iip,\n      String leaseHolder, String clientMachine, boolean writeToEditLog,\n      boolean logRetryCache) throws IOException {\n    final INodeFile file \u003d iip.getLastINode().asFile();\n    file.recordModification(iip.getLatestSnapshotId());\n    file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(\n        file.getFileUnderConstructionFeature().getClientName(), src);\n    \n    LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(file);\n    if (ret !\u003d null) {\n      // update the quota: use the preferred block size for UC block\n      final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n      dir.updateSpaceConsumed(iip, 0, diff * file.getBlockReplication());\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logOpenFile(src, file, false, logRetryCache);\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "05af0ff4be871ddbb4c4cb4f0b5b506ecee36fb8": {
      "type": "Ymodifierchange",
      "commitMessage": "Revert HDFS-6940.",
      "commitDate": "09/09/14 5:30 PM",
      "commitName": "05af0ff4be871ddbb4c4cb4f0b5b506ecee36fb8",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "06/09/14 12:07 PM",
      "commitNameOld": "88209ce181b5ecc55c0ae2bceff4893ab4817e88",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 3.22,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  LocatedBlock prepareFileForWrite(String src, INodeFile file,\n                                   String leaseHolder, String clientMachine,\n                                   boolean writeToEditLog,\n                                   int latestSnapshot, boolean logRetryCache)\n      throws IOException {\n    file.recordModification(latestSnapshot);\n    final INodeFile cons \u003d file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(cons.getFileUnderConstructionFeature()\n        .getClientName(), src);\n    \n    LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(cons);\n    if (ret !\u003d null) {\n      // update the quota: use the preferred block size for UC block\n      final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n      dir.updateSpaceConsumed(src, 0, diff * file.getBlockReplication());\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logOpenFile(src, cons, false, logRetryCache);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {
        "oldValue": "[protected]",
        "newValue": "[]"
      }
    },
    "88209ce181b5ecc55c0ae2bceff4893ab4817e88": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-6940. Refactoring to allow ConsensusNode implementation.\nContributed by Konstantin Shvachko.",
      "commitDate": "06/09/14 12:07 PM",
      "commitName": "88209ce181b5ecc55c0ae2bceff4893ab4817e88",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "04/09/14 6:54 PM",
      "commitNameOld": "6104520369045dfaa4b543cbad21236ed322249b",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 1.72,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  LocatedBlock prepareFileForWrite(String src, INodeFile file,\n                                   String leaseHolder, String clientMachine,\n                                   boolean writeToEditLog,\n                                   int latestSnapshot, boolean logRetryCache)\n      throws IOException {\n    file.recordModification(latestSnapshot);\n    final INodeFile cons \u003d file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(cons.getFileUnderConstructionFeature()\n        .getClientName(), src);\n    \n    LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(cons);\n    if (ret !\u003d null) {\n      // update the quota: use the preferred block size for UC block\n      final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n      dir.updateSpaceConsumed(src, 0, diff * file.getBlockReplication());\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logOpenFile(src, cons, false, logRetryCache);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {
        "oldValue": "[]",
        "newValue": "[protected]"
      }
    },
    "6104520369045dfaa4b543cbad21236ed322249b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6886. Use single editlog record for creating file + overwrite. Contributed by Yi Liu.\n",
      "commitDate": "04/09/14 6:54 PM",
      "commitName": "6104520369045dfaa4b543cbad21236ed322249b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "03/09/14 6:23 AM",
      "commitNameOld": "3425ae5d7eaa27b2526d0e0c07bdfea9440359f8",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 1.52,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   LocatedBlock prepareFileForWrite(String src, INodeFile file,\n                                    String leaseHolder, String clientMachine,\n                                    boolean writeToEditLog,\n                                    int latestSnapshot, boolean logRetryCache)\n       throws IOException {\n     file.recordModification(latestSnapshot);\n     final INodeFile cons \u003d file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(cons.getFileUnderConstructionFeature()\n         .getClientName(), src);\n     \n     LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(cons);\n     if (ret !\u003d null) {\n       // update the quota: use the preferred block size for UC block\n       final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n       dir.updateSpaceConsumed(src, 0, diff * file.getBlockReplication());\n     }\n \n     if (writeToEditLog) {\n-      getEditLog().logOpenFile(src, cons, logRetryCache);\n+      getEditLog().logOpenFile(src, cons, false, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  LocatedBlock prepareFileForWrite(String src, INodeFile file,\n                                   String leaseHolder, String clientMachine,\n                                   boolean writeToEditLog,\n                                   int latestSnapshot, boolean logRetryCache)\n      throws IOException {\n    file.recordModification(latestSnapshot);\n    final INodeFile cons \u003d file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(cons.getFileUnderConstructionFeature()\n        .getClientName(), src);\n    \n    LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(cons);\n    if (ret !\u003d null) {\n      // update the quota: use the preferred block size for UC block\n      final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n      dir.updateSpaceConsumed(src, 0, diff * file.getBlockReplication());\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logOpenFile(src, cons, false, logRetryCache);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "80691b073fe7c104a8684c0a8900a1657bcdc03f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6838. Code cleanup for unnecessary INode replacement. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617361 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/08/14 2:28 PM",
      "commitName": "80691b073fe7c104a8684c0a8900a1657bcdc03f",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "07/08/14 10:41 PM",
      "commitNameOld": "d3a2fe280775e9320181b671d5951f06837bddad",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 3.66,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   LocatedBlock prepareFileForWrite(String src, INodeFile file,\n                                    String leaseHolder, String clientMachine,\n                                    boolean writeToEditLog,\n                                    int latestSnapshot, boolean logRetryCache)\n       throws IOException {\n-    file \u003d file.recordModification(latestSnapshot);\n+    file.recordModification(latestSnapshot);\n     final INodeFile cons \u003d file.toUnderConstruction(leaseHolder, clientMachine);\n \n     leaseManager.addLease(cons.getFileUnderConstructionFeature()\n         .getClientName(), src);\n     \n     LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(cons);\n     if (ret !\u003d null) {\n       // update the quota: use the preferred block size for UC block\n       final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n       dir.updateSpaceConsumed(src, 0, diff * file.getBlockReplication());\n     }\n \n     if (writeToEditLog) {\n       getEditLog().logOpenFile(src, cons, logRetryCache);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  LocatedBlock prepareFileForWrite(String src, INodeFile file,\n                                   String leaseHolder, String clientMachine,\n                                   boolean writeToEditLog,\n                                   int latestSnapshot, boolean logRetryCache)\n      throws IOException {\n    file.recordModification(latestSnapshot);\n    final INodeFile cons \u003d file.toUnderConstruction(leaseHolder, clientMachine);\n\n    leaseManager.addLease(cons.getFileUnderConstructionFeature()\n        .getClientName(), src);\n    \n    LocatedBlock ret \u003d blockManager.convertLastBlockToUnderConstruction(cons);\n    if (ret !\u003d null) {\n      // update the quota: use the preferred block size for UC block\n      final long diff \u003d file.getPreferredBlockSize() - ret.getBlockSize();\n      dir.updateSpaceConsumed(src, 0, diff * file.getBlockReplication());\n    }\n\n    if (writeToEditLog) {\n      getEditLog().logOpenFile(src, cons, logRetryCache);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    }
  }
}