{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerLaunch.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
  "functionStartLine": 194,
  "functionEndLine": 394,
  "numCommitsSeen": 111,
  "timeTaken": 17901,
  "changeHistory": [
    "f4906ac01960c78ff0c91797eaa4b36d80f6826d",
    "21ec4bdaef4b68adbbf4f33a6f74494c074f803c",
    "c2288ac45b748b4119442c46147ccc324926c340",
    "6b5838ed3220f992092c7348f92f1d9d0d4a3061",
    "d69b31f7f70f296ddd180e004fa0f827c2f737f2",
    "b9a429bb2854910add8d4cf787e6ee65ebdfc9cf",
    "8013475d447a8377b5aed858208bf8b91dd32366",
    "456705a07c8b80658950acc99f23086244c6b20f",
    "fa8cf4d1b4896a602dc383d5e266768392a9790c",
    "2abab1d7c53e64c160384fd5a3ac4cd8ffa57af4",
    "d5ff57a08fac983f8b5d201064ce07945f0f216e",
    "74a61438ca01e2191b54000af73b654a2d0b8253",
    "46940d92e2b17c627eb17a9d8fc6cec9c3715592",
    "6f6dfe0202249c129b36edfd145a2224140139cc",
    "cde3a00526c562a500308232e2b93498d22c90d7",
    "58e18508018081b5b5aa7c12cc5af386146cd26b",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
    "b41a7e89d1eb8650975ac7092532ed9563ac60f2",
    "2c17b81569c05b5f375d0ddad99d43cb4e3b23b1",
    "dfcbbddb0963c89c0455d41223427165b9f9e537",
    "3e6fce91a471b4a5099de109582e7c6417e8a822",
    "53fafcf061616516c24e2e2007a66a93d23d3e25",
    "53f64ee516d03f6ec87b41d77c214aa2fe4fa0ed",
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
    "6f2028bd1514d90b831f889fd0ee7f2ba5c15000",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b",
    "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb",
    "74d20250ffe16a85c6ef70b70e1254a77eaf03a3",
    "813efd25a19f6e36537245b8cb6f9e6e42f40cc1",
    "29a370872435ee558fbeb9f64bf70da87f8cd27a",
    "2692675fc3b5046d2ec88542c30203c87e135b70",
    "259edf8dca44de54033e96f7eb65a83aaa6096f2",
    "27e8c86999bc6a972a99216060b11ef35b7de858",
    "edcfd4527ca93acdf54403aafaa070b17aff5dd0",
    "0e01f26821caa3bf8554afe422bb080abcfe1e83",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
    "638801cce16fc1dc3259c541dc30a599faaddda1",
    "82910ecaa383381ea04932a9d5e2dfa78ae9e5cb",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "e948247715ba001b00eafc5f801fa926c409ea5a",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449",
    "2fe343f96348e894e6ed16c447c8c77ba1611d11",
    "02a81203bd0ff6116e3c68d376b3af3838231986",
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
    "88b82a0f6687ce103817fbb460fd30d870f717a0",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
    "fafe8cd28e726566509c679e19d7da622f29f90d",
    "f560a1066f8906862000c9b9d8c4e09bb10ea6a8",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "f4906ac01960c78ff0c91797eaa4b36d80f6826d": "Ybodychange",
    "21ec4bdaef4b68adbbf4f33a6f74494c074f803c": "Ybodychange",
    "c2288ac45b748b4119442c46147ccc324926c340": "Ybodychange",
    "6b5838ed3220f992092c7348f92f1d9d0d4a3061": "Ybodychange",
    "d69b31f7f70f296ddd180e004fa0f827c2f737f2": "Ybodychange",
    "b9a429bb2854910add8d4cf787e6ee65ebdfc9cf": "Ybodychange",
    "8013475d447a8377b5aed858208bf8b91dd32366": "Ybodychange",
    "456705a07c8b80658950acc99f23086244c6b20f": "Ybodychange",
    "fa8cf4d1b4896a602dc383d5e266768392a9790c": "Ybodychange",
    "2abab1d7c53e64c160384fd5a3ac4cd8ffa57af4": "Ybodychange",
    "d5ff57a08fac983f8b5d201064ce07945f0f216e": "Ybodychange",
    "74a61438ca01e2191b54000af73b654a2d0b8253": "Ybodychange",
    "46940d92e2b17c627eb17a9d8fc6cec9c3715592": "Ybodychange",
    "6f6dfe0202249c129b36edfd145a2224140139cc": "Ybodychange",
    "cde3a00526c562a500308232e2b93498d22c90d7": "Ybodychange",
    "58e18508018081b5b5aa7c12cc5af386146cd26b": "Ybodychange",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f": "Ybodychange",
    "b41a7e89d1eb8650975ac7092532ed9563ac60f2": "Ybodychange",
    "2c17b81569c05b5f375d0ddad99d43cb4e3b23b1": "Ybodychange",
    "dfcbbddb0963c89c0455d41223427165b9f9e537": "Ybodychange",
    "3e6fce91a471b4a5099de109582e7c6417e8a822": "Ybodychange",
    "53fafcf061616516c24e2e2007a66a93d23d3e25": "Ybodychange",
    "53f64ee516d03f6ec87b41d77c214aa2fe4fa0ed": "Ybodychange",
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5": "Ybodychange",
    "6f2028bd1514d90b831f889fd0ee7f2ba5c15000": "Ybodychange",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": "Ybodychange",
    "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb": "Ybodychange",
    "74d20250ffe16a85c6ef70b70e1254a77eaf03a3": "Ybodychange",
    "813efd25a19f6e36537245b8cb6f9e6e42f40cc1": "Ybodychange",
    "29a370872435ee558fbeb9f64bf70da87f8cd27a": "Ybodychange",
    "2692675fc3b5046d2ec88542c30203c87e135b70": "Ybodychange",
    "259edf8dca44de54033e96f7eb65a83aaa6096f2": "Ybodychange",
    "27e8c86999bc6a972a99216060b11ef35b7de858": "Ybodychange",
    "edcfd4527ca93acdf54403aafaa070b17aff5dd0": "Ybodychange",
    "0e01f26821caa3bf8554afe422bb080abcfe1e83": "Ybodychange",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": "Ybodychange",
    "638801cce16fc1dc3259c541dc30a599faaddda1": "Ybodychange",
    "82910ecaa383381ea04932a9d5e2dfa78ae9e5cb": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "e948247715ba001b00eafc5f801fa926c409ea5a": "Ybodychange",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": "Ybodychange",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": "Ybodychange",
    "2fe343f96348e894e6ed16c447c8c77ba1611d11": "Ybodychange",
    "02a81203bd0ff6116e3c68d376b3af3838231986": "Ybodychange",
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940": "Ybodychange",
    "88b82a0f6687ce103817fbb460fd30d870f717a0": "Ybodychange",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": "Ybodychange",
    "fafe8cd28e726566509c679e19d7da622f29f90d": "Ybodychange",
    "f560a1066f8906862000c9b9d8c4e09bb10ea6a8": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f4906ac01960c78ff0c91797eaa4b36d80f6826d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9038. [CSI] Add ability to publish/unpublish volumes on node managers. Contributed by Weiwei Yang.\n",
      "commitDate": "03/01/19 10:40 PM",
      "commitName": "f4906ac01960c78ff0c91797eaa4b36d80f6826d",
      "commitAuthor": "Sunil G",
      "commitDateOld": "19/12/18 11:55 AM",
      "commitNameOld": "e815fd9c49e80b9200dd8852abe74fe219ad9110",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 15.45,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,196 +1,201 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n           launchContext, containerLogDir);\n       // /////////////////////////// End of variable expansion\n \n       // Use this to track variables that are added to the environment by nm.\n       LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + String.format(TOKEN_FILE_NAME_FMT, containerIdStr));\n       Path nmPrivateKeystorePath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + KEYSTORE_FILE);\n       Path nmPrivateTruststorePath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + TRUSTSTORE_FILE);\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n+      // Select a root dir for all csi volumes for the container\n+      Path csiVolumesRoot \u003d deriveCsiVolumesRootDir();\n+      recordContainerCsiVolumesRootDir(containerID, csiVolumesRoot.toString());\n+\n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not\n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e localDirsForRead \u003d dirsHandler.getLocalDirsForRead();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirsForRead);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n       List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirsForRead);\n       List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n           appIdStr);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n       for (String localDir : localDirs) {\n         Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n         Path userdir \u003d new Path(usersdir, user);\n         Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n         appDirs.add(new Path(appsdir, appIdStr));\n       }\n \n       byte[] keystore \u003d container.getCredentials().getSecretKey(\n           AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE);\n       if (keystore !\u003d null) {\n         try (DataOutputStream keystoreOutStream \u003d\n                  lfs.create(nmPrivateKeystorePath,\n                      EnumSet.of(CREATE, OVERWRITE))) {\n           keystoreOutStream.write(keystore);\n           environment.put(ApplicationConstants.KEYSTORE_FILE_LOCATION_ENV_NAME,\n               new Path(containerWorkDir,\n                   ContainerLaunch.KEYSTORE_FILE).toUri().getPath());\n           environment.put(ApplicationConstants.KEYSTORE_PASSWORD_ENV_NAME,\n               new String(container.getCredentials().getSecretKey(\n                   AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE_PASSWORD),\n                   StandardCharsets.UTF_8));\n         }\n       } else {\n         nmPrivateKeystorePath \u003d null;\n       }\n       byte[] truststore \u003d container.getCredentials().getSecretKey(\n           AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE);\n       if (truststore !\u003d null) {\n         try (DataOutputStream truststoreOutStream \u003d\n                  lfs.create(nmPrivateTruststorePath,\n                      EnumSet.of(CREATE, OVERWRITE))) {\n           truststoreOutStream.write(truststore);\n           environment.put(\n               ApplicationConstants.TRUSTSTORE_FILE_LOCATION_ENV_NAME,\n               new Path(containerWorkDir,\n                   ContainerLaunch.TRUSTSTORE_FILE).toUri().getPath());\n           environment.put(ApplicationConstants.TRUSTSTORE_PASSWORD_ENV_NAME,\n               new String(container.getCredentials().getSecretKey(\n                   AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE_PASSWORD),\n                   StandardCharsets.UTF_8));\n         }\n       } else {\n         nmPrivateTruststorePath \u003d null;\n       }\n \n       // Set the token location too.\n       addToEnvMap(environment, nmEnvVars,\n           ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n           new Path(containerWorkDir,\n               FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n       // /////////// Write out the container-script in the nmPrivate space.\n       try (DataOutputStream containerScriptOutStream \u003d\n                lfs.create(nmPrivateContainerScriptPath,\n                    EnumSet.of(CREATE, OVERWRITE))) {\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n             containerLogDirs, localResources, nmPrivateClasspathJarDir,\n             nmEnvVars);\n \n         prepareContainer(localResources, containerLocalDirs);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n             containerLogDir, user, nmEnvVars);\n       }\n       // /////////// End of writing out container-script\n \n       // /////////// Write out the container-tokens in the nmPrivate space.\n       try (DataOutputStream tokensOutStream \u003d\n                lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n       }\n       // /////////// End of writing out container-tokens\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setNmPrivateKeystorePath(nmPrivateKeystorePath)\n           .setNmPrivateTruststorePath(nmPrivateTruststorePath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n+          .setContainerCsiVolumesRootDir(csiVolumesRoot)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs)\n           .setUserFilecacheDirs(userFilecacheDirs)\n           .setApplicationLocalDirs(applicationLocalDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n          launchContext, containerLogDir);\n      // /////////////////////////// End of variable expansion\n\n      // Use this to track variables that are added to the environment by nm.\n      LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(TOKEN_FILE_NAME_FMT, containerIdStr));\n      Path nmPrivateKeystorePath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + KEYSTORE_FILE);\n      Path nmPrivateTruststorePath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + TRUSTSTORE_FILE);\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      // Select a root dir for all csi volumes for the container\n      Path csiVolumesRoot \u003d deriveCsiVolumesRootDir();\n      recordContainerCsiVolumesRootDir(containerID, csiVolumesRoot.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not\n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e localDirsForRead \u003d dirsHandler.getLocalDirsForRead();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirsForRead);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n      List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirsForRead);\n      List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n          appIdStr);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n      for (String localDir : localDirs) {\n        Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n        Path userdir \u003d new Path(usersdir, user);\n        Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n        appDirs.add(new Path(appsdir, appIdStr));\n      }\n\n      byte[] keystore \u003d container.getCredentials().getSecretKey(\n          AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE);\n      if (keystore !\u003d null) {\n        try (DataOutputStream keystoreOutStream \u003d\n                 lfs.create(nmPrivateKeystorePath,\n                     EnumSet.of(CREATE, OVERWRITE))) {\n          keystoreOutStream.write(keystore);\n          environment.put(ApplicationConstants.KEYSTORE_FILE_LOCATION_ENV_NAME,\n              new Path(containerWorkDir,\n                  ContainerLaunch.KEYSTORE_FILE).toUri().getPath());\n          environment.put(ApplicationConstants.KEYSTORE_PASSWORD_ENV_NAME,\n              new String(container.getCredentials().getSecretKey(\n                  AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE_PASSWORD),\n                  StandardCharsets.UTF_8));\n        }\n      } else {\n        nmPrivateKeystorePath \u003d null;\n      }\n      byte[] truststore \u003d container.getCredentials().getSecretKey(\n          AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE);\n      if (truststore !\u003d null) {\n        try (DataOutputStream truststoreOutStream \u003d\n                 lfs.create(nmPrivateTruststorePath,\n                     EnumSet.of(CREATE, OVERWRITE))) {\n          truststoreOutStream.write(truststore);\n          environment.put(\n              ApplicationConstants.TRUSTSTORE_FILE_LOCATION_ENV_NAME,\n              new Path(containerWorkDir,\n                  ContainerLaunch.TRUSTSTORE_FILE).toUri().getPath());\n          environment.put(ApplicationConstants.TRUSTSTORE_PASSWORD_ENV_NAME,\n              new String(container.getCredentials().getSecretKey(\n                  AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE_PASSWORD),\n                  StandardCharsets.UTF_8));\n        }\n      } else {\n        nmPrivateTruststorePath \u003d null;\n      }\n\n      // Set the token location too.\n      addToEnvMap(environment, nmEnvVars,\n          ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n          new Path(containerWorkDir,\n              FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n      // /////////// Write out the container-script in the nmPrivate space.\n      try (DataOutputStream containerScriptOutStream \u003d\n               lfs.create(nmPrivateContainerScriptPath,\n                   EnumSet.of(CREATE, OVERWRITE))) {\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir,\n            nmEnvVars);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            containerLogDir, user, nmEnvVars);\n      }\n      // /////////// End of writing out container-script\n\n      // /////////// Write out the container-tokens in the nmPrivate space.\n      try (DataOutputStream tokensOutStream \u003d\n               lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n      }\n      // /////////// End of writing out container-tokens\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setNmPrivateKeystorePath(nmPrivateKeystorePath)\n          .setNmPrivateTruststorePath(nmPrivateTruststorePath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setContainerCsiVolumesRootDir(csiVolumesRoot)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .setUserFilecacheDirs(userFilecacheDirs)\n          .setApplicationLocalDirs(applicationLocalDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "21ec4bdaef4b68adbbf4f33a6f74494c074f803c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8672.  Improve token filename management for localization.\n            Contributed by Chandni Singh\n",
      "commitDate": "14/11/18 12:22 PM",
      "commitName": "21ec4bdaef4b68adbbf4f33a6f74494c074f803c",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "16/10/18 1:36 PM",
      "commitNameOld": "c2288ac45b748b4119442c46147ccc324926c340",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 28.99,
      "commitsBetweenForRepo": 239,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,197 +1,196 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n           launchContext, containerLogDir);\n       // /////////////////////////// End of variable expansion\n \n       // Use this to track variables that are added to the environment by nm.\n       LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n-              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n-              containerIdStr));\n+              + String.format(TOKEN_FILE_NAME_FMT, containerIdStr));\n       Path nmPrivateKeystorePath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + KEYSTORE_FILE);\n       Path nmPrivateTruststorePath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + TRUSTSTORE_FILE);\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not\n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e localDirsForRead \u003d dirsHandler.getLocalDirsForRead();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirsForRead);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n       List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirsForRead);\n       List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n           appIdStr);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n       for (String localDir : localDirs) {\n         Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n         Path userdir \u003d new Path(usersdir, user);\n         Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n         appDirs.add(new Path(appsdir, appIdStr));\n       }\n \n       byte[] keystore \u003d container.getCredentials().getSecretKey(\n           AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE);\n       if (keystore !\u003d null) {\n         try (DataOutputStream keystoreOutStream \u003d\n                  lfs.create(nmPrivateKeystorePath,\n                      EnumSet.of(CREATE, OVERWRITE))) {\n           keystoreOutStream.write(keystore);\n           environment.put(ApplicationConstants.KEYSTORE_FILE_LOCATION_ENV_NAME,\n               new Path(containerWorkDir,\n                   ContainerLaunch.KEYSTORE_FILE).toUri().getPath());\n           environment.put(ApplicationConstants.KEYSTORE_PASSWORD_ENV_NAME,\n               new String(container.getCredentials().getSecretKey(\n                   AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE_PASSWORD),\n                   StandardCharsets.UTF_8));\n         }\n       } else {\n         nmPrivateKeystorePath \u003d null;\n       }\n       byte[] truststore \u003d container.getCredentials().getSecretKey(\n           AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE);\n       if (truststore !\u003d null) {\n         try (DataOutputStream truststoreOutStream \u003d\n                  lfs.create(nmPrivateTruststorePath,\n                      EnumSet.of(CREATE, OVERWRITE))) {\n           truststoreOutStream.write(truststore);\n           environment.put(\n               ApplicationConstants.TRUSTSTORE_FILE_LOCATION_ENV_NAME,\n               new Path(containerWorkDir,\n                   ContainerLaunch.TRUSTSTORE_FILE).toUri().getPath());\n           environment.put(ApplicationConstants.TRUSTSTORE_PASSWORD_ENV_NAME,\n               new String(container.getCredentials().getSecretKey(\n                   AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE_PASSWORD),\n                   StandardCharsets.UTF_8));\n         }\n       } else {\n         nmPrivateTruststorePath \u003d null;\n       }\n \n       // Set the token location too.\n       addToEnvMap(environment, nmEnvVars,\n           ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n           new Path(containerWorkDir,\n               FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n       // /////////// Write out the container-script in the nmPrivate space.\n       try (DataOutputStream containerScriptOutStream \u003d\n                lfs.create(nmPrivateContainerScriptPath,\n                    EnumSet.of(CREATE, OVERWRITE))) {\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n             containerLogDirs, localResources, nmPrivateClasspathJarDir,\n             nmEnvVars);\n \n         prepareContainer(localResources, containerLocalDirs);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n             containerLogDir, user, nmEnvVars);\n       }\n       // /////////// End of writing out container-script\n \n       // /////////// Write out the container-tokens in the nmPrivate space.\n       try (DataOutputStream tokensOutStream \u003d\n                lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n       }\n       // /////////// End of writing out container-tokens\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setNmPrivateKeystorePath(nmPrivateKeystorePath)\n           .setNmPrivateTruststorePath(nmPrivateTruststorePath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs)\n           .setUserFilecacheDirs(userFilecacheDirs)\n           .setApplicationLocalDirs(applicationLocalDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n          launchContext, containerLogDir);\n      // /////////////////////////// End of variable expansion\n\n      // Use this to track variables that are added to the environment by nm.\n      LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(TOKEN_FILE_NAME_FMT, containerIdStr));\n      Path nmPrivateKeystorePath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + KEYSTORE_FILE);\n      Path nmPrivateTruststorePath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + TRUSTSTORE_FILE);\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not\n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e localDirsForRead \u003d dirsHandler.getLocalDirsForRead();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirsForRead);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n      List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirsForRead);\n      List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n          appIdStr);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n      for (String localDir : localDirs) {\n        Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n        Path userdir \u003d new Path(usersdir, user);\n        Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n        appDirs.add(new Path(appsdir, appIdStr));\n      }\n\n      byte[] keystore \u003d container.getCredentials().getSecretKey(\n          AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE);\n      if (keystore !\u003d null) {\n        try (DataOutputStream keystoreOutStream \u003d\n                 lfs.create(nmPrivateKeystorePath,\n                     EnumSet.of(CREATE, OVERWRITE))) {\n          keystoreOutStream.write(keystore);\n          environment.put(ApplicationConstants.KEYSTORE_FILE_LOCATION_ENV_NAME,\n              new Path(containerWorkDir,\n                  ContainerLaunch.KEYSTORE_FILE).toUri().getPath());\n          environment.put(ApplicationConstants.KEYSTORE_PASSWORD_ENV_NAME,\n              new String(container.getCredentials().getSecretKey(\n                  AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE_PASSWORD),\n                  StandardCharsets.UTF_8));\n        }\n      } else {\n        nmPrivateKeystorePath \u003d null;\n      }\n      byte[] truststore \u003d container.getCredentials().getSecretKey(\n          AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE);\n      if (truststore !\u003d null) {\n        try (DataOutputStream truststoreOutStream \u003d\n                 lfs.create(nmPrivateTruststorePath,\n                     EnumSet.of(CREATE, OVERWRITE))) {\n          truststoreOutStream.write(truststore);\n          environment.put(\n              ApplicationConstants.TRUSTSTORE_FILE_LOCATION_ENV_NAME,\n              new Path(containerWorkDir,\n                  ContainerLaunch.TRUSTSTORE_FILE).toUri().getPath());\n          environment.put(ApplicationConstants.TRUSTSTORE_PASSWORD_ENV_NAME,\n              new String(container.getCredentials().getSecretKey(\n                  AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE_PASSWORD),\n                  StandardCharsets.UTF_8));\n        }\n      } else {\n        nmPrivateTruststorePath \u003d null;\n      }\n\n      // Set the token location too.\n      addToEnvMap(environment, nmEnvVars,\n          ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n          new Path(containerWorkDir,\n              FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n      // /////////// Write out the container-script in the nmPrivate space.\n      try (DataOutputStream containerScriptOutStream \u003d\n               lfs.create(nmPrivateContainerScriptPath,\n                   EnumSet.of(CREATE, OVERWRITE))) {\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir,\n            nmEnvVars);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            containerLogDir, user, nmEnvVars);\n      }\n      // /////////// End of writing out container-script\n\n      // /////////// Write out the container-tokens in the nmPrivate space.\n      try (DataOutputStream tokensOutStream \u003d\n               lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n      }\n      // /////////// End of writing out container-tokens\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setNmPrivateKeystorePath(nmPrivateKeystorePath)\n          .setNmPrivateTruststorePath(nmPrivateTruststorePath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .setUserFilecacheDirs(userFilecacheDirs)\n          .setApplicationLocalDirs(applicationLocalDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "c2288ac45b748b4119442c46147ccc324926c340": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8448. AM HTTPS Support for AM communication with RMWeb proxy. (Contributed by Robert Kanter)\n",
      "commitDate": "16/10/18 1:36 PM",
      "commitName": "c2288ac45b748b4119442c46147ccc324926c340",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "11/10/18 8:54 AM",
      "commitNameOld": "e787d65a08f5d5245d2313fc34f2dde518bfaa5b",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 5.2,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,197 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n           launchContext, containerLogDir);\n       // /////////////////////////// End of variable expansion\n \n       // Use this to track variables that are added to the environment by nm.\n       LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n               containerIdStr));\n+      Path nmPrivateKeystorePath \u003d dirsHandler.getLocalPathForWrite(\n+          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n+              + KEYSTORE_FILE);\n+      Path nmPrivateTruststorePath \u003d dirsHandler.getLocalPathForWrite(\n+          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n+              + TRUSTSTORE_FILE);\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not\n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e localDirsForRead \u003d dirsHandler.getLocalDirsForRead();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirsForRead);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n       List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirsForRead);\n       List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n           appIdStr);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n       for (String localDir : localDirs) {\n         Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n         Path userdir \u003d new Path(usersdir, user);\n         Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n         appDirs.add(new Path(appsdir, appIdStr));\n       }\n \n+      byte[] keystore \u003d container.getCredentials().getSecretKey(\n+          AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE);\n+      if (keystore !\u003d null) {\n+        try (DataOutputStream keystoreOutStream \u003d\n+                 lfs.create(nmPrivateKeystorePath,\n+                     EnumSet.of(CREATE, OVERWRITE))) {\n+          keystoreOutStream.write(keystore);\n+          environment.put(ApplicationConstants.KEYSTORE_FILE_LOCATION_ENV_NAME,\n+              new Path(containerWorkDir,\n+                  ContainerLaunch.KEYSTORE_FILE).toUri().getPath());\n+          environment.put(ApplicationConstants.KEYSTORE_PASSWORD_ENV_NAME,\n+              new String(container.getCredentials().getSecretKey(\n+                  AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE_PASSWORD),\n+                  StandardCharsets.UTF_8));\n+        }\n+      } else {\n+        nmPrivateKeystorePath \u003d null;\n+      }\n+      byte[] truststore \u003d container.getCredentials().getSecretKey(\n+          AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE);\n+      if (truststore !\u003d null) {\n+        try (DataOutputStream truststoreOutStream \u003d\n+                 lfs.create(nmPrivateTruststorePath,\n+                     EnumSet.of(CREATE, OVERWRITE))) {\n+          truststoreOutStream.write(truststore);\n+          environment.put(\n+              ApplicationConstants.TRUSTSTORE_FILE_LOCATION_ENV_NAME,\n+              new Path(containerWorkDir,\n+                  ContainerLaunch.TRUSTSTORE_FILE).toUri().getPath());\n+          environment.put(ApplicationConstants.TRUSTSTORE_PASSWORD_ENV_NAME,\n+              new String(container.getCredentials().getSecretKey(\n+                  AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE_PASSWORD),\n+                  StandardCharsets.UTF_8));\n+        }\n+      } else {\n+        nmPrivateTruststorePath \u003d null;\n+      }\n+\n       // Set the token location too.\n       addToEnvMap(environment, nmEnvVars,\n           ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n           new Path(containerWorkDir,\n               FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n       // /////////// Write out the container-script in the nmPrivate space.\n       try (DataOutputStream containerScriptOutStream \u003d\n                lfs.create(nmPrivateContainerScriptPath,\n                    EnumSet.of(CREATE, OVERWRITE))) {\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n             containerLogDirs, localResources, nmPrivateClasspathJarDir,\n             nmEnvVars);\n \n         prepareContainer(localResources, containerLocalDirs);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n             containerLogDir, user, nmEnvVars);\n       }\n       // /////////// End of writing out container-script\n \n       // /////////// Write out the container-tokens in the nmPrivate space.\n       try (DataOutputStream tokensOutStream \u003d\n                lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n       }\n       // /////////// End of writing out container-tokens\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n+          .setNmPrivateKeystorePath(nmPrivateKeystorePath)\n+          .setNmPrivateTruststorePath(nmPrivateTruststorePath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs)\n           .setUserFilecacheDirs(userFilecacheDirs)\n           .setApplicationLocalDirs(applicationLocalDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n          launchContext, containerLogDir);\n      // /////////////////////////// End of variable expansion\n\n      // Use this to track variables that are added to the environment by nm.\n      LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n              containerIdStr));\n      Path nmPrivateKeystorePath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + KEYSTORE_FILE);\n      Path nmPrivateTruststorePath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + TRUSTSTORE_FILE);\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not\n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e localDirsForRead \u003d dirsHandler.getLocalDirsForRead();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirsForRead);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n      List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirsForRead);\n      List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n          appIdStr);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n      for (String localDir : localDirs) {\n        Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n        Path userdir \u003d new Path(usersdir, user);\n        Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n        appDirs.add(new Path(appsdir, appIdStr));\n      }\n\n      byte[] keystore \u003d container.getCredentials().getSecretKey(\n          AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE);\n      if (keystore !\u003d null) {\n        try (DataOutputStream keystoreOutStream \u003d\n                 lfs.create(nmPrivateKeystorePath,\n                     EnumSet.of(CREATE, OVERWRITE))) {\n          keystoreOutStream.write(keystore);\n          environment.put(ApplicationConstants.KEYSTORE_FILE_LOCATION_ENV_NAME,\n              new Path(containerWorkDir,\n                  ContainerLaunch.KEYSTORE_FILE).toUri().getPath());\n          environment.put(ApplicationConstants.KEYSTORE_PASSWORD_ENV_NAME,\n              new String(container.getCredentials().getSecretKey(\n                  AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE_PASSWORD),\n                  StandardCharsets.UTF_8));\n        }\n      } else {\n        nmPrivateKeystorePath \u003d null;\n      }\n      byte[] truststore \u003d container.getCredentials().getSecretKey(\n          AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE);\n      if (truststore !\u003d null) {\n        try (DataOutputStream truststoreOutStream \u003d\n                 lfs.create(nmPrivateTruststorePath,\n                     EnumSet.of(CREATE, OVERWRITE))) {\n          truststoreOutStream.write(truststore);\n          environment.put(\n              ApplicationConstants.TRUSTSTORE_FILE_LOCATION_ENV_NAME,\n              new Path(containerWorkDir,\n                  ContainerLaunch.TRUSTSTORE_FILE).toUri().getPath());\n          environment.put(ApplicationConstants.TRUSTSTORE_PASSWORD_ENV_NAME,\n              new String(container.getCredentials().getSecretKey(\n                  AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE_PASSWORD),\n                  StandardCharsets.UTF_8));\n        }\n      } else {\n        nmPrivateTruststorePath \u003d null;\n      }\n\n      // Set the token location too.\n      addToEnvMap(environment, nmEnvVars,\n          ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n          new Path(containerWorkDir,\n              FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n      // /////////// Write out the container-script in the nmPrivate space.\n      try (DataOutputStream containerScriptOutStream \u003d\n               lfs.create(nmPrivateContainerScriptPath,\n                   EnumSet.of(CREATE, OVERWRITE))) {\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir,\n            nmEnvVars);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            containerLogDir, user, nmEnvVars);\n      }\n      // /////////// End of writing out container-script\n\n      // /////////// Write out the container-tokens in the nmPrivate space.\n      try (DataOutputStream tokensOutStream \u003d\n               lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n      }\n      // /////////// End of writing out container-tokens\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setNmPrivateKeystorePath(nmPrivateKeystorePath)\n          .setNmPrivateTruststorePath(nmPrivateTruststorePath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .setUserFilecacheDirs(userFilecacheDirs)\n          .setApplicationLocalDirs(applicationLocalDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "6b5838ed3220f992092c7348f92f1d9d0d4a3061": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8784. DockerLinuxContainerRuntime prevents access to distributed cache entries on a full disk. Contributed by Eric Badger\n",
      "commitDate": "19/09/18 2:44 PM",
      "commitName": "6b5838ed3220f992092c7348f92f1d9d0d4a3061",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "16/08/18 3:41 PM",
      "commitNameOld": "d42806160eb95594f08f38bb753cf0306a191a38",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 33.96,
      "commitsBetweenForRepo": 293,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,151 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n           launchContext, containerLogDir);\n       // /////////////////////////// End of variable expansion\n \n       // Use this to track variables that are added to the environment by nm.\n       LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n               containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not\n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n+      List\u003cString\u003e localDirsForRead \u003d dirsHandler.getLocalDirsForRead();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n-      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n+      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirsForRead);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n-      List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirs);\n+      List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirsForRead);\n       List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n           appIdStr);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n       for (String localDir : localDirs) {\n         Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n         Path userdir \u003d new Path(usersdir, user);\n         Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n         appDirs.add(new Path(appsdir, appIdStr));\n       }\n \n       // Set the token location too.\n       addToEnvMap(environment, nmEnvVars,\n           ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n           new Path(containerWorkDir,\n               FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n       // /////////// Write out the container-script in the nmPrivate space.\n       try (DataOutputStream containerScriptOutStream \u003d\n                lfs.create(nmPrivateContainerScriptPath,\n                    EnumSet.of(CREATE, OVERWRITE))) {\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n             containerLogDirs, localResources, nmPrivateClasspathJarDir,\n             nmEnvVars);\n \n         prepareContainer(localResources, containerLocalDirs);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n             containerLogDir, user, nmEnvVars);\n       }\n       // /////////// End of writing out container-script\n \n       // /////////// Write out the container-tokens in the nmPrivate space.\n       try (DataOutputStream tokensOutStream \u003d\n                lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n       }\n       // /////////// End of writing out container-tokens\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs)\n           .setUserFilecacheDirs(userFilecacheDirs)\n           .setApplicationLocalDirs(applicationLocalDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n          launchContext, containerLogDir);\n      // /////////////////////////// End of variable expansion\n\n      // Use this to track variables that are added to the environment by nm.\n      LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n              containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not\n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e localDirsForRead \u003d dirsHandler.getLocalDirsForRead();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirsForRead);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n      List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirsForRead);\n      List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n          appIdStr);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n      for (String localDir : localDirs) {\n        Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n        Path userdir \u003d new Path(usersdir, user);\n        Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n        appDirs.add(new Path(appsdir, appIdStr));\n      }\n\n      // Set the token location too.\n      addToEnvMap(environment, nmEnvVars,\n          ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n          new Path(containerWorkDir,\n              FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n      // /////////// Write out the container-script in the nmPrivate space.\n      try (DataOutputStream containerScriptOutStream \u003d\n               lfs.create(nmPrivateContainerScriptPath,\n                   EnumSet.of(CREATE, OVERWRITE))) {\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir,\n            nmEnvVars);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            containerLogDir, user, nmEnvVars);\n      }\n      // /////////// End of writing out container-script\n\n      // /////////// Write out the container-tokens in the nmPrivate space.\n      try (DataOutputStream tokensOutStream \u003d\n               lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n      }\n      // /////////// End of writing out container-tokens\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .setUserFilecacheDirs(userFilecacheDirs)\n          .setApplicationLocalDirs(applicationLocalDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "d69b31f7f70f296ddd180e004fa0f827c2f737f2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\n",
      "commitDate": "07/03/18 7:20 AM",
      "commitName": "d69b31f7f70f296ddd180e004fa0f827c2f737f2",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "23/02/18 1:46 PM",
      "commitNameOld": "8e728f39c961f034369b43e087d68d01aa4a0e7d",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 11.73,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,150 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n           launchContext, containerLogDir);\n       // /////////////////////////// End of variable expansion\n \n+      // Use this to track variables that are added to the environment by nm.\n+      LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n+\n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n               containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not\n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n       List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirs);\n       List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n           appIdStr);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n       for (String localDir : localDirs) {\n         Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n         Path userdir \u003d new Path(usersdir, user);\n         Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n         appDirs.add(new Path(appsdir, appIdStr));\n       }\n \n       // Set the token location too.\n-      environment.put(\n+      addToEnvMap(environment, nmEnvVars,\n           ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n           new Path(containerWorkDir,\n               FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n       // /////////// Write out the container-script in the nmPrivate space.\n       try (DataOutputStream containerScriptOutStream \u003d\n                lfs.create(nmPrivateContainerScriptPath,\n                    EnumSet.of(CREATE, OVERWRITE))) {\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n-            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n+            containerLogDirs, localResources, nmPrivateClasspathJarDir,\n+            nmEnvVars);\n \n         prepareContainer(localResources, containerLocalDirs);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n-            containerLogDir, user);\n+            containerLogDir, user, nmEnvVars);\n       }\n       // /////////// End of writing out container-script\n \n       // /////////// Write out the container-tokens in the nmPrivate space.\n       try (DataOutputStream tokensOutStream \u003d\n                lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n       }\n       // /////////// End of writing out container-tokens\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs)\n           .setUserFilecacheDirs(userFilecacheDirs)\n           .setApplicationLocalDirs(applicationLocalDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n          launchContext, containerLogDir);\n      // /////////////////////////// End of variable expansion\n\n      // Use this to track variables that are added to the environment by nm.\n      LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n              containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not\n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n      List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirs);\n      List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n          appIdStr);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n      for (String localDir : localDirs) {\n        Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n        Path userdir \u003d new Path(usersdir, user);\n        Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n        appDirs.add(new Path(appsdir, appIdStr));\n      }\n\n      // Set the token location too.\n      addToEnvMap(environment, nmEnvVars,\n          ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n          new Path(containerWorkDir,\n              FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n      // /////////// Write out the container-script in the nmPrivate space.\n      try (DataOutputStream containerScriptOutStream \u003d\n               lfs.create(nmPrivateContainerScriptPath,\n                   EnumSet.of(CREATE, OVERWRITE))) {\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir,\n            nmEnvVars);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            containerLogDir, user, nmEnvVars);\n      }\n      // /////////// End of writing out container-script\n\n      // /////////// Write out the container-tokens in the nmPrivate space.\n      try (DataOutputStream tokensOutStream \u003d\n               lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n      }\n      // /////////// End of writing out container-tokens\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .setUserFilecacheDirs(userFilecacheDirs)\n          .setApplicationLocalDirs(applicationLocalDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "b9a429bb2854910add8d4cf787e6ee65ebdfc9cf": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\"\n\nThis reverts commit 8013475d447a8377b5aed858208bf8b91dd32366.\n",
      "commitDate": "19/02/18 6:16 AM",
      "commitName": "b9a429bb2854910add8d4cf787e6ee65ebdfc9cf",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "15/02/18 3:09 PM",
      "commitNameOld": "8013475d447a8377b5aed858208bf8b91dd32366",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 3.63,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,146 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n           launchContext, containerLogDir);\n       // /////////////////////////// End of variable expansion\n \n-      // Use this to track variables that are added to the environment by nm.\n-      LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n-\n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n               containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not\n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n       List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirs);\n       List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n           appIdStr);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n       for (String localDir : localDirs) {\n         Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n         Path userdir \u003d new Path(usersdir, user);\n         Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n         appDirs.add(new Path(appsdir, appIdStr));\n       }\n \n       // Set the token location too.\n-      addToEnvMap(environment, nmEnvVars,\n+      environment.put(\n           ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n           new Path(containerWorkDir,\n               FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n       // /////////// Write out the container-script in the nmPrivate space.\n       try (DataOutputStream containerScriptOutStream \u003d\n                lfs.create(nmPrivateContainerScriptPath,\n                    EnumSet.of(CREATE, OVERWRITE))) {\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n-            containerLogDirs, localResources, nmPrivateClasspathJarDir,\n-            nmEnvVars);\n+            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n \n         prepareContainer(localResources, containerLocalDirs);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n-            containerLogDir, user, nmEnvVars);\n+            containerLogDir, user);\n       }\n       // /////////// End of writing out container-script\n \n       // /////////// Write out the container-tokens in the nmPrivate space.\n       try (DataOutputStream tokensOutStream \u003d\n                lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n       }\n       // /////////// End of writing out container-tokens\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs)\n           .setUserFilecacheDirs(userFilecacheDirs)\n           .setApplicationLocalDirs(applicationLocalDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n          launchContext, containerLogDir);\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n              containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not\n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n      List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirs);\n      List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n          appIdStr);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n      for (String localDir : localDirs) {\n        Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n        Path userdir \u003d new Path(usersdir, user);\n        Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n        appDirs.add(new Path(appsdir, appIdStr));\n      }\n\n      // Set the token location too.\n      environment.put(\n          ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n          new Path(containerWorkDir,\n              FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n      // /////////// Write out the container-script in the nmPrivate space.\n      try (DataOutputStream containerScriptOutStream \u003d\n               lfs.create(nmPrivateContainerScriptPath,\n                   EnumSet.of(CREATE, OVERWRITE))) {\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            containerLogDir, user);\n      }\n      // /////////// End of writing out container-script\n\n      // /////////// Write out the container-tokens in the nmPrivate space.\n      try (DataOutputStream tokensOutStream \u003d\n               lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n      }\n      // /////////// End of writing out container-tokens\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .setUserFilecacheDirs(userFilecacheDirs)\n          .setApplicationLocalDirs(applicationLocalDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "8013475d447a8377b5aed858208bf8b91dd32366": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7677. Docker image cannot set HADOOP_CONF_DIR. Contributed by Jim Brennan\n",
      "commitDate": "15/02/18 3:09 PM",
      "commitName": "8013475d447a8377b5aed858208bf8b91dd32366",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "07/02/18 11:09 AM",
      "commitNameOld": "456705a07c8b80658950acc99f23086244c6b20f",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 8.17,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,150 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n           launchContext, containerLogDir);\n       // /////////////////////////// End of variable expansion\n \n+      // Use this to track variables that are added to the environment by nm.\n+      LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n+\n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n               containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not\n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n       List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirs);\n       List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n           appIdStr);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n       for (String localDir : localDirs) {\n         Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n         Path userdir \u003d new Path(usersdir, user);\n         Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n         appDirs.add(new Path(appsdir, appIdStr));\n       }\n \n       // Set the token location too.\n-      environment.put(\n+      addToEnvMap(environment, nmEnvVars,\n           ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n           new Path(containerWorkDir,\n               FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n       // /////////// Write out the container-script in the nmPrivate space.\n       try (DataOutputStream containerScriptOutStream \u003d\n                lfs.create(nmPrivateContainerScriptPath,\n                    EnumSet.of(CREATE, OVERWRITE))) {\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n-            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n+            containerLogDirs, localResources, nmPrivateClasspathJarDir,\n+            nmEnvVars);\n \n         prepareContainer(localResources, containerLocalDirs);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n-            containerLogDir, user);\n+            containerLogDir, user, nmEnvVars);\n       }\n       // /////////// End of writing out container-script\n \n       // /////////// Write out the container-tokens in the nmPrivate space.\n       try (DataOutputStream tokensOutStream \u003d\n                lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n       }\n       // /////////// End of writing out container-tokens\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs)\n           .setUserFilecacheDirs(userFilecacheDirs)\n           .setApplicationLocalDirs(applicationLocalDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n          launchContext, containerLogDir);\n      // /////////////////////////// End of variable expansion\n\n      // Use this to track variables that are added to the environment by nm.\n      LinkedHashSet\u003cString\u003e nmEnvVars \u003d new LinkedHashSet\u003cString\u003e();\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n              containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not\n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n      List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirs);\n      List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n          appIdStr);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n      for (String localDir : localDirs) {\n        Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n        Path userdir \u003d new Path(usersdir, user);\n        Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n        appDirs.add(new Path(appsdir, appIdStr));\n      }\n\n      // Set the token location too.\n      addToEnvMap(environment, nmEnvVars,\n          ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n          new Path(containerWorkDir,\n              FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n      // /////////// Write out the container-script in the nmPrivate space.\n      try (DataOutputStream containerScriptOutStream \u003d\n               lfs.create(nmPrivateContainerScriptPath,\n                   EnumSet.of(CREATE, OVERWRITE))) {\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir,\n            nmEnvVars);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            containerLogDir, user, nmEnvVars);\n      }\n      // /////////// End of writing out container-script\n\n      // /////////// Write out the container-tokens in the nmPrivate space.\n      try (DataOutputStream tokensOutStream \u003d\n               lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n      }\n      // /////////// End of writing out container-tokens\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .setUserFilecacheDirs(userFilecacheDirs)\n          .setApplicationLocalDirs(applicationLocalDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "456705a07c8b80658950acc99f23086244c6b20f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7815. Make the YARN mounts added to Docker containers more restrictive. Contributed by Shane Kumpf\n",
      "commitDate": "07/02/18 11:09 AM",
      "commitName": "456705a07c8b80658950acc99f23086244c6b20f",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "01/02/18 10:14 AM",
      "commitNameOld": "682ea21f2bbc587e1b727b3c895c2f513a908432",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 6.04,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,146 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n-      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n-      // Make a copy of env to iterate \u0026 do variable expansion\n-      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n-        String value \u003d entry.getValue();\n-        value \u003d expandEnvironment(value, containerLogDir);\n-        entry.setValue(value);\n-      }\n+      Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n+          launchContext, containerLogDir);\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n               containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not\n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n+      List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirs);\n+      List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n+          appIdStr);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n       for (String localDir : localDirs) {\n         Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n         Path userdir \u003d new Path(usersdir, user);\n         Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n         appDirs.add(new Path(appsdir, appIdStr));\n       }\n \n       // Set the token location too.\n       environment.put(\n           ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n           new Path(containerWorkDir,\n               FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n       // /////////// Write out the container-script in the nmPrivate space.\n       try (DataOutputStream containerScriptOutStream \u003d\n                lfs.create(nmPrivateContainerScriptPath,\n                    EnumSet.of(CREATE, OVERWRITE))) {\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n             containerLogDirs, localResources, nmPrivateClasspathJarDir);\n \n         prepareContainer(localResources, containerLocalDirs);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n             containerLogDir, user);\n       }\n       // /////////// End of writing out container-script\n \n       // /////////// Write out the container-tokens in the nmPrivate space.\n       try (DataOutputStream tokensOutStream \u003d\n                lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n       }\n       // /////////// End of writing out container-tokens\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n-          .setContainerLogDirs(containerLogDirs).build());\n+          .setContainerLogDirs(containerLogDirs)\n+          .setUserFilecacheDirs(userFilecacheDirs)\n+          .setApplicationLocalDirs(applicationLocalDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d expandAllEnvironmentVars(\n          launchContext, containerLogDir);\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n              containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not\n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n      List\u003cString\u003e userFilecacheDirs \u003d getUserFilecacheDirs(localDirs);\n      List\u003cString\u003e applicationLocalDirs \u003d getApplicationLocalDirs(localDirs,\n          appIdStr);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n      for (String localDir : localDirs) {\n        Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n        Path userdir \u003d new Path(usersdir, user);\n        Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n        appDirs.add(new Path(appsdir, appIdStr));\n      }\n\n      // Set the token location too.\n      environment.put(\n          ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n          new Path(containerWorkDir,\n              FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n      // /////////// Write out the container-script in the nmPrivate space.\n      try (DataOutputStream containerScriptOutStream \u003d\n               lfs.create(nmPrivateContainerScriptPath,\n                   EnumSet.of(CREATE, OVERWRITE))) {\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            containerLogDir, user);\n      }\n      // /////////// End of writing out container-script\n\n      // /////////// Write out the container-tokens in the nmPrivate space.\n      try (DataOutputStream tokensOutStream \u003d\n               lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n      }\n      // /////////// End of writing out container-tokens\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .setUserFilecacheDirs(userFilecacheDirs)\n          .setApplicationLocalDirs(applicationLocalDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "fa8cf4d1b4896a602dc383d5e266768392a9790c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7737. prelaunch.err file not found exception on container failure. Contributed by Keqiu Hu.\n",
      "commitDate": "24/01/18 12:54 PM",
      "commitName": "fa8cf4d1b4896a602dc383d5e266768392a9790c",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "12/01/18 10:41 AM",
      "commitNameOld": "3d65dbe032e202361d613344ccc6d9c5f99ba395",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 12.09,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,146 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n               containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not\n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n       for (String localDir : localDirs) {\n         Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n         Path userdir \u003d new Path(usersdir, user);\n         Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n         appDirs.add(new Path(appsdir, appIdStr));\n       }\n \n       // Set the token location too.\n       environment.put(\n           ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n           new Path(containerWorkDir,\n               FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n       // /////////// Write out the container-script in the nmPrivate space.\n       try (DataOutputStream containerScriptOutStream \u003d\n                lfs.create(nmPrivateContainerScriptPath,\n                    EnumSet.of(CREATE, OVERWRITE))) {\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n             containerLogDirs, localResources, nmPrivateClasspathJarDir);\n \n         prepareContainer(localResources, containerLocalDirs);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n-            new Path(containerLogDirs.get(0)), user);\n+            containerLogDir, user);\n       }\n       // /////////// End of writing out container-script\n \n       // /////////// Write out the container-tokens in the nmPrivate space.\n       try (DataOutputStream tokensOutStream \u003d\n                lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n       }\n       // /////////// End of writing out container-tokens\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n              containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not\n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n      for (String localDir : localDirs) {\n        Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n        Path userdir \u003d new Path(usersdir, user);\n        Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n        appDirs.add(new Path(appsdir, appIdStr));\n      }\n\n      // Set the token location too.\n      environment.put(\n          ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n          new Path(containerWorkDir,\n              FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n      // /////////// Write out the container-script in the nmPrivate space.\n      try (DataOutputStream containerScriptOutStream \u003d\n               lfs.create(nmPrivateContainerScriptPath,\n                   EnumSet.of(CREATE, OVERWRITE))) {\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            containerLogDir, user);\n      }\n      // /////////// End of writing out container-script\n\n      // /////////// Write out the container-tokens in the nmPrivate space.\n      try (DataOutputStream tokensOutStream \u003d\n               lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n      }\n      // /////////// End of writing out container-tokens\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "2abab1d7c53e64c160384fd5a3ac4cd8ffa57af4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7595. Container launching code suppresses close exceptions after writes. Contributed by Jim Brennan\n",
      "commitDate": "12/12/17 2:04 PM",
      "commitName": "2abab1d7c53e64c160384fd5a3ac4cd8ffa57af4",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "05/10/17 3:50 PM",
      "commitNameOld": "c071aad5da6f6601978e73d38ce5813958848bc4",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 67.97,
      "commitsBetweenForRepo": 522,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,146 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n               containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n-      DataOutputStream containerScriptOutStream \u003d null;\n-      DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n-      // pid file should be in nm private dir so that it is not \n+      // pid file should be in nm private dir so that it is not\n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n-      try {\n-        // /////////// Write out the container-script in the nmPrivate space.\n-        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n-        for (String localDir : localDirs) {\n-          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n-          Path userdir \u003d new Path(usersdir, user);\n-          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n-          appDirs.add(new Path(appsdir, appIdStr));\n-        }\n-        containerScriptOutStream \u003d\n-            lfs.create(nmPrivateContainerScriptPath,\n-                EnumSet.of(CREATE, OVERWRITE));\n+      List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n+      for (String localDir : localDirs) {\n+        Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n+        Path userdir \u003d new Path(usersdir, user);\n+        Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n+        appDirs.add(new Path(appsdir, appIdStr));\n+      }\n \n-        // Set the token location too.\n-        environment.put(\n-            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n-            new Path(containerWorkDir,\n-                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n+      // Set the token location too.\n+      environment.put(\n+          ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n+          new Path(containerWorkDir,\n+              FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n+\n+      // /////////// Write out the container-script in the nmPrivate space.\n+      try (DataOutputStream containerScriptOutStream \u003d\n+               lfs.create(nmPrivateContainerScriptPath,\n+                   EnumSet.of(CREATE, OVERWRITE))) {\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n             containerLogDirs, localResources, nmPrivateClasspathJarDir);\n \n         prepareContainer(localResources, containerLocalDirs);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n             new Path(containerLogDirs.get(0)), user);\n-        // /////////// End of writing out container-script\n+      }\n+      // /////////// End of writing out container-script\n \n-        // /////////// Write out the container-tokens in the nmPrivate space.\n-        tokensOutStream \u003d\n-            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n+      // /////////// Write out the container-tokens in the nmPrivate space.\n+      try (DataOutputStream tokensOutStream \u003d\n+               lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n-        // /////////// End of writing out container-tokens\n-      } finally {\n-        IOUtils.cleanupWithLogger(LOG, containerScriptOutStream,\n-            tokensOutStream);\n       }\n+      // /////////// End of writing out container-tokens\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n              containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not\n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n      for (String localDir : localDirs) {\n        Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n        Path userdir \u003d new Path(usersdir, user);\n        Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n        appDirs.add(new Path(appsdir, appIdStr));\n      }\n\n      // Set the token location too.\n      environment.put(\n          ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n          new Path(containerWorkDir,\n              FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n      // /////////// Write out the container-script in the nmPrivate space.\n      try (DataOutputStream containerScriptOutStream \u003d\n               lfs.create(nmPrivateContainerScriptPath,\n                   EnumSet.of(CREATE, OVERWRITE))) {\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)), user);\n      }\n      // /////////// End of writing out container-script\n\n      // /////////// Write out the container-tokens in the nmPrivate space.\n      try (DataOutputStream tokensOutStream \u003d\n               lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE))) {\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n      }\n      // /////////// End of writing out container-tokens\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "d5ff57a08fac983f8b5d201064ce07945f0f216e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7047. Moving logging APIs over to slf4j in hadoop-yarn-server-nodemanager. Contributed by Yeliang Cang.\n",
      "commitDate": "22/08/17 1:14 AM",
      "commitName": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "10/05/17 10:46 AM",
      "commitNameOld": "74a61438ca01e2191b54000af73b654a2d0b8253",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 103.6,
      "commitsBetweenForRepo": 586,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,150 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n               containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n             lfs.create(nmPrivateContainerScriptPath,\n                 EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n             new Path(containerWorkDir,\n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n             containerLogDirs, localResources, nmPrivateClasspathJarDir);\n \n         prepareContainer(localResources, containerLocalDirs);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n             new Path(containerLogDirs.get(0)), user);\n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n-        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n+        IOUtils.cleanupWithLogger(LOG, containerScriptOutStream,\n+            tokensOutStream);\n       }\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n              containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n            lfs.create(nmPrivateContainerScriptPath,\n                EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n            new Path(containerWorkDir,\n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)), user);\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanupWithLogger(LOG, containerScriptOutStream,\n            tokensOutStream);\n      }\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "74a61438ca01e2191b54000af73b654a2d0b8253": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6475. Fix some long function checkstyle issues\n(Contributed by Soumabrata Chakraborty via Daniel Templeton)\n",
      "commitDate": "10/05/17 10:46 AM",
      "commitName": "74a61438ca01e2191b54000af73b654a2d0b8253",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "19/04/17 12:23 PM",
      "commitNameOld": "46940d92e2b17c627eb17a9d8fc6cec9c3715592",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 20.93,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,158 +1,149 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n               + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n               containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n           getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n-      Path containerWorkDir \u003d\n-          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n-                  + Path.SEPARATOR + user + Path.SEPARATOR\n-                  + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n-                  + Path.SEPARATOR + containerIdStr,\n-              LocalDirAllocator.SIZE_UNKNOWN, false);\n+      Path containerWorkDir \u003d deriveContainerWorkDir();\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n             lfs.create(nmPrivateContainerScriptPath,\n                 EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n             new Path(containerWorkDir,\n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n             containerLogDirs, localResources, nmPrivateClasspathJarDir);\n \n-        exec.prepareContainer(new ContainerPrepareContext.Builder()\n-            .setContainer(container)\n-            .setLocalizedResources(localResources)\n-            .setUser(user)\n-            .setContainerLocalDirs(containerLocalDirs)\n-            .setCommands(launchContext.getCommands()).build());\n+        prepareContainer(localResources, containerLocalDirs);\n+\n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n             localResources, launchContext.getCommands(),\n             new Path(containerLogDirs.get(0)), user);\n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs).build());\n     } catch (ConfigurationException e) {\n       LOG.error(\"Failed to launch container due to configuration error.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       // Mark the node as unhealthy\n       context.getNodeStatusUpdater().reportException(e);\n       return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n              containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d deriveContainerWorkDir();\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n            lfs.create(nmPrivateContainerScriptPath,\n                EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n            new Path(containerWorkDir,\n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n\n        prepareContainer(localResources, containerLocalDirs);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)), user);\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "46940d92e2b17c627eb17a9d8fc6cec9c3715592": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6302. Fail the node if Linux Container Executor is not configured properly\n(Contributed by Miklos Szegedi via Daniel Templeton)\n",
      "commitDate": "19/04/17 12:23 PM",
      "commitName": "46940d92e2b17c627eb17a9d8fc6cec9c3715592",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "01/03/17 2:53 PM",
      "commitNameOld": "6f6dfe0202249c129b36edfd145a2224140139cc",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 48.85,
      "commitsBetweenForRepo": 295,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,158 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n-              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n-                  + CONTAINER_SCRIPT);\n+          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n+              + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n-              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n-                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n-                      containerIdStr));\n+          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n+              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n+              containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n-              getContainerPrivateDir(appIdStr, containerIdStr));\n+          getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n-              + Path.SEPARATOR + user + Path.SEPARATOR\n-              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n-              + Path.SEPARATOR + containerIdStr,\n+                  + Path.SEPARATOR + user + Path.SEPARATOR\n+                  + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n+                  + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n-          lfs.create(nmPrivateContainerScriptPath,\n-              EnumSet.of(CREATE, OVERWRITE));\n+            lfs.create(nmPrivateContainerScriptPath,\n+                EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n-            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n+            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n             new Path(containerWorkDir,\n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n             containerLogDirs, localResources, nmPrivateClasspathJarDir);\n \n         exec.prepareContainer(new ContainerPrepareContext.Builder()\n             .setContainer(container)\n             .setLocalizedResources(localResources)\n             .setUser(user)\n             .setContainerLocalDirs(containerLocalDirs)\n             .setCommands(launchContext.getCommands()).build());\n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n-          localResources, launchContext.getCommands(),\n+            localResources, launchContext.getCommands(),\n             new Path(containerLogDirs.get(0)), user);\n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs).build());\n+    } catch (ConfigurationException e) {\n+      LOG.error(\"Failed to launch container due to configuration error.\", e);\n+      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n+          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n+          e.getMessage()));\n+      // Mark the node as unhealthy\n+      context.getNodeStatusUpdater().reportException(e);\n+      return ret;\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n              + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n              containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n          getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n                  + Path.SEPARATOR + user + Path.SEPARATOR\n                  + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n                  + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n            lfs.create(nmPrivateContainerScriptPath,\n                EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME,\n            new Path(containerWorkDir,\n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n\n        exec.prepareContainer(new ContainerPrepareContext.Builder()\n            .setContainer(container)\n            .setLocalizedResources(localResources)\n            .setUser(user)\n            .setContainerLocalDirs(containerLocalDirs)\n            .setCommands(launchContext.getCommands()).build());\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n            localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)), user);\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs).build());\n    } catch (ConfigurationException e) {\n      LOG.error(\"Failed to launch container due to configuration error.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      // Mark the node as unhealthy\n      context.getNodeStatusUpdater().reportException(e);\n      return ret;\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "6f6dfe0202249c129b36edfd145a2224140139cc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5280. Allow YARN containers to run with Java Security Manager (gphillips via rkanter)\n",
      "commitDate": "01/03/17 2:53 PM",
      "commitName": "6f6dfe0202249c129b36edfd145a2224140139cc",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "15/11/16 7:56 AM",
      "commitNameOld": "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 106.29,
      "commitsBetweenForRepo": 548,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,155 +1,150 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n-      Path nmPrivateContainerScriptPath \u003d\n-          dirsHandler.getLocalPathForWrite(\n+      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n-      Path nmPrivateTokensPath \u003d\n-          dirsHandler.getLocalPathForWrite(\n-              getContainerPrivateDir(appIdStr, containerIdStr)\n-                  + Path.SEPARATOR\n+      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n+              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n-      Path nmPrivateClasspathJarDir \u003d \n-          dirsHandler.getLocalPathForWrite(\n+      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n-\n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n-\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n-\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n-            new Path(containerWorkDir, \n+            new Path(containerWorkDir,\n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n-            containerLogDirs,\n-          localResources, nmPrivateClasspathJarDir);\n+            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n \n+        exec.prepareContainer(new ContainerPrepareContext.Builder()\n+            .setContainer(container)\n+            .setLocalizedResources(localResources)\n+            .setUser(user)\n+            .setContainerLocalDirs(containerLocalDirs)\n+            .setCommands(launchContext.getCommands()).build());\n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n           localResources, launchContext.getCommands(),\n             new Path(containerLogDirs.get(0)), user);\n-\n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n-          .setContainerLogDirs(containerLogDirs)\n-          .build());\n+          .setContainerLogDirs(containerLogDirs).build());\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n-\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir,\n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs, localResources, nmPrivateClasspathJarDir);\n\n        exec.prepareContainer(new ContainerPrepareContext.Builder()\n            .setContainer(container)\n            .setLocalizedResources(localResources)\n            .setUser(user)\n            .setContainerLocalDirs(containerLocalDirs)\n            .setCommands(launchContext.getCommands()).build());\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n          localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)), user);\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs).build());\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "cde3a00526c562a500308232e2b93498d22c90d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5373. NPE listing wildcard directory in containerLaunch. (Daniel Templeton via kasha)\n",
      "commitDate": "26/08/16 11:04 AM",
      "commitName": "cde3a00526c562a500308232e2b93498d22c90d7",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "14/07/16 6:58 AM",
      "commitNameOld": "54bf14f80bcb2cafd1d30b77f2e02cd40b9515d9",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 43.17,
      "commitsBetweenForRepo": 302,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,155 +1,155 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d \n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n       List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n \n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n             containerLogDirs,\n           localResources, nmPrivateClasspathJarDir);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n           localResources, launchContext.getCommands(),\n-            new Path(containerLogDirs.get(0)));\n+            new Path(containerLogDirs.get(0)), user);\n \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setFilecacheDirs(filecacheDirs)\n           .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs)\n           .build());\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d \n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs,\n          localResources, nmPrivateClasspathJarDir);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n          localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)), user);\n\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .build());\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "58e18508018081b5b5aa7c12cc5af386146cd26b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5298. Mount usercache and NM filecache directories into Docker container. Contributed by  Sidharta Seethana.\n",
      "commitDate": "14/07/16 3:41 AM",
      "commitName": "58e18508018081b5b5aa7c12cc5af386146cd26b",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 29.52,
      "commitsBetweenForRepo": 329,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,155 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d \n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n+      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n+      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n+\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n-        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n+        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n+            containerLogDirs,\n           localResources, nmPrivateClasspathJarDir);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n           localResources, launchContext.getCommands(),\n             new Path(containerLogDirs.get(0)));\n \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n+          .setFilecacheDirs(filecacheDirs)\n+          .setUserLocalDirs(userLocalDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs)\n           .build());\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d \n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e filecacheDirs \u003d getNMFilecacheDirs(localDirs);\n      List\u003cString\u003e userLocalDirs \u003d getUserLocalDirs(localDirs);\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, userLocalDirs,\n            containerLogDirs,\n          localResources, nmPrivateClasspathJarDir);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n          localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)));\n\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setFilecacheDirs(filecacheDirs)\n          .setUserLocalDirs(userLocalDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .build());\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "29/04/16 3:39 AM",
      "commitNameOld": "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 46.48,
      "commitsBetweenForRepo": 304,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,149 @@\n   public Integer call() {\n     if (!validateContainerState()) {\n       return 0;\n     }\n \n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     ContainerId containerID \u003d container.getContainerId();\n-    String containerIdStr \u003d ConverterUtils.toString(containerID);\n+    String containerIdStr \u003d containerID.toString();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     Path containerLogDir;\n     try {\n       Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d \n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n       recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n       List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n       List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources, nmPrivateClasspathJarDir);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n           localResources, launchContext.getCommands(),\n             new Path(containerLogDirs.get(0)));\n \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       ret \u003d launchContainer(new ContainerStartContext.Builder()\n           .setContainer(container)\n           .setLocalizedResources(localResources)\n           .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n           .setNmPrivateTokensPath(nmPrivateTokensPath)\n           .setUser(user)\n           .setAppId(appIdStr)\n           .setContainerWorkDir(containerWorkDir)\n           .setLocalDirs(localDirs)\n           .setLogDirs(logDirs)\n           .setContainerLocalDirs(containerLocalDirs)\n           .setContainerLogDirs(containerLogDirs)\n           .build());\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       setContainerCompletedStatus(ret);\n     }\n \n     handleContainerExitCode(ret, containerLogDir);\n \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d containerID.toString();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d \n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources, nmPrivateClasspathJarDir);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n          localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)));\n\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .build());\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3998. Add support in the NodeManager to re-launch containers. Contributed by Jun Gong.\n",
      "commitDate": "29/04/16 3:39 AM",
      "commitName": "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "10/04/16 10:55 PM",
      "commitNameOld": "1ff27f9d12e8124c1b9a722708264c5b07fd0fde",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 18.2,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,223 +1,149 @@\n   public Integer call() {\n+    if (!validateContainerState()) {\n+      return 0;\n+    }\n+\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n-    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n-    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n-    // is already at KILLING\n-    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n-      dispatcher.getEventHandler().handle(\n-          new ContainerExitEvent(containerID,\n-              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n-              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n-                  ExitCode.TERMINATED.getExitCode(),\n-              \"Container terminated before launch.\"));\n-      return 0;\n-    }\n-\n     Path containerLogDir;\n     try {\n-      localResources \u003d container.getLocalizedResources();\n-      if (localResources \u003d\u003d null) {\n-        throw RPCUtil.getRemoteException(\n-            \"Unable to get local resources when Container \" + containerID +\n-            \" is at \" + container.getContainerState());\n-      }\n+      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n+      recordContainerLogDir(containerID, containerLogDir.toString());\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d \n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n+      recordContainerWorkDir(containerID, containerWorkDir.toString());\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n-\n-      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n-      for( String logDir : logDirs) {\n-        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n-      }\n+      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n+      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n \n-      List\u003cString\u003e containerLocalDirs \u003d new ArrayList\u003c\u003e(localDirs.size());\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n-\n-          String containerLocalDir \u003d localDir + Path.SEPARATOR +\n-              ContainerLocalizer.USERCACHE + Path.SEPARATOR + user\n-              + Path.SEPARATOR\n-              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n-              + Path.SEPARATOR;\n-\n-          containerLocalDirs.add(containerLocalDir);\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources, nmPrivateClasspathJarDir);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n           localResources, launchContext.getCommands(),\n             new Path(containerLogDirs.get(0)));\n \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n-      // LaunchContainer is a blocking call. We are here almost means the\n-      // container is launched, so send out the event.\n-      dispatcher.getEventHandler().handle(new ContainerEvent(\n-            containerID,\n-            ContainerEventType.CONTAINER_LAUNCHED));\n-      context.getNMStateStore().storeContainerLaunched(containerID);\n-\n-      // Check if the container is signalled to be killed.\n-      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n-        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n-            + \"cleanup already called\");\n-        ret \u003d ExitCode.TERMINATED.getExitCode();\n-      }\n-      else {\n-        exec.activateContainer(containerID, pidFilePath);\n-        ret \u003d exec.launchContainer(new ContainerStartContext.Builder()\n-            .setContainer(container)\n-            .setLocalizedResources(localResources)\n-            .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n-            .setNmPrivateTokensPath(nmPrivateTokensPath)\n-            .setUser(user)\n-            .setAppId(appIdStr)\n-            .setContainerWorkDir(containerWorkDir)\n-            .setLocalDirs(localDirs)\n-            .setLogDirs(logDirs)\n-            .setContainerLocalDirs(containerLocalDirs)\n-            .setContainerLogDirs(containerLogDirs)\n-            .build());\n-      }\n+      ret \u003d launchContainer(new ContainerStartContext.Builder()\n+          .setContainer(container)\n+          .setLocalizedResources(localResources)\n+          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n+          .setNmPrivateTokensPath(nmPrivateTokensPath)\n+          .setUser(user)\n+          .setAppId(appIdStr)\n+          .setContainerWorkDir(containerWorkDir)\n+          .setLocalDirs(localDirs)\n+          .setLogDirs(logDirs)\n+          .setContainerLocalDirs(containerLocalDirs)\n+          .setContainerLogDirs(containerLogDirs)\n+          .build());\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n-      completed.set(true);\n-      exec.deactivateContainer(containerID);\n-      try {\n-        context.getNMStateStore().storeContainerCompleted(containerID, ret);\n-      } catch (IOException e) {\n-        LOG.error(\"Unable to set exit code for container \" + containerID);\n-      }\n+      setContainerCompletedStatus(ret);\n     }\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n-                + ret);\n-    }\n+    handleContainerExitCode(ret, containerLogDir);\n \n-    StringBuilder diagnosticInfo \u003d\n-        new StringBuilder(\"Container exited with a non-zero exit code \");\n-    diagnosticInfo.append(ret);\n-    diagnosticInfo.append(\". \");\n-    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n-        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n-      // If the process was killed, Send container_cleanedup_after_kill and\n-      // just break out of this method.\n-      dispatcher.getEventHandler().handle(\n-            new ContainerExitEvent(containerID,\n-                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n-                diagnosticInfo.toString()));\n-      return ret;\n-    }\n-\n-    if (ret !\u003d 0) {\n-      handleContainerExitWithFailure(containerID, ret, containerLogDir,\n-          diagnosticInfo);\n-      return ret;\n-    }\n-\n-    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n-    dispatcher.getEventHandler().handle(\n-        new ContainerEvent(containerID,\n-            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n-    return 0;\n+    return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    if (!validateContainerState()) {\n      return 0;\n    }\n\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    Path containerLogDir;\n    try {\n      Map\u003cPath, List\u003cString\u003e\u003e localResources \u003d getLocalizedResources();\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      recordContainerLogDir(containerID, containerLogDir.toString());\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d \n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n      recordContainerWorkDir(containerID, containerWorkDir.toString());\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n      List\u003cString\u003e containerLocalDirs \u003d getContainerLocalDirs(localDirs);\n      List\u003cString\u003e containerLogDirs \u003d getContainerLogDirs(logDirs);\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources, nmPrivateClasspathJarDir);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n          localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)));\n\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      ret \u003d launchContainer(new ContainerStartContext.Builder()\n          .setContainer(container)\n          .setLocalizedResources(localResources)\n          .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n          .setNmPrivateTokensPath(nmPrivateTokensPath)\n          .setUser(user)\n          .setAppId(appIdStr)\n          .setContainerWorkDir(containerWorkDir)\n          .setLocalDirs(localDirs)\n          .setLogDirs(logDirs)\n          .setContainerLocalDirs(containerLocalDirs)\n          .setContainerLogDirs(containerLogDirs)\n          .build());\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      setContainerCompletedStatus(ret);\n    }\n\n    handleContainerExitCode(ret, containerLogDir);\n\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "b41a7e89d1eb8650975ac7092532ed9563ac60f2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4578. Directories that are mounted in docker containers need to be more restrictive/container-specific. Contributed by Sidharta Seethana.\n",
      "commitDate": "22/01/16 1:13 AM",
      "commitName": "b41a7e89d1eb8650975ac7092532ed9563ac60f2",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "24/12/15 11:48 PM",
      "commitNameOld": "2c17b81569c05b5f375d0ddad99d43cb4e3b23b1",
      "commitAuthorOld": "Gera Shegalov",
      "daysBetweenCommits": 28.06,
      "commitsBetweenForRepo": 159,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,212 +1,223 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n     // is already at KILLING\n     if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n       dispatcher.getEventHandler().handle(\n           new ContainerExitEvent(containerID,\n               ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n               Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                   ExitCode.TERMINATED.getExitCode(),\n               \"Container terminated before launch.\"));\n       return 0;\n     }\n \n     Path containerLogDir;\n     try {\n       localResources \u003d container.getLocalizedResources();\n       if (localResources \u003d\u003d null) {\n         throw RPCUtil.getRemoteException(\n             \"Unable to get local resources when Container \" + containerID +\n             \" is at \" + container.getContainerState());\n       }\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d \n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n \n+      List\u003cString\u003e containerLocalDirs \u003d new ArrayList\u003c\u003e(localDirs.size());\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n+\n+          String containerLocalDir \u003d localDir + Path.SEPARATOR +\n+              ContainerLocalizer.USERCACHE + Path.SEPARATOR + user\n+              + Path.SEPARATOR\n+              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n+              + Path.SEPARATOR;\n+\n+          containerLocalDirs.add(containerLocalDir);\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources, nmPrivateClasspathJarDir);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n           localResources, launchContext.getCommands(),\n             new Path(containerLogDirs.get(0)));\n \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n       context.getNMStateStore().storeContainerLaunched(containerID);\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(new ContainerStartContext.Builder()\n             .setContainer(container)\n             .setLocalizedResources(localResources)\n             .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n             .setNmPrivateTokensPath(nmPrivateTokensPath)\n             .setUser(user)\n             .setAppId(appIdStr)\n             .setContainerWorkDir(containerWorkDir)\n             .setLocalDirs(localDirs)\n             .setLogDirs(logDirs)\n+            .setContainerLocalDirs(containerLocalDirs)\n+            .setContainerLogDirs(containerLogDirs)\n             .build());\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n       try {\n         context.getNMStateStore().storeContainerCompleted(containerID, ret);\n       } catch (IOException e) {\n         LOG.error(\"Unable to set exit code for container \" + containerID);\n       }\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n \n     StringBuilder diagnosticInfo \u003d\n         new StringBuilder(\"Container exited with a non-zero exit code \");\n     diagnosticInfo.append(ret);\n     diagnosticInfo.append(\". \");\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 diagnosticInfo.toString()));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       handleContainerExitWithFailure(containerID, ret, containerLogDir,\n           diagnosticInfo);\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n    // is already at KILLING\n    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n      dispatcher.getEventHandler().handle(\n          new ContainerExitEvent(containerID,\n              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                  ExitCode.TERMINATED.getExitCode(),\n              \"Container terminated before launch.\"));\n      return 0;\n    }\n\n    Path containerLogDir;\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        throw RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d \n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      List\u003cString\u003e containerLocalDirs \u003d new ArrayList\u003c\u003e(localDirs.size());\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n\n          String containerLocalDir \u003d localDir + Path.SEPARATOR +\n              ContainerLocalizer.USERCACHE + Path.SEPARATOR + user\n              + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR;\n\n          containerLocalDirs.add(containerLocalDir);\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources, nmPrivateClasspathJarDir);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n          localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)));\n\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n      context.getNMStateStore().storeContainerLaunched(containerID);\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(new ContainerStartContext.Builder()\n            .setContainer(container)\n            .setLocalizedResources(localResources)\n            .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n            .setNmPrivateTokensPath(nmPrivateTokensPath)\n            .setUser(user)\n            .setAppId(appIdStr)\n            .setContainerWorkDir(containerWorkDir)\n            .setLocalDirs(localDirs)\n            .setLogDirs(logDirs)\n            .setContainerLocalDirs(containerLocalDirs)\n            .setContainerLogDirs(containerLogDirs)\n            .build());\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n      try {\n        context.getNMStateStore().storeContainerCompleted(containerID, ret);\n      } catch (IOException e) {\n        LOG.error(\"Unable to set exit code for container \" + containerID);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n\n    StringBuilder diagnosticInfo \u003d\n        new StringBuilder(\"Container exited with a non-zero exit code \");\n    diagnosticInfo.append(ret);\n    diagnosticInfo.append(\". \");\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                diagnosticInfo.toString()));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      handleContainerExitWithFailure(containerID, ret, containerLogDir,\n          diagnosticInfo);\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "2c17b81569c05b5f375d0ddad99d43cb4e3b23b1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2934. Improve handling of container\u0027s stderr. (Naganarasimha G R via gera)\n",
      "commitDate": "24/12/15 11:48 PM",
      "commitName": "2c17b81569c05b5f375d0ddad99d43cb4e3b23b1",
      "commitAuthor": "Gera Shegalov",
      "commitDateOld": "14/12/15 11:13 AM",
      "commitNameOld": "dfcbbddb0963c89c0455d41223427165b9f9e537",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 10.52,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,209 +1,212 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n     // is already at KILLING\n     if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n       dispatcher.getEventHandler().handle(\n           new ContainerExitEvent(containerID,\n               ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n               Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                   ExitCode.TERMINATED.getExitCode(),\n               \"Container terminated before launch.\"));\n       return 0;\n     }\n \n+    Path containerLogDir;\n     try {\n       localResources \u003d container.getLocalizedResources();\n       if (localResources \u003d\u003d null) {\n         throw RPCUtil.getRemoteException(\n             \"Unable to get local resources when Container \" + containerID +\n             \" is at \" + container.getContainerState());\n       }\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n-      Path containerLogDir \u003d\n+      containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d \n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources, nmPrivateClasspathJarDir);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n           localResources, launchContext.getCommands(),\n             new Path(containerLogDirs.get(0)));\n \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n       context.getNMStateStore().storeContainerLaunched(containerID);\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(new ContainerStartContext.Builder()\n             .setContainer(container)\n             .setLocalizedResources(localResources)\n             .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n             .setNmPrivateTokensPath(nmPrivateTokensPath)\n             .setUser(user)\n             .setAppId(appIdStr)\n             .setContainerWorkDir(containerWorkDir)\n             .setLocalDirs(localDirs)\n             .setLogDirs(logDirs)\n             .build());\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n       try {\n         context.getNMStateStore().storeContainerCompleted(containerID, ret);\n       } catch (IOException e) {\n         LOG.error(\"Unable to set exit code for container \" + containerID);\n       }\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n+\n+    StringBuilder diagnosticInfo \u003d\n+        new StringBuilder(\"Container exited with a non-zero exit code \");\n+    diagnosticInfo.append(ret);\n+    diagnosticInfo.append(\". \");\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n-                \"Container exited with a non-zero exit code \" + ret));\n+                diagnosticInfo.toString()));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n-      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n-      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n-          containerID,\n-          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n-          \"Container exited with a non-zero exit code \" + ret));\n+      handleContainerExitWithFailure(containerID, ret, containerLogDir,\n+          diagnosticInfo);\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n    // is already at KILLING\n    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n      dispatcher.getEventHandler().handle(\n          new ContainerExitEvent(containerID,\n              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                  ExitCode.TERMINATED.getExitCode(),\n              \"Container terminated before launch.\"));\n      return 0;\n    }\n\n    Path containerLogDir;\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        throw RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d \n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources, nmPrivateClasspathJarDir);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n          localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)));\n\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n      context.getNMStateStore().storeContainerLaunched(containerID);\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(new ContainerStartContext.Builder()\n            .setContainer(container)\n            .setLocalizedResources(localResources)\n            .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n            .setNmPrivateTokensPath(nmPrivateTokensPath)\n            .setUser(user)\n            .setAppId(appIdStr)\n            .setContainerWorkDir(containerWorkDir)\n            .setLocalDirs(localDirs)\n            .setLogDirs(logDirs)\n            .build());\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n      try {\n        context.getNMStateStore().storeContainerCompleted(containerID, ret);\n      } catch (IOException e) {\n        LOG.error(\"Unable to set exit code for container \" + containerID);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n\n    StringBuilder diagnosticInfo \u003d\n        new StringBuilder(\"Container exited with a non-zero exit code \");\n    diagnosticInfo.append(ret);\n    diagnosticInfo.append(\". \");\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                diagnosticInfo.toString()));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      handleContainerExitWithFailure(containerID, ret, containerLogDir,\n          diagnosticInfo);\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "dfcbbddb0963c89c0455d41223427165b9f9e537": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4309. Add container launch related debug information to container logs when a container fails. (Varun Vasudev via wangda)\n",
      "commitDate": "14/12/15 11:13 AM",
      "commitName": "dfcbbddb0963c89c0455d41223427165b9f9e537",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/10/15 12:25 PM",
      "commitNameOld": "dfa78484633b3ce21471d527b9c24671e3ca5df9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 60.99,
      "commitsBetweenForRepo": 437,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,208 +1,209 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n     // is already at KILLING\n     if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n       dispatcher.getEventHandler().handle(\n           new ContainerExitEvent(containerID,\n               ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n               Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                   ExitCode.TERMINATED.getExitCode(),\n               \"Container terminated before launch.\"));\n       return 0;\n     }\n \n     try {\n       localResources \u003d container.getLocalizedResources();\n       if (localResources \u003d\u003d null) {\n         throw RPCUtil.getRemoteException(\n             \"Unable to get local resources when Container \" + containerID +\n             \" is at \" + container.getContainerState());\n       }\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d \n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources, nmPrivateClasspathJarDir);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n-          localResources, launchContext.getCommands());\n+          localResources, launchContext.getCommands(),\n+            new Path(containerLogDirs.get(0)));\n \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n       context.getNMStateStore().storeContainerLaunched(containerID);\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(new ContainerStartContext.Builder()\n             .setContainer(container)\n             .setLocalizedResources(localResources)\n             .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n             .setNmPrivateTokensPath(nmPrivateTokensPath)\n             .setUser(user)\n             .setAppId(appIdStr)\n             .setContainerWorkDir(containerWorkDir)\n             .setLocalDirs(localDirs)\n             .setLogDirs(logDirs)\n             .build());\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n       try {\n         context.getNMStateStore().storeContainerCompleted(containerID, ret);\n       } catch (IOException e) {\n         LOG.error(\"Unable to set exit code for container \" + containerID);\n       }\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n    // is already at KILLING\n    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n      dispatcher.getEventHandler().handle(\n          new ContainerExitEvent(containerID,\n              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                  ExitCode.TERMINATED.getExitCode(),\n              \"Container terminated before launch.\"));\n      return 0;\n    }\n\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        throw RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d \n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources, nmPrivateClasspathJarDir);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n          localResources, launchContext.getCommands(),\n            new Path(containerLogDirs.get(0)));\n\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n      context.getNMStateStore().storeContainerLaunched(containerID);\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(new ContainerStartContext.Builder()\n            .setContainer(container)\n            .setLocalizedResources(localResources)\n            .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n            .setNmPrivateTokensPath(nmPrivateTokensPath)\n            .setUser(user)\n            .setAppId(appIdStr)\n            .setContainerWorkDir(containerWorkDir)\n            .setLocalDirs(localDirs)\n            .setLogDirs(logDirs)\n            .build());\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n      try {\n        context.getNMStateStore().storeContainerCompleted(containerID, ret);\n      } catch (IOException e) {\n        LOG.error(\"Unable to set exit code for container \" + containerID);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "3e6fce91a471b4a5099de109582e7c6417e8a822": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3853. Add docker container runtime support to LinuxContainterExecutor. Contributed by Sidharta Seethana.\n",
      "commitDate": "27/07/15 11:57 AM",
      "commitName": "3e6fce91a471b4a5099de109582e7c6417e8a822",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "27/05/15 2:31 PM",
      "commitNameOld": "4102e5882e17b75507ae5cf8b8979485b3e24cbc",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 60.89,
      "commitsBetweenForRepo": 412,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,207 +1,208 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n     // is already at KILLING\n     if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n       dispatcher.getEventHandler().handle(\n           new ContainerExitEvent(containerID,\n               ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n               Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                   ExitCode.TERMINATED.getExitCode(),\n               \"Container terminated before launch.\"));\n       return 0;\n     }\n \n     try {\n       localResources \u003d container.getLocalizedResources();\n       if (localResources \u003d\u003d null) {\n         throw RPCUtil.getRemoteException(\n             \"Unable to get local resources when Container \" + containerID +\n             \" is at \" + container.getContainerState());\n       }\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d \n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources, nmPrivateClasspathJarDir);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n           localResources, launchContext.getCommands());\n \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n       context.getNMStateStore().storeContainerLaunched(containerID);\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(new ContainerStartContext.Builder()\n             .setContainer(container)\n+            .setLocalizedResources(localResources)\n             .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n             .setNmPrivateTokensPath(nmPrivateTokensPath)\n             .setUser(user)\n             .setAppId(appIdStr)\n             .setContainerWorkDir(containerWorkDir)\n             .setLocalDirs(localDirs)\n             .setLogDirs(logDirs)\n             .build());\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n       try {\n         context.getNMStateStore().storeContainerCompleted(containerID, ret);\n       } catch (IOException e) {\n         LOG.error(\"Unable to set exit code for container \" + containerID);\n       }\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n    // is already at KILLING\n    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n      dispatcher.getEventHandler().handle(\n          new ContainerExitEvent(containerID,\n              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                  ExitCode.TERMINATED.getExitCode(),\n              \"Container terminated before launch.\"));\n      return 0;\n    }\n\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        throw RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d \n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources, nmPrivateClasspathJarDir);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n          localResources, launchContext.getCommands());\n\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n      context.getNMStateStore().storeContainerLaunched(containerID);\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(new ContainerStartContext.Builder()\n            .setContainer(container)\n            .setLocalizedResources(localResources)\n            .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n            .setNmPrivateTokensPath(nmPrivateTokensPath)\n            .setUser(user)\n            .setAppId(appIdStr)\n            .setContainerWorkDir(containerWorkDir)\n            .setLocalDirs(localDirs)\n            .setLogDirs(logDirs)\n            .build());\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n      try {\n        context.getNMStateStore().storeContainerCompleted(containerID, ret);\n      } catch (IOException e) {\n        LOG.error(\"Unable to set exit code for container \" + containerID);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "53fafcf061616516c24e2e2007a66a93d23d3e25": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3684. Changed ContainerExecutor\u0027s primary lifecycle methods to use a more extensible mechanism of context objects. Contributed by Sidharta Seethana.\n",
      "commitDate": "21/05/15 3:50 PM",
      "commitName": "53fafcf061616516c24e2e2007a66a93d23d3e25",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/05/15 1:10 PM",
      "commitNameOld": "0f95921447ea547bdf9caf18f7fde46bc66031f8",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 8.11,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,200 +1,207 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n     // is already at KILLING\n     if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n       dispatcher.getEventHandler().handle(\n           new ContainerExitEvent(containerID,\n               ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n               Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                   ExitCode.TERMINATED.getExitCode(),\n               \"Container terminated before launch.\"));\n       return 0;\n     }\n \n     try {\n       localResources \u003d container.getLocalizedResources();\n       if (localResources \u003d\u003d null) {\n         throw RPCUtil.getRemoteException(\n             \"Unable to get local resources when Container \" + containerID +\n             \" is at \" + container.getContainerState());\n       }\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d \n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources, nmPrivateClasspathJarDir);\n \n         // Write out the environment\n         exec.writeLaunchEnv(containerScriptOutStream, environment,\n           localResources, launchContext.getCommands());\n \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n       context.getNMStateStore().storeContainerLaunched(containerID);\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n-        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n-                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n-                localDirs, logDirs);\n+        ret \u003d exec.launchContainer(new ContainerStartContext.Builder()\n+            .setContainer(container)\n+            .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n+            .setNmPrivateTokensPath(nmPrivateTokensPath)\n+            .setUser(user)\n+            .setAppId(appIdStr)\n+            .setContainerWorkDir(containerWorkDir)\n+            .setLocalDirs(localDirs)\n+            .setLogDirs(logDirs)\n+            .build());\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n       try {\n         context.getNMStateStore().storeContainerCompleted(containerID, ret);\n       } catch (IOException e) {\n         LOG.error(\"Unable to set exit code for container \" + containerID);\n       }\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n    // is already at KILLING\n    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n      dispatcher.getEventHandler().handle(\n          new ContainerExitEvent(containerID,\n              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                  ExitCode.TERMINATED.getExitCode(),\n              \"Container terminated before launch.\"));\n      return 0;\n    }\n\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        throw RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d \n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources, nmPrivateClasspathJarDir);\n\n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment,\n          localResources, launchContext.getCommands());\n\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n      context.getNMStateStore().storeContainerLaunched(containerID);\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(new ContainerStartContext.Builder()\n            .setContainer(container)\n            .setNmPrivateContainerScriptPath(nmPrivateContainerScriptPath)\n            .setNmPrivateTokensPath(nmPrivateTokensPath)\n            .setUser(user)\n            .setAppId(appIdStr)\n            .setContainerWorkDir(containerWorkDir)\n            .setLocalDirs(localDirs)\n            .setLogDirs(logDirs)\n            .build());\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n      try {\n        context.getNMStateStore().storeContainerCompleted(containerID, ret);\n      } catch (IOException e) {\n        LOG.error(\"Unable to set exit code for container \" + containerID);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "53f64ee516d03f6ec87b41d77c214aa2fe4fa0ed": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1964. Create Docker analog of the LinuxContainerExecutor in YARN\n",
      "commitDate": "11/11/14 9:28 PM",
      "commitName": "53f64ee516d03f6ec87b41d77c214aa2fe4fa0ed",
      "commitAuthor": "Ravi Prakash",
      "commitDateOld": "07/11/14 12:29 PM",
      "commitNameOld": "06b797947c980d7d21864eb8b700cf565756aac1",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 4.37,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,200 +1,200 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n     // is already at KILLING\n     if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n       dispatcher.getEventHandler().handle(\n           new ContainerExitEvent(containerID,\n               ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n               Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                   ExitCode.TERMINATED.getExitCode(),\n               \"Container terminated before launch.\"));\n       return 0;\n     }\n \n     try {\n       localResources \u003d container.getLocalizedResources();\n       if (localResources \u003d\u003d null) {\n         throw RPCUtil.getRemoteException(\n             \"Unable to get local resources when Container \" + containerID +\n             \" is at \" + container.getContainerState());\n       }\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n       Path nmPrivateClasspathJarDir \u003d \n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources, nmPrivateClasspathJarDir);\n         \n         // Write out the environment\n-        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n+        exec.writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n       context.getNMStateStore().storeContainerLaunched(containerID);\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n       try {\n         context.getNMStateStore().storeContainerCompleted(containerID, ret);\n       } catch (IOException e) {\n         LOG.error(\"Unable to set exit code for container \" + containerID);\n       }\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n    // is already at KILLING\n    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n      dispatcher.getEventHandler().handle(\n          new ContainerExitEvent(containerID,\n              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                  ExitCode.TERMINATED.getExitCode(),\n              \"Container terminated before launch.\"));\n      return 0;\n    }\n\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        throw RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d \n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources, nmPrivateClasspathJarDir);\n        \n        // Write out the environment\n        exec.writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n      context.getNMStateStore().storeContainerLaunched(containerID);\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n      try {\n        context.getNMStateStore().storeContainerCompleted(containerID, ret);\n      } catch (IOException e) {\n        LOG.error(\"Unable to set exit code for container \" + containerID);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
      "commitDate": "22/10/14 3:57 PM",
      "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
      "commitAuthor": "Jian He",
      "commitDateOld": "21/10/14 12:33 PM",
      "commitNameOld": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 1.14,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,200 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n     // is already at KILLING\n     if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n       dispatcher.getEventHandler().handle(\n           new ContainerExitEvent(containerID,\n               ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n               Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                   ExitCode.TERMINATED.getExitCode(),\n               \"Container terminated before launch.\"));\n       return 0;\n     }\n \n     try {\n       localResources \u003d container.getLocalizedResources();\n       if (localResources \u003d\u003d null) {\n         throw RPCUtil.getRemoteException(\n             \"Unable to get local resources when Container \" + containerID +\n             \" is at \" + container.getContainerState());\n       }\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n-\n+      Path nmPrivateClasspathJarDir \u003d \n+          dirsHandler.getLocalPathForWrite(\n+              getContainerPrivateDir(appIdStr, containerIdStr));\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport(false));\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n-          localResources);\n+          localResources, nmPrivateClasspathJarDir);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n       context.getNMStateStore().storeContainerLaunched(containerID);\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n       try {\n         context.getNMStateStore().storeContainerCompleted(containerID, ret);\n       } catch (IOException e) {\n         LOG.error(\"Unable to set exit code for container \" + containerID);\n       }\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n    // is already at KILLING\n    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n      dispatcher.getEventHandler().handle(\n          new ContainerExitEvent(containerID,\n              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                  ExitCode.TERMINATED.getExitCode(),\n              \"Container terminated before launch.\"));\n      return 0;\n    }\n\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        throw RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n      Path nmPrivateClasspathJarDir \u003d \n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr));\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources, nmPrivateClasspathJarDir);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n      context.getNMStateStore().storeContainerLaunched(containerID);\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n      try {\n        context.getNMStateStore().storeContainerCompleted(containerID, ret);\n      } catch (IOException e) {\n        LOG.error(\"Unable to set exit code for container \" + containerID);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "6f2028bd1514d90b831f889fd0ee7f2ba5c15000": {
      "type": "Ybodychange",
      "commitMessage": "YARN-90. NodeManager should identify failed disks becoming good again. Contributed by Varun Vasudev\n",
      "commitDate": "21/10/14 10:31 AM",
      "commitName": "6f2028bd1514d90b831f889fd0ee7f2ba5c15000",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "01/10/14 10:14 AM",
      "commitNameOld": "ba7f31c2ee8d23ecb183f88920ef06053c0b9769",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 20.01,
      "commitsBetweenForRepo": 158,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,198 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n     // is already at KILLING\n     if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n       dispatcher.getEventHandler().handle(\n           new ContainerExitEvent(containerID,\n               ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n               Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                   ExitCode.TERMINATED.getExitCode(),\n               \"Container terminated before launch.\"));\n       return 0;\n     }\n \n     try {\n       localResources \u003d container.getLocalizedResources();\n       if (localResources \u003d\u003d null) {\n         throw RPCUtil.getRemoteException(\n             \"Unable to get local resources when Container \" + containerID +\n             \" is at \" + container.getContainerState());\n       }\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n-            + dirsHandler.getDisksHealthReport());\n+            + dirsHandler.getDisksHealthReport(false));\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n       context.getNMStateStore().storeContainerLaunched(containerID);\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n       try {\n         context.getNMStateStore().storeContainerCompleted(containerID, ret);\n       } catch (IOException e) {\n         LOG.error(\"Unable to set exit code for container \" + containerID);\n       }\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n    // is already at KILLING\n    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n      dispatcher.getEventHandler().handle(\n          new ContainerExitEvent(containerID,\n              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                  ExitCode.TERMINATED.getExitCode(),\n              \"Container terminated before launch.\"));\n      return 0;\n    }\n\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        throw RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport(false));\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n      context.getNMStateStore().storeContainerLaunched(containerID);\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n      try {\n        context.getNMStateStore().storeContainerCompleted(containerID, ret);\n      } catch (IOException e) {\n        LOG.error(\"Unable to set exit code for container \" + containerID);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1337. Recover containers upon nodemanager restart. (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617448 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 3:56 AM",
      "commitName": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthor": "Junping Du",
      "commitDateOld": "19/04/14 11:55 AM",
      "commitNameOld": "4810e2b849e8a27a30d2906e1389adf79952006e",
      "commitAuthorOld": "Ivan Mitic",
      "daysBetweenCommits": 114.67,
      "commitsBetweenForRepo": 719,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,198 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n     // is already at KILLING\n     if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n       dispatcher.getEventHandler().handle(\n           new ContainerExitEvent(containerID,\n               ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n               Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                   ExitCode.TERMINATED.getExitCode(),\n               \"Container terminated before launch.\"));\n       return 0;\n     }\n \n     try {\n       localResources \u003d container.getLocalizedResources();\n       if (localResources \u003d\u003d null) {\n         throw RPCUtil.getRemoteException(\n             \"Unable to get local resources when Container \" + containerID +\n             \" is at \" + container.getContainerState());\n       }\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         value \u003d expandEnvironment(value, containerLogDir);\n         entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n-      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n-          containerIdStr);\n+      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n-      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n-          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n-          + pidFileSuffix);\n+      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n+      context.getNMStateStore().storeContainerLaunched(containerID);\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n+      try {\n+        context.getNMStateStore().storeContainerCompleted(containerID, ret);\n+      } catch (IOException e) {\n+        LOG.error(\"Unable to set exit code for container \" + containerID);\n+      }\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n    // is already at KILLING\n    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n      dispatcher.getEventHandler().handle(\n          new ContainerExitEvent(containerID,\n              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                  ExitCode.TERMINATED.getExitCode(),\n              \"Container terminated before launch.\"));\n      return 0;\n    }\n\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        throw RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSubpath \u003d getPidFileSubpath(appIdStr, containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(pidFileSubpath);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n      context.getNMStateStore().storeContainerLaunched(containerID);\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n      try {\n        context.getNMStateStore().storeContainerCompleted(containerID, ret);\n      } catch (IOException e) {\n        LOG.error(\"Unable to set exit code for container \" + containerID);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1824. Improved NodeManager and clients to be able to handle cross platform application submissions. Contributed by Jian He.\nMAPREDUCE-4052. Improved MapReduce clients to use NodeManagers\u0027 ability to handle cross platform application submissions. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1578135 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/03/14 11:32 AM",
      "commitName": "96e0ca2d272dc7ecd7f7f0e65a0c596fcc063bcb",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/11/13 11:52 AM",
      "commitNameOld": "1a76ccbbc47ba51f9a9813512e93abc09136f280",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 121.94,
      "commitsBetweenForRepo": 852,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,199 +1,195 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n     // is already at KILLING\n     if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n       dispatcher.getEventHandler().handle(\n           new ContainerExitEvent(containerID,\n               ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n               Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                   ExitCode.TERMINATED.getExitCode(),\n               \"Container terminated before launch.\"));\n       return 0;\n     }\n \n     try {\n       localResources \u003d container.getLocalizedResources();\n       if (localResources \u003d\u003d null) {\n         throw RPCUtil.getRemoteException(\n             \"Unable to get local resources when Container \" + containerID +\n             \" is at \" + container.getContainerState());\n       }\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n-        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n-            containerLogDir.toString()));\n+        newCmds.add(expandEnvironment(str, containerLogDir));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n-        entry.setValue(\n-            value.replace(\n-                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n-                containerLogDir.toString())\n-            );\n+        value \u003d expandEnvironment(value, containerLogDir);\n+        entry.setValue(value);\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n    // is already at KILLING\n    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n      dispatcher.getEventHandler().handle(\n          new ContainerExitEvent(containerID,\n              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                  ExitCode.TERMINATED.getExitCode(),\n              \"Container terminated before launch.\"));\n      return 0;\n    }\n\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        throw RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(expandEnvironment(str, containerLogDir));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        value \u003d expandEnvironment(value, containerLogDir);\n        entry.setValue(value);\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "74d20250ffe16a85c6ef70b70e1254a77eaf03a3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1070. Fixed race conditions in NodeManager during container-kill. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527827 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/09/13 5:18 PM",
      "commitName": "74d20250ffe16a85c6ef70b70e1254a77eaf03a3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "04/09/13 1:42 PM",
      "commitNameOld": "49afc64cd469bc3a775c18e0458661e39270b7a5",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 26.15,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,187 +1,199 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n+    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n+    // is already at KILLING\n+    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n+      dispatcher.getEventHandler().handle(\n+          new ContainerExitEvent(containerID,\n+              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n+              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n+                  ExitCode.TERMINATED.getExitCode(),\n+              \"Container terminated before launch.\"));\n+      return 0;\n+    }\n+\n     try {\n       localResources \u003d container.getLocalizedResources();\n       if (localResources \u003d\u003d null) {\n-        RPCUtil.getRemoteException(\n+        throw RPCUtil.getRemoteException(\n             \"Unable to get local resources when Container \" + containerID +\n             \" is at \" + container.getContainerState());\n       }\n \n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toString()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toString())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    // CONTAINER_KILLED_ON_REQUEST should not be missed if the container\n    // is already at KILLING\n    if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n      dispatcher.getEventHandler().handle(\n          new ContainerExitEvent(containerID,\n              ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n              Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() :\n                  ExitCode.TERMINATED.getExitCode(),\n              \"Container terminated before launch.\"));\n      return 0;\n    }\n\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        throw RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toString()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toString())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "813efd25a19f6e36537245b8cb6f9e6e42f40cc1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-966. Fixed ContainerLaunch to not fail quietly when there are no localized resources due to some other failure. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508688 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/07/13 4:58 PM",
      "commitName": "813efd25a19f6e36537245b8cb6f9e6e42f40cc1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/07/13 5:28 PM",
      "commitNameOld": "7a29bccd7aaf2eb33adac937379ba6be43a1031d",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 11.98,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,182 +1,188 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n-    final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n-        container.getLocalizedResources();\n+    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n+      localResources \u003d container.getLocalizedResources();\n+      if (localResources \u003d\u003d null) {\n+        RPCUtil.getRemoteException(\n+            \"Unable to get local resources when Container \" + containerID +\n+            \" is at \" + container.getContainerState());\n+      }\n+\n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       String relativeContainerLogDir \u003d ContainerLaunch\n           .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toString()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toString())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n       for( String logDir : logDirs) {\n         containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n       }\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n           localResources);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d null;\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      localResources \u003d container.getLocalizedResources();\n      if (localResources \u003d\u003d null) {\n        RPCUtil.getRemoteException(\n            \"Unable to get local resources when Container \" + containerID +\n            \" is at \" + container.getContainerState());\n      }\n\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toString()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toString())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "29a370872435ee558fbeb9f64bf70da87f8cd27a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-781. Exposing LOGDIR in all containers\u0027 environment which should be used by containers for logging purposes. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493428 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/06/13 4:09 PM",
      "commitName": "29a370872435ee558fbeb9f64bf70da87f8cd27a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/06/13 9:10 AM",
      "commitNameOld": "fdc9412a810564c79fbebf5eb730cb1018a95c6c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.29,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,182 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n         container.getLocalizedResources();\n     ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n+      String relativeContainerLogDir \u003d ContainerLaunch\n+          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n       Path containerLogDir \u003d\n-          dirsHandler.getLogPathForWrite(ContainerLaunch\n-              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n+          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toString()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toString())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n+      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n+      for( String logDir : logDirs) {\n+        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n+      }\n+\n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n-        sanitizeEnv(environment, containerWorkDir, appDirs, localResources);\n+        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n+          localResources);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n        container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      String relativeContainerLogDir \u003d ContainerLaunch\n          .getRelativeContainerLogDir(appIdStr, containerIdStr);\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(relativeContainerLogDir, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toString()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toString())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      List\u003cString\u003e containerLogDirs \u003d new ArrayList\u003cString\u003e();\n      for( String logDir : logDirs) {\n        containerLogDirs.add(logDir + Path.SEPARATOR + relativeContainerLogDir);\n      }\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, containerLogDirs,\n          localResources);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "2692675fc3b5046d2ec88542c30203c87e135b70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-684. ContainerManager.startContainer should use ContainerTokenIdentifier instead of the entire Container. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488085 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/13 9:13 PM",
      "commitName": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "23/05/13 8:22 PM",
      "commitNameOld": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.03,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,175 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n         container.getLocalizedResources();\n-    ContainerId containerID \u003d container.getContainer().getId();\n+    ContainerId containerID \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(ContainerLaunch\n               .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toString()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toString())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, localResources);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n        container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toString()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toString())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, localResources);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "259edf8dca44de54033e96f7eb65a83aaa6096f2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-571. Remove user from ContainerLaunchContext. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485928 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/13 8:22 PM",
      "commitName": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "23/04/13 2:39 PM",
      "commitNameOld": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 30.24,
      "commitsBetweenForRepo": 191,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,175 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n         container.getLocalizedResources();\n     ContainerId containerID \u003d container.getContainer().getId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n-    final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n+      final String user \u003d container.getUser();\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(ContainerLaunch\n               .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toString()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toString())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, localResources);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n        container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainer().getId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      final String user \u003d container.getUser();\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toString()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toString())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, localResources);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "27e8c86999bc6a972a99216060b11ef35b7de858": {
      "type": "Ybodychange",
      "commitMessage": "YARN-561. Modified NodeManager to set key information into the environment of every container that it launches. Contributed by Xuan Gong.\nMAPREDUCE-5175. Updated MR App to not set envs that will be set by NMs anyways after YARN-561. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1471156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/13 2:39 PM",
      "commitName": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "19/04/13 12:29 PM",
      "commitNameOld": "edcfd4527ca93acdf54403aafaa070b17aff5dd0",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 4.09,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,175 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n         container.getLocalizedResources();\n-    ContainerId containerID \u003d container.getContainerID();\n+    ContainerId containerID \u003d container.getContainer().getId();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(ContainerLaunch\n               .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toString()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toString())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs, localResources);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n        container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainer().getId();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toString()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toString())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, localResources);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "edcfd4527ca93acdf54403aafaa070b17aff5dd0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-593. container launch on Windows does not correctly populate classpath with new process\u0027s environment variables and localized resources (Chris Nauroth via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469998 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/04/13 12:29 PM",
      "commitName": "edcfd4527ca93acdf54403aafaa070b17aff5dd0",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "18/04/13 7:14 PM",
      "commitNameOld": "44bf8525a591b56b5c09cd4201bd193516ea9530",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.72,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,175 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n         container.getLocalizedResources();\n     ContainerId containerID \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(ContainerLaunch\n               .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toString()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toString())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n-        sanitizeEnv(environment, containerWorkDir, appDirs);\n+        sanitizeEnv(environment, containerWorkDir, appDirs, localResources);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n        container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toString()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toString())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs, localResources);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "0e01f26821caa3bf8554afe422bb080abcfe1e83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-444. Moved special container exit codes from YarnConfiguration to API where they belong. Contributed by Sandy Ryza.\nMAPREDUCE-5151. Updated MR AM to use standard exit codes from the API after YARN-444. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1468276 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/04/13 4:54 PM",
      "commitName": "0e01f26821caa3bf8554afe422bb080abcfe1e83",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/04/13 12:28 PM",
      "commitNameOld": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.18,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,175 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n         container.getLocalizedResources();\n     ContainerId containerID \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(ContainerLaunch\n               .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toString()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toString())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       if (!dirsHandler.areDisksHealthy()) {\n-        ret \u003d YarnConfiguration.DISKS_FAILED;\n+        ret \u003d ContainerExitStatus.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerID,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n           \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n        container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toString()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toString())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ContainerExitStatus.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-486. Changed NM\u0027s startContainer API to accept Container record given by RM as a direct parameter instead of as part of the ContainerLaunchContext record. Contributed by Xuan Gong.\nMAPREDUCE-5139. Update MR AM to use the modified startContainer API after YARN-486. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1467063 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/04/13 12:28 PM",
      "commitName": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "21/03/13 1:38 PM",
      "commitNameOld": "92fb7cdcdeedf2a68b127667ced2633dae22f970",
      "commitAuthorOld": "Hitesh Shah",
      "daysBetweenCommits": 20.95,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,176 +1,175 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n         container.getLocalizedResources();\n     ContainerId containerID \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(ContainerLaunch\n               .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toString()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toString())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d YarnConfiguration.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n-            launchContext.getContainerId(),\n-            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n-            e.getMessage()));\n+          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n+          e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n-            new ContainerExitEvent(launchContext.getContainerId(),\n+            new ContainerExitEvent(containerID,\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n-              launchContext.getContainerId(),\n-              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n-              \"Container exited with a non-zero exit code \" + ret));\n+          containerID,\n+          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n+          \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n-        new ContainerEvent(launchContext.getContainerId(),\n+        new ContainerEvent(containerID,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n        container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toString()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toString())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d YarnConfiguration.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID, ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(containerID,\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerID,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n          \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerID,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "638801cce16fc1dc3259c541dc30a599faaddda1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8952. Enhancements to support Hadoop on Windows Server and Windows Azure environments. Contributed by Ivan Mitic, Chuan Liu, Ramya Sunil, Bikas Saha, Kanna Karanam, John Gordon, Brandon Li, Chris Nauroth, David Lao, Sumadhur Reddy Bolli, Arpit Agarwal, Ahmed El Baz, Mike Liddell, Jing Zhao, Thejas Nair, Steve Maine, Ganeshan Iyer, Raja Aluri, Giridharan Kesavan, Ramya Bharathi Nimmagadda.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1453486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/03/13 11:15 AM",
      "commitName": "638801cce16fc1dc3259c541dc30a599faaddda1",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "09/08/12 12:15 PM",
      "commitNameOld": "82910ecaa383381ea04932a9d5e2dfa78ae9e5cb",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 209.0,
      "commitsBetweenForRepo": 1053,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,176 +1,176 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n         container.getLocalizedResources();\n     ContainerId containerID \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(ContainerLaunch\n               .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n-            containerLogDir.toUri().getPath()));\n+            containerLogDir.toString()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n-                containerLogDir.toUri().getPath())\n+                containerLogDir.toString())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d YarnConfiguration.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n             e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n               ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n               \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n        container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toString()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toString())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d YarnConfiguration.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n            e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n              \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "82910ecaa383381ea04932a9d5e2dfa78ae9e5cb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-14. Symlinks to peer distributed cache files no longer work (Jason Lowe via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1371390 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/08/12 12:15 PM",
      "commitName": "82910ecaa383381ea04932a9d5e2dfa78ae9e5cb",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,176 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n-    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n+    final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n+        container.getLocalizedResources();\n     ContainerId containerID \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(ContainerLaunch\n               .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toUri().getPath()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toUri().getPath())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       if (!dirsHandler.areDisksHealthy()) {\n         ret \u003d YarnConfiguration.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n             e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n               ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n               \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,List\u003cString\u003e\u003e localResources \u003d\n        container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d YarnConfiguration.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n            e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n              \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d YarnConfiguration.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n            e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n              \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java"
      }
    },
    "e948247715ba001b00eafc5f801fa926c409ea5a": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3485. DISKS_FAILED -101 error code should be defined in same location as ABORTED_CONTAINER_EXIT_STATUS. (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1210192 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/11 12:11 PM",
      "commitName": "e948247715ba001b00eafc5f801fa926c409ea5a",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "29/11/11 3:17 PM",
      "commitNameOld": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 4.87,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,175 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n     ContainerId containerID \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       Path containerLogDir \u003d\n           dirsHandler.getLogPathForWrite(ContainerLaunch\n               .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toUri().getPath()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toUri().getPath())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n \n       Path nmPrivateContainerScriptPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n           dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix);\n       List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n       List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n \n       if (!dirsHandler.areDisksHealthy()) {\n-        ret \u003d ExitCode.DISKS_FAILED.getExitCode();\n+        ret \u003d YarnConfiguration.DISKS_FAILED;\n         throw new IOException(\"Most of the disks failed. \"\n             + dirsHandler.getDisksHealthReport());\n       }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                 localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n             e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                 + ret);\n     }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                 \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n               ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n               \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d YarnConfiguration.DISKS_FAILED;\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n            e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n              \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/11 3:17 PM",
      "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "15/11/11 2:30 AM",
      "commitNameOld": "c56e05196190f172e9c8cdcd9d59d09950f1419b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 14.53,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,175 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n     ContainerId containerID \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.getAppId().toString();\n       Path containerLogDir \u003d\n-          this.logDirsSelector.getLocalPathForWrite(ContainerLaunch\n-              .getRelativeContainerLogDir(appIdStr, containerIdStr),\n-              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n+          dirsHandler.getLogPathForWrite(ContainerLaunch\n+              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toUri().getPath()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toUri().getPath())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n-      LocalDirAllocator lDirAllocator \u003d\n-          new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n \n       Path nmPrivateContainerScriptPath \u003d\n-          lDirAllocator.getLocalPathForWrite(\n+          dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n-                  + CONTAINER_SCRIPT, this.conf);\n+                  + CONTAINER_SCRIPT);\n       Path nmPrivateTokensPath \u003d\n-          lDirAllocator.getLocalPathForWrite(\n+          dirsHandler.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n-                      containerIdStr), this.conf);\n+                      containerIdStr));\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n-          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n+          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n-              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n+              LocalDirAllocator.SIZE_UNKNOWN, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n-      pidFilePath \u003d lDirAllocator.getLocalPathForWrite(\n+      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n-          + pidFileSuffix,\n-          this.conf);\n+          + pidFileSuffix);\n+      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n+      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n+\n+      if (!dirsHandler.areDisksHealthy()) {\n+        ret \u003d ExitCode.DISKS_FAILED.getExitCode();\n+        throw new IOException(\"Most of the disks failed. \"\n+            + dirsHandler.getDisksHealthReport());\n+      }\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n-        String[] localDirs \u003d\n-            this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n-                YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n-        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n+        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n-        ret \u003d\n-            exec.launchContainer(container, nmPrivateContainerScriptPath,\n-                nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n+        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n+                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n+                localDirs, logDirs);\n       }\n     } catch (Throwable e) {\n-      LOG.warn(\"Failed to launch container\", e);\n+      LOG.warn(\"Failed to launch container.\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n-            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n+            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n+            e.getMessage()));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n-    LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n-        + ret);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n+                + ret);\n+    }\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n-                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n+                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n+                \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n-              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n+              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n+              \"Container exited with a non-zero exit code \" + ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          dirsHandler.getLogPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr), false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n\n      Path nmPrivateContainerScriptPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT);\n      Path nmPrivateTokensPath \u003d\n          dirsHandler.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr));\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          dirsHandler.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d dirsHandler.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix);\n      List\u003cString\u003e localDirs \u003d dirsHandler.getLocalDirs();\n      List\u003cString\u003e logDirs \u003d dirsHandler.getLogDirs();\n\n      if (!dirsHandler.areDisksHealthy()) {\n        ret \u003d ExitCode.DISKS_FAILED.getExitCode();\n        throw new IOException(\"Most of the disks failed. \"\n            + dirsHandler.getDisksHealthReport());\n      }\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.size());\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir,\n                localDirs, logDirs);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container.\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n            e.getMessage()));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n                + ret);\n    }\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret,\n                \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret,\n              \"Container exited with a non-zero exit code \" + ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2989. Modified JobHistory to link to task and AM logs from the JobHistoryServer. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 11:45 PM",
      "commitName": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/10/11 5:03 AM",
      "commitNameOld": "2fe343f96348e894e6ed16c447c8c77ba1611d11",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,169 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n     ContainerId containerID \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n-      String appIdStr \u003d app.toString();\n+      String appIdStr \u003d app.getAppId().toString();\n       Path containerLogDir \u003d\n-          this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n-              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n-              false);\n+          this.logDirsSelector.getLocalPathForWrite(ContainerLaunch\n+              .getRelativeContainerLogDir(appIdStr, containerIdStr),\n+              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toUri().getPath()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toUri().getPath())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n       LocalDirAllocator lDirAllocator \u003d\n           new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n \n       Path nmPrivateContainerScriptPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT, this.conf);\n       Path nmPrivateTokensPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr), this.conf);\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n \n       String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n           containerIdStr);\n \n       // pid file should be in nm private dir so that it is not \n       // accessible by users\n       pidFilePath \u003d lDirAllocator.getLocalPathForWrite(\n           ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n           + pidFileSuffix,\n           this.conf);\n \n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         String[] localDirs \u003d\n             this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                 YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       // Check if the container is signalled to be killed.\n       if (!shouldLaunchContainer.compareAndSet(false, true)) {\n         LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n             + \"cleanup already called\");\n         ret \u003d ExitCode.TERMINATED.getExitCode();\n       }\n       else {\n         exec.activateContainer(containerID, pidFilePath);\n         ret \u003d\n             exec.launchContainer(container, nmPrivateContainerScriptPath,\n                 nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n       }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     } finally {\n       completed.set(true);\n       exec.deactivateContainer(containerID);\n     }\n \n     LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n         + ret);\n     if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n         || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n               ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.getAppId().toString();\n      Path containerLogDir \u003d\n          this.logDirsSelector.getLocalPathForWrite(ContainerLaunch\n              .getRelativeContainerLogDir(appIdStr, containerIdStr),\n              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n      LocalDirAllocator lDirAllocator \u003d\n          new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n\n      Path nmPrivateContainerScriptPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT, this.conf);\n      Path nmPrivateTokensPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr), this.conf);\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d lDirAllocator.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix,\n          this.conf);\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        String[] localDirs \u003d\n            this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d\n            exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n        + ret);\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "2fe343f96348e894e6ed16c447c8c77ba1611d11": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3240. Fixed NodeManager to be able to forcefully cleanup its containers (process-trees) irrespective of whether the container succeeded, or killed. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189711 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 5:03 AM",
      "commitName": "2fe343f96348e894e6ed16c447c8c77ba1611d11",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/10/11 10:09 AM",
      "commitNameOld": "7ce1c4ab352bca4b59ecbafdf237e5817cf833e5",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.79,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,169 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n-    String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n+    ContainerId containerID \u003d container.getContainerID();\n+    String containerIdStr \u003d ConverterUtils.toString(containerID);\n     final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.toString();\n       Path containerLogDir \u003d\n           this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n               + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n               false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toUri().getPath()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toUri().getPath())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n       LocalDirAllocator lDirAllocator \u003d\n           new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n \n       Path nmPrivateContainerScriptPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                   + CONTAINER_SCRIPT, this.conf);\n       Path nmPrivateTokensPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr), this.conf);\n \n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n+\n+      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n+          containerIdStr);\n+\n+      // pid file should be in nm private dir so that it is not \n+      // accessible by users\n+      pidFilePath \u003d lDirAllocator.getLocalPathForWrite(\n+          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n+          + pidFileSuffix,\n+          this.conf);\n+\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         String[] localDirs \u003d\n             this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                 YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n-            container.getContainerID(),\n+            containerID,\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n-      ret \u003d\n-          exec.launchContainer(container, nmPrivateContainerScriptPath,\n-              nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n+      // Check if the container is signalled to be killed.\n+      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n+        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n+            + \"cleanup already called\");\n+        ret \u003d ExitCode.TERMINATED.getExitCode();\n+      }\n+      else {\n+        exec.activateContainer(containerID, pidFilePath);\n+        ret \u003d\n+            exec.launchContainer(container, nmPrivateContainerScriptPath,\n+                nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n+      }\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n+    } finally {\n+      completed.set(true);\n+      exec.deactivateContainer(containerID);\n     }\n \n-    if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n+    LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n+        + ret);\n+    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n+        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n               ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    ContainerId containerID \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerID);\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.toString();\n      Path containerLogDir \u003d\n          this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n              false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n      LocalDirAllocator lDirAllocator \u003d\n          new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n\n      Path nmPrivateContainerScriptPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT, this.conf);\n      Path nmPrivateTokensPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr), this.conf);\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n\n      String pidFileSuffix \u003d String.format(ContainerLaunch.PID_FILE_NAME_FMT,\n          containerIdStr);\n\n      // pid file should be in nm private dir so that it is not \n      // accessible by users\n      pidFilePath \u003d lDirAllocator.getLocalPathForWrite(\n          ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR \n          + pidFileSuffix,\n          this.conf);\n\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        String[] localDirs \u003d\n            this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            containerID,\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      // Check if the container is signalled to be killed.\n      if (!shouldLaunchContainer.compareAndSet(false, true)) {\n        LOG.info(\"Container \" + containerIdStr + \" not launched as \"\n            + \"cleanup already called\");\n        ret \u003d ExitCode.TERMINATED.getExitCode();\n      }\n      else {\n        exec.activateContainer(containerID, pidFilePath);\n        ret \u003d\n            exec.launchContainer(container, nmPrivateContainerScriptPath,\n                nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n      }\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    } finally {\n      completed.set(true);\n      exec.deactivateContainer(containerID);\n    }\n\n    LOG.debug(\"Container \" + containerIdStr + \" completed with exit code \"\n        + ret);\n    if (ret \u003d\u003d ExitCode.FORCE_KILLED.getExitCode()\n        || ret \u003d\u003d ExitCode.TERMINATED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "02a81203bd0ff6116e3c68d376b3af3838231986": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2751. Modified NodeManager to stop leaving around local files after application finishes. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1180071 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/10/11 8:23 AM",
      "commitName": "02a81203bd0ff6116e3c68d376b3af3838231986",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "21/09/11 11:28 AM",
      "commitNameOld": "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 15.87,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,142 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n     String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n     final String user \u003d launchContext.getUser();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.toString();\n       Path containerLogDir \u003d\n           this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n               + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n               false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toUri().getPath()));\n       }\n       launchContext.setCommands(newCmds);\n \n       Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n       // Make a copy of env to iterate \u0026 do variable expansion\n       for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n         String value \u003d entry.getValue();\n         entry.setValue(\n             value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toUri().getPath())\n             );\n       }\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n       LocalDirAllocator lDirAllocator \u003d\n           new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n+\n       Path nmPrivateContainerScriptPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n-              ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n-                  + appIdStr + Path.SEPARATOR + containerIdStr\n-                  + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n+              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n+                  + CONTAINER_SCRIPT, this.conf);\n       Path nmPrivateTokensPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n-              ResourceLocalizationService.NM_PRIVATE_DIR\n-                  + Path.SEPARATOR\n-                  + containerIdStr\n+              getContainerPrivateDir(appIdStr, containerIdStr)\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr), this.conf);\n+\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         String[] localDirs \u003d\n             this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                 YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         environment.put(\n             ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n             new Path(containerWorkDir, \n                 FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         // Sanitize the container\u0027s environment\n         sanitizeEnv(environment, containerWorkDir, appDirs);\n         \n         // Write out the environment\n         writeLaunchEnv(containerScriptOutStream, environment, localResources,\n             launchContext.getCommands());\n         \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             container.getContainerID(),\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       ret \u003d\n           exec.launchContainer(container, nmPrivateContainerScriptPath,\n               nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n               ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.toString();\n      Path containerLogDir \u003d\n          this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n              false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n      LocalDirAllocator lDirAllocator \u003d\n          new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n\n      Path nmPrivateContainerScriptPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n                  + CONTAINER_SCRIPT, this.conf);\n      Path nmPrivateTokensPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              getContainerPrivateDir(appIdStr, containerIdStr)\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr), this.conf);\n\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        String[] localDirs \u003d\n            this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            container.getContainerID(),\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      ret \u003d\n          exec.launchContainer(container, nmPrivateContainerScriptPath,\n              nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2880. Improved classpath-construction for mapreduce AM and containers. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1173783 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/09/11 11:28 AM",
      "commitName": "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/09/11 12:26 AM",
      "commitNameOld": "88b82a0f6687ce103817fbb460fd30d870f717a0",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 7.46,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,143 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n     String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n     final String user \u003d launchContext.getUser();\n-    final Map\u003cString,String\u003e env \u003d launchContext.getEnvironment();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.toString();\n       Path containerLogDir \u003d\n           this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n               + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n               false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toUri().getPath()));\n       }\n       launchContext.setCommands(newCmds);\n \n-      Map\u003cString, String\u003e envs \u003d launchContext.getEnvironment();\n-      Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n-      for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n-        newEnvs.put(\n-            entry.getKey(),\n-            entry.getValue().replace(\n+      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n+      // Make a copy of env to iterate \u0026 do variable expansion\n+      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n+        String value \u003d entry.getValue();\n+        entry.setValue(\n+            value.replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n-                containerLogDir.toUri().getPath()));\n+                containerLogDir.toUri().getPath())\n+            );\n       }\n-      launchContext.setEnvironment(newEnvs);\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n       LocalDirAllocator lDirAllocator \u003d\n           new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n       Path nmPrivateContainerScriptPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                   + appIdStr + Path.SEPARATOR + containerIdStr\n                   + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n       Path nmPrivateTokensPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               ResourceLocalizationService.NM_PRIVATE_DIR\n                   + Path.SEPARATOR\n                   + containerIdStr\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr), this.conf);\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         String[] localDirs \u003d\n             this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                 YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n-        env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n-            containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n+        environment.put(\n+            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n+            new Path(containerWorkDir, \n+                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n-        writeLaunchEnv(containerScriptOutStream, env, localResources,\n-            launchContext.getCommands(), appDirs);\n+        // Sanitize the container\u0027s environment\n+        sanitizeEnv(environment, containerWorkDir, appDirs);\n+        \n+        // Write out the environment\n+        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n+            launchContext.getCommands());\n+        \n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             container.getContainerID(),\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       ret \u003d\n           exec.launchContainer(container, nmPrivateContainerScriptPath,\n               nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n               ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n    final String user \u003d launchContext.getUser();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.toString();\n      Path containerLogDir \u003d\n          this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n              false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e environment \u003d launchContext.getEnvironment();\n      // Make a copy of env to iterate \u0026 do variable expansion\n      for (Entry\u003cString, String\u003e entry : environment.entrySet()) {\n        String value \u003d entry.getValue();\n        entry.setValue(\n            value.replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath())\n            );\n      }\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n      LocalDirAllocator lDirAllocator \u003d\n          new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n      Path nmPrivateContainerScriptPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                  + appIdStr + Path.SEPARATOR + containerIdStr\n                  + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n      Path nmPrivateTokensPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR\n                  + Path.SEPARATOR\n                  + containerIdStr\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr), this.conf);\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        String[] localDirs \u003d\n            this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        environment.put(\n            ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, \n            new Path(containerWorkDir, \n                FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        // Sanitize the container\u0027s environment\n        sanitizeEnv(environment, containerWorkDir, appDirs);\n        \n        // Write out the environment\n        writeLaunchEnv(containerScriptOutStream, environment, localResources,\n            launchContext.getCommands());\n        \n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            container.getContainerID(),\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      ret \u003d\n          exec.launchContainer(container, nmPrivateContainerScriptPath,\n              nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "88b82a0f6687ce103817fbb460fd30d870f717a0": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2899. Replace major parts of ApplicationSubmissionContext with a ContainerLaunchContext (Arun Murthy via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1170459 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/09/11 12:26 AM",
      "commitName": "88b82a0f6687ce103817fbb460fd30d870f717a0",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "12/09/11 5:05 PM",
      "commitNameOld": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.31,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,137 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n     String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n     final String user \u003d launchContext.getUser();\n-    final Map\u003cString,String\u003e env \u003d launchContext.getEnv();\n+    final Map\u003cString,String\u003e env \u003d launchContext.getEnvironment();\n     final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.toString();\n       Path containerLogDir \u003d\n           this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n               + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n               false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toUri().getPath()));\n       }\n       launchContext.setCommands(newCmds);\n \n-      Map\u003cString, String\u003e envs \u003d launchContext.getEnv();\n+      Map\u003cString, String\u003e envs \u003d launchContext.getEnvironment();\n       Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n       for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n         newEnvs.put(\n             entry.getKey(),\n             entry.getValue().replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toUri().getPath()));\n       }\n-      launchContext.setEnv(newEnvs);\n+      launchContext.setEnvironment(newEnvs);\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n       LocalDirAllocator lDirAllocator \u003d\n           new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n       Path nmPrivateContainerScriptPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                   + appIdStr + Path.SEPARATOR + containerIdStr\n                   + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n       Path nmPrivateTokensPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               ResourceLocalizationService.NM_PRIVATE_DIR\n                   + Path.SEPARATOR\n                   + containerIdStr\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr), this.conf);\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         String[] localDirs \u003d\n             this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                 YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n             containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         writeLaunchEnv(containerScriptOutStream, env, localResources,\n             launchContext.getCommands(), appDirs);\n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             container.getContainerID(),\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       ret \u003d\n           exec.launchContainer(container, nmPrivateContainerScriptPath,\n               nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n               ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n    final String user \u003d launchContext.getUser();\n    final Map\u003cString,String\u003e env \u003d launchContext.getEnvironment();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.toString();\n      Path containerLogDir \u003d\n          this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n              false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e envs \u003d launchContext.getEnvironment();\n      Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n      for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n        newEnvs.put(\n            entry.getKey(),\n            entry.getValue().replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath()));\n      }\n      launchContext.setEnvironment(newEnvs);\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n      LocalDirAllocator lDirAllocator \u003d\n          new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n      Path nmPrivateContainerScriptPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                  + appIdStr + Path.SEPARATOR + containerIdStr\n                  + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n      Path nmPrivateTokensPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR\n                  + Path.SEPARATOR\n                  + containerIdStr\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr), this.conf);\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        String[] localDirs \u003d\n            this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n            containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        writeLaunchEnv(containerScriptOutStream, env, localResources,\n            launchContext.getCommands(), appDirs);\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            container.getContainerID(),\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      ret \u003d\n          exec.launchContainer(container, nmPrivateContainerScriptPath,\n              nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2896. Simplify all apis to in org.apache.hadoop.yarn.api.records.* to be get/set only. Added javadocs to all public records.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169980 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/09/11 5:05 PM",
      "commitName": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "08/09/11 6:44 PM",
      "commitNameOld": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 3.93,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,139 +1,137 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n     String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n     final String user \u003d launchContext.getUser();\n-    final Map\u003cString,String\u003e env \u003d launchContext.getAllEnv();\n-    final List\u003cString\u003e command \u003d launchContext.getCommandList();\n+    final Map\u003cString,String\u003e env \u003d launchContext.getEnv();\n+    final List\u003cString\u003e command \u003d launchContext.getCommands();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.toString();\n       Path containerLogDir \u003d\n           this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n               + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n               false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toUri().getPath()));\n       }\n-      launchContext.clearCommands();\n-      launchContext.addAllCommands(newCmds);\n+      launchContext.setCommands(newCmds);\n \n-      Map\u003cString, String\u003e envs \u003d launchContext.getAllEnv();\n+      Map\u003cString, String\u003e envs \u003d launchContext.getEnv();\n       Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n       for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n         newEnvs.put(\n             entry.getKey(),\n             entry.getValue().replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toUri().getPath()));\n       }\n-      launchContext.clearEnv();\n-      launchContext.addAllEnv(newEnvs);\n+      launchContext.setEnv(newEnvs);\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n       LocalDirAllocator lDirAllocator \u003d\n           new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n       Path nmPrivateContainerScriptPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                   + appIdStr + Path.SEPARATOR + containerIdStr\n                   + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n       Path nmPrivateTokensPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               ResourceLocalizationService.NM_PRIVATE_DIR\n                   + Path.SEPARATOR\n                   + containerIdStr\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr), this.conf);\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         String[] localDirs \u003d\n             this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                 YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n             containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         writeLaunchEnv(containerScriptOutStream, env, localResources,\n-            launchContext.getCommandList(), appDirs);\n+            launchContext.getCommands(), appDirs);\n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             container.getContainerID(),\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       ret \u003d\n           exec.launchContainer(container, nmPrivateContainerScriptPath,\n               nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n               ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n    final String user \u003d launchContext.getUser();\n    final Map\u003cString,String\u003e env \u003d launchContext.getEnv();\n    final List\u003cString\u003e command \u003d launchContext.getCommands();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.toString();\n      Path containerLogDir \u003d\n          this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n              false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.setCommands(newCmds);\n\n      Map\u003cString, String\u003e envs \u003d launchContext.getEnv();\n      Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n      for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n        newEnvs.put(\n            entry.getKey(),\n            entry.getValue().replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath()));\n      }\n      launchContext.setEnv(newEnvs);\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n      LocalDirAllocator lDirAllocator \u003d\n          new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n      Path nmPrivateContainerScriptPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                  + appIdStr + Path.SEPARATOR + containerIdStr\n                  + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n      Path nmPrivateTokensPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR\n                  + Path.SEPARATOR\n                  + containerIdStr\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr), this.conf);\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        String[] localDirs \u003d\n            this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n            containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        writeLaunchEnv(containerScriptOutStream, env, localResources,\n            launchContext.getCommands(), appDirs);\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            container.getContainerID(),\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      ret \u003d\n          exec.launchContainer(container, nmPrivateContainerScriptPath,\n              nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "fafe8cd28e726566509c679e19d7da622f29f90d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2864. Normalize configuration variable names for YARN. Contributed by Robert Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166955 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 6:44 PM",
      "commitName": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "06/09/11 2:49 PM",
      "commitNameOld": "f560a1066f8906862000c9b9d8c4e09bb10ea6a8",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 2.16,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,139 +1,139 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n     String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n     final String user \u003d launchContext.getUser();\n     final Map\u003cString,String\u003e env \u003d launchContext.getAllEnv();\n     final List\u003cString\u003e command \u003d launchContext.getCommandList();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.toString();\n       Path containerLogDir \u003d\n           this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n               + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n               false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toUri().getPath()));\n       }\n       launchContext.clearCommands();\n       launchContext.addAllCommands(newCmds);\n \n       Map\u003cString, String\u003e envs \u003d launchContext.getAllEnv();\n       Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n       for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n         newEnvs.put(\n             entry.getKey(),\n             entry.getValue().replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toUri().getPath()));\n       }\n       launchContext.clearEnv();\n       launchContext.addAllEnv(newEnvs);\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n       LocalDirAllocator lDirAllocator \u003d\n-          new LocalDirAllocator(NMConfig.NM_LOCAL_DIR); // TODO\n+          new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n       Path nmPrivateContainerScriptPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                   + appIdStr + Path.SEPARATOR + containerIdStr\n                   + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n       Path nmPrivateTokensPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               ResourceLocalizationService.NM_PRIVATE_DIR\n                   + Path.SEPARATOR\n                   + containerIdStr\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr), this.conf);\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n               LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         String[] localDirs \u003d\n-            this.conf.getStrings(NMConfig.NM_LOCAL_DIR,\n-                NMConfig.DEFAULT_NM_LOCAL_DIR);\n+            this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n+                YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n             containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         writeLaunchEnv(containerScriptOutStream, env, localResources,\n             launchContext.getCommandList(), appDirs);\n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             container.getContainerID(),\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       ret \u003d\n           exec.launchContainer(container, nmPrivateContainerScriptPath,\n               nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n               ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n    final String user \u003d launchContext.getUser();\n    final Map\u003cString,String\u003e env \u003d launchContext.getAllEnv();\n    final List\u003cString\u003e command \u003d launchContext.getCommandList();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.toString();\n      Path containerLogDir \u003d\n          this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n              false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.clearCommands();\n      launchContext.addAllCommands(newCmds);\n\n      Map\u003cString, String\u003e envs \u003d launchContext.getAllEnv();\n      Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n      for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n        newEnvs.put(\n            entry.getKey(),\n            entry.getValue().replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath()));\n      }\n      launchContext.clearEnv();\n      launchContext.addAllEnv(newEnvs);\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n      LocalDirAllocator lDirAllocator \u003d\n          new LocalDirAllocator(YarnConfiguration.NM_LOCAL_DIRS); // TODO\n      Path nmPrivateContainerScriptPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                  + appIdStr + Path.SEPARATOR + containerIdStr\n                  + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n      Path nmPrivateTokensPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR\n                  + Path.SEPARATOR\n                  + containerIdStr\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr), this.conf);\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        String[] localDirs \u003d\n            this.conf.getStrings(YarnConfiguration.NM_LOCAL_DIRS,\n                YarnConfiguration.DEFAULT_NM_LOCAL_DIRS);\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n            containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        writeLaunchEnv(containerScriptOutStream, env, localResources,\n            launchContext.getCommandList(), appDirs);\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            container.getContainerID(),\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      ret \u003d\n          exec.launchContainer(container, nmPrivateContainerScriptPath,\n              nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "f560a1066f8906862000c9b9d8c4e09bb10ea6a8": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2687. Fix NodeManager to use the right version of LocalDirAllocator.getLocalPathToWrite. Contributed by mahadev \u0026 acmurthy. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165890 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/11 2:49 PM",
      "commitName": "f560a1066f8906862000c9b9d8c4e09bb10ea6a8",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 12.9,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,138 +1,139 @@\n   public Integer call() {\n     final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n     final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n     String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n     final String user \u003d launchContext.getUser();\n     final Map\u003cString,String\u003e env \u003d launchContext.getAllEnv();\n     final List\u003cString\u003e command \u003d launchContext.getCommandList();\n     int ret \u003d -1;\n \n     try {\n       // /////////////////////////// Variable expansion\n       // Before the container script gets written out.\n       List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n       String appIdStr \u003d app.toString();\n       Path containerLogDir \u003d\n           this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n-              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf);\n+              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n+              false);\n       for (String str : command) {\n         // TODO: Should we instead work via symlinks without this grammar?\n         newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n             containerLogDir.toUri().getPath()));\n       }\n       launchContext.clearCommands();\n       launchContext.addAllCommands(newCmds);\n \n       Map\u003cString, String\u003e envs \u003d launchContext.getAllEnv();\n       Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n       for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n         newEnvs.put(\n             entry.getKey(),\n             entry.getValue().replace(\n                 ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                 containerLogDir.toUri().getPath()));\n       }\n       launchContext.clearEnv();\n       launchContext.addAllEnv(newEnvs);\n       // /////////////////////////// End of variable expansion\n \n       FileContext lfs \u003d FileContext.getLocalFSFileContext();\n       LocalDirAllocator lDirAllocator \u003d\n           new LocalDirAllocator(NMConfig.NM_LOCAL_DIR); // TODO\n       Path nmPrivateContainerScriptPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                   + appIdStr + Path.SEPARATOR + containerIdStr\n                   + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n       Path nmPrivateTokensPath \u003d\n           lDirAllocator.getLocalPathForWrite(\n               ResourceLocalizationService.NM_PRIVATE_DIR\n                   + Path.SEPARATOR\n                   + containerIdStr\n                   + Path.SEPARATOR\n                   + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                       containerIdStr), this.conf);\n       DataOutputStream containerScriptOutStream \u003d null;\n       DataOutputStream tokensOutStream \u003d null;\n \n       // Select the working directory for the container\n       Path containerWorkDir \u003d\n           lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n               + Path.SEPARATOR + user + Path.SEPARATOR\n               + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n               + Path.SEPARATOR + containerIdStr,\n-              LocalDirAllocator.SIZE_UNKNOWN, this.conf);\n+              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n       try {\n         // /////////// Write out the container-script in the nmPrivate space.\n         String[] localDirs \u003d\n             this.conf.getStrings(NMConfig.NM_LOCAL_DIR,\n                 NMConfig.DEFAULT_NM_LOCAL_DIR);\n         List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n         for (String localDir : localDirs) {\n           Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n           Path userdir \u003d new Path(usersdir, user);\n           Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n           appDirs.add(new Path(appsdir, appIdStr));\n         }\n         containerScriptOutStream \u003d\n           lfs.create(nmPrivateContainerScriptPath,\n               EnumSet.of(CREATE, OVERWRITE));\n \n         // Set the token location too.\n         env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n             containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n \n         writeLaunchEnv(containerScriptOutStream, env, localResources,\n             launchContext.getCommandList(), appDirs);\n         // /////////// End of writing out container-script\n \n         // /////////// Write out the container-tokens in the nmPrivate space.\n         tokensOutStream \u003d\n             lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n         Credentials creds \u003d container.getCredentials();\n         creds.writeTokenStorageToStream(tokensOutStream);\n         // /////////// End of writing out container-tokens\n       } finally {\n         IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n       }\n \n       // LaunchContainer is a blocking call. We are here almost means the\n       // container is launched, so send out the event.\n       dispatcher.getEventHandler().handle(new ContainerEvent(\n             container.getContainerID(),\n             ContainerEventType.CONTAINER_LAUNCHED));\n \n       ret \u003d\n           exec.launchContainer(container, nmPrivateContainerScriptPath,\n               nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n     } catch (Throwable e) {\n       LOG.warn(\"Failed to launch container\", e);\n       dispatcher.getEventHandler().handle(new ContainerExitEvent(\n             launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n       // If the process was killed, Send container_cleanedup_after_kill and\n       // just break out of this method.\n       dispatcher.getEventHandler().handle(\n             new ContainerExitEvent(launchContext.getContainerId(),\n                 ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n       return ret;\n     }\n \n     if (ret !\u003d 0) {\n       LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n               launchContext.getContainerId(),\n               ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n       return ret;\n     }\n \n     LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(launchContext.getContainerId(),\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n    final String user \u003d launchContext.getUser();\n    final Map\u003cString,String\u003e env \u003d launchContext.getAllEnv();\n    final List\u003cString\u003e command \u003d launchContext.getCommandList();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.toString();\n      Path containerLogDir \u003d\n          this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf, \n              false);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.clearCommands();\n      launchContext.addAllCommands(newCmds);\n\n      Map\u003cString, String\u003e envs \u003d launchContext.getAllEnv();\n      Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n      for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n        newEnvs.put(\n            entry.getKey(),\n            entry.getValue().replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath()));\n      }\n      launchContext.clearEnv();\n      launchContext.addAllEnv(newEnvs);\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n      LocalDirAllocator lDirAllocator \u003d\n          new LocalDirAllocator(NMConfig.NM_LOCAL_DIR); // TODO\n      Path nmPrivateContainerScriptPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                  + appIdStr + Path.SEPARATOR + containerIdStr\n                  + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n      Path nmPrivateTokensPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR\n                  + Path.SEPARATOR\n                  + containerIdStr\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr), this.conf);\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, this.conf, false);\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        String[] localDirs \u003d\n            this.conf.getStrings(NMConfig.NM_LOCAL_DIR,\n                NMConfig.DEFAULT_NM_LOCAL_DIR);\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n            containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        writeLaunchEnv(containerScriptOutStream, env, localResources,\n            launchContext.getCommandList(), appDirs);\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            container.getContainerID(),\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      ret \u003d\n          exec.launchContainer(container, nmPrivateContainerScriptPath,\n              nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n    final String user \u003d launchContext.getUser();\n    final Map\u003cString,String\u003e env \u003d launchContext.getAllEnv();\n    final List\u003cString\u003e command \u003d launchContext.getCommandList();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.toString();\n      Path containerLogDir \u003d\n          this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.clearCommands();\n      launchContext.addAllCommands(newCmds);\n\n      Map\u003cString, String\u003e envs \u003d launchContext.getAllEnv();\n      Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n      for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n        newEnvs.put(\n            entry.getKey(),\n            entry.getValue().replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath()));\n      }\n      launchContext.clearEnv();\n      launchContext.addAllEnv(newEnvs);\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n      LocalDirAllocator lDirAllocator \u003d\n          new LocalDirAllocator(NMConfig.NM_LOCAL_DIR); // TODO\n      Path nmPrivateContainerScriptPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                  + appIdStr + Path.SEPARATOR + containerIdStr\n                  + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n      Path nmPrivateTokensPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR\n                  + Path.SEPARATOR\n                  + containerIdStr\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr), this.conf);\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, this.conf);\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        String[] localDirs \u003d\n            this.conf.getStrings(NMConfig.NM_LOCAL_DIR,\n                NMConfig.DEFAULT_NM_LOCAL_DIR);\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n            containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        writeLaunchEnv(containerScriptOutStream, env, localResources,\n            launchContext.getCommandList(), appDirs);\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            container.getContainerID(),\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      ret \u003d\n          exec.launchContainer(container, nmPrivateContainerScriptPath,\n              nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,138 @@\n+  public Integer call() {\n+    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n+    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n+    String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n+    final String user \u003d launchContext.getUser();\n+    final Map\u003cString,String\u003e env \u003d launchContext.getAllEnv();\n+    final List\u003cString\u003e command \u003d launchContext.getCommandList();\n+    int ret \u003d -1;\n+\n+    try {\n+      // /////////////////////////// Variable expansion\n+      // Before the container script gets written out.\n+      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n+      String appIdStr \u003d app.toString();\n+      Path containerLogDir \u003d\n+          this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n+              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf);\n+      for (String str : command) {\n+        // TODO: Should we instead work via symlinks without this grammar?\n+        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n+            containerLogDir.toUri().getPath()));\n+      }\n+      launchContext.clearCommands();\n+      launchContext.addAllCommands(newCmds);\n+\n+      Map\u003cString, String\u003e envs \u003d launchContext.getAllEnv();\n+      Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n+      for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n+        newEnvs.put(\n+            entry.getKey(),\n+            entry.getValue().replace(\n+                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n+                containerLogDir.toUri().getPath()));\n+      }\n+      launchContext.clearEnv();\n+      launchContext.addAllEnv(newEnvs);\n+      // /////////////////////////// End of variable expansion\n+\n+      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n+      LocalDirAllocator lDirAllocator \u003d\n+          new LocalDirAllocator(NMConfig.NM_LOCAL_DIR); // TODO\n+      Path nmPrivateContainerScriptPath \u003d\n+          lDirAllocator.getLocalPathForWrite(\n+              ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n+                  + appIdStr + Path.SEPARATOR + containerIdStr\n+                  + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n+      Path nmPrivateTokensPath \u003d\n+          lDirAllocator.getLocalPathForWrite(\n+              ResourceLocalizationService.NM_PRIVATE_DIR\n+                  + Path.SEPARATOR\n+                  + containerIdStr\n+                  + Path.SEPARATOR\n+                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n+                      containerIdStr), this.conf);\n+      DataOutputStream containerScriptOutStream \u003d null;\n+      DataOutputStream tokensOutStream \u003d null;\n+\n+      // Select the working directory for the container\n+      Path containerWorkDir \u003d\n+          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n+              + Path.SEPARATOR + user + Path.SEPARATOR\n+              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n+              + Path.SEPARATOR + containerIdStr,\n+              LocalDirAllocator.SIZE_UNKNOWN, this.conf);\n+      try {\n+        // /////////// Write out the container-script in the nmPrivate space.\n+        String[] localDirs \u003d\n+            this.conf.getStrings(NMConfig.NM_LOCAL_DIR,\n+                NMConfig.DEFAULT_NM_LOCAL_DIR);\n+        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n+        for (String localDir : localDirs) {\n+          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n+          Path userdir \u003d new Path(usersdir, user);\n+          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n+          appDirs.add(new Path(appsdir, appIdStr));\n+        }\n+        containerScriptOutStream \u003d\n+          lfs.create(nmPrivateContainerScriptPath,\n+              EnumSet.of(CREATE, OVERWRITE));\n+\n+        // Set the token location too.\n+        env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n+            containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n+\n+        writeLaunchEnv(containerScriptOutStream, env, localResources,\n+            launchContext.getCommandList(), appDirs);\n+        // /////////// End of writing out container-script\n+\n+        // /////////// Write out the container-tokens in the nmPrivate space.\n+        tokensOutStream \u003d\n+            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n+        Credentials creds \u003d container.getCredentials();\n+        creds.writeTokenStorageToStream(tokensOutStream);\n+        // /////////// End of writing out container-tokens\n+      } finally {\n+        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n+      }\n+\n+      // LaunchContainer is a blocking call. We are here almost means the\n+      // container is launched, so send out the event.\n+      dispatcher.getEventHandler().handle(new ContainerEvent(\n+            container.getContainerID(),\n+            ContainerEventType.CONTAINER_LAUNCHED));\n+\n+      ret \u003d\n+          exec.launchContainer(container, nmPrivateContainerScriptPath,\n+              nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n+    } catch (Throwable e) {\n+      LOG.warn(\"Failed to launch container\", e);\n+      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n+            launchContext.getContainerId(),\n+            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n+      return ret;\n+    }\n+\n+    if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n+      // If the process was killed, Send container_cleanedup_after_kill and\n+      // just break out of this method.\n+      dispatcher.getEventHandler().handle(\n+            new ContainerExitEvent(launchContext.getContainerId(),\n+                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n+      return ret;\n+    }\n+\n+    if (ret !\u003d 0) {\n+      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n+      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n+              launchContext.getContainerId(),\n+              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n+      return ret;\n+    }\n+\n+    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n+    dispatcher.getEventHandler().handle(\n+        new ContainerEvent(launchContext.getContainerId(),\n+            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n+    return 0;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    final ContainerLaunchContext launchContext \u003d container.getLaunchContext();\n    final Map\u003cPath,String\u003e localResources \u003d container.getLocalizedResources();\n    String containerIdStr \u003d ConverterUtils.toString(container.getContainerID());\n    final String user \u003d launchContext.getUser();\n    final Map\u003cString,String\u003e env \u003d launchContext.getAllEnv();\n    final List\u003cString\u003e command \u003d launchContext.getCommandList();\n    int ret \u003d -1;\n\n    try {\n      // /////////////////////////// Variable expansion\n      // Before the container script gets written out.\n      List\u003cString\u003e newCmds \u003d new ArrayList\u003cString\u003e(command.size());\n      String appIdStr \u003d app.toString();\n      Path containerLogDir \u003d\n          this.logDirsSelector.getLocalPathForWrite(appIdStr + Path.SEPARATOR\n              + containerIdStr, LocalDirAllocator.SIZE_UNKNOWN, this.conf);\n      for (String str : command) {\n        // TODO: Should we instead work via symlinks without this grammar?\n        newCmds.add(str.replace(ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n            containerLogDir.toUri().getPath()));\n      }\n      launchContext.clearCommands();\n      launchContext.addAllCommands(newCmds);\n\n      Map\u003cString, String\u003e envs \u003d launchContext.getAllEnv();\n      Map\u003cString, String\u003e newEnvs \u003d new HashMap\u003cString, String\u003e(envs.size());\n      for (Entry\u003cString, String\u003e entry : envs.entrySet()) {\n        newEnvs.put(\n            entry.getKey(),\n            entry.getValue().replace(\n                ApplicationConstants.LOG_DIR_EXPANSION_VAR,\n                containerLogDir.toUri().getPath()));\n      }\n      launchContext.clearEnv();\n      launchContext.addAllEnv(newEnvs);\n      // /////////////////////////// End of variable expansion\n\n      FileContext lfs \u003d FileContext.getLocalFSFileContext();\n      LocalDirAllocator lDirAllocator \u003d\n          new LocalDirAllocator(NMConfig.NM_LOCAL_DIR); // TODO\n      Path nmPrivateContainerScriptPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR + Path.SEPARATOR\n                  + appIdStr + Path.SEPARATOR + containerIdStr\n                  + Path.SEPARATOR + CONTAINER_SCRIPT, this.conf);\n      Path nmPrivateTokensPath \u003d\n          lDirAllocator.getLocalPathForWrite(\n              ResourceLocalizationService.NM_PRIVATE_DIR\n                  + Path.SEPARATOR\n                  + containerIdStr\n                  + Path.SEPARATOR\n                  + String.format(ContainerLocalizer.TOKEN_FILE_NAME_FMT,\n                      containerIdStr), this.conf);\n      DataOutputStream containerScriptOutStream \u003d null;\n      DataOutputStream tokensOutStream \u003d null;\n\n      // Select the working directory for the container\n      Path containerWorkDir \u003d\n          lDirAllocator.getLocalPathForWrite(ContainerLocalizer.USERCACHE\n              + Path.SEPARATOR + user + Path.SEPARATOR\n              + ContainerLocalizer.APPCACHE + Path.SEPARATOR + appIdStr\n              + Path.SEPARATOR + containerIdStr,\n              LocalDirAllocator.SIZE_UNKNOWN, this.conf);\n      try {\n        // /////////// Write out the container-script in the nmPrivate space.\n        String[] localDirs \u003d\n            this.conf.getStrings(NMConfig.NM_LOCAL_DIR,\n                NMConfig.DEFAULT_NM_LOCAL_DIR);\n        List\u003cPath\u003e appDirs \u003d new ArrayList\u003cPath\u003e(localDirs.length);\n        for (String localDir : localDirs) {\n          Path usersdir \u003d new Path(localDir, ContainerLocalizer.USERCACHE);\n          Path userdir \u003d new Path(usersdir, user);\n          Path appsdir \u003d new Path(userdir, ContainerLocalizer.APPCACHE);\n          appDirs.add(new Path(appsdir, appIdStr));\n        }\n        containerScriptOutStream \u003d\n          lfs.create(nmPrivateContainerScriptPath,\n              EnumSet.of(CREATE, OVERWRITE));\n\n        // Set the token location too.\n        env.put(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME, new Path(\n            containerWorkDir, FINAL_CONTAINER_TOKENS_FILE).toUri().getPath());\n\n        writeLaunchEnv(containerScriptOutStream, env, localResources,\n            launchContext.getCommandList(), appDirs);\n        // /////////// End of writing out container-script\n\n        // /////////// Write out the container-tokens in the nmPrivate space.\n        tokensOutStream \u003d\n            lfs.create(nmPrivateTokensPath, EnumSet.of(CREATE, OVERWRITE));\n        Credentials creds \u003d container.getCredentials();\n        creds.writeTokenStorageToStream(tokensOutStream);\n        // /////////// End of writing out container-tokens\n      } finally {\n        IOUtils.cleanup(LOG, containerScriptOutStream, tokensOutStream);\n      }\n\n      // LaunchContainer is a blocking call. We are here almost means the\n      // container is launched, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n            container.getContainerID(),\n            ContainerEventType.CONTAINER_LAUNCHED));\n\n      ret \u003d\n          exec.launchContainer(container, nmPrivateContainerScriptPath,\n              nmPrivateTokensPath, user, appIdStr, containerWorkDir);\n    } catch (Throwable e) {\n      LOG.warn(\"Failed to launch container\", e);\n      dispatcher.getEventHandler().handle(new ContainerExitEvent(\n            launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    if (ret \u003d\u003d ExitCode.KILLED.getExitCode()) {\n      // If the process was killed, Send container_cleanedup_after_kill and\n      // just break out of this method.\n      dispatcher.getEventHandler().handle(\n            new ContainerExitEvent(launchContext.getContainerId(),\n                ContainerEventType.CONTAINER_KILLED_ON_REQUEST, ret));\n      return ret;\n    }\n\n    if (ret !\u003d 0) {\n      LOG.warn(\"Container exited with a non-zero exit code \" + ret);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n              launchContext.getContainerId(),\n              ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, ret));\n      return ret;\n    }\n\n    LOG.info(\"Container \" + containerIdStr + \" succeeded \");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(launchContext.getContainerId(),\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java"
    }
  }
}