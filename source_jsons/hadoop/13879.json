{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockManager.java",
  "functionName": "chooseExcessRedundancyStriped",
  "functionId": "chooseExcessRedundancyStriped___bc-BlockCollection__nonExcess-Collection__DatanodeStorageInfo__(modifiers-final)__storedBlock-BlockInfo__delNodeHint-DatanodeDescriptor",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
  "functionStartLine": 3948,
  "functionEndLine": 4014,
  "numCommitsSeen": 807,
  "timeTaken": 10533,
  "changeHistory": [
    "a2a5d7b5bca715835d92816e7b267b59f7270708",
    "5865fe2bf01284993572ea60b3ec3bf8b4492818",
    "f2ba7da4f0df6cf0fc245093aeb4500158e6ee0b",
    "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e",
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e"
  ],
  "changeHistoryShort": {
    "a2a5d7b5bca715835d92816e7b267b59f7270708": "Ybodychange",
    "5865fe2bf01284993572ea60b3ec3bf8b4492818": "Ymultichange(Yrename,Ybodychange)",
    "f2ba7da4f0df6cf0fc245093aeb4500158e6ee0b": "Ybodychange",
    "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e": "Ybodychange",
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e": "Ybodychange"
  },
  "changeHistoryDetails": {
    "a2a5d7b5bca715835d92816e7b267b59f7270708": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10759. Change fsimage bool isStriped from boolean to an enum. Contributed by Ewan Higgs.\n",
      "commitDate": "18/01/17 1:31 PM",
      "commitName": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "05/12/16 10:54 AM",
      "commitNameOld": "1b5cceaffbdde50a87ede81552dc380832db8e79",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 44.11,
      "commitsBetweenForRepo": 218,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,67 @@\n   private void chooseExcessRedundancyStriped(BlockCollection bc,\n       final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n       BlockInfo storedBlock,\n       DatanodeDescriptor delNodeHint) {\n     assert storedBlock instanceof BlockInfoStriped;\n     BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n     short groupSize \u003d sblk.getTotalBlockNum();\n \n     // find all duplicated indices\n     BitSet found \u003d new BitSet(groupSize); //indices found\n     BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n     HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n     for (DatanodeStorageInfo storage : nonExcess) {\n       int index \u003d sblk.getStorageBlockIndex(storage);\n       assert index \u003e\u003d 0;\n       if (found.get(index)) {\n         duplicated.set(index);\n       }\n       found.set(index);\n       storage2index.put(storage, index);\n     }\n \n     // use delHint only if delHint is duplicated\n     final DatanodeStorageInfo delStorageHint \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n     if (delStorageHint !\u003d null) {\n       Integer index \u003d storage2index.get(delStorageHint);\n       if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n         processChosenExcessRedundancy(nonExcess, delStorageHint, storedBlock);\n       }\n     }\n \n     // cardinality of found indicates the expected number of internal blocks\n     final int numOfTarget \u003d found.cardinality();\n     final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n         bc.getStoragePolicyID());\n     final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n         (short) numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n     if (excessTypes.isEmpty()) {\n       LOG.warn(\"excess types chosen for block {} among storages {} is empty\",\n           storedBlock, nonExcess);\n       return;\n     }\n \n-    BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n+    BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(STRIPED);\n     // for each duplicated index, delete some replicas until only one left\n     for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n          targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n       List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (DatanodeStorageInfo storage : nonExcess) {\n         int index \u003d storage2index.get(storage);\n         if (index \u003d\u003d targetIndex) {\n           candidates.add(storage);\n         }\n       }\n       if (candidates.size() \u003e 1) {\n         List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n             .chooseReplicasToDelete(nonExcess, candidates, (short) 1,\n                 excessTypes, null, null);\n         for (DatanodeStorageInfo chosen : replicasToDelete) {\n           processChosenExcessRedundancy(nonExcess, chosen, storedBlock);\n           candidates.remove(chosen);\n         }\n       }\n       duplicated.clear(targetIndex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void chooseExcessRedundancyStriped(BlockCollection bc,\n      final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n      BlockInfo storedBlock,\n      DatanodeDescriptor delNodeHint) {\n    assert storedBlock instanceof BlockInfoStriped;\n    BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n    short groupSize \u003d sblk.getTotalBlockNum();\n\n    // find all duplicated indices\n    BitSet found \u003d new BitSet(groupSize); //indices found\n    BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n    HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n    for (DatanodeStorageInfo storage : nonExcess) {\n      int index \u003d sblk.getStorageBlockIndex(storage);\n      assert index \u003e\u003d 0;\n      if (found.get(index)) {\n        duplicated.set(index);\n      }\n      found.set(index);\n      storage2index.put(storage, index);\n    }\n\n    // use delHint only if delHint is duplicated\n    final DatanodeStorageInfo delStorageHint \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n    if (delStorageHint !\u003d null) {\n      Integer index \u003d storage2index.get(delStorageHint);\n      if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n        processChosenExcessRedundancy(nonExcess, delStorageHint, storedBlock);\n      }\n    }\n\n    // cardinality of found indicates the expected number of internal blocks\n    final int numOfTarget \u003d found.cardinality();\n    final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n        bc.getStoragePolicyID());\n    final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n        (short) numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n    if (excessTypes.isEmpty()) {\n      LOG.warn(\"excess types chosen for block {} among storages {} is empty\",\n          storedBlock, nonExcess);\n      return;\n    }\n\n    BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(STRIPED);\n    // for each duplicated index, delete some replicas until only one left\n    for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n         targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n      List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (DatanodeStorageInfo storage : nonExcess) {\n        int index \u003d storage2index.get(storage);\n        if (index \u003d\u003d targetIndex) {\n          candidates.add(storage);\n        }\n      }\n      if (candidates.size() \u003e 1) {\n        List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n            .chooseReplicasToDelete(nonExcess, candidates, (short) 1,\n                excessTypes, null, null);\n        for (DatanodeStorageInfo chosen : replicasToDelete) {\n          processChosenExcessRedundancy(nonExcess, chosen, storedBlock);\n          candidates.remove(chosen);\n        }\n      }\n      duplicated.clear(targetIndex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "5865fe2bf01284993572ea60b3ec3bf8b4492818": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "HDFS-9869. Erasure Coding: Rename replication-based names in BlockManager to more generic [part-2]. Contributed by Rakesh R.\n",
      "commitDate": "25/04/16 10:01 PM",
      "commitName": "5865fe2bf01284993572ea60b3ec3bf8b4492818",
      "commitAuthor": "Zhe Zhang",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-9869. Erasure Coding: Rename replication-based names in BlockManager to more generic [part-2]. Contributed by Rakesh R.\n",
          "commitDate": "25/04/16 10:01 PM",
          "commitName": "5865fe2bf01284993572ea60b3ec3bf8b4492818",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "17/04/16 6:28 PM",
          "commitNameOld": "67523ffcf491f4f2db5335899c00a174d0caaa9b",
          "commitAuthorOld": "Walter Su",
          "daysBetweenCommits": 8.15,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,67 @@\n-  private void chooseExcessReplicasStriped(BlockCollection bc,\n+  private void chooseExcessRedundancyStriped(BlockCollection bc,\n       final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n       BlockInfo storedBlock,\n       DatanodeDescriptor delNodeHint) {\n     assert storedBlock instanceof BlockInfoStriped;\n     BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n     short groupSize \u003d sblk.getTotalBlockNum();\n \n     // find all duplicated indices\n     BitSet found \u003d new BitSet(groupSize); //indices found\n     BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n     HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n     for (DatanodeStorageInfo storage : nonExcess) {\n       int index \u003d sblk.getStorageBlockIndex(storage);\n       assert index \u003e\u003d 0;\n       if (found.get(index)) {\n         duplicated.set(index);\n       }\n       found.set(index);\n       storage2index.put(storage, index);\n     }\n \n     // use delHint only if delHint is duplicated\n     final DatanodeStorageInfo delStorageHint \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n     if (delStorageHint !\u003d null) {\n       Integer index \u003d storage2index.get(delStorageHint);\n       if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n-        processChosenExcessReplica(nonExcess, delStorageHint, storedBlock);\n+        processChosenExcessRedundancy(nonExcess, delStorageHint, storedBlock);\n       }\n     }\n \n     // cardinality of found indicates the expected number of internal blocks\n     final int numOfTarget \u003d found.cardinality();\n     final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n         bc.getStoragePolicyID());\n     final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n         (short) numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n     if (excessTypes.isEmpty()) {\n       LOG.warn(\"excess types chosen for block {} among storages {} is empty\",\n           storedBlock, nonExcess);\n       return;\n     }\n \n     BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n     // for each duplicated index, delete some replicas until only one left\n     for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n          targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n       List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (DatanodeStorageInfo storage : nonExcess) {\n         int index \u003d storage2index.get(storage);\n         if (index \u003d\u003d targetIndex) {\n           candidates.add(storage);\n         }\n       }\n       if (candidates.size() \u003e 1) {\n         List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n             .chooseReplicasToDelete(nonExcess, candidates, (short) 1,\n                 excessTypes, null, null);\n         for (DatanodeStorageInfo chosen : replicasToDelete) {\n-          processChosenExcessReplica(nonExcess, chosen, storedBlock);\n+          processChosenExcessRedundancy(nonExcess, chosen, storedBlock);\n           candidates.remove(chosen);\n         }\n       }\n       duplicated.clear(targetIndex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void chooseExcessRedundancyStriped(BlockCollection bc,\n      final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n      BlockInfo storedBlock,\n      DatanodeDescriptor delNodeHint) {\n    assert storedBlock instanceof BlockInfoStriped;\n    BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n    short groupSize \u003d sblk.getTotalBlockNum();\n\n    // find all duplicated indices\n    BitSet found \u003d new BitSet(groupSize); //indices found\n    BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n    HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n    for (DatanodeStorageInfo storage : nonExcess) {\n      int index \u003d sblk.getStorageBlockIndex(storage);\n      assert index \u003e\u003d 0;\n      if (found.get(index)) {\n        duplicated.set(index);\n      }\n      found.set(index);\n      storage2index.put(storage, index);\n    }\n\n    // use delHint only if delHint is duplicated\n    final DatanodeStorageInfo delStorageHint \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n    if (delStorageHint !\u003d null) {\n      Integer index \u003d storage2index.get(delStorageHint);\n      if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n        processChosenExcessRedundancy(nonExcess, delStorageHint, storedBlock);\n      }\n    }\n\n    // cardinality of found indicates the expected number of internal blocks\n    final int numOfTarget \u003d found.cardinality();\n    final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n        bc.getStoragePolicyID());\n    final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n        (short) numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n    if (excessTypes.isEmpty()) {\n      LOG.warn(\"excess types chosen for block {} among storages {} is empty\",\n          storedBlock, nonExcess);\n      return;\n    }\n\n    BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n    // for each duplicated index, delete some replicas until only one left\n    for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n         targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n      List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (DatanodeStorageInfo storage : nonExcess) {\n        int index \u003d storage2index.get(storage);\n        if (index \u003d\u003d targetIndex) {\n          candidates.add(storage);\n        }\n      }\n      if (candidates.size() \u003e 1) {\n        List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n            .chooseReplicasToDelete(nonExcess, candidates, (short) 1,\n                excessTypes, null, null);\n        for (DatanodeStorageInfo chosen : replicasToDelete) {\n          processChosenExcessRedundancy(nonExcess, chosen, storedBlock);\n          candidates.remove(chosen);\n        }\n      }\n      duplicated.clear(targetIndex);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {
            "oldValue": "chooseExcessReplicasStriped",
            "newValue": "chooseExcessRedundancyStriped"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9869. Erasure Coding: Rename replication-based names in BlockManager to more generic [part-2]. Contributed by Rakesh R.\n",
          "commitDate": "25/04/16 10:01 PM",
          "commitName": "5865fe2bf01284993572ea60b3ec3bf8b4492818",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "17/04/16 6:28 PM",
          "commitNameOld": "67523ffcf491f4f2db5335899c00a174d0caaa9b",
          "commitAuthorOld": "Walter Su",
          "daysBetweenCommits": 8.15,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,67 @@\n-  private void chooseExcessReplicasStriped(BlockCollection bc,\n+  private void chooseExcessRedundancyStriped(BlockCollection bc,\n       final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n       BlockInfo storedBlock,\n       DatanodeDescriptor delNodeHint) {\n     assert storedBlock instanceof BlockInfoStriped;\n     BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n     short groupSize \u003d sblk.getTotalBlockNum();\n \n     // find all duplicated indices\n     BitSet found \u003d new BitSet(groupSize); //indices found\n     BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n     HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n     for (DatanodeStorageInfo storage : nonExcess) {\n       int index \u003d sblk.getStorageBlockIndex(storage);\n       assert index \u003e\u003d 0;\n       if (found.get(index)) {\n         duplicated.set(index);\n       }\n       found.set(index);\n       storage2index.put(storage, index);\n     }\n \n     // use delHint only if delHint is duplicated\n     final DatanodeStorageInfo delStorageHint \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n     if (delStorageHint !\u003d null) {\n       Integer index \u003d storage2index.get(delStorageHint);\n       if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n-        processChosenExcessReplica(nonExcess, delStorageHint, storedBlock);\n+        processChosenExcessRedundancy(nonExcess, delStorageHint, storedBlock);\n       }\n     }\n \n     // cardinality of found indicates the expected number of internal blocks\n     final int numOfTarget \u003d found.cardinality();\n     final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n         bc.getStoragePolicyID());\n     final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n         (short) numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n     if (excessTypes.isEmpty()) {\n       LOG.warn(\"excess types chosen for block {} among storages {} is empty\",\n           storedBlock, nonExcess);\n       return;\n     }\n \n     BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n     // for each duplicated index, delete some replicas until only one left\n     for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n          targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n       List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (DatanodeStorageInfo storage : nonExcess) {\n         int index \u003d storage2index.get(storage);\n         if (index \u003d\u003d targetIndex) {\n           candidates.add(storage);\n         }\n       }\n       if (candidates.size() \u003e 1) {\n         List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n             .chooseReplicasToDelete(nonExcess, candidates, (short) 1,\n                 excessTypes, null, null);\n         for (DatanodeStorageInfo chosen : replicasToDelete) {\n-          processChosenExcessReplica(nonExcess, chosen, storedBlock);\n+          processChosenExcessRedundancy(nonExcess, chosen, storedBlock);\n           candidates.remove(chosen);\n         }\n       }\n       duplicated.clear(targetIndex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void chooseExcessRedundancyStriped(BlockCollection bc,\n      final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n      BlockInfo storedBlock,\n      DatanodeDescriptor delNodeHint) {\n    assert storedBlock instanceof BlockInfoStriped;\n    BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n    short groupSize \u003d sblk.getTotalBlockNum();\n\n    // find all duplicated indices\n    BitSet found \u003d new BitSet(groupSize); //indices found\n    BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n    HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n    for (DatanodeStorageInfo storage : nonExcess) {\n      int index \u003d sblk.getStorageBlockIndex(storage);\n      assert index \u003e\u003d 0;\n      if (found.get(index)) {\n        duplicated.set(index);\n      }\n      found.set(index);\n      storage2index.put(storage, index);\n    }\n\n    // use delHint only if delHint is duplicated\n    final DatanodeStorageInfo delStorageHint \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n    if (delStorageHint !\u003d null) {\n      Integer index \u003d storage2index.get(delStorageHint);\n      if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n        processChosenExcessRedundancy(nonExcess, delStorageHint, storedBlock);\n      }\n    }\n\n    // cardinality of found indicates the expected number of internal blocks\n    final int numOfTarget \u003d found.cardinality();\n    final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n        bc.getStoragePolicyID());\n    final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n        (short) numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n    if (excessTypes.isEmpty()) {\n      LOG.warn(\"excess types chosen for block {} among storages {} is empty\",\n          storedBlock, nonExcess);\n      return;\n    }\n\n    BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n    // for each duplicated index, delete some replicas until only one left\n    for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n         targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n      List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (DatanodeStorageInfo storage : nonExcess) {\n        int index \u003d storage2index.get(storage);\n        if (index \u003d\u003d targetIndex) {\n          candidates.add(storage);\n        }\n      }\n      if (candidates.size() \u003e 1) {\n        List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n            .chooseReplicasToDelete(nonExcess, candidates, (short) 1,\n                excessTypes, null, null);\n        for (DatanodeStorageInfo chosen : replicasToDelete) {\n          processChosenExcessRedundancy(nonExcess, chosen, storedBlock);\n          candidates.remove(chosen);\n        }\n      }\n      duplicated.clear(targetIndex);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "f2ba7da4f0df6cf0fc245093aeb4500158e6ee0b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9876. shouldProcessOverReplicated should not count number of pending replicas. Contributed by Jing Zhao.\n",
      "commitDate": "01/03/16 6:41 PM",
      "commitName": "f2ba7da4f0df6cf0fc245093aeb4500158e6ee0b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "28/02/16 2:54 PM",
      "commitNameOld": "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.16,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,67 @@\n   private void chooseExcessReplicasStriped(BlockCollection bc,\n       final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n       BlockInfo storedBlock,\n       DatanodeDescriptor delNodeHint) {\n     assert storedBlock instanceof BlockInfoStriped;\n     BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n     short groupSize \u003d sblk.getTotalBlockNum();\n-    BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n \n     // find all duplicated indices\n     BitSet found \u003d new BitSet(groupSize); //indices found\n     BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n     HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n     for (DatanodeStorageInfo storage : nonExcess) {\n       int index \u003d sblk.getStorageBlockIndex(storage);\n       assert index \u003e\u003d 0;\n       if (found.get(index)) {\n         duplicated.set(index);\n       }\n       found.set(index);\n       storage2index.put(storage, index);\n     }\n-    // the number of target left replicas equals to the of number of the found\n-    // indices.\n-    int numOfTarget \u003d found.cardinality();\n-\n-    final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n-        bc.getStoragePolicyID());\n-    final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n-        (short)numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n \n     // use delHint only if delHint is duplicated\n     final DatanodeStorageInfo delStorageHint \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n     if (delStorageHint !\u003d null) {\n       Integer index \u003d storage2index.get(delStorageHint);\n       if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n         processChosenExcessReplica(nonExcess, delStorageHint, storedBlock);\n       }\n     }\n \n+    // cardinality of found indicates the expected number of internal blocks\n+    final int numOfTarget \u003d found.cardinality();\n+    final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n+        bc.getStoragePolicyID());\n+    final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n+        (short) numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n+    if (excessTypes.isEmpty()) {\n+      LOG.warn(\"excess types chosen for block {} among storages {} is empty\",\n+          storedBlock, nonExcess);\n+      return;\n+    }\n+\n+    BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n     // for each duplicated index, delete some replicas until only one left\n     for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n          targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n       List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (DatanodeStorageInfo storage : nonExcess) {\n         int index \u003d storage2index.get(storage);\n         if (index \u003d\u003d targetIndex) {\n           candidates.add(storage);\n         }\n       }\n-      Block internalBlock \u003d new Block(storedBlock);\n-      internalBlock.setBlockId(storedBlock.getBlockId() + targetIndex);\n-      while (candidates.size() \u003e 1) {\n+      if (candidates.size() \u003e 1) {\n         List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n             .chooseReplicasToDelete(nonExcess, candidates, (short) 1,\n                 excessTypes, null, null);\n         for (DatanodeStorageInfo chosen : replicasToDelete) {\n           processChosenExcessReplica(nonExcess, chosen, storedBlock);\n           candidates.remove(chosen);\n         }\n       }\n       duplicated.clear(targetIndex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void chooseExcessReplicasStriped(BlockCollection bc,\n      final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n      BlockInfo storedBlock,\n      DatanodeDescriptor delNodeHint) {\n    assert storedBlock instanceof BlockInfoStriped;\n    BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n    short groupSize \u003d sblk.getTotalBlockNum();\n\n    // find all duplicated indices\n    BitSet found \u003d new BitSet(groupSize); //indices found\n    BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n    HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n    for (DatanodeStorageInfo storage : nonExcess) {\n      int index \u003d sblk.getStorageBlockIndex(storage);\n      assert index \u003e\u003d 0;\n      if (found.get(index)) {\n        duplicated.set(index);\n      }\n      found.set(index);\n      storage2index.put(storage, index);\n    }\n\n    // use delHint only if delHint is duplicated\n    final DatanodeStorageInfo delStorageHint \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n    if (delStorageHint !\u003d null) {\n      Integer index \u003d storage2index.get(delStorageHint);\n      if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n        processChosenExcessReplica(nonExcess, delStorageHint, storedBlock);\n      }\n    }\n\n    // cardinality of found indicates the expected number of internal blocks\n    final int numOfTarget \u003d found.cardinality();\n    final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n        bc.getStoragePolicyID());\n    final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n        (short) numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n    if (excessTypes.isEmpty()) {\n      LOG.warn(\"excess types chosen for block {} among storages {} is empty\",\n          storedBlock, nonExcess);\n      return;\n    }\n\n    BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n    // for each duplicated index, delete some replicas until only one left\n    for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n         targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n      List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (DatanodeStorageInfo storage : nonExcess) {\n        int index \u003d storage2index.get(storage);\n        if (index \u003d\u003d targetIndex) {\n          candidates.add(storage);\n        }\n      }\n      if (candidates.size() \u003e 1) {\n        List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n            .chooseReplicasToDelete(nonExcess, candidates, (short) 1,\n                excessTypes, null, null);\n        for (DatanodeStorageInfo chosen : replicasToDelete) {\n          processChosenExcessReplica(nonExcess, chosen, storedBlock);\n          candidates.remove(chosen);\n        }\n      }\n      duplicated.clear(targetIndex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9866. BlockManager#chooseExcessReplicasStriped may weaken rack fault tolerance. Contributed by Jing Zhao.\n",
      "commitDate": "28/02/16 2:54 PM",
      "commitName": "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "24/02/16 7:42 PM",
      "commitNameOld": "6979cbfc1f4c28440816b56f5624765872b0be49",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 3.8,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   private void chooseExcessReplicasStriped(BlockCollection bc,\n       final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n       BlockInfo storedBlock,\n       DatanodeDescriptor delNodeHint) {\n     assert storedBlock instanceof BlockInfoStriped;\n     BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n     short groupSize \u003d sblk.getTotalBlockNum();\n     BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n \n     // find all duplicated indices\n     BitSet found \u003d new BitSet(groupSize); //indices found\n     BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n     HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n     for (DatanodeStorageInfo storage : nonExcess) {\n       int index \u003d sblk.getStorageBlockIndex(storage);\n       assert index \u003e\u003d 0;\n       if (found.get(index)) {\n         duplicated.set(index);\n       }\n       found.set(index);\n       storage2index.put(storage, index);\n     }\n     // the number of target left replicas equals to the of number of the found\n     // indices.\n     int numOfTarget \u003d found.cardinality();\n \n     final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n         bc.getStoragePolicyID());\n     final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n         (short)numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n \n     // use delHint only if delHint is duplicated\n     final DatanodeStorageInfo delStorageHint \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n     if (delStorageHint !\u003d null) {\n       Integer index \u003d storage2index.get(delStorageHint);\n       if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n         processChosenExcessReplica(nonExcess, delStorageHint, storedBlock);\n       }\n     }\n \n     // for each duplicated index, delete some replicas until only one left\n     for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n          targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n       List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (DatanodeStorageInfo storage : nonExcess) {\n         int index \u003d storage2index.get(storage);\n         if (index \u003d\u003d targetIndex) {\n           candidates.add(storage);\n         }\n       }\n       Block internalBlock \u003d new Block(storedBlock);\n       internalBlock.setBlockId(storedBlock.getBlockId() + targetIndex);\n       while (candidates.size() \u003e 1) {\n         List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n-            .chooseReplicasToDelete(candidates, (short) 1, excessTypes, null,\n-                null);\n+            .chooseReplicasToDelete(nonExcess, candidates, (short) 1,\n+                excessTypes, null, null);\n         for (DatanodeStorageInfo chosen : replicasToDelete) {\n           processChosenExcessReplica(nonExcess, chosen, storedBlock);\n           candidates.remove(chosen);\n         }\n       }\n       duplicated.clear(targetIndex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void chooseExcessReplicasStriped(BlockCollection bc,\n      final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n      BlockInfo storedBlock,\n      DatanodeDescriptor delNodeHint) {\n    assert storedBlock instanceof BlockInfoStriped;\n    BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n    short groupSize \u003d sblk.getTotalBlockNum();\n    BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n\n    // find all duplicated indices\n    BitSet found \u003d new BitSet(groupSize); //indices found\n    BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n    HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n    for (DatanodeStorageInfo storage : nonExcess) {\n      int index \u003d sblk.getStorageBlockIndex(storage);\n      assert index \u003e\u003d 0;\n      if (found.get(index)) {\n        duplicated.set(index);\n      }\n      found.set(index);\n      storage2index.put(storage, index);\n    }\n    // the number of target left replicas equals to the of number of the found\n    // indices.\n    int numOfTarget \u003d found.cardinality();\n\n    final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n        bc.getStoragePolicyID());\n    final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n        (short)numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n\n    // use delHint only if delHint is duplicated\n    final DatanodeStorageInfo delStorageHint \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n    if (delStorageHint !\u003d null) {\n      Integer index \u003d storage2index.get(delStorageHint);\n      if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n        processChosenExcessReplica(nonExcess, delStorageHint, storedBlock);\n      }\n    }\n\n    // for each duplicated index, delete some replicas until only one left\n    for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n         targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n      List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (DatanodeStorageInfo storage : nonExcess) {\n        int index \u003d storage2index.get(storage);\n        if (index \u003d\u003d targetIndex) {\n          candidates.add(storage);\n        }\n      }\n      Block internalBlock \u003d new Block(storedBlock);\n      internalBlock.setBlockId(storedBlock.getBlockId() + targetIndex);\n      while (candidates.size() \u003e 1) {\n        List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n            .chooseReplicasToDelete(nonExcess, candidates, (short) 1,\n                excessTypes, null, null);\n        for (DatanodeStorageInfo chosen : replicasToDelete) {\n          processChosenExcessReplica(nonExcess, chosen, storedBlock);\n          candidates.remove(chosen);\n        }\n      }\n      duplicated.clear(targetIndex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8647. Abstract BlockManager\u0027s rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)\n",
      "commitDate": "21/10/15 8:06 AM",
      "commitName": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "15/10/15 3:07 AM",
      "commitNameOld": "5411dc559d5f73e4153e76fdff94a26869c17a37",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 6.21,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,65 @@\n   private void chooseExcessReplicasStriped(BlockCollection bc,\n       final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n       BlockInfo storedBlock,\n       DatanodeDescriptor delNodeHint) {\n     assert storedBlock instanceof BlockInfoStriped;\n     BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n     short groupSize \u003d sblk.getTotalBlockNum();\n     BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n-    List\u003cDatanodeStorageInfo\u003e empty \u003d new ArrayList\u003c\u003e(0);\n \n     // find all duplicated indices\n     BitSet found \u003d new BitSet(groupSize); //indices found\n     BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n     HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n     for (DatanodeStorageInfo storage : nonExcess) {\n       int index \u003d sblk.getStorageBlockIndex(storage);\n       assert index \u003e\u003d 0;\n       if (found.get(index)) {\n         duplicated.set(index);\n       }\n       found.set(index);\n       storage2index.put(storage, index);\n     }\n     // the number of target left replicas equals to the of number of the found\n     // indices.\n     int numOfTarget \u003d found.cardinality();\n \n     final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n         bc.getStoragePolicyID());\n     final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n         (short)numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n \n     // use delHint only if delHint is duplicated\n     final DatanodeStorageInfo delStorageHint \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n     if (delStorageHint !\u003d null) {\n       Integer index \u003d storage2index.get(delStorageHint);\n       if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n         processChosenExcessReplica(nonExcess, delStorageHint, storedBlock);\n       }\n     }\n \n     // for each duplicated index, delete some replicas until only one left\n     for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n          targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n       List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (DatanodeStorageInfo storage : nonExcess) {\n         int index \u003d storage2index.get(storage);\n         if (index \u003d\u003d targetIndex) {\n           candidates.add(storage);\n         }\n       }\n       Block internalBlock \u003d new Block(storedBlock);\n       internalBlock.setBlockId(storedBlock.getBlockId() + targetIndex);\n       while (candidates.size() \u003e 1) {\n-        DatanodeStorageInfo target \u003d placementPolicy.chooseReplicaToDelete(bc,\n-            internalBlock, (short)1, candidates, empty, excessTypes);\n-        processChosenExcessReplica(nonExcess, target, storedBlock);\n-        candidates.remove(target);\n+        List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n+            .chooseReplicasToDelete(candidates, (short) 1, excessTypes, null,\n+                null);\n+        for (DatanodeStorageInfo chosen : replicasToDelete) {\n+          processChosenExcessReplica(nonExcess, chosen, storedBlock);\n+          candidates.remove(chosen);\n+        }\n       }\n       duplicated.clear(targetIndex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void chooseExcessReplicasStriped(BlockCollection bc,\n      final Collection\u003cDatanodeStorageInfo\u003e nonExcess,\n      BlockInfo storedBlock,\n      DatanodeDescriptor delNodeHint) {\n    assert storedBlock instanceof BlockInfoStriped;\n    BlockInfoStriped sblk \u003d (BlockInfoStriped) storedBlock;\n    short groupSize \u003d sblk.getTotalBlockNum();\n    BlockPlacementPolicy placementPolicy \u003d placementPolicies.getPolicy(true);\n\n    // find all duplicated indices\n    BitSet found \u003d new BitSet(groupSize); //indices found\n    BitSet duplicated \u003d new BitSet(groupSize); //indices found more than once\n    HashMap\u003cDatanodeStorageInfo, Integer\u003e storage2index \u003d new HashMap\u003c\u003e();\n    for (DatanodeStorageInfo storage : nonExcess) {\n      int index \u003d sblk.getStorageBlockIndex(storage);\n      assert index \u003e\u003d 0;\n      if (found.get(index)) {\n        duplicated.set(index);\n      }\n      found.set(index);\n      storage2index.put(storage, index);\n    }\n    // the number of target left replicas equals to the of number of the found\n    // indices.\n    int numOfTarget \u003d found.cardinality();\n\n    final BlockStoragePolicy storagePolicy \u003d storagePolicySuite.getPolicy(\n        bc.getStoragePolicyID());\n    final List\u003cStorageType\u003e excessTypes \u003d storagePolicy.chooseExcess(\n        (short)numOfTarget, DatanodeStorageInfo.toStorageTypes(nonExcess));\n\n    // use delHint only if delHint is duplicated\n    final DatanodeStorageInfo delStorageHint \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(nonExcess, delNodeHint);\n    if (delStorageHint !\u003d null) {\n      Integer index \u003d storage2index.get(delStorageHint);\n      if (index !\u003d null \u0026\u0026 duplicated.get(index)) {\n        processChosenExcessReplica(nonExcess, delStorageHint, storedBlock);\n      }\n    }\n\n    // for each duplicated index, delete some replicas until only one left\n    for (int targetIndex \u003d duplicated.nextSetBit(0); targetIndex \u003e\u003d 0;\n         targetIndex \u003d duplicated.nextSetBit(targetIndex + 1)) {\n      List\u003cDatanodeStorageInfo\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (DatanodeStorageInfo storage : nonExcess) {\n        int index \u003d storage2index.get(storage);\n        if (index \u003d\u003d targetIndex) {\n          candidates.add(storage);\n        }\n      }\n      Block internalBlock \u003d new Block(storedBlock);\n      internalBlock.setBlockId(storedBlock.getBlockId() + targetIndex);\n      while (candidates.size() \u003e 1) {\n        List\u003cDatanodeStorageInfo\u003e replicasToDelete \u003d placementPolicy\n            .chooseReplicasToDelete(candidates, (short) 1, excessTypes, null,\n                null);\n        for (DatanodeStorageInfo chosen : replicasToDelete) {\n          processChosenExcessReplica(nonExcess, chosen, storedBlock);\n          candidates.remove(chosen);\n        }\n      }\n      duplicated.clear(targetIndex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    }
  }
}