{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DefaultSpeculator.java",
  "functionName": "maybeScheduleASpeculation",
  "functionId": "maybeScheduleASpeculation___type-TaskType",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java",
  "functionStartLine": 488,
  "functionEndLine": 553,
  "numCommitsSeen": 19,
  "timeTaken": 7216,
  "changeHistory": [
    "8acc5e9b4b3fea8b418b3526c15022c8a9fedd56",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "8acc5e9b4b3fea8b418b3526c15022c8a9fedd56": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8acc5e9b4b3fea8b418b3526c15022c8a9fedd56": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6143. add configuration for mapreduce speculative execution in MR2 (zxu via rkanter)\n",
      "commitDate": "02/02/15 1:51 PM",
      "commitName": "8acc5e9b4b3fea8b418b3526c15022c8a9fedd56",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "28/08/14 7:05 PM",
      "commitNameOld": "fef8554be80c01519870ad2969f6c9f3df4d6a7f",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 157.82,
      "commitsBetweenForRepo": 1288,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   private int maybeScheduleASpeculation(TaskType type) {\n     int successes \u003d 0;\n \n     long now \u003d clock.getTime();\n \n     ConcurrentMap\u003cJobId, AtomicInteger\u003e containerNeeds\n         \u003d type \u003d\u003d TaskType.MAP ? mapContainerNeeds : reduceContainerNeeds;\n \n     for (ConcurrentMap.Entry\u003cJobId, AtomicInteger\u003e jobEntry : containerNeeds.entrySet()) {\n       // This race conditon is okay.  If we skip a speculation attempt we\n       //  should have tried because the event that lowers the number of\n       //  containers needed to zero hasn\u0027t come through, it will next time.\n       // Also, if we miss the fact that the number of containers needed was\n       //  zero but increased due to a failure it\u0027s not too bad to launch one\n       //  container prematurely.\n       if (jobEntry.getValue().get() \u003e 0) {\n         continue;\n       }\n \n       int numberSpeculationsAlready \u003d 0;\n       int numberRunningTasks \u003d 0;\n \n       // loop through the tasks of the kind\n       Job job \u003d context.getJob(jobEntry.getKey());\n \n       Map\u003cTaskId, Task\u003e tasks \u003d job.getTasks(type);\n \n       int numberAllowedSpeculativeTasks\n-          \u003d (int) Math.max(MINIMUM_ALLOWED_SPECULATIVE_TASKS,\n-                           PROPORTION_TOTAL_TASKS_SPECULATABLE * tasks.size());\n+          \u003d (int) Math.max(minimumAllowedSpeculativeTasks,\n+              proportionTotalTasksSpeculatable * tasks.size());\n \n       TaskId bestTaskID \u003d null;\n       long bestSpeculationValue \u003d -1L;\n \n       // this loop is potentially pricey.\n       // TODO track the tasks that are potentially worth looking at\n       for (Map.Entry\u003cTaskId, Task\u003e taskEntry : tasks.entrySet()) {\n         long mySpeculationValue \u003d speculationValue(taskEntry.getKey(), now);\n \n         if (mySpeculationValue \u003d\u003d ALREADY_SPECULATING) {\n           ++numberSpeculationsAlready;\n         }\n \n         if (mySpeculationValue !\u003d NOT_RUNNING) {\n           ++numberRunningTasks;\n         }\n \n         if (mySpeculationValue \u003e bestSpeculationValue) {\n           bestTaskID \u003d taskEntry.getKey();\n           bestSpeculationValue \u003d mySpeculationValue;\n         }\n       }\n       numberAllowedSpeculativeTasks\n           \u003d (int) Math.max(numberAllowedSpeculativeTasks,\n-                           PROPORTION_RUNNING_TASKS_SPECULATABLE * numberRunningTasks);\n+              proportionRunningTasksSpeculatable * numberRunningTasks);\n \n       // If we found a speculation target, fire it off\n       if (bestTaskID !\u003d null\n           \u0026\u0026 numberAllowedSpeculativeTasks \u003e numberSpeculationsAlready) {\n         addSpeculativeAttempt(bestTaskID);\n         ++successes;\n       }\n     }\n \n     return successes;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int maybeScheduleASpeculation(TaskType type) {\n    int successes \u003d 0;\n\n    long now \u003d clock.getTime();\n\n    ConcurrentMap\u003cJobId, AtomicInteger\u003e containerNeeds\n        \u003d type \u003d\u003d TaskType.MAP ? mapContainerNeeds : reduceContainerNeeds;\n\n    for (ConcurrentMap.Entry\u003cJobId, AtomicInteger\u003e jobEntry : containerNeeds.entrySet()) {\n      // This race conditon is okay.  If we skip a speculation attempt we\n      //  should have tried because the event that lowers the number of\n      //  containers needed to zero hasn\u0027t come through, it will next time.\n      // Also, if we miss the fact that the number of containers needed was\n      //  zero but increased due to a failure it\u0027s not too bad to launch one\n      //  container prematurely.\n      if (jobEntry.getValue().get() \u003e 0) {\n        continue;\n      }\n\n      int numberSpeculationsAlready \u003d 0;\n      int numberRunningTasks \u003d 0;\n\n      // loop through the tasks of the kind\n      Job job \u003d context.getJob(jobEntry.getKey());\n\n      Map\u003cTaskId, Task\u003e tasks \u003d job.getTasks(type);\n\n      int numberAllowedSpeculativeTasks\n          \u003d (int) Math.max(minimumAllowedSpeculativeTasks,\n              proportionTotalTasksSpeculatable * tasks.size());\n\n      TaskId bestTaskID \u003d null;\n      long bestSpeculationValue \u003d -1L;\n\n      // this loop is potentially pricey.\n      // TODO track the tasks that are potentially worth looking at\n      for (Map.Entry\u003cTaskId, Task\u003e taskEntry : tasks.entrySet()) {\n        long mySpeculationValue \u003d speculationValue(taskEntry.getKey(), now);\n\n        if (mySpeculationValue \u003d\u003d ALREADY_SPECULATING) {\n          ++numberSpeculationsAlready;\n        }\n\n        if (mySpeculationValue !\u003d NOT_RUNNING) {\n          ++numberRunningTasks;\n        }\n\n        if (mySpeculationValue \u003e bestSpeculationValue) {\n          bestTaskID \u003d taskEntry.getKey();\n          bestSpeculationValue \u003d mySpeculationValue;\n        }\n      }\n      numberAllowedSpeculativeTasks\n          \u003d (int) Math.max(numberAllowedSpeculativeTasks,\n              proportionRunningTasksSpeculatable * numberRunningTasks);\n\n      // If we found a speculation target, fire it off\n      if (bestTaskID !\u003d null\n          \u0026\u0026 numberAllowedSpeculativeTasks \u003e numberSpeculationsAlready) {\n        addSpeculativeAttempt(bestTaskID);\n        ++successes;\n      }\n    }\n\n    return successes;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private int maybeScheduleASpeculation(TaskType type) {\n    int successes \u003d 0;\n\n    long now \u003d clock.getTime();\n\n    ConcurrentMap\u003cJobId, AtomicInteger\u003e containerNeeds\n        \u003d type \u003d\u003d TaskType.MAP ? mapContainerNeeds : reduceContainerNeeds;\n\n    for (ConcurrentMap.Entry\u003cJobId, AtomicInteger\u003e jobEntry : containerNeeds.entrySet()) {\n      // This race conditon is okay.  If we skip a speculation attempt we\n      //  should have tried because the event that lowers the number of\n      //  containers needed to zero hasn\u0027t come through, it will next time.\n      // Also, if we miss the fact that the number of containers needed was\n      //  zero but increased due to a failure it\u0027s not too bad to launch one\n      //  container prematurely.\n      if (jobEntry.getValue().get() \u003e 0) {\n        continue;\n      }\n\n      int numberSpeculationsAlready \u003d 0;\n      int numberRunningTasks \u003d 0;\n\n      // loop through the tasks of the kind\n      Job job \u003d context.getJob(jobEntry.getKey());\n\n      Map\u003cTaskId, Task\u003e tasks \u003d job.getTasks(type);\n\n      int numberAllowedSpeculativeTasks\n          \u003d (int) Math.max(MINIMUM_ALLOWED_SPECULATIVE_TASKS,\n                           PROPORTION_TOTAL_TASKS_SPECULATABLE * tasks.size());\n\n      TaskId bestTaskID \u003d null;\n      long bestSpeculationValue \u003d -1L;\n\n      // this loop is potentially pricey.\n      // TODO track the tasks that are potentially worth looking at\n      for (Map.Entry\u003cTaskId, Task\u003e taskEntry : tasks.entrySet()) {\n        long mySpeculationValue \u003d speculationValue(taskEntry.getKey(), now);\n\n        if (mySpeculationValue \u003d\u003d ALREADY_SPECULATING) {\n          ++numberSpeculationsAlready;\n        }\n\n        if (mySpeculationValue !\u003d NOT_RUNNING) {\n          ++numberRunningTasks;\n        }\n\n        if (mySpeculationValue \u003e bestSpeculationValue) {\n          bestTaskID \u003d taskEntry.getKey();\n          bestSpeculationValue \u003d mySpeculationValue;\n        }\n      }\n      numberAllowedSpeculativeTasks\n          \u003d (int) Math.max(numberAllowedSpeculativeTasks,\n                           PROPORTION_RUNNING_TASKS_SPECULATABLE * numberRunningTasks);\n\n      // If we found a speculation target, fire it off\n      if (bestTaskID !\u003d null\n          \u0026\u0026 numberAllowedSpeculativeTasks \u003e numberSpeculationsAlready) {\n        addSpeculativeAttempt(bestTaskID);\n        ++successes;\n      }\n    }\n\n    return successes;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,66 @@\n+  private int maybeScheduleASpeculation(TaskType type) {\n+    int successes \u003d 0;\n+\n+    long now \u003d clock.getTime();\n+\n+    ConcurrentMap\u003cJobId, AtomicInteger\u003e containerNeeds\n+        \u003d type \u003d\u003d TaskType.MAP ? mapContainerNeeds : reduceContainerNeeds;\n+\n+    for (ConcurrentMap.Entry\u003cJobId, AtomicInteger\u003e jobEntry : containerNeeds.entrySet()) {\n+      // This race conditon is okay.  If we skip a speculation attempt we\n+      //  should have tried because the event that lowers the number of\n+      //  containers needed to zero hasn\u0027t come through, it will next time.\n+      // Also, if we miss the fact that the number of containers needed was\n+      //  zero but increased due to a failure it\u0027s not too bad to launch one\n+      //  container prematurely.\n+      if (jobEntry.getValue().get() \u003e 0) {\n+        continue;\n+      }\n+\n+      int numberSpeculationsAlready \u003d 0;\n+      int numberRunningTasks \u003d 0;\n+\n+      // loop through the tasks of the kind\n+      Job job \u003d context.getJob(jobEntry.getKey());\n+\n+      Map\u003cTaskId, Task\u003e tasks \u003d job.getTasks(type);\n+\n+      int numberAllowedSpeculativeTasks\n+          \u003d (int) Math.max(MINIMUM_ALLOWED_SPECULATIVE_TASKS,\n+                           PROPORTION_TOTAL_TASKS_SPECULATABLE * tasks.size());\n+\n+      TaskId bestTaskID \u003d null;\n+      long bestSpeculationValue \u003d -1L;\n+\n+      // this loop is potentially pricey.\n+      // TODO track the tasks that are potentially worth looking at\n+      for (Map.Entry\u003cTaskId, Task\u003e taskEntry : tasks.entrySet()) {\n+        long mySpeculationValue \u003d speculationValue(taskEntry.getKey(), now);\n+\n+        if (mySpeculationValue \u003d\u003d ALREADY_SPECULATING) {\n+          ++numberSpeculationsAlready;\n+        }\n+\n+        if (mySpeculationValue !\u003d NOT_RUNNING) {\n+          ++numberRunningTasks;\n+        }\n+\n+        if (mySpeculationValue \u003e bestSpeculationValue) {\n+          bestTaskID \u003d taskEntry.getKey();\n+          bestSpeculationValue \u003d mySpeculationValue;\n+        }\n+      }\n+      numberAllowedSpeculativeTasks\n+          \u003d (int) Math.max(numberAllowedSpeculativeTasks,\n+                           PROPORTION_RUNNING_TASKS_SPECULATABLE * numberRunningTasks);\n+\n+      // If we found a speculation target, fire it off\n+      if (bestTaskID !\u003d null\n+          \u0026\u0026 numberAllowedSpeculativeTasks \u003e numberSpeculationsAlready) {\n+        addSpeculativeAttempt(bestTaskID);\n+        ++successes;\n+      }\n+    }\n+\n+    return successes;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int maybeScheduleASpeculation(TaskType type) {\n    int successes \u003d 0;\n\n    long now \u003d clock.getTime();\n\n    ConcurrentMap\u003cJobId, AtomicInteger\u003e containerNeeds\n        \u003d type \u003d\u003d TaskType.MAP ? mapContainerNeeds : reduceContainerNeeds;\n\n    for (ConcurrentMap.Entry\u003cJobId, AtomicInteger\u003e jobEntry : containerNeeds.entrySet()) {\n      // This race conditon is okay.  If we skip a speculation attempt we\n      //  should have tried because the event that lowers the number of\n      //  containers needed to zero hasn\u0027t come through, it will next time.\n      // Also, if we miss the fact that the number of containers needed was\n      //  zero but increased due to a failure it\u0027s not too bad to launch one\n      //  container prematurely.\n      if (jobEntry.getValue().get() \u003e 0) {\n        continue;\n      }\n\n      int numberSpeculationsAlready \u003d 0;\n      int numberRunningTasks \u003d 0;\n\n      // loop through the tasks of the kind\n      Job job \u003d context.getJob(jobEntry.getKey());\n\n      Map\u003cTaskId, Task\u003e tasks \u003d job.getTasks(type);\n\n      int numberAllowedSpeculativeTasks\n          \u003d (int) Math.max(MINIMUM_ALLOWED_SPECULATIVE_TASKS,\n                           PROPORTION_TOTAL_TASKS_SPECULATABLE * tasks.size());\n\n      TaskId bestTaskID \u003d null;\n      long bestSpeculationValue \u003d -1L;\n\n      // this loop is potentially pricey.\n      // TODO track the tasks that are potentially worth looking at\n      for (Map.Entry\u003cTaskId, Task\u003e taskEntry : tasks.entrySet()) {\n        long mySpeculationValue \u003d speculationValue(taskEntry.getKey(), now);\n\n        if (mySpeculationValue \u003d\u003d ALREADY_SPECULATING) {\n          ++numberSpeculationsAlready;\n        }\n\n        if (mySpeculationValue !\u003d NOT_RUNNING) {\n          ++numberRunningTasks;\n        }\n\n        if (mySpeculationValue \u003e bestSpeculationValue) {\n          bestTaskID \u003d taskEntry.getKey();\n          bestSpeculationValue \u003d mySpeculationValue;\n        }\n      }\n      numberAllowedSpeculativeTasks\n          \u003d (int) Math.max(numberAllowedSpeculativeTasks,\n                           PROPORTION_RUNNING_TASKS_SPECULATABLE * numberRunningTasks);\n\n      // If we found a speculation target, fire it off\n      if (bestTaskID !\u003d null\n          \u0026\u0026 numberAllowedSpeculativeTasks \u003e numberSpeculationsAlready) {\n        addSpeculativeAttempt(bestTaskID);\n        ++successes;\n      }\n    }\n\n    return successes;\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/speculate/DefaultSpeculator.java"
    }
  }
}