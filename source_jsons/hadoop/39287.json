{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacityScheduler.java",
  "functionName": "nodeUpdate",
  "functionId": "nodeUpdate___rmNode-RMNode",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
  "functionStartLine": 1328,
  "functionEndLine": 1355,
  "numCommitsSeen": 403,
  "timeTaken": 20107,
  "changeHistory": [
    "fc05b0e70e9bb556d6bdc00fa8735e18a6f90bc9",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "f24c842d52e166e8566337ef93c96438f1c870d8",
    "f69a107aeccc68ca1085a7be8093d36b2f45eaa1",
    "ab1faa4ba80702fb04e28ffb23a4b3bb6e64ee16",
    "e0f2379312c48e26b0cb2c1e1e803ef71d1839cf",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c",
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
    "f9692770a58af0ab082eb7f15da9cbdcd177605b",
    "9ed17f181d96b8719a0ef54a129081948781d57e",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff",
    "adf260a728df427eb729abe8fb9ad7248991ea54",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
    "52948bb20bd1446164df1d3920c46c96dad750ae",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434",
    "4bc42d76e7fa53cb268cab0f9fe1fd8d8dbb17fd",
    "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
    "5c14bc426b4be381383018ebc2236be83eef15cd",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b",
    "57cdf8626a32b8595a645b7551f46ab950db4789",
    "1393581bceda234c88cafec00dbfc0ef2a402e83",
    "6990355e577ad19371cb656c250fb665ed14062f",
    "5b99672658ce24bfd1002b880583cbecfa47f9b3",
    "7ea82ca558c2e2fbb50277ee6ac7debdf9e94b69",
    "106e2e27ffb81f816ae627fa1712f5db5fb36002",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "7ed0f74997ad8af0aaea7a2e54d6c1e3abbee33d",
    "f24dcb3449c77da665058427bc7fa480cad507fc",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "fc05b0e70e9bb556d6bdc00fa8735e18a6f90bc9": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "f24c842d52e166e8566337ef93c96438f1c870d8": "Ybodychange",
    "f69a107aeccc68ca1085a7be8093d36b2f45eaa1": "Ymodifierchange",
    "ab1faa4ba80702fb04e28ffb23a4b3bb6e64ee16": "Ymodifierchange",
    "e0f2379312c48e26b0cb2c1e1e803ef71d1839cf": "Ymodifierchange",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Ymultichange(Yparameterchange,Ybodychange)",
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335": "Ymultichange(Ymodifierchange,Ybodychange)",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ymultichange(Ymodifierchange,Ybodychange)",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": "Ybodychange",
    "f9692770a58af0ab082eb7f15da9cbdcd177605b": "Ybodychange",
    "9ed17f181d96b8719a0ef54a129081948781d57e": "Ybodychange",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": "Ybodychange",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": "Ybodychange",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": "Ybodychange",
    "adf260a728df427eb729abe8fb9ad7248991ea54": "Ybodychange",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": "Ybodychange",
    "52948bb20bd1446164df1d3920c46c96dad750ae": "Ybodychange",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": "Ybodychange",
    "4bc42d76e7fa53cb268cab0f9fe1fd8d8dbb17fd": "Ybodychange",
    "afa5d4715a3aea2a6e93380b014c7bb8f0880383": "Ybodychange",
    "5c14bc426b4be381383018ebc2236be83eef15cd": "Ybodychange",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": "Ybodychange",
    "57cdf8626a32b8595a645b7551f46ab950db4789": "Ybodychange",
    "1393581bceda234c88cafec00dbfc0ef2a402e83": "Ybodychange",
    "6990355e577ad19371cb656c250fb665ed14062f": "Ybodychange",
    "5b99672658ce24bfd1002b880583cbecfa47f9b3": "Ybodychange",
    "7ea82ca558c2e2fbb50277ee6ac7debdf9e94b69": "Ymultichange(Yparameterchange,Ybodychange)",
    "106e2e27ffb81f816ae627fa1712f5db5fb36002": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Ybodychange",
    "7ed0f74997ad8af0aaea7a2e54d6c1e3abbee33d": "Ybodychange",
    "f24dcb3449c77da665058427bc7fa480cad507fc": "Ybodychange",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": "Ybodychange",
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0": "Ymultichange(Yparameterchange,Ybodychange)",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fc05b0e70e9bb556d6bdc00fa8735e18a6f90bc9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9313. Support asynchronized scheduling mode and multi-node lookup mechanism for scheduler activities. Contributed by Tao Yang.\n",
      "commitDate": "07/04/19 10:40 PM",
      "commitName": "fc05b0e70e9bb556d6bdc00fa8735e18a6f90bc9",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "18/03/19 10:57 AM",
      "commitNameOld": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 20.49,
      "commitsBetweenForRepo": 151,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,28 @@\n   protected void nodeUpdate(RMNode rmNode) {\n     long begin \u003d System.nanoTime();\n     readLock.lock();\n     try {\n       setLastNodeUpdateTime(Time.now());\n       super.nodeUpdate(rmNode);\n     } finally {\n       readLock.unlock();\n     }\n \n     // Try to do scheduling\n     if (!scheduleAsynchronously) {\n       writeLock.lock();\n       try {\n-        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n-            rmNode.getNodeID());\n-\n         // reset allocation and reservation stats before we start doing any\n         // work\n         updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n             CSAssignment.NULL_ASSIGNMENT);\n \n         allocateContainersToNode(rmNode.getNodeID(), true);\n-        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n-            rmNode.getNodeID());\n       } finally {\n         writeLock.unlock();\n       }\n     }\n \n     long latency \u003d System.nanoTime() - begin;\n     CapacitySchedulerMetrics.getMetrics().addNodeUpdate(latency);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void nodeUpdate(RMNode rmNode) {\n    long begin \u003d System.nanoTime();\n    readLock.lock();\n    try {\n      setLastNodeUpdateTime(Time.now());\n      super.nodeUpdate(rmNode);\n    } finally {\n      readLock.unlock();\n    }\n\n    // Try to do scheduling\n    if (!scheduleAsynchronously) {\n      writeLock.lock();\n      try {\n        // reset allocation and reservation stats before we start doing any\n        // work\n        updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n            CSAssignment.NULL_ASSIGNMENT);\n\n        allocateContainersToNode(rmNode.getNodeID(), true);\n      } finally {\n        writeLock.unlock();\n      }\n    }\n\n    long latency \u003d System.nanoTime() - begin;\n    CapacitySchedulerMetrics.getMetrics().addNodeUpdate(latency);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   protected void nodeUpdate(RMNode rmNode) {\n     long begin \u003d System.nanoTime();\n+    readLock.lock();\n     try {\n-      readLock.lock();\n       setLastNodeUpdateTime(Time.now());\n       super.nodeUpdate(rmNode);\n     } finally {\n       readLock.unlock();\n     }\n \n     // Try to do scheduling\n     if (!scheduleAsynchronously) {\n+      writeLock.lock();\n       try {\n-        writeLock.lock();\n         ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n             rmNode.getNodeID());\n \n         // reset allocation and reservation stats before we start doing any\n         // work\n         updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n             CSAssignment.NULL_ASSIGNMENT);\n \n         allocateContainersToNode(rmNode.getNodeID(), true);\n         ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n             rmNode.getNodeID());\n       } finally {\n         writeLock.unlock();\n       }\n     }\n \n     long latency \u003d System.nanoTime() - begin;\n     CapacitySchedulerMetrics.getMetrics().addNodeUpdate(latency);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void nodeUpdate(RMNode rmNode) {\n    long begin \u003d System.nanoTime();\n    readLock.lock();\n    try {\n      setLastNodeUpdateTime(Time.now());\n      super.nodeUpdate(rmNode);\n    } finally {\n      readLock.unlock();\n    }\n\n    // Try to do scheduling\n    if (!scheduleAsynchronously) {\n      writeLock.lock();\n      try {\n        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n\n        // reset allocation and reservation stats before we start doing any\n        // work\n        updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n            CSAssignment.NULL_ASSIGNMENT);\n\n        allocateContainersToNode(rmNode.getNodeID(), true);\n        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n      } finally {\n        writeLock.unlock();\n      }\n    }\n\n    long latency \u003d System.nanoTime() - begin;\n    CapacitySchedulerMetrics.getMetrics().addNodeUpdate(latency);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "f24c842d52e166e8566337ef93c96438f1c870d8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8213. Add Capacity Scheduler performance metrics. (Weiwei Yang via wangda)\n\nChange-Id: Ieea6f3eeb83c90cd74233fea896f0fcd0f325d5f\n",
      "commitDate": "25/05/18 9:53 PM",
      "commitName": "f24c842d52e166e8566337ef93c96438f1c870d8",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "10/05/18 7:47 PM",
      "commitNameOld": "9db9cd95bd0348070a286e69e7965c03c9bd39d6",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 15.09,
      "commitsBetweenForRepo": 138,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,33 @@\n   protected void nodeUpdate(RMNode rmNode) {\n+    long begin \u003d System.nanoTime();\n     try {\n       readLock.lock();\n       setLastNodeUpdateTime(Time.now());\n       super.nodeUpdate(rmNode);\n     } finally {\n       readLock.unlock();\n     }\n \n     // Try to do scheduling\n     if (!scheduleAsynchronously) {\n       try {\n         writeLock.lock();\n         ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n             rmNode.getNodeID());\n \n         // reset allocation and reservation stats before we start doing any\n         // work\n         updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n             CSAssignment.NULL_ASSIGNMENT);\n \n         allocateContainersToNode(rmNode.getNodeID(), true);\n         ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n             rmNode.getNodeID());\n       } finally {\n         writeLock.unlock();\n       }\n     }\n+\n+    long latency \u003d System.nanoTime() - begin;\n+    CapacitySchedulerMetrics.getMetrics().addNodeUpdate(latency);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void nodeUpdate(RMNode rmNode) {\n    long begin \u003d System.nanoTime();\n    try {\n      readLock.lock();\n      setLastNodeUpdateTime(Time.now());\n      super.nodeUpdate(rmNode);\n    } finally {\n      readLock.unlock();\n    }\n\n    // Try to do scheduling\n    if (!scheduleAsynchronously) {\n      try {\n        writeLock.lock();\n        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n\n        // reset allocation and reservation stats before we start doing any\n        // work\n        updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n            CSAssignment.NULL_ASSIGNMENT);\n\n        allocateContainersToNode(rmNode.getNodeID(), true);\n        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n      } finally {\n        writeLock.unlock();\n      }\n    }\n\n    long latency \u003d System.nanoTime() - begin;\n    CapacitySchedulerMetrics.getMetrics().addNodeUpdate(latency);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "f69a107aeccc68ca1085a7be8093d36b2f45eaa1": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-6025. Fix synchronization issues of AbstractYarnScheduler#nodeUpdate and its implementations. (Naganarasimha G R via wangda)\n\n(cherry picked from commit e0f2379312c48e26b0cb2c1e1e803ef71d1839cf)\n",
      "commitDate": "03/01/17 2:53 PM",
      "commitName": "f69a107aeccc68ca1085a7be8093d36b2f45eaa1",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "03/01/17 2:53 PM",
      "commitNameOld": "ab1faa4ba80702fb04e28ffb23a4b3bb6e64ee16",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n-  protected synchronized void nodeUpdate(RMNode rmNode) {\n+  protected void nodeUpdate(RMNode rmNode) {\n     try {\n       readLock.lock();\n       setLastNodeUpdateTime(Time.now());\n       super.nodeUpdate(rmNode);\n     } finally {\n       readLock.unlock();\n     }\n \n     // Try to do scheduling\n     if (!scheduleAsynchronously) {\n       try {\n         writeLock.lock();\n         ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n             rmNode.getNodeID());\n \n         // reset allocation and reservation stats before we start doing any\n         // work\n         updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n             CSAssignment.NULL_ASSIGNMENT);\n \n         allocateContainersToNode(rmNode.getNodeID(), true);\n         ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n             rmNode.getNodeID());\n       } finally {\n         writeLock.unlock();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void nodeUpdate(RMNode rmNode) {\n    try {\n      readLock.lock();\n      setLastNodeUpdateTime(Time.now());\n      super.nodeUpdate(rmNode);\n    } finally {\n      readLock.unlock();\n    }\n\n    // Try to do scheduling\n    if (!scheduleAsynchronously) {\n      try {\n        writeLock.lock();\n        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n\n        // reset allocation and reservation stats before we start doing any\n        // work\n        updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n            CSAssignment.NULL_ASSIGNMENT);\n\n        allocateContainersToNode(rmNode.getNodeID(), true);\n        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n      } finally {\n        writeLock.unlock();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldValue": "[protected, synchronized]",
        "newValue": "[protected]"
      }
    },
    "ab1faa4ba80702fb04e28ffb23a4b3bb6e64ee16": {
      "type": "Ymodifierchange",
      "commitMessage": "Revert \"Fix synchronization issues of AbstractYarnScheduler#nodeUpdate and its implementations. (Naganarasimha G R via wangda)\" to add correct JIRA number\n\nThis reverts commit e0f2379312c48e26b0cb2c1e1e803ef71d1839cf.\n",
      "commitDate": "03/01/17 2:53 PM",
      "commitName": "ab1faa4ba80702fb04e28ffb23a4b3bb6e64ee16",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "03/01/17 2:46 PM",
      "commitNameOld": "e0f2379312c48e26b0cb2c1e1e803ef71d1839cf",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n-  protected void nodeUpdate(RMNode rmNode) {\n+  protected synchronized void nodeUpdate(RMNode rmNode) {\n     try {\n       readLock.lock();\n       setLastNodeUpdateTime(Time.now());\n       super.nodeUpdate(rmNode);\n     } finally {\n       readLock.unlock();\n     }\n \n     // Try to do scheduling\n     if (!scheduleAsynchronously) {\n       try {\n         writeLock.lock();\n         ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n             rmNode.getNodeID());\n \n         // reset allocation and reservation stats before we start doing any\n         // work\n         updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n             CSAssignment.NULL_ASSIGNMENT);\n \n         allocateContainersToNode(rmNode.getNodeID(), true);\n         ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n             rmNode.getNodeID());\n       } finally {\n         writeLock.unlock();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void nodeUpdate(RMNode rmNode) {\n    try {\n      readLock.lock();\n      setLastNodeUpdateTime(Time.now());\n      super.nodeUpdate(rmNode);\n    } finally {\n      readLock.unlock();\n    }\n\n    // Try to do scheduling\n    if (!scheduleAsynchronously) {\n      try {\n        writeLock.lock();\n        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n\n        // reset allocation and reservation stats before we start doing any\n        // work\n        updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n            CSAssignment.NULL_ASSIGNMENT);\n\n        allocateContainersToNode(rmNode.getNodeID(), true);\n        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n      } finally {\n        writeLock.unlock();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldValue": "[protected]",
        "newValue": "[protected, synchronized]"
      }
    },
    "e0f2379312c48e26b0cb2c1e1e803ef71d1839cf": {
      "type": "Ymodifierchange",
      "commitMessage": "Fix synchronization issues of AbstractYarnScheduler#nodeUpdate and its implementations. (Naganarasimha G R via wangda)\n",
      "commitDate": "03/01/17 2:46 PM",
      "commitName": "e0f2379312c48e26b0cb2c1e1e803ef71d1839cf",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/12/16 9:18 PM",
      "commitNameOld": "0840b4329b2428b20b862f70d72cbdcd6d1618ed",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 6.73,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n-  protected synchronized void nodeUpdate(RMNode rmNode) {\n+  protected void nodeUpdate(RMNode rmNode) {\n     try {\n       readLock.lock();\n       setLastNodeUpdateTime(Time.now());\n       super.nodeUpdate(rmNode);\n     } finally {\n       readLock.unlock();\n     }\n \n     // Try to do scheduling\n     if (!scheduleAsynchronously) {\n       try {\n         writeLock.lock();\n         ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n             rmNode.getNodeID());\n \n         // reset allocation and reservation stats before we start doing any\n         // work\n         updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n             CSAssignment.NULL_ASSIGNMENT);\n \n         allocateContainersToNode(rmNode.getNodeID(), true);\n         ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n             rmNode.getNodeID());\n       } finally {\n         writeLock.unlock();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void nodeUpdate(RMNode rmNode) {\n    try {\n      readLock.lock();\n      setLastNodeUpdateTime(Time.now());\n      super.nodeUpdate(rmNode);\n    } finally {\n      readLock.unlock();\n    }\n\n    // Try to do scheduling\n    if (!scheduleAsynchronously) {\n      try {\n        writeLock.lock();\n        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n\n        // reset allocation and reservation stats before we start doing any\n        // work\n        updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n            CSAssignment.NULL_ASSIGNMENT);\n\n        allocateContainersToNode(rmNode.getNodeID(), true);\n        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n      } finally {\n        writeLock.unlock();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldValue": "[protected, synchronized]",
        "newValue": "[protected]"
      }
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "01/11/16 3:02 AM",
          "commitNameOld": "7d2d8d25ba0cb10a3c6192d4123f27ede5ef2ba6",
          "commitAuthorOld": "Varun Saxena",
          "daysBetweenCommits": 6.34,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,29 @@\n-  protected synchronized void nodeUpdate(RMNode nm) {\n+  protected synchronized void nodeUpdate(RMNode rmNode) {\n     try {\n-      writeLock.lock();\n+      readLock.lock();\n       setLastNodeUpdateTime(Time.now());\n-      super.nodeUpdate(nm);\n-      if (!scheduleAsynchronously) {\n-        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n-            nm.getNodeID());\n-        allocateContainersToNode(getNode(nm.getNodeID()));\n-        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n-            nm.getNodeID());\n-      }\n+      super.nodeUpdate(rmNode);\n     } finally {\n-      writeLock.unlock();\n+      readLock.unlock();\n+    }\n+\n+    // Try to do scheduling\n+    if (!scheduleAsynchronously) {\n+      try {\n+        writeLock.lock();\n+        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n+            rmNode.getNodeID());\n+\n+        // reset allocation and reservation stats before we start doing any\n+        // work\n+        updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n+            CSAssignment.NULL_ASSIGNMENT);\n+\n+        allocateContainersToNode(rmNode.getNodeID(), true);\n+        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n+            rmNode.getNodeID());\n+      } finally {\n+        writeLock.unlock();\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void nodeUpdate(RMNode rmNode) {\n    try {\n      readLock.lock();\n      setLastNodeUpdateTime(Time.now());\n      super.nodeUpdate(rmNode);\n    } finally {\n      readLock.unlock();\n    }\n\n    // Try to do scheduling\n    if (!scheduleAsynchronously) {\n      try {\n        writeLock.lock();\n        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n\n        // reset allocation and reservation stats before we start doing any\n        // work\n        updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n            CSAssignment.NULL_ASSIGNMENT);\n\n        allocateContainersToNode(rmNode.getNodeID(), true);\n        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n      } finally {\n        writeLock.unlock();\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[nm-RMNode]",
            "newValue": "[rmNode-RMNode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "01/11/16 3:02 AM",
          "commitNameOld": "7d2d8d25ba0cb10a3c6192d4123f27ede5ef2ba6",
          "commitAuthorOld": "Varun Saxena",
          "daysBetweenCommits": 6.34,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,29 @@\n-  protected synchronized void nodeUpdate(RMNode nm) {\n+  protected synchronized void nodeUpdate(RMNode rmNode) {\n     try {\n-      writeLock.lock();\n+      readLock.lock();\n       setLastNodeUpdateTime(Time.now());\n-      super.nodeUpdate(nm);\n-      if (!scheduleAsynchronously) {\n-        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n-            nm.getNodeID());\n-        allocateContainersToNode(getNode(nm.getNodeID()));\n-        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n-            nm.getNodeID());\n-      }\n+      super.nodeUpdate(rmNode);\n     } finally {\n-      writeLock.unlock();\n+      readLock.unlock();\n+    }\n+\n+    // Try to do scheduling\n+    if (!scheduleAsynchronously) {\n+      try {\n+        writeLock.lock();\n+        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n+            rmNode.getNodeID());\n+\n+        // reset allocation and reservation stats before we start doing any\n+        // work\n+        updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n+            CSAssignment.NULL_ASSIGNMENT);\n+\n+        allocateContainersToNode(rmNode.getNodeID(), true);\n+        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n+            rmNode.getNodeID());\n+      } finally {\n+        writeLock.unlock();\n+      }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void nodeUpdate(RMNode rmNode) {\n    try {\n      readLock.lock();\n      setLastNodeUpdateTime(Time.now());\n      super.nodeUpdate(rmNode);\n    } finally {\n      readLock.unlock();\n    }\n\n    // Try to do scheduling\n    if (!scheduleAsynchronously) {\n      try {\n        writeLock.lock();\n        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n\n        // reset allocation and reservation stats before we start doing any\n        // work\n        updateSchedulerHealth(lastNodeUpdateTime, rmNode.getNodeID(),\n            CSAssignment.NULL_ASSIGNMENT);\n\n        allocateContainersToNode(rmNode.getNodeID(), true);\n        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n            rmNode.getNodeID());\n      } finally {\n        writeLock.unlock();\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-5047. Refactor nodeUpdate across schedulers. (Ray Chiang via kasha)\n",
      "commitDate": "20/10/16 9:17 PM",
      "commitName": "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-5047. Refactor nodeUpdate across schedulers. (Ray Chiang via kasha)\n",
          "commitDate": "20/10/16 9:17 PM",
          "commitName": "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "04/10/16 5:23 PM",
          "commitNameOld": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 16.16,
          "commitsBetweenForRepo": 125,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,86 +1,16 @@\n-  private void nodeUpdate(RMNode nm) {\n+  protected synchronized void nodeUpdate(RMNode nm) {\n     try {\n       writeLock.lock();\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\n-            \"nodeUpdate: \" + nm + \" clusterResources: \" + getClusterResource());\n-      }\n-\n-      Resource releaseResources \u003d Resource.newInstance(0, 0);\n-\n-      FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n-\n-      List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n-      List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n-          new ArrayList\u003cContainerStatus\u003e();\n-      List\u003cContainerStatus\u003e completedContainers \u003d\n-          new ArrayList\u003cContainerStatus\u003e();\n-      for (UpdatedContainerInfo containerInfo : containerInfoList) {\n-        newlyLaunchedContainers.addAll(\n-            containerInfo.getNewlyLaunchedContainers());\n-        completedContainers.addAll(containerInfo.getCompletedContainers());\n-      }\n-\n-      // Processing the newly launched containers\n-      for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n-        containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n-      }\n-\n-      // Processing the newly increased containers\n-      List\u003cContainer\u003e newlyIncreasedContainers \u003d\n-          nm.pullNewlyIncreasedContainers();\n-      for (Container container : newlyIncreasedContainers) {\n-        containerIncreasedOnNode(container.getId(), node, container);\n-      }\n-\n-      // Process completed containers\n-      int releasedContainers \u003d 0;\n-      for (ContainerStatus completedContainer : completedContainers) {\n-        ContainerId containerId \u003d completedContainer.getContainerId();\n-        RMContainer container \u003d getRMContainer(containerId);\n-        super.completedContainer(container, completedContainer,\n-            RMContainerEventType.FINISHED);\n-        if (container !\u003d null) {\n-          releasedContainers++;\n-          Resource rs \u003d container.getAllocatedResource();\n-          if (rs !\u003d null) {\n-            Resources.addTo(releaseResources, rs);\n-          }\n-          rs \u003d container.getReservedResource();\n-          if (rs !\u003d null) {\n-            Resources.addTo(releaseResources, rs);\n-          }\n-        }\n-      }\n-\n-      // If the node is decommissioning, send an update to have the total\n-      // resource equal to the used resource, so no available resource to\n-      // schedule.\n-      // TODO: Fix possible race-condition when request comes in before\n-      // update is propagated\n-      if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n-        this.rmContext.getDispatcher().getEventHandler().handle(\n-            new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n-                .newInstance(\n-                    getSchedulerNode(nm.getNodeID()).getAllocatedResource(),\n-                    0)));\n-      }\n-      schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n-          releaseResources);\n-      schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n-\n-      // Updating node resource utilization\n-      node.setAggregatedContainersUtilization(\n-          nm.getAggregatedContainersUtilization());\n-      node.setNodeUtilization(nm.getNodeUtilization());\n-\n-      // Now node data structures are upto date and ready for scheduling.\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\n-            \"Node being looked for scheduling \" + nm + \" availableResource: \"\n-                + node.getUnallocatedResource());\n+      setLastNodeUpdateTime(Time.now());\n+      super.nodeUpdate(nm);\n+      if (!scheduleAsynchronously) {\n+        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n+            nm.getNodeID());\n+        allocateContainersToNode(getNode(nm.getNodeID()));\n+        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n+            nm.getNodeID());\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void nodeUpdate(RMNode nm) {\n    try {\n      writeLock.lock();\n      setLastNodeUpdateTime(Time.now());\n      super.nodeUpdate(nm);\n      if (!scheduleAsynchronously) {\n        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n            nm.getNodeID());\n        allocateContainersToNode(getNode(nm.getNodeID()));\n        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n            nm.getNodeID());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected, synchronized]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5047. Refactor nodeUpdate across schedulers. (Ray Chiang via kasha)\n",
          "commitDate": "20/10/16 9:17 PM",
          "commitName": "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "04/10/16 5:23 PM",
          "commitNameOld": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 16.16,
          "commitsBetweenForRepo": 125,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,86 +1,16 @@\n-  private void nodeUpdate(RMNode nm) {\n+  protected synchronized void nodeUpdate(RMNode nm) {\n     try {\n       writeLock.lock();\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\n-            \"nodeUpdate: \" + nm + \" clusterResources: \" + getClusterResource());\n-      }\n-\n-      Resource releaseResources \u003d Resource.newInstance(0, 0);\n-\n-      FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n-\n-      List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n-      List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n-          new ArrayList\u003cContainerStatus\u003e();\n-      List\u003cContainerStatus\u003e completedContainers \u003d\n-          new ArrayList\u003cContainerStatus\u003e();\n-      for (UpdatedContainerInfo containerInfo : containerInfoList) {\n-        newlyLaunchedContainers.addAll(\n-            containerInfo.getNewlyLaunchedContainers());\n-        completedContainers.addAll(containerInfo.getCompletedContainers());\n-      }\n-\n-      // Processing the newly launched containers\n-      for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n-        containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n-      }\n-\n-      // Processing the newly increased containers\n-      List\u003cContainer\u003e newlyIncreasedContainers \u003d\n-          nm.pullNewlyIncreasedContainers();\n-      for (Container container : newlyIncreasedContainers) {\n-        containerIncreasedOnNode(container.getId(), node, container);\n-      }\n-\n-      // Process completed containers\n-      int releasedContainers \u003d 0;\n-      for (ContainerStatus completedContainer : completedContainers) {\n-        ContainerId containerId \u003d completedContainer.getContainerId();\n-        RMContainer container \u003d getRMContainer(containerId);\n-        super.completedContainer(container, completedContainer,\n-            RMContainerEventType.FINISHED);\n-        if (container !\u003d null) {\n-          releasedContainers++;\n-          Resource rs \u003d container.getAllocatedResource();\n-          if (rs !\u003d null) {\n-            Resources.addTo(releaseResources, rs);\n-          }\n-          rs \u003d container.getReservedResource();\n-          if (rs !\u003d null) {\n-            Resources.addTo(releaseResources, rs);\n-          }\n-        }\n-      }\n-\n-      // If the node is decommissioning, send an update to have the total\n-      // resource equal to the used resource, so no available resource to\n-      // schedule.\n-      // TODO: Fix possible race-condition when request comes in before\n-      // update is propagated\n-      if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n-        this.rmContext.getDispatcher().getEventHandler().handle(\n-            new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n-                .newInstance(\n-                    getSchedulerNode(nm.getNodeID()).getAllocatedResource(),\n-                    0)));\n-      }\n-      schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n-          releaseResources);\n-      schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n-\n-      // Updating node resource utilization\n-      node.setAggregatedContainersUtilization(\n-          nm.getAggregatedContainersUtilization());\n-      node.setNodeUtilization(nm.getNodeUtilization());\n-\n-      // Now node data structures are upto date and ready for scheduling.\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\n-            \"Node being looked for scheduling \" + nm + \" availableResource: \"\n-                + node.getUnallocatedResource());\n+      setLastNodeUpdateTime(Time.now());\n+      super.nodeUpdate(nm);\n+      if (!scheduleAsynchronously) {\n+        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n+            nm.getNodeID());\n+        allocateContainersToNode(getNode(nm.getNodeID()));\n+        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n+            nm.getNodeID());\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void nodeUpdate(RMNode nm) {\n    try {\n      writeLock.lock();\n      setLastNodeUpdateTime(Time.now());\n      super.nodeUpdate(nm);\n      if (!scheduleAsynchronously) {\n        ActivitiesLogger.NODE.startNodeUpdateRecording(activitiesManager,\n            nm.getNodeID());\n        allocateContainersToNode(getNode(nm.getNodeID()));\n        ActivitiesLogger.NODE.finishNodeUpdateRecording(activitiesManager,\n            nm.getNodeID());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,86 @@\n-  private synchronized void nodeUpdate(RMNode nm) {\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"nodeUpdate: \" + nm +\n-          \" clusterResources: \" + getClusterResource());\n-    }\n+  private void nodeUpdate(RMNode nm) {\n+    try {\n+      writeLock.lock();\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\n+            \"nodeUpdate: \" + nm + \" clusterResources: \" + getClusterResource());\n+      }\n \n-    Resource releaseResources \u003d Resource.newInstance(0, 0);\n+      Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n-    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n-    \n-    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n-    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n-    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n-    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n-      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n-      completedContainers.addAll(containerInfo.getCompletedContainers());\n-    }\n-    \n-    // Processing the newly launched containers\n-    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n-      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n-    }\n-    \n-    // Processing the newly increased containers\n-    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n-        nm.pullNewlyIncreasedContainers();\n-    for (Container container : newlyIncreasedContainers) {\n-      containerIncreasedOnNode(container.getId(), node, container);\n-    }\n+      FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n \n-    // Process completed containers\n-    int releasedContainers \u003d 0;\n-    for (ContainerStatus completedContainer : completedContainers) {\n-      ContainerId containerId \u003d completedContainer.getContainerId();\n-      RMContainer container \u003d getRMContainer(containerId);\n-      super.completedContainer(container, completedContainer,\n-        RMContainerEventType.FINISHED);\n-      if (container !\u003d null) {\n-        releasedContainers++;\n-        Resource rs \u003d container.getAllocatedResource();\n-        if (rs !\u003d null) {\n-          Resources.addTo(releaseResources, rs);\n-        }\n-        rs \u003d container.getReservedResource();\n-        if (rs !\u003d null) {\n-          Resources.addTo(releaseResources, rs);\n+      List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n+      List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n+          new ArrayList\u003cContainerStatus\u003e();\n+      List\u003cContainerStatus\u003e completedContainers \u003d\n+          new ArrayList\u003cContainerStatus\u003e();\n+      for (UpdatedContainerInfo containerInfo : containerInfoList) {\n+        newlyLaunchedContainers.addAll(\n+            containerInfo.getNewlyLaunchedContainers());\n+        completedContainers.addAll(containerInfo.getCompletedContainers());\n+      }\n+\n+      // Processing the newly launched containers\n+      for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n+        containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n+      }\n+\n+      // Processing the newly increased containers\n+      List\u003cContainer\u003e newlyIncreasedContainers \u003d\n+          nm.pullNewlyIncreasedContainers();\n+      for (Container container : newlyIncreasedContainers) {\n+        containerIncreasedOnNode(container.getId(), node, container);\n+      }\n+\n+      // Process completed containers\n+      int releasedContainers \u003d 0;\n+      for (ContainerStatus completedContainer : completedContainers) {\n+        ContainerId containerId \u003d completedContainer.getContainerId();\n+        RMContainer container \u003d getRMContainer(containerId);\n+        super.completedContainer(container, completedContainer,\n+            RMContainerEventType.FINISHED);\n+        if (container !\u003d null) {\n+          releasedContainers++;\n+          Resource rs \u003d container.getAllocatedResource();\n+          if (rs !\u003d null) {\n+            Resources.addTo(releaseResources, rs);\n+          }\n+          rs \u003d container.getReservedResource();\n+          if (rs !\u003d null) {\n+            Resources.addTo(releaseResources, rs);\n+          }\n         }\n       }\n-    }\n \n-    // If the node is decommissioning, send an update to have the total\n-    // resource equal to the used resource, so no available resource to\n-    // schedule.\n-    // TODO: Fix possible race-condition when request comes in before\n-    // update is propagated\n-    if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n-      this.rmContext\n-          .getDispatcher()\n-          .getEventHandler()\n-          .handle(\n-              new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n-                  .newInstance(getSchedulerNode(nm.getNodeID())\n-                      .getAllocatedResource(), 0)));\n-    }\n-    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n-      releaseResources);\n-    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n+      // If the node is decommissioning, send an update to have the total\n+      // resource equal to the used resource, so no available resource to\n+      // schedule.\n+      // TODO: Fix possible race-condition when request comes in before\n+      // update is propagated\n+      if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n+        this.rmContext.getDispatcher().getEventHandler().handle(\n+            new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n+                .newInstance(\n+                    getSchedulerNode(nm.getNodeID()).getAllocatedResource(),\n+                    0)));\n+      }\n+      schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n+          releaseResources);\n+      schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n-    // Updating node resource utilization\n-    node.setAggregatedContainersUtilization(\n-        nm.getAggregatedContainersUtilization());\n-    node.setNodeUtilization(nm.getNodeUtilization());\n+      // Updating node resource utilization\n+      node.setAggregatedContainersUtilization(\n+          nm.getAggregatedContainersUtilization());\n+      node.setNodeUtilization(nm.getNodeUtilization());\n \n-    // Now node data structures are upto date and ready for scheduling.\n-    if(LOG.isDebugEnabled()) {\n-      LOG.debug(\"Node being looked for scheduling \" + nm +\n-          \" availableResource: \" + node.getUnallocatedResource());\n+      // Now node data structures are upto date and ready for scheduling.\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\n+            \"Node being looked for scheduling \" + nm + \" availableResource: \"\n+                + node.getUnallocatedResource());\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void nodeUpdate(RMNode nm) {\n    try {\n      writeLock.lock();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\n            \"nodeUpdate: \" + nm + \" clusterResources: \" + getClusterResource());\n      }\n\n      Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n      FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n\n      List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n      List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n          new ArrayList\u003cContainerStatus\u003e();\n      List\u003cContainerStatus\u003e completedContainers \u003d\n          new ArrayList\u003cContainerStatus\u003e();\n      for (UpdatedContainerInfo containerInfo : containerInfoList) {\n        newlyLaunchedContainers.addAll(\n            containerInfo.getNewlyLaunchedContainers());\n        completedContainers.addAll(containerInfo.getCompletedContainers());\n      }\n\n      // Processing the newly launched containers\n      for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n        containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n      }\n\n      // Processing the newly increased containers\n      List\u003cContainer\u003e newlyIncreasedContainers \u003d\n          nm.pullNewlyIncreasedContainers();\n      for (Container container : newlyIncreasedContainers) {\n        containerIncreasedOnNode(container.getId(), node, container);\n      }\n\n      // Process completed containers\n      int releasedContainers \u003d 0;\n      for (ContainerStatus completedContainer : completedContainers) {\n        ContainerId containerId \u003d completedContainer.getContainerId();\n        RMContainer container \u003d getRMContainer(containerId);\n        super.completedContainer(container, completedContainer,\n            RMContainerEventType.FINISHED);\n        if (container !\u003d null) {\n          releasedContainers++;\n          Resource rs \u003d container.getAllocatedResource();\n          if (rs !\u003d null) {\n            Resources.addTo(releaseResources, rs);\n          }\n          rs \u003d container.getReservedResource();\n          if (rs !\u003d null) {\n            Resources.addTo(releaseResources, rs);\n          }\n        }\n      }\n\n      // If the node is decommissioning, send an update to have the total\n      // resource equal to the used resource, so no available resource to\n      // schedule.\n      // TODO: Fix possible race-condition when request comes in before\n      // update is propagated\n      if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n                .newInstance(\n                    getSchedulerNode(nm.getNodeID()).getAllocatedResource(),\n                    0)));\n      }\n      schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n          releaseResources);\n      schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n      // Updating node resource utilization\n      node.setAggregatedContainersUtilization(\n          nm.getAggregatedContainersUtilization());\n      node.setNodeUtilization(nm.getNodeUtilization());\n\n      // Now node data structures are upto date and ready for scheduling.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\n            \"Node being looked for scheduling \" + nm + \" availableResource: \"\n                + node.getUnallocatedResource());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[private, synchronized]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,86 @@\n-  private synchronized void nodeUpdate(RMNode nm) {\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"nodeUpdate: \" + nm +\n-          \" clusterResources: \" + getClusterResource());\n-    }\n+  private void nodeUpdate(RMNode nm) {\n+    try {\n+      writeLock.lock();\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\n+            \"nodeUpdate: \" + nm + \" clusterResources: \" + getClusterResource());\n+      }\n \n-    Resource releaseResources \u003d Resource.newInstance(0, 0);\n+      Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n-    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n-    \n-    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n-    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n-    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n-    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n-      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n-      completedContainers.addAll(containerInfo.getCompletedContainers());\n-    }\n-    \n-    // Processing the newly launched containers\n-    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n-      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n-    }\n-    \n-    // Processing the newly increased containers\n-    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n-        nm.pullNewlyIncreasedContainers();\n-    for (Container container : newlyIncreasedContainers) {\n-      containerIncreasedOnNode(container.getId(), node, container);\n-    }\n+      FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n \n-    // Process completed containers\n-    int releasedContainers \u003d 0;\n-    for (ContainerStatus completedContainer : completedContainers) {\n-      ContainerId containerId \u003d completedContainer.getContainerId();\n-      RMContainer container \u003d getRMContainer(containerId);\n-      super.completedContainer(container, completedContainer,\n-        RMContainerEventType.FINISHED);\n-      if (container !\u003d null) {\n-        releasedContainers++;\n-        Resource rs \u003d container.getAllocatedResource();\n-        if (rs !\u003d null) {\n-          Resources.addTo(releaseResources, rs);\n-        }\n-        rs \u003d container.getReservedResource();\n-        if (rs !\u003d null) {\n-          Resources.addTo(releaseResources, rs);\n+      List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n+      List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n+          new ArrayList\u003cContainerStatus\u003e();\n+      List\u003cContainerStatus\u003e completedContainers \u003d\n+          new ArrayList\u003cContainerStatus\u003e();\n+      for (UpdatedContainerInfo containerInfo : containerInfoList) {\n+        newlyLaunchedContainers.addAll(\n+            containerInfo.getNewlyLaunchedContainers());\n+        completedContainers.addAll(containerInfo.getCompletedContainers());\n+      }\n+\n+      // Processing the newly launched containers\n+      for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n+        containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n+      }\n+\n+      // Processing the newly increased containers\n+      List\u003cContainer\u003e newlyIncreasedContainers \u003d\n+          nm.pullNewlyIncreasedContainers();\n+      for (Container container : newlyIncreasedContainers) {\n+        containerIncreasedOnNode(container.getId(), node, container);\n+      }\n+\n+      // Process completed containers\n+      int releasedContainers \u003d 0;\n+      for (ContainerStatus completedContainer : completedContainers) {\n+        ContainerId containerId \u003d completedContainer.getContainerId();\n+        RMContainer container \u003d getRMContainer(containerId);\n+        super.completedContainer(container, completedContainer,\n+            RMContainerEventType.FINISHED);\n+        if (container !\u003d null) {\n+          releasedContainers++;\n+          Resource rs \u003d container.getAllocatedResource();\n+          if (rs !\u003d null) {\n+            Resources.addTo(releaseResources, rs);\n+          }\n+          rs \u003d container.getReservedResource();\n+          if (rs !\u003d null) {\n+            Resources.addTo(releaseResources, rs);\n+          }\n         }\n       }\n-    }\n \n-    // If the node is decommissioning, send an update to have the total\n-    // resource equal to the used resource, so no available resource to\n-    // schedule.\n-    // TODO: Fix possible race-condition when request comes in before\n-    // update is propagated\n-    if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n-      this.rmContext\n-          .getDispatcher()\n-          .getEventHandler()\n-          .handle(\n-              new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n-                  .newInstance(getSchedulerNode(nm.getNodeID())\n-                      .getAllocatedResource(), 0)));\n-    }\n-    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n-      releaseResources);\n-    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n+      // If the node is decommissioning, send an update to have the total\n+      // resource equal to the used resource, so no available resource to\n+      // schedule.\n+      // TODO: Fix possible race-condition when request comes in before\n+      // update is propagated\n+      if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n+        this.rmContext.getDispatcher().getEventHandler().handle(\n+            new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n+                .newInstance(\n+                    getSchedulerNode(nm.getNodeID()).getAllocatedResource(),\n+                    0)));\n+      }\n+      schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n+          releaseResources);\n+      schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n-    // Updating node resource utilization\n-    node.setAggregatedContainersUtilization(\n-        nm.getAggregatedContainersUtilization());\n-    node.setNodeUtilization(nm.getNodeUtilization());\n+      // Updating node resource utilization\n+      node.setAggregatedContainersUtilization(\n+          nm.getAggregatedContainersUtilization());\n+      node.setNodeUtilization(nm.getNodeUtilization());\n \n-    // Now node data structures are upto date and ready for scheduling.\n-    if(LOG.isDebugEnabled()) {\n-      LOG.debug(\"Node being looked for scheduling \" + nm +\n-          \" availableResource: \" + node.getUnallocatedResource());\n+      // Now node data structures are upto date and ready for scheduling.\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\n+            \"Node being looked for scheduling \" + nm + \" availableResource: \"\n+                + node.getUnallocatedResource());\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void nodeUpdate(RMNode nm) {\n    try {\n      writeLock.lock();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\n            \"nodeUpdate: \" + nm + \" clusterResources: \" + getClusterResource());\n      }\n\n      Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n      FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n\n      List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n      List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n          new ArrayList\u003cContainerStatus\u003e();\n      List\u003cContainerStatus\u003e completedContainers \u003d\n          new ArrayList\u003cContainerStatus\u003e();\n      for (UpdatedContainerInfo containerInfo : containerInfoList) {\n        newlyLaunchedContainers.addAll(\n            containerInfo.getNewlyLaunchedContainers());\n        completedContainers.addAll(containerInfo.getCompletedContainers());\n      }\n\n      // Processing the newly launched containers\n      for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n        containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n      }\n\n      // Processing the newly increased containers\n      List\u003cContainer\u003e newlyIncreasedContainers \u003d\n          nm.pullNewlyIncreasedContainers();\n      for (Container container : newlyIncreasedContainers) {\n        containerIncreasedOnNode(container.getId(), node, container);\n      }\n\n      // Process completed containers\n      int releasedContainers \u003d 0;\n      for (ContainerStatus completedContainer : completedContainers) {\n        ContainerId containerId \u003d completedContainer.getContainerId();\n        RMContainer container \u003d getRMContainer(containerId);\n        super.completedContainer(container, completedContainer,\n            RMContainerEventType.FINISHED);\n        if (container !\u003d null) {\n          releasedContainers++;\n          Resource rs \u003d container.getAllocatedResource();\n          if (rs !\u003d null) {\n            Resources.addTo(releaseResources, rs);\n          }\n          rs \u003d container.getReservedResource();\n          if (rs !\u003d null) {\n            Resources.addTo(releaseResources, rs);\n          }\n        }\n      }\n\n      // If the node is decommissioning, send an update to have the total\n      // resource equal to the used resource, so no available resource to\n      // schedule.\n      // TODO: Fix possible race-condition when request comes in before\n      // update is propagated\n      if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n                .newInstance(\n                    getSchedulerNode(nm.getNodeID()).getAllocatedResource(),\n                    0)));\n      }\n      schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n          releaseResources);\n      schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n      // Updating node resource utilization\n      node.setAggregatedContainersUtilization(\n          nm.getAggregatedContainersUtilization());\n      node.setNodeUtilization(nm.getNodeUtilization());\n\n      // Now node data structures are upto date and ready for scheduling.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\n            \"Node being looked for scheduling \" + nm + \" availableResource: \"\n                + node.getUnallocatedResource());\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4719. Add a helper library to maintain node state and allows common queries. (kasha)\n",
      "commitDate": "14/03/16 2:19 PM",
      "commitName": "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "01/03/16 1:14 PM",
      "commitNameOld": "5c465df90414d43250d09084748ab2d41af44eea",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 13.0,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,79 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n+      LOG.debug(\"nodeUpdate: \" + nm +\n+          \" clusterResources: \" + getClusterResource());\n     }\n \n     Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n     \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n       containerIncreasedOnNode(container.getId(), node, container);\n     }\n \n     // Process completed containers\n     int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       RMContainer container \u003d getRMContainer(containerId);\n       super.completedContainer(container, completedContainer,\n         RMContainerEventType.FINISHED);\n       if (container !\u003d null) {\n         releasedContainers++;\n         Resource rs \u003d container.getAllocatedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n         rs \u003d container.getReservedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n       }\n     }\n \n     // If the node is decommissioning, send an update to have the total\n     // resource equal to the used resource, so no available resource to\n     // schedule.\n     // TODO: Fix possible race-condition when request comes in before\n     // update is propagated\n     if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n                   .newInstance(getSchedulerNode(nm.getNodeID())\n                       .getAllocatedResource(), 0)));\n     }\n     schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n       releaseResources);\n     schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n     // Updating node resource utilization\n     node.setAggregatedContainersUtilization(\n         nm.getAggregatedContainersUtilization());\n     node.setNodeUtilization(nm.getNodeUtilization());\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm +\n           \" availableResource: \" + node.getUnallocatedResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm +\n          \" clusterResources: \" + getClusterResource());\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n    \n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), node, container);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      super.completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    // If the node is decommissioning, send an update to have the total\n    // resource equal to the used resource, so no available resource to\n    // schedule.\n    // TODO: Fix possible race-condition when request comes in before\n    // update is propagated\n    if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n                  .newInstance(getSchedulerNode(nm.getNodeID())\n                      .getAllocatedResource(), 0)));\n    }\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Updating node resource utilization\n    node.setAggregatedContainersUtilization(\n        nm.getAggregatedContainersUtilization());\n    node.setNodeUtilization(nm.getNodeUtilization());\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm +\n          \" availableResource: \" + node.getUnallocatedResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "f9692770a58af0ab082eb7f15da9cbdcd177605b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4718. Rename variables in SchedulerNode to reduce ambiguity post YARN-1011. (Inigo Goiri via kasha)\n",
      "commitDate": "28/02/16 9:35 AM",
      "commitName": "f9692770a58af0ab082eb7f15da9cbdcd177605b",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "23/02/16 3:30 AM",
      "commitNameOld": "9ed17f181d96b8719a0ef54a129081948781d57e",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 5.25,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,78 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n     \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n       containerIncreasedOnNode(container.getId(), node, container);\n     }\n \n     // Process completed containers\n     int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       RMContainer container \u003d getRMContainer(containerId);\n       super.completedContainer(container, completedContainer,\n         RMContainerEventType.FINISHED);\n       if (container !\u003d null) {\n         releasedContainers++;\n         Resource rs \u003d container.getAllocatedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n         rs \u003d container.getReservedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n       }\n     }\n \n     // If the node is decommissioning, send an update to have the total\n     // resource equal to the used resource, so no available resource to\n     // schedule.\n     // TODO: Fix possible race-condition when request comes in before\n     // update is propagated\n     if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n                   .newInstance(getSchedulerNode(nm.getNodeID())\n-                      .getUsedResource(), 0)));\n+                      .getAllocatedResource(), 0)));\n     }\n     schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n       releaseResources);\n     schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n     // Updating node resource utilization\n     node.setAggregatedContainersUtilization(\n         nm.getAggregatedContainersUtilization());\n     node.setNodeUtilization(nm.getNodeUtilization());\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n-      LOG.debug(\"Node being looked for scheduling \" + nm\n-        + \" availableResource: \" + node.getAvailableResource());\n+      LOG.debug(\"Node being looked for scheduling \" + nm +\n+          \" availableResource: \" + node.getUnallocatedResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n    \n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), node, container);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      super.completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    // If the node is decommissioning, send an update to have the total\n    // resource equal to the used resource, so no available resource to\n    // schedule.\n    // TODO: Fix possible race-condition when request comes in before\n    // update is propagated\n    if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n                  .newInstance(getSchedulerNode(nm.getNodeID())\n                      .getAllocatedResource(), 0)));\n    }\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Updating node resource utilization\n    node.setAggregatedContainersUtilization(\n        nm.getAggregatedContainersUtilization());\n    node.setNodeUtilization(nm.getNodeUtilization());\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm +\n          \" availableResource: \" + node.getUnallocatedResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "9ed17f181d96b8719a0ef54a129081948781d57e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3223. Resource update during NM graceful decommission. Contributed by Brook Zhou.\n",
      "commitDate": "23/02/16 3:30 AM",
      "commitName": "9ed17f181d96b8719a0ef54a129081948781d57e",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/02/16 6:06 PM",
      "commitNameOld": "d16b17b4d299b4d58f879a2a15708bacd0938685",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 12.39,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,78 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n     \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n       containerIncreasedOnNode(container.getId(), node, container);\n     }\n \n     // Process completed containers\n     int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       RMContainer container \u003d getRMContainer(containerId);\n       super.completedContainer(container, completedContainer,\n         RMContainerEventType.FINISHED);\n       if (container !\u003d null) {\n         releasedContainers++;\n         Resource rs \u003d container.getAllocatedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n         rs \u003d container.getReservedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n       }\n     }\n \n+    // If the node is decommissioning, send an update to have the total\n+    // resource equal to the used resource, so no available resource to\n+    // schedule.\n+    // TODO: Fix possible race-condition when request comes in before\n+    // update is propagated\n+    if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n+      this.rmContext\n+          .getDispatcher()\n+          .getEventHandler()\n+          .handle(\n+              new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n+                  .newInstance(getSchedulerNode(nm.getNodeID())\n+                      .getUsedResource(), 0)));\n+    }\n     schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n       releaseResources);\n     schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n     // Updating node resource utilization\n     node.setAggregatedContainersUtilization(\n         nm.getAggregatedContainersUtilization());\n     node.setNodeUtilization(nm.getNodeUtilization());\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n    \n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), node, container);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      super.completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    // If the node is decommissioning, send an update to have the total\n    // resource equal to the used resource, so no available resource to\n    // schedule.\n    // TODO: Fix possible race-condition when request comes in before\n    // update is propagated\n    if (nm.getState() \u003d\u003d NodeState.DECOMMISSIONING) {\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeResourceUpdateEvent(nm.getNodeID(), ResourceOption\n                  .newInstance(getSchedulerNode(nm.getNodeID())\n                      .getUsedResource(), 0)));\n    }\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Updating node resource utilization\n    node.setAggregatedContainersUtilization(\n        nm.getAggregatedContainersUtilization());\n    node.setNodeUtilization(nm.getNodeUtilization());\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "18/01/16 5:30 PM",
      "commitName": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 5:27 PM",
      "commitNameOld": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n     \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n       containerIncreasedOnNode(container.getId(), node, container);\n     }\n \n     // Process completed containers\n     int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       RMContainer container \u003d getRMContainer(containerId);\n-      completedContainer(container, completedContainer,\n+      super.completedContainer(container, completedContainer,\n         RMContainerEventType.FINISHED);\n       if (container !\u003d null) {\n         releasedContainers++;\n         Resource rs \u003d container.getAllocatedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n         rs \u003d container.getReservedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n       }\n     }\n \n     schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n       releaseResources);\n     schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n     // Updating node resource utilization\n     node.setAggregatedContainersUtilization(\n         nm.getAggregatedContainersUtilization());\n     node.setNodeUtilization(nm.getNodeUtilization());\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n    \n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), node, container);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      super.completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Updating node resource utilization\n    node.setAggregatedContainersUtilization(\n        nm.getAggregatedContainersUtilization());\n    node.setNodeUtilization(nm.getNodeUtilization());\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 3fe57285635e8058c34aa40a103845b49ca7d6ff.\n\nConflicts:\n\thadoop-yarn-project/CHANGES.txt\n",
      "commitDate": "18/01/16 5:27 PM",
      "commitName": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 1:06 AM",
      "commitNameOld": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.68,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n     \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n       containerIncreasedOnNode(container.getId(), node, container);\n     }\n \n     // Process completed containers\n     int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       RMContainer container \u003d getRMContainer(containerId);\n-      super.completedContainer(container, completedContainer,\n+      completedContainer(container, completedContainer,\n         RMContainerEventType.FINISHED);\n       if (container !\u003d null) {\n         releasedContainers++;\n         Resource rs \u003d container.getAllocatedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n         rs \u003d container.getReservedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n       }\n     }\n \n     schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n       releaseResources);\n     schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n     // Updating node resource utilization\n     node.setAggregatedContainersUtilization(\n         nm.getAggregatedContainersUtilization());\n     node.setNodeUtilization(nm.getNodeUtilization());\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n    \n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), node, container);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Updating node resource utilization\n    node.setAggregatedContainersUtilization(\n        nm.getAggregatedContainersUtilization());\n    node.setNodeUtilization(nm.getNodeUtilization());\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n\n(cherry picked from commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579)\n",
      "commitDate": "18/01/16 1:06 AM",
      "commitName": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 12:50 AM",
      "commitNameOld": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n     \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n       containerIncreasedOnNode(container.getId(), node, container);\n     }\n \n     // Process completed containers\n     int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       RMContainer container \u003d getRMContainer(containerId);\n-      completedContainer(container, completedContainer,\n+      super.completedContainer(container, completedContainer,\n         RMContainerEventType.FINISHED);\n       if (container !\u003d null) {\n         releasedContainers++;\n         Resource rs \u003d container.getAllocatedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n         rs \u003d container.getReservedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n       }\n     }\n \n     schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n       releaseResources);\n     schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n     // Updating node resource utilization\n     node.setAggregatedContainersUtilization(\n         nm.getAggregatedContainersUtilization());\n     node.setNodeUtilization(nm.getNodeUtilization());\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n    \n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), node, container);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      super.completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Updating node resource utilization\n    node.setAggregatedContainersUtilization(\n        nm.getAggregatedContainersUtilization());\n    node.setNodeUtilization(nm.getNodeUtilization());\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "adf260a728df427eb729abe8fb9ad7248991ea54": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579.\n",
      "commitDate": "18/01/16 12:50 AM",
      "commitName": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/01/16 7:04 PM",
      "commitNameOld": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n     \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n       containerIncreasedOnNode(container.getId(), node, container);\n     }\n \n     // Process completed containers\n     int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       RMContainer container \u003d getRMContainer(containerId);\n-      super.completedContainer(container, completedContainer,\n+      completedContainer(container, completedContainer,\n         RMContainerEventType.FINISHED);\n       if (container !\u003d null) {\n         releasedContainers++;\n         Resource rs \u003d container.getAllocatedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n         rs \u003d container.getReservedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n       }\n     }\n \n     schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n       releaseResources);\n     schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n     // Updating node resource utilization\n     node.setAggregatedContainersUtilization(\n         nm.getAggregatedContainersUtilization());\n     node.setNodeUtilization(nm.getNodeUtilization());\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n    \n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), node, container);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Updating node resource utilization\n    node.setAggregatedContainersUtilization(\n        nm.getAggregatedContainersUtilization());\n    node.setNodeUtilization(nm.getNodeUtilization());\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "17/01/16 7:04 PM",
      "commitName": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "12/01/16 9:18 PM",
      "commitNameOld": "c0537bcd2c2dcdb4812fcab7badf42e4f55a54d9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 4.91,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n     \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n       containerIncreasedOnNode(container.getId(), node, container);\n     }\n \n     // Process completed containers\n     int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       RMContainer container \u003d getRMContainer(containerId);\n-      completedContainer(container, completedContainer,\n+      super.completedContainer(container, completedContainer,\n         RMContainerEventType.FINISHED);\n       if (container !\u003d null) {\n         releasedContainers++;\n         Resource rs \u003d container.getAllocatedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n         rs \u003d container.getReservedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n       }\n     }\n \n     schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n       releaseResources);\n     schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n     // Updating node resource utilization\n     node.setAggregatedContainersUtilization(\n         nm.getAggregatedContainersUtilization());\n     node.setNodeUtilization(nm.getNodeUtilization());\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n    \n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), node, container);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      super.completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Updating node resource utilization\n    node.setAggregatedContainersUtilization(\n        nm.getAggregatedContainersUtilization());\n    node.setNodeUtilization(nm.getNodeUtilization());\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "52948bb20bd1446164df1d3920c46c96dad750ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3980. Plumb resource-utilization info in node heartbeat through to the scheduler. (Inigo Goiri via kasha)\n",
      "commitDate": "24/11/15 12:17 AM",
      "commitName": "52948bb20bd1446164df1d3920c46c96dad750ae",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "23/11/15 5:19 PM",
      "commitNameOld": "8676a118a12165ae5a8b80a2a4596c133471ebc1",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,64 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n     \n     // Processing the newly increased containers\n     List\u003cContainer\u003e newlyIncreasedContainers \u003d\n         nm.pullNewlyIncreasedContainers();\n     for (Container container : newlyIncreasedContainers) {\n       containerIncreasedOnNode(container.getId(), node, container);\n     }\n \n     // Process completed containers\n     int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       RMContainer container \u003d getRMContainer(containerId);\n       completedContainer(container, completedContainer,\n         RMContainerEventType.FINISHED);\n       if (container !\u003d null) {\n         releasedContainers++;\n         Resource rs \u003d container.getAllocatedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n         rs \u003d container.getReservedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n       }\n     }\n \n     schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n       releaseResources);\n     schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n+    // Updating node resource utilization\n+    node.setAggregatedContainersUtilization(\n+        nm.getAggregatedContainersUtilization());\n+    node.setNodeUtilization(nm.getNodeUtilization());\n+\n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n    \n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), node, container);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Updating node resource utilization\n    node.setAggregatedContainersUtilization(\n        nm.getAggregatedContainersUtilization());\n    node.setNodeUtilization(nm.getNodeUtilization());\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
      "commitDate": "23/09/15 1:29 PM",
      "commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthor": "Jian He",
      "commitDateOld": "15/09/15 12:39 AM",
      "commitNameOld": "5468baa80aa2a3e2a02e9a902deebafd734daf23",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 8.53,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,59 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n+    \n+    // Processing the newly increased containers\n+    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n+        nm.pullNewlyIncreasedContainers();\n+    for (Container container : newlyIncreasedContainers) {\n+      containerIncreasedOnNode(container.getId(), node, container);\n+    }\n \n     // Process completed containers\n     int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       RMContainer container \u003d getRMContainer(containerId);\n       completedContainer(container, completedContainer,\n         RMContainerEventType.FINISHED);\n       if (container !\u003d null) {\n         releasedContainers++;\n         Resource rs \u003d container.getAllocatedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n         rs \u003d container.getReservedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n       }\n     }\n \n     schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n       releaseResources);\n     schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n    \n    // Processing the newly increased containers\n    List\u003cContainer\u003e newlyIncreasedContainers \u003d\n        nm.pullNewlyIncreasedContainers();\n    for (Container container : newlyIncreasedContainers) {\n      containerIncreasedOnNode(container.getId(), node, container);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "4bc42d76e7fa53cb268cab0f9fe1fd8d8dbb17fd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3966. Fix excessive loggings in CapacityScheduler. (Jian He via wangda)\n",
      "commitDate": "07/08/15 9:46 AM",
      "commitName": "4bc42d76e7fa53cb268cab0f9fe1fd8d8dbb17fd",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "24/07/15 4:44 PM",
      "commitNameOld": "a3bd7b4a59b3664273dc424f240356838213d4e7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.71,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,52 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     Resource releaseResources \u003d Resource.newInstance(0, 0);\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       RMContainer container \u003d getRMContainer(containerId);\n-      LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(container, completedContainer,\n         RMContainerEventType.FINISHED);\n       if (container !\u003d null) {\n         releasedContainers++;\n         Resource rs \u003d container.getAllocatedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n         rs \u003d container.getReservedResource();\n         if (rs !\u003d null) {\n           Resources.addTo(releaseResources, rs);\n         }\n       }\n     }\n \n     schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n       releaseResources);\n     schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "afa5d4715a3aea2a6e93380b014c7bb8f0880383": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3293. Track and display capacity scheduler health metrics in web\nUI. Contributed by Varun Vasudev\n",
      "commitDate": "09/04/15 11:38 PM",
      "commitName": "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
      "commitAuthor": "Xuan",
      "commitDateOld": "17/03/15 10:24 AM",
      "commitNameOld": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 23.55,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,53 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n+    Resource releaseResources \u003d Resource.newInstance(0, 0);\n+\n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n+    int releasedContainers \u003d 0;\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n+      RMContainer container \u003d getRMContainer(containerId);\n       LOG.debug(\"Container FINISHED: \" + containerId);\n-      completedContainer(getRMContainer(containerId), \n-          completedContainer, RMContainerEventType.FINISHED);\n+      completedContainer(container, completedContainer,\n+        RMContainerEventType.FINISHED);\n+      if (container !\u003d null) {\n+        releasedContainers++;\n+        Resource rs \u003d container.getAllocatedResource();\n+        if (rs !\u003d null) {\n+          Resources.addTo(releaseResources, rs);\n+        }\n+        rs \u003d container.getReservedResource();\n+        if (rs !\u003d null) {\n+          Resources.addTo(releaseResources, rs);\n+        }\n+      }\n     }\n \n+    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n+      releaseResources);\n+    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n+\n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    Resource releaseResources \u003d Resource.newInstance(0, 0);\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    int releasedContainers \u003d 0;\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      RMContainer container \u003d getRMContainer(containerId);\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(container, completedContainer,\n        RMContainerEventType.FINISHED);\n      if (container !\u003d null) {\n        releasedContainers++;\n        Resource rs \u003d container.getAllocatedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n        rs \u003d container.getReservedResource();\n        if (rs !\u003d null) {\n          Resources.addTo(releaseResources, rs);\n        }\n      }\n    }\n\n    schedulerHealth.updateSchedulerReleaseDetails(lastNodeUpdateTime,\n      releaseResources);\n    schedulerHealth.updateSchedulerReleaseCounts(releasedContainers);\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "5c14bc426b4be381383018ebc2236be83eef15cd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1506. Changed RMNode/SchedulerNode to update resource with event notification. Contributed by Junping Du\n",
      "commitDate": "29/08/14 11:05 PM",
      "commitName": "5c14bc426b4be381383018ebc2236be83eef15cd",
      "commitAuthor": "Jian He",
      "commitDateOld": "19/08/14 1:33 PM",
      "commitNameOld": "f6a778c3725bcdaba1e1de43786af17dd44deb78",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 10.4,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,34 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n-    // Update resource if any change\n-    if (SchedulerUtils.updateResourceIfChanged(node, nm, clusterResource,\n-        LOG)) {\n-      root.updateClusterResource(clusterResource);\n-    }\n-    \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1337. Recover containers upon nodemanager restart. (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617448 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 3:56 AM",
      "commitName": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthor": "Junping Du",
      "commitDateOld": "18/07/14 5:12 PM",
      "commitNameOld": "8871d8ed9fb1e4b21943477dcbaa13ef22ea7b8e",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 24.45,
      "commitsBetweenForRepo": 167,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,40 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     // Update resource if any change\n-    SchedulerUtils.updateResourceIfChanged(node, nm, clusterResource, LOG);\n+    if (SchedulerUtils.updateResourceIfChanged(node, nm, clusterResource,\n+        LOG)) {\n+      root.updateClusterResource(clusterResource);\n+    }\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    // Update resource if any change\n    if (SchedulerUtils.updateResourceIfChanged(node, nm, clusterResource,\n        LOG)) {\n      root.updateClusterResource(clusterResource);\n    }\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "57cdf8626a32b8595a645b7551f46ab950db4789": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1512. Enhanced CapacityScheduler to be able to decouple scheduling from node-heartbeats. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1578722 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/03/14 7:53 PM",
      "commitName": "57cdf8626a32b8595a645b7551f46ab950db4789",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/03/14 3:22 PM",
      "commitNameOld": "92317e3459b502f33a3575c247f05d64e5d39a00",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,37 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     // Update resource if any change\n     SchedulerUtils.updateResourceIfChanged(node, nm, clusterResource, LOG);\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n-\n-    // Assign new containers...\n-    // 1. Check for reserved applications\n-    // 2. Schedule if there are no reservations\n-\n-    RMContainer reservedContainer \u003d node.getReservedContainer();\n-    if (reservedContainer !\u003d null) {\n-      FiCaSchedulerApp reservedApplication \u003d\n-          getCurrentAttemptForContainer(reservedContainer.getContainerId());\n-      \n-      // Try to fulfill the reservation\n-      LOG.info(\"Trying to fulfill reservation for application \" + \n-          reservedApplication.getApplicationId() + \" on node: \" + nm);\n-      \n-      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n-      CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n-      \n-      RMContainer excessReservation \u003d assignment.getExcessReservation();\n-      if (excessReservation !\u003d null) {\n-      Container container \u003d excessReservation.getContainer();\n-      queue.completedContainer(\n-          clusterResource, assignment.getApplication(), node, \n-          excessReservation, \n-          SchedulerUtils.createAbnormalContainerStatus(\n-              container.getId(), \n-              SchedulerUtils.UNRESERVED_CONTAINER), \n-          RMContainerEventType.RELEASED, null);\n-      }\n-\n-    }\n-\n-    // Try to schedule more if there are no reservations to fulfill\n-    if (node.getReservedContainer() \u003d\u003d null) {\n-      root.assignContainers(clusterResource, node);\n-    } else {\n-      LOG.info(\"Skipping scheduling since node \" + nm + \n-          \" is reserved by application \" + \n-          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n-          );\n-    }\n-  \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    // Update resource if any change\n    SchedulerUtils.updateResourceIfChanged(node, nm, clusterResource, LOG);\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "1393581bceda234c88cafec00dbfc0ef2a402e83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 7:04 AM",
      "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/01/14 12:19 PM",
      "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.78,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,78 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     \n     // Update resource if any change\n     SchedulerUtils.updateResourceIfChanged(node, nm, clusterResource, LOG);\n     \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      FiCaSchedulerApp reservedApplication \u003d \n-          getApplication(reservedContainer.getApplicationAttemptId());\n+      FiCaSchedulerApp reservedApplication \u003d\n+          getCurrentAttemptForContainer(reservedContainer.getContainerId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n       CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n       \n       RMContainer excessReservation \u003d assignment.getExcessReservation();\n       if (excessReservation !\u003d null) {\n       Container container \u003d excessReservation.getContainer();\n       queue.completedContainer(\n           clusterResource, assignment.getApplication(), node, \n           excessReservation, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getId(), \n               SchedulerUtils.UNRESERVED_CONTAINER), \n           RMContainerEventType.RELEASED, null);\n       }\n \n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n           node.getReservedContainer().getContainerId().getApplicationAttemptId()\n           );\n     }\n   \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    // Update resource if any change\n    SchedulerUtils.updateResourceIfChanged(node, nm, clusterResource, LOG);\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      FiCaSchedulerApp reservedApplication \u003d\n          getCurrentAttemptForContainer(reservedContainer.getContainerId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n      \n      RMContainer excessReservation \u003d assignment.getExcessReservation();\n      if (excessReservation !\u003d null) {\n      Container container \u003d excessReservation.getContainer();\n      queue.completedContainer(\n          clusterResource, assignment.getApplication(), node, \n          excessReservation, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getId(), \n              SchedulerUtils.UNRESERVED_CONTAINER), \n          RMContainerEventType.RELEASED, null);\n      }\n\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n          );\n    }\n  \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "6990355e577ad19371cb656c250fb665ed14062f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-311. RM/scheduler support for dynamic resource configuration. (Junping Du via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539134 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/11/13 1:23 PM",
      "commitName": "6990355e577ad19371cb656c250fb665ed14062f",
      "commitAuthor": "Luke Lu",
      "commitDateOld": "31/10/13 7:54 PM",
      "commitNameOld": "da317f2ea5af8c12dd8ce04173239d5f9ace5d96",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 4.77,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,78 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n+    \n+    // Update resource if any change\n+    SchedulerUtils.updateResourceIfChanged(node, nm, clusterResource, LOG);\n+    \n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       FiCaSchedulerApp reservedApplication \u003d \n           getApplication(reservedContainer.getApplicationAttemptId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n       CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n       \n       RMContainer excessReservation \u003d assignment.getExcessReservation();\n       if (excessReservation !\u003d null) {\n       Container container \u003d excessReservation.getContainer();\n       queue.completedContainer(\n           clusterResource, assignment.getApplication(), node, \n           excessReservation, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getId(), \n               SchedulerUtils.UNRESERVED_CONTAINER), \n           RMContainerEventType.RELEASED, null);\n       }\n \n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n           node.getReservedContainer().getContainerId().getApplicationAttemptId()\n           );\n     }\n-\n+  \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    \n    // Update resource if any change\n    SchedulerUtils.updateResourceIfChanged(node, nm, clusterResource, LOG);\n    \n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      FiCaSchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n      \n      RMContainer excessReservation \u003d assignment.getExcessReservation();\n      if (excessReservation !\u003d null) {\n      Container container \u003d excessReservation.getContainer();\n      queue.completedContainer(\n          clusterResource, assignment.getApplication(), node, \n          excessReservation, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getId(), \n              SchedulerUtils.UNRESERVED_CONTAINER), \n          RMContainerEventType.RELEASED, null);\n      }\n\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n          );\n    }\n  \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "5b99672658ce24bfd1002b880583cbecfa47f9b3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-897. Ensure child queues are ordered correctly to account for completed containers. Contributed by Djellel Eddine Difallah.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505146 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/07/13 7:59 AM",
      "commitName": "5b99672658ce24bfd1002b880583cbecfa47f9b3",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "10/07/13 6:20 PM",
      "commitNameOld": "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61",
      "commitAuthorOld": "Christopher Douglas",
      "daysBetweenCommits": 9.57,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n     List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n     for(UpdatedContainerInfo containerInfo : containerInfoList) {\n       newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n       completedContainers.addAll(containerInfo.getCompletedContainers());\n     }\n     \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       FiCaSchedulerApp reservedApplication \u003d \n           getApplication(reservedContainer.getApplicationAttemptId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n       CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n       \n       RMContainer excessReservation \u003d assignment.getExcessReservation();\n       if (excessReservation !\u003d null) {\n       Container container \u003d excessReservation.getContainer();\n       queue.completedContainer(\n           clusterResource, assignment.getApplication(), node, \n           excessReservation, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getId(), \n               SchedulerUtils.UNRESERVED_CONTAINER), \n-          RMContainerEventType.RELEASED);\n+          RMContainerEventType.RELEASED, null);\n       }\n \n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n           node.getReservedContainer().getContainerId().getApplicationAttemptId()\n           );\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      FiCaSchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n      \n      RMContainer excessReservation \u003d assignment.getExcessReservation();\n      if (excessReservation !\u003d null) {\n      Container container \u003d excessReservation.getContainer();\n      queue.completedContainer(\n          clusterResource, assignment.getApplication(), node, \n          excessReservation, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getId(), \n              SchedulerUtils.UNRESERVED_CONTAINER), \n          RMContainerEventType.RELEASED, null);\n      }\n\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n          );\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "7ea82ca558c2e2fbb50277ee6ac7debdf9e94b69": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-365. Change NM heartbeat handling to not generate a scheduler event on each heartbeat. (Contributed by Xuan Gong)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1450007 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/13 7:32 PM",
      "commitName": "7ea82ca558c2e2fbb50277ee6ac7debdf9e94b69",
      "commitAuthor": "Siddharth Seth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-365. Change NM heartbeat handling to not generate a scheduler event on each heartbeat. (Contributed by Xuan Gong)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1450007 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "25/02/13 7:32 PM",
          "commitName": "7ea82ca558c2e2fbb50277ee6ac7debdf9e94b69",
          "commitAuthor": "Siddharth Seth",
          "commitDateOld": "09/01/13 1:00 PM",
          "commitNameOld": "106e2e27ffb81f816ae627fa1712f5db5fb36002",
          "commitAuthorOld": "Thomas Graves",
          "daysBetweenCommits": 47.27,
          "commitsBetweenForRepo": 202,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,74 @@\n-  private synchronized void nodeUpdate(RMNode nm, \n-      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n-      List\u003cContainerStatus\u003e completedContainers) {\n+  private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n-                  \n-    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n \n+    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n+    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n+    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n+    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n+    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n+      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n+      completedContainers.addAll(containerInfo.getCompletedContainers());\n+    }\n+    \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       FiCaSchedulerApp reservedApplication \u003d \n           getApplication(reservedContainer.getApplicationAttemptId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n       CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n       \n       RMContainer excessReservation \u003d assignment.getExcessReservation();\n       if (excessReservation !\u003d null) {\n       Container container \u003d excessReservation.getContainer();\n       queue.completedContainer(\n           clusterResource, assignment.getApplication(), node, \n           excessReservation, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getId(), \n               SchedulerUtils.UNRESERVED_CONTAINER), \n           RMContainerEventType.RELEASED);\n       }\n \n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n           node.getReservedContainer().getContainerId().getApplicationAttemptId()\n           );\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      FiCaSchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n      \n      RMContainer excessReservation \u003d assignment.getExcessReservation();\n      if (excessReservation !\u003d null) {\n      Container container \u003d excessReservation.getContainer();\n      queue.completedContainer(\n          clusterResource, assignment.getApplication(), node, \n          excessReservation, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getId(), \n              SchedulerUtils.UNRESERVED_CONTAINER), \n          RMContainerEventType.RELEASED);\n      }\n\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n          );\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[nm-RMNode, newlyLaunchedContainers-List\u003cContainerStatus\u003e, completedContainers-List\u003cContainerStatus\u003e]",
            "newValue": "[nm-RMNode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-365. Change NM heartbeat handling to not generate a scheduler event on each heartbeat. (Contributed by Xuan Gong)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1450007 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "25/02/13 7:32 PM",
          "commitName": "7ea82ca558c2e2fbb50277ee6ac7debdf9e94b69",
          "commitAuthor": "Siddharth Seth",
          "commitDateOld": "09/01/13 1:00 PM",
          "commitNameOld": "106e2e27ffb81f816ae627fa1712f5db5fb36002",
          "commitAuthorOld": "Thomas Graves",
          "daysBetweenCommits": 47.27,
          "commitsBetweenForRepo": 202,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,74 @@\n-  private synchronized void nodeUpdate(RMNode nm, \n-      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n-      List\u003cContainerStatus\u003e completedContainers) {\n+  private synchronized void nodeUpdate(RMNode nm) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n-                  \n-    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n \n+    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n+    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n+    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n+    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n+    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n+      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n+      completedContainers.addAll(containerInfo.getCompletedContainers());\n+    }\n+    \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       FiCaSchedulerApp reservedApplication \u003d \n           getApplication(reservedContainer.getApplicationAttemptId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n       CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n       \n       RMContainer excessReservation \u003d assignment.getExcessReservation();\n       if (excessReservation !\u003d null) {\n       Container container \u003d excessReservation.getContainer();\n       queue.completedContainer(\n           clusterResource, assignment.getApplication(), node, \n           excessReservation, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getId(), \n               SchedulerUtils.UNRESERVED_CONTAINER), \n           RMContainerEventType.RELEASED);\n       }\n \n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n           node.getReservedContainer().getContainerId().getApplicationAttemptId()\n           );\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void nodeUpdate(RMNode nm) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n\n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n    List\u003cUpdatedContainerInfo\u003e containerInfoList \u003d nm.pullContainerUpdates();\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d new ArrayList\u003cContainerStatus\u003e();\n    for(UpdatedContainerInfo containerInfo : containerInfoList) {\n      newlyLaunchedContainers.addAll(containerInfo.getNewlyLaunchedContainers());\n      completedContainers.addAll(containerInfo.getCompletedContainers());\n    }\n    \n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      FiCaSchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n      \n      RMContainer excessReservation \u003d assignment.getExcessReservation();\n      if (excessReservation !\u003d null) {\n      Container container \u003d excessReservation.getContainer();\n      queue.completedContainer(\n          clusterResource, assignment.getApplication(), node, \n          excessReservation, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getId(), \n              SchedulerUtils.UNRESERVED_CONTAINER), \n          RMContainerEventType.RELEASED);\n      }\n\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n          );\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "106e2e27ffb81f816ae627fa1712f5db5fb36002": {
      "type": "Ybodychange",
      "commitMessage": "YARN-325. RM CapacityScheduler can deadlock when getQueueInfo() is called and a container is completing (Arun C Murthy via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1431070 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/13 1:00 PM",
      "commitName": "106e2e27ffb81f816ae627fa1712f5db5fb36002",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "08/01/13 9:08 PM",
      "commitNameOld": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.66,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,69 @@\n   private synchronized void nodeUpdate(RMNode nm, \n       List\u003cContainerStatus\u003e newlyLaunchedContainers,\n       List\u003cContainerStatus\u003e completedContainers) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n                   \n     FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       FiCaSchedulerApp reservedApplication \u003d \n           getApplication(reservedContainer.getApplicationAttemptId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n-      queue.assignContainers(clusterResource, node);\n+      CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n+      \n+      RMContainer excessReservation \u003d assignment.getExcessReservation();\n+      if (excessReservation !\u003d null) {\n+      Container container \u003d excessReservation.getContainer();\n+      queue.completedContainer(\n+          clusterResource, assignment.getApplication(), node, \n+          excessReservation, \n+          SchedulerUtils.createAbnormalContainerStatus(\n+              container.getId(), \n+              SchedulerUtils.UNRESERVED_CONTAINER), \n+          RMContainerEventType.RELEASED);\n+      }\n+\n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n           node.getReservedContainer().getContainerId().getApplicationAttemptId()\n           );\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm, \n      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n      List\u003cContainerStatus\u003e completedContainers) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n                  \n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      FiCaSchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      CSAssignment assignment \u003d queue.assignContainers(clusterResource, node);\n      \n      RMContainer excessReservation \u003d assignment.getExcessReservation();\n      if (excessReservation !\u003d null) {\n      Container container \u003d excessReservation.getContainer();\n      queue.completedContainer(\n          clusterResource, assignment.getApplication(), node, \n          excessReservation, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getId(), \n              SchedulerUtils.UNRESERVED_CONTAINER), \n          RMContainerEventType.RELEASED);\n      }\n\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n          );\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm, \n      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n      List\u003cContainerStatus\u003e completedContainers) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n                  \n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      FiCaSchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      queue.assignContainers(clusterResource, node);\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n          );\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "09/03/12 3:34 PM",
      "commitNameOld": "ed4c222d5c0aeb4a46a2dd8a6342c85e88f31d3b",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 129.09,
      "commitsBetweenForRepo": 802,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n   private synchronized void nodeUpdate(RMNode nm, \n       List\u003cContainerStatus\u003e newlyLaunchedContainers,\n       List\u003cContainerStatus\u003e completedContainers) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     }\n                   \n-    SchedulerNode node \u003d getNode(nm.getNodeID());\n+    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      SchedulerApp reservedApplication \u003d \n+      FiCaSchedulerApp reservedApplication \u003d \n           getApplication(reservedContainer.getApplicationAttemptId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n       queue.assignContainers(clusterResource, node);\n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n           node.getReservedContainer().getContainerId().getApplicationAttemptId()\n           );\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm, \n      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n      List\u003cContainerStatus\u003e completedContainers) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n                  \n    FiCaSchedulerNode node \u003d getNode(nm.getNodeID());\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      FiCaSchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      queue.assignContainers(clusterResource, node);\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n          );\n    }\n\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "7ed0f74997ad8af0aaea7a2e54d6c1e3abbee33d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3748. Changed a log in CapacityScheduler.nodeUpdate to debug. Contributed by Ramya Sunil.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1238157 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/01/12 10:22 PM",
      "commitName": "7ed0f74997ad8af0aaea7a2e54d6c1e3abbee33d",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "27/01/12 5:32 PM",
      "commitNameOld": "5262b7ba4d018562d4e7d60772af4ddc3d770a23",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.2,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,56 @@\n   private synchronized void nodeUpdate(RMNode nm, \n       List\u003cContainerStatus\u003e newlyLaunchedContainers,\n       List\u003cContainerStatus\u003e completedContainers) {\n-    LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n-    \n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n+    }\n+                  \n     SchedulerNode node \u003d getNode(nm.getNodeID());\n \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     if(LOG.isDebugEnabled()) {\n       LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n     }\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       SchedulerApp reservedApplication \u003d \n           getApplication(reservedContainer.getApplicationAttemptId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n       queue.assignContainers(clusterResource, node);\n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n           node.getReservedContainer().getContainerId().getApplicationAttemptId()\n           );\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm, \n      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n      List\u003cContainerStatus\u003e completedContainers) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    }\n                  \n    SchedulerNode node \u003d getNode(nm.getNodeID());\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      SchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      queue.assignContainers(clusterResource, node);\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n          );\n    }\n\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "f24dcb3449c77da665058427bc7fa480cad507fc": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2907. Changed log level for various messages in ResourceManager from INFO to DEBUG. Contributed by Ravi Prakash.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1179178 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/10/11 4:56 AM",
      "commitName": "f24dcb3449c77da665058427bc7fa480cad507fc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/09/11 3:19 PM",
      "commitNameOld": "dcf9d475e0de05a2e1a7fe9239034c0a6d8a9456",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 4.57,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,54 @@\n   private synchronized void nodeUpdate(RMNode nm, \n       List\u003cContainerStatus\u003e newlyLaunchedContainers,\n       List\u003cContainerStatus\u003e completedContainers) {\n     LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     \n     SchedulerNode node \u003d getNode(nm.getNodeID());\n \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n-      LOG.info(\"DEBUG --- Container FINISHED: \" + containerId);\n+      LOG.debug(\"Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n-    LOG.info(\"DEBUG -- Node being looked for scheduling \" + nm\n+    if(LOG.isDebugEnabled()) {\n+      LOG.debug(\"Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n+    }\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       SchedulerApp reservedApplication \u003d \n           getApplication(reservedContainer.getApplicationAttemptId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n       queue.assignContainers(clusterResource, node);\n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n           node.getReservedContainer().getContainerId().getApplicationAttemptId()\n           );\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm, \n      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n      List\u003cContainerStatus\u003e completedContainers) {\n    LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    \n    SchedulerNode node \u003d getNode(nm.getNodeID());\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.debug(\"Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n    }\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      SchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      queue.assignContainers(clusterResource, node);\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n          );\n    }\n\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2896. Simplify all apis to in org.apache.hadoop.yarn.api.records.* to be get/set only. Added javadocs to all public records.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169980 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/09/11 5:05 PM",
      "commitName": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "11/09/11 10:26 AM",
      "commitNameOld": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.28,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,52 @@\n   private synchronized void nodeUpdate(RMNode nm, \n       List\u003cContainerStatus\u003e newlyLaunchedContainers,\n       List\u003cContainerStatus\u003e completedContainers) {\n     LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     \n     SchedulerNode node \u003d getNode(nm.getNodeID());\n \n     // Processing the newly launched containers\n     for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n       containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n     }\n \n     // Process completed containers\n     for (ContainerStatus completedContainer : completedContainers) {\n       ContainerId containerId \u003d completedContainer.getContainerId();\n       LOG.info(\"DEBUG --- Container FINISHED: \" + containerId);\n       completedContainer(getRMContainer(containerId), \n           completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     LOG.info(\"DEBUG -- Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       SchedulerApp reservedApplication \u003d \n           getApplication(reservedContainer.getApplicationAttemptId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n       queue.assignContainers(clusterResource, node);\n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n-          node.getReservedContainer().getContainerId().getAppId());\n+          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n+          );\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm, \n      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n      List\u003cContainerStatus\u003e completedContainers) {\n    LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    \n    SchedulerNode node \u003d getNode(nm.getNodeID());\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.info(\"DEBUG --- Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    LOG.info(\"DEBUG -- Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      SchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      queue.assignContainers(clusterResource, node);\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getApplicationAttemptId()\n          );\n    }\n\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-2933. Change allocate call to return ContainerStatus for completed containers rather than Container.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169484 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/09/11 10:26 AM",
      "commitName": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
      "commitAuthor": "Arun Murthy",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-2933. Change allocate call to return ContainerStatus for completed containers rather than Container.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169484 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/09/11 10:26 AM",
          "commitName": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "08/09/11 11:26 AM",
          "commitNameOld": "1f46b991da9b91585608a0babd3eda39485dce09",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 2.96,
          "commitsBetweenForRepo": 24,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,51 @@\n   private synchronized void nodeUpdate(RMNode nm, \n-      Map\u003cApplicationId, List\u003cContainer\u003e\u003e containers ) {\n+      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n+      List\u003cContainerStatus\u003e completedContainers) {\n     LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     \n     SchedulerNode node \u003d getNode(nm.getNodeID());\n \n-    // Processing the current containers running/finished on node\n-    for (List\u003cContainer\u003e appContainers : containers.values()) {\n-      for (Container container : appContainers) {\n-        if (container.getState() \u003d\u003d ContainerState.RUNNING) {\n-          containerLaunchedOnNode(container, node);\n-        } else { // has to be \u0027COMPLETE\u0027\n-          LOG.info(\"DEBUG --- Container FINISHED: \" + container.getId());\n-          completedContainer(getRMContainer(container.getId()), \n-              RMContainerEventType.FINISHED);\n-        }\n-      }\n+    // Processing the newly launched containers\n+    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n+      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n+    }\n+\n+    // Process completed containers\n+    for (ContainerStatus completedContainer : completedContainers) {\n+      ContainerId containerId \u003d completedContainer.getContainerId();\n+      LOG.info(\"DEBUG --- Container FINISHED: \" + containerId);\n+      completedContainer(getRMContainer(containerId), \n+          completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     LOG.info(\"DEBUG -- Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       SchedulerApp reservedApplication \u003d \n           getApplication(reservedContainer.getApplicationAttemptId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n       queue.assignContainers(clusterResource, node);\n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n           node.getReservedContainer().getContainerId().getAppId());\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void nodeUpdate(RMNode nm, \n      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n      List\u003cContainerStatus\u003e completedContainers) {\n    LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    \n    SchedulerNode node \u003d getNode(nm.getNodeID());\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.info(\"DEBUG --- Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    LOG.info(\"DEBUG -- Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      SchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      queue.assignContainers(clusterResource, node);\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getAppId());\n    }\n\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[nm-RMNode, containers-Map\u003cApplicationId,List\u003cContainer\u003e\u003e]",
            "newValue": "[nm-RMNode, newlyLaunchedContainers-List\u003cContainerStatus\u003e, completedContainers-List\u003cContainerStatus\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-2933. Change allocate call to return ContainerStatus for completed containers rather than Container.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169484 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/09/11 10:26 AM",
          "commitName": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "08/09/11 11:26 AM",
          "commitNameOld": "1f46b991da9b91585608a0babd3eda39485dce09",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 2.96,
          "commitsBetweenForRepo": 24,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,51 @@\n   private synchronized void nodeUpdate(RMNode nm, \n-      Map\u003cApplicationId, List\u003cContainer\u003e\u003e containers ) {\n+      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n+      List\u003cContainerStatus\u003e completedContainers) {\n     LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n     \n     SchedulerNode node \u003d getNode(nm.getNodeID());\n \n-    // Processing the current containers running/finished on node\n-    for (List\u003cContainer\u003e appContainers : containers.values()) {\n-      for (Container container : appContainers) {\n-        if (container.getState() \u003d\u003d ContainerState.RUNNING) {\n-          containerLaunchedOnNode(container, node);\n-        } else { // has to be \u0027COMPLETE\u0027\n-          LOG.info(\"DEBUG --- Container FINISHED: \" + container.getId());\n-          completedContainer(getRMContainer(container.getId()), \n-              RMContainerEventType.FINISHED);\n-        }\n-      }\n+    // Processing the newly launched containers\n+    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n+      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n+    }\n+\n+    // Process completed containers\n+    for (ContainerStatus completedContainer : completedContainers) {\n+      ContainerId containerId \u003d completedContainer.getContainerId();\n+      LOG.info(\"DEBUG --- Container FINISHED: \" + containerId);\n+      completedContainer(getRMContainer(containerId), \n+          completedContainer, RMContainerEventType.FINISHED);\n     }\n \n     // Now node data structures are upto date and ready for scheduling.\n     LOG.info(\"DEBUG -- Node being looked for scheduling \" + nm\n         + \" availableResource: \" + node.getAvailableResource());\n \n     // Assign new containers...\n     // 1. Check for reserved applications\n     // 2. Schedule if there are no reservations\n \n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       SchedulerApp reservedApplication \u003d \n           getApplication(reservedContainer.getApplicationAttemptId());\n       \n       // Try to fulfill the reservation\n       LOG.info(\"Trying to fulfill reservation for application \" + \n           reservedApplication.getApplicationId() + \" on node: \" + nm);\n       \n       LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n       queue.assignContainers(clusterResource, node);\n     }\n \n     // Try to schedule more if there are no reservations to fulfill\n     if (node.getReservedContainer() \u003d\u003d null) {\n       root.assignContainers(clusterResource, node);\n     } else {\n       LOG.info(\"Skipping scheduling since node \" + nm + \n           \" is reserved by application \" + \n           node.getReservedContainer().getContainerId().getAppId());\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void nodeUpdate(RMNode nm, \n      List\u003cContainerStatus\u003e newlyLaunchedContainers,\n      List\u003cContainerStatus\u003e completedContainers) {\n    LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    \n    SchedulerNode node \u003d getNode(nm.getNodeID());\n\n    // Processing the newly launched containers\n    for (ContainerStatus launchedContainer : newlyLaunchedContainers) {\n      containerLaunchedOnNode(launchedContainer.getContainerId(), node);\n    }\n\n    // Process completed containers\n    for (ContainerStatus completedContainer : completedContainers) {\n      ContainerId containerId \u003d completedContainer.getContainerId();\n      LOG.info(\"DEBUG --- Container FINISHED: \" + containerId);\n      completedContainer(getRMContainer(containerId), \n          completedContainer, RMContainerEventType.FINISHED);\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    LOG.info(\"DEBUG -- Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      SchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      queue.assignContainers(clusterResource, node);\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getAppId());\n    }\n\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm, \n      Map\u003cApplicationId, List\u003cContainer\u003e\u003e containers ) {\n    LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    \n    SchedulerNode node \u003d getNode(nm.getNodeID());\n\n    // Processing the current containers running/finished on node\n    for (List\u003cContainer\u003e appContainers : containers.values()) {\n      for (Container container : appContainers) {\n        if (container.getState() \u003d\u003d ContainerState.RUNNING) {\n          containerLaunchedOnNode(container, node);\n        } else { // has to be \u0027COMPLETE\u0027\n          LOG.info(\"DEBUG --- Container FINISHED: \" + container.getId());\n          completedContainer(getRMContainer(container.getId()), \n              RMContainerEventType.FINISHED);\n        }\n      }\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    LOG.info(\"DEBUG -- Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      SchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      queue.assignContainers(clusterResource, node);\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getAppId());\n    }\n\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,50 @@\n+  private synchronized void nodeUpdate(RMNode nm, \n+      Map\u003cApplicationId, List\u003cContainer\u003e\u003e containers ) {\n+    LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n+    \n+    SchedulerNode node \u003d getNode(nm.getNodeID());\n+\n+    // Processing the current containers running/finished on node\n+    for (List\u003cContainer\u003e appContainers : containers.values()) {\n+      for (Container container : appContainers) {\n+        if (container.getState() \u003d\u003d ContainerState.RUNNING) {\n+          containerLaunchedOnNode(container, node);\n+        } else { // has to be \u0027COMPLETE\u0027\n+          LOG.info(\"DEBUG --- Container FINISHED: \" + container.getId());\n+          completedContainer(getRMContainer(container.getId()), \n+              RMContainerEventType.FINISHED);\n+        }\n+      }\n+    }\n+\n+    // Now node data structures are upto date and ready for scheduling.\n+    LOG.info(\"DEBUG -- Node being looked for scheduling \" + nm\n+        + \" availableResource: \" + node.getAvailableResource());\n+\n+    // Assign new containers...\n+    // 1. Check for reserved applications\n+    // 2. Schedule if there are no reservations\n+\n+    RMContainer reservedContainer \u003d node.getReservedContainer();\n+    if (reservedContainer !\u003d null) {\n+      SchedulerApp reservedApplication \u003d \n+          getApplication(reservedContainer.getApplicationAttemptId());\n+      \n+      // Try to fulfill the reservation\n+      LOG.info(\"Trying to fulfill reservation for application \" + \n+          reservedApplication.getApplicationId() + \" on node: \" + nm);\n+      \n+      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n+      queue.assignContainers(clusterResource, node);\n+    }\n+\n+    // Try to schedule more if there are no reservations to fulfill\n+    if (node.getReservedContainer() \u003d\u003d null) {\n+      root.assignContainers(clusterResource, node);\n+    } else {\n+      LOG.info(\"Skipping scheduling since node \" + nm + \n+          \" is reserved by application \" + \n+          node.getReservedContainer().getContainerId().getAppId());\n+    }\n+\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void nodeUpdate(RMNode nm, \n      Map\u003cApplicationId, List\u003cContainer\u003e\u003e containers ) {\n    LOG.info(\"nodeUpdate: \" + nm + \" clusterResources: \" + clusterResource);\n    \n    SchedulerNode node \u003d getNode(nm.getNodeID());\n\n    // Processing the current containers running/finished on node\n    for (List\u003cContainer\u003e appContainers : containers.values()) {\n      for (Container container : appContainers) {\n        if (container.getState() \u003d\u003d ContainerState.RUNNING) {\n          containerLaunchedOnNode(container, node);\n        } else { // has to be \u0027COMPLETE\u0027\n          LOG.info(\"DEBUG --- Container FINISHED: \" + container.getId());\n          completedContainer(getRMContainer(container.getId()), \n              RMContainerEventType.FINISHED);\n        }\n      }\n    }\n\n    // Now node data structures are upto date and ready for scheduling.\n    LOG.info(\"DEBUG -- Node being looked for scheduling \" + nm\n        + \" availableResource: \" + node.getAvailableResource());\n\n    // Assign new containers...\n    // 1. Check for reserved applications\n    // 2. Schedule if there are no reservations\n\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      SchedulerApp reservedApplication \u003d \n          getApplication(reservedContainer.getApplicationAttemptId());\n      \n      // Try to fulfill the reservation\n      LOG.info(\"Trying to fulfill reservation for application \" + \n          reservedApplication.getApplicationId() + \" on node: \" + nm);\n      \n      LeafQueue queue \u003d ((LeafQueue)reservedApplication.getQueue());\n      queue.assignContainers(clusterResource, node);\n    }\n\n    // Try to schedule more if there are no reservations to fulfill\n    if (node.getReservedContainer() \u003d\u003d null) {\n      root.assignContainers(clusterResource, node);\n    } else {\n      LOG.info(\"Skipping scheduling since node \" + nm + \n          \" is reserved by application \" + \n          node.getReservedContainer().getContainerId().getAppId());\n    }\n\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}