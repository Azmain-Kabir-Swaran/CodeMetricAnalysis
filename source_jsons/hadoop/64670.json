{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AFileSystem.java",
  "functionName": "copyFile",
  "functionId": "copyFile___srcKey-String__dstKey-String__size-long__srcAttributes-S3ObjectAttributes__readContext-S3AReadOpContext",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
  "functionStartLine": 3426,
  "functionEndLine": 3515,
  "numCommitsSeen": 272,
  "timeTaken": 9739,
  "changeHistory": [
    "f864ef742960b805b430841c3a1ccb9e11bcc77c",
    "9221704f857e33a5f9e00c19d3705e46e94f427b",
    "a36274d69947648dbe82721220cc5240ec5d396d",
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744",
    "839b690ed5edc2ac4984640d58c005bb63cd8a07",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
    "39ec1515a205952eda7e171408a8b83eceb4abde",
    "27c4e90efce04e1b1302f668b5eb22412e00d033",
    "256c82fe2981748cd0befc5490d8118d139908f9",
    "d5403747b57b1e294e533ce17f197e7be8f5339c",
    "4e7ad4f0a88bd36bc91db6b1bd311d7f5c6bebee",
    "2e98ad34ce64a9e5184c53447004de20a637f927",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0"
  ],
  "changeHistoryShort": {
    "f864ef742960b805b430841c3a1ccb9e11bcc77c": "Ybodychange",
    "9221704f857e33a5f9e00c19d3705e46e94f427b": "Ybodychange",
    "a36274d69947648dbe82721220cc5240ec5d396d": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744": "Ymultichange(Yexceptionschange,Ybodychange)",
    "839b690ed5edc2ac4984640d58c005bb63cd8a07": "Ybodychange",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": "Ybodychange",
    "39ec1515a205952eda7e171408a8b83eceb4abde": "Ymultichange(Yexceptionschange,Ybodychange)",
    "27c4e90efce04e1b1302f668b5eb22412e00d033": "Ymultichange(Yparameterchange,Ybodychange)",
    "256c82fe2981748cd0befc5490d8118d139908f9": "Ybodychange",
    "d5403747b57b1e294e533ce17f197e7be8f5339c": "Ybodychange",
    "4e7ad4f0a88bd36bc91db6b1bd311d7f5c6bebee": "Ybodychange",
    "2e98ad34ce64a9e5184c53447004de20a637f927": "Ybodychange",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f864ef742960b805b430841c3a1ccb9e11bcc77c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16794. S3A reverts KMS encryption to the bucket\u0027s default KMS key in rename/copy.\n\n\r\nAreContributed by Mukund Thakur.\r\n\r\nThis addresses an issue which surfaced with KMS encryption: the wrong\r\nKMS key could be picked up in the S3 COPY operation, so\r\nrenamed files, while encrypted, would end up with the\r\nbucket default key.\r\n\r\nAs well as adding tests in the new suite\r\nITestS3AEncryptionWithDefaultS3Settings,\r\nAbstractSTestS3AHugeFiles has a new test method to\r\nverify that the encryption settings also work\r\nfor large files copied via multipart operations.\r\n",
      "commitDate": "02/03/20 9:31 AM",
      "commitName": "f864ef742960b805b430841c3a1ccb9e11bcc77c",
      "commitAuthor": "Mukund Thakur",
      "commitDateOld": "21/02/20 5:44 AM",
      "commitNameOld": "e77767bb1e8dfb8b0bd7af4664c900f7238b4fa0",
      "commitAuthorOld": "Mukund Thakur",
      "daysBetweenCommits": 10.16,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n   private CopyResult copyFile(String srcKey, String dstKey, long size,\n       S3ObjectAttributes srcAttributes, S3AReadOpContext readContext)\n       throws IOException, InterruptedIOException  {\n     LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n     ProgressListener progressListener \u003d progressEvent -\u003e {\n       switch (progressEvent.getEventType()) {\n       case TRANSFER_PART_COMPLETED_EVENT:\n         incrementWriteOperations();\n         break;\n       default:\n         break;\n       }\n     };\n \n     ChangeTracker changeTracker \u003d new ChangeTracker(\n         keyToQualifiedPath(srcKey).toString(),\n         changeDetectionPolicy,\n         readContext.instrumentation.newInputStreamStatistics()\n             .getVersionMismatchCounter(),\n         srcAttributes);\n \n     String action \u003d \"copyFile(\" + srcKey + \", \" + dstKey + \")\";\n     Invoker readInvoker \u003d readContext.getReadInvoker();\n \n     ObjectMetadata srcom;\n     try {\n       srcom \u003d once(action, srcKey,\n           () -\u003e\n               getObjectMetadata(srcKey, changeTracker, readInvoker, \"copy\"));\n     } catch (FileNotFoundException e) {\n       // if rename fails at this point it means that the expected file was not\n       // found.\n       // The cause is believed to always be one of\n       //  - File was deleted since LIST/S3Guard metastore.list.() knew of it.\n       //  - S3Guard is asking for a specific version and it\u0027s been removed by\n       //    lifecycle rules.\n       //  - there\u0027s a 404 cached in the S3 load balancers.\n       LOG.debug(\"getObjectMetadata({}) failed to find an expected file\",\n           srcKey, e);\n       // We create an exception, but the text depends on the S3Guard state\n       String message \u003d hasMetadataStore()\n           ? RemoteFileChangedException.FILE_NEVER_FOUND\n           : RemoteFileChangedException.FILE_NOT_FOUND_SINGLE_ATTEMPT;\n       throw new RemoteFileChangedException(\n           keyToQualifiedPath(srcKey).toString(),\n           action,\n           message,\n           e);\n     }\n     ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n     setOptionalObjectMetadata(dstom);\n \n     return readInvoker.retry(\n         action, srcKey,\n         true,\n         () -\u003e {\n           CopyObjectRequest copyObjectRequest \u003d\n               new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n           changeTracker.maybeApplyConstraint(copyObjectRequest);\n \n-          setOptionalCopyObjectRequestParameters(copyObjectRequest);\n+          setOptionalCopyObjectRequestParameters(srcom, copyObjectRequest);\n           copyObjectRequest.setCannedAccessControlList(cannedACL);\n           copyObjectRequest.setNewObjectMetadata(dstom);\n           Optional.ofNullable(srcom.getStorageClass())\n               .ifPresent(copyObjectRequest::setStorageClass);\n           Copy copy \u003d transfers.copy(copyObjectRequest);\n           copy.addProgressListener(progressListener);\n           CopyOutcome copyOutcome \u003d CopyOutcome.waitForCopy(copy);\n           InterruptedException interruptedException \u003d\n               copyOutcome.getInterruptedException();\n           if (interruptedException !\u003d null) {\n             // copy interrupted: convert to an IOException.\n             throw (IOException)new InterruptedIOException(\n                 \"Interrupted copying \" + srcKey\n                     + \" to \" + dstKey + \", cancelling\")\n                 .initCause(interruptedException);\n           }\n           SdkBaseException awsException \u003d copyOutcome.getAwsException();\n           if (awsException !\u003d null) {\n             changeTracker.processException(awsException, \"copy\");\n             throw awsException;\n           }\n           CopyResult result \u003d copyOutcome.getCopyResult();\n           changeTracker.processResponse(result);\n           incrementWriteOperations();\n           instrumentation.filesCopied(1, size);\n           return result;\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private CopyResult copyFile(String srcKey, String dstKey, long size,\n      S3ObjectAttributes srcAttributes, S3AReadOpContext readContext)\n      throws IOException, InterruptedIOException  {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    ProgressListener progressListener \u003d progressEvent -\u003e {\n      switch (progressEvent.getEventType()) {\n      case TRANSFER_PART_COMPLETED_EVENT:\n        incrementWriteOperations();\n        break;\n      default:\n        break;\n      }\n    };\n\n    ChangeTracker changeTracker \u003d new ChangeTracker(\n        keyToQualifiedPath(srcKey).toString(),\n        changeDetectionPolicy,\n        readContext.instrumentation.newInputStreamStatistics()\n            .getVersionMismatchCounter(),\n        srcAttributes);\n\n    String action \u003d \"copyFile(\" + srcKey + \", \" + dstKey + \")\";\n    Invoker readInvoker \u003d readContext.getReadInvoker();\n\n    ObjectMetadata srcom;\n    try {\n      srcom \u003d once(action, srcKey,\n          () -\u003e\n              getObjectMetadata(srcKey, changeTracker, readInvoker, \"copy\"));\n    } catch (FileNotFoundException e) {\n      // if rename fails at this point it means that the expected file was not\n      // found.\n      // The cause is believed to always be one of\n      //  - File was deleted since LIST/S3Guard metastore.list.() knew of it.\n      //  - S3Guard is asking for a specific version and it\u0027s been removed by\n      //    lifecycle rules.\n      //  - there\u0027s a 404 cached in the S3 load balancers.\n      LOG.debug(\"getObjectMetadata({}) failed to find an expected file\",\n          srcKey, e);\n      // We create an exception, but the text depends on the S3Guard state\n      String message \u003d hasMetadataStore()\n          ? RemoteFileChangedException.FILE_NEVER_FOUND\n          : RemoteFileChangedException.FILE_NOT_FOUND_SINGLE_ATTEMPT;\n      throw new RemoteFileChangedException(\n          keyToQualifiedPath(srcKey).toString(),\n          action,\n          message,\n          e);\n    }\n    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n    setOptionalObjectMetadata(dstom);\n\n    return readInvoker.retry(\n        action, srcKey,\n        true,\n        () -\u003e {\n          CopyObjectRequest copyObjectRequest \u003d\n              new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n          changeTracker.maybeApplyConstraint(copyObjectRequest);\n\n          setOptionalCopyObjectRequestParameters(srcom, copyObjectRequest);\n          copyObjectRequest.setCannedAccessControlList(cannedACL);\n          copyObjectRequest.setNewObjectMetadata(dstom);\n          Optional.ofNullable(srcom.getStorageClass())\n              .ifPresent(copyObjectRequest::setStorageClass);\n          Copy copy \u003d transfers.copy(copyObjectRequest);\n          copy.addProgressListener(progressListener);\n          CopyOutcome copyOutcome \u003d CopyOutcome.waitForCopy(copy);\n          InterruptedException interruptedException \u003d\n              copyOutcome.getInterruptedException();\n          if (interruptedException !\u003d null) {\n            // copy interrupted: convert to an IOException.\n            throw (IOException)new InterruptedIOException(\n                \"Interrupted copying \" + srcKey\n                    + \" to \" + dstKey + \", cancelling\")\n                .initCause(interruptedException);\n          }\n          SdkBaseException awsException \u003d copyOutcome.getAwsException();\n          if (awsException !\u003d null) {\n            changeTracker.processException(awsException, \"copy\");\n            throw awsException;\n          }\n          CopyResult result \u003d copyOutcome.getCopyResult();\n          changeTracker.processResponse(result);\n          incrementWriteOperations();\n          instrumentation.filesCopied(1, size);\n          return result;\n        });\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "9221704f857e33a5f9e00c19d3705e46e94f427b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16490. Avoid/handle cached 404s during S3A file creation.\n\nContributed by Steve Loughran.\n\nThis patch avoids issuing any HEAD path request when creating a file with overwrite\u003dtrue,\nso 404s will not end up in the S3 load balancers unless someone calls getFileStatus/exists/isFile\nin their own code.\n\nThe Hadoop FsShell CommandWithDestination class is modified to not register uncreated files\nfor deleteOnExit(), because that calls exists() and so can place the 404 in the cache, even\nafter S3A is patched to not do it itself.\n\nBecause S3Guard knows when a file should be present, it adds a special FileNotFound retry policy\nindependently configurable from other retry policies; it is also exponential, but with\ndifferent parameters. This is because every HEAD request will refresh any 404 cached in\nthe S3 Load Balancers. It\u0027s not enough to retry: we have to have a suitable gap between\nattempts to (hopefully) ensure any cached entry wil be gone.\n\nThe options and values are:\n\nfs.s3a.s3guard.consistency.retry.interval: 2s\nfs.s3a.s3guard.consistency.retry.limit: 7\n\nThe S3A copy() method used during rename() raises a RemoteFileChangedException which is not caught\nso not downgraded to false. Thus: when a rename is unrecoverable, this fact is propagated.\n\nCopy operations without S3Guard lack the confidence that the file exists, so don\u0027t retry the same way:\nit will fail fast with a different error message. However, because create(path, overwrite\u003dfalse) no\nlonger does HEAD path, we can at least be confident that S3A itself is not creating those cached\n404 markers.\n\nChange-Id: Ia7807faad8b9a8546836cb19f816cccf17cca26d\n",
      "commitDate": "11/09/19 8:46 AM",
      "commitName": "9221704f857e33a5f9e00c19d3705e46e94f427b",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/09/19 6:25 AM",
      "commitNameOld": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 6.1,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,90 @@\n   private CopyResult copyFile(String srcKey, String dstKey, long size,\n       S3ObjectAttributes srcAttributes, S3AReadOpContext readContext)\n       throws IOException, InterruptedIOException  {\n     LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n     ProgressListener progressListener \u003d progressEvent -\u003e {\n       switch (progressEvent.getEventType()) {\n       case TRANSFER_PART_COMPLETED_EVENT:\n         incrementWriteOperations();\n         break;\n       default:\n         break;\n       }\n     };\n \n     ChangeTracker changeTracker \u003d new ChangeTracker(\n         keyToQualifiedPath(srcKey).toString(),\n         changeDetectionPolicy,\n         readContext.instrumentation.newInputStreamStatistics()\n             .getVersionMismatchCounter(),\n         srcAttributes);\n \n     String action \u003d \"copyFile(\" + srcKey + \", \" + dstKey + \")\";\n     Invoker readInvoker \u003d readContext.getReadInvoker();\n \n-    ObjectMetadata srcom \u003d\n-        once(action, srcKey,\n-            () -\u003e\n-                getObjectMetadata(srcKey, changeTracker, readInvoker, \"copy\"));\n+    ObjectMetadata srcom;\n+    try {\n+      srcom \u003d once(action, srcKey,\n+          () -\u003e\n+              getObjectMetadata(srcKey, changeTracker, readInvoker, \"copy\"));\n+    } catch (FileNotFoundException e) {\n+      // if rename fails at this point it means that the expected file was not\n+      // found.\n+      // The cause is believed to always be one of\n+      //  - File was deleted since LIST/S3Guard metastore.list.() knew of it.\n+      //  - S3Guard is asking for a specific version and it\u0027s been removed by\n+      //    lifecycle rules.\n+      //  - there\u0027s a 404 cached in the S3 load balancers.\n+      LOG.debug(\"getObjectMetadata({}) failed to find an expected file\",\n+          srcKey, e);\n+      // We create an exception, but the text depends on the S3Guard state\n+      String message \u003d hasMetadataStore()\n+          ? RemoteFileChangedException.FILE_NEVER_FOUND\n+          : RemoteFileChangedException.FILE_NOT_FOUND_SINGLE_ATTEMPT;\n+      throw new RemoteFileChangedException(\n+          keyToQualifiedPath(srcKey).toString(),\n+          action,\n+          message,\n+          e);\n+    }\n     ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n     setOptionalObjectMetadata(dstom);\n \n     return readInvoker.retry(\n         action, srcKey,\n         true,\n         () -\u003e {\n           CopyObjectRequest copyObjectRequest \u003d\n               new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n           changeTracker.maybeApplyConstraint(copyObjectRequest);\n \n           setOptionalCopyObjectRequestParameters(copyObjectRequest);\n           copyObjectRequest.setCannedAccessControlList(cannedACL);\n           copyObjectRequest.setNewObjectMetadata(dstom);\n           Optional.ofNullable(srcom.getStorageClass())\n               .ifPresent(copyObjectRequest::setStorageClass);\n           Copy copy \u003d transfers.copy(copyObjectRequest);\n           copy.addProgressListener(progressListener);\n           CopyOutcome copyOutcome \u003d CopyOutcome.waitForCopy(copy);\n           InterruptedException interruptedException \u003d\n               copyOutcome.getInterruptedException();\n           if (interruptedException !\u003d null) {\n             // copy interrupted: convert to an IOException.\n             throw (IOException)new InterruptedIOException(\n                 \"Interrupted copying \" + srcKey\n                     + \" to \" + dstKey + \", cancelling\")\n                 .initCause(interruptedException);\n           }\n           SdkBaseException awsException \u003d copyOutcome.getAwsException();\n           if (awsException !\u003d null) {\n             changeTracker.processException(awsException, \"copy\");\n             throw awsException;\n           }\n           CopyResult result \u003d copyOutcome.getCopyResult();\n           changeTracker.processResponse(result);\n           incrementWriteOperations();\n           instrumentation.filesCopied(1, size);\n           return result;\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private CopyResult copyFile(String srcKey, String dstKey, long size,\n      S3ObjectAttributes srcAttributes, S3AReadOpContext readContext)\n      throws IOException, InterruptedIOException  {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    ProgressListener progressListener \u003d progressEvent -\u003e {\n      switch (progressEvent.getEventType()) {\n      case TRANSFER_PART_COMPLETED_EVENT:\n        incrementWriteOperations();\n        break;\n      default:\n        break;\n      }\n    };\n\n    ChangeTracker changeTracker \u003d new ChangeTracker(\n        keyToQualifiedPath(srcKey).toString(),\n        changeDetectionPolicy,\n        readContext.instrumentation.newInputStreamStatistics()\n            .getVersionMismatchCounter(),\n        srcAttributes);\n\n    String action \u003d \"copyFile(\" + srcKey + \", \" + dstKey + \")\";\n    Invoker readInvoker \u003d readContext.getReadInvoker();\n\n    ObjectMetadata srcom;\n    try {\n      srcom \u003d once(action, srcKey,\n          () -\u003e\n              getObjectMetadata(srcKey, changeTracker, readInvoker, \"copy\"));\n    } catch (FileNotFoundException e) {\n      // if rename fails at this point it means that the expected file was not\n      // found.\n      // The cause is believed to always be one of\n      //  - File was deleted since LIST/S3Guard metastore.list.() knew of it.\n      //  - S3Guard is asking for a specific version and it\u0027s been removed by\n      //    lifecycle rules.\n      //  - there\u0027s a 404 cached in the S3 load balancers.\n      LOG.debug(\"getObjectMetadata({}) failed to find an expected file\",\n          srcKey, e);\n      // We create an exception, but the text depends on the S3Guard state\n      String message \u003d hasMetadataStore()\n          ? RemoteFileChangedException.FILE_NEVER_FOUND\n          : RemoteFileChangedException.FILE_NOT_FOUND_SINGLE_ATTEMPT;\n      throw new RemoteFileChangedException(\n          keyToQualifiedPath(srcKey).toString(),\n          action,\n          message,\n          e);\n    }\n    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n    setOptionalObjectMetadata(dstom);\n\n    return readInvoker.retry(\n        action, srcKey,\n        true,\n        () -\u003e {\n          CopyObjectRequest copyObjectRequest \u003d\n              new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n          changeTracker.maybeApplyConstraint(copyObjectRequest);\n\n          setOptionalCopyObjectRequestParameters(copyObjectRequest);\n          copyObjectRequest.setCannedAccessControlList(cannedACL);\n          copyObjectRequest.setNewObjectMetadata(dstom);\n          Optional.ofNullable(srcom.getStorageClass())\n              .ifPresent(copyObjectRequest::setStorageClass);\n          Copy copy \u003d transfers.copy(copyObjectRequest);\n          copy.addProgressListener(progressListener);\n          CopyOutcome copyOutcome \u003d CopyOutcome.waitForCopy(copy);\n          InterruptedException interruptedException \u003d\n              copyOutcome.getInterruptedException();\n          if (interruptedException !\u003d null) {\n            // copy interrupted: convert to an IOException.\n            throw (IOException)new InterruptedIOException(\n                \"Interrupted copying \" + srcKey\n                    + \" to \" + dstKey + \", cancelling\")\n                .initCause(interruptedException);\n          }\n          SdkBaseException awsException \u003d copyOutcome.getAwsException();\n          if (awsException !\u003d null) {\n            changeTracker.processException(awsException, \"copy\");\n            throw awsException;\n          }\n          CopyResult result \u003d copyOutcome.getCopyResult();\n          changeTracker.processResponse(result);\n          incrementWriteOperations();\n          instrumentation.filesCopied(1, size);\n          return result;\n        });\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "a36274d69947648dbe82721220cc5240ec5d396d": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
      "commitDate": "19/05/19 2:29 PM",
      "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthor": "Ben Roling",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
          "commitDate": "19/05/19 2:29 PM",
          "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
          "commitAuthor": "Ben Roling",
          "commitDateOld": "30/04/19 3:53 AM",
          "commitNameOld": "0af4011580878566213016af0c32633eabd15100",
          "commitAuthorOld": "Ben Roling",
          "daysBetweenCommits": 19.44,
          "commitsBetweenForRepo": 90,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,69 @@\n-  private void copyFile(String srcKey, String dstKey, long size)\n+  private CopyResult copyFile(String srcKey, String dstKey, long size,\n+      S3ObjectAttributes srcAttributes, S3AReadOpContext readContext)\n       throws IOException, InterruptedIOException  {\n     LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n     ProgressListener progressListener \u003d progressEvent -\u003e {\n       switch (progressEvent.getEventType()) {\n       case TRANSFER_PART_COMPLETED_EVENT:\n         incrementWriteOperations();\n         break;\n       default:\n         break;\n       }\n     };\n \n-    once(\"copyFile(\" + srcKey + \", \" + dstKey + \")\", srcKey,\n+    ChangeTracker changeTracker \u003d new ChangeTracker(\n+        keyToQualifiedPath(srcKey).toString(),\n+        changeDetectionPolicy,\n+        readContext.instrumentation.newInputStreamStatistics()\n+            .getVersionMismatchCounter(),\n+        srcAttributes);\n+\n+    String action \u003d \"copyFile(\" + srcKey + \", \" + dstKey + \")\";\n+    Invoker readInvoker \u003d readContext.getReadInvoker();\n+\n+    ObjectMetadata srcom \u003d\n+        once(action, srcKey,\n+            () -\u003e\n+                getObjectMetadata(srcKey, changeTracker, readInvoker, \"copy\"));\n+    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n+    setOptionalObjectMetadata(dstom);\n+\n+    return readInvoker.retry(\n+        action, srcKey,\n+        true,\n         () -\u003e {\n-          ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n-          ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n-          setOptionalObjectMetadata(dstom);\n           CopyObjectRequest copyObjectRequest \u003d\n               new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n+          changeTracker.maybeApplyConstraint(copyObjectRequest);\n+\n           setOptionalCopyObjectRequestParameters(copyObjectRequest);\n           copyObjectRequest.setCannedAccessControlList(cannedACL);\n           copyObjectRequest.setNewObjectMetadata(dstom);\n+          Optional.ofNullable(srcom.getStorageClass())\n+              .ifPresent(copyObjectRequest::setStorageClass);\n           Copy copy \u003d transfers.copy(copyObjectRequest);\n           copy.addProgressListener(progressListener);\n-          try {\n-            copy.waitForCopyResult();\n-            incrementWriteOperations();\n-            instrumentation.filesCopied(1, size);\n-          } catch (InterruptedException e) {\n-            throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n-                + \" to \" + dstKey + \", cancelling\");\n+          CopyOutcome copyOutcome \u003d CopyOutcome.waitForCopy(copy);\n+          InterruptedException interruptedException \u003d\n+              copyOutcome.getInterruptedException();\n+          if (interruptedException !\u003d null) {\n+            // copy interrupted: convert to an IOException.\n+            throw (IOException)new InterruptedIOException(\n+                \"Interrupted copying \" + srcKey\n+                    + \" to \" + dstKey + \", cancelling\")\n+                .initCause(interruptedException);\n           }\n+          SdkBaseException awsException \u003d copyOutcome.getAwsException();\n+          if (awsException !\u003d null) {\n+            changeTracker.processException(awsException, \"copy\");\n+            throw awsException;\n+          }\n+          CopyResult result \u003d copyOutcome.getCopyResult();\n+          changeTracker.processResponse(result);\n+          incrementWriteOperations();\n+          instrumentation.filesCopied(1, size);\n+          return result;\n         });\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private CopyResult copyFile(String srcKey, String dstKey, long size,\n      S3ObjectAttributes srcAttributes, S3AReadOpContext readContext)\n      throws IOException, InterruptedIOException  {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    ProgressListener progressListener \u003d progressEvent -\u003e {\n      switch (progressEvent.getEventType()) {\n      case TRANSFER_PART_COMPLETED_EVENT:\n        incrementWriteOperations();\n        break;\n      default:\n        break;\n      }\n    };\n\n    ChangeTracker changeTracker \u003d new ChangeTracker(\n        keyToQualifiedPath(srcKey).toString(),\n        changeDetectionPolicy,\n        readContext.instrumentation.newInputStreamStatistics()\n            .getVersionMismatchCounter(),\n        srcAttributes);\n\n    String action \u003d \"copyFile(\" + srcKey + \", \" + dstKey + \")\";\n    Invoker readInvoker \u003d readContext.getReadInvoker();\n\n    ObjectMetadata srcom \u003d\n        once(action, srcKey,\n            () -\u003e\n                getObjectMetadata(srcKey, changeTracker, readInvoker, \"copy\"));\n    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n    setOptionalObjectMetadata(dstom);\n\n    return readInvoker.retry(\n        action, srcKey,\n        true,\n        () -\u003e {\n          CopyObjectRequest copyObjectRequest \u003d\n              new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n          changeTracker.maybeApplyConstraint(copyObjectRequest);\n\n          setOptionalCopyObjectRequestParameters(copyObjectRequest);\n          copyObjectRequest.setCannedAccessControlList(cannedACL);\n          copyObjectRequest.setNewObjectMetadata(dstom);\n          Optional.ofNullable(srcom.getStorageClass())\n              .ifPresent(copyObjectRequest::setStorageClass);\n          Copy copy \u003d transfers.copy(copyObjectRequest);\n          copy.addProgressListener(progressListener);\n          CopyOutcome copyOutcome \u003d CopyOutcome.waitForCopy(copy);\n          InterruptedException interruptedException \u003d\n              copyOutcome.getInterruptedException();\n          if (interruptedException !\u003d null) {\n            // copy interrupted: convert to an IOException.\n            throw (IOException)new InterruptedIOException(\n                \"Interrupted copying \" + srcKey\n                    + \" to \" + dstKey + \", cancelling\")\n                .initCause(interruptedException);\n          }\n          SdkBaseException awsException \u003d copyOutcome.getAwsException();\n          if (awsException !\u003d null) {\n            changeTracker.processException(awsException, \"copy\");\n            throw awsException;\n          }\n          CopyResult result \u003d copyOutcome.getCopyResult();\n          changeTracker.processResponse(result);\n          incrementWriteOperations();\n          instrumentation.filesCopied(1, size);\n          return result;\n        });\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[srcKey-String, dstKey-String, size-long]",
            "newValue": "[srcKey-String, dstKey-String, size-long, srcAttributes-S3ObjectAttributes, readContext-S3AReadOpContext]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
          "commitDate": "19/05/19 2:29 PM",
          "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
          "commitAuthor": "Ben Roling",
          "commitDateOld": "30/04/19 3:53 AM",
          "commitNameOld": "0af4011580878566213016af0c32633eabd15100",
          "commitAuthorOld": "Ben Roling",
          "daysBetweenCommits": 19.44,
          "commitsBetweenForRepo": 90,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,69 @@\n-  private void copyFile(String srcKey, String dstKey, long size)\n+  private CopyResult copyFile(String srcKey, String dstKey, long size,\n+      S3ObjectAttributes srcAttributes, S3AReadOpContext readContext)\n       throws IOException, InterruptedIOException  {\n     LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n     ProgressListener progressListener \u003d progressEvent -\u003e {\n       switch (progressEvent.getEventType()) {\n       case TRANSFER_PART_COMPLETED_EVENT:\n         incrementWriteOperations();\n         break;\n       default:\n         break;\n       }\n     };\n \n-    once(\"copyFile(\" + srcKey + \", \" + dstKey + \")\", srcKey,\n+    ChangeTracker changeTracker \u003d new ChangeTracker(\n+        keyToQualifiedPath(srcKey).toString(),\n+        changeDetectionPolicy,\n+        readContext.instrumentation.newInputStreamStatistics()\n+            .getVersionMismatchCounter(),\n+        srcAttributes);\n+\n+    String action \u003d \"copyFile(\" + srcKey + \", \" + dstKey + \")\";\n+    Invoker readInvoker \u003d readContext.getReadInvoker();\n+\n+    ObjectMetadata srcom \u003d\n+        once(action, srcKey,\n+            () -\u003e\n+                getObjectMetadata(srcKey, changeTracker, readInvoker, \"copy\"));\n+    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n+    setOptionalObjectMetadata(dstom);\n+\n+    return readInvoker.retry(\n+        action, srcKey,\n+        true,\n         () -\u003e {\n-          ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n-          ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n-          setOptionalObjectMetadata(dstom);\n           CopyObjectRequest copyObjectRequest \u003d\n               new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n+          changeTracker.maybeApplyConstraint(copyObjectRequest);\n+\n           setOptionalCopyObjectRequestParameters(copyObjectRequest);\n           copyObjectRequest.setCannedAccessControlList(cannedACL);\n           copyObjectRequest.setNewObjectMetadata(dstom);\n+          Optional.ofNullable(srcom.getStorageClass())\n+              .ifPresent(copyObjectRequest::setStorageClass);\n           Copy copy \u003d transfers.copy(copyObjectRequest);\n           copy.addProgressListener(progressListener);\n-          try {\n-            copy.waitForCopyResult();\n-            incrementWriteOperations();\n-            instrumentation.filesCopied(1, size);\n-          } catch (InterruptedException e) {\n-            throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n-                + \" to \" + dstKey + \", cancelling\");\n+          CopyOutcome copyOutcome \u003d CopyOutcome.waitForCopy(copy);\n+          InterruptedException interruptedException \u003d\n+              copyOutcome.getInterruptedException();\n+          if (interruptedException !\u003d null) {\n+            // copy interrupted: convert to an IOException.\n+            throw (IOException)new InterruptedIOException(\n+                \"Interrupted copying \" + srcKey\n+                    + \" to \" + dstKey + \", cancelling\")\n+                .initCause(interruptedException);\n           }\n+          SdkBaseException awsException \u003d copyOutcome.getAwsException();\n+          if (awsException !\u003d null) {\n+            changeTracker.processException(awsException, \"copy\");\n+            throw awsException;\n+          }\n+          CopyResult result \u003d copyOutcome.getCopyResult();\n+          changeTracker.processResponse(result);\n+          incrementWriteOperations();\n+          instrumentation.filesCopied(1, size);\n+          return result;\n         });\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private CopyResult copyFile(String srcKey, String dstKey, long size,\n      S3ObjectAttributes srcAttributes, S3AReadOpContext readContext)\n      throws IOException, InterruptedIOException  {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    ProgressListener progressListener \u003d progressEvent -\u003e {\n      switch (progressEvent.getEventType()) {\n      case TRANSFER_PART_COMPLETED_EVENT:\n        incrementWriteOperations();\n        break;\n      default:\n        break;\n      }\n    };\n\n    ChangeTracker changeTracker \u003d new ChangeTracker(\n        keyToQualifiedPath(srcKey).toString(),\n        changeDetectionPolicy,\n        readContext.instrumentation.newInputStreamStatistics()\n            .getVersionMismatchCounter(),\n        srcAttributes);\n\n    String action \u003d \"copyFile(\" + srcKey + \", \" + dstKey + \")\";\n    Invoker readInvoker \u003d readContext.getReadInvoker();\n\n    ObjectMetadata srcom \u003d\n        once(action, srcKey,\n            () -\u003e\n                getObjectMetadata(srcKey, changeTracker, readInvoker, \"copy\"));\n    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n    setOptionalObjectMetadata(dstom);\n\n    return readInvoker.retry(\n        action, srcKey,\n        true,\n        () -\u003e {\n          CopyObjectRequest copyObjectRequest \u003d\n              new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n          changeTracker.maybeApplyConstraint(copyObjectRequest);\n\n          setOptionalCopyObjectRequestParameters(copyObjectRequest);\n          copyObjectRequest.setCannedAccessControlList(cannedACL);\n          copyObjectRequest.setNewObjectMetadata(dstom);\n          Optional.ofNullable(srcom.getStorageClass())\n              .ifPresent(copyObjectRequest::setStorageClass);\n          Copy copy \u003d transfers.copy(copyObjectRequest);\n          copy.addProgressListener(progressListener);\n          CopyOutcome copyOutcome \u003d CopyOutcome.waitForCopy(copy);\n          InterruptedException interruptedException \u003d\n              copyOutcome.getInterruptedException();\n          if (interruptedException !\u003d null) {\n            // copy interrupted: convert to an IOException.\n            throw (IOException)new InterruptedIOException(\n                \"Interrupted copying \" + srcKey\n                    + \" to \" + dstKey + \", cancelling\")\n                .initCause(interruptedException);\n          }\n          SdkBaseException awsException \u003d copyOutcome.getAwsException();\n          if (awsException !\u003d null) {\n            changeTracker.processException(awsException, \"copy\");\n            throw awsException;\n          }\n          CopyResult result \u003d copyOutcome.getCopyResult();\n          changeTracker.processResponse(result);\n          incrementWriteOperations();\n          instrumentation.filesCopied(1, size);\n          return result;\n        });\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "CopyResult"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
          "commitDate": "19/05/19 2:29 PM",
          "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
          "commitAuthor": "Ben Roling",
          "commitDateOld": "30/04/19 3:53 AM",
          "commitNameOld": "0af4011580878566213016af0c32633eabd15100",
          "commitAuthorOld": "Ben Roling",
          "daysBetweenCommits": 19.44,
          "commitsBetweenForRepo": 90,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,69 @@\n-  private void copyFile(String srcKey, String dstKey, long size)\n+  private CopyResult copyFile(String srcKey, String dstKey, long size,\n+      S3ObjectAttributes srcAttributes, S3AReadOpContext readContext)\n       throws IOException, InterruptedIOException  {\n     LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n     ProgressListener progressListener \u003d progressEvent -\u003e {\n       switch (progressEvent.getEventType()) {\n       case TRANSFER_PART_COMPLETED_EVENT:\n         incrementWriteOperations();\n         break;\n       default:\n         break;\n       }\n     };\n \n-    once(\"copyFile(\" + srcKey + \", \" + dstKey + \")\", srcKey,\n+    ChangeTracker changeTracker \u003d new ChangeTracker(\n+        keyToQualifiedPath(srcKey).toString(),\n+        changeDetectionPolicy,\n+        readContext.instrumentation.newInputStreamStatistics()\n+            .getVersionMismatchCounter(),\n+        srcAttributes);\n+\n+    String action \u003d \"copyFile(\" + srcKey + \", \" + dstKey + \")\";\n+    Invoker readInvoker \u003d readContext.getReadInvoker();\n+\n+    ObjectMetadata srcom \u003d\n+        once(action, srcKey,\n+            () -\u003e\n+                getObjectMetadata(srcKey, changeTracker, readInvoker, \"copy\"));\n+    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n+    setOptionalObjectMetadata(dstom);\n+\n+    return readInvoker.retry(\n+        action, srcKey,\n+        true,\n         () -\u003e {\n-          ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n-          ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n-          setOptionalObjectMetadata(dstom);\n           CopyObjectRequest copyObjectRequest \u003d\n               new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n+          changeTracker.maybeApplyConstraint(copyObjectRequest);\n+\n           setOptionalCopyObjectRequestParameters(copyObjectRequest);\n           copyObjectRequest.setCannedAccessControlList(cannedACL);\n           copyObjectRequest.setNewObjectMetadata(dstom);\n+          Optional.ofNullable(srcom.getStorageClass())\n+              .ifPresent(copyObjectRequest::setStorageClass);\n           Copy copy \u003d transfers.copy(copyObjectRequest);\n           copy.addProgressListener(progressListener);\n-          try {\n-            copy.waitForCopyResult();\n-            incrementWriteOperations();\n-            instrumentation.filesCopied(1, size);\n-          } catch (InterruptedException e) {\n-            throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n-                + \" to \" + dstKey + \", cancelling\");\n+          CopyOutcome copyOutcome \u003d CopyOutcome.waitForCopy(copy);\n+          InterruptedException interruptedException \u003d\n+              copyOutcome.getInterruptedException();\n+          if (interruptedException !\u003d null) {\n+            // copy interrupted: convert to an IOException.\n+            throw (IOException)new InterruptedIOException(\n+                \"Interrupted copying \" + srcKey\n+                    + \" to \" + dstKey + \", cancelling\")\n+                .initCause(interruptedException);\n           }\n+          SdkBaseException awsException \u003d copyOutcome.getAwsException();\n+          if (awsException !\u003d null) {\n+            changeTracker.processException(awsException, \"copy\");\n+            throw awsException;\n+          }\n+          CopyResult result \u003d copyOutcome.getCopyResult();\n+          changeTracker.processResponse(result);\n+          incrementWriteOperations();\n+          instrumentation.filesCopied(1, size);\n+          return result;\n         });\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private CopyResult copyFile(String srcKey, String dstKey, long size,\n      S3ObjectAttributes srcAttributes, S3AReadOpContext readContext)\n      throws IOException, InterruptedIOException  {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    ProgressListener progressListener \u003d progressEvent -\u003e {\n      switch (progressEvent.getEventType()) {\n      case TRANSFER_PART_COMPLETED_EVENT:\n        incrementWriteOperations();\n        break;\n      default:\n        break;\n      }\n    };\n\n    ChangeTracker changeTracker \u003d new ChangeTracker(\n        keyToQualifiedPath(srcKey).toString(),\n        changeDetectionPolicy,\n        readContext.instrumentation.newInputStreamStatistics()\n            .getVersionMismatchCounter(),\n        srcAttributes);\n\n    String action \u003d \"copyFile(\" + srcKey + \", \" + dstKey + \")\";\n    Invoker readInvoker \u003d readContext.getReadInvoker();\n\n    ObjectMetadata srcom \u003d\n        once(action, srcKey,\n            () -\u003e\n                getObjectMetadata(srcKey, changeTracker, readInvoker, \"copy\"));\n    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n    setOptionalObjectMetadata(dstom);\n\n    return readInvoker.retry(\n        action, srcKey,\n        true,\n        () -\u003e {\n          CopyObjectRequest copyObjectRequest \u003d\n              new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n          changeTracker.maybeApplyConstraint(copyObjectRequest);\n\n          setOptionalCopyObjectRequestParameters(copyObjectRequest);\n          copyObjectRequest.setCannedAccessControlList(cannedACL);\n          copyObjectRequest.setNewObjectMetadata(dstom);\n          Optional.ofNullable(srcom.getStorageClass())\n              .ifPresent(copyObjectRequest::setStorageClass);\n          Copy copy \u003d transfers.copy(copyObjectRequest);\n          copy.addProgressListener(progressListener);\n          CopyOutcome copyOutcome \u003d CopyOutcome.waitForCopy(copy);\n          InterruptedException interruptedException \u003d\n              copyOutcome.getInterruptedException();\n          if (interruptedException !\u003d null) {\n            // copy interrupted: convert to an IOException.\n            throw (IOException)new InterruptedIOException(\n                \"Interrupted copying \" + srcKey\n                    + \" to \" + dstKey + \", cancelling\")\n                .initCause(interruptedException);\n          }\n          SdkBaseException awsException \u003d copyOutcome.getAwsException();\n          if (awsException !\u003d null) {\n            changeTracker.processException(awsException, \"copy\");\n            throw awsException;\n          }\n          CopyResult result \u003d copyOutcome.getCopyResult();\n          changeTracker.processResponse(result);\n          incrementWriteOperations();\n          instrumentation.filesCopied(1, size);\n          return result;\n        });\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-15079. ITestS3AFileOperationCost#testFakeDirectoryDeletion failing\nafter OutputCommitter patch.\nContributed by Steve Loughran\n",
      "commitDate": "15/01/18 3:33 AM",
      "commitName": "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-15079. ITestS3AFileOperationCost#testFakeDirectoryDeletion failing\nafter OutputCommitter patch.\nContributed by Steve Loughran\n",
          "commitDate": "15/01/18 3:33 AM",
          "commitName": "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "09/01/18 10:46 AM",
          "commitNameOld": "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 5.7,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,36 @@\n   private void copyFile(String srcKey, String dstKey, long size)\n-      throws IOException, InterruptedIOException, AmazonClientException {\n+      throws IOException, InterruptedIOException  {\n     LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n-    try {\n-      ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n-      ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n-      setOptionalObjectMetadata(dstom);\n-      CopyObjectRequest copyObjectRequest \u003d\n-          new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n-      setOptionalCopyObjectRequestParameters(copyObjectRequest);\n-      copyObjectRequest.setCannedAccessControlList(cannedACL);\n-      copyObjectRequest.setNewObjectMetadata(dstom);\n-\n-      ProgressListener progressListener \u003d new ProgressListener() {\n-        public void progressChanged(ProgressEvent progressEvent) {\n-          switch (progressEvent.getEventType()) {\n-            case TRANSFER_PART_COMPLETED_EVENT:\n-              incrementWriteOperations();\n-              break;\n-            default:\n-              break;\n-          }\n-        }\n-      };\n-\n-      Copy copy \u003d transfers.copy(copyObjectRequest);\n-      copy.addProgressListener(progressListener);\n-      try {\n-        copy.waitForCopyResult();\n+    ProgressListener progressListener \u003d progressEvent -\u003e {\n+      switch (progressEvent.getEventType()) {\n+      case TRANSFER_PART_COMPLETED_EVENT:\n         incrementWriteOperations();\n-        instrumentation.filesCopied(1, size);\n-      } catch (InterruptedException e) {\n-        throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n-            + \" to \" + dstKey + \", cancelling\");\n+        break;\n+      default:\n+        break;\n       }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"copyFile(\"+ srcKey+ \", \" + dstKey + \")\",\n-          srcKey, e);\n-    }\n+    };\n+\n+    once(\"copyFile(\" + srcKey + \", \" + dstKey + \")\", srcKey,\n+        () -\u003e {\n+          ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n+          ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n+          setOptionalObjectMetadata(dstom);\n+          CopyObjectRequest copyObjectRequest \u003d\n+              new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n+          setOptionalCopyObjectRequestParameters(copyObjectRequest);\n+          copyObjectRequest.setCannedAccessControlList(cannedACL);\n+          copyObjectRequest.setNewObjectMetadata(dstom);\n+          Copy copy \u003d transfers.copy(copyObjectRequest);\n+          copy.addProgressListener(progressListener);\n+          try {\n+            copy.waitForCopyResult();\n+            incrementWriteOperations();\n+            instrumentation.filesCopied(1, size);\n+          } catch (InterruptedException e) {\n+            throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n+                + \" to \" + dstKey + \", cancelling\");\n+          }\n+        });\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void copyFile(String srcKey, String dstKey, long size)\n      throws IOException, InterruptedIOException  {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    ProgressListener progressListener \u003d progressEvent -\u003e {\n      switch (progressEvent.getEventType()) {\n      case TRANSFER_PART_COMPLETED_EVENT:\n        incrementWriteOperations();\n        break;\n      default:\n        break;\n      }\n    };\n\n    once(\"copyFile(\" + srcKey + \", \" + dstKey + \")\", srcKey,\n        () -\u003e {\n          ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n          ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n          setOptionalObjectMetadata(dstom);\n          CopyObjectRequest copyObjectRequest \u003d\n              new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n          setOptionalCopyObjectRequestParameters(copyObjectRequest);\n          copyObjectRequest.setCannedAccessControlList(cannedACL);\n          copyObjectRequest.setNewObjectMetadata(dstom);\n          Copy copy \u003d transfers.copy(copyObjectRequest);\n          copy.addProgressListener(progressListener);\n          try {\n            copy.waitForCopyResult();\n            incrementWriteOperations();\n            instrumentation.filesCopied(1, size);\n          } catch (InterruptedException e) {\n            throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n                + \" to \" + dstKey + \", cancelling\");\n          }\n        });\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[IOException, InterruptedIOException, AmazonClientException]",
            "newValue": "[IOException, InterruptedIOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15079. ITestS3AFileOperationCost#testFakeDirectoryDeletion failing\nafter OutputCommitter patch.\nContributed by Steve Loughran\n",
          "commitDate": "15/01/18 3:33 AM",
          "commitName": "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "09/01/18 10:46 AM",
          "commitNameOld": "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 5.7,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,36 @@\n   private void copyFile(String srcKey, String dstKey, long size)\n-      throws IOException, InterruptedIOException, AmazonClientException {\n+      throws IOException, InterruptedIOException  {\n     LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n-    try {\n-      ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n-      ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n-      setOptionalObjectMetadata(dstom);\n-      CopyObjectRequest copyObjectRequest \u003d\n-          new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n-      setOptionalCopyObjectRequestParameters(copyObjectRequest);\n-      copyObjectRequest.setCannedAccessControlList(cannedACL);\n-      copyObjectRequest.setNewObjectMetadata(dstom);\n-\n-      ProgressListener progressListener \u003d new ProgressListener() {\n-        public void progressChanged(ProgressEvent progressEvent) {\n-          switch (progressEvent.getEventType()) {\n-            case TRANSFER_PART_COMPLETED_EVENT:\n-              incrementWriteOperations();\n-              break;\n-            default:\n-              break;\n-          }\n-        }\n-      };\n-\n-      Copy copy \u003d transfers.copy(copyObjectRequest);\n-      copy.addProgressListener(progressListener);\n-      try {\n-        copy.waitForCopyResult();\n+    ProgressListener progressListener \u003d progressEvent -\u003e {\n+      switch (progressEvent.getEventType()) {\n+      case TRANSFER_PART_COMPLETED_EVENT:\n         incrementWriteOperations();\n-        instrumentation.filesCopied(1, size);\n-      } catch (InterruptedException e) {\n-        throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n-            + \" to \" + dstKey + \", cancelling\");\n+        break;\n+      default:\n+        break;\n       }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"copyFile(\"+ srcKey+ \", \" + dstKey + \")\",\n-          srcKey, e);\n-    }\n+    };\n+\n+    once(\"copyFile(\" + srcKey + \", \" + dstKey + \")\", srcKey,\n+        () -\u003e {\n+          ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n+          ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n+          setOptionalObjectMetadata(dstom);\n+          CopyObjectRequest copyObjectRequest \u003d\n+              new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n+          setOptionalCopyObjectRequestParameters(copyObjectRequest);\n+          copyObjectRequest.setCannedAccessControlList(cannedACL);\n+          copyObjectRequest.setNewObjectMetadata(dstom);\n+          Copy copy \u003d transfers.copy(copyObjectRequest);\n+          copy.addProgressListener(progressListener);\n+          try {\n+            copy.waitForCopyResult();\n+            incrementWriteOperations();\n+            instrumentation.filesCopied(1, size);\n+          } catch (InterruptedException e) {\n+            throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n+                + \" to \" + dstKey + \", cancelling\");\n+          }\n+        });\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void copyFile(String srcKey, String dstKey, long size)\n      throws IOException, InterruptedIOException  {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    ProgressListener progressListener \u003d progressEvent -\u003e {\n      switch (progressEvent.getEventType()) {\n      case TRANSFER_PART_COMPLETED_EVENT:\n        incrementWriteOperations();\n        break;\n      default:\n        break;\n      }\n    };\n\n    once(\"copyFile(\" + srcKey + \", \" + dstKey + \")\", srcKey,\n        () -\u003e {\n          ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n          ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n          setOptionalObjectMetadata(dstom);\n          CopyObjectRequest copyObjectRequest \u003d\n              new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n          setOptionalCopyObjectRequestParameters(copyObjectRequest);\n          copyObjectRequest.setCannedAccessControlList(cannedACL);\n          copyObjectRequest.setNewObjectMetadata(dstom);\n          Copy copy \u003d transfers.copy(copyObjectRequest);\n          copy.addProgressListener(progressListener);\n          try {\n            copy.waitForCopyResult();\n            incrementWriteOperations();\n            instrumentation.filesCopied(1, size);\n          } catch (InterruptedException e) {\n            throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n                + \" to \" + dstKey + \", cancelling\");\n          }\n        });\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "839b690ed5edc2ac4984640d58c005bb63cd8a07": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13075. Add support for SSE-KMS and SSE-C in s3a filesystem. (Steve Moist via lei)\n",
      "commitDate": "11/02/17 1:59 PM",
      "commitName": "839b690ed5edc2ac4984640d58c005bb63cd8a07",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "11/01/17 9:25 AM",
      "commitNameOld": "e648b6e1382336af69434dfbf9161bced3caa244",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 31.19,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,41 @@\n   private void copyFile(String srcKey, String dstKey, long size)\n       throws IOException, InterruptedIOException, AmazonClientException {\n     LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n     try {\n       ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n       ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n-      if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n-        dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n-      }\n+      setOptionalObjectMetadata(dstom);\n       CopyObjectRequest copyObjectRequest \u003d\n           new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n+      setOptionalCopyObjectRequestParameters(copyObjectRequest);\n       copyObjectRequest.setCannedAccessControlList(cannedACL);\n       copyObjectRequest.setNewObjectMetadata(dstom);\n \n       ProgressListener progressListener \u003d new ProgressListener() {\n         public void progressChanged(ProgressEvent progressEvent) {\n           switch (progressEvent.getEventType()) {\n             case TRANSFER_PART_COMPLETED_EVENT:\n               incrementWriteOperations();\n               break;\n             default:\n               break;\n           }\n         }\n       };\n \n       Copy copy \u003d transfers.copy(copyObjectRequest);\n       copy.addProgressListener(progressListener);\n       try {\n         copy.waitForCopyResult();\n         incrementWriteOperations();\n         instrumentation.filesCopied(1, size);\n       } catch (InterruptedException e) {\n         throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n             + \" to \" + dstKey + \", cancelling\");\n       }\n     } catch (AmazonClientException e) {\n       throw translateException(\"copyFile(\"+ srcKey+ \", \" + dstKey + \")\",\n           srcKey, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void copyFile(String srcKey, String dstKey, long size)\n      throws IOException, InterruptedIOException, AmazonClientException {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    try {\n      ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n      ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n      setOptionalObjectMetadata(dstom);\n      CopyObjectRequest copyObjectRequest \u003d\n          new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n      setOptionalCopyObjectRequestParameters(copyObjectRequest);\n      copyObjectRequest.setCannedAccessControlList(cannedACL);\n      copyObjectRequest.setNewObjectMetadata(dstom);\n\n      ProgressListener progressListener \u003d new ProgressListener() {\n        public void progressChanged(ProgressEvent progressEvent) {\n          switch (progressEvent.getEventType()) {\n            case TRANSFER_PART_COMPLETED_EVENT:\n              incrementWriteOperations();\n              break;\n            default:\n              break;\n          }\n        }\n      };\n\n      Copy copy \u003d transfers.copy(copyObjectRequest);\n      copy.addProgressListener(progressListener);\n      try {\n        copy.waitForCopyResult();\n        incrementWriteOperations();\n        instrumentation.filesCopied(1, size);\n      } catch (InterruptedException e) {\n        throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n            + \" to \" + dstKey + \", cancelling\");\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"copyFile(\"+ srcKey+ \", \" + dstKey + \")\",\n          srcKey, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13171. Add StorageStatistics to S3A; instrument some more operations. Contributed by Steve Loughran.\n",
      "commitDate": "03/06/16 8:55 AM",
      "commitName": "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "01/06/16 2:49 PM",
      "commitNameOld": "16b1cc7af9bd63b65ef50e1056f275a7baf111a2",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 1.75,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   private void copyFile(String srcKey, String dstKey, long size)\n       throws IOException, InterruptedIOException, AmazonClientException {\n     LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n     try {\n-      ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n+      ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n       ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n       if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n         dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n       }\n       CopyObjectRequest copyObjectRequest \u003d\n           new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n       copyObjectRequest.setCannedAccessControlList(cannedACL);\n       copyObjectRequest.setNewObjectMetadata(dstom);\n \n       ProgressListener progressListener \u003d new ProgressListener() {\n         public void progressChanged(ProgressEvent progressEvent) {\n           switch (progressEvent.getEventType()) {\n             case TRANSFER_PART_COMPLETED_EVENT:\n-              statistics.incrementWriteOps(1);\n+              incrementWriteOperations();\n               break;\n             default:\n               break;\n           }\n         }\n       };\n \n       Copy copy \u003d transfers.copy(copyObjectRequest);\n       copy.addProgressListener(progressListener);\n       try {\n         copy.waitForCopyResult();\n-        statistics.incrementWriteOps(1);\n+        incrementWriteOperations();\n         instrumentation.filesCopied(1, size);\n       } catch (InterruptedException e) {\n         throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n             + \" to \" + dstKey + \", cancelling\");\n       }\n     } catch (AmazonClientException e) {\n       throw translateException(\"copyFile(\"+ srcKey+ \", \" + dstKey + \")\",\n           srcKey, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void copyFile(String srcKey, String dstKey, long size)\n      throws IOException, InterruptedIOException, AmazonClientException {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    try {\n      ObjectMetadata srcom \u003d getObjectMetadata(srcKey);\n      ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n      if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n        dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n      }\n      CopyObjectRequest copyObjectRequest \u003d\n          new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n      copyObjectRequest.setCannedAccessControlList(cannedACL);\n      copyObjectRequest.setNewObjectMetadata(dstom);\n\n      ProgressListener progressListener \u003d new ProgressListener() {\n        public void progressChanged(ProgressEvent progressEvent) {\n          switch (progressEvent.getEventType()) {\n            case TRANSFER_PART_COMPLETED_EVENT:\n              incrementWriteOperations();\n              break;\n            default:\n              break;\n          }\n        }\n      };\n\n      Copy copy \u003d transfers.copy(copyObjectRequest);\n      copy.addProgressListener(progressListener);\n      try {\n        copy.waitForCopyResult();\n        incrementWriteOperations();\n        instrumentation.filesCopied(1, size);\n      } catch (InterruptedException e) {\n        throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n            + \" to \" + dstKey + \", cancelling\");\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"copyFile(\"+ srcKey+ \", \" + dstKey + \")\",\n          srcKey, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "39ec1515a205952eda7e171408a8b83eceb4abde": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
      "commitDate": "21/05/16 8:39 AM",
      "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
          "commitDate": "21/05/16 8:39 AM",
          "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "20/05/16 5:52 AM",
          "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,42 @@\n   private void copyFile(String srcKey, String dstKey, long size)\n-      throws IOException {\n+      throws IOException, InterruptedIOException, AmazonClientException {\n     LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n-    ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n-    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n-    if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n-      dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n-    }\n-    CopyObjectRequest copyObjectRequest \u003d\n-        new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n-    copyObjectRequest.setCannedAccessControlList(cannedACL);\n-    copyObjectRequest.setNewObjectMetadata(dstom);\n-\n-    ProgressListener progressListener \u003d new ProgressListener() {\n-      public void progressChanged(ProgressEvent progressEvent) {\n-        switch (progressEvent.getEventType()) {\n-          case TRANSFER_PART_COMPLETED_EVENT:\n-            statistics.incrementWriteOps(1);\n-            break;\n-          default:\n-            break;\n-        }\n-      }\n-    };\n-\n-    Copy copy \u003d transfers.copy(copyObjectRequest);\n-    copy.addProgressListener(progressListener);\n     try {\n-      copy.waitForCopyResult();\n-      statistics.incrementWriteOps(1);\n-      instrumentation.filesCopied(1, size);\n-    } catch (InterruptedException e) {\n-      throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n-          + \" to \" + dstKey + \", cancelling\");\n+      ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n+      ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n+      if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n+        dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n+      }\n+      CopyObjectRequest copyObjectRequest \u003d\n+          new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n+      copyObjectRequest.setCannedAccessControlList(cannedACL);\n+      copyObjectRequest.setNewObjectMetadata(dstom);\n+\n+      ProgressListener progressListener \u003d new ProgressListener() {\n+        public void progressChanged(ProgressEvent progressEvent) {\n+          switch (progressEvent.getEventType()) {\n+            case TRANSFER_PART_COMPLETED_EVENT:\n+              statistics.incrementWriteOps(1);\n+              break;\n+            default:\n+              break;\n+          }\n+        }\n+      };\n+\n+      Copy copy \u003d transfers.copy(copyObjectRequest);\n+      copy.addProgressListener(progressListener);\n+      try {\n+        copy.waitForCopyResult();\n+        statistics.incrementWriteOps(1);\n+        instrumentation.filesCopied(1, size);\n+      } catch (InterruptedException e) {\n+        throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n+            + \" to \" + dstKey + \", cancelling\");\n+      }\n+    } catch (AmazonClientException e) {\n+      throw translateException(\"copyFile(\"+ srcKey+ \", \" + dstKey + \")\",\n+          srcKey, e);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void copyFile(String srcKey, String dstKey, long size)\n      throws IOException, InterruptedIOException, AmazonClientException {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    try {\n      ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n      ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n      if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n        dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n      }\n      CopyObjectRequest copyObjectRequest \u003d\n          new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n      copyObjectRequest.setCannedAccessControlList(cannedACL);\n      copyObjectRequest.setNewObjectMetadata(dstom);\n\n      ProgressListener progressListener \u003d new ProgressListener() {\n        public void progressChanged(ProgressEvent progressEvent) {\n          switch (progressEvent.getEventType()) {\n            case TRANSFER_PART_COMPLETED_EVENT:\n              statistics.incrementWriteOps(1);\n              break;\n            default:\n              break;\n          }\n        }\n      };\n\n      Copy copy \u003d transfers.copy(copyObjectRequest);\n      copy.addProgressListener(progressListener);\n      try {\n        copy.waitForCopyResult();\n        statistics.incrementWriteOps(1);\n        instrumentation.filesCopied(1, size);\n      } catch (InterruptedException e) {\n        throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n            + \" to \" + dstKey + \", cancelling\");\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"copyFile(\"+ srcKey+ \", \" + dstKey + \")\",\n          srcKey, e);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[IOException, InterruptedIOException, AmazonClientException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
          "commitDate": "21/05/16 8:39 AM",
          "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "20/05/16 5:52 AM",
          "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,42 @@\n   private void copyFile(String srcKey, String dstKey, long size)\n-      throws IOException {\n+      throws IOException, InterruptedIOException, AmazonClientException {\n     LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n-    ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n-    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n-    if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n-      dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n-    }\n-    CopyObjectRequest copyObjectRequest \u003d\n-        new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n-    copyObjectRequest.setCannedAccessControlList(cannedACL);\n-    copyObjectRequest.setNewObjectMetadata(dstom);\n-\n-    ProgressListener progressListener \u003d new ProgressListener() {\n-      public void progressChanged(ProgressEvent progressEvent) {\n-        switch (progressEvent.getEventType()) {\n-          case TRANSFER_PART_COMPLETED_EVENT:\n-            statistics.incrementWriteOps(1);\n-            break;\n-          default:\n-            break;\n-        }\n-      }\n-    };\n-\n-    Copy copy \u003d transfers.copy(copyObjectRequest);\n-    copy.addProgressListener(progressListener);\n     try {\n-      copy.waitForCopyResult();\n-      statistics.incrementWriteOps(1);\n-      instrumentation.filesCopied(1, size);\n-    } catch (InterruptedException e) {\n-      throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n-          + \" to \" + dstKey + \", cancelling\");\n+      ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n+      ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n+      if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n+        dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n+      }\n+      CopyObjectRequest copyObjectRequest \u003d\n+          new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n+      copyObjectRequest.setCannedAccessControlList(cannedACL);\n+      copyObjectRequest.setNewObjectMetadata(dstom);\n+\n+      ProgressListener progressListener \u003d new ProgressListener() {\n+        public void progressChanged(ProgressEvent progressEvent) {\n+          switch (progressEvent.getEventType()) {\n+            case TRANSFER_PART_COMPLETED_EVENT:\n+              statistics.incrementWriteOps(1);\n+              break;\n+            default:\n+              break;\n+          }\n+        }\n+      };\n+\n+      Copy copy \u003d transfers.copy(copyObjectRequest);\n+      copy.addProgressListener(progressListener);\n+      try {\n+        copy.waitForCopyResult();\n+        statistics.incrementWriteOps(1);\n+        instrumentation.filesCopied(1, size);\n+      } catch (InterruptedException e) {\n+        throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n+            + \" to \" + dstKey + \", cancelling\");\n+      }\n+    } catch (AmazonClientException e) {\n+      throw translateException(\"copyFile(\"+ srcKey+ \", \" + dstKey + \")\",\n+          srcKey, e);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void copyFile(String srcKey, String dstKey, long size)\n      throws IOException, InterruptedIOException, AmazonClientException {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    try {\n      ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n      ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n      if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n        dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n      }\n      CopyObjectRequest copyObjectRequest \u003d\n          new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n      copyObjectRequest.setCannedAccessControlList(cannedACL);\n      copyObjectRequest.setNewObjectMetadata(dstom);\n\n      ProgressListener progressListener \u003d new ProgressListener() {\n        public void progressChanged(ProgressEvent progressEvent) {\n          switch (progressEvent.getEventType()) {\n            case TRANSFER_PART_COMPLETED_EVENT:\n              statistics.incrementWriteOps(1);\n              break;\n            default:\n              break;\n          }\n        }\n      };\n\n      Copy copy \u003d transfers.copy(copyObjectRequest);\n      copy.addProgressListener(progressListener);\n      try {\n        copy.waitForCopyResult();\n        statistics.incrementWriteOps(1);\n        instrumentation.filesCopied(1, size);\n      } catch (InterruptedException e) {\n        throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n            + \" to \" + dstKey + \", cancelling\");\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"copyFile(\"+ srcKey+ \", \" + dstKey + \")\",\n          srcKey, e);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "27c4e90efce04e1b1302f668b5eb22412e00d033": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
      "commitDate": "12/05/16 11:24 AM",
      "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
          "commitDate": "12/05/16 11:24 AM",
          "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "12/05/16 5:57 AM",
          "commitNameOld": "def2a6d3856452d5c804f04e5bf485541a3bc53a",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.23,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,37 @@\n-  private void copyFile(String srcKey, String dstKey) throws IOException {\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n-    }\n+  private void copyFile(String srcKey, String dstKey, long size)\n+      throws IOException {\n+    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n     ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n     ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n     if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n       dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n     }\n-    CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n+    CopyObjectRequest copyObjectRequest \u003d\n+        new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n     copyObjectRequest.setCannedAccessControlList(cannedACL);\n     copyObjectRequest.setNewObjectMetadata(dstom);\n \n     ProgressListener progressListener \u003d new ProgressListener() {\n       public void progressChanged(ProgressEvent progressEvent) {\n         switch (progressEvent.getEventType()) {\n           case TRANSFER_PART_COMPLETED_EVENT:\n             statistics.incrementWriteOps(1);\n             break;\n           default:\n             break;\n         }\n       }\n     };\n \n     Copy copy \u003d transfers.copy(copyObjectRequest);\n     copy.addProgressListener(progressListener);\n     try {\n       copy.waitForCopyResult();\n       statistics.incrementWriteOps(1);\n+      instrumentation.filesCopied(1, size);\n     } catch (InterruptedException e) {\n-      throw new IOException(\"Got interrupted, cancelling\");\n+      throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n+          + \" to \" + dstKey + \", cancelling\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void copyFile(String srcKey, String dstKey, long size)\n      throws IOException {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n    if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n      dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n    }\n    CopyObjectRequest copyObjectRequest \u003d\n        new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n    copyObjectRequest.setCannedAccessControlList(cannedACL);\n    copyObjectRequest.setNewObjectMetadata(dstom);\n\n    ProgressListener progressListener \u003d new ProgressListener() {\n      public void progressChanged(ProgressEvent progressEvent) {\n        switch (progressEvent.getEventType()) {\n          case TRANSFER_PART_COMPLETED_EVENT:\n            statistics.incrementWriteOps(1);\n            break;\n          default:\n            break;\n        }\n      }\n    };\n\n    Copy copy \u003d transfers.copy(copyObjectRequest);\n    copy.addProgressListener(progressListener);\n    try {\n      copy.waitForCopyResult();\n      statistics.incrementWriteOps(1);\n      instrumentation.filesCopied(1, size);\n    } catch (InterruptedException e) {\n      throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n          + \" to \" + dstKey + \", cancelling\");\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[srcKey-String, dstKey-String]",
            "newValue": "[srcKey-String, dstKey-String, size-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
          "commitDate": "12/05/16 11:24 AM",
          "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "12/05/16 5:57 AM",
          "commitNameOld": "def2a6d3856452d5c804f04e5bf485541a3bc53a",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.23,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,37 @@\n-  private void copyFile(String srcKey, String dstKey) throws IOException {\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n-    }\n+  private void copyFile(String srcKey, String dstKey, long size)\n+      throws IOException {\n+    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n \n     ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n     ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n     if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n       dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n     }\n-    CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n+    CopyObjectRequest copyObjectRequest \u003d\n+        new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n     copyObjectRequest.setCannedAccessControlList(cannedACL);\n     copyObjectRequest.setNewObjectMetadata(dstom);\n \n     ProgressListener progressListener \u003d new ProgressListener() {\n       public void progressChanged(ProgressEvent progressEvent) {\n         switch (progressEvent.getEventType()) {\n           case TRANSFER_PART_COMPLETED_EVENT:\n             statistics.incrementWriteOps(1);\n             break;\n           default:\n             break;\n         }\n       }\n     };\n \n     Copy copy \u003d transfers.copy(copyObjectRequest);\n     copy.addProgressListener(progressListener);\n     try {\n       copy.waitForCopyResult();\n       statistics.incrementWriteOps(1);\n+      instrumentation.filesCopied(1, size);\n     } catch (InterruptedException e) {\n-      throw new IOException(\"Got interrupted, cancelling\");\n+      throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n+          + \" to \" + dstKey + \", cancelling\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void copyFile(String srcKey, String dstKey, long size)\n      throws IOException {\n    LOG.debug(\"copyFile {} -\u003e {} \", srcKey, dstKey);\n\n    ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n    if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n      dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n    }\n    CopyObjectRequest copyObjectRequest \u003d\n        new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n    copyObjectRequest.setCannedAccessControlList(cannedACL);\n    copyObjectRequest.setNewObjectMetadata(dstom);\n\n    ProgressListener progressListener \u003d new ProgressListener() {\n      public void progressChanged(ProgressEvent progressEvent) {\n        switch (progressEvent.getEventType()) {\n          case TRANSFER_PART_COMPLETED_EVENT:\n            statistics.incrementWriteOps(1);\n            break;\n          default:\n            break;\n        }\n      }\n    };\n\n    Copy copy \u003d transfers.copy(copyObjectRequest);\n    copy.addProgressListener(progressListener);\n    try {\n      copy.waitForCopyResult();\n      statistics.incrementWriteOps(1);\n      instrumentation.filesCopied(1, size);\n    } catch (InterruptedException e) {\n      throw new InterruptedIOException(\"Interrupted copying \" + srcKey\n          + \" to \" + dstKey + \", cancelling\");\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "256c82fe2981748cd0befc5490d8118d139908f9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11687. Ignore x-* and response headers when copying an Amazon S3 object. Contributed by Aaron Peterson and harsh.\n",
      "commitDate": "01/04/16 1:48 AM",
      "commitName": "256c82fe2981748cd0befc5490d8118d139908f9",
      "commitAuthor": "Harsh J",
      "commitDateOld": "29/02/16 9:59 PM",
      "commitNameOld": "d251e55415f1fab085159b9eb3b43214d100b6a8",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 31.12,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private void copyFile(String srcKey, String dstKey) throws IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n     }\n \n     ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n-    final ObjectMetadata dstom \u003d srcom.clone();\n+    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n     if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n       dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n     }\n     CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n     copyObjectRequest.setCannedAccessControlList(cannedACL);\n     copyObjectRequest.setNewObjectMetadata(dstom);\n \n     ProgressListener progressListener \u003d new ProgressListener() {\n       public void progressChanged(ProgressEvent progressEvent) {\n         switch (progressEvent.getEventType()) {\n           case TRANSFER_PART_COMPLETED_EVENT:\n             statistics.incrementWriteOps(1);\n             break;\n           default:\n             break;\n         }\n       }\n     };\n \n     Copy copy \u003d transfers.copy(copyObjectRequest);\n     copy.addProgressListener(progressListener);\n     try {\n       copy.waitForCopyResult();\n       statistics.incrementWriteOps(1);\n     } catch (InterruptedException e) {\n       throw new IOException(\"Got interrupted, cancelling\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void copyFile(String srcKey, String dstKey) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n    }\n\n    ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n    ObjectMetadata dstom \u003d cloneObjectMetadata(srcom);\n    if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n      dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n    }\n    CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n    copyObjectRequest.setCannedAccessControlList(cannedACL);\n    copyObjectRequest.setNewObjectMetadata(dstom);\n\n    ProgressListener progressListener \u003d new ProgressListener() {\n      public void progressChanged(ProgressEvent progressEvent) {\n        switch (progressEvent.getEventType()) {\n          case TRANSFER_PART_COMPLETED_EVENT:\n            statistics.incrementWriteOps(1);\n            break;\n          default:\n            break;\n        }\n      }\n    };\n\n    Copy copy \u003d transfers.copy(copyObjectRequest);\n    copy.addProgressListener(progressListener);\n    try {\n      copy.waitForCopyResult();\n      statistics.incrementWriteOps(1);\n    } catch (InterruptedException e) {\n      throw new IOException(\"Got interrupted, cancelling\");\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "d5403747b57b1e294e533ce17f197e7be8f5339c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12269. Update aws-sdk dependency to 1.10.6 (Thomas Demoor via Lei (Eddy) Xu)\n",
      "commitDate": "04/08/15 6:51 PM",
      "commitName": "d5403747b57b1e294e533ce17f197e7be8f5339c",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "08/03/15 11:22 AM",
      "commitNameOld": "64443490d7f189e8e42d284615f3814ef751395a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 149.31,
      "commitsBetweenForRepo": 1216,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private void copyFile(String srcKey, String dstKey) throws IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n     }\n \n     ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n     final ObjectMetadata dstom \u003d srcom.clone();\n     if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n-      dstom.setServerSideEncryption(serverSideEncryptionAlgorithm);\n+      dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n     }\n     CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n     copyObjectRequest.setCannedAccessControlList(cannedACL);\n     copyObjectRequest.setNewObjectMetadata(dstom);\n \n     ProgressListener progressListener \u003d new ProgressListener() {\n       public void progressChanged(ProgressEvent progressEvent) {\n-        switch (progressEvent.getEventCode()) {\n-          case ProgressEvent.PART_COMPLETED_EVENT_CODE:\n+        switch (progressEvent.getEventType()) {\n+          case TRANSFER_PART_COMPLETED_EVENT:\n             statistics.incrementWriteOps(1);\n             break;\n           default:\n             break;\n         }\n       }\n     };\n \n     Copy copy \u003d transfers.copy(copyObjectRequest);\n     copy.addProgressListener(progressListener);\n     try {\n       copy.waitForCopyResult();\n       statistics.incrementWriteOps(1);\n     } catch (InterruptedException e) {\n       throw new IOException(\"Got interrupted, cancelling\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void copyFile(String srcKey, String dstKey) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n    }\n\n    ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n    final ObjectMetadata dstom \u003d srcom.clone();\n    if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n      dstom.setSSEAlgorithm(serverSideEncryptionAlgorithm);\n    }\n    CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n    copyObjectRequest.setCannedAccessControlList(cannedACL);\n    copyObjectRequest.setNewObjectMetadata(dstom);\n\n    ProgressListener progressListener \u003d new ProgressListener() {\n      public void progressChanged(ProgressEvent progressEvent) {\n        switch (progressEvent.getEventType()) {\n          case TRANSFER_PART_COMPLETED_EVENT:\n            statistics.incrementWriteOps(1);\n            break;\n          default:\n            break;\n        }\n      }\n    };\n\n    Copy copy \u003d transfers.copy(copyObjectRequest);\n    copy.addProgressListener(progressListener);\n    try {\n      copy.waitForCopyResult();\n      statistics.incrementWriteOps(1);\n    } catch (InterruptedException e) {\n      throw new IOException(\"Got interrupted, cancelling\");\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "4e7ad4f0a88bd36bc91db6b1bd311d7f5c6bebee": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11463 Replace method-local TransferManager object with S3AFileSystem#transfers. (Ted Yu via stevel)\n",
      "commitDate": "05/02/15 4:20 AM",
      "commitName": "4e7ad4f0a88bd36bc91db6b1bd311d7f5c6bebee",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/01/15 10:40 AM",
      "commitNameOld": "2908fe4ec52f78d74e4207274a34d88d54cd468f",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 18.74,
      "commitsBetweenForRepo": 152,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,35 @@\n   private void copyFile(String srcKey, String dstKey) throws IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n     }\n \n-    TransferManagerConfiguration transferConfiguration \u003d new TransferManagerConfiguration();\n-    transferConfiguration.setMultipartCopyPartSize(partSize);\n-\n-    TransferManager transfers \u003d new TransferManager(s3);\n-    transfers.setConfiguration(transferConfiguration);\n-\n     ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n     final ObjectMetadata dstom \u003d srcom.clone();\n     if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n       dstom.setServerSideEncryption(serverSideEncryptionAlgorithm);\n     }\n     CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n     copyObjectRequest.setCannedAccessControlList(cannedACL);\n     copyObjectRequest.setNewObjectMetadata(dstom);\n \n     ProgressListener progressListener \u003d new ProgressListener() {\n       public void progressChanged(ProgressEvent progressEvent) {\n         switch (progressEvent.getEventCode()) {\n           case ProgressEvent.PART_COMPLETED_EVENT_CODE:\n             statistics.incrementWriteOps(1);\n             break;\n           default:\n             break;\n         }\n       }\n     };\n \n     Copy copy \u003d transfers.copy(copyObjectRequest);\n     copy.addProgressListener(progressListener);\n     try {\n       copy.waitForCopyResult();\n       statistics.incrementWriteOps(1);\n     } catch (InterruptedException e) {\n       throw new IOException(\"Got interrupted, cancelling\");\n-    } finally {\n-      transfers.shutdownNow(false);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void copyFile(String srcKey, String dstKey) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n    }\n\n    ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n    final ObjectMetadata dstom \u003d srcom.clone();\n    if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n      dstom.setServerSideEncryption(serverSideEncryptionAlgorithm);\n    }\n    CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n    copyObjectRequest.setCannedAccessControlList(cannedACL);\n    copyObjectRequest.setNewObjectMetadata(dstom);\n\n    ProgressListener progressListener \u003d new ProgressListener() {\n      public void progressChanged(ProgressEvent progressEvent) {\n        switch (progressEvent.getEventCode()) {\n          case ProgressEvent.PART_COMPLETED_EVENT_CODE:\n            statistics.incrementWriteOps(1);\n            break;\n          default:\n            break;\n        }\n      }\n    };\n\n    Copy copy \u003d transfers.copy(copyObjectRequest);\n    copy.addProgressListener(progressListener);\n    try {\n      copy.waitForCopyResult();\n      statistics.incrementWriteOps(1);\n    } catch (InterruptedException e) {\n      throw new IOException(\"Got interrupted, cancelling\");\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "2e98ad34ce64a9e5184c53447004de20a637f927": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11381. Fix findbugs warnings in hadoop-distcp, hadoop-aws, hadoop-azure, and hadoop-openstack. Contributed by Li Lu.\n",
      "commitDate": "09/12/14 8:45 PM",
      "commitName": "2e98ad34ce64a9e5184c53447004de20a637f927",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "05/11/14 5:17 PM",
      "commitNameOld": "6ba52d88ec11444cbac946ffadbc645acd0657de",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 34.14,
      "commitsBetweenForRepo": 255,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,43 @@\n   private void copyFile(String srcKey, String dstKey) throws IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n     }\n \n     TransferManagerConfiguration transferConfiguration \u003d new TransferManagerConfiguration();\n     transferConfiguration.setMultipartCopyPartSize(partSize);\n \n     TransferManager transfers \u003d new TransferManager(s3);\n     transfers.setConfiguration(transferConfiguration);\n \n     ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n     final ObjectMetadata dstom \u003d srcom.clone();\n     if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n       dstom.setServerSideEncryption(serverSideEncryptionAlgorithm);\n     }\n     CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n     copyObjectRequest.setCannedAccessControlList(cannedACL);\n     copyObjectRequest.setNewObjectMetadata(dstom);\n \n     ProgressListener progressListener \u003d new ProgressListener() {\n       public void progressChanged(ProgressEvent progressEvent) {\n         switch (progressEvent.getEventCode()) {\n           case ProgressEvent.PART_COMPLETED_EVENT_CODE:\n             statistics.incrementWriteOps(1);\n             break;\n+          default:\n+            break;\n         }\n       }\n     };\n \n     Copy copy \u003d transfers.copy(copyObjectRequest);\n     copy.addProgressListener(progressListener);\n     try {\n       copy.waitForCopyResult();\n       statistics.incrementWriteOps(1);\n     } catch (InterruptedException e) {\n       throw new IOException(\"Got interrupted, cancelling\");\n     } finally {\n       transfers.shutdownNow(false);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void copyFile(String srcKey, String dstKey) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n    }\n\n    TransferManagerConfiguration transferConfiguration \u003d new TransferManagerConfiguration();\n    transferConfiguration.setMultipartCopyPartSize(partSize);\n\n    TransferManager transfers \u003d new TransferManager(s3);\n    transfers.setConfiguration(transferConfiguration);\n\n    ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n    final ObjectMetadata dstom \u003d srcom.clone();\n    if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n      dstom.setServerSideEncryption(serverSideEncryptionAlgorithm);\n    }\n    CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n    copyObjectRequest.setCannedAccessControlList(cannedACL);\n    copyObjectRequest.setNewObjectMetadata(dstom);\n\n    ProgressListener progressListener \u003d new ProgressListener() {\n      public void progressChanged(ProgressEvent progressEvent) {\n        switch (progressEvent.getEventCode()) {\n          case ProgressEvent.PART_COMPLETED_EVENT_CODE:\n            statistics.incrementWriteOps(1);\n            break;\n          default:\n            break;\n        }\n      }\n    };\n\n    Copy copy \u003d transfers.copy(copyObjectRequest);\n    copy.addProgressListener(progressListener);\n    try {\n      copy.waitForCopyResult();\n      statistics.incrementWriteOps(1);\n    } catch (InterruptedException e) {\n      throw new IOException(\"Got interrupted, cancelling\");\n    } finally {\n      transfers.shutdownNow(false);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10400. Incorporate new S3A FileSystem implementation. Contributed by Jordan Mendelson and Dave Wang.\n",
      "commitDate": "15/09/14 8:27 AM",
      "commitName": "24d920b80eb3626073925a1d0b6dcf148add8cc0",
      "commitAuthor": "Aaron T. Myers",
      "diff": "@@ -0,0 +1,41 @@\n+  private void copyFile(String srcKey, String dstKey) throws IOException {\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n+    }\n+\n+    TransferManagerConfiguration transferConfiguration \u003d new TransferManagerConfiguration();\n+    transferConfiguration.setMultipartCopyPartSize(partSize);\n+\n+    TransferManager transfers \u003d new TransferManager(s3);\n+    transfers.setConfiguration(transferConfiguration);\n+\n+    ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n+    final ObjectMetadata dstom \u003d srcom.clone();\n+    if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n+      dstom.setServerSideEncryption(serverSideEncryptionAlgorithm);\n+    }\n+    CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n+    copyObjectRequest.setCannedAccessControlList(cannedACL);\n+    copyObjectRequest.setNewObjectMetadata(dstom);\n+\n+    ProgressListener progressListener \u003d new ProgressListener() {\n+      public void progressChanged(ProgressEvent progressEvent) {\n+        switch (progressEvent.getEventCode()) {\n+          case ProgressEvent.PART_COMPLETED_EVENT_CODE:\n+            statistics.incrementWriteOps(1);\n+            break;\n+        }\n+      }\n+    };\n+\n+    Copy copy \u003d transfers.copy(copyObjectRequest);\n+    copy.addProgressListener(progressListener);\n+    try {\n+      copy.waitForCopyResult();\n+      statistics.incrementWriteOps(1);\n+    } catch (InterruptedException e) {\n+      throw new IOException(\"Got interrupted, cancelling\");\n+    } finally {\n+      transfers.shutdownNow(false);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void copyFile(String srcKey, String dstKey) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"copyFile \" + srcKey + \" -\u003e \" + dstKey);\n    }\n\n    TransferManagerConfiguration transferConfiguration \u003d new TransferManagerConfiguration();\n    transferConfiguration.setMultipartCopyPartSize(partSize);\n\n    TransferManager transfers \u003d new TransferManager(s3);\n    transfers.setConfiguration(transferConfiguration);\n\n    ObjectMetadata srcom \u003d s3.getObjectMetadata(bucket, srcKey);\n    final ObjectMetadata dstom \u003d srcom.clone();\n    if (StringUtils.isNotBlank(serverSideEncryptionAlgorithm)) {\n      dstom.setServerSideEncryption(serverSideEncryptionAlgorithm);\n    }\n    CopyObjectRequest copyObjectRequest \u003d new CopyObjectRequest(bucket, srcKey, bucket, dstKey);\n    copyObjectRequest.setCannedAccessControlList(cannedACL);\n    copyObjectRequest.setNewObjectMetadata(dstom);\n\n    ProgressListener progressListener \u003d new ProgressListener() {\n      public void progressChanged(ProgressEvent progressEvent) {\n        switch (progressEvent.getEventCode()) {\n          case ProgressEvent.PART_COMPLETED_EVENT_CODE:\n            statistics.incrementWriteOps(1);\n            break;\n        }\n      }\n    };\n\n    Copy copy \u003d transfers.copy(copyObjectRequest);\n    copy.addProgressListener(progressListener);\n    try {\n      copy.waitForCopyResult();\n      statistics.incrementWriteOps(1);\n    } catch (InterruptedException e) {\n      throw new IOException(\"Got interrupted, cancelling\");\n    } finally {\n      transfers.shutdownNow(false);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java"
    }
  }
}