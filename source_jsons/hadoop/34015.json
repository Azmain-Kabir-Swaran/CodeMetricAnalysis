{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "GpuResourceHandlerImpl.java",
  "functionName": "preStart",
  "functionId": "preStart___container-Container",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/gpu/GpuResourceHandlerImpl.java",
  "functionStartLine": 100,
  "functionEndLine": 161,
  "numCommitsSeen": 13,
  "timeTaken": 2595,
  "changeHistory": [
    "29465bf169a7e348a4f32265083450faf66d5631",
    "b237a0dd44ab285941983648d7ef26b99b30d624",
    "9114d7a5a0159bbe70e9c289dbe1fc5db9101db5",
    "fa5cfc68f37c78b6cf26ce13247b9ff34da806cd"
  ],
  "changeHistoryShort": {
    "29465bf169a7e348a4f32265083450faf66d5631": "Ybodychange",
    "b237a0dd44ab285941983648d7ef26b99b30d624": "Ybodychange",
    "9114d7a5a0159bbe70e9c289dbe1fc5db9101db5": "Ybodychange",
    "fa5cfc68f37c78b6cf26ce13247b9ff34da806cd": "Yintroduced"
  },
  "changeHistoryDetails": {
    "29465bf169a7e348a4f32265083450faf66d5631": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9560. Restructure DockerLinuxContainerRuntime to extend OCIContainerRuntime.\n           Contributed by Eric Badger, Jim Brennan, Craig Condit\n",
      "commitDate": "28/06/19 2:18 PM",
      "commitName": "29465bf169a7e348a4f32265083450faf66d5631",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "18/03/19 10:57 AM",
      "commitNameOld": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 102.14,
      "commitsBetweenForRepo": 733,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n   public synchronized List\u003cPrivilegedOperation\u003e preStart(Container container)\n       throws ResourceHandlerException {\n     String containerIdStr \u003d container.getContainerId().toString();\n \n     // Assign Gpus to container if requested some.\n     GpuResourceAllocator.GpuAllocation allocation \u003d gpuAllocator.assignGpus(\n         container);\n \n     // Create device cgroups for the container\n     cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n         containerIdStr);\n-    if (!DockerLinuxContainerRuntime.isDockerContainerRequested(\n+    if (!OCIContainerRuntime.isOCICompliantContainerRequested(\n         nmContext.getConf(),\n         container.getLaunchContext().getEnvironment())) {\n       // Write to devices cgroup only for non-docker container. The reason is\n       // docker engine runtime runc do the devices cgroups initialize in the\n       // pre-hook, see:\n       //   https://github.com/opencontainers/runc/blob/master/libcontainer/configs/device_defaults.go\n       //\n       // YARN by default runs docker container inside cgroup, if we setup cgroups\n       // devices.deny for the parent cgroup for launched container, we can see\n       // errors like: failed to write c *:* m to devices.allow:\n       // write path-to-parent-cgroup/\u003ccontainer-id\u003e/devices.allow:\n       // operation not permitted.\n       //\n       // To avoid this happen, if docker is requested when container being\n       // launched, we will not setup devices.deny for the container. Instead YARN\n       // will pass --device parameter to docker engine. See NvidiaDockerV1CommandPlugin\n       try {\n         // Execute c-e to setup GPU isolation before launch the container\n         PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(\n             PrivilegedOperation.OperationType.GPU,\n             Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n         if (!allocation.getDeniedGPUs().isEmpty()) {\n           List\u003cInteger\u003e minorNumbers \u003d new ArrayList\u003c\u003e();\n           for (GpuDevice deniedGpu : allocation.getDeniedGPUs()) {\n             minorNumbers.add(deniedGpu.getMinorNumber());\n           }\n           privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_GPUS_CLI_OPTION,\n               StringUtils.join(\",\", minorNumbers)));\n         }\n \n         privilegedOperationExecutor.executePrivilegedOperation(\n             privilegedOperation, true);\n       } catch (PrivilegedOperationException e) {\n         cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n             containerIdStr);\n         LOG.warn(\"Could not update cgroup for container\", e);\n         throw new ResourceHandlerException(e);\n       }\n \n       List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n       ret.add(new PrivilegedOperation(\n           PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n           PrivilegedOperation.CGROUP_ARG_PREFIX + cGroupsHandler\n               .getPathForCGroupTasks(CGroupsHandler.CGroupController.DEVICES,\n                   containerIdStr)));\n \n       return ret;\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003cPrivilegedOperation\u003e preStart(Container container)\n      throws ResourceHandlerException {\n    String containerIdStr \u003d container.getContainerId().toString();\n\n    // Assign Gpus to container if requested some.\n    GpuResourceAllocator.GpuAllocation allocation \u003d gpuAllocator.assignGpus(\n        container);\n\n    // Create device cgroups for the container\n    cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n        containerIdStr);\n    if (!OCIContainerRuntime.isOCICompliantContainerRequested(\n        nmContext.getConf(),\n        container.getLaunchContext().getEnvironment())) {\n      // Write to devices cgroup only for non-docker container. The reason is\n      // docker engine runtime runc do the devices cgroups initialize in the\n      // pre-hook, see:\n      //   https://github.com/opencontainers/runc/blob/master/libcontainer/configs/device_defaults.go\n      //\n      // YARN by default runs docker container inside cgroup, if we setup cgroups\n      // devices.deny for the parent cgroup for launched container, we can see\n      // errors like: failed to write c *:* m to devices.allow:\n      // write path-to-parent-cgroup/\u003ccontainer-id\u003e/devices.allow:\n      // operation not permitted.\n      //\n      // To avoid this happen, if docker is requested when container being\n      // launched, we will not setup devices.deny for the container. Instead YARN\n      // will pass --device parameter to docker engine. See NvidiaDockerV1CommandPlugin\n      try {\n        // Execute c-e to setup GPU isolation before launch the container\n        PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(\n            PrivilegedOperation.OperationType.GPU,\n            Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n        if (!allocation.getDeniedGPUs().isEmpty()) {\n          List\u003cInteger\u003e minorNumbers \u003d new ArrayList\u003c\u003e();\n          for (GpuDevice deniedGpu : allocation.getDeniedGPUs()) {\n            minorNumbers.add(deniedGpu.getMinorNumber());\n          }\n          privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_GPUS_CLI_OPTION,\n              StringUtils.join(\",\", minorNumbers)));\n        }\n\n        privilegedOperationExecutor.executePrivilegedOperation(\n            privilegedOperation, true);\n      } catch (PrivilegedOperationException e) {\n        cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n            containerIdStr);\n        LOG.warn(\"Could not update cgroup for container\", e);\n        throw new ResourceHandlerException(e);\n      }\n\n      List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n      ret.add(new PrivilegedOperation(\n          PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n          PrivilegedOperation.CGROUP_ARG_PREFIX + cGroupsHandler\n              .getPathForCGroupTasks(CGroupsHandler.CGroupController.DEVICES,\n                  containerIdStr)));\n\n      return ret;\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/gpu/GpuResourceHandlerImpl.java",
      "extendedDetails": {}
    },
    "b237a0dd44ab285941983648d7ef26b99b30d624": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6456.  Added config to set default container runtimes.\n            Contributed by Craig Condit\n",
      "commitDate": "27/09/18 12:31 PM",
      "commitName": "b237a0dd44ab285941983648d7ef26b99b30d624",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "26/06/18 7:25 PM",
      "commitNameOld": "ada8f63d0b3739d245300461387b0516dc92ccf9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 92.71,
      "commitsBetweenForRepo": 756,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,62 @@\n   public synchronized List\u003cPrivilegedOperation\u003e preStart(Container container)\n       throws ResourceHandlerException {\n     String containerIdStr \u003d container.getContainerId().toString();\n \n     // Assign Gpus to container if requested some.\n     GpuResourceAllocator.GpuAllocation allocation \u003d gpuAllocator.assignGpus(\n         container);\n \n     // Create device cgroups for the container\n     cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n         containerIdStr);\n     if (!DockerLinuxContainerRuntime.isDockerContainerRequested(\n+        nmContext.getConf(),\n         container.getLaunchContext().getEnvironment())) {\n       // Write to devices cgroup only for non-docker container. The reason is\n       // docker engine runtime runc do the devices cgroups initialize in the\n       // pre-hook, see:\n       //   https://github.com/opencontainers/runc/blob/master/libcontainer/configs/device_defaults.go\n       //\n       // YARN by default runs docker container inside cgroup, if we setup cgroups\n       // devices.deny for the parent cgroup for launched container, we can see\n       // errors like: failed to write c *:* m to devices.allow:\n       // write path-to-parent-cgroup/\u003ccontainer-id\u003e/devices.allow:\n       // operation not permitted.\n       //\n       // To avoid this happen, if docker is requested when container being\n       // launched, we will not setup devices.deny for the container. Instead YARN\n       // will pass --device parameter to docker engine. See NvidiaDockerV1CommandPlugin\n       try {\n         // Execute c-e to setup GPU isolation before launch the container\n         PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(\n             PrivilegedOperation.OperationType.GPU,\n             Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n         if (!allocation.getDeniedGPUs().isEmpty()) {\n           List\u003cInteger\u003e minorNumbers \u003d new ArrayList\u003c\u003e();\n           for (GpuDevice deniedGpu : allocation.getDeniedGPUs()) {\n             minorNumbers.add(deniedGpu.getMinorNumber());\n           }\n           privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_GPUS_CLI_OPTION,\n               StringUtils.join(\",\", minorNumbers)));\n         }\n \n         privilegedOperationExecutor.executePrivilegedOperation(\n             privilegedOperation, true);\n       } catch (PrivilegedOperationException e) {\n         cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n             containerIdStr);\n         LOG.warn(\"Could not update cgroup for container\", e);\n         throw new ResourceHandlerException(e);\n       }\n \n       List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n       ret.add(new PrivilegedOperation(\n           PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n           PrivilegedOperation.CGROUP_ARG_PREFIX + cGroupsHandler\n               .getPathForCGroupTasks(CGroupsHandler.CGroupController.DEVICES,\n                   containerIdStr)));\n \n       return ret;\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003cPrivilegedOperation\u003e preStart(Container container)\n      throws ResourceHandlerException {\n    String containerIdStr \u003d container.getContainerId().toString();\n\n    // Assign Gpus to container if requested some.\n    GpuResourceAllocator.GpuAllocation allocation \u003d gpuAllocator.assignGpus(\n        container);\n\n    // Create device cgroups for the container\n    cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n        containerIdStr);\n    if (!DockerLinuxContainerRuntime.isDockerContainerRequested(\n        nmContext.getConf(),\n        container.getLaunchContext().getEnvironment())) {\n      // Write to devices cgroup only for non-docker container. The reason is\n      // docker engine runtime runc do the devices cgroups initialize in the\n      // pre-hook, see:\n      //   https://github.com/opencontainers/runc/blob/master/libcontainer/configs/device_defaults.go\n      //\n      // YARN by default runs docker container inside cgroup, if we setup cgroups\n      // devices.deny for the parent cgroup for launched container, we can see\n      // errors like: failed to write c *:* m to devices.allow:\n      // write path-to-parent-cgroup/\u003ccontainer-id\u003e/devices.allow:\n      // operation not permitted.\n      //\n      // To avoid this happen, if docker is requested when container being\n      // launched, we will not setup devices.deny for the container. Instead YARN\n      // will pass --device parameter to docker engine. See NvidiaDockerV1CommandPlugin\n      try {\n        // Execute c-e to setup GPU isolation before launch the container\n        PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(\n            PrivilegedOperation.OperationType.GPU,\n            Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n        if (!allocation.getDeniedGPUs().isEmpty()) {\n          List\u003cInteger\u003e minorNumbers \u003d new ArrayList\u003c\u003e();\n          for (GpuDevice deniedGpu : allocation.getDeniedGPUs()) {\n            minorNumbers.add(deniedGpu.getMinorNumber());\n          }\n          privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_GPUS_CLI_OPTION,\n              StringUtils.join(\",\", minorNumbers)));\n        }\n\n        privilegedOperationExecutor.executePrivilegedOperation(\n            privilegedOperation, true);\n      } catch (PrivilegedOperationException e) {\n        cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n            containerIdStr);\n        LOG.warn(\"Could not update cgroup for container\", e);\n        throw new ResourceHandlerException(e);\n      }\n\n      List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n      ret.add(new PrivilegedOperation(\n          PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n          PrivilegedOperation.CGROUP_ARG_PREFIX + cGroupsHandler\n              .getPathForCGroupTasks(CGroupsHandler.CGroupController.DEVICES,\n                  containerIdStr)));\n\n      return ret;\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/gpu/GpuResourceHandlerImpl.java",
      "extendedDetails": {}
    },
    "9114d7a5a0159bbe70e9c289dbe1fc5db9101db5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7224. Support GPU isolation for docker container. Contributed by Wangda Tan.\n",
      "commitDate": "28/10/17 10:38 PM",
      "commitName": "9114d7a5a0159bbe70e9c289dbe1fc5db9101db5",
      "commitAuthor": "Sunil G",
      "commitDateOld": "11/10/17 11:14 AM",
      "commitNameOld": "fa5cfc68f37c78b6cf26ce13247b9ff34da806cd",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 17.48,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,61 @@\n   public synchronized List\u003cPrivilegedOperation\u003e preStart(Container container)\n       throws ResourceHandlerException {\n     String containerIdStr \u003d container.getContainerId().toString();\n \n     // Assign Gpus to container if requested some.\n     GpuResourceAllocator.GpuAllocation allocation \u003d gpuAllocator.assignGpus(\n         container);\n \n     // Create device cgroups for the container\n     cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n         containerIdStr);\n-    try {\n-      // Execute c-e to setup GPU isolation before launch the container\n-      PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(\n-          PrivilegedOperation.OperationType.GPU, Arrays\n-          .asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n-      if (!allocation.getDeniedGPUs().isEmpty()) {\n-        privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_GPUS_CLI_OPTION,\n-            StringUtils.join(\",\", allocation.getDeniedGPUs())));\n+    if (!DockerLinuxContainerRuntime.isDockerContainerRequested(\n+        container.getLaunchContext().getEnvironment())) {\n+      // Write to devices cgroup only for non-docker container. The reason is\n+      // docker engine runtime runc do the devices cgroups initialize in the\n+      // pre-hook, see:\n+      //   https://github.com/opencontainers/runc/blob/master/libcontainer/configs/device_defaults.go\n+      //\n+      // YARN by default runs docker container inside cgroup, if we setup cgroups\n+      // devices.deny for the parent cgroup for launched container, we can see\n+      // errors like: failed to write c *:* m to devices.allow:\n+      // write path-to-parent-cgroup/\u003ccontainer-id\u003e/devices.allow:\n+      // operation not permitted.\n+      //\n+      // To avoid this happen, if docker is requested when container being\n+      // launched, we will not setup devices.deny for the container. Instead YARN\n+      // will pass --device parameter to docker engine. See NvidiaDockerV1CommandPlugin\n+      try {\n+        // Execute c-e to setup GPU isolation before launch the container\n+        PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(\n+            PrivilegedOperation.OperationType.GPU,\n+            Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n+        if (!allocation.getDeniedGPUs().isEmpty()) {\n+          List\u003cInteger\u003e minorNumbers \u003d new ArrayList\u003c\u003e();\n+          for (GpuDevice deniedGpu : allocation.getDeniedGPUs()) {\n+            minorNumbers.add(deniedGpu.getMinorNumber());\n+          }\n+          privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_GPUS_CLI_OPTION,\n+              StringUtils.join(\",\", minorNumbers)));\n+        }\n+\n+        privilegedOperationExecutor.executePrivilegedOperation(\n+            privilegedOperation, true);\n+      } catch (PrivilegedOperationException e) {\n+        cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n+            containerIdStr);\n+        LOG.warn(\"Could not update cgroup for container\", e);\n+        throw new ResourceHandlerException(e);\n       }\n \n-      privilegedOperationExecutor.executePrivilegedOperation(\n-          privilegedOperation, true);\n-    } catch (PrivilegedOperationException e) {\n-      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n-          containerIdStr);\n-      LOG.warn(\"Could not update cgroup for container\", e);\n-      throw new ResourceHandlerException(e);\n+      List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n+      ret.add(new PrivilegedOperation(\n+          PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n+          PrivilegedOperation.CGROUP_ARG_PREFIX + cGroupsHandler\n+              .getPathForCGroupTasks(CGroupsHandler.CGroupController.DEVICES,\n+                  containerIdStr)));\n+\n+      return ret;\n     }\n-\n-    List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n-    ret.add(new PrivilegedOperation(\n-        PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n-        PrivilegedOperation.CGROUP_ARG_PREFIX\n-            + cGroupsHandler.getPathForCGroupTasks(\n-            CGroupsHandler.CGroupController.DEVICES, containerIdStr)));\n-\n-    return ret;\n+    return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003cPrivilegedOperation\u003e preStart(Container container)\n      throws ResourceHandlerException {\n    String containerIdStr \u003d container.getContainerId().toString();\n\n    // Assign Gpus to container if requested some.\n    GpuResourceAllocator.GpuAllocation allocation \u003d gpuAllocator.assignGpus(\n        container);\n\n    // Create device cgroups for the container\n    cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n        containerIdStr);\n    if (!DockerLinuxContainerRuntime.isDockerContainerRequested(\n        container.getLaunchContext().getEnvironment())) {\n      // Write to devices cgroup only for non-docker container. The reason is\n      // docker engine runtime runc do the devices cgroups initialize in the\n      // pre-hook, see:\n      //   https://github.com/opencontainers/runc/blob/master/libcontainer/configs/device_defaults.go\n      //\n      // YARN by default runs docker container inside cgroup, if we setup cgroups\n      // devices.deny for the parent cgroup for launched container, we can see\n      // errors like: failed to write c *:* m to devices.allow:\n      // write path-to-parent-cgroup/\u003ccontainer-id\u003e/devices.allow:\n      // operation not permitted.\n      //\n      // To avoid this happen, if docker is requested when container being\n      // launched, we will not setup devices.deny for the container. Instead YARN\n      // will pass --device parameter to docker engine. See NvidiaDockerV1CommandPlugin\n      try {\n        // Execute c-e to setup GPU isolation before launch the container\n        PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(\n            PrivilegedOperation.OperationType.GPU,\n            Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n        if (!allocation.getDeniedGPUs().isEmpty()) {\n          List\u003cInteger\u003e minorNumbers \u003d new ArrayList\u003c\u003e();\n          for (GpuDevice deniedGpu : allocation.getDeniedGPUs()) {\n            minorNumbers.add(deniedGpu.getMinorNumber());\n          }\n          privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_GPUS_CLI_OPTION,\n              StringUtils.join(\",\", minorNumbers)));\n        }\n\n        privilegedOperationExecutor.executePrivilegedOperation(\n            privilegedOperation, true);\n      } catch (PrivilegedOperationException e) {\n        cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n            containerIdStr);\n        LOG.warn(\"Could not update cgroup for container\", e);\n        throw new ResourceHandlerException(e);\n      }\n\n      List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n      ret.add(new PrivilegedOperation(\n          PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n          PrivilegedOperation.CGROUP_ARG_PREFIX + cGroupsHandler\n              .getPathForCGroupTasks(CGroupsHandler.CGroupController.DEVICES,\n                  containerIdStr)));\n\n      return ret;\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/gpu/GpuResourceHandlerImpl.java",
      "extendedDetails": {}
    },
    "fa5cfc68f37c78b6cf26ce13247b9ff34da806cd": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6620. Add support in NodeManager to isolate GPU devices by using CGroups. Contributed by Wangda Tan.\n",
      "commitDate": "11/10/17 11:14 AM",
      "commitName": "fa5cfc68f37c78b6cf26ce13247b9ff34da806cd",
      "commitAuthor": "Sunil G",
      "diff": "@@ -0,0 +1,39 @@\n+  public synchronized List\u003cPrivilegedOperation\u003e preStart(Container container)\n+      throws ResourceHandlerException {\n+    String containerIdStr \u003d container.getContainerId().toString();\n+\n+    // Assign Gpus to container if requested some.\n+    GpuResourceAllocator.GpuAllocation allocation \u003d gpuAllocator.assignGpus(\n+        container);\n+\n+    // Create device cgroups for the container\n+    cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n+        containerIdStr);\n+    try {\n+      // Execute c-e to setup GPU isolation before launch the container\n+      PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(\n+          PrivilegedOperation.OperationType.GPU, Arrays\n+          .asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n+      if (!allocation.getDeniedGPUs().isEmpty()) {\n+        privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_GPUS_CLI_OPTION,\n+            StringUtils.join(\",\", allocation.getDeniedGPUs())));\n+      }\n+\n+      privilegedOperationExecutor.executePrivilegedOperation(\n+          privilegedOperation, true);\n+    } catch (PrivilegedOperationException e) {\n+      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n+          containerIdStr);\n+      LOG.warn(\"Could not update cgroup for container\", e);\n+      throw new ResourceHandlerException(e);\n+    }\n+\n+    List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n+    ret.add(new PrivilegedOperation(\n+        PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n+        PrivilegedOperation.CGROUP_ARG_PREFIX\n+            + cGroupsHandler.getPathForCGroupTasks(\n+            CGroupsHandler.CGroupController.DEVICES, containerIdStr)));\n+\n+    return ret;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003cPrivilegedOperation\u003e preStart(Container container)\n      throws ResourceHandlerException {\n    String containerIdStr \u003d container.getContainerId().toString();\n\n    // Assign Gpus to container if requested some.\n    GpuResourceAllocator.GpuAllocation allocation \u003d gpuAllocator.assignGpus(\n        container);\n\n    // Create device cgroups for the container\n    cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES,\n        containerIdStr);\n    try {\n      // Execute c-e to setup GPU isolation before launch the container\n      PrivilegedOperation privilegedOperation \u003d new PrivilegedOperation(\n          PrivilegedOperation.OperationType.GPU, Arrays\n          .asList(CONTAINER_ID_CLI_OPTION, containerIdStr));\n      if (!allocation.getDeniedGPUs().isEmpty()) {\n        privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_GPUS_CLI_OPTION,\n            StringUtils.join(\",\", allocation.getDeniedGPUs())));\n      }\n\n      privilegedOperationExecutor.executePrivilegedOperation(\n          privilegedOperation, true);\n    } catch (PrivilegedOperationException e) {\n      cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES,\n          containerIdStr);\n      LOG.warn(\"Could not update cgroup for container\", e);\n      throw new ResourceHandlerException(e);\n    }\n\n    List\u003cPrivilegedOperation\u003e ret \u003d new ArrayList\u003c\u003e();\n    ret.add(new PrivilegedOperation(\n        PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n        PrivilegedOperation.CGROUP_ARG_PREFIX\n            + cGroupsHandler.getPathForCGroupTasks(\n            CGroupsHandler.CGroupController.DEVICES, containerIdStr)));\n\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/gpu/GpuResourceHandlerImpl.java"
    }
  }
}