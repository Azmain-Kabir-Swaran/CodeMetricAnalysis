{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ImportOperation.java",
  "functionName": "importDir",
  "functionId": "importDir",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/ImportOperation.java",
  "functionStartLine": 136,
  "functionEndLine": 233,
  "numCommitsSeen": 2,
  "timeTaken": 1671,
  "changeHistory": [
    "5977360878e6780bd04842c8a2156f9848e1d088",
    "49df83899543586bbcaf80f01399ade031cf68b0"
  ],
  "changeHistoryShort": {
    "5977360878e6780bd04842c8a2156f9848e1d088": "Ybodychange",
    "49df83899543586bbcaf80f01399ade031cf68b0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5977360878e6780bd04842c8a2156f9848e1d088": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16801. S3Guard listFiles will not query S3 if all listings are authoritative (#1815). Contributed by Mustafa İman.\n\n",
      "commitDate": "30/01/20 2:16 AM",
      "commitName": "5977360878e6780bd04842c8a2156f9848e1d088",
      "commitAuthor": "Mustafa İman",
      "commitDateOld": "10/01/20 3:11 AM",
      "commitNameOld": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 19.96,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n   private long importDir() throws IOException {\n     Preconditions.checkArgument(status.isDirectory());\n     long totalCountOfEntriesWritten \u003d 0;\n     final Path basePath \u003d status.getPath();\n     final MetadataStore ms \u003d getStore();\n     LOG.info(\"Importing directory {}\", basePath);\n     try (BulkOperationState operationState \u003d ms\n         .initiateBulkWrite(\n             BulkOperationState.OperationType.Import,\n             basePath)) {\n       long countOfFilesWritten \u003d 0;\n       long countOfDirsWritten \u003d 0;\n       RemoteIterator\u003cS3ALocatedFileStatus\u003e it \u003d getFilesystem()\n-          .listFilesAndEmptyDirectories(basePath, true);\n+          .listFilesAndEmptyDirectoriesForceNonAuth(basePath, true);\n       while (it.hasNext()) {\n         S3ALocatedFileStatus located \u003d it.next();\n         S3AFileStatus child;\n         final Path path \u003d located.getPath();\n         final boolean isDirectory \u003d located.isDirectory();\n         if (isDirectory) {\n           child \u003d DynamoDBMetadataStore.makeDirStatus(path,\n               located.getOwner());\n           dirCache.add(path);\n           // and update the dir count\n           countOfDirsWritten++;\n         } else {\n           child \u003d located.toS3AFileStatus();\n         }\n \n         int parentsWritten \u003d putParentsIfNotPresent(child, operationState);\n         LOG.debug(\"Wrote {} parent entries\", parentsWritten);\n \n         // We don\u0027t blindly overwrite any existing file entry in S3Guard with a\n         // new one, Because that may lose the version information.\n         // instead we merge them\n         if (!isDirectory) {\n           final PathMetadata existingEntry \u003d S3Guard.getWithTtl(ms, path, null,\n               false, true);\n           if (existingEntry !\u003d null) {\n             final S3AFileStatus existingStatus \u003d existingEntry.getFileStatus();\n             if (existingStatus.isFile()) {\n               // source is also a file.\n               // we only worry about an update if the timestamp is different,\n               final String existingEtag \u003d existingStatus.getETag();\n               final String childEtag \u003d child.getETag();\n               if (child.getModificationTime()\n                   !\u003d existingStatus.getModificationTime()\n                   || existingStatus.getLen() !\u003d child.getLen()\n                   || existingEtag \u003d\u003d null\n                   || !existingEtag.equals(childEtag)) {\n                 // files are potentially different, though a modtime change\n                 // can just be a clock skew problem\n                 // so if the etag is unchanged, we propagate any versionID\n                 if (childEtag.equals(existingEtag)) {\n                   // copy over any version ID.\n                   child.setVersionId(existingStatus.getVersionId());\n                 }\n               } else {\n                 // the entry modtimes match\n                 child \u003d null;\n               }\n             }\n           }\n           if (child !\u003d null) {\n             countOfFilesWritten++;\n           }\n         }\n         if (child !\u003d null) {\n           // there\u0027s an entry to add.\n \n           // log entry spaced to same width\n           String t \u003d isDirectory ? \"Dir \" : \"File\";\n           if (verbose) {\n             LOG.info(\"{} {}\", t, path);\n           } else {\n             LOG.debug(\"{} {}\", t, path);\n           }\n           S3Guard.putWithTtl(\n               ms,\n               new PathMetadata(child),\n               getFilesystem().getTtlTimeProvider(),\n               operationState);\n           totalCountOfEntriesWritten++;\n         }\n       }\n       LOG.info(\"Updated S3Guard with {} files and {} directory entries\",\n           countOfFilesWritten, countOfDirsWritten);\n \n       // here all entries are imported.\n       // tell the store that everything should be marked as auth\n       if (authoritative) {\n         LOG.info(\"Marking directory tree {} as authoritative\",\n             basePath);\n         ms.markAsAuthoritative(basePath, operationState);\n       }\n     }\n     return totalCountOfEntriesWritten;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long importDir() throws IOException {\n    Preconditions.checkArgument(status.isDirectory());\n    long totalCountOfEntriesWritten \u003d 0;\n    final Path basePath \u003d status.getPath();\n    final MetadataStore ms \u003d getStore();\n    LOG.info(\"Importing directory {}\", basePath);\n    try (BulkOperationState operationState \u003d ms\n        .initiateBulkWrite(\n            BulkOperationState.OperationType.Import,\n            basePath)) {\n      long countOfFilesWritten \u003d 0;\n      long countOfDirsWritten \u003d 0;\n      RemoteIterator\u003cS3ALocatedFileStatus\u003e it \u003d getFilesystem()\n          .listFilesAndEmptyDirectoriesForceNonAuth(basePath, true);\n      while (it.hasNext()) {\n        S3ALocatedFileStatus located \u003d it.next();\n        S3AFileStatus child;\n        final Path path \u003d located.getPath();\n        final boolean isDirectory \u003d located.isDirectory();\n        if (isDirectory) {\n          child \u003d DynamoDBMetadataStore.makeDirStatus(path,\n              located.getOwner());\n          dirCache.add(path);\n          // and update the dir count\n          countOfDirsWritten++;\n        } else {\n          child \u003d located.toS3AFileStatus();\n        }\n\n        int parentsWritten \u003d putParentsIfNotPresent(child, operationState);\n        LOG.debug(\"Wrote {} parent entries\", parentsWritten);\n\n        // We don\u0027t blindly overwrite any existing file entry in S3Guard with a\n        // new one, Because that may lose the version information.\n        // instead we merge them\n        if (!isDirectory) {\n          final PathMetadata existingEntry \u003d S3Guard.getWithTtl(ms, path, null,\n              false, true);\n          if (existingEntry !\u003d null) {\n            final S3AFileStatus existingStatus \u003d existingEntry.getFileStatus();\n            if (existingStatus.isFile()) {\n              // source is also a file.\n              // we only worry about an update if the timestamp is different,\n              final String existingEtag \u003d existingStatus.getETag();\n              final String childEtag \u003d child.getETag();\n              if (child.getModificationTime()\n                  !\u003d existingStatus.getModificationTime()\n                  || existingStatus.getLen() !\u003d child.getLen()\n                  || existingEtag \u003d\u003d null\n                  || !existingEtag.equals(childEtag)) {\n                // files are potentially different, though a modtime change\n                // can just be a clock skew problem\n                // so if the etag is unchanged, we propagate any versionID\n                if (childEtag.equals(existingEtag)) {\n                  // copy over any version ID.\n                  child.setVersionId(existingStatus.getVersionId());\n                }\n              } else {\n                // the entry modtimes match\n                child \u003d null;\n              }\n            }\n          }\n          if (child !\u003d null) {\n            countOfFilesWritten++;\n          }\n        }\n        if (child !\u003d null) {\n          // there\u0027s an entry to add.\n\n          // log entry spaced to same width\n          String t \u003d isDirectory ? \"Dir \" : \"File\";\n          if (verbose) {\n            LOG.info(\"{} {}\", t, path);\n          } else {\n            LOG.debug(\"{} {}\", t, path);\n          }\n          S3Guard.putWithTtl(\n              ms,\n              new PathMetadata(child),\n              getFilesystem().getTtlTimeProvider(),\n              operationState);\n          totalCountOfEntriesWritten++;\n        }\n      }\n      LOG.info(\"Updated S3Guard with {} files and {} directory entries\",\n          countOfFilesWritten, countOfDirsWritten);\n\n      // here all entries are imported.\n      // tell the store that everything should be marked as auth\n      if (authoritative) {\n        LOG.info(\"Marking directory tree {} as authoritative\",\n            basePath);\n        ms.markAsAuthoritative(basePath, operationState);\n      }\n    }\n    return totalCountOfEntriesWritten;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/ImportOperation.java",
      "extendedDetails": {}
    },
    "49df83899543586bbcaf80f01399ade031cf68b0": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
      "commitDate": "10/01/20 3:11 AM",
      "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,98 @@\n+  private long importDir() throws IOException {\n+    Preconditions.checkArgument(status.isDirectory());\n+    long totalCountOfEntriesWritten \u003d 0;\n+    final Path basePath \u003d status.getPath();\n+    final MetadataStore ms \u003d getStore();\n+    LOG.info(\"Importing directory {}\", basePath);\n+    try (BulkOperationState operationState \u003d ms\n+        .initiateBulkWrite(\n+            BulkOperationState.OperationType.Import,\n+            basePath)) {\n+      long countOfFilesWritten \u003d 0;\n+      long countOfDirsWritten \u003d 0;\n+      RemoteIterator\u003cS3ALocatedFileStatus\u003e it \u003d getFilesystem()\n+          .listFilesAndEmptyDirectories(basePath, true);\n+      while (it.hasNext()) {\n+        S3ALocatedFileStatus located \u003d it.next();\n+        S3AFileStatus child;\n+        final Path path \u003d located.getPath();\n+        final boolean isDirectory \u003d located.isDirectory();\n+        if (isDirectory) {\n+          child \u003d DynamoDBMetadataStore.makeDirStatus(path,\n+              located.getOwner());\n+          dirCache.add(path);\n+          // and update the dir count\n+          countOfDirsWritten++;\n+        } else {\n+          child \u003d located.toS3AFileStatus();\n+        }\n+\n+        int parentsWritten \u003d putParentsIfNotPresent(child, operationState);\n+        LOG.debug(\"Wrote {} parent entries\", parentsWritten);\n+\n+        // We don\u0027t blindly overwrite any existing file entry in S3Guard with a\n+        // new one, Because that may lose the version information.\n+        // instead we merge them\n+        if (!isDirectory) {\n+          final PathMetadata existingEntry \u003d S3Guard.getWithTtl(ms, path, null,\n+              false, true);\n+          if (existingEntry !\u003d null) {\n+            final S3AFileStatus existingStatus \u003d existingEntry.getFileStatus();\n+            if (existingStatus.isFile()) {\n+              // source is also a file.\n+              // we only worry about an update if the timestamp is different,\n+              final String existingEtag \u003d existingStatus.getETag();\n+              final String childEtag \u003d child.getETag();\n+              if (child.getModificationTime()\n+                  !\u003d existingStatus.getModificationTime()\n+                  || existingStatus.getLen() !\u003d child.getLen()\n+                  || existingEtag \u003d\u003d null\n+                  || !existingEtag.equals(childEtag)) {\n+                // files are potentially different, though a modtime change\n+                // can just be a clock skew problem\n+                // so if the etag is unchanged, we propagate any versionID\n+                if (childEtag.equals(existingEtag)) {\n+                  // copy over any version ID.\n+                  child.setVersionId(existingStatus.getVersionId());\n+                }\n+              } else {\n+                // the entry modtimes match\n+                child \u003d null;\n+              }\n+            }\n+          }\n+          if (child !\u003d null) {\n+            countOfFilesWritten++;\n+          }\n+        }\n+        if (child !\u003d null) {\n+          // there\u0027s an entry to add.\n+\n+          // log entry spaced to same width\n+          String t \u003d isDirectory ? \"Dir \" : \"File\";\n+          if (verbose) {\n+            LOG.info(\"{} {}\", t, path);\n+          } else {\n+            LOG.debug(\"{} {}\", t, path);\n+          }\n+          S3Guard.putWithTtl(\n+              ms,\n+              new PathMetadata(child),\n+              getFilesystem().getTtlTimeProvider(),\n+              operationState);\n+          totalCountOfEntriesWritten++;\n+        }\n+      }\n+      LOG.info(\"Updated S3Guard with {} files and {} directory entries\",\n+          countOfFilesWritten, countOfDirsWritten);\n+\n+      // here all entries are imported.\n+      // tell the store that everything should be marked as auth\n+      if (authoritative) {\n+        LOG.info(\"Marking directory tree {} as authoritative\",\n+            basePath);\n+        ms.markAsAuthoritative(basePath, operationState);\n+      }\n+    }\n+    return totalCountOfEntriesWritten;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private long importDir() throws IOException {\n    Preconditions.checkArgument(status.isDirectory());\n    long totalCountOfEntriesWritten \u003d 0;\n    final Path basePath \u003d status.getPath();\n    final MetadataStore ms \u003d getStore();\n    LOG.info(\"Importing directory {}\", basePath);\n    try (BulkOperationState operationState \u003d ms\n        .initiateBulkWrite(\n            BulkOperationState.OperationType.Import,\n            basePath)) {\n      long countOfFilesWritten \u003d 0;\n      long countOfDirsWritten \u003d 0;\n      RemoteIterator\u003cS3ALocatedFileStatus\u003e it \u003d getFilesystem()\n          .listFilesAndEmptyDirectories(basePath, true);\n      while (it.hasNext()) {\n        S3ALocatedFileStatus located \u003d it.next();\n        S3AFileStatus child;\n        final Path path \u003d located.getPath();\n        final boolean isDirectory \u003d located.isDirectory();\n        if (isDirectory) {\n          child \u003d DynamoDBMetadataStore.makeDirStatus(path,\n              located.getOwner());\n          dirCache.add(path);\n          // and update the dir count\n          countOfDirsWritten++;\n        } else {\n          child \u003d located.toS3AFileStatus();\n        }\n\n        int parentsWritten \u003d putParentsIfNotPresent(child, operationState);\n        LOG.debug(\"Wrote {} parent entries\", parentsWritten);\n\n        // We don\u0027t blindly overwrite any existing file entry in S3Guard with a\n        // new one, Because that may lose the version information.\n        // instead we merge them\n        if (!isDirectory) {\n          final PathMetadata existingEntry \u003d S3Guard.getWithTtl(ms, path, null,\n              false, true);\n          if (existingEntry !\u003d null) {\n            final S3AFileStatus existingStatus \u003d existingEntry.getFileStatus();\n            if (existingStatus.isFile()) {\n              // source is also a file.\n              // we only worry about an update if the timestamp is different,\n              final String existingEtag \u003d existingStatus.getETag();\n              final String childEtag \u003d child.getETag();\n              if (child.getModificationTime()\n                  !\u003d existingStatus.getModificationTime()\n                  || existingStatus.getLen() !\u003d child.getLen()\n                  || existingEtag \u003d\u003d null\n                  || !existingEtag.equals(childEtag)) {\n                // files are potentially different, though a modtime change\n                // can just be a clock skew problem\n                // so if the etag is unchanged, we propagate any versionID\n                if (childEtag.equals(existingEtag)) {\n                  // copy over any version ID.\n                  child.setVersionId(existingStatus.getVersionId());\n                }\n              } else {\n                // the entry modtimes match\n                child \u003d null;\n              }\n            }\n          }\n          if (child !\u003d null) {\n            countOfFilesWritten++;\n          }\n        }\n        if (child !\u003d null) {\n          // there\u0027s an entry to add.\n\n          // log entry spaced to same width\n          String t \u003d isDirectory ? \"Dir \" : \"File\";\n          if (verbose) {\n            LOG.info(\"{} {}\", t, path);\n          } else {\n            LOG.debug(\"{} {}\", t, path);\n          }\n          S3Guard.putWithTtl(\n              ms,\n              new PathMetadata(child),\n              getFilesystem().getTtlTimeProvider(),\n              operationState);\n          totalCountOfEntriesWritten++;\n        }\n      }\n      LOG.info(\"Updated S3Guard with {} files and {} directory entries\",\n          countOfFilesWritten, countOfDirsWritten);\n\n      // here all entries are imported.\n      // tell the store that everything should be marked as auth\n      if (authoritative) {\n        LOG.info(\"Marking directory tree {} as authoritative\",\n            basePath);\n        ms.markAsAuthoritative(basePath, operationState);\n      }\n    }\n    return totalCountOfEntriesWritten;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/ImportOperation.java"
    }
  }
}