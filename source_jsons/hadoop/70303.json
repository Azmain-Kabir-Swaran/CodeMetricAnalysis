{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "finishSingleFileRename",
  "functionId": "finishSingleFileRename___fileName-String",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 601,
  "functionEndLine": 624,
  "numCommitsSeen": 66,
  "timeTaken": 4012,
  "changeHistory": [
    "325163f23f727e82379d4a385b73aa3a04a510f6",
    "91a96eaa534dbb27e81b6c24bbb8138200a80a83",
    "978bbdfeb2d12efd6e750da6a14849e072fb814b",
    "cb282d5b89fdece4719cc4ad37a6e27f13371534",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40"
  ],
  "changeHistoryShort": {
    "325163f23f727e82379d4a385b73aa3a04a510f6": "Ybodychange",
    "91a96eaa534dbb27e81b6c24bbb8138200a80a83": "Ybodychange",
    "978bbdfeb2d12efd6e750da6a14849e072fb814b": "Ybodychange",
    "cb282d5b89fdece4719cc4ad37a6e27f13371534": "Ybodychange",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Yintroduced"
  },
  "changeHistoryDetails": {
    "325163f23f727e82379d4a385b73aa3a04a510f6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14512. WASB atomic rename should not throw exception if the file is neither in src nor in dst when doing the rename. Contributed by Duo Xu\n",
      "commitDate": "09/06/17 1:07 PM",
      "commitName": "325163f23f727e82379d4a385b73aa3a04a510f6",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "05/06/17 3:56 PM",
      "commitNameOld": "5fd9742c83fbeae96bf0913bdcdf77fafbf15b2f",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,24 @@\n     private void finishSingleFileRename(String fileName)\n         throws IOException {\n       Path srcFile \u003d fullPath(srcKey, fileName);\n       Path dstFile \u003d fullPath(dstKey, fileName);\n       String srcName \u003d fs.pathToKey(srcFile);\n       String dstName \u003d fs.pathToKey(dstFile);\n       boolean srcExists \u003d fs.getStoreInterface().explicitFileExists(srcName);\n       boolean dstExists \u003d fs.getStoreInterface().explicitFileExists(dstName);\n       if(srcExists) {\n         // Rename gets exclusive access (via a lease) for HBase write-ahead log\n         // (WAL) file processing correctness.  See the rename code for details.\n         fs.getStoreInterface().rename(srcName, dstName, true, null);\n       } else if (!srcExists \u0026\u0026 dstExists) {\n         // The rename already finished, so do nothing.\n         ;\n       } else {\n-        throw new IOException(\n-            \"Attempting to complete rename of file \" + srcKey + \"/\" + fileName\n-            + \" during folder rename redo, and file was not found in source \"\n-            + \"or destination.\");\n+        // HADOOP-14512\n+        LOG.warn(\n+          \"Attempting to complete rename of file \" + srcKey + \"/\" + fileName\n+          + \" during folder rename redo, and file was not found in source \"\n+          + \"or destination \" + dstKey + \"/\" + fileName + \". \"\n+          + \"This must mean the rename of this file has already completed\");\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishSingleFileRename(String fileName)\n        throws IOException {\n      Path srcFile \u003d fullPath(srcKey, fileName);\n      Path dstFile \u003d fullPath(dstKey, fileName);\n      String srcName \u003d fs.pathToKey(srcFile);\n      String dstName \u003d fs.pathToKey(dstFile);\n      boolean srcExists \u003d fs.getStoreInterface().explicitFileExists(srcName);\n      boolean dstExists \u003d fs.getStoreInterface().explicitFileExists(dstName);\n      if(srcExists) {\n        // Rename gets exclusive access (via a lease) for HBase write-ahead log\n        // (WAL) file processing correctness.  See the rename code for details.\n        fs.getStoreInterface().rename(srcName, dstName, true, null);\n      } else if (!srcExists \u0026\u0026 dstExists) {\n        // The rename already finished, so do nothing.\n        ;\n      } else {\n        // HADOOP-14512\n        LOG.warn(\n          \"Attempting to complete rename of file \" + srcKey + \"/\" + fileName\n          + \" during folder rename redo, and file was not found in source \"\n          + \"or destination \" + dstKey + \"/\" + fileName + \". \"\n          + \"This must mean the rename of this file has already completed\");\n      }\n    }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "91a96eaa534dbb27e81b6c24bbb8138200a80a83": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12780. During WASB atomic rename handle crash when one directory has been renamed but not file under it. Contributed by Madhumita Chakraborty.\n",
      "commitDate": "12/02/16 3:50 PM",
      "commitName": "91a96eaa534dbb27e81b6c24bbb8138200a80a83",
      "commitAuthor": "cnauroth",
      "commitDateOld": "18/01/16 9:08 AM",
      "commitNameOld": "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 25.28,
      "commitsBetweenForRepo": 196,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,22 @@\n     private void finishSingleFileRename(String fileName)\n         throws IOException {\n       Path srcFile \u003d fullPath(srcKey, fileName);\n       Path dstFile \u003d fullPath(dstKey, fileName);\n-      boolean srcExists \u003d fs.exists(srcFile);\n-      boolean dstExists \u003d fs.exists(dstFile);\n+      String srcName \u003d fs.pathToKey(srcFile);\n+      String dstName \u003d fs.pathToKey(dstFile);\n+      boolean srcExists \u003d fs.getStoreInterface().explicitFileExists(srcName);\n+      boolean dstExists \u003d fs.getStoreInterface().explicitFileExists(dstName);\n       if(srcExists) {\n         // Rename gets exclusive access (via a lease) for HBase write-ahead log\n         // (WAL) file processing correctness.  See the rename code for details.\n-        String srcName \u003d fs.pathToKey(srcFile);\n-        String dstName \u003d fs.pathToKey(dstFile);\n         fs.getStoreInterface().rename(srcName, dstName, true, null);\n       } else if (!srcExists \u0026\u0026 dstExists) {\n         // The rename already finished, so do nothing.\n         ;\n       } else {\n         throw new IOException(\n             \"Attempting to complete rename of file \" + srcKey + \"/\" + fileName\n             + \" during folder rename redo, and file was not found in source \"\n             + \"or destination.\");\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishSingleFileRename(String fileName)\n        throws IOException {\n      Path srcFile \u003d fullPath(srcKey, fileName);\n      Path dstFile \u003d fullPath(dstKey, fileName);\n      String srcName \u003d fs.pathToKey(srcFile);\n      String dstName \u003d fs.pathToKey(dstFile);\n      boolean srcExists \u003d fs.getStoreInterface().explicitFileExists(srcName);\n      boolean dstExists \u003d fs.getStoreInterface().explicitFileExists(dstName);\n      if(srcExists) {\n        // Rename gets exclusive access (via a lease) for HBase write-ahead log\n        // (WAL) file processing correctness.  See the rename code for details.\n        fs.getStoreInterface().rename(srcName, dstName, true, null);\n      } else if (!srcExists \u0026\u0026 dstExists) {\n        // The rename already finished, so do nothing.\n        ;\n      } else {\n        throw new IOException(\n            \"Attempting to complete rename of file \" + srcKey + \"/\" + fileName\n            + \" during folder rename redo, and file was not found in source \"\n            + \"or destination.\");\n      }\n    }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "978bbdfeb2d12efd6e750da6a14849e072fb814b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12634. Change Lazy Rename Pending Operation Completion of WASB to address case of potential data loss due to partial copy. Contributed by Gaurav Kanade.\n",
      "commitDate": "06/01/16 11:15 AM",
      "commitName": "978bbdfeb2d12efd6e750da6a14849e072fb814b",
      "commitAuthor": "cnauroth",
      "commitDateOld": "02/11/15 10:17 AM",
      "commitNameOld": "3ce0a6502e78240f551c29bb27a2324ce359cd70",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 65.04,
      "commitsBetweenForRepo": 375,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,22 @@\n     private void finishSingleFileRename(String fileName)\n         throws IOException {\n       Path srcFile \u003d fullPath(srcKey, fileName);\n       Path dstFile \u003d fullPath(dstKey, fileName);\n       boolean srcExists \u003d fs.exists(srcFile);\n       boolean dstExists \u003d fs.exists(dstFile);\n-      if (srcExists \u0026\u0026 !dstExists) {\n-\n+      if(srcExists) {\n         // Rename gets exclusive access (via a lease) for HBase write-ahead log\n         // (WAL) file processing correctness.  See the rename code for details.\n         String srcName \u003d fs.pathToKey(srcFile);\n         String dstName \u003d fs.pathToKey(dstFile);\n         fs.getStoreInterface().rename(srcName, dstName, true, null);\n-      } else if (srcExists \u0026\u0026 dstExists) {\n-\n-        // Get a lease on source to block write access.\n-        String srcName \u003d fs.pathToKey(srcFile);\n-        SelfRenewingLease lease \u003d null;\n-        try {\n-          lease \u003d fs.acquireLease(srcFile);\n-          // Delete the file. This will free the lease too.\n-          fs.getStoreInterface().delete(srcName, lease);\n-        } catch(AzureException e) {\n-            String errorCode \u003d \"\";\n-            try {\n-              StorageException e2 \u003d (StorageException) e.getCause();\n-              errorCode \u003d e2.getErrorCode();\n-            } catch(Exception e3) {\n-              // do nothing if cast fails\n-            }\n-            // If the rename already finished do nothing\n-            if(!errorCode.equals(\"BlobNotFound\")){\n-              throw e;\n-            }\n-        } finally {\n-          try {\n-            if(lease !\u003d null){\n-              lease.free();\n-            }\n-          } catch(StorageException e) {\n-            LOG.warn(\"Unable to free lease because: \" + e.getMessage());\n-          }\n-        }\n       } else if (!srcExists \u0026\u0026 dstExists) {\n-\n         // The rename already finished, so do nothing.\n         ;\n       } else {\n         throw new IOException(\n             \"Attempting to complete rename of file \" + srcKey + \"/\" + fileName\n             + \" during folder rename redo, and file was not found in source \"\n             + \"or destination.\");\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishSingleFileRename(String fileName)\n        throws IOException {\n      Path srcFile \u003d fullPath(srcKey, fileName);\n      Path dstFile \u003d fullPath(dstKey, fileName);\n      boolean srcExists \u003d fs.exists(srcFile);\n      boolean dstExists \u003d fs.exists(dstFile);\n      if(srcExists) {\n        // Rename gets exclusive access (via a lease) for HBase write-ahead log\n        // (WAL) file processing correctness.  See the rename code for details.\n        String srcName \u003d fs.pathToKey(srcFile);\n        String dstName \u003d fs.pathToKey(dstFile);\n        fs.getStoreInterface().rename(srcName, dstName, true, null);\n      } else if (!srcExists \u0026\u0026 dstExists) {\n        // The rename already finished, so do nothing.\n        ;\n      } else {\n        throw new IOException(\n            \"Attempting to complete rename of file \" + srcKey + \"/\" + fileName\n            + \" during folder rename redo, and file was not found in source \"\n            + \"or destination.\");\n      }\n    }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "cb282d5b89fdece4719cc4ad37a6e27f13371534": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12484. Single File Rename Throws Incorrectly In Potential Race Condition Scenarios. Contributed by Gaurav Kanade.\n",
      "commitDate": "22/10/15 2:29 PM",
      "commitName": "cb282d5b89fdece4719cc4ad37a6e27f13371534",
      "commitAuthor": "cnauroth",
      "commitDateOld": "05/10/15 8:11 PM",
      "commitNameOld": "5f6edb30c2bb648d5564c951edc25645e17e6636",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 16.76,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,54 @@\n     private void finishSingleFileRename(String fileName)\n         throws IOException {\n       Path srcFile \u003d fullPath(srcKey, fileName);\n       Path dstFile \u003d fullPath(dstKey, fileName);\n       boolean srcExists \u003d fs.exists(srcFile);\n       boolean dstExists \u003d fs.exists(dstFile);\n       if (srcExists \u0026\u0026 !dstExists) {\n \n         // Rename gets exclusive access (via a lease) for HBase write-ahead log\n         // (WAL) file processing correctness.  See the rename code for details.\n         String srcName \u003d fs.pathToKey(srcFile);\n         String dstName \u003d fs.pathToKey(dstFile);\n         fs.getStoreInterface().rename(srcName, dstName, true, null);\n       } else if (srcExists \u0026\u0026 dstExists) {\n \n         // Get a lease on source to block write access.\n         String srcName \u003d fs.pathToKey(srcFile);\n-        SelfRenewingLease lease \u003d fs.acquireLease(srcFile);\n-\n-        // Delete the file. This will free the lease too.\n-        fs.getStoreInterface().delete(srcName, lease);\n+        SelfRenewingLease lease \u003d null;\n+        try {\n+          lease \u003d fs.acquireLease(srcFile);\n+          // Delete the file. This will free the lease too.\n+          fs.getStoreInterface().delete(srcName, lease);\n+        } catch(AzureException e) {\n+            String errorCode \u003d \"\";\n+            try {\n+              StorageException e2 \u003d (StorageException) e.getCause();\n+              errorCode \u003d e2.getErrorCode();\n+            } catch(Exception e3) {\n+              // do nothing if cast fails\n+            }\n+            // If the rename already finished do nothing\n+            if(!errorCode.equals(\"BlobNotFound\")){\n+              throw e;\n+            }\n+        } finally {\n+          try {\n+            if(lease !\u003d null){\n+              lease.free();\n+            }\n+          } catch(StorageException e) {\n+            LOG.warn(\"Unable to free lease because: \" + e.getMessage());\n+          }\n+        }\n       } else if (!srcExists \u0026\u0026 dstExists) {\n \n         // The rename already finished, so do nothing.\n         ;\n       } else {\n         throw new IOException(\n             \"Attempting to complete rename of file \" + srcKey + \"/\" + fileName\n             + \" during folder rename redo, and file was not found in source \"\n             + \"or destination.\");\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishSingleFileRename(String fileName)\n        throws IOException {\n      Path srcFile \u003d fullPath(srcKey, fileName);\n      Path dstFile \u003d fullPath(dstKey, fileName);\n      boolean srcExists \u003d fs.exists(srcFile);\n      boolean dstExists \u003d fs.exists(dstFile);\n      if (srcExists \u0026\u0026 !dstExists) {\n\n        // Rename gets exclusive access (via a lease) for HBase write-ahead log\n        // (WAL) file processing correctness.  See the rename code for details.\n        String srcName \u003d fs.pathToKey(srcFile);\n        String dstName \u003d fs.pathToKey(dstFile);\n        fs.getStoreInterface().rename(srcName, dstName, true, null);\n      } else if (srcExists \u0026\u0026 dstExists) {\n\n        // Get a lease on source to block write access.\n        String srcName \u003d fs.pathToKey(srcFile);\n        SelfRenewingLease lease \u003d null;\n        try {\n          lease \u003d fs.acquireLease(srcFile);\n          // Delete the file. This will free the lease too.\n          fs.getStoreInterface().delete(srcName, lease);\n        } catch(AzureException e) {\n            String errorCode \u003d \"\";\n            try {\n              StorageException e2 \u003d (StorageException) e.getCause();\n              errorCode \u003d e2.getErrorCode();\n            } catch(Exception e3) {\n              // do nothing if cast fails\n            }\n            // If the rename already finished do nothing\n            if(!errorCode.equals(\"BlobNotFound\")){\n              throw e;\n            }\n        } finally {\n          try {\n            if(lease !\u003d null){\n              lease.free();\n            }\n          } catch(StorageException e) {\n            LOG.warn(\"Unable to free lease because: \" + e.getMessage());\n          }\n        }\n      } else if (!srcExists \u0026\u0026 dstExists) {\n\n        // The rename already finished, so do nothing.\n        ;\n      } else {\n        throw new IOException(\n            \"Attempting to complete rename of file \" + srcKey + \"/\" + fileName\n            + \" during folder rename redo, and file was not found in source \"\n            + \"or destination.\");\n      }\n    }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "diff": "@@ -0,0 +1,32 @@\n+    private void finishSingleFileRename(String fileName)\n+        throws IOException {\n+      Path srcFile \u003d fullPath(srcKey, fileName);\n+      Path dstFile \u003d fullPath(dstKey, fileName);\n+      boolean srcExists \u003d fs.exists(srcFile);\n+      boolean dstExists \u003d fs.exists(dstFile);\n+      if (srcExists \u0026\u0026 !dstExists) {\n+\n+        // Rename gets exclusive access (via a lease) for HBase write-ahead log\n+        // (WAL) file processing correctness.  See the rename code for details.\n+        String srcName \u003d fs.pathToKey(srcFile);\n+        String dstName \u003d fs.pathToKey(dstFile);\n+        fs.getStoreInterface().rename(srcName, dstName, true, null);\n+      } else if (srcExists \u0026\u0026 dstExists) {\n+\n+        // Get a lease on source to block write access.\n+        String srcName \u003d fs.pathToKey(srcFile);\n+        SelfRenewingLease lease \u003d fs.acquireLease(srcFile);\n+\n+        // Delete the file. This will free the lease too.\n+        fs.getStoreInterface().delete(srcName, lease);\n+      } else if (!srcExists \u0026\u0026 dstExists) {\n+\n+        // The rename already finished, so do nothing.\n+        ;\n+      } else {\n+        throw new IOException(\n+            \"Attempting to complete rename of file \" + srcKey + \"/\" + fileName\n+            + \" during folder rename redo, and file was not found in source \"\n+            + \"or destination.\");\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishSingleFileRename(String fileName)\n        throws IOException {\n      Path srcFile \u003d fullPath(srcKey, fileName);\n      Path dstFile \u003d fullPath(dstKey, fileName);\n      boolean srcExists \u003d fs.exists(srcFile);\n      boolean dstExists \u003d fs.exists(dstFile);\n      if (srcExists \u0026\u0026 !dstExists) {\n\n        // Rename gets exclusive access (via a lease) for HBase write-ahead log\n        // (WAL) file processing correctness.  See the rename code for details.\n        String srcName \u003d fs.pathToKey(srcFile);\n        String dstName \u003d fs.pathToKey(dstFile);\n        fs.getStoreInterface().rename(srcName, dstName, true, null);\n      } else if (srcExists \u0026\u0026 dstExists) {\n\n        // Get a lease on source to block write access.\n        String srcName \u003d fs.pathToKey(srcFile);\n        SelfRenewingLease lease \u003d fs.acquireLease(srcFile);\n\n        // Delete the file. This will free the lease too.\n        fs.getStoreInterface().delete(srcName, lease);\n      } else if (!srcExists \u0026\u0026 dstExists) {\n\n        // The rename already finished, so do nothing.\n        ;\n      } else {\n        throw new IOException(\n            \"Attempting to complete rename of file \" + srcKey + \"/\" + fileName\n            + \" during folder rename redo, and file was not found in source \"\n            + \"or destination.\");\n      }\n    }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}