{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "HostRestrictingAuthorizationFilter.java",
  "functionName": "matchRule",
  "functionId": "matchRule___user-String__remoteIp-String__path-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/HostRestrictingAuthorizationFilter.java",
  "functionStartLine": 94,
  "functionEndLine": 136,
  "numCommitsSeen": 2,
  "timeTaken": 705,
  "changeHistory": [
    "101d5b5f865f94e4772051ea8ce4ee0f92ddedca"
  ],
  "changeHistoryShort": {
    "101d5b5f865f94e4772051ea8ce4ee0f92ddedca": "Yintroduced"
  },
  "changeHistoryDetails": {
    "101d5b5f865f94e4772051ea8ce4ee0f92ddedca": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-14234. Limit WebHDFS to specifc user, host, directory triples.\nContributed by Clay B.\n",
      "commitDate": "10/06/19 5:55 PM",
      "commitName": "101d5b5f865f94e4772051ea8ce4ee0f92ddedca",
      "commitAuthor": "Anu Engineer",
      "diff": "@@ -0,0 +1,43 @@\n+  private boolean matchRule(String user, String remoteIp, String path) {\n+    // allow lookups for blank in the rules for user and path\n+    user \u003d (user !\u003d null ? user : \"\");\n+    path \u003d (path !\u003d null ? path : \"\");\n+\n+    LOG.trace(\"Got user: {}, remoteIp: {}, path: {}\", user, remoteIp, path);\n+\n+    // isInRange fails for null/blank IPs, require an IP to approve\n+    if (remoteIp \u003d\u003d null) {\n+      LOG.trace(\"Returned false due to null rempteIp\");\n+      return false;\n+    }\n+\n+    List\u003cRule\u003e userRules \u003d ((userRules \u003d rulemap.get(user)) !\u003d null) ?\n+        userRules : new ArrayList\u003cRule\u003e();\n+    List\u003cRule\u003e anyRules \u003d ((anyRules \u003d rulemap.get(\"*\")) !\u003d null) ?\n+        anyRules : new ArrayList\u003cRule\u003e();\n+\n+    List\u003cRule\u003e rules \u003d Stream.of(userRules, anyRules)\n+        .flatMap(l -\u003e l.stream()).collect(Collectors.toList());\n+\n+    for (Rule rule : rules) {\n+      SubnetUtils.SubnetInfo subnet \u003d rule.getSubnet();\n+      String rulePath \u003d rule.getPath();\n+      LOG.trace(\"Evaluating rule, subnet: {}, path: {}\",\n+          subnet !\u003d null ? subnet.getCidrSignature() : \"*\", rulePath);\n+      try {\n+        if ((subnet \u003d\u003d null || subnet.isInRange(remoteIp))\n+            \u0026\u0026 FilenameUtils.directoryContains(rulePath, path)) {\n+          LOG.debug(\"Found matching rule, subnet: {}, path: {}; returned true\",\n+              rule.getSubnet() !\u003d null ? subnet.getCidrSignature() : null,\n+              rulePath);\n+          return true;\n+        }\n+      } catch (IOException e) {\n+        LOG.warn(\"Got IOException {}; returned false\", e);\n+        return false;\n+      }\n+    }\n+\n+    LOG.trace(\"Found no rules for user\");\n+    return false;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean matchRule(String user, String remoteIp, String path) {\n    // allow lookups for blank in the rules for user and path\n    user \u003d (user !\u003d null ? user : \"\");\n    path \u003d (path !\u003d null ? path : \"\");\n\n    LOG.trace(\"Got user: {}, remoteIp: {}, path: {}\", user, remoteIp, path);\n\n    // isInRange fails for null/blank IPs, require an IP to approve\n    if (remoteIp \u003d\u003d null) {\n      LOG.trace(\"Returned false due to null rempteIp\");\n      return false;\n    }\n\n    List\u003cRule\u003e userRules \u003d ((userRules \u003d rulemap.get(user)) !\u003d null) ?\n        userRules : new ArrayList\u003cRule\u003e();\n    List\u003cRule\u003e anyRules \u003d ((anyRules \u003d rulemap.get(\"*\")) !\u003d null) ?\n        anyRules : new ArrayList\u003cRule\u003e();\n\n    List\u003cRule\u003e rules \u003d Stream.of(userRules, anyRules)\n        .flatMap(l -\u003e l.stream()).collect(Collectors.toList());\n\n    for (Rule rule : rules) {\n      SubnetUtils.SubnetInfo subnet \u003d rule.getSubnet();\n      String rulePath \u003d rule.getPath();\n      LOG.trace(\"Evaluating rule, subnet: {}, path: {}\",\n          subnet !\u003d null ? subnet.getCidrSignature() : \"*\", rulePath);\n      try {\n        if ((subnet \u003d\u003d null || subnet.isInRange(remoteIp))\n            \u0026\u0026 FilenameUtils.directoryContains(rulePath, path)) {\n          LOG.debug(\"Found matching rule, subnet: {}, path: {}; returned true\",\n              rule.getSubnet() !\u003d null ? subnet.getCidrSignature() : null,\n              rulePath);\n          return true;\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Got IOException {}; returned false\", e);\n        return false;\n      }\n    }\n\n    LOG.trace(\"Found no rules for user\");\n    return false;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/HostRestrictingAuthorizationFilter.java"
    }
  }
}