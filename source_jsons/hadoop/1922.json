{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReplicatedBlockStats.java",
  "functionName": "merge",
  "functionId": "merge___stats-Collection__ReplicatedBlockStats__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/ReplicatedBlockStats.java",
  "functionStartLine": 122,
  "functionEndLine": 155,
  "numCommitsSeen": 4,
  "timeTaken": 1184,
  "changeHistory": [
    "5eeb6da2d44335a27dc79e59e6ca561247b46a31"
  ],
  "changeHistoryShort": {
    "5eeb6da2d44335a27dc79e59e6ca561247b46a31": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5eeb6da2d44335a27dc79e59e6ca561247b46a31": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-14714. RBF: implement getReplicatedBlockStats interface. Contributed by Chen Zhang.\n",
      "commitDate": "21/08/19 9:38 AM",
      "commitName": "5eeb6da2d44335a27dc79e59e6ca561247b46a31",
      "commitAuthor": "Inigo Goiri",
      "diff": "@@ -0,0 +1,34 @@\n+  public static ReplicatedBlockStats merge(\n+      Collection\u003cReplicatedBlockStats\u003e stats) {\n+    long lowRedundancyBlocks \u003d 0;\n+    long corruptBlocks \u003d 0;\n+    long missingBlocks \u003d 0;\n+    long missingReplicationOneBlocks \u003d 0;\n+    long bytesInFutureBlocks \u003d 0;\n+    long pendingDeletionBlocks \u003d 0;\n+    long highestPriorityLowRedundancyBlocks \u003d 0;\n+    boolean hasHighestPriorityLowRedundancyBlocks \u003d false;\n+\n+    // long\u0027s range is large enough that we don\u0027t need to consider overflow\n+    for (ReplicatedBlockStats stat : stats) {\n+      lowRedundancyBlocks +\u003d stat.getLowRedundancyBlocks();\n+      corruptBlocks +\u003d stat.getCorruptBlocks();\n+      missingBlocks +\u003d stat.getMissingReplicaBlocks();\n+      missingReplicationOneBlocks +\u003d stat.getMissingReplicationOneBlocks();\n+      bytesInFutureBlocks +\u003d stat.getBytesInFutureBlocks();\n+      pendingDeletionBlocks +\u003d stat.getPendingDeletionBlocks();\n+      if (stat.hasHighestPriorityLowRedundancyBlocks()) {\n+        hasHighestPriorityLowRedundancyBlocks \u003d true;\n+        highestPriorityLowRedundancyBlocks +\u003d\n+            stat.getHighestPriorityLowRedundancyBlocks();\n+      }\n+    }\n+    if (hasHighestPriorityLowRedundancyBlocks) {\n+      return new ReplicatedBlockStats(lowRedundancyBlocks, corruptBlocks,\n+          missingBlocks, missingReplicationOneBlocks, bytesInFutureBlocks,\n+          pendingDeletionBlocks, highestPriorityLowRedundancyBlocks);\n+    }\n+    return new ReplicatedBlockStats(lowRedundancyBlocks, corruptBlocks,\n+        missingBlocks, missingReplicationOneBlocks, bytesInFutureBlocks,\n+        pendingDeletionBlocks);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static ReplicatedBlockStats merge(\n      Collection\u003cReplicatedBlockStats\u003e stats) {\n    long lowRedundancyBlocks \u003d 0;\n    long corruptBlocks \u003d 0;\n    long missingBlocks \u003d 0;\n    long missingReplicationOneBlocks \u003d 0;\n    long bytesInFutureBlocks \u003d 0;\n    long pendingDeletionBlocks \u003d 0;\n    long highestPriorityLowRedundancyBlocks \u003d 0;\n    boolean hasHighestPriorityLowRedundancyBlocks \u003d false;\n\n    // long\u0027s range is large enough that we don\u0027t need to consider overflow\n    for (ReplicatedBlockStats stat : stats) {\n      lowRedundancyBlocks +\u003d stat.getLowRedundancyBlocks();\n      corruptBlocks +\u003d stat.getCorruptBlocks();\n      missingBlocks +\u003d stat.getMissingReplicaBlocks();\n      missingReplicationOneBlocks +\u003d stat.getMissingReplicationOneBlocks();\n      bytesInFutureBlocks +\u003d stat.getBytesInFutureBlocks();\n      pendingDeletionBlocks +\u003d stat.getPendingDeletionBlocks();\n      if (stat.hasHighestPriorityLowRedundancyBlocks()) {\n        hasHighestPriorityLowRedundancyBlocks \u003d true;\n        highestPriorityLowRedundancyBlocks +\u003d\n            stat.getHighestPriorityLowRedundancyBlocks();\n      }\n    }\n    if (hasHighestPriorityLowRedundancyBlocks) {\n      return new ReplicatedBlockStats(lowRedundancyBlocks, corruptBlocks,\n          missingBlocks, missingReplicationOneBlocks, bytesInFutureBlocks,\n          pendingDeletionBlocks, highestPriorityLowRedundancyBlocks);\n    }\n    return new ReplicatedBlockStats(lowRedundancyBlocks, corruptBlocks,\n        missingBlocks, missingReplicationOneBlocks, bytesInFutureBlocks,\n        pendingDeletionBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/ReplicatedBlockStats.java"
    }
  }
}