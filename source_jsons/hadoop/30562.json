{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineACLsManager.java",
  "functionName": "checkAccess",
  "functionId": "checkAccess___callerUGI-UserGroupInformation__applicationAccessType-ApplicationAccessType__entity-TimelineEntity",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineACLsManager.java",
  "functionStartLine": 103,
  "functionEndLine": 144,
  "numCommitsSeen": 13,
  "timeTaken": 2343,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
    "a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705",
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
    "7f0724dddb75d24b91f67b581a08f89f1ecfadf0",
    "892ada8fb35d57a1120d548fdefb056824aa939f"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614": "Ymultichange(Yparameterchange,Ybodychange)",
    "a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705": "Ybodychange",
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c": "Yfilerename",
    "7f0724dddb75d24b91f67b581a08f89f1ecfadf0": "Ybodychange",
    "892ada8fb35d57a1120d548fdefb056824aa939f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "07/08/17 2:56 AM",
      "commitNameOld": "839e077faf4019d6efdcd89d95930023cd0b0a08",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 585.56,
      "commitsBetweenForRepo": 5057,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,42 @@\n   public boolean checkAccess(UserGroupInformation callerUGI,\n       ApplicationAccessType applicationAccessType,\n       TimelineEntity entity) throws YarnException, IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Verifying the access of \"\n           + (callerUGI \u003d\u003d null ? null : callerUGI.getShortUserName())\n           + \" on the timeline entity \"\n           + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n     }\n \n     if (!adminAclsManager.areACLsEnabled()) {\n       return true;\n     }\n \n     // find domain owner and acls\n     AccessControlListExt aclExt \u003d aclExts.get(entity.getDomainId());\n     if (aclExt \u003d\u003d null) {\n       aclExt \u003d loadDomainFromTimelineStore(entity.getDomainId());\n     }\n     if (aclExt \u003d\u003d null) {\n       throw new YarnException(\"Domain information of the timeline entity \"\n           + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n           + \" doesn\u0027t exist.\");\n     }\n     String owner \u003d aclExt.owner;\n     AccessControlList domainACL \u003d aclExt.acls.get(applicationAccessType);\n     if (domainACL \u003d\u003d null) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"ACL not found for access-type \" + applicationAccessType\n-            + \" for domain \" + entity.getDomainId() + \" owned by \"\n-            + owner + \". Using default [\"\n-            + YarnConfiguration.DEFAULT_YARN_APP_ACL + \"]\");\n-      }\n+      LOG.debug(\"ACL not found for access-type {} for domain {} owned by {}.\"\n+          + \" Using default [{}]\", applicationAccessType,\n+          entity.getDomainId(), owner, YarnConfiguration.DEFAULT_YARN_APP_ACL);\n       domainACL \u003d\n           new AccessControlList(YarnConfiguration.DEFAULT_YARN_APP_ACL);\n     }\n \n     if (callerUGI !\u003d null\n         \u0026\u0026 (adminAclsManager.isAdmin(callerUGI) ||\n             callerUGI.getShortUserName().equals(owner) ||\n             domainACL.isUserAllowed(callerUGI))) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean checkAccess(UserGroupInformation callerUGI,\n      ApplicationAccessType applicationAccessType,\n      TimelineEntity entity) throws YarnException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Verifying the access of \"\n          + (callerUGI \u003d\u003d null ? null : callerUGI.getShortUserName())\n          + \" on the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n    }\n\n    if (!adminAclsManager.areACLsEnabled()) {\n      return true;\n    }\n\n    // find domain owner and acls\n    AccessControlListExt aclExt \u003d aclExts.get(entity.getDomainId());\n    if (aclExt \u003d\u003d null) {\n      aclExt \u003d loadDomainFromTimelineStore(entity.getDomainId());\n    }\n    if (aclExt \u003d\u003d null) {\n      throw new YarnException(\"Domain information of the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n          + \" doesn\u0027t exist.\");\n    }\n    String owner \u003d aclExt.owner;\n    AccessControlList domainACL \u003d aclExt.acls.get(applicationAccessType);\n    if (domainACL \u003d\u003d null) {\n      LOG.debug(\"ACL not found for access-type {} for domain {} owned by {}.\"\n          + \" Using default [{}]\", applicationAccessType,\n          entity.getDomainId(), owner, YarnConfiguration.DEFAULT_YARN_APP_ACL);\n      domainACL \u003d\n          new AccessControlList(YarnConfiguration.DEFAULT_YARN_APP_ACL);\n    }\n\n    if (callerUGI !\u003d null\n        \u0026\u0026 (adminAclsManager.isAdmin(callerUGI) ||\n            callerUGI.getShortUserName().equals(owner) ||\n            domainACL.isUserAllowed(callerUGI))) {\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineACLsManager.java",
      "extendedDetails": {}
    },
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2446. Augmented Timeline service APIs to start taking in domains as a parameter while posting entities and events. Contributed by Zhijie Shen.\n",
      "commitDate": "01/10/14 5:52 PM",
      "commitName": "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2446. Augmented Timeline service APIs to start taking in domains as a parameter while posting entities and events. Contributed by Zhijie Shen.\n",
          "commitDate": "01/10/14 5:52 PM",
          "commitName": "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "24/09/14 11:27 AM",
          "commitNameOld": "d78b452a4f413c6931a494c33df0666ce9b44973",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 7.27,
          "commitsBetweenForRepo": 96,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,45 @@\n   public boolean checkAccess(UserGroupInformation callerUGI,\n+      ApplicationAccessType applicationAccessType,\n       TimelineEntity entity) throws YarnException, IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Verifying the access of \"\n           + (callerUGI \u003d\u003d null ? null : callerUGI.getShortUserName())\n           + \" on the timeline entity \"\n           + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n     }\n \n     if (!adminAclsManager.areACLsEnabled()) {\n       return true;\n     }\n \n-    Set\u003cObject\u003e values \u003d\n-        entity.getPrimaryFilters().get(\n-            SystemFilter.ENTITY_OWNER.toString());\n-    if (values \u003d\u003d null || values.size() !\u003d 1) {\n-      throw new YarnException(\"Owner information of the timeline entity \"\n-          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n-          + \" is corrupted.\");\n+    // find domain owner and acls\n+    AccessControlListExt aclExt \u003d aclExts.get(entity.getDomainId());\n+    if (aclExt \u003d\u003d null) {\n+      aclExt \u003d loadDomainFromTimelineStore(entity.getDomainId());\n     }\n-    String owner \u003d values.iterator().next().toString();\n-    // TODO: Currently we just check the user is the admin or the timeline\n-    // entity owner. In the future, we need to check whether the user is in the\n-    // allowed user/group list\n+    if (aclExt \u003d\u003d null) {\n+      throw new YarnException(\"Domain information of the timeline entity \"\n+          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n+          + \" doesn\u0027t exist.\");\n+    }\n+    String owner \u003d aclExt.owner;\n+    AccessControlList domainACL \u003d aclExt.acls.get(applicationAccessType);\n+    if (domainACL \u003d\u003d null) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"ACL not found for access-type \" + applicationAccessType\n+            + \" for domain \" + entity.getDomainId() + \" owned by \"\n+            + owner + \". Using default [\"\n+            + YarnConfiguration.DEFAULT_YARN_APP_ACL + \"]\");\n+      }\n+      domainACL \u003d\n+          new AccessControlList(YarnConfiguration.DEFAULT_YARN_APP_ACL);\n+    }\n+\n     if (callerUGI !\u003d null\n         \u0026\u0026 (adminAclsManager.isAdmin(callerUGI) ||\n-            callerUGI.getShortUserName().equals(owner))) {\n+            callerUGI.getShortUserName().equals(owner) ||\n+            domainACL.isUserAllowed(callerUGI))) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean checkAccess(UserGroupInformation callerUGI,\n      ApplicationAccessType applicationAccessType,\n      TimelineEntity entity) throws YarnException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Verifying the access of \"\n          + (callerUGI \u003d\u003d null ? null : callerUGI.getShortUserName())\n          + \" on the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n    }\n\n    if (!adminAclsManager.areACLsEnabled()) {\n      return true;\n    }\n\n    // find domain owner and acls\n    AccessControlListExt aclExt \u003d aclExts.get(entity.getDomainId());\n    if (aclExt \u003d\u003d null) {\n      aclExt \u003d loadDomainFromTimelineStore(entity.getDomainId());\n    }\n    if (aclExt \u003d\u003d null) {\n      throw new YarnException(\"Domain information of the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n          + \" doesn\u0027t exist.\");\n    }\n    String owner \u003d aclExt.owner;\n    AccessControlList domainACL \u003d aclExt.acls.get(applicationAccessType);\n    if (domainACL \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ACL not found for access-type \" + applicationAccessType\n            + \" for domain \" + entity.getDomainId() + \" owned by \"\n            + owner + \". Using default [\"\n            + YarnConfiguration.DEFAULT_YARN_APP_ACL + \"]\");\n      }\n      domainACL \u003d\n          new AccessControlList(YarnConfiguration.DEFAULT_YARN_APP_ACL);\n    }\n\n    if (callerUGI !\u003d null\n        \u0026\u0026 (adminAclsManager.isAdmin(callerUGI) ||\n            callerUGI.getShortUserName().equals(owner) ||\n            domainACL.isUserAllowed(callerUGI))) {\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineACLsManager.java",
          "extendedDetails": {
            "oldValue": "[callerUGI-UserGroupInformation, entity-TimelineEntity]",
            "newValue": "[callerUGI-UserGroupInformation, applicationAccessType-ApplicationAccessType, entity-TimelineEntity]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2446. Augmented Timeline service APIs to start taking in domains as a parameter while posting entities and events. Contributed by Zhijie Shen.\n",
          "commitDate": "01/10/14 5:52 PM",
          "commitName": "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "24/09/14 11:27 AM",
          "commitNameOld": "d78b452a4f413c6931a494c33df0666ce9b44973",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 7.27,
          "commitsBetweenForRepo": 96,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,45 @@\n   public boolean checkAccess(UserGroupInformation callerUGI,\n+      ApplicationAccessType applicationAccessType,\n       TimelineEntity entity) throws YarnException, IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Verifying the access of \"\n           + (callerUGI \u003d\u003d null ? null : callerUGI.getShortUserName())\n           + \" on the timeline entity \"\n           + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n     }\n \n     if (!adminAclsManager.areACLsEnabled()) {\n       return true;\n     }\n \n-    Set\u003cObject\u003e values \u003d\n-        entity.getPrimaryFilters().get(\n-            SystemFilter.ENTITY_OWNER.toString());\n-    if (values \u003d\u003d null || values.size() !\u003d 1) {\n-      throw new YarnException(\"Owner information of the timeline entity \"\n-          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n-          + \" is corrupted.\");\n+    // find domain owner and acls\n+    AccessControlListExt aclExt \u003d aclExts.get(entity.getDomainId());\n+    if (aclExt \u003d\u003d null) {\n+      aclExt \u003d loadDomainFromTimelineStore(entity.getDomainId());\n     }\n-    String owner \u003d values.iterator().next().toString();\n-    // TODO: Currently we just check the user is the admin or the timeline\n-    // entity owner. In the future, we need to check whether the user is in the\n-    // allowed user/group list\n+    if (aclExt \u003d\u003d null) {\n+      throw new YarnException(\"Domain information of the timeline entity \"\n+          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n+          + \" doesn\u0027t exist.\");\n+    }\n+    String owner \u003d aclExt.owner;\n+    AccessControlList domainACL \u003d aclExt.acls.get(applicationAccessType);\n+    if (domainACL \u003d\u003d null) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"ACL not found for access-type \" + applicationAccessType\n+            + \" for domain \" + entity.getDomainId() + \" owned by \"\n+            + owner + \". Using default [\"\n+            + YarnConfiguration.DEFAULT_YARN_APP_ACL + \"]\");\n+      }\n+      domainACL \u003d\n+          new AccessControlList(YarnConfiguration.DEFAULT_YARN_APP_ACL);\n+    }\n+\n     if (callerUGI !\u003d null\n         \u0026\u0026 (adminAclsManager.isAdmin(callerUGI) ||\n-            callerUGI.getShortUserName().equals(owner))) {\n+            callerUGI.getShortUserName().equals(owner) ||\n+            domainACL.isUserAllowed(callerUGI))) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean checkAccess(UserGroupInformation callerUGI,\n      ApplicationAccessType applicationAccessType,\n      TimelineEntity entity) throws YarnException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Verifying the access of \"\n          + (callerUGI \u003d\u003d null ? null : callerUGI.getShortUserName())\n          + \" on the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n    }\n\n    if (!adminAclsManager.areACLsEnabled()) {\n      return true;\n    }\n\n    // find domain owner and acls\n    AccessControlListExt aclExt \u003d aclExts.get(entity.getDomainId());\n    if (aclExt \u003d\u003d null) {\n      aclExt \u003d loadDomainFromTimelineStore(entity.getDomainId());\n    }\n    if (aclExt \u003d\u003d null) {\n      throw new YarnException(\"Domain information of the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n          + \" doesn\u0027t exist.\");\n    }\n    String owner \u003d aclExt.owner;\n    AccessControlList domainACL \u003d aclExt.acls.get(applicationAccessType);\n    if (domainACL \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ACL not found for access-type \" + applicationAccessType\n            + \" for domain \" + entity.getDomainId() + \" owned by \"\n            + owner + \". Using default [\"\n            + YarnConfiguration.DEFAULT_YARN_APP_ACL + \"]\");\n      }\n      domainACL \u003d\n          new AccessControlList(YarnConfiguration.DEFAULT_YARN_APP_ACL);\n    }\n\n    if (callerUGI !\u003d null\n        \u0026\u0026 (adminAclsManager.isAdmin(callerUGI) ||\n            callerUGI.getShortUserName().equals(owner) ||\n            domainACL.isUserAllowed(callerUGI))) {\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineACLsManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2228. Augmented TimelineServer to load pseudo authentication filter when authentication \u003d simple. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1610575 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/07/14 9:33 PM",
      "commitName": "a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "28/05/14 11:09 AM",
      "commitNameOld": "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 47.43,
      "commitsBetweenForRepo": 298,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,32 @@\n   public boolean checkAccess(UserGroupInformation callerUGI,\n       TimelineEntity entity) throws YarnException, IOException {\n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Verifying the access of \" + callerUGI.getShortUserName()\n+      LOG.debug(\"Verifying the access of \"\n+          + (callerUGI \u003d\u003d null ? null : callerUGI.getShortUserName())\n           + \" on the timeline entity \"\n           + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n     }\n \n     if (!adminAclsManager.areACLsEnabled()) {\n       return true;\n     }\n \n     Set\u003cObject\u003e values \u003d\n         entity.getPrimaryFilters().get(\n             SystemFilter.ENTITY_OWNER.toString());\n     if (values \u003d\u003d null || values.size() !\u003d 1) {\n       throw new YarnException(\"Owner information of the timeline entity \"\n           + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n           + \" is corrupted.\");\n     }\n     String owner \u003d values.iterator().next().toString();\n     // TODO: Currently we just check the user is the admin or the timeline\n     // entity owner. In the future, we need to check whether the user is in the\n     // allowed user/group list\n     if (callerUGI !\u003d null\n         \u0026\u0026 (adminAclsManager.isAdmin(callerUGI) ||\n             callerUGI.getShortUserName().equals(owner))) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean checkAccess(UserGroupInformation callerUGI,\n      TimelineEntity entity) throws YarnException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Verifying the access of \"\n          + (callerUGI \u003d\u003d null ? null : callerUGI.getShortUserName())\n          + \" on the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n    }\n\n    if (!adminAclsManager.areACLsEnabled()) {\n      return true;\n    }\n\n    Set\u003cObject\u003e values \u003d\n        entity.getPrimaryFilters().get(\n            SystemFilter.ENTITY_OWNER.toString());\n    if (values \u003d\u003d null || values.size() !\u003d 1) {\n      throw new YarnException(\"Owner information of the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n          + \" is corrupted.\");\n    }\n    String owner \u003d values.iterator().next().toString();\n    // TODO: Currently we just check the user is the admin or the timeline\n    // entity owner. In the future, we need to check whether the user is in the\n    // allowed user/group list\n    if (callerUGI !\u003d null\n        \u0026\u0026 (adminAclsManager.isAdmin(callerUGI) ||\n            callerUGI.getShortUserName().equals(owner))) {\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineACLsManager.java",
      "extendedDetails": {}
    },
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c": {
      "type": "Yfilerename",
      "commitMessage": "YARN-2107. Refactored timeline classes into o.a.h.y.s.timeline package. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598094 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/05/14 11:09 AM",
      "commitName": "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "28/05/14 10:44 AM",
      "commitNameOld": "cfd8647d0f20c08761f908be1f5b718c1c372498",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public boolean checkAccess(UserGroupInformation callerUGI,\n      TimelineEntity entity) throws YarnException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Verifying the access of \" + callerUGI.getShortUserName()\n          + \" on the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n    }\n\n    if (!adminAclsManager.areACLsEnabled()) {\n      return true;\n    }\n\n    Set\u003cObject\u003e values \u003d\n        entity.getPrimaryFilters().get(\n            SystemFilter.ENTITY_OWNER.toString());\n    if (values \u003d\u003d null || values.size() !\u003d 1) {\n      throw new YarnException(\"Owner information of the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n          + \" is corrupted.\");\n    }\n    String owner \u003d values.iterator().next().toString();\n    // TODO: Currently we just check the user is the admin or the timeline\n    // entity owner. In the future, we need to check whether the user is in the\n    // allowed user/group list\n    if (callerUGI !\u003d null\n        \u0026\u0026 (adminAclsManager.isAdmin(callerUGI) ||\n            callerUGI.getShortUserName().equals(owner))) {\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineACLsManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/security/TimelineACLsManager.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineACLsManager.java"
      }
    },
    "7f0724dddb75d24b91f67b581a08f89f1ecfadf0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2059. Added admin ACLs support to Timeline Server. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1597207 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/14 3:40 PM",
      "commitName": "7f0724dddb75d24b91f67b581a08f89f1ecfadf0",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "23/05/14 2:19 PM",
      "commitNameOld": "892ada8fb35d57a1120d548fdefb056824aa939f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,31 @@\n   public boolean checkAccess(UserGroupInformation callerUGI,\n       TimelineEntity entity) throws YarnException, IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Verifying the access of \" + callerUGI.getShortUserName()\n           + \" on the timeline entity \"\n           + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n     }\n \n-    if (!aclsEnabled) {\n+    if (!adminAclsManager.areACLsEnabled()) {\n       return true;\n     }\n \n     Set\u003cObject\u003e values \u003d\n         entity.getPrimaryFilters().get(\n             SystemFilter.ENTITY_OWNER.toString());\n     if (values \u003d\u003d null || values.size() !\u003d 1) {\n       throw new YarnException(\"Owner information of the timeline entity \"\n           + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n           + \" is corrupted.\");\n     }\n     String owner \u003d values.iterator().next().toString();\n-    // TODO: Currently we just check the user is the timeline entity owner. In\n-    // the future, we need to check whether the user is admin or is in the\n+    // TODO: Currently we just check the user is the admin or the timeline\n+    // entity owner. In the future, we need to check whether the user is in the\n     // allowed user/group list\n-    if (callerUGI !\u003d null \u0026\u0026 callerUGI.getShortUserName().equals(owner)) {\n+    if (callerUGI !\u003d null\n+        \u0026\u0026 (adminAclsManager.isAdmin(callerUGI) ||\n+            callerUGI.getShortUserName().equals(owner))) {\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean checkAccess(UserGroupInformation callerUGI,\n      TimelineEntity entity) throws YarnException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Verifying the access of \" + callerUGI.getShortUserName()\n          + \" on the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n    }\n\n    if (!adminAclsManager.areACLsEnabled()) {\n      return true;\n    }\n\n    Set\u003cObject\u003e values \u003d\n        entity.getPrimaryFilters().get(\n            SystemFilter.ENTITY_OWNER.toString());\n    if (values \u003d\u003d null || values.size() !\u003d 1) {\n      throw new YarnException(\"Owner information of the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n          + \" is corrupted.\");\n    }\n    String owner \u003d values.iterator().next().toString();\n    // TODO: Currently we just check the user is the admin or the timeline\n    // entity owner. In the future, we need to check whether the user is in the\n    // allowed user/group list\n    if (callerUGI !\u003d null\n        \u0026\u0026 (adminAclsManager.isAdmin(callerUGI) ||\n            callerUGI.getShortUserName().equals(owner))) {\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/security/TimelineACLsManager.java",
      "extendedDetails": {}
    },
    "892ada8fb35d57a1120d548fdefb056824aa939f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1937. Added owner-only ACLs support for Timeline Client and server. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1597186 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/14 2:19 PM",
      "commitName": "892ada8fb35d57a1120d548fdefb056824aa939f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,29 @@\n+  public boolean checkAccess(UserGroupInformation callerUGI,\n+      TimelineEntity entity) throws YarnException, IOException {\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Verifying the access of \" + callerUGI.getShortUserName()\n+          + \" on the timeline entity \"\n+          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n+    }\n+\n+    if (!aclsEnabled) {\n+      return true;\n+    }\n+\n+    Set\u003cObject\u003e values \u003d\n+        entity.getPrimaryFilters().get(\n+            SystemFilter.ENTITY_OWNER.toString());\n+    if (values \u003d\u003d null || values.size() !\u003d 1) {\n+      throw new YarnException(\"Owner information of the timeline entity \"\n+          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n+          + \" is corrupted.\");\n+    }\n+    String owner \u003d values.iterator().next().toString();\n+    // TODO: Currently we just check the user is the timeline entity owner. In\n+    // the future, we need to check whether the user is admin or is in the\n+    // allowed user/group list\n+    if (callerUGI !\u003d null \u0026\u0026 callerUGI.getShortUserName().equals(owner)) {\n+      return true;\n+    }\n+    return false;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean checkAccess(UserGroupInformation callerUGI,\n      TimelineEntity entity) throws YarnException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Verifying the access of \" + callerUGI.getShortUserName()\n          + \" on the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n    }\n\n    if (!aclsEnabled) {\n      return true;\n    }\n\n    Set\u003cObject\u003e values \u003d\n        entity.getPrimaryFilters().get(\n            SystemFilter.ENTITY_OWNER.toString());\n    if (values \u003d\u003d null || values.size() !\u003d 1) {\n      throw new YarnException(\"Owner information of the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n          + \" is corrupted.\");\n    }\n    String owner \u003d values.iterator().next().toString();\n    // TODO: Currently we just check the user is the timeline entity owner. In\n    // the future, we need to check whether the user is admin or is in the\n    // allowed user/group list\n    if (callerUGI !\u003d null \u0026\u0026 callerUGI.getShortUserName().equals(owner)) {\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/security/TimelineACLsManager.java"
    }
  }
}