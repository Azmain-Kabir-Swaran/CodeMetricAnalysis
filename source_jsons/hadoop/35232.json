{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NMLeveldbStateStoreService.java",
  "functionName": "loadAMRMProxyState",
  "functionId": "loadAMRMProxyState",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/recovery/NMLeveldbStateStoreService.java",
  "functionStartLine": 1494,
  "functionEndLine": 1567,
  "numCommitsSeen": 43,
  "timeTaken": 1503,
  "changeHistory": [
    "49aa60e50d20f8c18ed6f00fa8966244536fe7da"
  ],
  "changeHistoryShort": {
    "49aa60e50d20f8c18ed6f00fa8966244536fe7da": "Yintroduced"
  },
  "changeHistoryDetails": {
    "49aa60e50d20f8c18ed6f00fa8966244536fe7da": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6127. Add support for work preserving NM restart when AMRMProxy is enabled. (Botong Huang via asuresh).\n",
      "commitDate": "22/06/17 11:27 AM",
      "commitName": "49aa60e50d20f8c18ed6f00fa8966244536fe7da",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,74 @@\n+  public RecoveredAMRMProxyState loadAMRMProxyState() throws IOException {\n+    RecoveredAMRMProxyState result \u003d new RecoveredAMRMProxyState();\n+    Set\u003cString\u003e unknownKeys \u003d new HashSet\u003c\u003e();\n+    LeveldbIterator iter \u003d null;\n+    try {\n+      iter \u003d new LeveldbIterator(db);\n+      iter.seek(bytes(AMRMPROXY_KEY_PREFIX));\n+      while (iter.hasNext()) {\n+        Entry\u003cbyte[], byte[]\u003e entry \u003d iter.peekNext();\n+        String key \u003d asString(entry.getKey());\n+        if (!key.startsWith(AMRMPROXY_KEY_PREFIX)) {\n+          break;\n+        }\n+\n+        String suffix \u003d key.substring(AMRMPROXY_KEY_PREFIX.length());\n+        if (suffix.equals(CURRENT_MASTER_KEY_SUFFIX)) {\n+          iter.next();\n+          result.setCurrentMasterKey(parseMasterKey(entry.getValue()));\n+          LOG.info(\"Recovered for AMRMProxy: current master key id \"\n+              + result.getCurrentMasterKey().getKeyId());\n+\n+        } else if (suffix.equals(NEXT_MASTER_KEY_SUFFIX)) {\n+          iter.next();\n+          result.setNextMasterKey(parseMasterKey(entry.getValue()));\n+          LOG.info(\"Recovered for AMRMProxy: next master key id \"\n+              + result.getNextMasterKey().getKeyId());\n+\n+        } else { // Load AMRMProxy application context map for an app attempt\n+          // Parse appAttemptId, also handle the unknown keys\n+          int idEndPos;\n+          ApplicationAttemptId attemptId;\n+          try {\n+            idEndPos \u003d key.indexOf(\u0027/\u0027, AMRMPROXY_KEY_PREFIX.length());\n+            if (idEndPos \u003c 0) {\n+              throw new IOException(\n+                  \"Unable to determine attemptId in key: \" + key);\n+            }\n+            attemptId \u003d ApplicationAttemptId.fromString(\n+                key.substring(AMRMPROXY_KEY_PREFIX.length(), idEndPos));\n+          } catch (Exception e) {\n+            // Try to move on for back-forward compatibility\n+            LOG.warn(\"Unknown key \" + key + \", remove and move on\", e);\n+            // Do this because iter.remove() is not supported here\n+            unknownKeys.add(key);\n+            continue;\n+          }\n+          // Parse the context map for the appAttemptId\n+          Map\u003cString, byte[]\u003e appContext \u003d\n+              loadAMRMProxyAppContextMap(iter, key.substring(0, idEndPos + 1));\n+          result.getAppContexts().put(attemptId, appContext);\n+\n+          LOG.info(\"Recovered for AMRMProxy: \" + attemptId + \", map size \"\n+              + appContext.size());\n+        }\n+      }\n+    } catch (DBException e) {\n+      throw new IOException(e);\n+    } finally {\n+      if (iter !\u003d null) {\n+        iter.close();\n+      }\n+    }\n+\n+    // Delete all unknown keys\n+    try {\n+      for (String key : unknownKeys) {\n+        db.delete(bytes(key));\n+      }\n+    } catch (DBException e) {\n+      throw new IOException(e);\n+    }\n+\n+    return result;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public RecoveredAMRMProxyState loadAMRMProxyState() throws IOException {\n    RecoveredAMRMProxyState result \u003d new RecoveredAMRMProxyState();\n    Set\u003cString\u003e unknownKeys \u003d new HashSet\u003c\u003e();\n    LeveldbIterator iter \u003d null;\n    try {\n      iter \u003d new LeveldbIterator(db);\n      iter.seek(bytes(AMRMPROXY_KEY_PREFIX));\n      while (iter.hasNext()) {\n        Entry\u003cbyte[], byte[]\u003e entry \u003d iter.peekNext();\n        String key \u003d asString(entry.getKey());\n        if (!key.startsWith(AMRMPROXY_KEY_PREFIX)) {\n          break;\n        }\n\n        String suffix \u003d key.substring(AMRMPROXY_KEY_PREFIX.length());\n        if (suffix.equals(CURRENT_MASTER_KEY_SUFFIX)) {\n          iter.next();\n          result.setCurrentMasterKey(parseMasterKey(entry.getValue()));\n          LOG.info(\"Recovered for AMRMProxy: current master key id \"\n              + result.getCurrentMasterKey().getKeyId());\n\n        } else if (suffix.equals(NEXT_MASTER_KEY_SUFFIX)) {\n          iter.next();\n          result.setNextMasterKey(parseMasterKey(entry.getValue()));\n          LOG.info(\"Recovered for AMRMProxy: next master key id \"\n              + result.getNextMasterKey().getKeyId());\n\n        } else { // Load AMRMProxy application context map for an app attempt\n          // Parse appAttemptId, also handle the unknown keys\n          int idEndPos;\n          ApplicationAttemptId attemptId;\n          try {\n            idEndPos \u003d key.indexOf(\u0027/\u0027, AMRMPROXY_KEY_PREFIX.length());\n            if (idEndPos \u003c 0) {\n              throw new IOException(\n                  \"Unable to determine attemptId in key: \" + key);\n            }\n            attemptId \u003d ApplicationAttemptId.fromString(\n                key.substring(AMRMPROXY_KEY_PREFIX.length(), idEndPos));\n          } catch (Exception e) {\n            // Try to move on for back-forward compatibility\n            LOG.warn(\"Unknown key \" + key + \", remove and move on\", e);\n            // Do this because iter.remove() is not supported here\n            unknownKeys.add(key);\n            continue;\n          }\n          // Parse the context map for the appAttemptId\n          Map\u003cString, byte[]\u003e appContext \u003d\n              loadAMRMProxyAppContextMap(iter, key.substring(0, idEndPos + 1));\n          result.getAppContexts().put(attemptId, appContext);\n\n          LOG.info(\"Recovered for AMRMProxy: \" + attemptId + \", map size \"\n              + appContext.size());\n        }\n      }\n    } catch (DBException e) {\n      throw new IOException(e);\n    } finally {\n      if (iter !\u003d null) {\n        iter.close();\n      }\n    }\n\n    // Delete all unknown keys\n    try {\n      for (String key : unknownKeys) {\n        db.delete(bytes(key));\n      }\n    } catch (DBException e) {\n      throw new IOException(e);\n    }\n\n    return result;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/recovery/NMLeveldbStateStoreService.java"
    }
  }
}