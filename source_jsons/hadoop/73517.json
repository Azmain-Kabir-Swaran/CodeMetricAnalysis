{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Client.java",
  "functionName": "setupIOstreams",
  "functionId": "setupIOstreams___fallbackToSimpleAuth-AtomicBoolean",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
  "functionStartLine": 788,
  "functionEndLine": 890,
  "numCommitsSeen": 222,
  "timeTaken": 6630,
  "changeHistory": [
    "9e96ac666d783376a8cdea9c3cc84098c5bdcb56",
    "27a1a5fde94d4d7ea0ed172635c146d594413781",
    "d4d076876a8d0002bd3a73491d8459d11cb4896c",
    "ed9806ea40b945df0637c21b68964d1d2bd204f3",
    "892ade689f9bcce76daae8f66fc00a49bee8548e",
    "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5",
    "6962510f729717f776929708813f99a28e582f34",
    "2eb913b6ece143f23fec67926550e97dcd931fba",
    "f799618828b0ba09b694b07eaab0689d31f4954d",
    "c03c8fe199429a43c6aa944016566738abd9b193",
    "c6ba793b65014306ec1ff40c61938399412e72c1",
    "f5312aedb9fa3dc895d61844b5c3202b02554f80",
    "65be21267587f04a2c33af65b951211cc9085b15",
    "3eb61be352589491117ac2781bb18f55988a8084",
    "5605b54010b67785085192629d9a191e0c79bd90",
    "22ef03bc7677d6718902a7587bbd26ab750f8d78",
    "589c68ae09effd6c4f26505d61636f779c22e99f",
    "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "f853b52a3b2dc97f750db0a3f6eeaf058fc8884a",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "c47d34a8660923f6f6e21e91aa48ca5780c0ff9f",
    "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539",
    "8b4b190cbd4678b4b6a5d85b32ce831bd3b99da2",
    "1793e7d9094cd984ae402177c5935239059d74e8",
    "940389afce6a1b9b9e1519aed528cbc444786756",
    "c38c5a43ffc2b12a1acb3afd1fa7685775bdeda1",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "9e96ac666d783376a8cdea9c3cc84098c5bdcb56": "Ybodychange",
    "27a1a5fde94d4d7ea0ed172635c146d594413781": "Ybodychange",
    "d4d076876a8d0002bd3a73491d8459d11cb4896c": "Ybodychange",
    "ed9806ea40b945df0637c21b68964d1d2bd204f3": "Ybodychange",
    "892ade689f9bcce76daae8f66fc00a49bee8548e": "Ybodychange",
    "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5": "Ymultichange(Yparameterchange,Ybodychange)",
    "6962510f729717f776929708813f99a28e582f34": "Ybodychange",
    "2eb913b6ece143f23fec67926550e97dcd931fba": "Ybodychange",
    "f799618828b0ba09b694b07eaab0689d31f4954d": "Ybodychange",
    "c03c8fe199429a43c6aa944016566738abd9b193": "Ybodychange",
    "c6ba793b65014306ec1ff40c61938399412e72c1": "Ybodychange",
    "f5312aedb9fa3dc895d61844b5c3202b02554f80": "Ybodychange",
    "65be21267587f04a2c33af65b951211cc9085b15": "Ybodychange",
    "3eb61be352589491117ac2781bb18f55988a8084": "Yexceptionschange",
    "5605b54010b67785085192629d9a191e0c79bd90": "Ybodychange",
    "22ef03bc7677d6718902a7587bbd26ab750f8d78": "Ybodychange",
    "589c68ae09effd6c4f26505d61636f779c22e99f": "Ybodychange",
    "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "f853b52a3b2dc97f750db0a3f6eeaf058fc8884a": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "c47d34a8660923f6f6e21e91aa48ca5780c0ff9f": "Ybodychange",
    "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539": "Ybodychange",
    "8b4b190cbd4678b4b6a5d85b32ce831bd3b99da2": "Ybodychange",
    "1793e7d9094cd984ae402177c5935239059d74e8": "Ybodychange",
    "940389afce6a1b9b9e1519aed528cbc444786756": "Ymultichange(Yexceptionschange,Ybodychange)",
    "c38c5a43ffc2b12a1acb3afd1fa7685775bdeda1": "Ybodychange",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9e96ac666d783376a8cdea9c3cc84098c5bdcb56": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10219. ipc.Client.setupIOstreams() needs to check for ClientCache.stopClient requested shutdowns.\nContributed by Kihwal Lee and Lukas Majercak.\n",
      "commitDate": "04/09/18 8:46 AM",
      "commitName": "9e96ac666d783376a8cdea9c3cc84098c5bdcb56",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "01/08/18 12:32 PM",
      "commitNameOld": "f2e29acbfa0b7e1fcecbdcf3e791c96114b456a5",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 33.84,
      "commitsBetweenForRepo": 261,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,103 @@\n     private synchronized void setupIOstreams(\n         AtomicBoolean fallbackToSimpleAuth) {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       }\n       UserGroupInformation ticket \u003d remoteId.getTicket();\n       if (ticket !\u003d null) {\n         final UserGroupInformation realUser \u003d ticket.getRealUser();\n         if (realUser !\u003d null) {\n           ticket \u003d realUser;\n         }\n       }\n       try {\n+        connectingThread.set(Thread.currentThread());\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         Span span \u003d Tracer.getCurrentSpan();\n         if (span !\u003d null) {\n           span.addTimelineAnnotation(\"IPC client connecting to \" + server);\n         }\n         short numRetries \u003d 0;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection(ticket);\n           ipcStreams \u003d new IpcStreams(socket, maxResponseLength);\n           writeConnectionHeader(ipcStreams);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(ipcStreams);\n                     }\n                   });\n             } catch (IOException ex) {\n               if (saslRpcClient \u003d\u003d null) {\n                 // whatever happened -it can\u0027t be handled, so rethrow\n                 throw ex;\n               }\n               // otherwise, assume a connection problem\n               authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                   rand, ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               ipcStreams.setSaslClient(saslRpcClient);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n               LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n               if (fallbackToSimpleAuth !\u003d null) {\n                 fallbackToSimpleAuth.set(false);\n               }\n             } else if (UserGroupInformation.isSecurityEnabled()) {\n               if (!fallbackAllowed) {\n                 throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                     \"auth, but this client is configured to only allow secure \" +\n                     \"connections.\");\n               }\n               if (fallbackToSimpleAuth !\u003d null) {\n                 fallbackToSimpleAuth.set(true);\n               }\n             }\n           }\n \n           if (doPing) {\n             ipcStreams.setInputStream(new PingInputStream(ipcStreams.in));\n           }\n \n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           span \u003d Tracer.getCurrentSpan();\n           if (span !\u003d null) {\n             span.addTimelineAnnotation(\"IPC client connected to \" + server);\n           }\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams: \" + t, t));\n         }\n         close();\n+      } finally {\n+        connectingThread.set(null);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams(\n        AtomicBoolean fallbackToSimpleAuth) {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      }\n      UserGroupInformation ticket \u003d remoteId.getTicket();\n      if (ticket !\u003d null) {\n        final UserGroupInformation realUser \u003d ticket.getRealUser();\n        if (realUser !\u003d null) {\n          ticket \u003d realUser;\n        }\n      }\n      try {\n        connectingThread.set(Thread.currentThread());\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        Span span \u003d Tracer.getCurrentSpan();\n        if (span !\u003d null) {\n          span.addTimelineAnnotation(\"IPC client connecting to \" + server);\n        }\n        short numRetries \u003d 0;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection(ticket);\n          ipcStreams \u003d new IpcStreams(socket, maxResponseLength);\n          writeConnectionHeader(ipcStreams);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(ipcStreams);\n                    }\n                  });\n            } catch (IOException ex) {\n              if (saslRpcClient \u003d\u003d null) {\n                // whatever happened -it can\u0027t be handled, so rethrow\n                throw ex;\n              }\n              // otherwise, assume a connection problem\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                  rand, ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              ipcStreams.setSaslClient(saslRpcClient);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n              LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(false);\n              }\n            } else if (UserGroupInformation.isSecurityEnabled()) {\n              if (!fallbackAllowed) {\n                throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                    \"auth, but this client is configured to only allow secure \" +\n                    \"connections.\");\n              }\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(true);\n              }\n            }\n          }\n\n          if (doPing) {\n            ipcStreams.setInputStream(new PingInputStream(ipcStreams.in));\n          }\n\n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          span \u003d Tracer.getCurrentSpan();\n          if (span !\u003d null) {\n            span.addTimelineAnnotation(\"IPC client connected to \" + server);\n          }\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams: \" + t, t));\n        }\n        close();\n      } finally {\n        connectingThread.set(null);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "27a1a5fde94d4d7ea0ed172635c146d594413781": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14578. Bind IPC connections to kerberos UPN host for proxy users. Contributed by Daryn Sharp.\n",
      "commitDate": "26/07/17 11:12 AM",
      "commitName": "27a1a5fde94d4d7ea0ed172635c146d594413781",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "17/07/17 9:32 PM",
      "commitNameOld": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 8.57,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,100 @@\n     private synchronized void setupIOstreams(\n         AtomicBoolean fallbackToSimpleAuth) {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n-      } \n+      }\n+      UserGroupInformation ticket \u003d remoteId.getTicket();\n+      if (ticket !\u003d null) {\n+        final UserGroupInformation realUser \u003d ticket.getRealUser();\n+        if (realUser !\u003d null) {\n+          ticket \u003d realUser;\n+        }\n+      }\n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         Span span \u003d Tracer.getCurrentSpan();\n         if (span !\u003d null) {\n           span.addTimelineAnnotation(\"IPC client connecting to \" + server);\n         }\n         short numRetries \u003d 0;\n         Random rand \u003d null;\n         while (true) {\n-          setupConnection();\n+          setupConnection(ticket);\n           ipcStreams \u003d new IpcStreams(socket, maxResponseLength);\n           writeConnectionHeader(ipcStreams);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n-            UserGroupInformation ticket \u003d remoteId.getTicket();\n-            if (ticket.getRealUser() !\u003d null) {\n-              ticket \u003d ticket.getRealUser();\n-            }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(ipcStreams);\n                     }\n                   });\n             } catch (IOException ex) {\n               if (saslRpcClient \u003d\u003d null) {\n                 // whatever happened -it can\u0027t be handled, so rethrow\n                 throw ex;\n               }\n               // otherwise, assume a connection problem\n               authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                   rand, ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               ipcStreams.setSaslClient(saslRpcClient);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n               LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n               if (fallbackToSimpleAuth !\u003d null) {\n                 fallbackToSimpleAuth.set(false);\n               }\n             } else if (UserGroupInformation.isSecurityEnabled()) {\n               if (!fallbackAllowed) {\n                 throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                     \"auth, but this client is configured to only allow secure \" +\n                     \"connections.\");\n               }\n               if (fallbackToSimpleAuth !\u003d null) {\n                 fallbackToSimpleAuth.set(true);\n               }\n             }\n           }\n \n           if (doPing) {\n             ipcStreams.setInputStream(new PingInputStream(ipcStreams.in));\n           }\n \n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           span \u003d Tracer.getCurrentSpan();\n           if (span !\u003d null) {\n             span.addTimelineAnnotation(\"IPC client connected to \" + server);\n           }\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams: \" + t, t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams(\n        AtomicBoolean fallbackToSimpleAuth) {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      }\n      UserGroupInformation ticket \u003d remoteId.getTicket();\n      if (ticket !\u003d null) {\n        final UserGroupInformation realUser \u003d ticket.getRealUser();\n        if (realUser !\u003d null) {\n          ticket \u003d realUser;\n        }\n      }\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        Span span \u003d Tracer.getCurrentSpan();\n        if (span !\u003d null) {\n          span.addTimelineAnnotation(\"IPC client connecting to \" + server);\n        }\n        short numRetries \u003d 0;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection(ticket);\n          ipcStreams \u003d new IpcStreams(socket, maxResponseLength);\n          writeConnectionHeader(ipcStreams);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(ipcStreams);\n                    }\n                  });\n            } catch (IOException ex) {\n              if (saslRpcClient \u003d\u003d null) {\n                // whatever happened -it can\u0027t be handled, so rethrow\n                throw ex;\n              }\n              // otherwise, assume a connection problem\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                  rand, ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              ipcStreams.setSaslClient(saslRpcClient);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n              LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(false);\n              }\n            } else if (UserGroupInformation.isSecurityEnabled()) {\n              if (!fallbackAllowed) {\n                throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                    \"auth, but this client is configured to only allow secure \" +\n                    \"connections.\");\n              }\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(true);\n              }\n            }\n          }\n\n          if (doPing) {\n            ipcStreams.setInputStream(new PingInputStream(ipcStreams.in));\n          }\n\n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          span \u003d Tracer.getCurrentSpan();\n          if (span !\u003d null) {\n            span.addTimelineAnnotation(\"IPC client connected to \" + server);\n          }\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams: \" + t, t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "d4d076876a8d0002bd3a73491d8459d11cb4896c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10940. RPC client does no bounds checking of responses. Contributed by Daryn Sharp.\n",
      "commitDate": "09/09/16 8:39 AM",
      "commitName": "d4d076876a8d0002bd3a73491d8459d11cb4896c",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "02/09/16 9:03 AM",
      "commitNameOld": "23abb09c1f979d8c18ece81e32630a35ed569399",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 6.98,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,97 @@\n     private synchronized void setupIOstreams(\n         AtomicBoolean fallbackToSimpleAuth) {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         Span span \u003d Tracer.getCurrentSpan();\n         if (span !\u003d null) {\n           span.addTimelineAnnotation(\"IPC client connecting to \" + server);\n         }\n         short numRetries \u003d 0;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n-          InputStream inStream \u003d NetUtils.getInputStream(socket);\n-          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n-          writeConnectionHeader(outStream);\n+          ipcStreams \u003d new IpcStreams(socket, maxResponseLength);\n+          writeConnectionHeader(ipcStreams);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n-            final InputStream in2 \u003d inStream;\n-            final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n-                      return setupSaslConnection(in2, out2);\n+                      return setupSaslConnection(ipcStreams);\n                     }\n                   });\n             } catch (IOException ex) {\n               if (saslRpcClient \u003d\u003d null) {\n                 // whatever happened -it can\u0027t be handled, so rethrow\n                 throw ex;\n               }\n               // otherwise, assume a connection problem\n               authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                   rand, ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n-              inStream \u003d saslRpcClient.getInputStream(inStream);\n-              outStream \u003d saslRpcClient.getOutputStream(outStream);\n+              ipcStreams.setSaslClient(saslRpcClient);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n               LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n               if (fallbackToSimpleAuth !\u003d null) {\n                 fallbackToSimpleAuth.set(false);\n               }\n             } else if (UserGroupInformation.isSecurityEnabled()) {\n               if (!fallbackAllowed) {\n                 throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                     \"auth, but this client is configured to only allow secure \" +\n                     \"connections.\");\n               }\n               if (fallbackToSimpleAuth !\u003d null) {\n                 fallbackToSimpleAuth.set(true);\n               }\n             }\n           }\n-        \n-          if (doPing) {\n-            inStream \u003d new PingInputStream(inStream);\n-          }\n-          this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n \n-          // SASL may have already buffered the stream\n-          if (!(outStream instanceof BufferedOutputStream)) {\n-            outStream \u003d new BufferedOutputStream(outStream);\n+          if (doPing) {\n+            ipcStreams.setInputStream(new PingInputStream(ipcStreams.in));\n           }\n-          this.out \u003d new DataOutputStream(outStream);\n-          \n+\n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           span \u003d Tracer.getCurrentSpan();\n           if (span !\u003d null) {\n             span.addTimelineAnnotation(\"IPC client connected to \" + server);\n           }\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams: \" + t, t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams(\n        AtomicBoolean fallbackToSimpleAuth) {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        Span span \u003d Tracer.getCurrentSpan();\n        if (span !\u003d null) {\n          span.addTimelineAnnotation(\"IPC client connecting to \" + server);\n        }\n        short numRetries \u003d 0;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          ipcStreams \u003d new IpcStreams(socket, maxResponseLength);\n          writeConnectionHeader(ipcStreams);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(ipcStreams);\n                    }\n                  });\n            } catch (IOException ex) {\n              if (saslRpcClient \u003d\u003d null) {\n                // whatever happened -it can\u0027t be handled, so rethrow\n                throw ex;\n              }\n              // otherwise, assume a connection problem\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                  rand, ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              ipcStreams.setSaslClient(saslRpcClient);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n              LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(false);\n              }\n            } else if (UserGroupInformation.isSecurityEnabled()) {\n              if (!fallbackAllowed) {\n                throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                    \"auth, but this client is configured to only allow secure \" +\n                    \"connections.\");\n              }\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(true);\n              }\n            }\n          }\n\n          if (doPing) {\n            ipcStreams.setInputStream(new PingInputStream(ipcStreams.in));\n          }\n\n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          span \u003d Tracer.getCurrentSpan();\n          if (span !\u003d null) {\n            span.addTimelineAnnotation(\"IPC client connected to \" + server);\n          }\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams: \" + t, t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "ed9806ea40b945df0637c21b68964d1d2bd204f3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12178. NPE during handling of SASL setup if problem with SASL resolver class. Contributed by Steve Loughran\n",
      "commitDate": "27/10/15 9:51 AM",
      "commitName": "ed9806ea40b945df0637c21b68964d1d2bd204f3",
      "commitAuthor": "Zhihai Xu",
      "commitDateOld": "19/10/15 8:52 AM",
      "commitNameOld": "6144e0137bb51bd04b46ea5ce42c59c2d4f7657d",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 8.04,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,108 @@\n     private synchronized void setupIOstreams(\n         AtomicBoolean fallbackToSimpleAuth) {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         Span span \u003d Tracer.getCurrentSpan();\n         if (span !\u003d null) {\n           span.addTimelineAnnotation(\"IPC client connecting to \" + server);\n         }\n         short numRetries \u003d 0;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n-            } catch (Exception ex) {\n+            } catch (IOException ex) {\n+              if (saslRpcClient \u003d\u003d null) {\n+                // whatever happened -it can\u0027t be handled, so rethrow\n+                throw ex;\n+              }\n+              // otherwise, assume a connection problem\n               authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                   rand, ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n               LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n               if (fallbackToSimpleAuth !\u003d null) {\n                 fallbackToSimpleAuth.set(false);\n               }\n             } else if (UserGroupInformation.isSecurityEnabled()) {\n               if (!fallbackAllowed) {\n                 throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                     \"auth, but this client is configured to only allow secure \" +\n                     \"connections.\");\n               }\n               if (fallbackToSimpleAuth !\u003d null) {\n                 fallbackToSimpleAuth.set(true);\n               }\n             }\n           }\n         \n           if (doPing) {\n             inStream \u003d new PingInputStream(inStream);\n           }\n           this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n \n           // SASL may have already buffered the stream\n           if (!(outStream instanceof BufferedOutputStream)) {\n             outStream \u003d new BufferedOutputStream(outStream);\n           }\n           this.out \u003d new DataOutputStream(outStream);\n           \n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           span \u003d Tracer.getCurrentSpan();\n           if (span !\u003d null) {\n             span.addTimelineAnnotation(\"IPC client connected to \" + server);\n           }\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n-          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n+          markClosed(new IOException(\"Couldn\u0027t set up IO streams: \" + t, t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams(\n        AtomicBoolean fallbackToSimpleAuth) {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        Span span \u003d Tracer.getCurrentSpan();\n        if (span !\u003d null) {\n          span.addTimelineAnnotation(\"IPC client connecting to \" + server);\n        }\n        short numRetries \u003d 0;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (IOException ex) {\n              if (saslRpcClient \u003d\u003d null) {\n                // whatever happened -it can\u0027t be handled, so rethrow\n                throw ex;\n              }\n              // otherwise, assume a connection problem\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                  rand, ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n              LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(false);\n              }\n            } else if (UserGroupInformation.isSecurityEnabled()) {\n              if (!fallbackAllowed) {\n                throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                    \"auth, but this client is configured to only allow secure \" +\n                    \"connections.\");\n              }\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(true);\n              }\n            }\n          }\n        \n          if (doPing) {\n            inStream \u003d new PingInputStream(inStream);\n          }\n          this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n\n          // SASL may have already buffered the stream\n          if (!(outStream instanceof BufferedOutputStream)) {\n            outStream \u003d new BufferedOutputStream(outStream);\n          }\n          this.out \u003d new DataOutputStream(outStream);\n          \n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          span \u003d Tracer.getCurrentSpan();\n          if (span !\u003d null) {\n            span.addTimelineAnnotation(\"IPC client connected to \" + server);\n          }\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams: \" + t, t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "892ade689f9bcce76daae8f66fc00a49bee8548e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9080. Update htrace version to 4.0.1 (cmccabe)\n",
      "commitDate": "28/09/15 7:42 AM",
      "commitName": "892ade689f9bcce76daae8f66fc00a49bee8548e",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "03/09/15 7:32 AM",
      "commitNameOld": "0ebc658105336cfe3e1a248b411de60f1d380928",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 25.01,
      "commitsBetweenForRepo": 162,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,103 @@\n     private synchronized void setupIOstreams(\n         AtomicBoolean fallbackToSimpleAuth) {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n-        if (Trace.isTracing()) {\n-          Trace.addTimelineAnnotation(\"IPC client connecting to \" + server);\n+        Span span \u003d Tracer.getCurrentSpan();\n+        if (span !\u003d null) {\n+          span.addTimelineAnnotation(\"IPC client connecting to \" + server);\n         }\n         short numRetries \u003d 0;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                   rand, ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n               LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n               if (fallbackToSimpleAuth !\u003d null) {\n                 fallbackToSimpleAuth.set(false);\n               }\n             } else if (UserGroupInformation.isSecurityEnabled()) {\n               if (!fallbackAllowed) {\n                 throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                     \"auth, but this client is configured to only allow secure \" +\n                     \"connections.\");\n               }\n               if (fallbackToSimpleAuth !\u003d null) {\n                 fallbackToSimpleAuth.set(true);\n               }\n             }\n           }\n         \n           if (doPing) {\n             inStream \u003d new PingInputStream(inStream);\n           }\n           this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n \n           // SASL may have already buffered the stream\n           if (!(outStream instanceof BufferedOutputStream)) {\n             outStream \u003d new BufferedOutputStream(outStream);\n           }\n           this.out \u003d new DataOutputStream(outStream);\n           \n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n-          if (Trace.isTracing()) {\n-            Trace.addTimelineAnnotation(\"IPC client connected to \" + server);\n+          span \u003d Tracer.getCurrentSpan();\n+          if (span !\u003d null) {\n+            span.addTimelineAnnotation(\"IPC client connected to \" + server);\n           }\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams(\n        AtomicBoolean fallbackToSimpleAuth) {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        Span span \u003d Tracer.getCurrentSpan();\n        if (span !\u003d null) {\n          span.addTimelineAnnotation(\"IPC client connecting to \" + server);\n        }\n        short numRetries \u003d 0;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                  rand, ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n              LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(false);\n              }\n            } else if (UserGroupInformation.isSecurityEnabled()) {\n              if (!fallbackAllowed) {\n                throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                    \"auth, but this client is configured to only allow secure \" +\n                    \"connections.\");\n              }\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(true);\n              }\n            }\n          }\n        \n          if (doPing) {\n            inStream \u003d new PingInputStream(inStream);\n          }\n          this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n\n          // SASL may have already buffered the stream\n          if (!(outStream instanceof BufferedOutputStream)) {\n            outStream \u003d new BufferedOutputStream(outStream);\n          }\n          this.out \u003d new DataOutputStream(outStream);\n          \n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          span \u003d Tracer.getCurrentSpan();\n          if (span !\u003d null) {\n            span.addTimelineAnnotation(\"IPC client connected to \" + server);\n          }\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7073. Allow falling back to a non-SASL connection on DataTransferProtocol in several edge cases. Contributed by Chris Nauroth.\n",
      "commitDate": "19/09/14 9:23 PM",
      "commitName": "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5",
      "commitAuthor": "cnauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7073. Allow falling back to a non-SASL connection on DataTransferProtocol in several edge cases. Contributed by Chris Nauroth.\n",
          "commitDate": "19/09/14 9:23 PM",
          "commitName": "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5",
          "commitAuthor": "cnauroth",
          "commitDateOld": "27/08/14 2:12 PM",
          "commitNameOld": "6962510f729717f776929708813f99a28e582f34",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 23.3,
          "commitsBetweenForRepo": 247,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,101 @@\n-    private synchronized void setupIOstreams() {\n+    private synchronized void setupIOstreams(\n+        AtomicBoolean fallbackToSimpleAuth) {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         if (Trace.isTracing()) {\n           Trace.addTimelineAnnotation(\"IPC client connecting to \" + server);\n         }\n         short numRetries \u003d 0;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                   rand, ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n               LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n-            } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n-                       !fallbackAllowed) {\n-              throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n-                  \"auth, but this client is configured to only allow secure \" +\n-                  \"connections.\");\n+              if (fallbackToSimpleAuth !\u003d null) {\n+                fallbackToSimpleAuth.set(false);\n+              }\n+            } else if (UserGroupInformation.isSecurityEnabled()) {\n+              if (!fallbackAllowed) {\n+                throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n+                    \"auth, but this client is configured to only allow secure \" +\n+                    \"connections.\");\n+              }\n+              if (fallbackToSimpleAuth !\u003d null) {\n+                fallbackToSimpleAuth.set(true);\n+              }\n             }\n           }\n         \n           if (doPing) {\n             inStream \u003d new PingInputStream(inStream);\n           }\n           this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n \n           // SASL may have already buffered the stream\n           if (!(outStream instanceof BufferedOutputStream)) {\n             outStream \u003d new BufferedOutputStream(outStream);\n           }\n           this.out \u003d new DataOutputStream(outStream);\n           \n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           if (Trace.isTracing()) {\n             Trace.addTimelineAnnotation(\"IPC client connected to \" + server);\n           }\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private synchronized void setupIOstreams(\n        AtomicBoolean fallbackToSimpleAuth) {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        if (Trace.isTracing()) {\n          Trace.addTimelineAnnotation(\"IPC client connecting to \" + server);\n        }\n        short numRetries \u003d 0;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                  rand, ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n              LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(false);\n              }\n            } else if (UserGroupInformation.isSecurityEnabled()) {\n              if (!fallbackAllowed) {\n                throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                    \"auth, but this client is configured to only allow secure \" +\n                    \"connections.\");\n              }\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(true);\n              }\n            }\n          }\n        \n          if (doPing) {\n            inStream \u003d new PingInputStream(inStream);\n          }\n          this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n\n          // SASL may have already buffered the stream\n          if (!(outStream instanceof BufferedOutputStream)) {\n            outStream \u003d new BufferedOutputStream(outStream);\n          }\n          this.out \u003d new DataOutputStream(outStream);\n          \n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          if (Trace.isTracing()) {\n            Trace.addTimelineAnnotation(\"IPC client connected to \" + server);\n          }\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[fallbackToSimpleAuth-AtomicBoolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7073. Allow falling back to a non-SASL connection on DataTransferProtocol in several edge cases. Contributed by Chris Nauroth.\n",
          "commitDate": "19/09/14 9:23 PM",
          "commitName": "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5",
          "commitAuthor": "cnauroth",
          "commitDateOld": "27/08/14 2:12 PM",
          "commitNameOld": "6962510f729717f776929708813f99a28e582f34",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 23.3,
          "commitsBetweenForRepo": 247,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,101 @@\n-    private synchronized void setupIOstreams() {\n+    private synchronized void setupIOstreams(\n+        AtomicBoolean fallbackToSimpleAuth) {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         if (Trace.isTracing()) {\n           Trace.addTimelineAnnotation(\"IPC client connecting to \" + server);\n         }\n         short numRetries \u003d 0;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                   rand, ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n               LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n-            } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n-                       !fallbackAllowed) {\n-              throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n-                  \"auth, but this client is configured to only allow secure \" +\n-                  \"connections.\");\n+              if (fallbackToSimpleAuth !\u003d null) {\n+                fallbackToSimpleAuth.set(false);\n+              }\n+            } else if (UserGroupInformation.isSecurityEnabled()) {\n+              if (!fallbackAllowed) {\n+                throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n+                    \"auth, but this client is configured to only allow secure \" +\n+                    \"connections.\");\n+              }\n+              if (fallbackToSimpleAuth !\u003d null) {\n+                fallbackToSimpleAuth.set(true);\n+              }\n             }\n           }\n         \n           if (doPing) {\n             inStream \u003d new PingInputStream(inStream);\n           }\n           this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n \n           // SASL may have already buffered the stream\n           if (!(outStream instanceof BufferedOutputStream)) {\n             outStream \u003d new BufferedOutputStream(outStream);\n           }\n           this.out \u003d new DataOutputStream(outStream);\n           \n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           if (Trace.isTracing()) {\n             Trace.addTimelineAnnotation(\"IPC client connected to \" + server);\n           }\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private synchronized void setupIOstreams(\n        AtomicBoolean fallbackToSimpleAuth) {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        if (Trace.isTracing()) {\n          Trace.addTimelineAnnotation(\"IPC client connecting to \" + server);\n        }\n        short numRetries \u003d 0;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                  rand, ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n              LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(false);\n              }\n            } else if (UserGroupInformation.isSecurityEnabled()) {\n              if (!fallbackAllowed) {\n                throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                    \"auth, but this client is configured to only allow secure \" +\n                    \"connections.\");\n              }\n              if (fallbackToSimpleAuth !\u003d null) {\n                fallbackToSimpleAuth.set(true);\n              }\n            }\n          }\n        \n          if (doPing) {\n            inStream \u003d new PingInputStream(inStream);\n          }\n          this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n\n          // SASL may have already buffered the stream\n          if (!(outStream instanceof BufferedOutputStream)) {\n            outStream \u003d new BufferedOutputStream(outStream);\n          }\n          this.out \u003d new DataOutputStream(outStream);\n          \n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          if (Trace.isTracing()) {\n            Trace.addTimelineAnnotation(\"IPC client connected to \" + server);\n          }\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
          "extendedDetails": {}
        }
      ]
    },
    "6962510f729717f776929708813f99a28e582f34": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6879. Adding tracing to Hadoop RPC.  Contributed by Masatake Iwasaki.\n",
      "commitDate": "27/08/14 2:12 PM",
      "commitName": "6962510f729717f776929708813f99a28e582f34",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "24/06/14 4:11 PM",
      "commitNameOld": "2eb913b6ece143f23fec67926550e97dcd931fba",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 63.92,
      "commitsBetweenForRepo": 502,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,93 @@\n     private synchronized void setupIOstreams() {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n+        if (Trace.isTracing()) {\n+          Trace.addTimelineAnnotation(\"IPC client connecting to \" + server);\n+        }\n         short numRetries \u003d 0;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                   rand, ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n               LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n             } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                        !fallbackAllowed) {\n               throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                   \"auth, but this client is configured to only allow secure \" +\n                   \"connections.\");\n             }\n           }\n         \n           if (doPing) {\n             inStream \u003d new PingInputStream(inStream);\n           }\n           this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n \n           // SASL may have already buffered the stream\n           if (!(outStream instanceof BufferedOutputStream)) {\n             outStream \u003d new BufferedOutputStream(outStream);\n           }\n           this.out \u003d new DataOutputStream(outStream);\n           \n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n+          if (Trace.isTracing()) {\n+            Trace.addTimelineAnnotation(\"IPC client connected to \" + server);\n+          }\n+\n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        if (Trace.isTracing()) {\n          Trace.addTimelineAnnotation(\"IPC client connecting to \" + server);\n        }\n        short numRetries \u003d 0;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                  rand, ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n              LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n            } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                       !fallbackAllowed) {\n              throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                  \"auth, but this client is configured to only allow secure \" +\n                  \"connections.\");\n            }\n          }\n        \n          if (doPing) {\n            inStream \u003d new PingInputStream(inStream);\n          }\n          this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n\n          // SASL may have already buffered the stream\n          if (!(outStream instanceof BufferedOutputStream)) {\n            outStream \u003d new BufferedOutputStream(outStream);\n          }\n          this.out \u003d new DataOutputStream(outStream);\n          \n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          if (Trace.isTracing()) {\n            Trace.addTimelineAnnotation(\"IPC client connected to \" + server);\n          }\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "2eb913b6ece143f23fec67926550e97dcd931fba": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10747. Support configurable retries on SASL connection failures in RPC client. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605219 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/06/14 4:11 PM",
      "commitName": "2eb913b6ece143f23fec67926550e97dcd931fba",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "19/03/14 1:16 PM",
      "commitNameOld": "f799618828b0ba09b694b07eaab0689d31f4954d",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 97.12,
      "commitsBetweenForRepo": 604,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,86 @@\n     private synchronized void setupIOstreams() {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n-        final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n-              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n-                  ticket);\n+              handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n+                  rand, ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n               LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n             } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                        !fallbackAllowed) {\n               throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                   \"auth, but this client is configured to only allow secure \" +\n                   \"connections.\");\n             }\n           }\n         \n           if (doPing) {\n             inStream \u003d new PingInputStream(inStream);\n           }\n           this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n \n           // SASL may have already buffered the stream\n           if (!(outStream instanceof BufferedOutputStream)) {\n             outStream \u003d new BufferedOutputStream(outStream);\n           }\n           this.out \u003d new DataOutputStream(outStream);\n           \n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,\n                  rand, ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n              LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n            } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                       !fallbackAllowed) {\n              throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                  \"auth, but this client is configured to only allow secure \" +\n                  \"connections.\");\n            }\n          }\n        \n          if (doPing) {\n            inStream \u003d new PingInputStream(inStream);\n          }\n          this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n\n          // SASL may have already buffered the stream\n          if (!(outStream instanceof BufferedOutputStream)) {\n            outStream \u003d new BufferedOutputStream(outStream);\n          }\n          this.out \u003d new DataOutputStream(outStream);\n          \n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "f799618828b0ba09b694b07eaab0689d31f4954d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10221. Add a plugin to specify SaslProperties for RPC protocol based on connection properties. (Contributed by Benoy Antony and Daryn Sharp)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1579382 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/03/14 1:16 PM",
      "commitName": "f799618828b0ba09b694b07eaab0689d31f4954d",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "14/03/14 2:12 PM",
      "commitNameOld": "37cb314f79f515421cfc2c3605382bf1534dc266",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.96,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,87 @@\n     private synchronized void setupIOstreams() {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n         final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                   ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n+              LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n             } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                        !fallbackAllowed) {\n               throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                   \"auth, but this client is configured to only allow secure \" +\n                   \"connections.\");\n             }\n           }\n         \n           if (doPing) {\n             inStream \u003d new PingInputStream(inStream);\n           }\n           this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n \n           // SASL may have already buffered the stream\n           if (!(outStream instanceof BufferedOutputStream)) {\n             outStream \u003d new BufferedOutputStream(outStream);\n           }\n           this.out \u003d new DataOutputStream(outStream);\n           \n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n              LOG.debug(\"Negotiated QOP is :\" + remoteId.saslQop);\n            } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                       !fallbackAllowed) {\n              throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                  \"auth, but this client is configured to only allow secure \" +\n                  \"connections.\");\n            }\n          }\n        \n          if (doPing) {\n            inStream \u003d new PingInputStream(inStream);\n          }\n          this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n\n          // SASL may have already buffered the stream\n          if (!(outStream instanceof BufferedOutputStream)) {\n            outStream \u003d new BufferedOutputStream(outStream);\n          }\n          this.out \u003d new DataOutputStream(outStream);\n          \n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "c03c8fe199429a43c6aa944016566738abd9b193": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9820. RPCv9 wire protocol is insufficient to support multiplexing. Contributed by Daryn Sharp.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1512091 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/13 4:02 PM",
      "commitName": "c03c8fe199429a43c6aa944016566738abd9b193",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "08/08/13 8:03 AM",
      "commitNameOld": "c6ba793b65014306ec1ff40c61938399412e72c1",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,86 @@\n     private synchronized void setupIOstreams() {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n         final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                   ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n             } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                        !fallbackAllowed) {\n               throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                   \"auth, but this client is configured to only allow secure \" +\n                   \"connections.\");\n             }\n           }\n         \n           if (doPing) {\n-            this.in \u003d new DataInputStream(new BufferedInputStream(\n-                new PingInputStream(inStream)));\n-          } else {\n-            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n+            inStream \u003d new PingInputStream(inStream);\n           }\n-          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n+          this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n+\n+          // SASL may have already buffered the stream\n+          if (!(outStream instanceof BufferedOutputStream)) {\n+            outStream \u003d new BufferedOutputStream(outStream);\n+          }\n+          this.out \u003d new DataOutputStream(outStream);\n+          \n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n            } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                       !fallbackAllowed) {\n              throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                  \"auth, but this client is configured to only allow secure \" +\n                  \"connections.\");\n            }\n          }\n        \n          if (doPing) {\n            inStream \u003d new PingInputStream(inStream);\n          }\n          this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n\n          // SASL may have already buffered the stream\n          if (!(outStream instanceof BufferedOutputStream)) {\n            outStream \u003d new BufferedOutputStream(outStream);\n          }\n          this.out \u003d new DataOutputStream(outStream);\n          \n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "c6ba793b65014306ec1ff40c61938399412e72c1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9850. RPC kerberos errors don\u0027t trigger relogin. Contributed by Daryn Sharp.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1511823 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/13 8:03 AM",
      "commitName": "c6ba793b65014306ec1ff40c61938399412e72c1",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "05/08/13 4:01 PM",
      "commitNameOld": "63a1273f2a8e0b668ff70330262adedee63112d9",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 2.67,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,82 @@\n     private synchronized void setupIOstreams() {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n         final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n+              authMethod \u003d saslRpcClient.getAuthMethod();\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                   ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n               // for testing\n               remoteId.saslQop \u003d\n                   (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n             } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                        !fallbackAllowed) {\n               throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                   \"auth, but this client is configured to only allow secure \" +\n                   \"connections.\");\n             }\n           }\n         \n           if (doPing) {\n             this.in \u003d new DataInputStream(new BufferedInputStream(\n                 new PingInputStream(inStream)));\n           } else {\n             this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n           }\n           this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              authMethod \u003d saslRpcClient.getAuthMethod();\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n            } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                       !fallbackAllowed) {\n              throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                  \"auth, but this client is configured to only allow secure \" +\n                  \"connections.\");\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "f5312aedb9fa3dc895d61844b5c3202b02554f80": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9816. RPC Sasl QOP is broken (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1510772 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/08/13 3:02 PM",
      "commitName": "f5312aedb9fa3dc895d61844b5c3202b02554f80",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "30/07/13 12:51 AM",
      "commitNameOld": "8c7a7e619699386f9e6991842558d78aa0c8053d",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 6.59,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,81 @@\n     private synchronized void setupIOstreams() {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n         final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             try {\n               authMethod \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n                     public AuthMethod run()\n                         throws IOException, InterruptedException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                   ticket);\n               continue;\n             }\n             if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n+              // for testing\n+              remoteId.saslQop \u003d\n+                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n             } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                        !fallbackAllowed) {\n               throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                   \"auth, but this client is configured to only allow secure \" +\n                   \"connections.\");\n             }\n           }\n         \n           if (doPing) {\n             this.in \u003d new DataInputStream(new BufferedInputStream(\n                 new PingInputStream(inStream)));\n           } else {\n             this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n           }\n           this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n              // for testing\n              remoteId.saslQop \u003d\n                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);\n            } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                       !fallbackAllowed) {\n              throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                  \"auth, but this client is configured to only allow secure \" +\n                  \"connections.\");\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "65be21267587f04a2c33af65b951211cc9085b15": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9698. [RPC v9] Client must honor server\u0027s SASL negotiate response (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508086 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 7:44 AM",
      "commitName": "65be21267587f04a2c33af65b951211cc9085b15",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "22/07/13 12:22 AM",
      "commitNameOld": "3eb61be352589491117ac2781bb18f55988a8084",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 7.31,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,78 @@\n     private synchronized void setupIOstreams() {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n         final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n-          if (authMethod !\u003d AuthMethod.SIMPLE) {\n+          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n-            boolean continueSasl \u003d false;\n             try {\n-              continueSasl \u003d ticket\n-                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n+              authMethod \u003d ticket\n+                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                     @Override\n-                    public Boolean run() throws IOException {\n+                    public AuthMethod run()\n+                        throws IOException, InterruptedException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                   ticket);\n               continue;\n             }\n-            if (continueSasl) {\n+            if (authMethod !\u003d AuthMethod.SIMPLE) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n-            } else {\n-              // fall back to simple auth because server told us so.\n-              authMethod \u003d AuthMethod.SIMPLE;\n+            } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n+                       !fallbackAllowed) {\n+              throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n+                  \"auth, but this client is configured to only allow secure \" +\n+                  \"connections.\");\n             }\n           }\n         \n           if (doPing) {\n             this.in \u003d new DataInputStream(new BufferedInputStream(\n                 new PingInputStream(inStream)));\n           } else {\n             this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n           }\n           this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authProtocol \u003d\u003d AuthProtocol.SASL) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            try {\n              authMethod \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cAuthMethod\u003e() {\n                    @Override\n                    public AuthMethod run()\n                        throws IOException, InterruptedException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (authMethod !\u003d AuthMethod.SIMPLE) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n            } else if (UserGroupInformation.isSecurityEnabled() \u0026\u0026\n                       !fallbackAllowed) {\n              throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                  \"auth, but this client is configured to only allow secure \" +\n                  \"connections.\");\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "3eb61be352589491117ac2781bb18f55988a8084": {
      "type": "Yexceptionschange",
      "commitMessage": "HADOOP-9754. Remove unnecessary \"throws IOException/InterruptedException\", and fix generic and other javac warnings.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505610 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/13 12:22 AM",
      "commitName": "3eb61be352589491117ac2781bb18f55988a8084",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "19/07/13 2:49 PM",
      "commitNameOld": "9ff01d626118a97ea4bf2fd72f022e11e69ee17d",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 2.4,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n-    private synchronized void setupIOstreams() throws InterruptedException {\n+    private synchronized void setupIOstreams() {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n         final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             boolean continueSasl \u003d false;\n             try {\n               continueSasl \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                     @Override\n                     public Boolean run() throws IOException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                   ticket);\n               continue;\n             }\n             if (continueSasl) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n             } else {\n               // fall back to simple auth because server told us so.\n               authMethod \u003d AuthMethod.SIMPLE;\n             }\n           }\n         \n           if (doPing) {\n             this.in \u003d new DataInputStream(new BufferedInputStream(\n                 new PingInputStream(inStream)));\n           } else {\n             this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n           }\n           this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n           writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            boolean continueSasl \u003d false;\n            try {\n              continueSasl \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                    @Override\n                    public Boolean run() throws IOException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod \u003d AuthMethod.SIMPLE;\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {
        "oldValue": "[InterruptedException]",
        "newValue": "[]"
      }
    },
    "5605b54010b67785085192629d9a191e0c79bd90": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9012. IPC Client sends wrong connection context (daryn via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1406184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/11/12 7:37 AM",
      "commitName": "5605b54010b67785085192629d9a191e0c79bd90",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "05/11/12 10:37 AM",
      "commitNameOld": "b1aa62a848646f78e019c74186d9696e9101afcf",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,76 @@\n     private synchronized void setupIOstreams() throws InterruptedException {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n         final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (authMethod !\u003d AuthMethod.SIMPLE) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n             boolean continueSasl \u003d false;\n             try {\n               continueSasl \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                     @Override\n                     public Boolean run() throws IOException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                   ticket);\n               continue;\n             }\n             if (continueSasl) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n             } else {\n               // fall back to simple auth because server told us so.\n               authMethod \u003d AuthMethod.SIMPLE;\n-              // remake the connectionContext             \n-              connectionContext \u003d ProtoUtil.makeIpcConnectionContext(\n-                  connectionContext.getProtocol(), \n-                  ProtoUtil.getUgi(connectionContext.getUserInfo()),\n-                  authMethod);\n             }\n           }\n         \n           if (doPing) {\n             this.in \u003d new DataInputStream(new BufferedInputStream(\n                 new PingInputStream(inStream)));\n           } else {\n             this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n           }\n           this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n-          writeConnectionContext();\n+          writeConnectionContext(remoteId, authMethod);\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            boolean continueSasl \u003d false;\n            try {\n              continueSasl \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                    @Override\n                    public Boolean run() throws IOException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod \u003d AuthMethod.SIMPLE;\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeConnectionContext(remoteId, authMethod);\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "22ef03bc7677d6718902a7587bbd26ab750f8d78": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8784. Improve IPC.Client\u0027s token use (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1397634 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/10/12 9:27 AM",
      "commitName": "22ef03bc7677d6718902a7587bbd26ab750f8d78",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "24/09/12 4:16 PM",
      "commitNameOld": "5308a0ecd5d2d31ac92122ed517e24449137184c",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 17.72,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,81 @@\n     private synchronized void setupIOstreams() throws InterruptedException {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n         final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n-          if (useSasl) {\n+          if (authMethod !\u003d AuthMethod.SIMPLE) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n-            if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n-              if (ticket.getRealUser() !\u003d null) {\n-                ticket \u003d ticket.getRealUser();\n-              }\n+            if (ticket.getRealUser() !\u003d null) {\n+              ticket \u003d ticket.getRealUser();\n             }\n             boolean continueSasl \u003d false;\n             try {\n               continueSasl \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                     @Override\n                     public Boolean run() throws IOException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                   ticket);\n               continue;\n             }\n             if (continueSasl) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n             } else {\n               // fall back to simple auth because server told us so.\n               authMethod \u003d AuthMethod.SIMPLE;\n               // remake the connectionContext             \n               connectionContext \u003d ProtoUtil.makeIpcConnectionContext(\n                   connectionContext.getProtocol(), \n                   ProtoUtil.getUgi(connectionContext.getUserInfo()),\n                   authMethod);\n-              useSasl \u003d false;\n             }\n           }\n         \n           if (doPing) {\n             this.in \u003d new DataInputStream(new BufferedInputStream(\n                 new PingInputStream(inStream)));\n           } else {\n             this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n           }\n           this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n           writeConnectionContext();\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (authMethod !\u003d AuthMethod.SIMPLE) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n            boolean continueSasl \u003d false;\n            try {\n              continueSasl \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                    @Override\n                    public Boolean run() throws IOException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod \u003d AuthMethod.SIMPLE;\n              // remake the connectionContext             \n              connectionContext \u003d ProtoUtil.makeIpcConnectionContext(\n                  connectionContext.getProtocol(), \n                  ProtoUtil.getUgi(connectionContext.getUserInfo()),\n                  authMethod);\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeConnectionContext();\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "589c68ae09effd6c4f26505d61636f779c22e99f": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-8285 Use ProtoBuf for RpcPayLoadHeader (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1329319 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/12 9:34 AM",
      "commitName": "589c68ae09effd6c4f26505d61636f779c22e99f",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "12/04/12 1:43 PM",
      "commitNameOld": "047a7b276c497a4ebb896c93a24e2f0edf258a7b",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 10.83,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n     private synchronized void setupIOstreams() throws InterruptedException {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n         final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeConnectionHeader(outStream);\n           if (useSasl) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n               if (ticket.getRealUser() !\u003d null) {\n                 ticket \u003d ticket.getRealUser();\n               }\n             }\n             boolean continueSasl \u003d false;\n             try {\n               continueSasl \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                     @Override\n                     public Boolean run() throws IOException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                   ticket);\n               continue;\n             }\n             if (continueSasl) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n             } else {\n               // fall back to simple auth because server told us so.\n               authMethod \u003d AuthMethod.SIMPLE;\n               // remake the connectionContext             \n               connectionContext \u003d ProtoUtil.makeIpcConnectionContext(\n                   connectionContext.getProtocol(), \n                   ProtoUtil.getUgi(connectionContext.getUserInfo()),\n                   authMethod);\n               useSasl \u003d false;\n             }\n           }\n         \n           if (doPing) {\n             this.in \u003d new DataInputStream(new BufferedInputStream(\n                 new PingInputStream(inStream)));\n           } else {\n             this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n           }\n           this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n-          writeHeader();\n+          writeConnectionContext();\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (useSasl) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n              if (ticket.getRealUser() !\u003d null) {\n                ticket \u003d ticket.getRealUser();\n              }\n            }\n            boolean continueSasl \u003d false;\n            try {\n              continueSasl \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                    @Override\n                    public Boolean run() throws IOException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod \u003d AuthMethod.SIMPLE;\n              // remake the connectionContext             \n              connectionContext \u003d ProtoUtil.makeIpcConnectionContext(\n                  connectionContext.getProtocol(), \n                  ProtoUtil.getUgi(connectionContext.getUserInfo()),\n                  authMethod);\n              useSasl \u003d false;\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeConnectionContext();\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-7557 Make IPC header be extensible (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1295261 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/02/12 12:43 PM",
      "commitName": "7ae04652a6adf0f9d04b8702a7fe3b9790afa8b9",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "14/02/12 11:47 AM",
      "commitNameOld": "f42e58c381a1a8d4feb9384de3b8d8c857830d33",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 15.04,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,84 @@\n     private synchronized void setupIOstreams() throws InterruptedException {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n         final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n-          writeRpcHeader(outStream);\n+          writeConnectionHeader(outStream);\n           if (useSasl) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n               if (ticket.getRealUser() !\u003d null) {\n                 ticket \u003d ticket.getRealUser();\n               }\n             }\n             boolean continueSasl \u003d false;\n             try {\n               continueSasl \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                     @Override\n                     public Boolean run() throws IOException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                   ticket);\n               continue;\n             }\n             if (continueSasl) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n             } else {\n               // fall back to simple auth because server told us so.\n               authMethod \u003d AuthMethod.SIMPLE;\n-              header \u003d new ConnectionHeader(header.getProtocol(), header\n-                  .getUgi(), authMethod);\n+              // remake the connectionContext             \n+              connectionContext \u003d ProtoUtil.makeIpcConnectionContext(\n+                  connectionContext.getProtocol(), \n+                  ProtoUtil.getUgi(connectionContext.getUserInfo()),\n+                  authMethod);\n               useSasl \u003d false;\n             }\n           }\n         \n           if (doPing) {\n             this.in \u003d new DataInputStream(new BufferedInputStream(\n                 new PingInputStream(inStream)));\n           } else {\n             this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n           }\n           this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n           writeHeader();\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n       } catch (Throwable t) {\n         if (t instanceof IOException) {\n           markClosed((IOException)t);\n         } else {\n           markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n         }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeConnectionHeader(outStream);\n          if (useSasl) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n              if (ticket.getRealUser() !\u003d null) {\n                ticket \u003d ticket.getRealUser();\n              }\n            }\n            boolean continueSasl \u003d false;\n            try {\n              continueSasl \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                    @Override\n                    public Boolean run() throws IOException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod \u003d AuthMethod.SIMPLE;\n              // remake the connectionContext             \n              connectionContext \u003d ProtoUtil.makeIpcConnectionContext(\n                  connectionContext.getProtocol(), \n                  ProtoUtil.getUgi(connectionContext.getUserInfo()),\n                  authMethod);\n              useSasl \u003d false;\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeHeader();\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeRpcHeader(outStream);\n          if (useSasl) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n              if (ticket.getRealUser() !\u003d null) {\n                ticket \u003d ticket.getRealUser();\n              }\n            }\n            boolean continueSasl \u003d false;\n            try {\n              continueSasl \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                    @Override\n                    public Boolean run() throws IOException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod \u003d AuthMethod.SIMPLE;\n              header \u003d new ConnectionHeader(header.getProtocol(), header\n                  .getUgi(), authMethod);\n              useSasl \u003d false;\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeHeader();\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeRpcHeader(outStream);\n          if (useSasl) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n              if (ticket.getRealUser() !\u003d null) {\n                ticket \u003d ticket.getRealUser();\n              }\n            }\n            boolean continueSasl \u003d false;\n            try {\n              continueSasl \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                    @Override\n                    public Boolean run() throws IOException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod \u003d AuthMethod.SIMPLE;\n              header \u003d new ConnectionHeader(header.getProtocol(), header\n                  .getUgi(), authMethod);\n              useSasl \u003d false;\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeHeader();\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/ipc/Client.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java"
      }
    },
    "f853b52a3b2dc97f750db0a3f6eeaf058fc8884a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7428. IPC connection is orphaned with null \u0027out\u0027 member. Contributed by Todd Lipcon\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1141638 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/06/11 10:54 AM",
      "commitName": "f853b52a3b2dc97f750db0a3f6eeaf058fc8884a",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "15/06/11 4:38 PM",
      "commitNameOld": "f5c604f49c5559c402e682e5f15a6e9053ff68cf",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 14.76,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,81 @@\n     private synchronized void setupIOstreams() throws InterruptedException {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         short numRetries \u003d 0;\n         final short MAX_RETRIES \u003d 5;\n         Random rand \u003d null;\n         while (true) {\n           setupConnection();\n           InputStream inStream \u003d NetUtils.getInputStream(socket);\n           OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n           writeRpcHeader(outStream);\n           if (useSasl) {\n             final InputStream in2 \u003d inStream;\n             final OutputStream out2 \u003d outStream;\n             UserGroupInformation ticket \u003d remoteId.getTicket();\n             if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n               if (ticket.getRealUser() !\u003d null) {\n                 ticket \u003d ticket.getRealUser();\n               }\n             }\n             boolean continueSasl \u003d false;\n             try {\n               continueSasl \u003d ticket\n                   .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                     @Override\n                     public Boolean run() throws IOException {\n                       return setupSaslConnection(in2, out2);\n                     }\n                   });\n             } catch (Exception ex) {\n               if (rand \u003d\u003d null) {\n                 rand \u003d new Random();\n               }\n               handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                   ticket);\n               continue;\n             }\n             if (continueSasl) {\n               // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n               inStream \u003d saslRpcClient.getInputStream(inStream);\n               outStream \u003d saslRpcClient.getOutputStream(outStream);\n             } else {\n               // fall back to simple auth because server told us so.\n               authMethod \u003d AuthMethod.SIMPLE;\n               header \u003d new ConnectionHeader(header.getProtocol(), header\n                   .getUgi(), authMethod);\n               useSasl \u003d false;\n             }\n           }\n         \n           if (doPing) {\n             this.in \u003d new DataInputStream(new BufferedInputStream(\n                 new PingInputStream(inStream)));\n           } else {\n             this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n           }\n           this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n           writeHeader();\n \n           // update last activity time\n           touch();\n \n           // start the receiver thread after the socket connection has been set\n           // up\n           start();\n           return;\n         }\n-      } catch (IOException e) {\n-        markClosed(e);\n+      } catch (Throwable t) {\n+        if (t instanceof IOException) {\n+          markClosed((IOException)t);\n+        } else {\n+          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n+        }\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeRpcHeader(outStream);\n          if (useSasl) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n              if (ticket.getRealUser() !\u003d null) {\n                ticket \u003d ticket.getRealUser();\n              }\n            }\n            boolean continueSasl \u003d false;\n            try {\n              continueSasl \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                    @Override\n                    public Boolean run() throws IOException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod \u003d AuthMethod.SIMPLE;\n              header \u003d new ConnectionHeader(header.getProtocol(), header\n                  .getUgi(), authMethod);\n              useSasl \u003d false;\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeHeader();\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        if (t instanceof IOException) {\n          markClosed((IOException)t);\n        } else {\n          markClosed(new IOException(\"Couldn\u0027t set up IO streams\", t));\n        }\n        close();\n      }\n    }",
      "path": "common/src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeRpcHeader(outStream);\n          if (useSasl) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n              if (ticket.getRealUser() !\u003d null) {\n                ticket \u003d ticket.getRealUser();\n              }\n            }\n            boolean continueSasl \u003d false;\n            try {\n              continueSasl \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                    @Override\n                    public Boolean run() throws IOException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod \u003d AuthMethod.SIMPLE;\n              header \u003d new ConnectionHeader(header.getProtocol(), header\n                  .getUgi(), authMethod);\n              useSasl \u003d false;\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeHeader();\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (IOException e) {\n        markClosed(e);\n        close();\n      }\n    }",
      "path": "common/src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/ipc/Client.java",
        "newPath": "common/src/java/org/apache/hadoop/ipc/Client.java"
      }
    },
    "c47d34a8660923f6f6e21e91aa48ca5780c0ff9f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6706. Improves the sasl failure handling due to expired tickets, and other server detected failures. Contributed by Jitendra Pandey and Devaraj Das.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@981714 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/10 5:51 PM",
      "commitName": "c47d34a8660923f6f6e21e91aa48ca5780c0ff9f",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "29/07/10 10:29 AM",
      "commitNameOld": "1a6ed79ebf6649d4f0828b8c2adff26d0f79832f",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 4.31,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,77 @@\n     private synchronized void setupIOstreams() throws InterruptedException {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n-      }\n-      \n-      short ioFailures \u003d 0;\n-      short timeoutFailures \u003d 0;\n+      } \n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n+        short numRetries \u003d 0;\n+        final short MAX_RETRIES \u003d 5;\n+        Random rand \u003d null;\n         while (true) {\n-          try {\n-            this.socket \u003d socketFactory.createSocket();\n-            this.socket.setTcpNoDelay(tcpNoDelay);\n-            // connection time out is 20s\n-            NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n-            this.socket.setSoTimeout(pingInterval);\n-            break;\n-          } catch (SocketTimeoutException toe) {\n-            /* The max number of retries is 45,\n-             * which amounts to 20s*45 \u003d 15 minutes retries.\n-             */\n-            handleConnectionFailure(timeoutFailures++, 45, toe);\n-          } catch (IOException ie) {\n-            handleConnectionFailure(ioFailures++, maxRetries, ie);\n-          }\n-        }\n-        InputStream inStream \u003d NetUtils.getInputStream(socket);\n-        OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n-        writeRpcHeader(outStream);\n-        if (useSasl) {\n-          final InputStream in2 \u003d inStream;\n-          final OutputStream out2 \u003d outStream;\n-          UserGroupInformation ticket \u003d remoteId.getTicket();\n-          if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n-            if (ticket.getRealUser() !\u003d null) {\n-              ticket \u003d ticket.getRealUser();\n+          setupConnection();\n+          InputStream inStream \u003d NetUtils.getInputStream(socket);\n+          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n+          writeRpcHeader(outStream);\n+          if (useSasl) {\n+            final InputStream in2 \u003d inStream;\n+            final OutputStream out2 \u003d outStream;\n+            UserGroupInformation ticket \u003d remoteId.getTicket();\n+            if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n+              if (ticket.getRealUser() !\u003d null) {\n+                ticket \u003d ticket.getRealUser();\n+              }\n+            }\n+            boolean continueSasl \u003d false;\n+            try {\n+              continueSasl \u003d ticket\n+                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n+                    @Override\n+                    public Boolean run() throws IOException {\n+                      return setupSaslConnection(in2, out2);\n+                    }\n+                  });\n+            } catch (Exception ex) {\n+              if (rand \u003d\u003d null) {\n+                rand \u003d new Random();\n+              }\n+              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n+                  ticket);\n+              continue;\n+            }\n+            if (continueSasl) {\n+              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n+              inStream \u003d saslRpcClient.getInputStream(inStream);\n+              outStream \u003d saslRpcClient.getOutputStream(outStream);\n+            } else {\n+              // fall back to simple auth because server told us so.\n+              authMethod \u003d AuthMethod.SIMPLE;\n+              header \u003d new ConnectionHeader(header.getProtocol(), header\n+                  .getUgi(), authMethod);\n+              useSasl \u003d false;\n             }\n           }\n-          if (ticket.doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n-            @Override\n-            public Boolean run() throws IOException {\n-              return setupSaslConnection(in2, out2);\n-            }\n-          })) {\n-            // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n-            inStream \u003d saslRpcClient.getInputStream(inStream);\n-            outStream \u003d saslRpcClient.getOutputStream(outStream);\n+        \n+          if (doPing) {\n+            this.in \u003d new DataInputStream(new BufferedInputStream(\n+                new PingInputStream(inStream)));\n           } else {\n-            // fall back to simple auth because server told us so.\n-            authMethod \u003d AuthMethod.SIMPLE;\n-            header \u003d new ConnectionHeader(header.getProtocol(),\n-                header.getUgi(), authMethod);\n-            useSasl \u003d false;\n+            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n           }\n-        }\n-        if (doPing) {\n-          this.in \u003d new DataInputStream(new BufferedInputStream\n-            (new PingInputStream(inStream)));\n-        } else {\n-          this.in \u003d new DataInputStream(new BufferedInputStream\n-            (inStream));\n-        }\n-        this.out \u003d new DataOutputStream\n-            (new BufferedOutputStream(outStream));\n-        writeHeader();\n+          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n+          writeHeader();\n \n-        // update last activity time\n-        touch();\n+          // update last activity time\n+          touch();\n \n-        // start the receiver thread after the socket connection has been set up\n-        start();\n+          // start the receiver thread after the socket connection has been set\n+          // up\n+          start();\n+          return;\n+        }\n       } catch (IOException e) {\n         markClosed(e);\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      } \n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        short numRetries \u003d 0;\n        final short MAX_RETRIES \u003d 5;\n        Random rand \u003d null;\n        while (true) {\n          setupConnection();\n          InputStream inStream \u003d NetUtils.getInputStream(socket);\n          OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n          writeRpcHeader(outStream);\n          if (useSasl) {\n            final InputStream in2 \u003d inStream;\n            final OutputStream out2 \u003d outStream;\n            UserGroupInformation ticket \u003d remoteId.getTicket();\n            if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n              if (ticket.getRealUser() !\u003d null) {\n                ticket \u003d ticket.getRealUser();\n              }\n            }\n            boolean continueSasl \u003d false;\n            try {\n              continueSasl \u003d ticket\n                  .doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n                    @Override\n                    public Boolean run() throws IOException {\n                      return setupSaslConnection(in2, out2);\n                    }\n                  });\n            } catch (Exception ex) {\n              if (rand \u003d\u003d null) {\n                rand \u003d new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand,\n                  ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n              inStream \u003d saslRpcClient.getInputStream(inStream);\n              outStream \u003d saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod \u003d AuthMethod.SIMPLE;\n              header \u003d new ConnectionHeader(header.getProtocol(), header\n                  .getUgi(), authMethod);\n              useSasl \u003d false;\n            }\n          }\n        \n          if (doPing) {\n            this.in \u003d new DataInputStream(new BufferedInputStream(\n                new PingInputStream(inStream)));\n          } else {\n            this.in \u003d new DataInputStream(new BufferedInputStream(inStream));\n          }\n          this.out \u003d new DataOutputStream(new BufferedOutputStream(outStream));\n          writeHeader();\n\n          // update last activity time\n          touch();\n\n          // start the receiver thread after the socket connection has been set\n          // up\n          start();\n          return;\n        }\n      } catch (IOException e) {\n        markClosed(e);\n        close();\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6543. Allows secure clients to talk to unsecure clusters. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@915097 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/02/10 2:28 PM",
      "commitName": "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "14/02/10 11:28 PM",
      "commitNameOld": "8b4b190cbd4678b4b6a5d85b32ce831bd3b99da2",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 7.63,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,78 @@\n     private synchronized void setupIOstreams() throws InterruptedException {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       }\n       \n       short ioFailures \u003d 0;\n       short timeoutFailures \u003d 0;\n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         while (true) {\n           try {\n             this.socket \u003d socketFactory.createSocket();\n             this.socket.setTcpNoDelay(tcpNoDelay);\n             // connection time out is 20s\n             NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n             this.socket.setSoTimeout(pingInterval);\n             break;\n           } catch (SocketTimeoutException toe) {\n             /* The max number of retries is 45,\n              * which amounts to 20s*45 \u003d 15 minutes retries.\n              */\n             handleConnectionFailure(timeoutFailures++, 45, toe);\n           } catch (IOException ie) {\n             handleConnectionFailure(ioFailures++, maxRetries, ie);\n           }\n         }\n         InputStream inStream \u003d NetUtils.getInputStream(socket);\n         OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n         writeRpcHeader(outStream);\n         if (useSasl) {\n           final InputStream in2 \u003d inStream;\n           final OutputStream out2 \u003d outStream;\n           UserGroupInformation ticket \u003d remoteId.getTicket();\n           if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n           }\n-          ticket.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+          if (ticket.doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n             @Override\n-            public Object run() throws IOException, InterruptedException {\n-              setupSaslConnection(in2, out2);\n-              return null;\n+            public Boolean run() throws IOException {\n+              return setupSaslConnection(in2, out2);\n             }\n-          });\n-          inStream \u003d saslRpcClient.getInputStream(inStream);\n-          outStream \u003d saslRpcClient.getOutputStream(outStream);\n+          })) {\n+            // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n+            inStream \u003d saslRpcClient.getInputStream(inStream);\n+            outStream \u003d saslRpcClient.getOutputStream(outStream);\n+          } else {\n+            // fall back to simple auth because server told us so.\n+            authMethod \u003d AuthMethod.SIMPLE;\n+            header \u003d new ConnectionHeader(header.getProtocol(),\n+                header.getUgi(), authMethod);\n+            useSasl \u003d false;\n+          }\n         }\n         if (doPing) {\n           this.in \u003d new DataInputStream(new BufferedInputStream\n             (new PingInputStream(inStream)));\n         } else {\n           this.in \u003d new DataInputStream(new BufferedInputStream\n             (inStream));\n         }\n         this.out \u003d new DataOutputStream\n             (new BufferedOutputStream(outStream));\n         writeHeader();\n \n         // update last activity time\n         touch();\n \n         // start the receiver thread after the socket connection has been set up\n         start();\n       } catch (IOException e) {\n         markClosed(e);\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      }\n      \n      short ioFailures \u003d 0;\n      short timeoutFailures \u003d 0;\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        while (true) {\n          try {\n            this.socket \u003d socketFactory.createSocket();\n            this.socket.setTcpNoDelay(tcpNoDelay);\n            // connection time out is 20s\n            NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n            this.socket.setSoTimeout(pingInterval);\n            break;\n          } catch (SocketTimeoutException toe) {\n            /* The max number of retries is 45,\n             * which amounts to 20s*45 \u003d 15 minutes retries.\n             */\n            handleConnectionFailure(timeoutFailures++, 45, toe);\n          } catch (IOException ie) {\n            handleConnectionFailure(ioFailures++, maxRetries, ie);\n          }\n        }\n        InputStream inStream \u003d NetUtils.getInputStream(socket);\n        OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n        writeRpcHeader(outStream);\n        if (useSasl) {\n          final InputStream in2 \u003d inStream;\n          final OutputStream out2 \u003d outStream;\n          UserGroupInformation ticket \u003d remoteId.getTicket();\n          if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n          }\n          if (ticket.doAs(new PrivilegedExceptionAction\u003cBoolean\u003e() {\n            @Override\n            public Boolean run() throws IOException {\n              return setupSaslConnection(in2, out2);\n            }\n          })) {\n            // Sasl connect is successful. Let\u0027s set up Sasl i/o streams.\n            inStream \u003d saslRpcClient.getInputStream(inStream);\n            outStream \u003d saslRpcClient.getOutputStream(outStream);\n          } else {\n            // fall back to simple auth because server told us so.\n            authMethod \u003d AuthMethod.SIMPLE;\n            header \u003d new ConnectionHeader(header.getProtocol(),\n                header.getUgi(), authMethod);\n            useSasl \u003d false;\n          }\n        }\n        if (doPing) {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (new PingInputStream(inStream)));\n        } else {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (inStream));\n        }\n        this.out \u003d new DataOutputStream\n            (new BufferedOutputStream(outStream));\n        writeHeader();\n\n        // update last activity time\n        touch();\n\n        // start the receiver thread after the socket connection has been set up\n        start();\n      } catch (IOException e) {\n        markClosed(e);\n        close();\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "8b4b190cbd4678b4b6a5d85b32ce831bd3b99da2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6559. Makes the RPC client automatically re-login when the SASL connection setup fails. This is applicable only to keytab based logins. Contributed by Devaraj Das.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@910169 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/02/10 11:28 PM",
      "commitName": "8b4b190cbd4678b4b6a5d85b32ce831bd3b99da2",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "07/02/10 8:55 PM",
      "commitNameOld": "1793e7d9094cd984ae402177c5935239059d74e8",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 7.11,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,71 @@\n     private synchronized void setupIOstreams() throws InterruptedException {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       }\n       \n       short ioFailures \u003d 0;\n       short timeoutFailures \u003d 0;\n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         while (true) {\n           try {\n             this.socket \u003d socketFactory.createSocket();\n             this.socket.setTcpNoDelay(tcpNoDelay);\n             // connection time out is 20s\n             NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n             this.socket.setSoTimeout(pingInterval);\n             break;\n           } catch (SocketTimeoutException toe) {\n             /* The max number of retries is 45,\n              * which amounts to 20s*45 \u003d 15 minutes retries.\n              */\n             handleConnectionFailure(timeoutFailures++, 45, toe);\n           } catch (IOException ie) {\n             handleConnectionFailure(ioFailures++, maxRetries, ie);\n           }\n         }\n         InputStream inStream \u003d NetUtils.getInputStream(socket);\n         OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n         writeRpcHeader(outStream);\n         if (useSasl) {\n           final InputStream in2 \u003d inStream;\n           final OutputStream out2 \u003d outStream;\n           UserGroupInformation ticket \u003d remoteId.getTicket();\n           if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n             if (ticket.getRealUser() !\u003d null) {\n               ticket \u003d ticket.getRealUser();\n             }\n           }\n           ticket.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n             @Override\n-            public Object run() throws IOException {\n-              saslRpcClient \u003d new SaslRpcClient(authMethod, token,\n-                  serverPrincipal);\n-              saslRpcClient.saslConnect(in2, out2);\n+            public Object run() throws IOException, InterruptedException {\n+              setupSaslConnection(in2, out2);\n               return null;\n             }\n           });\n           inStream \u003d saslRpcClient.getInputStream(inStream);\n           outStream \u003d saslRpcClient.getOutputStream(outStream);\n         }\n         if (doPing) {\n           this.in \u003d new DataInputStream(new BufferedInputStream\n             (new PingInputStream(inStream)));\n         } else {\n           this.in \u003d new DataInputStream(new BufferedInputStream\n             (inStream));\n         }\n         this.out \u003d new DataOutputStream\n             (new BufferedOutputStream(outStream));\n         writeHeader();\n \n         // update last activity time\n         touch();\n \n         // start the receiver thread after the socket connection has been set up\n         start();\n       } catch (IOException e) {\n         markClosed(e);\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      }\n      \n      short ioFailures \u003d 0;\n      short timeoutFailures \u003d 0;\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        while (true) {\n          try {\n            this.socket \u003d socketFactory.createSocket();\n            this.socket.setTcpNoDelay(tcpNoDelay);\n            // connection time out is 20s\n            NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n            this.socket.setSoTimeout(pingInterval);\n            break;\n          } catch (SocketTimeoutException toe) {\n            /* The max number of retries is 45,\n             * which amounts to 20s*45 \u003d 15 minutes retries.\n             */\n            handleConnectionFailure(timeoutFailures++, 45, toe);\n          } catch (IOException ie) {\n            handleConnectionFailure(ioFailures++, maxRetries, ie);\n          }\n        }\n        InputStream inStream \u003d NetUtils.getInputStream(socket);\n        OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n        writeRpcHeader(outStream);\n        if (useSasl) {\n          final InputStream in2 \u003d inStream;\n          final OutputStream out2 \u003d outStream;\n          UserGroupInformation ticket \u003d remoteId.getTicket();\n          if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n          }\n          ticket.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n            @Override\n            public Object run() throws IOException, InterruptedException {\n              setupSaslConnection(in2, out2);\n              return null;\n            }\n          });\n          inStream \u003d saslRpcClient.getInputStream(inStream);\n          outStream \u003d saslRpcClient.getOutputStream(outStream);\n        }\n        if (doPing) {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (new PingInputStream(inStream)));\n        } else {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (inStream));\n        }\n        this.out \u003d new DataOutputStream\n            (new BufferedOutputStream(outStream));\n        writeHeader();\n\n        // update last activity time\n        touch();\n\n        // start the receiver thread after the socket connection has been set up\n        start();\n      } catch (IOException e) {\n        markClosed(e);\n        close();\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "1793e7d9094cd984ae402177c5935239059d74e8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6510. Adds a way for superusers to impersonate other users in a secure environment. Contributed by Jitendra Nath Pandey.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@907549 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/02/10 8:55 PM",
      "commitName": "1793e7d9094cd984ae402177c5935239059d74e8",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "02/02/10 5:30 PM",
      "commitNameOld": "940389afce6a1b9b9e1519aed528cbc444786756",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 5.14,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,73 @@\n     private synchronized void setupIOstreams() throws InterruptedException {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       }\n       \n       short ioFailures \u003d 0;\n       short timeoutFailures \u003d 0;\n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         while (true) {\n           try {\n             this.socket \u003d socketFactory.createSocket();\n             this.socket.setTcpNoDelay(tcpNoDelay);\n             // connection time out is 20s\n             NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n             this.socket.setSoTimeout(pingInterval);\n             break;\n           } catch (SocketTimeoutException toe) {\n             /* The max number of retries is 45,\n              * which amounts to 20s*45 \u003d 15 minutes retries.\n              */\n             handleConnectionFailure(timeoutFailures++, 45, toe);\n           } catch (IOException ie) {\n             handleConnectionFailure(ioFailures++, maxRetries, ie);\n           }\n         }\n         InputStream inStream \u003d NetUtils.getInputStream(socket);\n         OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n         writeRpcHeader(outStream);\n         if (useSasl) {\n           final InputStream in2 \u003d inStream;\n           final OutputStream out2 \u003d outStream;\n-          remoteId.getTicket().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+          UserGroupInformation ticket \u003d remoteId.getTicket();\n+          if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n+            if (ticket.getRealUser() !\u003d null) {\n+              ticket \u003d ticket.getRealUser();\n+            }\n+          }\n+          ticket.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n             @Override\n             public Object run() throws IOException {\n               saslRpcClient \u003d new SaslRpcClient(authMethod, token,\n                   serverPrincipal);\n               saslRpcClient.saslConnect(in2, out2);\n               return null;\n             }\n           });\n           inStream \u003d saslRpcClient.getInputStream(inStream);\n           outStream \u003d saslRpcClient.getOutputStream(outStream);\n         }\n         if (doPing) {\n           this.in \u003d new DataInputStream(new BufferedInputStream\n             (new PingInputStream(inStream)));\n         } else {\n           this.in \u003d new DataInputStream(new BufferedInputStream\n             (inStream));\n         }\n         this.out \u003d new DataOutputStream\n             (new BufferedOutputStream(outStream));\n         writeHeader();\n \n         // update last activity time\n         touch();\n \n         // start the receiver thread after the socket connection has been set up\n         start();\n       } catch (IOException e) {\n         markClosed(e);\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      }\n      \n      short ioFailures \u003d 0;\n      short timeoutFailures \u003d 0;\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        while (true) {\n          try {\n            this.socket \u003d socketFactory.createSocket();\n            this.socket.setTcpNoDelay(tcpNoDelay);\n            // connection time out is 20s\n            NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n            this.socket.setSoTimeout(pingInterval);\n            break;\n          } catch (SocketTimeoutException toe) {\n            /* The max number of retries is 45,\n             * which amounts to 20s*45 \u003d 15 minutes retries.\n             */\n            handleConnectionFailure(timeoutFailures++, 45, toe);\n          } catch (IOException ie) {\n            handleConnectionFailure(ioFailures++, maxRetries, ie);\n          }\n        }\n        InputStream inStream \u003d NetUtils.getInputStream(socket);\n        OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n        writeRpcHeader(outStream);\n        if (useSasl) {\n          final InputStream in2 \u003d inStream;\n          final OutputStream out2 \u003d outStream;\n          UserGroupInformation ticket \u003d remoteId.getTicket();\n          if (authMethod \u003d\u003d AuthMethod.KERBEROS) {\n            if (ticket.getRealUser() !\u003d null) {\n              ticket \u003d ticket.getRealUser();\n            }\n          }\n          ticket.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n            @Override\n            public Object run() throws IOException {\n              saslRpcClient \u003d new SaslRpcClient(authMethod, token,\n                  serverPrincipal);\n              saslRpcClient.saslConnect(in2, out2);\n              return null;\n            }\n          });\n          inStream \u003d saslRpcClient.getInputStream(inStream);\n          outStream \u003d saslRpcClient.getOutputStream(outStream);\n        }\n        if (doPing) {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (new PingInputStream(inStream)));\n        } else {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (inStream));\n        }\n        this.out \u003d new DataOutputStream\n            (new BufferedOutputStream(outStream));\n        writeHeader();\n\n        // update last activity time\n        touch();\n\n        // start the receiver thread after the socket connection has been set up\n        start();\n      } catch (IOException e) {\n        markClosed(e);\n        close();\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "940389afce6a1b9b9e1519aed528cbc444786756": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/02/10 5:30 PM",
      "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
      "commitAuthor": "Devaraj Das",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/02/10 5:30 PM",
          "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
          "commitAuthor": "Devaraj Das",
          "commitDateOld": "26/01/10 2:55 PM",
          "commitNameOld": "34d1b39c7525898b43e44a7c5cbd86768714baf0",
          "commitAuthorOld": "Hairong Kuang",
          "daysBetweenCommits": 7.11,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,67 @@\n-    private synchronized void setupIOstreams() {\n+    private synchronized void setupIOstreams() throws InterruptedException {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       }\n       \n       short ioFailures \u003d 0;\n       short timeoutFailures \u003d 0;\n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         while (true) {\n           try {\n             this.socket \u003d socketFactory.createSocket();\n             this.socket.setTcpNoDelay(tcpNoDelay);\n             // connection time out is 20s\n             NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n             this.socket.setSoTimeout(pingInterval);\n             break;\n           } catch (SocketTimeoutException toe) {\n             /* The max number of retries is 45,\n              * which amounts to 20s*45 \u003d 15 minutes retries.\n              */\n             handleConnectionFailure(timeoutFailures++, 45, toe);\n           } catch (IOException ie) {\n             handleConnectionFailure(ioFailures++, maxRetries, ie);\n           }\n         }\n+        InputStream inStream \u003d NetUtils.getInputStream(socket);\n+        OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n+        writeRpcHeader(outStream);\n+        if (useSasl) {\n+          final InputStream in2 \u003d inStream;\n+          final OutputStream out2 \u003d outStream;\n+          remoteId.getTicket().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+            @Override\n+            public Object run() throws IOException {\n+              saslRpcClient \u003d new SaslRpcClient(authMethod, token,\n+                  serverPrincipal);\n+              saslRpcClient.saslConnect(in2, out2);\n+              return null;\n+            }\n+          });\n+          inStream \u003d saslRpcClient.getInputStream(inStream);\n+          outStream \u003d saslRpcClient.getOutputStream(outStream);\n+        }\n         if (doPing) {\n           this.in \u003d new DataInputStream(new BufferedInputStream\n-            (new PingInputStream(NetUtils.getInputStream(socket))));\n+            (new PingInputStream(inStream)));\n         } else {\n           this.in \u003d new DataInputStream(new BufferedInputStream\n-            (NetUtils.getInputStream(socket)));\n+            (inStream));\n         }\n         this.out \u003d new DataOutputStream\n-            (new BufferedOutputStream(NetUtils.getOutputStream(socket)));\n+            (new BufferedOutputStream(outStream));\n         writeHeader();\n \n         // update last activity time\n         touch();\n \n         // start the receiver thread after the socket connection has been set up\n         start();\n       } catch (IOException e) {\n         markClosed(e);\n         close();\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      }\n      \n      short ioFailures \u003d 0;\n      short timeoutFailures \u003d 0;\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        while (true) {\n          try {\n            this.socket \u003d socketFactory.createSocket();\n            this.socket.setTcpNoDelay(tcpNoDelay);\n            // connection time out is 20s\n            NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n            this.socket.setSoTimeout(pingInterval);\n            break;\n          } catch (SocketTimeoutException toe) {\n            /* The max number of retries is 45,\n             * which amounts to 20s*45 \u003d 15 minutes retries.\n             */\n            handleConnectionFailure(timeoutFailures++, 45, toe);\n          } catch (IOException ie) {\n            handleConnectionFailure(ioFailures++, maxRetries, ie);\n          }\n        }\n        InputStream inStream \u003d NetUtils.getInputStream(socket);\n        OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n        writeRpcHeader(outStream);\n        if (useSasl) {\n          final InputStream in2 \u003d inStream;\n          final OutputStream out2 \u003d outStream;\n          remoteId.getTicket().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n            @Override\n            public Object run() throws IOException {\n              saslRpcClient \u003d new SaslRpcClient(authMethod, token,\n                  serverPrincipal);\n              saslRpcClient.saslConnect(in2, out2);\n              return null;\n            }\n          });\n          inStream \u003d saslRpcClient.getInputStream(inStream);\n          outStream \u003d saslRpcClient.getOutputStream(outStream);\n        }\n        if (doPing) {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (new PingInputStream(inStream)));\n        } else {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (inStream));\n        }\n        this.out \u003d new DataOutputStream\n            (new BufferedOutputStream(outStream));\n        writeHeader();\n\n        // update last activity time\n        touch();\n\n        // start the receiver thread after the socket connection has been set up\n        start();\n      } catch (IOException e) {\n        markClosed(e);\n        close();\n      }\n    }",
          "path": "src/java/org/apache/hadoop/ipc/Client.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/02/10 5:30 PM",
          "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
          "commitAuthor": "Devaraj Das",
          "commitDateOld": "26/01/10 2:55 PM",
          "commitNameOld": "34d1b39c7525898b43e44a7c5cbd86768714baf0",
          "commitAuthorOld": "Hairong Kuang",
          "daysBetweenCommits": 7.11,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,67 @@\n-    private synchronized void setupIOstreams() {\n+    private synchronized void setupIOstreams() throws InterruptedException {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       }\n       \n       short ioFailures \u003d 0;\n       short timeoutFailures \u003d 0;\n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         while (true) {\n           try {\n             this.socket \u003d socketFactory.createSocket();\n             this.socket.setTcpNoDelay(tcpNoDelay);\n             // connection time out is 20s\n             NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n             this.socket.setSoTimeout(pingInterval);\n             break;\n           } catch (SocketTimeoutException toe) {\n             /* The max number of retries is 45,\n              * which amounts to 20s*45 \u003d 15 minutes retries.\n              */\n             handleConnectionFailure(timeoutFailures++, 45, toe);\n           } catch (IOException ie) {\n             handleConnectionFailure(ioFailures++, maxRetries, ie);\n           }\n         }\n+        InputStream inStream \u003d NetUtils.getInputStream(socket);\n+        OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n+        writeRpcHeader(outStream);\n+        if (useSasl) {\n+          final InputStream in2 \u003d inStream;\n+          final OutputStream out2 \u003d outStream;\n+          remoteId.getTicket().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+            @Override\n+            public Object run() throws IOException {\n+              saslRpcClient \u003d new SaslRpcClient(authMethod, token,\n+                  serverPrincipal);\n+              saslRpcClient.saslConnect(in2, out2);\n+              return null;\n+            }\n+          });\n+          inStream \u003d saslRpcClient.getInputStream(inStream);\n+          outStream \u003d saslRpcClient.getOutputStream(outStream);\n+        }\n         if (doPing) {\n           this.in \u003d new DataInputStream(new BufferedInputStream\n-            (new PingInputStream(NetUtils.getInputStream(socket))));\n+            (new PingInputStream(inStream)));\n         } else {\n           this.in \u003d new DataInputStream(new BufferedInputStream\n-            (NetUtils.getInputStream(socket)));\n+            (inStream));\n         }\n         this.out \u003d new DataOutputStream\n-            (new BufferedOutputStream(NetUtils.getOutputStream(socket)));\n+            (new BufferedOutputStream(outStream));\n         writeHeader();\n \n         // update last activity time\n         touch();\n \n         // start the receiver thread after the socket connection has been set up\n         start();\n       } catch (IOException e) {\n         markClosed(e);\n         close();\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private synchronized void setupIOstreams() throws InterruptedException {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      }\n      \n      short ioFailures \u003d 0;\n      short timeoutFailures \u003d 0;\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        while (true) {\n          try {\n            this.socket \u003d socketFactory.createSocket();\n            this.socket.setTcpNoDelay(tcpNoDelay);\n            // connection time out is 20s\n            NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n            this.socket.setSoTimeout(pingInterval);\n            break;\n          } catch (SocketTimeoutException toe) {\n            /* The max number of retries is 45,\n             * which amounts to 20s*45 \u003d 15 minutes retries.\n             */\n            handleConnectionFailure(timeoutFailures++, 45, toe);\n          } catch (IOException ie) {\n            handleConnectionFailure(ioFailures++, maxRetries, ie);\n          }\n        }\n        InputStream inStream \u003d NetUtils.getInputStream(socket);\n        OutputStream outStream \u003d NetUtils.getOutputStream(socket);\n        writeRpcHeader(outStream);\n        if (useSasl) {\n          final InputStream in2 \u003d inStream;\n          final OutputStream out2 \u003d outStream;\n          remoteId.getTicket().doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n            @Override\n            public Object run() throws IOException {\n              saslRpcClient \u003d new SaslRpcClient(authMethod, token,\n                  serverPrincipal);\n              saslRpcClient.saslConnect(in2, out2);\n              return null;\n            }\n          });\n          inStream \u003d saslRpcClient.getInputStream(inStream);\n          outStream \u003d saslRpcClient.getOutputStream(outStream);\n        }\n        if (doPing) {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (new PingInputStream(inStream)));\n        } else {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (inStream));\n        }\n        this.out \u003d new DataOutputStream\n            (new BufferedOutputStream(outStream));\n        writeHeader();\n\n        // update last activity time\n        touch();\n\n        // start the receiver thread after the socket connection has been set up\n        start();\n      } catch (IOException e) {\n        markClosed(e);\n        close();\n      }\n    }",
          "path": "src/java/org/apache/hadoop/ipc/Client.java",
          "extendedDetails": {}
        }
      ]
    },
    "c38c5a43ffc2b12a1acb3afd1fa7685775bdeda1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6099. The RPC module can be configured to not send period pings.\nThe default behaviour remains unchanged. (dhruba)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@792812 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/07/09 11:17 PM",
      "commitName": "c38c5a43ffc2b12a1acb3afd1fa7685775bdeda1",
      "commitAuthor": "Dhruba Borthakur",
      "commitDateOld": "18/05/09 9:20 PM",
      "commitNameOld": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 52.08,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,49 @@\n     private synchronized void setupIOstreams() {\n       if (socket !\u003d null || shouldCloseConnection.get()) {\n         return;\n       }\n       \n       short ioFailures \u003d 0;\n       short timeoutFailures \u003d 0;\n       try {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to \"+server);\n         }\n         while (true) {\n           try {\n             this.socket \u003d socketFactory.createSocket();\n             this.socket.setTcpNoDelay(tcpNoDelay);\n             // connection time out is 20s\n             NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n             this.socket.setSoTimeout(pingInterval);\n             break;\n           } catch (SocketTimeoutException toe) {\n             /* The max number of retries is 45,\n              * which amounts to 20s*45 \u003d 15 minutes retries.\n              */\n             handleConnectionFailure(timeoutFailures++, 45, toe);\n           } catch (IOException ie) {\n             handleConnectionFailure(ioFailures++, maxRetries, ie);\n           }\n         }\n-        this.in \u003d new DataInputStream(new BufferedInputStream\n+        if (doPing) {\n+          this.in \u003d new DataInputStream(new BufferedInputStream\n             (new PingInputStream(NetUtils.getInputStream(socket))));\n+        } else {\n+          this.in \u003d new DataInputStream(new BufferedInputStream\n+            (NetUtils.getInputStream(socket)));\n+        }\n         this.out \u003d new DataOutputStream\n             (new BufferedOutputStream(NetUtils.getOutputStream(socket)));\n         writeHeader();\n \n         // update last activity time\n         touch();\n \n         // start the receiver thread after the socket connection has been set up\n         start();\n       } catch (IOException e) {\n         markClosed(e);\n         close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      }\n      \n      short ioFailures \u003d 0;\n      short timeoutFailures \u003d 0;\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        while (true) {\n          try {\n            this.socket \u003d socketFactory.createSocket();\n            this.socket.setTcpNoDelay(tcpNoDelay);\n            // connection time out is 20s\n            NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n            this.socket.setSoTimeout(pingInterval);\n            break;\n          } catch (SocketTimeoutException toe) {\n            /* The max number of retries is 45,\n             * which amounts to 20s*45 \u003d 15 minutes retries.\n             */\n            handleConnectionFailure(timeoutFailures++, 45, toe);\n          } catch (IOException ie) {\n            handleConnectionFailure(ioFailures++, maxRetries, ie);\n          }\n        }\n        if (doPing) {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (new PingInputStream(NetUtils.getInputStream(socket))));\n        } else {\n          this.in \u003d new DataInputStream(new BufferedInputStream\n            (NetUtils.getInputStream(socket)));\n        }\n        this.out \u003d new DataOutputStream\n            (new BufferedOutputStream(NetUtils.getOutputStream(socket)));\n        writeHeader();\n\n        // update last activity time\n        touch();\n\n        // start the receiver thread after the socket connection has been set up\n        start();\n      } catch (IOException e) {\n        markClosed(e);\n        close();\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,44 @@\n+    private synchronized void setupIOstreams() {\n+      if (socket !\u003d null || shouldCloseConnection.get()) {\n+        return;\n+      }\n+      \n+      short ioFailures \u003d 0;\n+      short timeoutFailures \u003d 0;\n+      try {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Connecting to \"+server);\n+        }\n+        while (true) {\n+          try {\n+            this.socket \u003d socketFactory.createSocket();\n+            this.socket.setTcpNoDelay(tcpNoDelay);\n+            // connection time out is 20s\n+            NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n+            this.socket.setSoTimeout(pingInterval);\n+            break;\n+          } catch (SocketTimeoutException toe) {\n+            /* The max number of retries is 45,\n+             * which amounts to 20s*45 \u003d 15 minutes retries.\n+             */\n+            handleConnectionFailure(timeoutFailures++, 45, toe);\n+          } catch (IOException ie) {\n+            handleConnectionFailure(ioFailures++, maxRetries, ie);\n+          }\n+        }\n+        this.in \u003d new DataInputStream(new BufferedInputStream\n+            (new PingInputStream(NetUtils.getInputStream(socket))));\n+        this.out \u003d new DataOutputStream\n+            (new BufferedOutputStream(NetUtils.getOutputStream(socket)));\n+        writeHeader();\n+\n+        // update last activity time\n+        touch();\n+\n+        // start the receiver thread after the socket connection has been set up\n+        start();\n+      } catch (IOException e) {\n+        markClosed(e);\n+        close();\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private synchronized void setupIOstreams() {\n      if (socket !\u003d null || shouldCloseConnection.get()) {\n        return;\n      }\n      \n      short ioFailures \u003d 0;\n      short timeoutFailures \u003d 0;\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \"+server);\n        }\n        while (true) {\n          try {\n            this.socket \u003d socketFactory.createSocket();\n            this.socket.setTcpNoDelay(tcpNoDelay);\n            // connection time out is 20s\n            NetUtils.connect(this.socket, remoteId.getAddress(), 20000);\n            this.socket.setSoTimeout(pingInterval);\n            break;\n          } catch (SocketTimeoutException toe) {\n            /* The max number of retries is 45,\n             * which amounts to 20s*45 \u003d 15 minutes retries.\n             */\n            handleConnectionFailure(timeoutFailures++, 45, toe);\n          } catch (IOException ie) {\n            handleConnectionFailure(ioFailures++, maxRetries, ie);\n          }\n        }\n        this.in \u003d new DataInputStream(new BufferedInputStream\n            (new PingInputStream(NetUtils.getInputStream(socket))));\n        this.out \u003d new DataOutputStream\n            (new BufferedOutputStream(NetUtils.getOutputStream(socket)));\n        writeHeader();\n\n        // update last activity time\n        touch();\n\n        // start the receiver thread after the socket connection has been set up\n        start();\n      } catch (IOException e) {\n        markClosed(e);\n        close();\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Client.java"
    }
  }
}