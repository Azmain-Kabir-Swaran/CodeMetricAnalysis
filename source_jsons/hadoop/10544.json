{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BPServiceActor.java",
  "functionName": "register",
  "functionId": "register___nsInfo-NamespaceInfo",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
  "functionStartLine": 782,
  "functionEndLine": 824,
  "numCommitsSeen": 225,
  "timeTaken": 10430,
  "changeHistory": [
    "2059f255d39510cddbb954b21ed4871a737bd2dc",
    "c4e27ef7735acd6f91b73d2ecb0227f8dd75a2e4",
    "69b903bbd8e2dafac6b2cb1d748ea666b6f877cf",
    "387dbe587aa66ac99ec5f5b50827ec3e0a327613",
    "5652131d2ea68c408dd3cd8bee31723642a8cdde",
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59",
    "dfc1c4c303cf15afc6c3361ed9d3238562f73cbd",
    "d324164a51a43d72c02567248bd9f0f12b244a40",
    "3d15728ff5301296801e541d9b23bd1687c4adad",
    "0663dbaac0a19719ddf9cd4290ba893bfca69da2",
    "9e108e61fb28244326d7cf4bb31d175eb75d2636",
    "1e346aa829519f8a2aa830e76d9856f914861805",
    "39ce694d05c6d8c428bd87bc1b9c95f94dfdf6fd",
    "1f92266516c882e43fa453b876dd8ca09893c477",
    "905a127850d5e0cba85c2e075f989fa0f5cf129a",
    "0864ef19089f703232107d8aa26c4a7571ff132e",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "c54c117407bc441b539b8acfdb022586f17dafc1",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "2059f255d39510cddbb954b21ed4871a737bd2dc": "Ybodychange",
    "c4e27ef7735acd6f91b73d2ecb0227f8dd75a2e4": "Ybodychange",
    "69b903bbd8e2dafac6b2cb1d748ea666b6f877cf": "Ybodychange",
    "387dbe587aa66ac99ec5f5b50827ec3e0a327613": "Ybodychange",
    "5652131d2ea68c408dd3cd8bee31723642a8cdde": "Ybodychange",
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59": "Ybodychange",
    "dfc1c4c303cf15afc6c3361ed9d3238562f73cbd": "Ybodychange",
    "d324164a51a43d72c02567248bd9f0f12b244a40": "Ymultichange(Yparameterchange,Ybodychange)",
    "3d15728ff5301296801e541d9b23bd1687c4adad": "Ybodychange",
    "0663dbaac0a19719ddf9cd4290ba893bfca69da2": "Ybodychange",
    "9e108e61fb28244326d7cf4bb31d175eb75d2636": "Ybodychange",
    "1e346aa829519f8a2aa830e76d9856f914861805": "Ymultichange(Ymovefromfile,Ybodychange)",
    "39ce694d05c6d8c428bd87bc1b9c95f94dfdf6fd": "Ymovefromfile",
    "1f92266516c882e43fa453b876dd8ca09893c477": "Ybodychange",
    "905a127850d5e0cba85c2e075f989fa0f5cf129a": "Ybodychange",
    "0864ef19089f703232107d8aa26c4a7571ff132e": "Ybodychange",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "c54c117407bc441b539b8acfdb022586f17dafc1": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2059f255d39510cddbb954b21ed4871a737bd2dc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15167. Block Report Interval shouldn\u0027t be reset apart from first Block Report. Contributed by Ayush Saxena.\n",
      "commitDate": "27/02/20 12:38 AM",
      "commitName": "2059f255d39510cddbb954b21ed4871a737bd2dc",
      "commitAuthor": "Surendra Singh Lilhore",
      "commitDateOld": "26/12/19 7:42 PM",
      "commitNameOld": "80f91d14ab0fb385252d4eeb19141bd059303d59",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 62.21,
      "commitsBetweenForRepo": 210,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   void register(NamespaceInfo nsInfo) throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n     DatanodeRegistration newBpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated fields\n         newBpRegistration \u003d bpNamenode.registerDatanode(newBpRegistration);\n         newBpRegistration.setNamespaceInfo(nsInfo);\n         bpRegistration \u003d newBpRegistration;\n         break;\n       } catch(EOFException e) {  // namenode might have just restarted\n         LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n             + e.getLocalizedMessage());\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n       } catch(RemoteException e) {\n         LOG.warn(\"RemoteException in register\", e);\n         throw e;\n       } catch(IOException e) {\n         LOG.warn(\"Problem connecting to server: \" + nnAddr);\n       }\n       // Try again in a second\n       sleepAndLogInterrupts(1000, \"connecting to server\");\n     }\n \n     if (bpRegistration \u003d\u003d null) {\n       throw new IOException(\"DN shut down before block pool registered\");\n     }\n \n     LOG.info(this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n     // reset lease id whenever registered to NN.\n     // ask for a new lease id at the next heartbeat.\n     fullBlockReportLeaseId \u003d 0;\n \n     // random short delay - helps scatter the BR from all DNs\n-    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs);\n+    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs, true);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void register(NamespaceInfo nsInfo) throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    DatanodeRegistration newBpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated fields\n        newBpRegistration \u003d bpNamenode.registerDatanode(newBpRegistration);\n        newBpRegistration.setNamespaceInfo(nsInfo);\n        bpRegistration \u003d newBpRegistration;\n        break;\n      } catch(EOFException e) {  // namenode might have just restarted\n        LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n            + e.getLocalizedMessage());\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n      } catch(RemoteException e) {\n        LOG.warn(\"RemoteException in register\", e);\n        throw e;\n      } catch(IOException e) {\n        LOG.warn(\"Problem connecting to server: \" + nnAddr);\n      }\n      // Try again in a second\n      sleepAndLogInterrupts(1000, \"connecting to server\");\n    }\n\n    if (bpRegistration \u003d\u003d null) {\n      throw new IOException(\"DN shut down before block pool registered\");\n    }\n\n    LOG.info(this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // reset lease id whenever registered to NN.\n    // ask for a new lease id at the next heartbeat.\n    fullBlockReportLeaseId \u003d 0;\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs, true);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "c4e27ef7735acd6f91b73d2ecb0227f8dd75a2e4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12749. DN may not send block report to NN after NN restart. Contributed by Xiaoqiao He.\n",
      "commitDate": "21/10/19 2:33 PM",
      "commitName": "c4e27ef7735acd6f91b73d2ecb0227f8dd75a2e4",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "17/08/19 4:37 AM",
      "commitNameOld": "528378784fe14e7069dd0471f3c4c478544b57c8",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 65.41,
      "commitsBetweenForRepo": 514,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,43 @@\n   void register(NamespaceInfo nsInfo) throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n     DatanodeRegistration newBpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated fields\n         newBpRegistration \u003d bpNamenode.registerDatanode(newBpRegistration);\n         newBpRegistration.setNamespaceInfo(nsInfo);\n         bpRegistration \u003d newBpRegistration;\n         break;\n       } catch(EOFException e) {  // namenode might have just restarted\n         LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n             + e.getLocalizedMessage());\n-        sleepAndLogInterrupts(1000, \"connecting to server\");\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n-        sleepAndLogInterrupts(1000, \"connecting to server\");\n+      } catch(RemoteException e) {\n+        LOG.warn(\"RemoteException in register\", e);\n+        throw e;\n+      } catch(IOException e) {\n+        LOG.warn(\"Problem connecting to server: \" + nnAddr);\n       }\n+      // Try again in a second\n+      sleepAndLogInterrupts(1000, \"connecting to server\");\n     }\n \n     if (bpRegistration \u003d\u003d null) {\n       throw new IOException(\"DN shut down before block pool registered\");\n     }\n \n     LOG.info(this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n     // reset lease id whenever registered to NN.\n     // ask for a new lease id at the next heartbeat.\n     fullBlockReportLeaseId \u003d 0;\n \n     // random short delay - helps scatter the BR from all DNs\n     scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void register(NamespaceInfo nsInfo) throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    DatanodeRegistration newBpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated fields\n        newBpRegistration \u003d bpNamenode.registerDatanode(newBpRegistration);\n        newBpRegistration.setNamespaceInfo(nsInfo);\n        bpRegistration \u003d newBpRegistration;\n        break;\n      } catch(EOFException e) {  // namenode might have just restarted\n        LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n            + e.getLocalizedMessage());\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n      } catch(RemoteException e) {\n        LOG.warn(\"RemoteException in register\", e);\n        throw e;\n      } catch(IOException e) {\n        LOG.warn(\"Problem connecting to server: \" + nnAddr);\n      }\n      // Try again in a second\n      sleepAndLogInterrupts(1000, \"connecting to server\");\n    }\n\n    if (bpRegistration \u003d\u003d null) {\n      throw new IOException(\"DN shut down before block pool registered\");\n    }\n\n    LOG.info(this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // reset lease id whenever registered to NN.\n    // ask for a new lease id at the next heartbeat.\n    fullBlockReportLeaseId \u003d 0;\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "69b903bbd8e2dafac6b2cb1d748ea666b6f877cf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14372. NPE while DN is shutting down. Contributed by lujie.\n",
      "commitDate": "05/05/19 4:03 AM",
      "commitName": "69b903bbd8e2dafac6b2cb1d748ea666b6f877cf",
      "commitAuthor": "Surendra Singh Lilhore",
      "commitDateOld": "04/03/19 10:43 AM",
      "commitNameOld": "387dbe587aa66ac99ec5f5b50827ec3e0a327613",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 61.68,
      "commitsBetweenForRepo": 426,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,38 @@\n   void register(NamespaceInfo nsInfo) throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n     DatanodeRegistration newBpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated fields\n         newBpRegistration \u003d bpNamenode.registerDatanode(newBpRegistration);\n         newBpRegistration.setNamespaceInfo(nsInfo);\n         bpRegistration \u003d newBpRegistration;\n         break;\n       } catch(EOFException e) {  // namenode might have just restarted\n         LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n             + e.getLocalizedMessage());\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n-    \n-    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n+\n+    if (bpRegistration \u003d\u003d null) {\n+      throw new IOException(\"DN shut down before block pool registered\");\n+    }\n+\n+    LOG.info(this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n     // reset lease id whenever registered to NN.\n     // ask for a new lease id at the next heartbeat.\n     fullBlockReportLeaseId \u003d 0;\n \n     // random short delay - helps scatter the BR from all DNs\n     scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void register(NamespaceInfo nsInfo) throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    DatanodeRegistration newBpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated fields\n        newBpRegistration \u003d bpNamenode.registerDatanode(newBpRegistration);\n        newBpRegistration.setNamespaceInfo(nsInfo);\n        bpRegistration \u003d newBpRegistration;\n        break;\n      } catch(EOFException e) {  // namenode might have just restarted\n        LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n            + e.getLocalizedMessage());\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n\n    if (bpRegistration \u003d\u003d null) {\n      throw new IOException(\"DN shut down before block pool registered\");\n    }\n\n    LOG.info(this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // reset lease id whenever registered to NN.\n    // ask for a new lease id at the next heartbeat.\n    fullBlockReportLeaseId \u003d 0;\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "387dbe587aa66ac99ec5f5b50827ec3e0a327613": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14314. fullBlockReportLeaseId should be reset after registering to NN. Contributed by star.\n",
      "commitDate": "04/03/19 10:43 AM",
      "commitName": "387dbe587aa66ac99ec5f5b50827ec3e0a327613",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "24/12/18 9:33 AM",
      "commitNameOld": "091ad974cd29fae0cf8fbc98ab84900a1a324839",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 70.05,
      "commitsBetweenForRepo": 524,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,34 @@\n   void register(NamespaceInfo nsInfo) throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n     DatanodeRegistration newBpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated fields\n         newBpRegistration \u003d bpNamenode.registerDatanode(newBpRegistration);\n         newBpRegistration.setNamespaceInfo(nsInfo);\n         bpRegistration \u003d newBpRegistration;\n         break;\n       } catch(EOFException e) {  // namenode might have just restarted\n         LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n             + e.getLocalizedMessage());\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n     \n     LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n+    // reset lease id whenever registered to NN.\n+    // ask for a new lease id at the next heartbeat.\n+    fullBlockReportLeaseId \u003d 0;\n+\n     // random short delay - helps scatter the BR from all DNs\n     scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void register(NamespaceInfo nsInfo) throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    DatanodeRegistration newBpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated fields\n        newBpRegistration \u003d bpNamenode.registerDatanode(newBpRegistration);\n        newBpRegistration.setNamespaceInfo(nsInfo);\n        bpRegistration \u003d newBpRegistration;\n        break;\n      } catch(EOFException e) {  // namenode might have just restarted\n        LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n            + e.getLocalizedMessage());\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // reset lease id whenever registered to NN.\n    // ask for a new lease id at the next heartbeat.\n    fullBlockReportLeaseId \u003d 0;\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "5652131d2ea68c408dd3cd8bee31723642a8cdde": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8995. Flaw in registration bookeeping can make DN die on reconnect. (Kihwal Lee via yliu)\n",
      "commitDate": "01/09/15 5:58 PM",
      "commitName": "5652131d2ea68c408dd3cd8bee31723642a8cdde",
      "commitAuthor": "yliu",
      "commitDateOld": "24/06/15 2:42 PM",
      "commitNameOld": "afe9ea3c12e1f5a71922400eadb642960bc87ca1",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 69.14,
      "commitsBetweenForRepo": 397,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,30 @@\n   void register(NamespaceInfo nsInfo) throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n-    bpRegistration \u003d bpos.createRegistration();\n+    DatanodeRegistration newBpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated fields\n-        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n-        bpRegistration.setNamespaceInfo(nsInfo);\n+        newBpRegistration \u003d bpNamenode.registerDatanode(newBpRegistration);\n+        newBpRegistration.setNamespaceInfo(nsInfo);\n+        bpRegistration \u003d newBpRegistration;\n         break;\n       } catch(EOFException e) {  // namenode might have just restarted\n         LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n             + e.getLocalizedMessage());\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n     \n     LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n     // random short delay - helps scatter the BR from all DNs\n     scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void register(NamespaceInfo nsInfo) throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    DatanodeRegistration newBpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated fields\n        newBpRegistration \u003d bpNamenode.registerDatanode(newBpRegistration);\n        newBpRegistration.setNamespaceInfo(nsInfo);\n        bpRegistration \u003d newBpRegistration;\n        break;\n      } catch(EOFException e) {  // namenode might have just restarted\n        LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n            + e.getLocalizedMessage());\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7923. The DataNodes should rate-limit their full block reports by asking the NN on heartbeat messages (cmccabe)\n",
      "commitDate": "12/06/15 11:17 AM",
      "commitName": "12b5b06c063d93e6c683c9b6fac9a96912f59e59",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "19/05/15 10:50 AM",
      "commitNameOld": "470c87dbc6c24dd3b370f1ad9e7ab1f6dabd2080",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 24.02,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   void register(NamespaceInfo nsInfo) throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n     bpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated fields\n         bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n         bpRegistration.setNamespaceInfo(nsInfo);\n         break;\n       } catch(EOFException e) {  // namenode might have just restarted\n         LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n             + e.getLocalizedMessage());\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n     \n     LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n     // random short delay - helps scatter the BR from all DNs\n-    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelay);\n+    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void register(NamespaceInfo nsInfo) throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    bpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated fields\n        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n        bpRegistration.setNamespaceInfo(nsInfo);\n        break;\n      } catch(EOFException e) {  // namenode might have just restarted\n        LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n            + e.getLocalizedMessage());\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelayMs);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "dfc1c4c303cf15afc6c3361ed9d3238562f73cbd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8163. Using monotonicNow for block report scheduling causes test failures on recently restarted systems. (Arpit Agarwal)\n",
      "commitDate": "21/04/15 10:58 AM",
      "commitName": "dfc1c4c303cf15afc6c3361ed9d3238562f73cbd",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "08/04/15 9:43 PM",
      "commitNameOld": "b1e059089d6a5b2b7006d7d384c6df81ed268bd9",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 12.55,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   void register(NamespaceInfo nsInfo) throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n     bpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated fields\n         bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n         bpRegistration.setNamespaceInfo(nsInfo);\n         break;\n       } catch(EOFException e) {  // namenode might have just restarted\n         LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n             + e.getLocalizedMessage());\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n     \n     LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n     // random short delay - helps scatter the BR from all DNs\n-    scheduleBlockReport(dnConf.initialBlockReportDelay);\n+    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelay);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void register(NamespaceInfo nsInfo) throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    bpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated fields\n        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n        bpRegistration.setNamespaceInfo(nsInfo);\n        break;\n      } catch(EOFException e) {  // namenode might have just restarted\n        LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n            + e.getLocalizedMessage());\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduler.scheduleBlockReport(dnConf.initialBlockReportDelay);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "d324164a51a43d72c02567248bd9f0f12b244a40": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7435. PB encoding of block reports is very inefficient. Contributed by Daryn Sharp.\n",
      "commitDate": "13/03/15 12:23 PM",
      "commitName": "d324164a51a43d72c02567248bd9f0f12b244a40",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7435. PB encoding of block reports is very inefficient. Contributed by Daryn Sharp.\n",
          "commitDate": "13/03/15 12:23 PM",
          "commitName": "d324164a51a43d72c02567248bd9f0f12b244a40",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "11/03/15 2:11 PM",
          "commitNameOld": "fb34f45727e63ea55377fe90241328025307d818",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.93,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,29 @@\n-  void register() throws IOException {\n+  void register(NamespaceInfo nsInfo) throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n     bpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated fields\n         bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n+        bpRegistration.setNamespaceInfo(nsInfo);\n         break;\n       } catch(EOFException e) {  // namenode might have just restarted\n         LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n             + e.getLocalizedMessage());\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n     \n     LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n     // random short delay - helps scatter the BR from all DNs\n     scheduleBlockReport(dnConf.initialBlockReportDelay);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void register(NamespaceInfo nsInfo) throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    bpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated fields\n        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n        bpRegistration.setNamespaceInfo(nsInfo);\n        break;\n      } catch(EOFException e) {  // namenode might have just restarted\n        LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n            + e.getLocalizedMessage());\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduleBlockReport(dnConf.initialBlockReportDelay);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[nsInfo-NamespaceInfo]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7435. PB encoding of block reports is very inefficient. Contributed by Daryn Sharp.\n",
          "commitDate": "13/03/15 12:23 PM",
          "commitName": "d324164a51a43d72c02567248bd9f0f12b244a40",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "11/03/15 2:11 PM",
          "commitNameOld": "fb34f45727e63ea55377fe90241328025307d818",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.93,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,29 @@\n-  void register() throws IOException {\n+  void register(NamespaceInfo nsInfo) throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n     bpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated fields\n         bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n+        bpRegistration.setNamespaceInfo(nsInfo);\n         break;\n       } catch(EOFException e) {  // namenode might have just restarted\n         LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n             + e.getLocalizedMessage());\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n     \n     LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n     // random short delay - helps scatter the BR from all DNs\n     scheduleBlockReport(dnConf.initialBlockReportDelay);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void register(NamespaceInfo nsInfo) throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    bpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated fields\n        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n        bpRegistration.setNamespaceInfo(nsInfo);\n        break;\n      } catch(EOFException e) {  // namenode might have just restarted\n        LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n            + e.getLocalizedMessage());\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduleBlockReport(dnConf.initialBlockReportDelay);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
          "extendedDetails": {}
        }
      ]
    },
    "3d15728ff5301296801e541d9b23bd1687c4adad": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7714. Simultaneous restart of HA NameNodes and DataNode can cause DataNode to register successfully with only one NameNode.(Contributed by Vinayakumar B)\n",
      "commitDate": "09/02/15 9:13 PM",
      "commitName": "3d15728ff5301296801e541d9b23bd1687c4adad",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "21/01/15 7:00 PM",
      "commitNameOld": "6e62a1a6728b1f782f64065424f92b292c3f163a",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 19.09,
      "commitsBetweenForRepo": 172,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,28 @@\n   void register() throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n     bpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated fields\n         bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n         break;\n+      } catch(EOFException e) {  // namenode might have just restarted\n+        LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n+            + e.getLocalizedMessage());\n+        sleepAndLogInterrupts(1000, \"connecting to server\");\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n     \n     LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n     // random short delay - helps scatter the BR from all DNs\n     scheduleBlockReport(dnConf.initialBlockReportDelay);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void register() throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    bpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated fields\n        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n        break;\n      } catch(EOFException e) {  // namenode might have just restarted\n        LOG.info(\"Problem connecting to server: \" + nnAddr + \" :\"\n            + e.getLocalizedMessage());\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduleBlockReport(dnConf.initialBlockReportDelay);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "0663dbaac0a19719ddf9cd4290ba893bfca69da2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3171. The DatanodeID \"name\" field is overloaded. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308014 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/03/12 8:41 PM",
      "commitName": "0663dbaac0a19719ddf9cd4290ba893bfca69da2",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "21/03/12 2:07 AM",
      "commitNameOld": "9e108e61fb28244326d7cf4bb31d175eb75d2636",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 10.77,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,24 @@\n   void register() throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n     bpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n-        // Use returned registration from namenode with updated machine name.\n+        // Use returned registration from namenode with updated fields\n         bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n         break;\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n     \n     LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n     // random short delay - helps scatter the BR from all DNs\n     scheduleBlockReport(dnConf.initialBlockReportDelay);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void register() throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    bpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated fields\n        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n        break;\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduleBlockReport(dnConf.initialBlockReportDelay);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "9e108e61fb28244326d7cf4bb31d175eb75d2636": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3086. Change Datanode not to send storage list in registration.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1303318 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/12 2:07 AM",
      "commitName": "9e108e61fb28244326d7cf4bb31d175eb75d2636",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "28/02/12 5:09 PM",
      "commitNameOld": "978a8050e28b2afb193a3e00d82a8475fa4d2428",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 21.33,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,24 @@\n   void register() throws IOException {\n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n     bpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated machine name.\n-        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration,\n-            new DatanodeStorage[0]);\n+        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n         break;\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n     \n     LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n     bpos.registrationSucceeded(this, bpRegistration);\n \n     // random short delay - helps scatter the BR from all DNs\n     scheduleBlockReport(dnConf.initialBlockReportDelay);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void register() throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    bpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated machine name.\n        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n        break;\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduleBlockReport(dnConf.initialBlockReportDelay);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "1e346aa829519f8a2aa830e76d9856f914861805": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "HDFS-1971. Send block report from datanode to both active and standby namenodes. (sanjay, todd via suresh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208925 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/11 5:10 PM",
      "commitName": "1e346aa829519f8a2aa830e76d9856f914861805",
      "commitAuthor": "Suresh Srinivas",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-1971. Send block report from datanode to both active and standby namenodes. (sanjay, todd via suresh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208925 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/11/11 5:10 PM",
          "commitName": "1e346aa829519f8a2aa830e76d9856f914861805",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "30/11/11 1:46 PM",
          "commitNameOld": "f87a4b40bc99e76602a75906df31747cfdbff78a",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,24 @@\n   void register() throws IOException {\n-    Preconditions.checkState(bpNSInfo !\u003d null,\n-        \"register() should be called after handshake()\");\n-    \n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n-    bpRegistration \u003d dn.createBPRegistration(bpNSInfo);\n+    bpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated machine name.\n         bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n         break;\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n     \n     LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n-    dn.bpRegistrationSucceeded(bpRegistration, getBlockPoolId());\n+    bpos.registrationSucceeded(this, bpRegistration);\n \n     // random short delay - helps scatter the BR from all DNs\n     scheduleBlockReport(dnConf.initialBlockReportDelay);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void register() throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    bpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated machine name.\n        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n        break;\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduleBlockReport(dnConf.initialBlockReportDelay);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPOfferService.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
            "oldMethodName": "register",
            "newMethodName": "register"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-1971. Send block report from datanode to both active and standby namenodes. (sanjay, todd via suresh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208925 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/11/11 5:10 PM",
          "commitName": "1e346aa829519f8a2aa830e76d9856f914861805",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "30/11/11 1:46 PM",
          "commitNameOld": "f87a4b40bc99e76602a75906df31747cfdbff78a",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,24 @@\n   void register() throws IOException {\n-    Preconditions.checkState(bpNSInfo !\u003d null,\n-        \"register() should be called after handshake()\");\n-    \n     // The handshake() phase loaded the block pool storage\n     // off disk - so update the bpRegistration object from that info\n-    bpRegistration \u003d dn.createBPRegistration(bpNSInfo);\n+    bpRegistration \u003d bpos.createRegistration();\n \n     LOG.info(this + \" beginning handshake with NN\");\n \n     while (shouldRun()) {\n       try {\n         // Use returned registration from namenode with updated machine name.\n         bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n         break;\n       } catch(SocketTimeoutException e) {  // namenode is busy\n         LOG.info(\"Problem connecting to server: \" + nnAddr);\n         sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n     }\n     \n     LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n-    dn.bpRegistrationSucceeded(bpRegistration, getBlockPoolId());\n+    bpos.registrationSucceeded(this, bpRegistration);\n \n     // random short delay - helps scatter the BR from all DNs\n     scheduleBlockReport(dnConf.initialBlockReportDelay);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void register() throws IOException {\n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    bpRegistration \u003d bpos.createRegistration();\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated machine name.\n        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n        break;\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    bpos.registrationSucceeded(this, bpRegistration);\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduleBlockReport(dnConf.initialBlockReportDelay);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
          "extendedDetails": {}
        }
      ]
    },
    "39ce694d05c6d8c428bd87bc1b9c95f94dfdf6fd": {
      "type": "Ymovefromfile",
      "commitMessage": "HDFS-2566. Move BPOfferService to be a non-inner class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1204659 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/11/11 11:27 AM",
      "commitName": "39ce694d05c6d8c428bd87bc1b9c95f94dfdf6fd",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "21/11/11 11:03 AM",
      "commitNameOld": "68173af69d2fbda3292404c90a5077483e14d6f4",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n-    void register() throws IOException {\n-      Preconditions.checkState(bpNSInfo !\u003d null,\n-          \"register() should be called after handshake()\");\n-      \n-      // The handshake() phase loaded the block pool storage\n-      // off disk - so update the bpRegistration object from that info\n-      bpRegistration \u003d dn.createBPRegistration(bpNSInfo);\n+  void register() throws IOException {\n+    Preconditions.checkState(bpNSInfo !\u003d null,\n+        \"register() should be called after handshake()\");\n+    \n+    // The handshake() phase loaded the block pool storage\n+    // off disk - so update the bpRegistration object from that info\n+    bpRegistration \u003d dn.createBPRegistration(bpNSInfo);\n \n-      LOG.info(this + \" beginning handshake with NN\");\n+    LOG.info(this + \" beginning handshake with NN\");\n \n-      while (shouldRun()) {\n-        try {\n-          // Use returned registration from namenode with updated machine name.\n-          bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n-          break;\n-        } catch(SocketTimeoutException e) {  // namenode is busy\n-          LOG.info(\"Problem connecting to server: \" + nnAddr);\n-          sleepAndLogInterrupts(1000, \"connecting to server\");\n-        }\n+    while (shouldRun()) {\n+      try {\n+        // Use returned registration from namenode with updated machine name.\n+        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n+        break;\n+      } catch(SocketTimeoutException e) {  // namenode is busy\n+        LOG.info(\"Problem connecting to server: \" + nnAddr);\n+        sleepAndLogInterrupts(1000, \"connecting to server\");\n       }\n-      \n-      LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n-      dn.bpRegistrationSucceeded(bpRegistration, getBlockPoolId());\n+    }\n+    \n+    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n+    dn.bpRegistrationSucceeded(bpRegistration, getBlockPoolId());\n \n-      // random short delay - helps scatter the BR from all DNs\n-      scheduleBlockReport(dnConf.initialBlockReportDelay);\n-    }\n\\ No newline at end of file\n+    // random short delay - helps scatter the BR from all DNs\n+    scheduleBlockReport(dnConf.initialBlockReportDelay);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void register() throws IOException {\n    Preconditions.checkState(bpNSInfo !\u003d null,\n        \"register() should be called after handshake()\");\n    \n    // The handshake() phase loaded the block pool storage\n    // off disk - so update the bpRegistration object from that info\n    bpRegistration \u003d dn.createBPRegistration(bpNSInfo);\n\n    LOG.info(this + \" beginning handshake with NN\");\n\n    while (shouldRun()) {\n      try {\n        // Use returned registration from namenode with updated machine name.\n        bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n        break;\n      } catch(SocketTimeoutException e) {  // namenode is busy\n        LOG.info(\"Problem connecting to server: \" + nnAddr);\n        sleepAndLogInterrupts(1000, \"connecting to server\");\n      }\n    }\n    \n    LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n    dn.bpRegistrationSucceeded(bpRegistration, getBlockPoolId());\n\n    // random short delay - helps scatter the BR from all DNs\n    scheduleBlockReport(dnConf.initialBlockReportDelay);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPOfferService.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPOfferService.java",
        "oldMethodName": "register",
        "newMethodName": "register"
      }
    },
    "1f92266516c882e43fa453b876dd8ca09893c477": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2563. Some cleanup in BPOfferService. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1203943 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/11 5:31 PM",
      "commitName": "1f92266516c882e43fa453b876dd8ca09893c477",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "18/11/11 1:04 AM",
      "commitNameOld": "905a127850d5e0cba85c2e075f989fa0f5cf129a",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,27 @@\n     void register() throws IOException {\n-      LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n-          + bpRegistration.storageInfo); \n+      Preconditions.checkState(bpNSInfo !\u003d null,\n+          \"register() should be called after handshake()\");\n+      \n+      // The handshake() phase loaded the block pool storage\n+      // off disk - so update the bpRegistration object from that info\n+      bpRegistration \u003d dn.createBPRegistration(bpNSInfo);\n \n-      // build and layout versions should match\n-      String nsBuildVer \u003d bpNamenode.versionRequest().getBuildVersion();\n-      String stBuildVer \u003d Storage.getBuildVersion();\n+      LOG.info(this + \" beginning handshake with NN\");\n \n-      if (!nsBuildVer.equals(stBuildVer)) {\n-        LOG.warn(\"Data-node and name-node Build versions must be \" +\n-          \"the same. Namenode build version: \" + nsBuildVer + \"Datanode \" +\n-          \"build version: \" + stBuildVer);\n-        throw new IncorrectVersionException(nsBuildVer, \"namenode\", stBuildVer);\n-      }\n-\n-      if (HdfsConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n-        LOG.warn(\"Data-node and name-node layout versions must be \" +\n-          \"the same. Expected: \"+ HdfsConstants.LAYOUT_VERSION +\n-          \" actual \"+ bpNSInfo.getLayoutVersion());\n-        throw new IncorrectVersionException\n-          (bpNSInfo.getLayoutVersion(), \"namenode\");\n-      }\n-\n-      while(dn.shouldRun \u0026\u0026 shouldServiceRun) {\n+      while (shouldRun()) {\n         try {\n           // Use returned registration from namenode with updated machine name.\n           bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n-\n-          LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n-              \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n-\n           break;\n         } catch(SocketTimeoutException e) {  // namenode is busy\n           LOG.info(\"Problem connecting to server: \" + nnAddr);\n-          try {\n-            Thread.sleep(1000);\n-          } catch (InterruptedException ie) {}\n+          sleepAndLogInterrupts(1000, \"connecting to server\");\n         }\n       }\n       \n-      dn.bpRegistrationSucceeded(bpRegistration, blockPoolId);\n-\n-      LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n+      LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n+      dn.bpRegistrationSucceeded(bpRegistration, getBlockPoolId());\n \n       // random short delay - helps scatter the BR from all DNs\n       scheduleBlockReport(dnConf.initialBlockReportDelay);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void register() throws IOException {\n      Preconditions.checkState(bpNSInfo !\u003d null,\n          \"register() should be called after handshake()\");\n      \n      // The handshake() phase loaded the block pool storage\n      // off disk - so update the bpRegistration object from that info\n      bpRegistration \u003d dn.createBPRegistration(bpNSInfo);\n\n      LOG.info(this + \" beginning handshake with NN\");\n\n      while (shouldRun()) {\n        try {\n          // Use returned registration from namenode with updated machine name.\n          bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n          break;\n        } catch(SocketTimeoutException e) {  // namenode is busy\n          LOG.info(\"Problem connecting to server: \" + nnAddr);\n          sleepAndLogInterrupts(1000, \"connecting to server\");\n        }\n      }\n      \n      LOG.info(\"Block pool \" + this + \" successfully registered with NN\");\n      dn.bpRegistrationSucceeded(bpRegistration, getBlockPoolId());\n\n      // random short delay - helps scatter the BR from all DNs\n      scheduleBlockReport(dnConf.initialBlockReportDelay);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "905a127850d5e0cba85c2e075f989fa0f5cf129a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2562. Refactor DN configuration variables out of DataNode class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1203543 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/11 1:04 AM",
      "commitName": "905a127850d5e0cba85c2e075f989fa0f5cf129a",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "17/11/11 4:45 PM",
      "commitNameOld": "0864ef19089f703232107d8aa26c4a7571ff132e",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.35,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n     void register() throws IOException {\n       LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n           + bpRegistration.storageInfo); \n \n       // build and layout versions should match\n       String nsBuildVer \u003d bpNamenode.versionRequest().getBuildVersion();\n       String stBuildVer \u003d Storage.getBuildVersion();\n \n       if (!nsBuildVer.equals(stBuildVer)) {\n         LOG.warn(\"Data-node and name-node Build versions must be \" +\n           \"the same. Namenode build version: \" + nsBuildVer + \"Datanode \" +\n           \"build version: \" + stBuildVer);\n         throw new IncorrectVersionException(nsBuildVer, \"namenode\", stBuildVer);\n       }\n \n       if (HdfsConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n         LOG.warn(\"Data-node and name-node layout versions must be \" +\n           \"the same. Expected: \"+ HdfsConstants.LAYOUT_VERSION +\n           \" actual \"+ bpNSInfo.getLayoutVersion());\n         throw new IncorrectVersionException\n           (bpNSInfo.getLayoutVersion(), \"namenode\");\n       }\n \n       while(dn.shouldRun \u0026\u0026 shouldServiceRun) {\n         try {\n           // Use returned registration from namenode with updated machine name.\n           bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n \n           LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n               \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n \n           break;\n         } catch(SocketTimeoutException e) {  // namenode is busy\n           LOG.info(\"Problem connecting to server: \" + nnAddr);\n           try {\n             Thread.sleep(1000);\n           } catch (InterruptedException ie) {}\n         }\n       }\n       \n       dn.bpRegistrationSucceeded(bpRegistration, blockPoolId);\n \n       LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n \n       // random short delay - helps scatter the BR from all DNs\n-      scheduleBlockReport(dn.initialBlockReportDelay);\n+      scheduleBlockReport(dnConf.initialBlockReportDelay);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void register() throws IOException {\n      LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n          + bpRegistration.storageInfo); \n\n      // build and layout versions should match\n      String nsBuildVer \u003d bpNamenode.versionRequest().getBuildVersion();\n      String stBuildVer \u003d Storage.getBuildVersion();\n\n      if (!nsBuildVer.equals(stBuildVer)) {\n        LOG.warn(\"Data-node and name-node Build versions must be \" +\n          \"the same. Namenode build version: \" + nsBuildVer + \"Datanode \" +\n          \"build version: \" + stBuildVer);\n        throw new IncorrectVersionException(nsBuildVer, \"namenode\", stBuildVer);\n      }\n\n      if (HdfsConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n        LOG.warn(\"Data-node and name-node layout versions must be \" +\n          \"the same. Expected: \"+ HdfsConstants.LAYOUT_VERSION +\n          \" actual \"+ bpNSInfo.getLayoutVersion());\n        throw new IncorrectVersionException\n          (bpNSInfo.getLayoutVersion(), \"namenode\");\n      }\n\n      while(dn.shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          // Use returned registration from namenode with updated machine name.\n          bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n\n          LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n              \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n\n          break;\n        } catch(SocketTimeoutException e) {  // namenode is busy\n          LOG.info(\"Problem connecting to server: \" + nnAddr);\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException ie) {}\n        }\n      }\n      \n      dn.bpRegistrationSucceeded(bpRegistration, blockPoolId);\n\n      LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n\n      // random short delay - helps scatter the BR from all DNs\n      scheduleBlockReport(dnConf.initialBlockReportDelay);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "0864ef19089f703232107d8aa26c4a7571ff132e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2560. Refactor BPOfferService to be a static inner class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1203444 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/11/11 4:45 PM",
      "commitName": "0864ef19089f703232107d8aa26c4a7571ff132e",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "31/10/11 10:17 PM",
      "commitNameOld": "1c940637b14eee777a65d153d0d712a1aea3866c",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 16.81,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,47 @@\n     void register() throws IOException {\n       LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n           + bpRegistration.storageInfo); \n \n       // build and layout versions should match\n       String nsBuildVer \u003d bpNamenode.versionRequest().getBuildVersion();\n       String stBuildVer \u003d Storage.getBuildVersion();\n \n       if (!nsBuildVer.equals(stBuildVer)) {\n         LOG.warn(\"Data-node and name-node Build versions must be \" +\n           \"the same. Namenode build version: \" + nsBuildVer + \"Datanode \" +\n           \"build version: \" + stBuildVer);\n         throw new IncorrectVersionException(nsBuildVer, \"namenode\", stBuildVer);\n       }\n \n       if (HdfsConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n         LOG.warn(\"Data-node and name-node layout versions must be \" +\n           \"the same. Expected: \"+ HdfsConstants.LAYOUT_VERSION +\n           \" actual \"+ bpNSInfo.getLayoutVersion());\n         throw new IncorrectVersionException\n           (bpNSInfo.getLayoutVersion(), \"namenode\");\n       }\n \n-      while(shouldRun \u0026\u0026 shouldServiceRun) {\n+      while(dn.shouldRun \u0026\u0026 shouldServiceRun) {\n         try {\n           // Use returned registration from namenode with updated machine name.\n           bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n \n           LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n               \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n \n-          NetUtils.getHostname();\n-          hostName \u003d bpRegistration.getHost();\n           break;\n         } catch(SocketTimeoutException e) {  // namenode is busy\n           LOG.info(\"Problem connecting to server: \" + nnAddr);\n           try {\n             Thread.sleep(1000);\n           } catch (InterruptedException ie) {}\n         }\n       }\n-\n-      if (storage.getStorageID().equals(\"\")) {\n-        storage.setStorageID(bpRegistration.getStorageID());\n-        storage.writeAll();\n-        LOG.info(\"New storage id \" + bpRegistration.getStorageID()\n-            + \" is assigned to data-node \" + bpRegistration.getName());\n-      } else if(!storage.getStorageID().equals(bpRegistration.getStorageID())) {\n-        throw new IOException(\"Inconsistent storage IDs. Name-node returned \"\n-            + bpRegistration.getStorageID() \n-            + \". Expecting \" + storage.getStorageID());\n-      }\n-\n-      if (!isBlockTokenInitialized) {\n-        /* first time registering with NN */\n-        ExportedBlockKeys keys \u003d bpRegistration.exportedKeys;\n-        isBlockTokenEnabled \u003d keys.isBlockTokenEnabled();\n-        if (isBlockTokenEnabled) {\n-          long blockKeyUpdateInterval \u003d keys.getKeyUpdateInterval();\n-          long blockTokenLifetime \u003d keys.getTokenLifetime();\n-          LOG.info(\"Block token params received from NN: for block pool \" +\n-              blockPoolId + \" keyUpdateInterval\u003d\"\n-              + blockKeyUpdateInterval / (60 * 1000)\n-              + \" min(s), tokenLifetime\u003d\" + blockTokenLifetime / (60 * 1000)\n-              + \" min(s)\");\n-          final BlockTokenSecretManager secretMgr \u003d \n-            new BlockTokenSecretManager(false, 0, blockTokenLifetime);\n-          blockPoolTokenSecretManager.addBlockPool(blockPoolId, secretMgr);\n-        }\n-        isBlockTokenInitialized \u003d true;\n-      }\n-\n-      if (isBlockTokenEnabled) {\n-        blockPoolTokenSecretManager.setKeys(blockPoolId,\n-            bpRegistration.exportedKeys);\n-        bpRegistration.exportedKeys \u003d ExportedBlockKeys.DUMMY_KEYS;\n-      }\n+      \n+      dn.bpRegistrationSucceeded(bpRegistration, blockPoolId);\n \n       LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n \n       // random short delay - helps scatter the BR from all DNs\n-      scheduleBlockReport(initialBlockReportDelay);\n+      scheduleBlockReport(dn.initialBlockReportDelay);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void register() throws IOException {\n      LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n          + bpRegistration.storageInfo); \n\n      // build and layout versions should match\n      String nsBuildVer \u003d bpNamenode.versionRequest().getBuildVersion();\n      String stBuildVer \u003d Storage.getBuildVersion();\n\n      if (!nsBuildVer.equals(stBuildVer)) {\n        LOG.warn(\"Data-node and name-node Build versions must be \" +\n          \"the same. Namenode build version: \" + nsBuildVer + \"Datanode \" +\n          \"build version: \" + stBuildVer);\n        throw new IncorrectVersionException(nsBuildVer, \"namenode\", stBuildVer);\n      }\n\n      if (HdfsConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n        LOG.warn(\"Data-node and name-node layout versions must be \" +\n          \"the same. Expected: \"+ HdfsConstants.LAYOUT_VERSION +\n          \" actual \"+ bpNSInfo.getLayoutVersion());\n        throw new IncorrectVersionException\n          (bpNSInfo.getLayoutVersion(), \"namenode\");\n      }\n\n      while(dn.shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          // Use returned registration from namenode with updated machine name.\n          bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n\n          LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n              \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n\n          break;\n        } catch(SocketTimeoutException e) {  // namenode is busy\n          LOG.info(\"Problem connecting to server: \" + nnAddr);\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException ie) {}\n        }\n      }\n      \n      dn.bpRegistrationSucceeded(bpRegistration, blockPoolId);\n\n      LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n\n      // random short delay - helps scatter the BR from all DNs\n      scheduleBlockReport(dn.initialBlockReportDelay);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1620. Rename HdfsConstants -\u003e HdfsServerConstants, FSConstants -\u003e HdfsConstants. (Harsh J Chouraria via atm)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165096 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/11 12:30 PM",
      "commitName": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "25/08/11 9:46 PM",
      "commitNameOld": "73451ed2d9fb5eb228d80ad5f3be302a60496527",
      "commitAuthorOld": "Hairong Kuang",
      "daysBetweenCommits": 9.61,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,83 @@\n     void register() throws IOException {\n       LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n           + bpRegistration.storageInfo); \n \n       // build and layout versions should match\n       String nsBuildVer \u003d bpNamenode.versionRequest().getBuildVersion();\n       String stBuildVer \u003d Storage.getBuildVersion();\n \n       if (!nsBuildVer.equals(stBuildVer)) {\n         LOG.warn(\"Data-node and name-node Build versions must be \" +\n           \"the same. Namenode build version: \" + nsBuildVer + \"Datanode \" +\n           \"build version: \" + stBuildVer);\n         throw new IncorrectVersionException(nsBuildVer, \"namenode\", stBuildVer);\n       }\n \n-      if (FSConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n+      if (HdfsConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n         LOG.warn(\"Data-node and name-node layout versions must be \" +\n-          \"the same. Expected: \"+ FSConstants.LAYOUT_VERSION +\n+          \"the same. Expected: \"+ HdfsConstants.LAYOUT_VERSION +\n           \" actual \"+ bpNSInfo.getLayoutVersion());\n         throw new IncorrectVersionException\n           (bpNSInfo.getLayoutVersion(), \"namenode\");\n       }\n \n       while(shouldRun \u0026\u0026 shouldServiceRun) {\n         try {\n           // Use returned registration from namenode with updated machine name.\n           bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n \n           LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n               \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n \n           NetUtils.getHostname();\n           hostName \u003d bpRegistration.getHost();\n           break;\n         } catch(SocketTimeoutException e) {  // namenode is busy\n           LOG.info(\"Problem connecting to server: \" + nnAddr);\n           try {\n             Thread.sleep(1000);\n           } catch (InterruptedException ie) {}\n         }\n       }\n \n       if (storage.getStorageID().equals(\"\")) {\n         storage.setStorageID(bpRegistration.getStorageID());\n         storage.writeAll();\n         LOG.info(\"New storage id \" + bpRegistration.getStorageID()\n             + \" is assigned to data-node \" + bpRegistration.getName());\n       } else if(!storage.getStorageID().equals(bpRegistration.getStorageID())) {\n         throw new IOException(\"Inconsistent storage IDs. Name-node returned \"\n             + bpRegistration.getStorageID() \n             + \". Expecting \" + storage.getStorageID());\n       }\n \n       if (!isBlockTokenInitialized) {\n         /* first time registering with NN */\n         ExportedBlockKeys keys \u003d bpRegistration.exportedKeys;\n         isBlockTokenEnabled \u003d keys.isBlockTokenEnabled();\n         if (isBlockTokenEnabled) {\n           long blockKeyUpdateInterval \u003d keys.getKeyUpdateInterval();\n           long blockTokenLifetime \u003d keys.getTokenLifetime();\n           LOG.info(\"Block token params received from NN: for block pool \" +\n               blockPoolId + \" keyUpdateInterval\u003d\"\n               + blockKeyUpdateInterval / (60 * 1000)\n               + \" min(s), tokenLifetime\u003d\" + blockTokenLifetime / (60 * 1000)\n               + \" min(s)\");\n           final BlockTokenSecretManager secretMgr \u003d \n             new BlockTokenSecretManager(false, 0, blockTokenLifetime);\n           blockPoolTokenSecretManager.addBlockPool(blockPoolId, secretMgr);\n         }\n         isBlockTokenInitialized \u003d true;\n       }\n \n       if (isBlockTokenEnabled) {\n         blockPoolTokenSecretManager.setKeys(blockPoolId,\n             bpRegistration.exportedKeys);\n         bpRegistration.exportedKeys \u003d ExportedBlockKeys.DUMMY_KEYS;\n       }\n \n       LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n \n       // random short delay - helps scatter the BR from all DNs\n       scheduleBlockReport(initialBlockReportDelay);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void register() throws IOException {\n      LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n          + bpRegistration.storageInfo); \n\n      // build and layout versions should match\n      String nsBuildVer \u003d bpNamenode.versionRequest().getBuildVersion();\n      String stBuildVer \u003d Storage.getBuildVersion();\n\n      if (!nsBuildVer.equals(stBuildVer)) {\n        LOG.warn(\"Data-node and name-node Build versions must be \" +\n          \"the same. Namenode build version: \" + nsBuildVer + \"Datanode \" +\n          \"build version: \" + stBuildVer);\n        throw new IncorrectVersionException(nsBuildVer, \"namenode\", stBuildVer);\n      }\n\n      if (HdfsConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n        LOG.warn(\"Data-node and name-node layout versions must be \" +\n          \"the same. Expected: \"+ HdfsConstants.LAYOUT_VERSION +\n          \" actual \"+ bpNSInfo.getLayoutVersion());\n        throw new IncorrectVersionException\n          (bpNSInfo.getLayoutVersion(), \"namenode\");\n      }\n\n      while(shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          // Use returned registration from namenode with updated machine name.\n          bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n\n          LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n              \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n\n          NetUtils.getHostname();\n          hostName \u003d bpRegistration.getHost();\n          break;\n        } catch(SocketTimeoutException e) {  // namenode is busy\n          LOG.info(\"Problem connecting to server: \" + nnAddr);\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException ie) {}\n        }\n      }\n\n      if (storage.getStorageID().equals(\"\")) {\n        storage.setStorageID(bpRegistration.getStorageID());\n        storage.writeAll();\n        LOG.info(\"New storage id \" + bpRegistration.getStorageID()\n            + \" is assigned to data-node \" + bpRegistration.getName());\n      } else if(!storage.getStorageID().equals(bpRegistration.getStorageID())) {\n        throw new IOException(\"Inconsistent storage IDs. Name-node returned \"\n            + bpRegistration.getStorageID() \n            + \". Expecting \" + storage.getStorageID());\n      }\n\n      if (!isBlockTokenInitialized) {\n        /* first time registering with NN */\n        ExportedBlockKeys keys \u003d bpRegistration.exportedKeys;\n        isBlockTokenEnabled \u003d keys.isBlockTokenEnabled();\n        if (isBlockTokenEnabled) {\n          long blockKeyUpdateInterval \u003d keys.getKeyUpdateInterval();\n          long blockTokenLifetime \u003d keys.getTokenLifetime();\n          LOG.info(\"Block token params received from NN: for block pool \" +\n              blockPoolId + \" keyUpdateInterval\u003d\"\n              + blockKeyUpdateInterval / (60 * 1000)\n              + \" min(s), tokenLifetime\u003d\" + blockTokenLifetime / (60 * 1000)\n              + \" min(s)\");\n          final BlockTokenSecretManager secretMgr \u003d \n            new BlockTokenSecretManager(false, 0, blockTokenLifetime);\n          blockPoolTokenSecretManager.addBlockPool(blockPoolId, secretMgr);\n        }\n        isBlockTokenInitialized \u003d true;\n      }\n\n      if (isBlockTokenEnabled) {\n        blockPoolTokenSecretManager.setKeys(blockPoolId,\n            bpRegistration.exportedKeys);\n        bpRegistration.exportedKeys \u003d ExportedBlockKeys.DUMMY_KEYS;\n      }\n\n      LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n\n      // random short delay - helps scatter the BR from all DNs\n      scheduleBlockReport(initialBlockReportDelay);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    void register() throws IOException {\n      LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n          + bpRegistration.storageInfo); \n\n      // build and layout versions should match\n      String nsBuildVer \u003d bpNamenode.versionRequest().getBuildVersion();\n      String stBuildVer \u003d Storage.getBuildVersion();\n\n      if (!nsBuildVer.equals(stBuildVer)) {\n        LOG.warn(\"Data-node and name-node Build versions must be \" +\n          \"the same. Namenode build version: \" + nsBuildVer + \"Datanode \" +\n          \"build version: \" + stBuildVer);\n        throw new IncorrectVersionException(nsBuildVer, \"namenode\", stBuildVer);\n      }\n\n      if (FSConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n        LOG.warn(\"Data-node and name-node layout versions must be \" +\n          \"the same. Expected: \"+ FSConstants.LAYOUT_VERSION +\n          \" actual \"+ bpNSInfo.getLayoutVersion());\n        throw new IncorrectVersionException\n          (bpNSInfo.getLayoutVersion(), \"namenode\");\n      }\n\n      while(shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          // Use returned registration from namenode with updated machine name.\n          bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n\n          LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n              \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n\n          NetUtils.getHostname();\n          hostName \u003d bpRegistration.getHost();\n          break;\n        } catch(SocketTimeoutException e) {  // namenode is busy\n          LOG.info(\"Problem connecting to server: \" + nnAddr);\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException ie) {}\n        }\n      }\n\n      if (storage.getStorageID().equals(\"\")) {\n        storage.setStorageID(bpRegistration.getStorageID());\n        storage.writeAll();\n        LOG.info(\"New storage id \" + bpRegistration.getStorageID()\n            + \" is assigned to data-node \" + bpRegistration.getName());\n      } else if(!storage.getStorageID().equals(bpRegistration.getStorageID())) {\n        throw new IOException(\"Inconsistent storage IDs. Name-node returned \"\n            + bpRegistration.getStorageID() \n            + \". Expecting \" + storage.getStorageID());\n      }\n\n      if (!isBlockTokenInitialized) {\n        /* first time registering with NN */\n        ExportedBlockKeys keys \u003d bpRegistration.exportedKeys;\n        isBlockTokenEnabled \u003d keys.isBlockTokenEnabled();\n        if (isBlockTokenEnabled) {\n          long blockKeyUpdateInterval \u003d keys.getKeyUpdateInterval();\n          long blockTokenLifetime \u003d keys.getTokenLifetime();\n          LOG.info(\"Block token params received from NN: for block pool \" +\n              blockPoolId + \" keyUpdateInterval\u003d\"\n              + blockKeyUpdateInterval / (60 * 1000)\n              + \" min(s), tokenLifetime\u003d\" + blockTokenLifetime / (60 * 1000)\n              + \" min(s)\");\n          final BlockTokenSecretManager secretMgr \u003d \n            new BlockTokenSecretManager(false, 0, blockTokenLifetime);\n          blockPoolTokenSecretManager.addBlockPool(blockPoolId, secretMgr);\n        }\n        isBlockTokenInitialized \u003d true;\n      }\n\n      if (isBlockTokenEnabled) {\n        blockPoolTokenSecretManager.setKeys(blockPoolId,\n            bpRegistration.exportedKeys);\n        bpRegistration.exportedKeys \u003d ExportedBlockKeys.DUMMY_KEYS;\n      }\n\n      LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n\n      // random short delay - helps scatter the BR from all DNs\n      scheduleBlockReport(initialBlockReportDelay);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    void register() throws IOException {\n      LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n          + bpRegistration.storageInfo); \n\n      // build and layout versions should match\n      String nsBuildVer \u003d bpNamenode.versionRequest().getBuildVersion();\n      String stBuildVer \u003d Storage.getBuildVersion();\n\n      if (!nsBuildVer.equals(stBuildVer)) {\n        LOG.warn(\"Data-node and name-node Build versions must be \" +\n          \"the same. Namenode build version: \" + nsBuildVer + \"Datanode \" +\n          \"build version: \" + stBuildVer);\n        throw new IncorrectVersionException(nsBuildVer, \"namenode\", stBuildVer);\n      }\n\n      if (FSConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n        LOG.warn(\"Data-node and name-node layout versions must be \" +\n          \"the same. Expected: \"+ FSConstants.LAYOUT_VERSION +\n          \" actual \"+ bpNSInfo.getLayoutVersion());\n        throw new IncorrectVersionException\n          (bpNSInfo.getLayoutVersion(), \"namenode\");\n      }\n\n      while(shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          // Use returned registration from namenode with updated machine name.\n          bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n\n          LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n              \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n\n          NetUtils.getHostname();\n          hostName \u003d bpRegistration.getHost();\n          break;\n        } catch(SocketTimeoutException e) {  // namenode is busy\n          LOG.info(\"Problem connecting to server: \" + nnAddr);\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException ie) {}\n        }\n      }\n\n      if (storage.getStorageID().equals(\"\")) {\n        storage.setStorageID(bpRegistration.getStorageID());\n        storage.writeAll();\n        LOG.info(\"New storage id \" + bpRegistration.getStorageID()\n            + \" is assigned to data-node \" + bpRegistration.getName());\n      } else if(!storage.getStorageID().equals(bpRegistration.getStorageID())) {\n        throw new IOException(\"Inconsistent storage IDs. Name-node returned \"\n            + bpRegistration.getStorageID() \n            + \". Expecting \" + storage.getStorageID());\n      }\n\n      if (!isBlockTokenInitialized) {\n        /* first time registering with NN */\n        ExportedBlockKeys keys \u003d bpRegistration.exportedKeys;\n        isBlockTokenEnabled \u003d keys.isBlockTokenEnabled();\n        if (isBlockTokenEnabled) {\n          long blockKeyUpdateInterval \u003d keys.getKeyUpdateInterval();\n          long blockTokenLifetime \u003d keys.getTokenLifetime();\n          LOG.info(\"Block token params received from NN: for block pool \" +\n              blockPoolId + \" keyUpdateInterval\u003d\"\n              + blockKeyUpdateInterval / (60 * 1000)\n              + \" min(s), tokenLifetime\u003d\" + blockTokenLifetime / (60 * 1000)\n              + \" min(s)\");\n          final BlockTokenSecretManager secretMgr \u003d \n            new BlockTokenSecretManager(false, 0, blockTokenLifetime);\n          blockPoolTokenSecretManager.addBlockPool(blockPoolId, secretMgr);\n        }\n        isBlockTokenInitialized \u003d true;\n      }\n\n      if (isBlockTokenEnabled) {\n        blockPoolTokenSecretManager.setKeys(blockPoolId,\n            bpRegistration.exportedKeys);\n        bpRegistration.exportedKeys \u003d ExportedBlockKeys.DUMMY_KEYS;\n      }\n\n      LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n\n      // random short delay - helps scatter the BR from all DNs\n      scheduleBlockReport(initialBlockReportDelay);\n    }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
      }
    },
    "c54c117407bc441b539b8acfdb022586f17dafc1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2120. on reconnect, DN can connect to NN even with different source versions. (John George via atm)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1146516 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/07/11 4:44 PM",
      "commitName": "c54c117407bc441b539b8acfdb022586f17dafc1",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "12/07/11 6:11 PM",
      "commitNameOld": "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
      "commitAuthorOld": "Jitendra Nath Pandey",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,83 @@\n     void register() throws IOException {\n       LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n           + bpRegistration.storageInfo); \n-                \n+\n+      // build and layout versions should match\n+      String nsBuildVer \u003d bpNamenode.versionRequest().getBuildVersion();\n+      String stBuildVer \u003d Storage.getBuildVersion();\n+\n+      if (!nsBuildVer.equals(stBuildVer)) {\n+        LOG.warn(\"Data-node and name-node Build versions must be \" +\n+          \"the same. Namenode build version: \" + nsBuildVer + \"Datanode \" +\n+          \"build version: \" + stBuildVer);\n+        throw new IncorrectVersionException(nsBuildVer, \"namenode\", stBuildVer);\n+      }\n+\n+      if (FSConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n+        LOG.warn(\"Data-node and name-node layout versions must be \" +\n+          \"the same. Expected: \"+ FSConstants.LAYOUT_VERSION +\n+          \" actual \"+ bpNSInfo.getLayoutVersion());\n+        throw new IncorrectVersionException\n+          (bpNSInfo.getLayoutVersion(), \"namenode\");\n+      }\n+\n       while(shouldRun \u0026\u0026 shouldServiceRun) {\n         try {\n           // Use returned registration from namenode with updated machine name.\n           bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n \n           LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n               \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n \n           NetUtils.getHostname();\n           hostName \u003d bpRegistration.getHost();\n           break;\n         } catch(SocketTimeoutException e) {  // namenode is busy\n           LOG.info(\"Problem connecting to server: \" + nnAddr);\n           try {\n             Thread.sleep(1000);\n           } catch (InterruptedException ie) {}\n         }\n       }\n \n       if (storage.getStorageID().equals(\"\")) {\n         storage.setStorageID(bpRegistration.getStorageID());\n         storage.writeAll();\n         LOG.info(\"New storage id \" + bpRegistration.getStorageID()\n             + \" is assigned to data-node \" + bpRegistration.getName());\n       } else if(!storage.getStorageID().equals(bpRegistration.getStorageID())) {\n         throw new IOException(\"Inconsistent storage IDs. Name-node returned \"\n             + bpRegistration.getStorageID() \n             + \". Expecting \" + storage.getStorageID());\n       }\n \n       if (!isBlockTokenInitialized) {\n         /* first time registering with NN */\n         ExportedBlockKeys keys \u003d bpRegistration.exportedKeys;\n         isBlockTokenEnabled \u003d keys.isBlockTokenEnabled();\n         if (isBlockTokenEnabled) {\n           long blockKeyUpdateInterval \u003d keys.getKeyUpdateInterval();\n           long blockTokenLifetime \u003d keys.getTokenLifetime();\n           LOG.info(\"Block token params received from NN: for block pool \" +\n               blockPoolId + \" keyUpdateInterval\u003d\"\n               + blockKeyUpdateInterval / (60 * 1000)\n               + \" min(s), tokenLifetime\u003d\" + blockTokenLifetime / (60 * 1000)\n               + \" min(s)\");\n           final BlockTokenSecretManager secretMgr \u003d \n             new BlockTokenSecretManager(false, 0, blockTokenLifetime);\n           blockPoolTokenSecretManager.addBlockPool(blockPoolId, secretMgr);\n         }\n         isBlockTokenInitialized \u003d true;\n       }\n \n       if (isBlockTokenEnabled) {\n         blockPoolTokenSecretManager.setKeys(blockPoolId,\n             bpRegistration.exportedKeys);\n         bpRegistration.exportedKeys \u003d ExportedBlockKeys.DUMMY_KEYS;\n       }\n \n       LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n \n       // random short delay - helps scatter the BR from all DNs\n       scheduleBlockReport(initialBlockReportDelay);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void register() throws IOException {\n      LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n          + bpRegistration.storageInfo); \n\n      // build and layout versions should match\n      String nsBuildVer \u003d bpNamenode.versionRequest().getBuildVersion();\n      String stBuildVer \u003d Storage.getBuildVersion();\n\n      if (!nsBuildVer.equals(stBuildVer)) {\n        LOG.warn(\"Data-node and name-node Build versions must be \" +\n          \"the same. Namenode build version: \" + nsBuildVer + \"Datanode \" +\n          \"build version: \" + stBuildVer);\n        throw new IncorrectVersionException(nsBuildVer, \"namenode\", stBuildVer);\n      }\n\n      if (FSConstants.LAYOUT_VERSION !\u003d bpNSInfo.getLayoutVersion()) {\n        LOG.warn(\"Data-node and name-node layout versions must be \" +\n          \"the same. Expected: \"+ FSConstants.LAYOUT_VERSION +\n          \" actual \"+ bpNSInfo.getLayoutVersion());\n        throw new IncorrectVersionException\n          (bpNSInfo.getLayoutVersion(), \"namenode\");\n      }\n\n      while(shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          // Use returned registration from namenode with updated machine name.\n          bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n\n          LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n              \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n\n          NetUtils.getHostname();\n          hostName \u003d bpRegistration.getHost();\n          break;\n        } catch(SocketTimeoutException e) {  // namenode is busy\n          LOG.info(\"Problem connecting to server: \" + nnAddr);\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException ie) {}\n        }\n      }\n\n      if (storage.getStorageID().equals(\"\")) {\n        storage.setStorageID(bpRegistration.getStorageID());\n        storage.writeAll();\n        LOG.info(\"New storage id \" + bpRegistration.getStorageID()\n            + \" is assigned to data-node \" + bpRegistration.getName());\n      } else if(!storage.getStorageID().equals(bpRegistration.getStorageID())) {\n        throw new IOException(\"Inconsistent storage IDs. Name-node returned \"\n            + bpRegistration.getStorageID() \n            + \". Expecting \" + storage.getStorageID());\n      }\n\n      if (!isBlockTokenInitialized) {\n        /* first time registering with NN */\n        ExportedBlockKeys keys \u003d bpRegistration.exportedKeys;\n        isBlockTokenEnabled \u003d keys.isBlockTokenEnabled();\n        if (isBlockTokenEnabled) {\n          long blockKeyUpdateInterval \u003d keys.getKeyUpdateInterval();\n          long blockTokenLifetime \u003d keys.getTokenLifetime();\n          LOG.info(\"Block token params received from NN: for block pool \" +\n              blockPoolId + \" keyUpdateInterval\u003d\"\n              + blockKeyUpdateInterval / (60 * 1000)\n              + \" min(s), tokenLifetime\u003d\" + blockTokenLifetime / (60 * 1000)\n              + \" min(s)\");\n          final BlockTokenSecretManager secretMgr \u003d \n            new BlockTokenSecretManager(false, 0, blockTokenLifetime);\n          blockPoolTokenSecretManager.addBlockPool(blockPoolId, secretMgr);\n        }\n        isBlockTokenInitialized \u003d true;\n      }\n\n      if (isBlockTokenEnabled) {\n        blockPoolTokenSecretManager.setKeys(blockPoolId,\n            bpRegistration.exportedKeys);\n        bpRegistration.exportedKeys \u003d ExportedBlockKeys.DUMMY_KEYS;\n      }\n\n      LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n\n      // random short delay - helps scatter the BR from all DNs\n      scheduleBlockReport(initialBlockReportDelay);\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,64 @@\n+    void register() throws IOException {\n+      LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n+          + bpRegistration.storageInfo); \n+                \n+      while(shouldRun \u0026\u0026 shouldServiceRun) {\n+        try {\n+          // Use returned registration from namenode with updated machine name.\n+          bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n+\n+          LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n+              \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n+\n+          NetUtils.getHostname();\n+          hostName \u003d bpRegistration.getHost();\n+          break;\n+        } catch(SocketTimeoutException e) {  // namenode is busy\n+          LOG.info(\"Problem connecting to server: \" + nnAddr);\n+          try {\n+            Thread.sleep(1000);\n+          } catch (InterruptedException ie) {}\n+        }\n+      }\n+\n+      if (storage.getStorageID().equals(\"\")) {\n+        storage.setStorageID(bpRegistration.getStorageID());\n+        storage.writeAll();\n+        LOG.info(\"New storage id \" + bpRegistration.getStorageID()\n+            + \" is assigned to data-node \" + bpRegistration.getName());\n+      } else if(!storage.getStorageID().equals(bpRegistration.getStorageID())) {\n+        throw new IOException(\"Inconsistent storage IDs. Name-node returned \"\n+            + bpRegistration.getStorageID() \n+            + \". Expecting \" + storage.getStorageID());\n+      }\n+\n+      if (!isBlockTokenInitialized) {\n+        /* first time registering with NN */\n+        ExportedBlockKeys keys \u003d bpRegistration.exportedKeys;\n+        isBlockTokenEnabled \u003d keys.isBlockTokenEnabled();\n+        if (isBlockTokenEnabled) {\n+          long blockKeyUpdateInterval \u003d keys.getKeyUpdateInterval();\n+          long blockTokenLifetime \u003d keys.getTokenLifetime();\n+          LOG.info(\"Block token params received from NN: for block pool \" +\n+              blockPoolId + \" keyUpdateInterval\u003d\"\n+              + blockKeyUpdateInterval / (60 * 1000)\n+              + \" min(s), tokenLifetime\u003d\" + blockTokenLifetime / (60 * 1000)\n+              + \" min(s)\");\n+          final BlockTokenSecretManager secretMgr \u003d \n+            new BlockTokenSecretManager(false, 0, blockTokenLifetime);\n+          blockPoolTokenSecretManager.addBlockPool(blockPoolId, secretMgr);\n+        }\n+        isBlockTokenInitialized \u003d true;\n+      }\n+\n+      if (isBlockTokenEnabled) {\n+        blockPoolTokenSecretManager.setKeys(blockPoolId,\n+            bpRegistration.exportedKeys);\n+        bpRegistration.exportedKeys \u003d ExportedBlockKeys.DUMMY_KEYS;\n+      }\n+\n+      LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n+\n+      // random short delay - helps scatter the BR from all DNs\n+      scheduleBlockReport(initialBlockReportDelay);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    void register() throws IOException {\n      LOG.info(\"in register: sid\u003d\" + bpRegistration.getStorageID() + \";SI\u003d\"\n          + bpRegistration.storageInfo); \n                \n      while(shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          // Use returned registration from namenode with updated machine name.\n          bpRegistration \u003d bpNamenode.registerDatanode(bpRegistration);\n\n          LOG.info(\"bpReg after \u003d\" + bpRegistration.storageInfo + \n              \";sid\u003d\" + bpRegistration.storageID + \";name\u003d\"+bpRegistration.getName());\n\n          NetUtils.getHostname();\n          hostName \u003d bpRegistration.getHost();\n          break;\n        } catch(SocketTimeoutException e) {  // namenode is busy\n          LOG.info(\"Problem connecting to server: \" + nnAddr);\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException ie) {}\n        }\n      }\n\n      if (storage.getStorageID().equals(\"\")) {\n        storage.setStorageID(bpRegistration.getStorageID());\n        storage.writeAll();\n        LOG.info(\"New storage id \" + bpRegistration.getStorageID()\n            + \" is assigned to data-node \" + bpRegistration.getName());\n      } else if(!storage.getStorageID().equals(bpRegistration.getStorageID())) {\n        throw new IOException(\"Inconsistent storage IDs. Name-node returned \"\n            + bpRegistration.getStorageID() \n            + \". Expecting \" + storage.getStorageID());\n      }\n\n      if (!isBlockTokenInitialized) {\n        /* first time registering with NN */\n        ExportedBlockKeys keys \u003d bpRegistration.exportedKeys;\n        isBlockTokenEnabled \u003d keys.isBlockTokenEnabled();\n        if (isBlockTokenEnabled) {\n          long blockKeyUpdateInterval \u003d keys.getKeyUpdateInterval();\n          long blockTokenLifetime \u003d keys.getTokenLifetime();\n          LOG.info(\"Block token params received from NN: for block pool \" +\n              blockPoolId + \" keyUpdateInterval\u003d\"\n              + blockKeyUpdateInterval / (60 * 1000)\n              + \" min(s), tokenLifetime\u003d\" + blockTokenLifetime / (60 * 1000)\n              + \" min(s)\");\n          final BlockTokenSecretManager secretMgr \u003d \n            new BlockTokenSecretManager(false, 0, blockTokenLifetime);\n          blockPoolTokenSecretManager.addBlockPool(blockPoolId, secretMgr);\n        }\n        isBlockTokenInitialized \u003d true;\n      }\n\n      if (isBlockTokenEnabled) {\n        blockPoolTokenSecretManager.setKeys(blockPoolId,\n            bpRegistration.exportedKeys);\n        bpRegistration.exportedKeys \u003d ExportedBlockKeys.DUMMY_KEYS;\n      }\n\n      LOG.info(\"in register:\" + \";bpDNR\u003d\"+bpRegistration.storageInfo);\n\n      // random short delay - helps scatter the BR from all DNs\n      scheduleBlockReport(initialBlockReportDelay);\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
    }
  }
}