{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LogsCLI.java",
  "functionName": "run",
  "functionId": "run___args-String[]",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
  "functionStartLine": 135,
  "functionEndLine": 147,
  "numCommitsSeen": 67,
  "timeTaken": 16319,
  "changeHistory": [
    "cef0756929458f65c4f6731fe21d659100bcc8ea",
    "b65815d6914996fed25bd9fef4d37d00828bc664",
    "7836bc4c3533e93e7adc0c7da0659bc04bdf2494",
    "cb9bc6e64c590622ae04aea2c81962be59037f7a",
    "ee3355be3cd1cd956296a1b79b264177ff139ce6",
    "a409425986fc128bb54f656b05373201545f7213",
    "1a84c24b0cf6674fa755403971fa57d8e412b320",
    "eb471632349deac4b62f8dec853c8ceb64c9617a",
    "d169f5052fe83debcea7cf2f317dcd990890a857",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
    "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1",
    "ef1757790d89cc72f88f5330761b1c8901c59e94",
    "87f5e351337a905af5215af76c72b9312616cd4f",
    "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835",
    "66b07d83740a2ec3e6bfb2bfd064863bae37a1b5",
    "34ef1a092bcab369bb845481efffb8c47adef53a",
    "a77d628339afaf2f5a085c73fd81a805b18348c9",
    "b610c68d4423a5a1ab342dc490cd0064f8983c07",
    "e90718fa5a0e7c18592af61534668acebb9db51b",
    "6ff600d9e3496008d81361c17ea427a8675cd0d4",
    "febedd64e998c70594d84e2dc273cc0a469544e2",
    "67699c2d187a8480a46acf5031652ff19196823d",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "6ba0375b21c4ce07d2b6b592c4963f705c35222b",
    "c27601fefebd0af887a12d684bfc6f90d9fc0321",
    "47a381e306877750b5a3ce5d76e0a5ff652ec188",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449",
    "fafe8cd28e726566509c679e19d7da622f29f90d",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517",
    "ded6f225a55517deedc2bd502f2b68f1ca2ddee8",
    "9bac807cedbcff34e1a144fb475eff267e5ed86d",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "cef0756929458f65c4f6731fe21d659100bcc8ea": "Ybodychange",
    "b65815d6914996fed25bd9fef4d37d00828bc664": "Ybodychange",
    "7836bc4c3533e93e7adc0c7da0659bc04bdf2494": "Ybodychange",
    "cb9bc6e64c590622ae04aea2c81962be59037f7a": "Ybodychange",
    "ee3355be3cd1cd956296a1b79b264177ff139ce6": "Ybodychange",
    "a409425986fc128bb54f656b05373201545f7213": "Ybodychange",
    "1a84c24b0cf6674fa755403971fa57d8e412b320": "Ybodychange",
    "eb471632349deac4b62f8dec853c8ceb64c9617a": "Ybodychange",
    "d169f5052fe83debcea7cf2f317dcd990890a857": "Ybodychange",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf": "Ybodychange",
    "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1": "Ybodychange",
    "ef1757790d89cc72f88f5330761b1c8901c59e94": "Ybodychange",
    "87f5e351337a905af5215af76c72b9312616cd4f": "Ybodychange",
    "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835": "Ybodychange",
    "66b07d83740a2ec3e6bfb2bfd064863bae37a1b5": "Ybodychange",
    "34ef1a092bcab369bb845481efffb8c47adef53a": "Ybodychange",
    "a77d628339afaf2f5a085c73fd81a805b18348c9": "Ybodychange",
    "b610c68d4423a5a1ab342dc490cd0064f8983c07": "Ybodychange",
    "e90718fa5a0e7c18592af61534668acebb9db51b": "Ybodychange",
    "6ff600d9e3496008d81361c17ea427a8675cd0d4": "Ymultichange(Ymovefromfile,Ybodychange)",
    "febedd64e998c70594d84e2dc273cc0a469544e2": "Ybodychange",
    "67699c2d187a8480a46acf5031652ff19196823d": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "6ba0375b21c4ce07d2b6b592c4963f705c35222b": "Ybodychange",
    "c27601fefebd0af887a12d684bfc6f90d9fc0321": "Ymultichange(Yfilerename,Ybodychange)",
    "47a381e306877750b5a3ce5d76e0a5ff652ec188": "Ybodychange",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": "Ybodychange",
    "fafe8cd28e726566509c679e19d7da622f29f90d": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Ymultichange(Ymovefromfile,Yreturntypechange,Yexceptionschange,Ybodychange,Yparameterchange)",
    "ded6f225a55517deedc2bd502f2b68f1ca2ddee8": "Ybodychange",
    "9bac807cedbcff34e1a144fb475eff267e5ed86d": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cef0756929458f65c4f6731fe21d659100bcc8ea": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9606. Set sslfactory for AuthenticatedURL() while creating LogsCLI#webServiceClient.\n\nContributed by Bilwa S T. Reviewed by Akira Ajisaka.\n",
      "commitDate": "19/05/20 11:06 PM",
      "commitName": "cef0756929458f65c4f6731fe21d659100bcc8ea",
      "commitAuthor": "Prabhu Joseph",
      "commitDateOld": "18/05/20 12:29 AM",
      "commitNameOld": "b65815d6914996fed25bd9fef4d37d00828bc664",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,13 @@\n   public int run(String[] args) throws Exception {\n     try {\n-      webServiceClient \u003d new Client(new URLConnectionClientHandler(\n-          new HttpURLConnectionFactory() {\n-          @Override\n-          public HttpURLConnection getHttpURLConnection(URL url)\n-              throws IOException {\n-            AuthenticatedURL.Token token \u003d new AuthenticatedURL.Token();\n-            HttpURLConnection conn \u003d null;\n-            try {\n-              conn \u003d new AuthenticatedURL().openConnection(url, token);\n-            } catch (AuthenticationException e) {\n-              throw new IOException(e);\n-            }\n-            return conn;\n-          }\n-        }));\n+      webServiceClient \u003d WebServiceClient.getWebServiceClient().createClient();\n       return runCommand(args);\n     } finally {\n       if (yarnClient !\u003d null) {\n         yarnClient.close();\n       }\n       if (webServiceClient !\u003d null) {\n         webServiceClient.destroy();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      webServiceClient \u003d WebServiceClient.getWebServiceClient().createClient();\n      return runCommand(args);\n    } finally {\n      if (yarnClient !\u003d null) {\n        yarnClient.close();\n      }\n      if (webServiceClient !\u003d null) {\n        webServiceClient.destroy();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "b65815d6914996fed25bd9fef4d37d00828bc664": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-9606. Set sslfactory for AuthenticatedURL() while creating LogsCLI#webServiceClient.\"\n\nThis reverts commit 7836bc4c3533e93e7adc0c7da0659bc04bdf2494.\n",
      "commitDate": "18/05/20 12:29 AM",
      "commitName": "b65815d6914996fed25bd9fef4d37d00828bc664",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "14/05/20 7:10 AM",
      "commitNameOld": "7836bc4c3533e93e7adc0c7da0659bc04bdf2494",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 3.72,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,27 @@\n   public int run(String[] args) throws Exception {\n     try {\n-      client \u003d WebServiceClient.getWebServiceClient().createClient();\n+      webServiceClient \u003d new Client(new URLConnectionClientHandler(\n+          new HttpURLConnectionFactory() {\n+          @Override\n+          public HttpURLConnection getHttpURLConnection(URL url)\n+              throws IOException {\n+            AuthenticatedURL.Token token \u003d new AuthenticatedURL.Token();\n+            HttpURLConnection conn \u003d null;\n+            try {\n+              conn \u003d new AuthenticatedURL().openConnection(url, token);\n+            } catch (AuthenticationException e) {\n+              throw new IOException(e);\n+            }\n+            return conn;\n+          }\n+        }));\n       return runCommand(args);\n     } finally {\n       if (yarnClient !\u003d null) {\n         yarnClient.close();\n       }\n-      if (client !\u003d null) {\n-        client.destroy();\n+      if (webServiceClient !\u003d null) {\n+        webServiceClient.destroy();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      webServiceClient \u003d new Client(new URLConnectionClientHandler(\n          new HttpURLConnectionFactory() {\n          @Override\n          public HttpURLConnection getHttpURLConnection(URL url)\n              throws IOException {\n            AuthenticatedURL.Token token \u003d new AuthenticatedURL.Token();\n            HttpURLConnection conn \u003d null;\n            try {\n              conn \u003d new AuthenticatedURL().openConnection(url, token);\n            } catch (AuthenticationException e) {\n              throw new IOException(e);\n            }\n            return conn;\n          }\n        }));\n      return runCommand(args);\n    } finally {\n      if (yarnClient !\u003d null) {\n        yarnClient.close();\n      }\n      if (webServiceClient !\u003d null) {\n        webServiceClient.destroy();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "7836bc4c3533e93e7adc0c7da0659bc04bdf2494": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9606. Set sslfactory for AuthenticatedURL() while creating LogsCLI#webServiceClient.\n\nContributed by Bilwa S T. Reviewed by Brahma Reddy Battula.\n",
      "commitDate": "14/05/20 7:10 AM",
      "commitName": "7836bc4c3533e93e7adc0c7da0659bc04bdf2494",
      "commitAuthor": "Prabhu Joseph",
      "commitDateOld": "06/02/20 3:25 AM",
      "commitNameOld": "71b2c2ffe962ff4f5799e1f55961db687cb55842",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 98.11,
      "commitsBetweenForRepo": 336,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,13 @@\n   public int run(String[] args) throws Exception {\n     try {\n-      webServiceClient \u003d new Client(new URLConnectionClientHandler(\n-          new HttpURLConnectionFactory() {\n-          @Override\n-          public HttpURLConnection getHttpURLConnection(URL url)\n-              throws IOException {\n-            AuthenticatedURL.Token token \u003d new AuthenticatedURL.Token();\n-            HttpURLConnection conn \u003d null;\n-            try {\n-              conn \u003d new AuthenticatedURL().openConnection(url, token);\n-            } catch (AuthenticationException e) {\n-              throw new IOException(e);\n-            }\n-            return conn;\n-          }\n-        }));\n+      client \u003d WebServiceClient.getWebServiceClient().createClient();\n       return runCommand(args);\n     } finally {\n       if (yarnClient !\u003d null) {\n         yarnClient.close();\n       }\n-      if (webServiceClient !\u003d null) {\n-        webServiceClient.destroy();\n+      if (client !\u003d null) {\n+        client.destroy();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      client \u003d WebServiceClient.getWebServiceClient().createClient();\n      return runCommand(args);\n    } finally {\n      if (yarnClient !\u003d null) {\n        yarnClient.close();\n      }\n      if (client !\u003d null) {\n        client.destroy();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "cb9bc6e64c590622ae04aea2c81962be59037f7a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9581.  Fixed yarn logs cli to access RM2.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "06/06/19 1:41 PM",
      "commitName": "cb9bc6e64c590622ae04aea2c81962be59037f7a",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "28/11/18 12:46 AM",
      "commitNameOld": "b3a052d199ff71da042029f27979a5323d3a6981",
      "commitAuthorOld": "Suma Shivaprasad",
      "daysBetweenCommits": 190.5,
      "commitsBetweenForRepo": 1321,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,27 @@\n   public int run(String[] args) throws Exception {\n     try {\n       webServiceClient \u003d new Client(new URLConnectionClientHandler(\n           new HttpURLConnectionFactory() {\n           @Override\n           public HttpURLConnection getHttpURLConnection(URL url)\n               throws IOException {\n             AuthenticatedURL.Token token \u003d new AuthenticatedURL.Token();\n             HttpURLConnection conn \u003d null;\n             try {\n               conn \u003d new AuthenticatedURL().openConnection(url, token);\n             } catch (AuthenticationException e) {\n               throw new IOException(e);\n             }\n             return conn;\n           }\n         }));\n       return runCommand(args);\n     } finally {\n       if (yarnClient !\u003d null) {\n         yarnClient.close();\n       }\n+      if (webServiceClient !\u003d null) {\n+        webServiceClient.destroy();\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      webServiceClient \u003d new Client(new URLConnectionClientHandler(\n          new HttpURLConnectionFactory() {\n          @Override\n          public HttpURLConnection getHttpURLConnection(URL url)\n              throws IOException {\n            AuthenticatedURL.Token token \u003d new AuthenticatedURL.Token();\n            HttpURLConnection conn \u003d null;\n            try {\n              conn \u003d new AuthenticatedURL().openConnection(url, token);\n            } catch (AuthenticationException e) {\n              throw new IOException(e);\n            }\n            return conn;\n          }\n        }));\n      return runCommand(args);\n    } finally {\n      if (yarnClient !\u003d null) {\n        yarnClient.close();\n      }\n      if (webServiceClient !\u003d null) {\n        webServiceClient.destroy();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "ee3355be3cd1cd956296a1b79b264177ff139ce6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8303. YarnClient should contact TimelineReader for application/attempt/container report.\n",
      "commitDate": "16/11/18 4:28 AM",
      "commitName": "ee3355be3cd1cd956296a1b79b264177ff139ce6",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "12/06/18 8:35 AM",
      "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 156.87,
      "commitsBetweenForRepo": 1287,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,24 @@\n   public int run(String[] args) throws Exception {\n     try {\n-      yarnClient \u003d createYarnClient();\n       webServiceClient \u003d new Client(new URLConnectionClientHandler(\n           new HttpURLConnectionFactory() {\n           @Override\n           public HttpURLConnection getHttpURLConnection(URL url)\n               throws IOException {\n             AuthenticatedURL.Token token \u003d new AuthenticatedURL.Token();\n             HttpURLConnection conn \u003d null;\n             try {\n               conn \u003d new AuthenticatedURL().openConnection(url, token);\n             } catch (AuthenticationException e) {\n               throw new IOException(e);\n             }\n             return conn;\n           }\n         }));\n       return runCommand(args);\n     } finally {\n       if (yarnClient !\u003d null) {\n         yarnClient.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      webServiceClient \u003d new Client(new URLConnectionClientHandler(\n          new HttpURLConnectionFactory() {\n          @Override\n          public HttpURLConnection getHttpURLConnection(URL url)\n              throws IOException {\n            AuthenticatedURL.Token token \u003d new AuthenticatedURL.Token();\n            HttpURLConnection conn \u003d null;\n            try {\n              conn \u003d new AuthenticatedURL().openConnection(url, token);\n            } catch (AuthenticationException e) {\n              throw new IOException(e);\n            }\n            return conn;\n          }\n        }));\n      return runCommand(args);\n    } finally {\n      if (yarnClient !\u003d null) {\n        yarnClient.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "a409425986fc128bb54f656b05373201545f7213": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7558. yarn logs command fails to get logs for running containers if UI authentication is enabled. Contributed by Xuan Gong.\n",
      "commitDate": "30/11/17 1:47 PM",
      "commitName": "a409425986fc128bb54f656b05373201545f7213",
      "commitAuthor": "Junping Du",
      "commitDateOld": "29/09/17 4:42 PM",
      "commitNameOld": "ec2ae3060a807c8754826af2135a68c08b2e4f13",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 61.92,
      "commitsBetweenForRepo": 479,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,11 +1,25 @@\n   public int run(String[] args) throws Exception {\n     try {\n       yarnClient \u003d createYarnClient();\n-      webServiceClient \u003d Client.create();\n+      webServiceClient \u003d new Client(new URLConnectionClientHandler(\n+          new HttpURLConnectionFactory() {\n+          @Override\n+          public HttpURLConnection getHttpURLConnection(URL url)\n+              throws IOException {\n+            AuthenticatedURL.Token token \u003d new AuthenticatedURL.Token();\n+            HttpURLConnection conn \u003d null;\n+            try {\n+              conn \u003d new AuthenticatedURL().openConnection(url, token);\n+            } catch (AuthenticationException e) {\n+              throw new IOException(e);\n+            }\n+            return conn;\n+          }\n+        }));\n       return runCommand(args);\n     } finally {\n       if (yarnClient !\u003d null) {\n         yarnClient.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      yarnClient \u003d createYarnClient();\n      webServiceClient \u003d new Client(new URLConnectionClientHandler(\n          new HttpURLConnectionFactory() {\n          @Override\n          public HttpURLConnection getHttpURLConnection(URL url)\n              throws IOException {\n            AuthenticatedURL.Token token \u003d new AuthenticatedURL.Token();\n            HttpURLConnection conn \u003d null;\n            try {\n              conn \u003d new AuthenticatedURL().openConnection(url, token);\n            } catch (AuthenticationException e) {\n              throw new IOException(e);\n            }\n            return conn;\n          }\n        }));\n      return runCommand(args);\n    } finally {\n      if (yarnClient !\u003d null) {\n        yarnClient.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "1a84c24b0cf6674fa755403971fa57d8e412b320": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7174. Add retry logic in LogsCLI when fetch running application logs. Contributed by Xuan Gong.\n",
      "commitDate": "15/09/17 3:33 PM",
      "commitName": "1a84c24b0cf6674fa755403971fa57d8e412b320",
      "commitAuthor": "Junping Du",
      "commitDateOld": "08/09/17 3:16 PM",
      "commitNameOld": "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 7.01,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,10 +1,11 @@\n   public int run(String[] args) throws Exception {\n     try {\n       yarnClient \u003d createYarnClient();\n+      webServiceClient \u003d Client.create();\n       return runCommand(args);\n     } finally {\n       if (yarnClient !\u003d null) {\n         yarnClient.close();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      yarnClient \u003d createYarnClient();\n      webServiceClient \u003d Client.create();\n      return runCommand(args);\n    } finally {\n      if (yarnClient !\u003d null) {\n        yarnClient.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "eb471632349deac4b62f8dec853c8ceb64c9617a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5200. Enhanced \"yarn logs\" to be able to get a list of containers whose logs are aggregated via a \"show_container_log_info\" option. Contributed by Xuan Gong.\n",
      "commitDate": "13/07/16 10:54 AM",
      "commitName": "eb471632349deac4b62f8dec853c8ceb64c9617a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/07/16 8:29 AM",
      "commitNameOld": "7705812c7e3a9f3f774130e25443fda249c08c9c",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 1.1,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,158 +1,10 @@\n   public int run(String[] args) throws Exception {\n-    Options opts \u003d createCommandOpts();\n-    Options printOpts \u003d createPrintOpts(opts);\n-    if (args.length \u003c 1) {\n-      printHelpMessage(printOpts);\n-      return -1;\n-    }\n-    if (args[0].equals(\"-help\")) {\n-      printHelpMessage(printOpts);\n-      return 0;\n-    }\n-    CommandLineParser parser \u003d new GnuParser();\n-    String appIdStr \u003d null;\n-    String containerIdStr \u003d null;\n-    String nodeAddress \u003d null;\n-    String appOwner \u003d null;\n-    boolean getAMContainerLogs \u003d false;\n-    boolean showMetaInfo \u003d false;\n-    boolean nodesList \u003d false;\n-    String[] logFiles \u003d null;\n-    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n-    String localDir \u003d null;\n-    long bytes \u003d Long.MAX_VALUE;\n     try {\n-      CommandLine commandLine \u003d parser.parse(opts, args, true);\n-      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n-      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n-      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n-      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n-      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n-      showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n-      nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n-      localDir \u003d commandLine.getOptionValue(OUT_OPTION);\n-      if (getAMContainerLogs) {\n-        try {\n-          amContainersList \u003d parseAMContainer(commandLine, printOpts);\n-        } catch (NumberFormatException ex) {\n-          System.err.println(ex.getMessage());\n-          return -1;\n-        }\n-      }\n-      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n-        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n-      }\n-      if (commandLine.hasOption(SIZE_OPTION)) {\n-        bytes \u003d Long.parseLong(commandLine.getOptionValue(SIZE_OPTION));\n-      }\n-    } catch (ParseException e) {\n-      System.err.println(\"options parsing failed: \" + e.getMessage());\n-      printHelpMessage(printOpts);\n-      return -1;\n-    }\n-\n-    if (appIdStr \u003d\u003d null \u0026\u0026 containerIdStr \u003d\u003d null) {\n-      System.err.println(\"Both applicationId and containerId are missing, \"\n-          + \" one of them must be specified.\");\n-      printHelpMessage(printOpts);\n-      return -1;\n-    }\n-\n-    ApplicationId appId \u003d null;\n-    if (appIdStr !\u003d null) {\n-      try {\n-        appId \u003d ApplicationId.fromString(appIdStr);\n-      } catch (Exception e) {\n-        System.err.println(\"Invalid ApplicationId specified\");\n-        return -1;\n+      yarnClient \u003d createYarnClient();\n+      return runCommand(args);\n+    } finally {\n+      if (yarnClient !\u003d null) {\n+        yarnClient.close();\n       }\n     }\n-\n-    if (containerIdStr !\u003d null) {\n-      try {\n-        ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n-        if (appId \u003d\u003d null) {\n-          appId \u003d containerId.getApplicationAttemptId().getApplicationId();\n-        } else if (!containerId.getApplicationAttemptId().getApplicationId()\n-            .equals(appId)) {\n-          System.err.println(\"The Application:\" + appId\n-              + \" does not have the container:\" + containerId);\n-          return -1;\n-        }\n-      } catch (Exception e) {\n-        System.err.println(\"Invalid ContainerId specified\");\n-        return -1;\n-      }\n-    }\n-\n-    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n-    logCliHelper.setConf(getConf());\n-\n-    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n-    ApplicationReport appReport \u003d null;\n-    try {\n-      appReport \u003d getApplicationReport(appId);\n-      appState \u003d appReport.getYarnApplicationState();\n-      if (appState \u003d\u003d YarnApplicationState.NEW\n-          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n-          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n-        System.err.println(\"Logs are not avaiable right now.\");\n-        return -1;\n-      }\n-    } catch (IOException | YarnException e) {\n-      // If we can not get appReport from either RM or ATS\n-      // We will assume that this app has already finished.\n-      appState \u003d YarnApplicationState.FINISHED;\n-      System.err.println(\"Unable to get ApplicationState.\"\n-          + \" Attempting to fetch logs directly from the filesystem.\");\n-    }\n-\n-    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n-      appOwner \u003d guessAppOwner(appReport, appId);\n-      if (appOwner \u003d\u003d null) {\n-        System.err.println(\"Can not find the appOwner. \"\n-            + \"Please specify the correct appOwner\");\n-        System.err.println(\"Could not locate application logs for \" + appId);\n-        return -1;\n-      }\n-    }\n-\n-    List\u003cString\u003e logs \u003d new ArrayList\u003cString\u003e();\n-    if (fetchAllLogFiles(logFiles)) {\n-      logs.add(\".*\");\n-    } else if (logFiles !\u003d null \u0026\u0026 logFiles.length \u003e 0) {\n-      logs \u003d Arrays.asList(logFiles);\n-    }\n-\n-    ContainerLogsRequest request \u003d new ContainerLogsRequest(appId,\n-        isApplicationFinished(appState), appOwner, nodeAddress, null,\n-        containerIdStr, localDir, logs, bytes);\n-\n-    if (showMetaInfo) {\n-      return showMetaInfo(request, logCliHelper);\n-    }\n-\n-    if (nodesList) {\n-      return showNodeLists(request, logCliHelper);\n-    }\n-\n-    // To get am logs\n-    if (getAMContainerLogs) {\n-      return fetchAMContainerLogs(request, amContainersList,\n-          logCliHelper);\n-    }\n-\n-    int resultCode \u003d 0;\n-    if (containerIdStr !\u003d null) {\n-      return fetchContainerLogs(request, logCliHelper);\n-    } else {\n-      if (nodeAddress \u003d\u003d null) {\n-        resultCode \u003d fetchApplicationLogs(request, logCliHelper);\n-      } else {\n-        System.err.println(\"Should at least provide ContainerId!\");\n-        printHelpMessage(printOpts);\n-        resultCode \u003d -1;\n-      }\n-    }\n-    return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    try {\n      yarnClient \u003d createYarnClient();\n      return runCommand(args);\n    } finally {\n      if (yarnClient !\u003d null) {\n        yarnClient.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "d169f5052fe83debcea7cf2f317dcd990890a857": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5227. Yarn logs command: no need to specify applicationId when\nspecifying containerId. Contributed by Gergely Nov√°k\n",
      "commitDate": "06/07/16 10:43 AM",
      "commitName": "d169f5052fe83debcea7cf2f317dcd990890a857",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/06/16 9:48 PM",
      "commitNameOld": "6ab5aa1c1f82f81726c6daa38b3db90d8c3ad856",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 13.54,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,158 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d createCommandOpts();\n     Options printOpts \u003d createPrintOpts(opts);\n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n     if (args[0].equals(\"-help\")) {\n       printHelpMessage(printOpts);\n       return 0;\n     }\n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     boolean getAMContainerLogs \u003d false;\n     boolean showMetaInfo \u003d false;\n     boolean nodesList \u003d false;\n     String[] logFiles \u003d null;\n     List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n     String localDir \u003d null;\n     long bytes \u003d Long.MAX_VALUE;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n       getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n       showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n       nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n       localDir \u003d commandLine.getOptionValue(OUT_OPTION);\n       if (getAMContainerLogs) {\n         try {\n           amContainersList \u003d parseAMContainer(commandLine, printOpts);\n         } catch (NumberFormatException ex) {\n           System.err.println(ex.getMessage());\n           return -1;\n         }\n       }\n       if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n         logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n       }\n       if (commandLine.hasOption(SIZE_OPTION)) {\n         bytes \u003d Long.parseLong(commandLine.getOptionValue(SIZE_OPTION));\n       }\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n-    if (appIdStr \u003d\u003d null) {\n-      System.err.println(\"ApplicationId cannot be null!\");\n+    if (appIdStr \u003d\u003d null \u0026\u0026 containerIdStr \u003d\u003d null) {\n+      System.err.println(\"Both applicationId and containerId are missing, \"\n+          + \" one of them must be specified.\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n-    try {\n-      appId \u003d ApplicationId.fromString(appIdStr);\n-    } catch (Exception e) {\n-      System.err.println(\"Invalid ApplicationId specified\");\n-      return -1;\n+    if (appIdStr !\u003d null) {\n+      try {\n+        appId \u003d ApplicationId.fromString(appIdStr);\n+      } catch (Exception e) {\n+        System.err.println(\"Invalid ApplicationId specified\");\n+        return -1;\n+      }\n+    }\n+\n+    if (containerIdStr !\u003d null) {\n+      try {\n+        ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n+        if (appId \u003d\u003d null) {\n+          appId \u003d containerId.getApplicationAttemptId().getApplicationId();\n+        } else if (!containerId.getApplicationAttemptId().getApplicationId()\n+            .equals(appId)) {\n+          System.err.println(\"The Application:\" + appId\n+              + \" does not have the container:\" + containerId);\n+          return -1;\n+        }\n+      } catch (Exception e) {\n+        System.err.println(\"Invalid ContainerId specified\");\n+        return -1;\n+      }\n     }\n \n     LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n     logCliHelper.setConf(getConf());\n \n     YarnApplicationState appState \u003d YarnApplicationState.NEW;\n     ApplicationReport appReport \u003d null;\n     try {\n       appReport \u003d getApplicationReport(appId);\n       appState \u003d appReport.getYarnApplicationState();\n       if (appState \u003d\u003d YarnApplicationState.NEW\n           || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n           || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n         System.err.println(\"Logs are not avaiable right now.\");\n         return -1;\n       }\n     } catch (IOException | YarnException e) {\n       // If we can not get appReport from either RM or ATS\n       // We will assume that this app has already finished.\n       appState \u003d YarnApplicationState.FINISHED;\n       System.err.println(\"Unable to get ApplicationState.\"\n           + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d guessAppOwner(appReport, appId);\n       if (appOwner \u003d\u003d null) {\n         System.err.println(\"Can not find the appOwner. \"\n             + \"Please specify the correct appOwner\");\n         System.err.println(\"Could not locate application logs for \" + appId);\n         return -1;\n       }\n     }\n \n     List\u003cString\u003e logs \u003d new ArrayList\u003cString\u003e();\n     if (fetchAllLogFiles(logFiles)) {\n       logs.add(\".*\");\n     } else if (logFiles !\u003d null \u0026\u0026 logFiles.length \u003e 0) {\n       logs \u003d Arrays.asList(logFiles);\n     }\n \n     ContainerLogsRequest request \u003d new ContainerLogsRequest(appId,\n         isApplicationFinished(appState), appOwner, nodeAddress, null,\n         containerIdStr, localDir, logs, bytes);\n \n     if (showMetaInfo) {\n       return showMetaInfo(request, logCliHelper);\n     }\n \n     if (nodesList) {\n       return showNodeLists(request, logCliHelper);\n     }\n \n     // To get am logs\n     if (getAMContainerLogs) {\n       return fetchAMContainerLogs(request, amContainersList,\n           logCliHelper);\n     }\n \n     int resultCode \u003d 0;\n     if (containerIdStr !\u003d null) {\n-      ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n-      if (!containerId.getApplicationAttemptId().getApplicationId()\n-          .equals(appId)) {\n-        System.err.println(\"The Application:\" + appId\n-            + \" does not have the container:\" + containerId);\n-        return -1;\n-      }\n       return fetchContainerLogs(request, logCliHelper);\n     } else {\n       if (nodeAddress \u003d\u003d null) {\n         resultCode \u003d fetchApplicationLogs(request, logCliHelper);\n       } else {\n         System.err.println(\"Should at least provide ContainerId!\");\n         printHelpMessage(printOpts);\n         resultCode \u003d -1;\n       }\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d createCommandOpts();\n    Options printOpts \u003d createPrintOpts(opts);\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n    if (args[0].equals(\"-help\")) {\n      printHelpMessage(printOpts);\n      return 0;\n    }\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    boolean getAMContainerLogs \u003d false;\n    boolean showMetaInfo \u003d false;\n    boolean nodesList \u003d false;\n    String[] logFiles \u003d null;\n    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n    String localDir \u003d null;\n    long bytes \u003d Long.MAX_VALUE;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n      showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n      nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n      localDir \u003d commandLine.getOptionValue(OUT_OPTION);\n      if (getAMContainerLogs) {\n        try {\n          amContainersList \u003d parseAMContainer(commandLine, printOpts);\n        } catch (NumberFormatException ex) {\n          System.err.println(ex.getMessage());\n          return -1;\n        }\n      }\n      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n      }\n      if (commandLine.hasOption(SIZE_OPTION)) {\n        bytes \u003d Long.parseLong(commandLine.getOptionValue(SIZE_OPTION));\n      }\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null \u0026\u0026 containerIdStr \u003d\u003d null) {\n      System.err.println(\"Both applicationId and containerId are missing, \"\n          + \" one of them must be specified.\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    if (appIdStr !\u003d null) {\n      try {\n        appId \u003d ApplicationId.fromString(appIdStr);\n      } catch (Exception e) {\n        System.err.println(\"Invalid ApplicationId specified\");\n        return -1;\n      }\n    }\n\n    if (containerIdStr !\u003d null) {\n      try {\n        ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n        if (appId \u003d\u003d null) {\n          appId \u003d containerId.getApplicationAttemptId().getApplicationId();\n        } else if (!containerId.getApplicationAttemptId().getApplicationId()\n            .equals(appId)) {\n          System.err.println(\"The Application:\" + appId\n              + \" does not have the container:\" + containerId);\n          return -1;\n        }\n      } catch (Exception e) {\n        System.err.println(\"Invalid ContainerId specified\");\n        return -1;\n      }\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n\n    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n    ApplicationReport appReport \u003d null;\n    try {\n      appReport \u003d getApplicationReport(appId);\n      appState \u003d appReport.getYarnApplicationState();\n      if (appState \u003d\u003d YarnApplicationState.NEW\n          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n        System.err.println(\"Logs are not avaiable right now.\");\n        return -1;\n      }\n    } catch (IOException | YarnException e) {\n      // If we can not get appReport from either RM or ATS\n      // We will assume that this app has already finished.\n      appState \u003d YarnApplicationState.FINISHED;\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d guessAppOwner(appReport, appId);\n      if (appOwner \u003d\u003d null) {\n        System.err.println(\"Can not find the appOwner. \"\n            + \"Please specify the correct appOwner\");\n        System.err.println(\"Could not locate application logs for \" + appId);\n        return -1;\n      }\n    }\n\n    List\u003cString\u003e logs \u003d new ArrayList\u003cString\u003e();\n    if (fetchAllLogFiles(logFiles)) {\n      logs.add(\".*\");\n    } else if (logFiles !\u003d null \u0026\u0026 logFiles.length \u003e 0) {\n      logs \u003d Arrays.asList(logFiles);\n    }\n\n    ContainerLogsRequest request \u003d new ContainerLogsRequest(appId,\n        isApplicationFinished(appState), appOwner, nodeAddress, null,\n        containerIdStr, localDir, logs, bytes);\n\n    if (showMetaInfo) {\n      return showMetaInfo(request, logCliHelper);\n    }\n\n    if (nodesList) {\n      return showNodeLists(request, logCliHelper);\n    }\n\n    // To get am logs\n    if (getAMContainerLogs) {\n      return fetchAMContainerLogs(request, amContainersList,\n          logCliHelper);\n    }\n\n    int resultCode \u003d 0;\n    if (containerIdStr !\u003d null) {\n      return fetchContainerLogs(request, logCliHelper);\n    } else {\n      if (nodeAddress \u003d\u003d null) {\n        resultCode \u003d fetchApplicationLogs(request, logCliHelper);\n      } else {\n        System.err.println(\"Should at least provide ContainerId!\");\n        printHelpMessage(printOpts);\n        resultCode \u003d -1;\n      }\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/06/16 9:49 AM",
      "commitNameOld": "5a43583c0bbb9650ea6a9f48d9544ec3ec24b580",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.22,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,145 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d createCommandOpts();\n     Options printOpts \u003d createPrintOpts(opts);\n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n     if (args[0].equals(\"-help\")) {\n       printHelpMessage(printOpts);\n       return 0;\n     }\n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     boolean getAMContainerLogs \u003d false;\n     boolean showMetaInfo \u003d false;\n     boolean nodesList \u003d false;\n     String[] logFiles \u003d null;\n     List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n     String localDir \u003d null;\n     long bytes \u003d Long.MAX_VALUE;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n       getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n       showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n       nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n       localDir \u003d commandLine.getOptionValue(OUT_OPTION);\n       if (getAMContainerLogs) {\n         try {\n           amContainersList \u003d parseAMContainer(commandLine, printOpts);\n         } catch (NumberFormatException ex) {\n           System.err.println(ex.getMessage());\n           return -1;\n         }\n       }\n       if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n         logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n       }\n       if (commandLine.hasOption(SIZE_OPTION)) {\n         bytes \u003d Long.parseLong(commandLine.getOptionValue(SIZE_OPTION));\n       }\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n     try {\n-      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n+      appId \u003d ApplicationId.fromString(appIdStr);\n     } catch (Exception e) {\n       System.err.println(\"Invalid ApplicationId specified\");\n       return -1;\n     }\n \n     LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n     logCliHelper.setConf(getConf());\n \n     YarnApplicationState appState \u003d YarnApplicationState.NEW;\n     ApplicationReport appReport \u003d null;\n     try {\n       appReport \u003d getApplicationReport(appId);\n       appState \u003d appReport.getYarnApplicationState();\n       if (appState \u003d\u003d YarnApplicationState.NEW\n           || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n           || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n         System.err.println(\"Logs are not avaiable right now.\");\n         return -1;\n       }\n     } catch (IOException | YarnException e) {\n       // If we can not get appReport from either RM or ATS\n       // We will assume that this app has already finished.\n       appState \u003d YarnApplicationState.FINISHED;\n       System.err.println(\"Unable to get ApplicationState.\"\n           + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d guessAppOwner(appReport, appId);\n       if (appOwner \u003d\u003d null) {\n         System.err.println(\"Can not find the appOwner. \"\n             + \"Please specify the correct appOwner\");\n         System.err.println(\"Could not locate application logs for \" + appId);\n         return -1;\n       }\n     }\n \n     List\u003cString\u003e logs \u003d new ArrayList\u003cString\u003e();\n     if (fetchAllLogFiles(logFiles)) {\n       logs.add(\".*\");\n     } else if (logFiles !\u003d null \u0026\u0026 logFiles.length \u003e 0) {\n       logs \u003d Arrays.asList(logFiles);\n     }\n \n     ContainerLogsRequest request \u003d new ContainerLogsRequest(appId,\n         isApplicationFinished(appState), appOwner, nodeAddress, null,\n         containerIdStr, localDir, logs, bytes);\n \n     if (showMetaInfo) {\n       return showMetaInfo(request, logCliHelper);\n     }\n \n     if (nodesList) {\n       return showNodeLists(request, logCliHelper);\n     }\n \n     // To get am logs\n     if (getAMContainerLogs) {\n       return fetchAMContainerLogs(request, amContainersList,\n           logCliHelper);\n     }\n \n     int resultCode \u003d 0;\n     if (containerIdStr !\u003d null) {\n       ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n       if (!containerId.getApplicationAttemptId().getApplicationId()\n           .equals(appId)) {\n         System.err.println(\"The Application:\" + appId\n             + \" does not have the container:\" + containerId);\n         return -1;\n       }\n       return fetchContainerLogs(request, logCliHelper);\n     } else {\n       if (nodeAddress \u003d\u003d null) {\n         resultCode \u003d fetchApplicationLogs(request, logCliHelper);\n       } else {\n         System.err.println(\"Should at least provide ContainerId!\");\n         printHelpMessage(printOpts);\n         resultCode \u003d -1;\n       }\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d createCommandOpts();\n    Options printOpts \u003d createPrintOpts(opts);\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n    if (args[0].equals(\"-help\")) {\n      printHelpMessage(printOpts);\n      return 0;\n    }\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    boolean getAMContainerLogs \u003d false;\n    boolean showMetaInfo \u003d false;\n    boolean nodesList \u003d false;\n    String[] logFiles \u003d null;\n    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n    String localDir \u003d null;\n    long bytes \u003d Long.MAX_VALUE;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n      showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n      nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n      localDir \u003d commandLine.getOptionValue(OUT_OPTION);\n      if (getAMContainerLogs) {\n        try {\n          amContainersList \u003d parseAMContainer(commandLine, printOpts);\n        } catch (NumberFormatException ex) {\n          System.err.println(ex.getMessage());\n          return -1;\n        }\n      }\n      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n      }\n      if (commandLine.hasOption(SIZE_OPTION)) {\n        bytes \u003d Long.parseLong(commandLine.getOptionValue(SIZE_OPTION));\n      }\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ApplicationId.fromString(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n\n    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n    ApplicationReport appReport \u003d null;\n    try {\n      appReport \u003d getApplicationReport(appId);\n      appState \u003d appReport.getYarnApplicationState();\n      if (appState \u003d\u003d YarnApplicationState.NEW\n          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n        System.err.println(\"Logs are not avaiable right now.\");\n        return -1;\n      }\n    } catch (IOException | YarnException e) {\n      // If we can not get appReport from either RM or ATS\n      // We will assume that this app has already finished.\n      appState \u003d YarnApplicationState.FINISHED;\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d guessAppOwner(appReport, appId);\n      if (appOwner \u003d\u003d null) {\n        System.err.println(\"Can not find the appOwner. \"\n            + \"Please specify the correct appOwner\");\n        System.err.println(\"Could not locate application logs for \" + appId);\n        return -1;\n      }\n    }\n\n    List\u003cString\u003e logs \u003d new ArrayList\u003cString\u003e();\n    if (fetchAllLogFiles(logFiles)) {\n      logs.add(\".*\");\n    } else if (logFiles !\u003d null \u0026\u0026 logFiles.length \u003e 0) {\n      logs \u003d Arrays.asList(logFiles);\n    }\n\n    ContainerLogsRequest request \u003d new ContainerLogsRequest(appId,\n        isApplicationFinished(appState), appOwner, nodeAddress, null,\n        containerIdStr, localDir, logs, bytes);\n\n    if (showMetaInfo) {\n      return showMetaInfo(request, logCliHelper);\n    }\n\n    if (nodesList) {\n      return showNodeLists(request, logCliHelper);\n    }\n\n    // To get am logs\n    if (getAMContainerLogs) {\n      return fetchAMContainerLogs(request, amContainersList,\n          logCliHelper);\n    }\n\n    int resultCode \u003d 0;\n    if (containerIdStr !\u003d null) {\n      ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n      if (!containerId.getApplicationAttemptId().getApplicationId()\n          .equals(appId)) {\n        System.err.println(\"The Application:\" + appId\n            + \" does not have the container:\" + containerId);\n        return -1;\n      }\n      return fetchContainerLogs(request, logCliHelper);\n    } else {\n      if (nodeAddress \u003d\u003d null) {\n        resultCode \u003d fetchApplicationLogs(request, logCliHelper);\n      } else {\n        System.err.println(\"Should at least provide ContainerId!\");\n        printHelpMessage(printOpts);\n        resultCode \u003d -1;\n      }\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5088. Improve \"yarn log\" command-line to read the last K bytes for the log files. Contributed by Xuan Gong\n",
      "commitDate": "01/06/16 1:44 PM",
      "commitName": "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
      "commitAuthor": "Xuan",
      "commitDateOld": "29/05/16 9:23 AM",
      "commitNameOld": "4e1f56e111a88c2bc600aaa601010295075676c9",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 3.18,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,145 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d createCommandOpts();\n     Options printOpts \u003d createPrintOpts(opts);\n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n     if (args[0].equals(\"-help\")) {\n       printHelpMessage(printOpts);\n       return 0;\n     }\n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     boolean getAMContainerLogs \u003d false;\n     boolean showMetaInfo \u003d false;\n     boolean nodesList \u003d false;\n     String[] logFiles \u003d null;\n     List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n     String localDir \u003d null;\n+    long bytes \u003d Long.MAX_VALUE;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n       getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n       showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n       nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n       localDir \u003d commandLine.getOptionValue(OUT_OPTION);\n       if (getAMContainerLogs) {\n         try {\n           amContainersList \u003d parseAMContainer(commandLine, printOpts);\n         } catch (NumberFormatException ex) {\n           System.err.println(ex.getMessage());\n           return -1;\n         }\n       }\n       if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n         logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n       }\n+      if (commandLine.hasOption(SIZE_OPTION)) {\n+        bytes \u003d Long.parseLong(commandLine.getOptionValue(SIZE_OPTION));\n+      }\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n     try {\n       appId \u003d ConverterUtils.toApplicationId(appIdStr);\n     } catch (Exception e) {\n       System.err.println(\"Invalid ApplicationId specified\");\n       return -1;\n     }\n \n     LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n     logCliHelper.setConf(getConf());\n \n     YarnApplicationState appState \u003d YarnApplicationState.NEW;\n     ApplicationReport appReport \u003d null;\n     try {\n       appReport \u003d getApplicationReport(appId);\n       appState \u003d appReport.getYarnApplicationState();\n       if (appState \u003d\u003d YarnApplicationState.NEW\n           || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n           || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n         System.err.println(\"Logs are not avaiable right now.\");\n         return -1;\n       }\n     } catch (IOException | YarnException e) {\n       // If we can not get appReport from either RM or ATS\n       // We will assume that this app has already finished.\n       appState \u003d YarnApplicationState.FINISHED;\n       System.err.println(\"Unable to get ApplicationState.\"\n           + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d guessAppOwner(appReport, appId);\n       if (appOwner \u003d\u003d null) {\n         System.err.println(\"Can not find the appOwner. \"\n             + \"Please specify the correct appOwner\");\n         System.err.println(\"Could not locate application logs for \" + appId);\n         return -1;\n       }\n     }\n \n     List\u003cString\u003e logs \u003d new ArrayList\u003cString\u003e();\n     if (fetchAllLogFiles(logFiles)) {\n       logs.add(\".*\");\n     } else if (logFiles !\u003d null \u0026\u0026 logFiles.length \u003e 0) {\n       logs \u003d Arrays.asList(logFiles);\n     }\n \n     ContainerLogsRequest request \u003d new ContainerLogsRequest(appId,\n         isApplicationFinished(appState), appOwner, nodeAddress, null,\n-        containerIdStr, localDir, logs);\n+        containerIdStr, localDir, logs, bytes);\n \n     if (showMetaInfo) {\n       return showMetaInfo(request, logCliHelper);\n     }\n \n     if (nodesList) {\n       return showNodeLists(request, logCliHelper);\n     }\n \n     // To get am logs\n     if (getAMContainerLogs) {\n       return fetchAMContainerLogs(request, amContainersList,\n           logCliHelper);\n     }\n \n     int resultCode \u003d 0;\n     if (containerIdStr !\u003d null) {\n       ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n       if (!containerId.getApplicationAttemptId().getApplicationId()\n           .equals(appId)) {\n         System.err.println(\"The Application:\" + appId\n             + \" does not have the container:\" + containerId);\n         return -1;\n       }\n       return fetchContainerLogs(request, logCliHelper);\n     } else {\n       if (nodeAddress \u003d\u003d null) {\n         resultCode \u003d fetchApplicationLogs(request, logCliHelper);\n       } else {\n         System.err.println(\"Should at least provide ContainerId!\");\n         printHelpMessage(printOpts);\n         resultCode \u003d -1;\n       }\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d createCommandOpts();\n    Options printOpts \u003d createPrintOpts(opts);\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n    if (args[0].equals(\"-help\")) {\n      printHelpMessage(printOpts);\n      return 0;\n    }\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    boolean getAMContainerLogs \u003d false;\n    boolean showMetaInfo \u003d false;\n    boolean nodesList \u003d false;\n    String[] logFiles \u003d null;\n    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n    String localDir \u003d null;\n    long bytes \u003d Long.MAX_VALUE;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n      showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n      nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n      localDir \u003d commandLine.getOptionValue(OUT_OPTION);\n      if (getAMContainerLogs) {\n        try {\n          amContainersList \u003d parseAMContainer(commandLine, printOpts);\n        } catch (NumberFormatException ex) {\n          System.err.println(ex.getMessage());\n          return -1;\n        }\n      }\n      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n      }\n      if (commandLine.hasOption(SIZE_OPTION)) {\n        bytes \u003d Long.parseLong(commandLine.getOptionValue(SIZE_OPTION));\n      }\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n\n    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n    ApplicationReport appReport \u003d null;\n    try {\n      appReport \u003d getApplicationReport(appId);\n      appState \u003d appReport.getYarnApplicationState();\n      if (appState \u003d\u003d YarnApplicationState.NEW\n          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n        System.err.println(\"Logs are not avaiable right now.\");\n        return -1;\n      }\n    } catch (IOException | YarnException e) {\n      // If we can not get appReport from either RM or ATS\n      // We will assume that this app has already finished.\n      appState \u003d YarnApplicationState.FINISHED;\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d guessAppOwner(appReport, appId);\n      if (appOwner \u003d\u003d null) {\n        System.err.println(\"Can not find the appOwner. \"\n            + \"Please specify the correct appOwner\");\n        System.err.println(\"Could not locate application logs for \" + appId);\n        return -1;\n      }\n    }\n\n    List\u003cString\u003e logs \u003d new ArrayList\u003cString\u003e();\n    if (fetchAllLogFiles(logFiles)) {\n      logs.add(\".*\");\n    } else if (logFiles !\u003d null \u0026\u0026 logFiles.length \u003e 0) {\n      logs \u003d Arrays.asList(logFiles);\n    }\n\n    ContainerLogsRequest request \u003d new ContainerLogsRequest(appId,\n        isApplicationFinished(appState), appOwner, nodeAddress, null,\n        containerIdStr, localDir, logs, bytes);\n\n    if (showMetaInfo) {\n      return showMetaInfo(request, logCliHelper);\n    }\n\n    if (nodesList) {\n      return showNodeLists(request, logCliHelper);\n    }\n\n    // To get am logs\n    if (getAMContainerLogs) {\n      return fetchAMContainerLogs(request, amContainersList,\n          logCliHelper);\n    }\n\n    int resultCode \u003d 0;\n    if (containerIdStr !\u003d null) {\n      ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n      if (!containerId.getApplicationAttemptId().getApplicationId()\n          .equals(appId)) {\n        System.err.println(\"The Application:\" + appId\n            + \" does not have the container:\" + containerId);\n        return -1;\n      }\n      return fetchContainerLogs(request, logCliHelper);\n    } else {\n      if (nodeAddress \u003d\u003d null) {\n        resultCode \u003d fetchApplicationLogs(request, logCliHelper);\n      } else {\n        System.err.println(\"Should at least provide ContainerId!\");\n        printHelpMessage(printOpts);\n        resultCode \u003d -1;\n      }\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5089. Improve \"yarn log\" command-line \"logFiles\" option to support\nregex. Contributed by Xuan Gong\n",
      "commitDate": "26/05/16 11:49 PM",
      "commitName": "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1",
      "commitAuthor": "Xuan",
      "commitDateOld": "18/05/16 10:14 AM",
      "commitNameOld": "ef1757790d89cc72f88f5330761b1c8901c59e94",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 8.57,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,141 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d createCommandOpts();\n     Options printOpts \u003d createPrintOpts(opts);\n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n     if (args[0].equals(\"-help\")) {\n       printHelpMessage(printOpts);\n       return 0;\n     }\n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     boolean getAMContainerLogs \u003d false;\n     boolean showMetaInfo \u003d false;\n     boolean nodesList \u003d false;\n     String[] logFiles \u003d null;\n     List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n     String localDir \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n       getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n       showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n       nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n       localDir \u003d commandLine.getOptionValue(OUT_OPTION);\n       if (getAMContainerLogs) {\n         try {\n           amContainersList \u003d parseAMContainer(commandLine, printOpts);\n         } catch (NumberFormatException ex) {\n           System.err.println(ex.getMessage());\n           return -1;\n         }\n       }\n       if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n         logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n       }\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n     try {\n       appId \u003d ConverterUtils.toApplicationId(appIdStr);\n     } catch (Exception e) {\n       System.err.println(\"Invalid ApplicationId specified\");\n       return -1;\n     }\n \n     LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n     logCliHelper.setConf(getConf());\n \n     YarnApplicationState appState \u003d YarnApplicationState.NEW;\n     ApplicationReport appReport \u003d null;\n     try {\n       appReport \u003d getApplicationReport(appId);\n       appState \u003d appReport.getYarnApplicationState();\n       if (appState \u003d\u003d YarnApplicationState.NEW\n           || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n           || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n         System.err.println(\"Logs are not avaiable right now.\");\n         return -1;\n       }\n     } catch (IOException | YarnException e) {\n       // If we can not get appReport from either RM or ATS\n       // We will assume that this app has already finished.\n       appState \u003d YarnApplicationState.FINISHED;\n       System.err.println(\"Unable to get ApplicationState.\"\n           + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d guessAppOwner(appReport, appId);\n       if (appOwner \u003d\u003d null) {\n         System.err.println(\"Can not find the appOwner. \"\n             + \"Please specify the correct appOwner\");\n         System.err.println(\"Could not locate application logs for \" + appId);\n         return -1;\n       }\n     }\n \n+    List\u003cString\u003e logs \u003d new ArrayList\u003cString\u003e();\n+    if (fetchAllLogFiles(logFiles)) {\n+      logs.add(\".*\");\n+    } else if (logFiles !\u003d null \u0026\u0026 logFiles.length \u003e 0) {\n+      logs \u003d Arrays.asList(logFiles);\n+    }\n+\n     ContainerLogsRequest request \u003d new ContainerLogsRequest(appId,\n-        isApplicationFinished(appState), appOwner,\n-        nodeAddress, null, containerIdStr);\n+        isApplicationFinished(appState), appOwner, nodeAddress, null,\n+        containerIdStr, localDir, logs);\n \n     if (showMetaInfo) {\n       return showMetaInfo(request, logCliHelper);\n     }\n \n     if (nodesList) {\n       return showNodeLists(request, logCliHelper);\n     }\n \n     // To get am logs\n     if (getAMContainerLogs) {\n       return fetchAMContainerLogs(request, amContainersList,\n-          logFiles, logCliHelper, localDir);\n+          logCliHelper);\n     }\n \n     int resultCode \u003d 0;\n     if (containerIdStr !\u003d null) {\n       ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n       if (!containerId.getApplicationAttemptId().getApplicationId()\n           .equals(appId)) {\n         System.err.println(\"The Application:\" + appId\n             + \" does not have the container:\" + containerId);\n         return -1;\n       }\n-      return fetchContainerLogs(request, logFiles,\n-          logCliHelper, localDir);\n+      return fetchContainerLogs(request, logCliHelper);\n     } else {\n       if (nodeAddress \u003d\u003d null) {\n-        resultCode \u003d fetchApplicationLogs(appId, appOwner,\n-            logCliHelper, localDir);\n+        resultCode \u003d fetchApplicationLogs(request, logCliHelper);\n       } else {\n         System.err.println(\"Should at least provide ContainerId!\");\n         printHelpMessage(printOpts);\n         resultCode \u003d -1;\n       }\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d createCommandOpts();\n    Options printOpts \u003d createPrintOpts(opts);\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n    if (args[0].equals(\"-help\")) {\n      printHelpMessage(printOpts);\n      return 0;\n    }\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    boolean getAMContainerLogs \u003d false;\n    boolean showMetaInfo \u003d false;\n    boolean nodesList \u003d false;\n    String[] logFiles \u003d null;\n    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n    String localDir \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n      showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n      nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n      localDir \u003d commandLine.getOptionValue(OUT_OPTION);\n      if (getAMContainerLogs) {\n        try {\n          amContainersList \u003d parseAMContainer(commandLine, printOpts);\n        } catch (NumberFormatException ex) {\n          System.err.println(ex.getMessage());\n          return -1;\n        }\n      }\n      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n      }\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n\n    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n    ApplicationReport appReport \u003d null;\n    try {\n      appReport \u003d getApplicationReport(appId);\n      appState \u003d appReport.getYarnApplicationState();\n      if (appState \u003d\u003d YarnApplicationState.NEW\n          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n        System.err.println(\"Logs are not avaiable right now.\");\n        return -1;\n      }\n    } catch (IOException | YarnException e) {\n      // If we can not get appReport from either RM or ATS\n      // We will assume that this app has already finished.\n      appState \u003d YarnApplicationState.FINISHED;\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d guessAppOwner(appReport, appId);\n      if (appOwner \u003d\u003d null) {\n        System.err.println(\"Can not find the appOwner. \"\n            + \"Please specify the correct appOwner\");\n        System.err.println(\"Could not locate application logs for \" + appId);\n        return -1;\n      }\n    }\n\n    List\u003cString\u003e logs \u003d new ArrayList\u003cString\u003e();\n    if (fetchAllLogFiles(logFiles)) {\n      logs.add(\".*\");\n    } else if (logFiles !\u003d null \u0026\u0026 logFiles.length \u003e 0) {\n      logs \u003d Arrays.asList(logFiles);\n    }\n\n    ContainerLogsRequest request \u003d new ContainerLogsRequest(appId,\n        isApplicationFinished(appState), appOwner, nodeAddress, null,\n        containerIdStr, localDir, logs);\n\n    if (showMetaInfo) {\n      return showMetaInfo(request, logCliHelper);\n    }\n\n    if (nodesList) {\n      return showNodeLists(request, logCliHelper);\n    }\n\n    // To get am logs\n    if (getAMContainerLogs) {\n      return fetchAMContainerLogs(request, amContainersList,\n          logCliHelper);\n    }\n\n    int resultCode \u003d 0;\n    if (containerIdStr !\u003d null) {\n      ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n      if (!containerId.getApplicationAttemptId().getApplicationId()\n          .equals(appId)) {\n        System.err.println(\"The Application:\" + appId\n            + \" does not have the container:\" + containerId);\n        return -1;\n      }\n      return fetchContainerLogs(request, logCliHelper);\n    } else {\n      if (nodeAddress \u003d\u003d null) {\n        resultCode \u003d fetchApplicationLogs(request, logCliHelper);\n      } else {\n        System.err.println(\"Should at least provide ContainerId!\");\n        printHelpMessage(printOpts);\n        resultCode \u003d -1;\n      }\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "ef1757790d89cc72f88f5330761b1c8901c59e94": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4913. Yarn logs should take a -out option to write to a directory. Contributed by Xuan Gong.\n",
      "commitDate": "18/05/16 10:14 AM",
      "commitName": "ef1757790d89cc72f88f5330761b1c8901c59e94",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "14/05/16 12:19 PM",
      "commitNameOld": "7be53b65f95dae89c760cde354b42f15f5ee3b5f",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 3.91,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,136 @@\n   public int run(String[] args) throws Exception {\n-\n     Options opts \u003d createCommandOpts();\n-\n     Options printOpts \u003d createPrintOpts(opts);\n-\n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n     if (args[0].equals(\"-help\")) {\n       printHelpMessage(printOpts);\n       return 0;\n     }\n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     boolean getAMContainerLogs \u003d false;\n     boolean showMetaInfo \u003d false;\n     boolean nodesList \u003d false;\n     String[] logFiles \u003d null;\n     List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n+    String localDir \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n       getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n       showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n       nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n+      localDir \u003d commandLine.getOptionValue(OUT_OPTION);\n       if (getAMContainerLogs) {\n         try {\n           amContainersList \u003d parseAMContainer(commandLine, printOpts);\n         } catch (NumberFormatException ex) {\n           System.err.println(ex.getMessage());\n           return -1;\n         }\n       }\n       if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n         logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n       }\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n     try {\n       appId \u003d ConverterUtils.toApplicationId(appIdStr);\n     } catch (Exception e) {\n       System.err.println(\"Invalid ApplicationId specified\");\n       return -1;\n     }\n \n     LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n     logCliHelper.setConf(getConf());\n \n-    boolean appStateObtainedSuccessfully \u003d true;\n     YarnApplicationState appState \u003d YarnApplicationState.NEW;\n     ApplicationReport appReport \u003d null;\n     try {\n       appReport \u003d getApplicationReport(appId);\n       appState \u003d appReport.getYarnApplicationState();\n       if (appState \u003d\u003d YarnApplicationState.NEW\n           || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n           || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n         System.err.println(\"Logs are not avaiable right now.\");\n         return -1;\n       }\n     } catch (IOException | YarnException e) {\n-      appStateObtainedSuccessfully \u003d false;\n+      // If we can not get appReport from either RM or ATS\n+      // We will assume that this app has already finished.\n+      appState \u003d YarnApplicationState.FINISHED;\n       System.err.println(\"Unable to get ApplicationState.\"\n           + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d guessAppOwner(appReport, appId);\n       if (appOwner \u003d\u003d null) {\n         System.err.println(\"Can not find the appOwner. \"\n             + \"Please specify the correct appOwner\");\n         System.err.println(\"Could not locate application logs for \" + appId);\n         return -1;\n       }\n     }\n \n+    ContainerLogsRequest request \u003d new ContainerLogsRequest(appId,\n+        isApplicationFinished(appState), appOwner,\n+        nodeAddress, null, containerIdStr);\n+\n     if (showMetaInfo) {\n-      return showMetaInfo(appState, appStateObtainedSuccessfully,\n-          logCliHelper, appId, containerIdStr, nodeAddress, appOwner);\n+      return showMetaInfo(request, logCliHelper);\n     }\n \n     if (nodesList) {\n-      return showNodeLists(appState, appStateObtainedSuccessfully,\n-          logCliHelper, appId, appOwner);\n+      return showNodeLists(request, logCliHelper);\n     }\n+\n     // To get am logs\n     if (getAMContainerLogs) {\n-      return fetchAMContainerLogs(logFiles, appState, appId, appOwner,\n-          amContainersList, logCliHelper);\n+      return fetchAMContainerLogs(request, amContainersList,\n+          logFiles, logCliHelper, localDir);\n     }\n \n     int resultCode \u003d 0;\n     if (containerIdStr !\u003d null) {\n       ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n       if (!containerId.getApplicationAttemptId().getApplicationId()\n           .equals(appId)) {\n         System.err.println(\"The Application:\" + appId\n             + \" does not have the container:\" + containerId);\n         return -1;\n       }\n-      return fetchContainerLogs(appState, appStateObtainedSuccessfully,\n-          logFiles, appOwner, nodeAddress, containerId, logCliHelper);\n+      return fetchContainerLogs(request, logFiles,\n+          logCliHelper, localDir);\n     } else {\n       if (nodeAddress \u003d\u003d null) {\n-        resultCode \u003d\n-            logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n-        if (resultCode \u003d\u003d -1) {\n-          System.err.println(\"Can not find the logs for the application: \"\n-              + appId + \" with the appOwner: \" + appOwner);\n-        }\n+        resultCode \u003d fetchApplicationLogs(appId, appOwner,\n+            logCliHelper, localDir);\n       } else {\n         System.err.println(\"Should at least provide ContainerId!\");\n         printHelpMessage(printOpts);\n         resultCode \u003d -1;\n       }\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d createCommandOpts();\n    Options printOpts \u003d createPrintOpts(opts);\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n    if (args[0].equals(\"-help\")) {\n      printHelpMessage(printOpts);\n      return 0;\n    }\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    boolean getAMContainerLogs \u003d false;\n    boolean showMetaInfo \u003d false;\n    boolean nodesList \u003d false;\n    String[] logFiles \u003d null;\n    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n    String localDir \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n      showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n      nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n      localDir \u003d commandLine.getOptionValue(OUT_OPTION);\n      if (getAMContainerLogs) {\n        try {\n          amContainersList \u003d parseAMContainer(commandLine, printOpts);\n        } catch (NumberFormatException ex) {\n          System.err.println(ex.getMessage());\n          return -1;\n        }\n      }\n      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n      }\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n\n    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n    ApplicationReport appReport \u003d null;\n    try {\n      appReport \u003d getApplicationReport(appId);\n      appState \u003d appReport.getYarnApplicationState();\n      if (appState \u003d\u003d YarnApplicationState.NEW\n          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n        System.err.println(\"Logs are not avaiable right now.\");\n        return -1;\n      }\n    } catch (IOException | YarnException e) {\n      // If we can not get appReport from either RM or ATS\n      // We will assume that this app has already finished.\n      appState \u003d YarnApplicationState.FINISHED;\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d guessAppOwner(appReport, appId);\n      if (appOwner \u003d\u003d null) {\n        System.err.println(\"Can not find the appOwner. \"\n            + \"Please specify the correct appOwner\");\n        System.err.println(\"Could not locate application logs for \" + appId);\n        return -1;\n      }\n    }\n\n    ContainerLogsRequest request \u003d new ContainerLogsRequest(appId,\n        isApplicationFinished(appState), appOwner,\n        nodeAddress, null, containerIdStr);\n\n    if (showMetaInfo) {\n      return showMetaInfo(request, logCliHelper);\n    }\n\n    if (nodesList) {\n      return showNodeLists(request, logCliHelper);\n    }\n\n    // To get am logs\n    if (getAMContainerLogs) {\n      return fetchAMContainerLogs(request, amContainersList,\n          logFiles, logCliHelper, localDir);\n    }\n\n    int resultCode \u003d 0;\n    if (containerIdStr !\u003d null) {\n      ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n      if (!containerId.getApplicationAttemptId().getApplicationId()\n          .equals(appId)) {\n        System.err.println(\"The Application:\" + appId\n            + \" does not have the container:\" + containerId);\n        return -1;\n      }\n      return fetchContainerLogs(request, logFiles,\n          logCliHelper, localDir);\n    } else {\n      if (nodeAddress \u003d\u003d null) {\n        resultCode \u003d fetchApplicationLogs(appId, appOwner,\n            logCliHelper, localDir);\n      } else {\n        System.err.println(\"Should at least provide ContainerId!\");\n        printHelpMessage(printOpts);\n        resultCode \u003d -1;\n      }\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "87f5e351337a905af5215af76c72b9312616cd4f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4842. Fixed \"yarn logs\" command to guess (and thus not require) the appOwner argument when viewing another user\u0027s logs. Contributed by Ram Venkatesh and Xuan Gong.\n",
      "commitDate": "09/05/16 10:41 PM",
      "commitName": "87f5e351337a905af5215af76c72b9312616cd4f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "04/05/16 2:16 PM",
      "commitNameOld": "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.35,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,137 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d createCommandOpts();\n \n     Options printOpts \u003d createPrintOpts(opts);\n \n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n     if (args[0].equals(\"-help\")) {\n       printHelpMessage(printOpts);\n       return 0;\n     }\n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     boolean getAMContainerLogs \u003d false;\n     boolean showMetaInfo \u003d false;\n     boolean nodesList \u003d false;\n     String[] logFiles \u003d null;\n     List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n       getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n       showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n       nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n       if (getAMContainerLogs) {\n         try {\n           amContainersList \u003d parseAMContainer(commandLine, printOpts);\n         } catch (NumberFormatException ex) {\n           System.err.println(ex.getMessage());\n           return -1;\n         }\n       }\n       if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n         logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n       }\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n     try {\n       appId \u003d ConverterUtils.toApplicationId(appIdStr);\n     } catch (Exception e) {\n       System.err.println(\"Invalid ApplicationId specified\");\n       return -1;\n     }\n \n     LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n     logCliHelper.setConf(getConf());\n \n-    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n-      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n-    }\n-\n     boolean appStateObtainedSuccessfully \u003d true;\n     YarnApplicationState appState \u003d YarnApplicationState.NEW;\n+    ApplicationReport appReport \u003d null;\n     try {\n-      appState \u003d getApplicationState(appId);\n+      appReport \u003d getApplicationReport(appId);\n+      appState \u003d appReport.getYarnApplicationState();\n       if (appState \u003d\u003d YarnApplicationState.NEW\n           || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n           || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n         System.err.println(\"Logs are not avaiable right now.\");\n         return -1;\n       }\n     } catch (IOException | YarnException e) {\n       appStateObtainedSuccessfully \u003d false;\n       System.err.println(\"Unable to get ApplicationState.\"\n           + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n+    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n+      appOwner \u003d guessAppOwner(appReport, appId);\n+      if (appOwner \u003d\u003d null) {\n+        System.err.println(\"Can not find the appOwner. \"\n+            + \"Please specify the correct appOwner\");\n+        System.err.println(\"Could not locate application logs for \" + appId);\n+        return -1;\n+      }\n+    }\n+\n     if (showMetaInfo) {\n       return showMetaInfo(appState, appStateObtainedSuccessfully,\n           logCliHelper, appId, containerIdStr, nodeAddress, appOwner);\n     }\n \n     if (nodesList) {\n       return showNodeLists(appState, appStateObtainedSuccessfully,\n           logCliHelper, appId, appOwner);\n     }\n     // To get am logs\n     if (getAMContainerLogs) {\n       return fetchAMContainerLogs(logFiles, appState, appId, appOwner,\n           amContainersList, logCliHelper);\n     }\n \n     int resultCode \u003d 0;\n     if (containerIdStr !\u003d null) {\n       ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n       if (!containerId.getApplicationAttemptId().getApplicationId()\n           .equals(appId)) {\n         System.err.println(\"The Application:\" + appId\n             + \" does not have the container:\" + containerId);\n         return -1;\n       }\n       return fetchContainerLogs(appState, appStateObtainedSuccessfully,\n           logFiles, appOwner, nodeAddress, containerId, logCliHelper);\n     } else {\n       if (nodeAddress \u003d\u003d null) {\n         resultCode \u003d\n             logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n+        if (resultCode \u003d\u003d -1) {\n+          System.err.println(\"Can not find the logs for the application: \"\n+              + appId + \" with the appOwner: \" + appOwner);\n+        }\n       } else {\n         System.err.println(\"Should at least provide ContainerId!\");\n         printHelpMessage(printOpts);\n         resultCode \u003d -1;\n       }\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d createCommandOpts();\n\n    Options printOpts \u003d createPrintOpts(opts);\n\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n    if (args[0].equals(\"-help\")) {\n      printHelpMessage(printOpts);\n      return 0;\n    }\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    boolean getAMContainerLogs \u003d false;\n    boolean showMetaInfo \u003d false;\n    boolean nodesList \u003d false;\n    String[] logFiles \u003d null;\n    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n      showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n      nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n      if (getAMContainerLogs) {\n        try {\n          amContainersList \u003d parseAMContainer(commandLine, printOpts);\n        } catch (NumberFormatException ex) {\n          System.err.println(ex.getMessage());\n          return -1;\n        }\n      }\n      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n      }\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n\n    boolean appStateObtainedSuccessfully \u003d true;\n    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n    ApplicationReport appReport \u003d null;\n    try {\n      appReport \u003d getApplicationReport(appId);\n      appState \u003d appReport.getYarnApplicationState();\n      if (appState \u003d\u003d YarnApplicationState.NEW\n          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n        System.err.println(\"Logs are not avaiable right now.\");\n        return -1;\n      }\n    } catch (IOException | YarnException e) {\n      appStateObtainedSuccessfully \u003d false;\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d guessAppOwner(appReport, appId);\n      if (appOwner \u003d\u003d null) {\n        System.err.println(\"Can not find the appOwner. \"\n            + \"Please specify the correct appOwner\");\n        System.err.println(\"Could not locate application logs for \" + appId);\n        return -1;\n      }\n    }\n\n    if (showMetaInfo) {\n      return showMetaInfo(appState, appStateObtainedSuccessfully,\n          logCliHelper, appId, containerIdStr, nodeAddress, appOwner);\n    }\n\n    if (nodesList) {\n      return showNodeLists(appState, appStateObtainedSuccessfully,\n          logCliHelper, appId, appOwner);\n    }\n    // To get am logs\n    if (getAMContainerLogs) {\n      return fetchAMContainerLogs(logFiles, appState, appId, appOwner,\n          amContainersList, logCliHelper);\n    }\n\n    int resultCode \u003d 0;\n    if (containerIdStr !\u003d null) {\n      ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n      if (!containerId.getApplicationAttemptId().getApplicationId()\n          .equals(appId)) {\n        System.err.println(\"The Application:\" + appId\n            + \" does not have the container:\" + containerId);\n        return -1;\n      }\n      return fetchContainerLogs(appState, appStateObtainedSuccessfully,\n          logFiles, appOwner, nodeAddress, containerId, logCliHelper);\n    } else {\n      if (nodeAddress \u003d\u003d null) {\n        resultCode \u003d\n            logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n        if (resultCode \u003d\u003d -1) {\n          System.err.println(\"Can not find the logs for the application: \"\n              + appId + \" with the appOwner: \" + appOwner);\n        }\n      } else {\n        System.err.println(\"Should at least provide ContainerId!\");\n        printHelpMessage(printOpts);\n        resultCode \u003d -1;\n      }\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4905. Improved \"yarn logs\" command-line to optionally show log metadata also. Contributed by Xuan Gong.\n",
      "commitDate": "04/05/16 2:16 PM",
      "commitName": "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/04/16 3:26 AM",
      "commitNameOld": "66b07d83740a2ec3e6bfb2bfd064863bae37a1b5",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 7.45,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,269 +1,125 @@\n   public int run(String[] args) throws Exception {\n \n-    Options opts \u003d new Options();\n-    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n-    Option appIdOpt \u003d\n-        new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n-    appIdOpt.setRequired(true);\n-    opts.addOption(appIdOpt);\n-    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId. \"\n-        + \"By default, it will only print syslog if the application is runing.\"\n-        + \" Work with -logFiles to get other logs.\");\n-    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n-      + \"nodename:port\");\n-    opts.addOption(APP_OWNER_OPTION, true,\n-      \"AppOwner (assumed to be current user if not specified)\");\n-    Option amOption \u003d new Option(AM_CONTAINER_OPTION, true, \n-      \"Prints the AM Container logs for this application. \"\n-      + \"Specify comma-separated value to get logs for related AM Container. \"\n-      + \"For example, If we specify -am 1,2, we will get the logs for \"\n-      + \"the first AM Container as well as the second AM Container. \"\n-      + \"To get logs for all AM Containers, use -am ALL. \"\n-      + \"To get logs for the latest AM Container, use -am -1. \"\n-      + \"By default, it will only print out syslog. Work with -logFiles \"\n-      + \"to get other logs\");\n-    amOption.setValueSeparator(\u0027,\u0027);\n-    amOption.setArgs(Option.UNLIMITED_VALUES);\n-    amOption.setArgName(\"AM Containers\");\n-    opts.addOption(amOption);\n-    Option logFileOpt \u003d new Option(CONTAINER_LOG_FILES, true,\n-      \"Work with -am/-containerId and specify comma-separated value \"\n-        + \"to get specified container log files. Use \\\"ALL\\\" to fetch all the \"\n-        + \"log files for the container.\");\n-    logFileOpt.setValueSeparator(\u0027,\u0027);\n-    logFileOpt.setArgs(Option.UNLIMITED_VALUES);\n-    logFileOpt.setArgName(\"Log File Name\");\n-    opts.addOption(logFileOpt);\n+    Options opts \u003d createCommandOpts();\n \n-    opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n-    opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n-    opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n-    opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n-    opts.getOption(AM_CONTAINER_OPTION).setArgName(\"AM Containers\");\n-\n-    Options printOpts \u003d new Options();\n-    printOpts.addOption(opts.getOption(HELP_CMD));\n-    printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n-    printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n-    printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n-    printOpts.addOption(opts.getOption(AM_CONTAINER_OPTION));\n-    printOpts.addOption(opts.getOption(CONTAINER_LOG_FILES));\n+    Options printOpts \u003d createPrintOpts(opts);\n \n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n     if (args[0].equals(\"-help\")) {\n       printHelpMessage(printOpts);\n       return 0;\n     }\n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     boolean getAMContainerLogs \u003d false;\n+    boolean showMetaInfo \u003d false;\n+    boolean nodesList \u003d false;\n     String[] logFiles \u003d null;\n     List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n       getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n+      showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n+      nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n       if (getAMContainerLogs) {\n-        String[] amContainers \u003d commandLine.getOptionValues(AM_CONTAINER_OPTION);\n-        for (String am : amContainers) {\n-          boolean errorInput \u003d false;\n-          if (!am.trim().equalsIgnoreCase(\"ALL\")) {\n-            try {\n-              int id \u003d Integer.parseInt(am.trim());\n-              if (id !\u003d -1 \u0026\u0026 id \u003c\u003d 0) {\n-                errorInput \u003d true;\n-              }\n-            } catch (NumberFormatException ex) {\n-              errorInput \u003d true;\n-            }\n-            if (errorInput) {\n-              System.err.println(\n-                \"Invalid input for option -am. Valid inputs are \u0027ALL\u0027, -1 \"\n-                + \"and any other integer which is larger than 0.\");\n-              printHelpMessage(printOpts);\n-              return -1;\n-            }\n-            amContainersList.add(am.trim());\n-          } else {\n-            amContainersList.add(\"ALL\");\n-            break;\n-          }\n+        try {\n+          amContainersList \u003d parseAMContainer(commandLine, printOpts);\n+        } catch (NumberFormatException ex) {\n+          System.err.println(ex.getMessage());\n+          return -1;\n         }\n       }\n       if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n         logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n       }\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n     try {\n       appId \u003d ConverterUtils.toApplicationId(appIdStr);\n     } catch (Exception e) {\n       System.err.println(\"Invalid ApplicationId specified\");\n       return -1;\n     }\n \n     LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n     logCliHelper.setConf(getConf());\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n \n-    boolean appStateKnown \u003d true;\n+    boolean appStateObtainedSuccessfully \u003d true;\n     YarnApplicationState appState \u003d YarnApplicationState.NEW;\n     try {\n       appState \u003d getApplicationState(appId);\n       if (appState \u003d\u003d YarnApplicationState.NEW\n           || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n           || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n-        System.out.println(\"Logs are not avaiable right now.\");\n+        System.err.println(\"Logs are not avaiable right now.\");\n         return -1;\n       }\n     } catch (IOException | YarnException e) {\n-      appStateKnown \u003d false;\n+      appStateObtainedSuccessfully \u003d false;\n       System.err.println(\"Unable to get ApplicationState.\"\n           + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n+    if (showMetaInfo) {\n+      return showMetaInfo(appState, appStateObtainedSuccessfully,\n+          logCliHelper, appId, containerIdStr, nodeAddress, appOwner);\n+    }\n+\n+    if (nodesList) {\n+      return showNodeLists(appState, appStateObtainedSuccessfully,\n+          logCliHelper, appId, appOwner);\n+    }\n     // To get am logs\n     if (getAMContainerLogs) {\n-      // if we do not specify the value for CONTAINER_LOG_FILES option,\n-      // we will only output syslog\n-      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n-        logFiles \u003d new String[] { \"syslog\" };\n-      }\n-      // If the application is running, we will call the RM WebService\n-      // to get the AppAttempts which includes the nodeHttpAddress\n-      // and containerId for all the AM Containers.\n-      // After that, we will call NodeManager webService to get the\n-      // related logs\n-      if (appState \u003d\u003d YarnApplicationState.ACCEPTED\n-          || appState \u003d\u003d YarnApplicationState.RUNNING) {\n-        return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n-          logFiles, logCliHelper, appOwner, false);\n-      } else {\n-        // If the application is in the final state, we will call RM webservice\n-        // to get all AppAttempts information first. If we get nothing,\n-        // we will try to call AHS webservice to get related AppAttempts\n-        // which includes nodeAddress for the AM Containers.\n-        // After that, we will use nodeAddress and containerId\n-        // to get logs from HDFS directly.\n-        if (getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n-          YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n-          return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n-            logFiles, logCliHelper, appOwner, true);\n-        } else {\n-          System.out\n-            .println(\n-                \"Can not get AMContainers logs for the application:\" + appId);\n-          System.out.println(\"This application:\" + appId + \" is finished.\"\n-              + \" Please enable the application history service. Or Using \"\n-              + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n-              + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n-          return -1;\n-        }\n-      }\n+      return fetchAMContainerLogs(logFiles, appState, appId, appOwner,\n+          amContainersList, logCliHelper);\n     }\n \n     int resultCode \u003d 0;\n     if (containerIdStr !\u003d null) {\n-      // if we provide the node address and the application is in the final\n-      // state, we could directly get logs from HDFS.\n-      if (nodeAddress !\u003d null \u0026\u0026 (!appStateKnown ||\n-          isApplicationFinished(appState))) {\n-        // if user specified \"ALL\" as the logFiles param, pass null\n-        // to logCliHelper so that it fetches all the logs\n-        List\u003cString\u003e logs;\n-        if (logFiles \u003d\u003d null) {\n-          logs \u003d null;\n-        } else if (fetchAllLogFiles(logFiles)) {\n-          logs \u003d null;\n-        } else {\n-          logs \u003d Arrays.asList(logFiles);\n-        }\n-        return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n-            containerIdStr, nodeAddress, appOwner, logs);\n+      ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n+      if (!containerId.getApplicationAttemptId().getApplicationId()\n+          .equals(appId)) {\n+        System.err.println(\"The Application:\" + appId\n+            + \" does not have the container:\" + containerId);\n+        return -1;\n       }\n-      String nodeHttpAddress \u003d null;\n-      String nodeId \u003d null;\n-      try {\n-        // If the nodeAddress is not provided, we will try to get\n-        // the ContainerReport. In the containerReport, we could get\n-        // nodeAddress and nodeHttpAddress\n-        ContainerReport report \u003d getContainerReport(containerIdStr);\n-        nodeHttpAddress \u003d\n-            report.getNodeHttpAddress().replaceFirst(\n-              WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n-        nodeId \u003d report.getAssignedNode().toString();\n-      } catch (IOException | YarnException ex) {\n-        if (!appStateKnown || isApplicationFinished(appState)) {\n-          String [] requestedLogFiles \u003d logFiles;\n-          if(fetchAllLogFiles(logFiles)) {\n-            requestedLogFiles \u003d null;\n-          }\n-          return printContainerLogsForFinishedApplicationWithoutNodeId(\n-              appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n-              appOwner);\n-        } else if (!isApplicationFinished(appState)) {\n-          System.err.println(\"Unable to get logs for this container:\"\n-              + containerIdStr + \"for the application:\" + appId);\n-          System.out.println(\"The application: \" + appId + \" is still running, \"\n-              + \"and we can not get Container report for the container: \"\n-              + containerIdStr +\". Please try later or after the application \"\n-              + \"finishes.\");\n-          return -1;\n-        }\n-      }\n-      // If the application is not in the final state,\n-      // we will provide the NodeHttpAddress and get the container logs\n-      // by calling NodeManager webservice.\n-      if (!isApplicationFinished(appState)) {\n-        if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n-          logFiles \u003d new String[] {\"syslog\"};\n-        }\n-        printContainerLogsFromRunningApplication(getConf(), appIdStr,\n-            containerIdStr, nodeHttpAddress, nodeId, logFiles, logCliHelper,\n-            appOwner);\n-      } else {\n-        String[] requestedLogFiles \u003d logFiles;\n-        if(fetchAllLogFiles(logFiles)) {\n-          requestedLogFiles \u003d null;\n-        }\n-        // If the application is in the final state, we will directly\n-        // get the container logs from HDFS.\n-        printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n-            nodeId, requestedLogFiles, logCliHelper, appOwner);\n-      }\n-      return resultCode;\n+      return fetchContainerLogs(appState, appStateObtainedSuccessfully,\n+          logFiles, appOwner, nodeAddress, containerId, logCliHelper);\n     } else {\n       if (nodeAddress \u003d\u003d null) {\n         resultCode \u003d\n             logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n       } else {\n-        System.out.println(\"Should at least provide ContainerId!\");\n+        System.err.println(\"Should at least provide ContainerId!\");\n         printHelpMessage(printOpts);\n         resultCode \u003d -1;\n       }\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d createCommandOpts();\n\n    Options printOpts \u003d createPrintOpts(opts);\n\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n    if (args[0].equals(\"-help\")) {\n      printHelpMessage(printOpts);\n      return 0;\n    }\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    boolean getAMContainerLogs \u003d false;\n    boolean showMetaInfo \u003d false;\n    boolean nodesList \u003d false;\n    String[] logFiles \u003d null;\n    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n      showMetaInfo \u003d commandLine.hasOption(SHOW_META_INFO);\n      nodesList \u003d commandLine.hasOption(LIST_NODES_OPTION);\n      if (getAMContainerLogs) {\n        try {\n          amContainersList \u003d parseAMContainer(commandLine, printOpts);\n        } catch (NumberFormatException ex) {\n          System.err.println(ex.getMessage());\n          return -1;\n        }\n      }\n      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n      }\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n\n    boolean appStateObtainedSuccessfully \u003d true;\n    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n    try {\n      appState \u003d getApplicationState(appId);\n      if (appState \u003d\u003d YarnApplicationState.NEW\n          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n        System.err.println(\"Logs are not avaiable right now.\");\n        return -1;\n      }\n    } catch (IOException | YarnException e) {\n      appStateObtainedSuccessfully \u003d false;\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    if (showMetaInfo) {\n      return showMetaInfo(appState, appStateObtainedSuccessfully,\n          logCliHelper, appId, containerIdStr, nodeAddress, appOwner);\n    }\n\n    if (nodesList) {\n      return showNodeLists(appState, appStateObtainedSuccessfully,\n          logCliHelper, appId, appOwner);\n    }\n    // To get am logs\n    if (getAMContainerLogs) {\n      return fetchAMContainerLogs(logFiles, appState, appId, appOwner,\n          amContainersList, logCliHelper);\n    }\n\n    int resultCode \u003d 0;\n    if (containerIdStr !\u003d null) {\n      ContainerId containerId \u003d ContainerId.fromString(containerIdStr);\n      if (!containerId.getApplicationAttemptId().getApplicationId()\n          .equals(appId)) {\n        System.err.println(\"The Application:\" + appId\n            + \" does not have the container:\" + containerId);\n        return -1;\n      }\n      return fetchContainerLogs(appState, appStateObtainedSuccessfully,\n          logFiles, appOwner, nodeAddress, containerId, logCliHelper);\n    } else {\n      if (nodeAddress \u003d\u003d null) {\n        resultCode \u003d\n            logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n      } else {\n        System.err.println(\"Should at least provide ContainerId!\");\n        printHelpMessage(printOpts);\n        resultCode \u003d -1;\n      }\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "66b07d83740a2ec3e6bfb2bfd064863bae37a1b5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4966. Improve yarn logs to fetch container logs without specifying nodeId. Contributed by Xuan Gong.\n",
      "commitDate": "27/04/16 3:26 AM",
      "commitName": "66b07d83740a2ec3e6bfb2bfd064863bae37a1b5",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "15/09/15 2:36 PM",
      "commitNameOld": "34ef1a092bcab369bb845481efffb8c47adef53a",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 224.53,
      "commitsBetweenForRepo": 1508,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,257 +1,269 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n     Option appIdOpt \u003d\n         new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n     appIdOpt.setRequired(true);\n     opts.addOption(appIdOpt);\n     opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId. \"\n         + \"By default, it will only print syslog if the application is runing.\"\n         + \" Work with -logFiles to get other logs.\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n       + \"nodename:port\");\n     opts.addOption(APP_OWNER_OPTION, true,\n       \"AppOwner (assumed to be current user if not specified)\");\n     Option amOption \u003d new Option(AM_CONTAINER_OPTION, true, \n       \"Prints the AM Container logs for this application. \"\n       + \"Specify comma-separated value to get logs for related AM Container. \"\n       + \"For example, If we specify -am 1,2, we will get the logs for \"\n       + \"the first AM Container as well as the second AM Container. \"\n       + \"To get logs for all AM Containers, use -am ALL. \"\n       + \"To get logs for the latest AM Container, use -am -1. \"\n       + \"By default, it will only print out syslog. Work with -logFiles \"\n       + \"to get other logs\");\n     amOption.setValueSeparator(\u0027,\u0027);\n     amOption.setArgs(Option.UNLIMITED_VALUES);\n     amOption.setArgName(\"AM Containers\");\n     opts.addOption(amOption);\n     Option logFileOpt \u003d new Option(CONTAINER_LOG_FILES, true,\n       \"Work with -am/-containerId and specify comma-separated value \"\n         + \"to get specified container log files. Use \\\"ALL\\\" to fetch all the \"\n         + \"log files for the container.\");\n     logFileOpt.setValueSeparator(\u0027,\u0027);\n     logFileOpt.setArgs(Option.UNLIMITED_VALUES);\n     logFileOpt.setArgName(\"Log File Name\");\n     opts.addOption(logFileOpt);\n \n     opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n     opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n     opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n     opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n     opts.getOption(AM_CONTAINER_OPTION).setArgName(\"AM Containers\");\n \n     Options printOpts \u003d new Options();\n     printOpts.addOption(opts.getOption(HELP_CMD));\n     printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n     printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n     printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n     printOpts.addOption(opts.getOption(AM_CONTAINER_OPTION));\n     printOpts.addOption(opts.getOption(CONTAINER_LOG_FILES));\n \n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n     if (args[0].equals(\"-help\")) {\n       printHelpMessage(printOpts);\n       return 0;\n     }\n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     boolean getAMContainerLogs \u003d false;\n     String[] logFiles \u003d null;\n     List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n       getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n       if (getAMContainerLogs) {\n         String[] amContainers \u003d commandLine.getOptionValues(AM_CONTAINER_OPTION);\n         for (String am : amContainers) {\n           boolean errorInput \u003d false;\n           if (!am.trim().equalsIgnoreCase(\"ALL\")) {\n             try {\n               int id \u003d Integer.parseInt(am.trim());\n               if (id !\u003d -1 \u0026\u0026 id \u003c\u003d 0) {\n                 errorInput \u003d true;\n               }\n             } catch (NumberFormatException ex) {\n               errorInput \u003d true;\n             }\n             if (errorInput) {\n               System.err.println(\n                 \"Invalid input for option -am. Valid inputs are \u0027ALL\u0027, -1 \"\n                 + \"and any other integer which is larger than 0.\");\n               printHelpMessage(printOpts);\n               return -1;\n             }\n             amContainersList.add(am.trim());\n           } else {\n             amContainersList.add(\"ALL\");\n             break;\n           }\n         }\n       }\n       if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n         logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n       }\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n     try {\n       appId \u003d ConverterUtils.toApplicationId(appIdStr);\n     } catch (Exception e) {\n       System.err.println(\"Invalid ApplicationId specified\");\n       return -1;\n     }\n \n     LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n     logCliHelper.setConf(getConf());\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n \n+    boolean appStateKnown \u003d true;\n     YarnApplicationState appState \u003d YarnApplicationState.NEW;\n     try {\n       appState \u003d getApplicationState(appId);\n       if (appState \u003d\u003d YarnApplicationState.NEW\n           || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n           || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n         System.out.println(\"Logs are not avaiable right now.\");\n         return -1;\n       }\n     } catch (IOException | YarnException e) {\n+      appStateKnown \u003d false;\n       System.err.println(\"Unable to get ApplicationState.\"\n           + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n     // To get am logs\n     if (getAMContainerLogs) {\n       // if we do not specify the value for CONTAINER_LOG_FILES option,\n       // we will only output syslog\n       if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n         logFiles \u003d new String[] { \"syslog\" };\n       }\n       // If the application is running, we will call the RM WebService\n       // to get the AppAttempts which includes the nodeHttpAddress\n       // and containerId for all the AM Containers.\n       // After that, we will call NodeManager webService to get the\n       // related logs\n       if (appState \u003d\u003d YarnApplicationState.ACCEPTED\n           || appState \u003d\u003d YarnApplicationState.RUNNING) {\n         return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n           logFiles, logCliHelper, appOwner, false);\n       } else {\n         // If the application is in the final state, we will call RM webservice\n         // to get all AppAttempts information first. If we get nothing,\n         // we will try to call AHS webservice to get related AppAttempts\n         // which includes nodeAddress for the AM Containers.\n         // After that, we will use nodeAddress and containerId\n         // to get logs from HDFS directly.\n         if (getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n           YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n           return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n             logFiles, logCliHelper, appOwner, true);\n         } else {\n           System.out\n             .println(\n                 \"Can not get AMContainers logs for the application:\" + appId);\n           System.out.println(\"This application:\" + appId + \" is finished.\"\n               + \" Please enable the application history service. Or Using \"\n               + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n               + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n           return -1;\n         }\n       }\n     }\n \n     int resultCode \u003d 0;\n     if (containerIdStr !\u003d null) {\n       // if we provide the node address and the application is in the final\n       // state, we could directly get logs from HDFS.\n-      if (nodeAddress !\u003d null \u0026\u0026 isApplicationFinished(appState)) {\n+      if (nodeAddress !\u003d null \u0026\u0026 (!appStateKnown ||\n+          isApplicationFinished(appState))) {\n         // if user specified \"ALL\" as the logFiles param, pass null\n         // to logCliHelper so that it fetches all the logs\n         List\u003cString\u003e logs;\n         if (logFiles \u003d\u003d null) {\n           logs \u003d null;\n         } else if (fetchAllLogFiles(logFiles)) {\n           logs \u003d null;\n         } else {\n           logs \u003d Arrays.asList(logFiles);\n         }\n         return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n             containerIdStr, nodeAddress, appOwner, logs);\n       }\n+      String nodeHttpAddress \u003d null;\n+      String nodeId \u003d null;\n       try {\n         // If the nodeAddress is not provided, we will try to get\n         // the ContainerReport. In the containerReport, we could get\n         // nodeAddress and nodeHttpAddress\n         ContainerReport report \u003d getContainerReport(containerIdStr);\n-        String nodeHttpAddress \u003d\n+        nodeHttpAddress \u003d\n             report.getNodeHttpAddress().replaceFirst(\n               WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n-        String nodeId \u003d report.getAssignedNode().toString();\n-        // If the application is not in the final state,\n-        // we will provide the NodeHttpAddress and get the container logs\n-        // by calling NodeManager webservice.\n-        if (!isApplicationFinished(appState)) {\n-          if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n-            logFiles \u003d new String[] { \"syslog\" };\n-          }\n-          printContainerLogsFromRunningApplication(getConf(), appIdStr,\n-            containerIdStr, nodeHttpAddress, nodeId, logFiles, logCliHelper,\n-            appOwner);\n-        } else {\n+        nodeId \u003d report.getAssignedNode().toString();\n+      } catch (IOException | YarnException ex) {\n+        if (!appStateKnown || isApplicationFinished(appState)) {\n           String [] requestedLogFiles \u003d logFiles;\n           if(fetchAllLogFiles(logFiles)) {\n             requestedLogFiles \u003d null;\n           }\n-          // If the application is in the final state, we will directly\n-          // get the container logs from HDFS.\n-          printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n-            nodeId, requestedLogFiles, logCliHelper, appOwner);\n+          return printContainerLogsForFinishedApplicationWithoutNodeId(\n+              appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n+              appOwner);\n+        } else if (!isApplicationFinished(appState)) {\n+          System.err.println(\"Unable to get logs for this container:\"\n+              + containerIdStr + \"for the application:\" + appId);\n+          System.out.println(\"The application: \" + appId + \" is still running, \"\n+              + \"and we can not get Container report for the container: \"\n+              + containerIdStr +\". Please try later or after the application \"\n+              + \"finishes.\");\n+          return -1;\n         }\n-        return resultCode;\n-      } catch (IOException | YarnException ex) {\n-        System.err.println(\"Unable to get logs for this container:\"\n-            + containerIdStr + \"for the application:\" + appId);\n-        if (!getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n-          YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n-          System.out.println(\"Please enable the application history service. Or \");\n-        }\n-        System.out.println(\"Using \"\n-            + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n-            + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n-        return -1;\n       }\n+      // If the application is not in the final state,\n+      // we will provide the NodeHttpAddress and get the container logs\n+      // by calling NodeManager webservice.\n+      if (!isApplicationFinished(appState)) {\n+        if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n+          logFiles \u003d new String[] {\"syslog\"};\n+        }\n+        printContainerLogsFromRunningApplication(getConf(), appIdStr,\n+            containerIdStr, nodeHttpAddress, nodeId, logFiles, logCliHelper,\n+            appOwner);\n+      } else {\n+        String[] requestedLogFiles \u003d logFiles;\n+        if(fetchAllLogFiles(logFiles)) {\n+          requestedLogFiles \u003d null;\n+        }\n+        // If the application is in the final state, we will directly\n+        // get the container logs from HDFS.\n+        printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n+            nodeId, requestedLogFiles, logCliHelper, appOwner);\n+      }\n+      return resultCode;\n     } else {\n       if (nodeAddress \u003d\u003d null) {\n         resultCode \u003d\n             logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n       } else {\n         System.out.println(\"Should at least provide ContainerId!\");\n         printHelpMessage(printOpts);\n         resultCode \u003d -1;\n       }\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n    Option appIdOpt \u003d\n        new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n    appIdOpt.setRequired(true);\n    opts.addOption(appIdOpt);\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId. \"\n        + \"By default, it will only print syslog if the application is runing.\"\n        + \" Work with -logFiles to get other logs.\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n      + \"nodename:port\");\n    opts.addOption(APP_OWNER_OPTION, true,\n      \"AppOwner (assumed to be current user if not specified)\");\n    Option amOption \u003d new Option(AM_CONTAINER_OPTION, true, \n      \"Prints the AM Container logs for this application. \"\n      + \"Specify comma-separated value to get logs for related AM Container. \"\n      + \"For example, If we specify -am 1,2, we will get the logs for \"\n      + \"the first AM Container as well as the second AM Container. \"\n      + \"To get logs for all AM Containers, use -am ALL. \"\n      + \"To get logs for the latest AM Container, use -am -1. \"\n      + \"By default, it will only print out syslog. Work with -logFiles \"\n      + \"to get other logs\");\n    amOption.setValueSeparator(\u0027,\u0027);\n    amOption.setArgs(Option.UNLIMITED_VALUES);\n    amOption.setArgName(\"AM Containers\");\n    opts.addOption(amOption);\n    Option logFileOpt \u003d new Option(CONTAINER_LOG_FILES, true,\n      \"Work with -am/-containerId and specify comma-separated value \"\n        + \"to get specified container log files. Use \\\"ALL\\\" to fetch all the \"\n        + \"log files for the container.\");\n    logFileOpt.setValueSeparator(\u0027,\u0027);\n    logFileOpt.setArgs(Option.UNLIMITED_VALUES);\n    logFileOpt.setArgName(\"Log File Name\");\n    opts.addOption(logFileOpt);\n\n    opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n    opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n    opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n    opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n    opts.getOption(AM_CONTAINER_OPTION).setArgName(\"AM Containers\");\n\n    Options printOpts \u003d new Options();\n    printOpts.addOption(opts.getOption(HELP_CMD));\n    printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n    printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n    printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n    printOpts.addOption(opts.getOption(AM_CONTAINER_OPTION));\n    printOpts.addOption(opts.getOption(CONTAINER_LOG_FILES));\n\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n    if (args[0].equals(\"-help\")) {\n      printHelpMessage(printOpts);\n      return 0;\n    }\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    boolean getAMContainerLogs \u003d false;\n    String[] logFiles \u003d null;\n    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n      if (getAMContainerLogs) {\n        String[] amContainers \u003d commandLine.getOptionValues(AM_CONTAINER_OPTION);\n        for (String am : amContainers) {\n          boolean errorInput \u003d false;\n          if (!am.trim().equalsIgnoreCase(\"ALL\")) {\n            try {\n              int id \u003d Integer.parseInt(am.trim());\n              if (id !\u003d -1 \u0026\u0026 id \u003c\u003d 0) {\n                errorInput \u003d true;\n              }\n            } catch (NumberFormatException ex) {\n              errorInput \u003d true;\n            }\n            if (errorInput) {\n              System.err.println(\n                \"Invalid input for option -am. Valid inputs are \u0027ALL\u0027, -1 \"\n                + \"and any other integer which is larger than 0.\");\n              printHelpMessage(printOpts);\n              return -1;\n            }\n            amContainersList.add(am.trim());\n          } else {\n            amContainersList.add(\"ALL\");\n            break;\n          }\n        }\n      }\n      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n      }\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n\n    boolean appStateKnown \u003d true;\n    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n    try {\n      appState \u003d getApplicationState(appId);\n      if (appState \u003d\u003d YarnApplicationState.NEW\n          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n        System.out.println(\"Logs are not avaiable right now.\");\n        return -1;\n      }\n    } catch (IOException | YarnException e) {\n      appStateKnown \u003d false;\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    // To get am logs\n    if (getAMContainerLogs) {\n      // if we do not specify the value for CONTAINER_LOG_FILES option,\n      // we will only output syslog\n      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n        logFiles \u003d new String[] { \"syslog\" };\n      }\n      // If the application is running, we will call the RM WebService\n      // to get the AppAttempts which includes the nodeHttpAddress\n      // and containerId for all the AM Containers.\n      // After that, we will call NodeManager webService to get the\n      // related logs\n      if (appState \u003d\u003d YarnApplicationState.ACCEPTED\n          || appState \u003d\u003d YarnApplicationState.RUNNING) {\n        return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n          logFiles, logCliHelper, appOwner, false);\n      } else {\n        // If the application is in the final state, we will call RM webservice\n        // to get all AppAttempts information first. If we get nothing,\n        // we will try to call AHS webservice to get related AppAttempts\n        // which includes nodeAddress for the AM Containers.\n        // After that, we will use nodeAddress and containerId\n        // to get logs from HDFS directly.\n        if (getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n          YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n          return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n            logFiles, logCliHelper, appOwner, true);\n        } else {\n          System.out\n            .println(\n                \"Can not get AMContainers logs for the application:\" + appId);\n          System.out.println(\"This application:\" + appId + \" is finished.\"\n              + \" Please enable the application history service. Or Using \"\n              + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n              + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n          return -1;\n        }\n      }\n    }\n\n    int resultCode \u003d 0;\n    if (containerIdStr !\u003d null) {\n      // if we provide the node address and the application is in the final\n      // state, we could directly get logs from HDFS.\n      if (nodeAddress !\u003d null \u0026\u0026 (!appStateKnown ||\n          isApplicationFinished(appState))) {\n        // if user specified \"ALL\" as the logFiles param, pass null\n        // to logCliHelper so that it fetches all the logs\n        List\u003cString\u003e logs;\n        if (logFiles \u003d\u003d null) {\n          logs \u003d null;\n        } else if (fetchAllLogFiles(logFiles)) {\n          logs \u003d null;\n        } else {\n          logs \u003d Arrays.asList(logFiles);\n        }\n        return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n            containerIdStr, nodeAddress, appOwner, logs);\n      }\n      String nodeHttpAddress \u003d null;\n      String nodeId \u003d null;\n      try {\n        // If the nodeAddress is not provided, we will try to get\n        // the ContainerReport. In the containerReport, we could get\n        // nodeAddress and nodeHttpAddress\n        ContainerReport report \u003d getContainerReport(containerIdStr);\n        nodeHttpAddress \u003d\n            report.getNodeHttpAddress().replaceFirst(\n              WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        nodeId \u003d report.getAssignedNode().toString();\n      } catch (IOException | YarnException ex) {\n        if (!appStateKnown || isApplicationFinished(appState)) {\n          String [] requestedLogFiles \u003d logFiles;\n          if(fetchAllLogFiles(logFiles)) {\n            requestedLogFiles \u003d null;\n          }\n          return printContainerLogsForFinishedApplicationWithoutNodeId(\n              appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n              appOwner);\n        } else if (!isApplicationFinished(appState)) {\n          System.err.println(\"Unable to get logs for this container:\"\n              + containerIdStr + \"for the application:\" + appId);\n          System.out.println(\"The application: \" + appId + \" is still running, \"\n              + \"and we can not get Container report for the container: \"\n              + containerIdStr +\". Please try later or after the application \"\n              + \"finishes.\");\n          return -1;\n        }\n      }\n      // If the application is not in the final state,\n      // we will provide the NodeHttpAddress and get the container logs\n      // by calling NodeManager webservice.\n      if (!isApplicationFinished(appState)) {\n        if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n          logFiles \u003d new String[] {\"syslog\"};\n        }\n        printContainerLogsFromRunningApplication(getConf(), appIdStr,\n            containerIdStr, nodeHttpAddress, nodeId, logFiles, logCliHelper,\n            appOwner);\n      } else {\n        String[] requestedLogFiles \u003d logFiles;\n        if(fetchAllLogFiles(logFiles)) {\n          requestedLogFiles \u003d null;\n        }\n        // If the application is in the final state, we will directly\n        // get the container logs from HDFS.\n        printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n            nodeId, requestedLogFiles, logCliHelper, appOwner);\n      }\n      return resultCode;\n    } else {\n      if (nodeAddress \u003d\u003d null) {\n        resultCode \u003d\n            logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n      } else {\n        System.out.println(\"Should at least provide ContainerId!\");\n        printHelpMessage(printOpts);\n        resultCode \u003d -1;\n      }\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "34ef1a092bcab369bb845481efffb8c47adef53a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4149. yarn logs -am should provide an option to fetch all the log\nfiles. Contributed by Varun Vasudev\n",
      "commitDate": "15/09/15 2:36 PM",
      "commitName": "34ef1a092bcab369bb845481efffb8c47adef53a",
      "commitAuthor": "Xuan",
      "commitDateOld": "13/04/15 5:29 PM",
      "commitNameOld": "a77d628339afaf2f5a085c73fd81a805b18348c9",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 154.88,
      "commitsBetweenForRepo": 1122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,243 +1,257 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n     Option appIdOpt \u003d\n         new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n     appIdOpt.setRequired(true);\n     opts.addOption(appIdOpt);\n     opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId. \"\n         + \"By default, it will only print syslog if the application is runing.\"\n         + \" Work with -logFiles to get other logs.\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n       + \"nodename:port\");\n     opts.addOption(APP_OWNER_OPTION, true,\n       \"AppOwner (assumed to be current user if not specified)\");\n     Option amOption \u003d new Option(AM_CONTAINER_OPTION, true, \n       \"Prints the AM Container logs for this application. \"\n       + \"Specify comma-separated value to get logs for related AM Container. \"\n       + \"For example, If we specify -am 1,2, we will get the logs for \"\n       + \"the first AM Container as well as the second AM Container. \"\n       + \"To get logs for all AM Containers, use -am ALL. \"\n       + \"To get logs for the latest AM Container, use -am -1. \"\n       + \"By default, it will only print out syslog. Work with -logFiles \"\n       + \"to get other logs\");\n     amOption.setValueSeparator(\u0027,\u0027);\n     amOption.setArgs(Option.UNLIMITED_VALUES);\n     amOption.setArgName(\"AM Containers\");\n     opts.addOption(amOption);\n     Option logFileOpt \u003d new Option(CONTAINER_LOG_FILES, true,\n       \"Work with -am/-containerId and specify comma-separated value \"\n-      + \"to get specified Container log files\");\n+        + \"to get specified container log files. Use \\\"ALL\\\" to fetch all the \"\n+        + \"log files for the container.\");\n     logFileOpt.setValueSeparator(\u0027,\u0027);\n     logFileOpt.setArgs(Option.UNLIMITED_VALUES);\n     logFileOpt.setArgName(\"Log File Name\");\n     opts.addOption(logFileOpt);\n \n     opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n     opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n     opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n     opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n     opts.getOption(AM_CONTAINER_OPTION).setArgName(\"AM Containers\");\n \n     Options printOpts \u003d new Options();\n     printOpts.addOption(opts.getOption(HELP_CMD));\n     printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n     printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n     printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n     printOpts.addOption(opts.getOption(AM_CONTAINER_OPTION));\n     printOpts.addOption(opts.getOption(CONTAINER_LOG_FILES));\n \n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n     if (args[0].equals(\"-help\")) {\n       printHelpMessage(printOpts);\n       return 0;\n     }\n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     boolean getAMContainerLogs \u003d false;\n     String[] logFiles \u003d null;\n     List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n       getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n       if (getAMContainerLogs) {\n         String[] amContainers \u003d commandLine.getOptionValues(AM_CONTAINER_OPTION);\n         for (String am : amContainers) {\n           boolean errorInput \u003d false;\n           if (!am.trim().equalsIgnoreCase(\"ALL\")) {\n             try {\n               int id \u003d Integer.parseInt(am.trim());\n               if (id !\u003d -1 \u0026\u0026 id \u003c\u003d 0) {\n                 errorInput \u003d true;\n               }\n             } catch (NumberFormatException ex) {\n               errorInput \u003d true;\n             }\n             if (errorInput) {\n               System.err.println(\n                 \"Invalid input for option -am. Valid inputs are \u0027ALL\u0027, -1 \"\n                 + \"and any other integer which is larger than 0.\");\n               printHelpMessage(printOpts);\n               return -1;\n             }\n             amContainersList.add(am.trim());\n           } else {\n             amContainersList.add(\"ALL\");\n             break;\n           }\n         }\n       }\n       if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n         logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n       }\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n     try {\n       appId \u003d ConverterUtils.toApplicationId(appIdStr);\n     } catch (Exception e) {\n       System.err.println(\"Invalid ApplicationId specified\");\n       return -1;\n     }\n \n     LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n     logCliHelper.setConf(getConf());\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n \n     YarnApplicationState appState \u003d YarnApplicationState.NEW;\n     try {\n       appState \u003d getApplicationState(appId);\n       if (appState \u003d\u003d YarnApplicationState.NEW\n           || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n           || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n         System.out.println(\"Logs are not avaiable right now.\");\n         return -1;\n       }\n     } catch (IOException | YarnException e) {\n       System.err.println(\"Unable to get ApplicationState.\"\n           + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n     // To get am logs\n     if (getAMContainerLogs) {\n       // if we do not specify the value for CONTAINER_LOG_FILES option,\n       // we will only output syslog\n       if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n         logFiles \u003d new String[] { \"syslog\" };\n       }\n       // If the application is running, we will call the RM WebService\n       // to get the AppAttempts which includes the nodeHttpAddress\n       // and containerId for all the AM Containers.\n       // After that, we will call NodeManager webService to get the\n       // related logs\n       if (appState \u003d\u003d YarnApplicationState.ACCEPTED\n           || appState \u003d\u003d YarnApplicationState.RUNNING) {\n         return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n           logFiles, logCliHelper, appOwner, false);\n       } else {\n         // If the application is in the final state, we will call RM webservice\n         // to get all AppAttempts information first. If we get nothing,\n         // we will try to call AHS webservice to get related AppAttempts\n         // which includes nodeAddress for the AM Containers.\n         // After that, we will use nodeAddress and containerId\n         // to get logs from HDFS directly.\n         if (getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n           YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n           return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n             logFiles, logCliHelper, appOwner, true);\n         } else {\n           System.out\n-            .println(\"Can not get AMContainers logs for the application:\"\n-                + appId);\n+            .println(\n+                \"Can not get AMContainers logs for the application:\" + appId);\n           System.out.println(\"This application:\" + appId + \" is finished.\"\n               + \" Please enable the application history service. Or Using \"\n               + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n               + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n           return -1;\n         }\n       }\n     }\n \n     int resultCode \u003d 0;\n     if (containerIdStr !\u003d null) {\n       // if we provide the node address and the application is in the final\n       // state, we could directly get logs from HDFS.\n       if (nodeAddress !\u003d null \u0026\u0026 isApplicationFinished(appState)) {\n+        // if user specified \"ALL\" as the logFiles param, pass null\n+        // to logCliHelper so that it fetches all the logs\n+        List\u003cString\u003e logs;\n+        if (logFiles \u003d\u003d null) {\n+          logs \u003d null;\n+        } else if (fetchAllLogFiles(logFiles)) {\n+          logs \u003d null;\n+        } else {\n+          logs \u003d Arrays.asList(logFiles);\n+        }\n         return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n-            containerIdStr, nodeAddress, appOwner, logFiles \u003d\u003d null ? null\n-                : Arrays.asList(logFiles));\n+            containerIdStr, nodeAddress, appOwner, logs);\n       }\n       try {\n         // If the nodeAddress is not provided, we will try to get\n         // the ContainerReport. In the containerReport, we could get\n         // nodeAddress and nodeHttpAddress\n         ContainerReport report \u003d getContainerReport(containerIdStr);\n         String nodeHttpAddress \u003d\n             report.getNodeHttpAddress().replaceFirst(\n               WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n         String nodeId \u003d report.getAssignedNode().toString();\n         // If the application is not in the final state,\n         // we will provide the NodeHttpAddress and get the container logs\n         // by calling NodeManager webservice.\n         if (!isApplicationFinished(appState)) {\n           if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n             logFiles \u003d new String[] { \"syslog\" };\n           }\n           printContainerLogsFromRunningApplication(getConf(), appIdStr,\n             containerIdStr, nodeHttpAddress, nodeId, logFiles, logCliHelper,\n             appOwner);\n         } else {\n+          String [] requestedLogFiles \u003d logFiles;\n+          if(fetchAllLogFiles(logFiles)) {\n+            requestedLogFiles \u003d null;\n+          }\n           // If the application is in the final state, we will directly\n           // get the container logs from HDFS.\n           printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n-            nodeId, logFiles, logCliHelper, appOwner);\n+            nodeId, requestedLogFiles, logCliHelper, appOwner);\n         }\n         return resultCode;\n       } catch (IOException | YarnException ex) {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appId);\n         if (!getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n           YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n           System.out.println(\"Please enable the application history service. Or \");\n         }\n         System.out.println(\"Using \"\n             + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n             + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n         return -1;\n       }\n     } else {\n       if (nodeAddress \u003d\u003d null) {\n         resultCode \u003d\n             logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n       } else {\n         System.out.println(\"Should at least provide ContainerId!\");\n         printHelpMessage(printOpts);\n         resultCode \u003d -1;\n       }\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n    Option appIdOpt \u003d\n        new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n    appIdOpt.setRequired(true);\n    opts.addOption(appIdOpt);\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId. \"\n        + \"By default, it will only print syslog if the application is runing.\"\n        + \" Work with -logFiles to get other logs.\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n      + \"nodename:port\");\n    opts.addOption(APP_OWNER_OPTION, true,\n      \"AppOwner (assumed to be current user if not specified)\");\n    Option amOption \u003d new Option(AM_CONTAINER_OPTION, true, \n      \"Prints the AM Container logs for this application. \"\n      + \"Specify comma-separated value to get logs for related AM Container. \"\n      + \"For example, If we specify -am 1,2, we will get the logs for \"\n      + \"the first AM Container as well as the second AM Container. \"\n      + \"To get logs for all AM Containers, use -am ALL. \"\n      + \"To get logs for the latest AM Container, use -am -1. \"\n      + \"By default, it will only print out syslog. Work with -logFiles \"\n      + \"to get other logs\");\n    amOption.setValueSeparator(\u0027,\u0027);\n    amOption.setArgs(Option.UNLIMITED_VALUES);\n    amOption.setArgName(\"AM Containers\");\n    opts.addOption(amOption);\n    Option logFileOpt \u003d new Option(CONTAINER_LOG_FILES, true,\n      \"Work with -am/-containerId and specify comma-separated value \"\n        + \"to get specified container log files. Use \\\"ALL\\\" to fetch all the \"\n        + \"log files for the container.\");\n    logFileOpt.setValueSeparator(\u0027,\u0027);\n    logFileOpt.setArgs(Option.UNLIMITED_VALUES);\n    logFileOpt.setArgName(\"Log File Name\");\n    opts.addOption(logFileOpt);\n\n    opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n    opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n    opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n    opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n    opts.getOption(AM_CONTAINER_OPTION).setArgName(\"AM Containers\");\n\n    Options printOpts \u003d new Options();\n    printOpts.addOption(opts.getOption(HELP_CMD));\n    printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n    printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n    printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n    printOpts.addOption(opts.getOption(AM_CONTAINER_OPTION));\n    printOpts.addOption(opts.getOption(CONTAINER_LOG_FILES));\n\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n    if (args[0].equals(\"-help\")) {\n      printHelpMessage(printOpts);\n      return 0;\n    }\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    boolean getAMContainerLogs \u003d false;\n    String[] logFiles \u003d null;\n    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n      if (getAMContainerLogs) {\n        String[] amContainers \u003d commandLine.getOptionValues(AM_CONTAINER_OPTION);\n        for (String am : amContainers) {\n          boolean errorInput \u003d false;\n          if (!am.trim().equalsIgnoreCase(\"ALL\")) {\n            try {\n              int id \u003d Integer.parseInt(am.trim());\n              if (id !\u003d -1 \u0026\u0026 id \u003c\u003d 0) {\n                errorInput \u003d true;\n              }\n            } catch (NumberFormatException ex) {\n              errorInput \u003d true;\n            }\n            if (errorInput) {\n              System.err.println(\n                \"Invalid input for option -am. Valid inputs are \u0027ALL\u0027, -1 \"\n                + \"and any other integer which is larger than 0.\");\n              printHelpMessage(printOpts);\n              return -1;\n            }\n            amContainersList.add(am.trim());\n          } else {\n            amContainersList.add(\"ALL\");\n            break;\n          }\n        }\n      }\n      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n      }\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n\n    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n    try {\n      appState \u003d getApplicationState(appId);\n      if (appState \u003d\u003d YarnApplicationState.NEW\n          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n        System.out.println(\"Logs are not avaiable right now.\");\n        return -1;\n      }\n    } catch (IOException | YarnException e) {\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    // To get am logs\n    if (getAMContainerLogs) {\n      // if we do not specify the value for CONTAINER_LOG_FILES option,\n      // we will only output syslog\n      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n        logFiles \u003d new String[] { \"syslog\" };\n      }\n      // If the application is running, we will call the RM WebService\n      // to get the AppAttempts which includes the nodeHttpAddress\n      // and containerId for all the AM Containers.\n      // After that, we will call NodeManager webService to get the\n      // related logs\n      if (appState \u003d\u003d YarnApplicationState.ACCEPTED\n          || appState \u003d\u003d YarnApplicationState.RUNNING) {\n        return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n          logFiles, logCliHelper, appOwner, false);\n      } else {\n        // If the application is in the final state, we will call RM webservice\n        // to get all AppAttempts information first. If we get nothing,\n        // we will try to call AHS webservice to get related AppAttempts\n        // which includes nodeAddress for the AM Containers.\n        // After that, we will use nodeAddress and containerId\n        // to get logs from HDFS directly.\n        if (getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n          YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n          return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n            logFiles, logCliHelper, appOwner, true);\n        } else {\n          System.out\n            .println(\n                \"Can not get AMContainers logs for the application:\" + appId);\n          System.out.println(\"This application:\" + appId + \" is finished.\"\n              + \" Please enable the application history service. Or Using \"\n              + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n              + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n          return -1;\n        }\n      }\n    }\n\n    int resultCode \u003d 0;\n    if (containerIdStr !\u003d null) {\n      // if we provide the node address and the application is in the final\n      // state, we could directly get logs from HDFS.\n      if (nodeAddress !\u003d null \u0026\u0026 isApplicationFinished(appState)) {\n        // if user specified \"ALL\" as the logFiles param, pass null\n        // to logCliHelper so that it fetches all the logs\n        List\u003cString\u003e logs;\n        if (logFiles \u003d\u003d null) {\n          logs \u003d null;\n        } else if (fetchAllLogFiles(logFiles)) {\n          logs \u003d null;\n        } else {\n          logs \u003d Arrays.asList(logFiles);\n        }\n        return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n            containerIdStr, nodeAddress, appOwner, logs);\n      }\n      try {\n        // If the nodeAddress is not provided, we will try to get\n        // the ContainerReport. In the containerReport, we could get\n        // nodeAddress and nodeHttpAddress\n        ContainerReport report \u003d getContainerReport(containerIdStr);\n        String nodeHttpAddress \u003d\n            report.getNodeHttpAddress().replaceFirst(\n              WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        String nodeId \u003d report.getAssignedNode().toString();\n        // If the application is not in the final state,\n        // we will provide the NodeHttpAddress and get the container logs\n        // by calling NodeManager webservice.\n        if (!isApplicationFinished(appState)) {\n          if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n            logFiles \u003d new String[] { \"syslog\" };\n          }\n          printContainerLogsFromRunningApplication(getConf(), appIdStr,\n            containerIdStr, nodeHttpAddress, nodeId, logFiles, logCliHelper,\n            appOwner);\n        } else {\n          String [] requestedLogFiles \u003d logFiles;\n          if(fetchAllLogFiles(logFiles)) {\n            requestedLogFiles \u003d null;\n          }\n          // If the application is in the final state, we will directly\n          // get the container logs from HDFS.\n          printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n            nodeId, requestedLogFiles, logCliHelper, appOwner);\n        }\n        return resultCode;\n      } catch (IOException | YarnException ex) {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appId);\n        if (!getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n          YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n          System.out.println(\"Please enable the application history service. Or \");\n        }\n        System.out.println(\"Using \"\n            + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n            + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n        return -1;\n      }\n    } else {\n      if (nodeAddress \u003d\u003d null) {\n        resultCode \u003d\n            logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n      } else {\n        System.out.println(\"Should at least provide ContainerId!\");\n        printHelpMessage(printOpts);\n        resultCode \u003d -1;\n      }\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "a77d628339afaf2f5a085c73fd81a805b18348c9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3347. Improve YARN log command to get AMContainer logs as well as running containers logs. Contributed by Xuan Gong.\n",
      "commitDate": "13/04/15 5:29 PM",
      "commitName": "a77d628339afaf2f5a085c73fd81a805b18348c9",
      "commitAuthor": "Junping Du",
      "commitDateOld": "23/02/15 10:34 PM",
      "commitNameOld": "b610c68d4423a5a1ab342dc490cd0064f8983c07",
      "commitAuthorOld": "Devaraj K",
      "daysBetweenCommits": 48.75,
      "commitsBetweenForRepo": 426,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,243 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n     Option appIdOpt \u003d\n         new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n     appIdOpt.setRequired(true);\n     opts.addOption(appIdOpt);\n-    opts.addOption(CONTAINER_ID_OPTION, true,\n-      \"ContainerId (must be specified if node address is specified)\");\n+    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId. \"\n+        + \"By default, it will only print syslog if the application is runing.\"\n+        + \" Work with -logFiles to get other logs.\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n-      + \"nodename:port (must be specified if container id is specified)\");\n+      + \"nodename:port\");\n     opts.addOption(APP_OWNER_OPTION, true,\n       \"AppOwner (assumed to be current user if not specified)\");\n+    Option amOption \u003d new Option(AM_CONTAINER_OPTION, true, \n+      \"Prints the AM Container logs for this application. \"\n+      + \"Specify comma-separated value to get logs for related AM Container. \"\n+      + \"For example, If we specify -am 1,2, we will get the logs for \"\n+      + \"the first AM Container as well as the second AM Container. \"\n+      + \"To get logs for all AM Containers, use -am ALL. \"\n+      + \"To get logs for the latest AM Container, use -am -1. \"\n+      + \"By default, it will only print out syslog. Work with -logFiles \"\n+      + \"to get other logs\");\n+    amOption.setValueSeparator(\u0027,\u0027);\n+    amOption.setArgs(Option.UNLIMITED_VALUES);\n+    amOption.setArgName(\"AM Containers\");\n+    opts.addOption(amOption);\n+    Option logFileOpt \u003d new Option(CONTAINER_LOG_FILES, true,\n+      \"Work with -am/-containerId and specify comma-separated value \"\n+      + \"to get specified Container log files\");\n+    logFileOpt.setValueSeparator(\u0027,\u0027);\n+    logFileOpt.setArgs(Option.UNLIMITED_VALUES);\n+    logFileOpt.setArgName(\"Log File Name\");\n+    opts.addOption(logFileOpt);\n+\n     opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n     opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n     opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n     opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n+    opts.getOption(AM_CONTAINER_OPTION).setArgName(\"AM Containers\");\n \n     Options printOpts \u003d new Options();\n     printOpts.addOption(opts.getOption(HELP_CMD));\n     printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n     printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n     printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n+    printOpts.addOption(opts.getOption(AM_CONTAINER_OPTION));\n+    printOpts.addOption(opts.getOption(CONTAINER_LOG_FILES));\n \n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n     if (args[0].equals(\"-help\")) {\n       printHelpMessage(printOpts);\n       return 0;\n     }\n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n+    boolean getAMContainerLogs \u003d false;\n+    String[] logFiles \u003d null;\n+    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n+      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n+      if (getAMContainerLogs) {\n+        String[] amContainers \u003d commandLine.getOptionValues(AM_CONTAINER_OPTION);\n+        for (String am : amContainers) {\n+          boolean errorInput \u003d false;\n+          if (!am.trim().equalsIgnoreCase(\"ALL\")) {\n+            try {\n+              int id \u003d Integer.parseInt(am.trim());\n+              if (id !\u003d -1 \u0026\u0026 id \u003c\u003d 0) {\n+                errorInput \u003d true;\n+              }\n+            } catch (NumberFormatException ex) {\n+              errorInput \u003d true;\n+            }\n+            if (errorInput) {\n+              System.err.println(\n+                \"Invalid input for option -am. Valid inputs are \u0027ALL\u0027, -1 \"\n+                + \"and any other integer which is larger than 0.\");\n+              printHelpMessage(printOpts);\n+              return -1;\n+            }\n+            amContainersList.add(am.trim());\n+          } else {\n+            amContainersList.add(\"ALL\");\n+            break;\n+          }\n+        }\n+      }\n+      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n+        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n+      }\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n     try {\n       appId \u003d ConverterUtils.toApplicationId(appIdStr);\n     } catch (Exception e) {\n       System.err.println(\"Invalid ApplicationId specified\");\n       return -1;\n     }\n \n+    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n+    logCliHelper.setConf(getConf());\n+\n+    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n+      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n+    }\n+\n+    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n     try {\n-      int resultCode \u003d verifyApplicationState(appId);\n-      if (resultCode !\u003d 0) {\n+      appState \u003d getApplicationState(appId);\n+      if (appState \u003d\u003d YarnApplicationState.NEW\n+          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n+          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n         System.out.println(\"Logs are not avaiable right now.\");\n-        return resultCode;\n+        return -1;\n       }\n-    } catch (Exception e) {\n+    } catch (IOException | YarnException e) {\n       System.err.println(\"Unable to get ApplicationState.\"\n           + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n-    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n-    logCliHelper.setConf(getConf());\n-    \n-    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n-      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n-    }\n-    int resultCode \u003d 0;\n-    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n-      resultCode \u003d logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n-    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n-        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n-      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n-      printHelpMessage(printOpts);\n-      resultCode \u003d -1;\n-    } else {\n-      resultCode \u003d\n-          logCliHelper.dumpAContainersLogs(appIdStr, containerIdStr,\n-            nodeAddress, appOwner);\n+    // To get am logs\n+    if (getAMContainerLogs) {\n+      // if we do not specify the value for CONTAINER_LOG_FILES option,\n+      // we will only output syslog\n+      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n+        logFiles \u003d new String[] { \"syslog\" };\n+      }\n+      // If the application is running, we will call the RM WebService\n+      // to get the AppAttempts which includes the nodeHttpAddress\n+      // and containerId for all the AM Containers.\n+      // After that, we will call NodeManager webService to get the\n+      // related logs\n+      if (appState \u003d\u003d YarnApplicationState.ACCEPTED\n+          || appState \u003d\u003d YarnApplicationState.RUNNING) {\n+        return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n+          logFiles, logCliHelper, appOwner, false);\n+      } else {\n+        // If the application is in the final state, we will call RM webservice\n+        // to get all AppAttempts information first. If we get nothing,\n+        // we will try to call AHS webservice to get related AppAttempts\n+        // which includes nodeAddress for the AM Containers.\n+        // After that, we will use nodeAddress and containerId\n+        // to get logs from HDFS directly.\n+        if (getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n+          YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n+          return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n+            logFiles, logCliHelper, appOwner, true);\n+        } else {\n+          System.out\n+            .println(\"Can not get AMContainers logs for the application:\"\n+                + appId);\n+          System.out.println(\"This application:\" + appId + \" is finished.\"\n+              + \" Please enable the application history service. Or Using \"\n+              + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n+              + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n+          return -1;\n+        }\n+      }\n     }\n \n+    int resultCode \u003d 0;\n+    if (containerIdStr !\u003d null) {\n+      // if we provide the node address and the application is in the final\n+      // state, we could directly get logs from HDFS.\n+      if (nodeAddress !\u003d null \u0026\u0026 isApplicationFinished(appState)) {\n+        return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n+            containerIdStr, nodeAddress, appOwner, logFiles \u003d\u003d null ? null\n+                : Arrays.asList(logFiles));\n+      }\n+      try {\n+        // If the nodeAddress is not provided, we will try to get\n+        // the ContainerReport. In the containerReport, we could get\n+        // nodeAddress and nodeHttpAddress\n+        ContainerReport report \u003d getContainerReport(containerIdStr);\n+        String nodeHttpAddress \u003d\n+            report.getNodeHttpAddress().replaceFirst(\n+              WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n+        String nodeId \u003d report.getAssignedNode().toString();\n+        // If the application is not in the final state,\n+        // we will provide the NodeHttpAddress and get the container logs\n+        // by calling NodeManager webservice.\n+        if (!isApplicationFinished(appState)) {\n+          if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n+            logFiles \u003d new String[] { \"syslog\" };\n+          }\n+          printContainerLogsFromRunningApplication(getConf(), appIdStr,\n+            containerIdStr, nodeHttpAddress, nodeId, logFiles, logCliHelper,\n+            appOwner);\n+        } else {\n+          // If the application is in the final state, we will directly\n+          // get the container logs from HDFS.\n+          printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n+            nodeId, logFiles, logCliHelper, appOwner);\n+        }\n+        return resultCode;\n+      } catch (IOException | YarnException ex) {\n+        System.err.println(\"Unable to get logs for this container:\"\n+            + containerIdStr + \"for the application:\" + appId);\n+        if (!getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n+          YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n+          System.out.println(\"Please enable the application history service. Or \");\n+        }\n+        System.out.println(\"Using \"\n+            + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n+            + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n+        return -1;\n+      }\n+    } else {\n+      if (nodeAddress \u003d\u003d null) {\n+        resultCode \u003d\n+            logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n+      } else {\n+        System.out.println(\"Should at least provide ContainerId!\");\n+        printHelpMessage(printOpts);\n+        resultCode \u003d -1;\n+      }\n+    }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n    Option appIdOpt \u003d\n        new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n    appIdOpt.setRequired(true);\n    opts.addOption(appIdOpt);\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId. \"\n        + \"By default, it will only print syslog if the application is runing.\"\n        + \" Work with -logFiles to get other logs.\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n      + \"nodename:port\");\n    opts.addOption(APP_OWNER_OPTION, true,\n      \"AppOwner (assumed to be current user if not specified)\");\n    Option amOption \u003d new Option(AM_CONTAINER_OPTION, true, \n      \"Prints the AM Container logs for this application. \"\n      + \"Specify comma-separated value to get logs for related AM Container. \"\n      + \"For example, If we specify -am 1,2, we will get the logs for \"\n      + \"the first AM Container as well as the second AM Container. \"\n      + \"To get logs for all AM Containers, use -am ALL. \"\n      + \"To get logs for the latest AM Container, use -am -1. \"\n      + \"By default, it will only print out syslog. Work with -logFiles \"\n      + \"to get other logs\");\n    amOption.setValueSeparator(\u0027,\u0027);\n    amOption.setArgs(Option.UNLIMITED_VALUES);\n    amOption.setArgName(\"AM Containers\");\n    opts.addOption(amOption);\n    Option logFileOpt \u003d new Option(CONTAINER_LOG_FILES, true,\n      \"Work with -am/-containerId and specify comma-separated value \"\n      + \"to get specified Container log files\");\n    logFileOpt.setValueSeparator(\u0027,\u0027);\n    logFileOpt.setArgs(Option.UNLIMITED_VALUES);\n    logFileOpt.setArgName(\"Log File Name\");\n    opts.addOption(logFileOpt);\n\n    opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n    opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n    opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n    opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n    opts.getOption(AM_CONTAINER_OPTION).setArgName(\"AM Containers\");\n\n    Options printOpts \u003d new Options();\n    printOpts.addOption(opts.getOption(HELP_CMD));\n    printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n    printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n    printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n    printOpts.addOption(opts.getOption(AM_CONTAINER_OPTION));\n    printOpts.addOption(opts.getOption(CONTAINER_LOG_FILES));\n\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n    if (args[0].equals(\"-help\")) {\n      printHelpMessage(printOpts);\n      return 0;\n    }\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    boolean getAMContainerLogs \u003d false;\n    String[] logFiles \u003d null;\n    List\u003cString\u003e amContainersList \u003d new ArrayList\u003cString\u003e();\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n      getAMContainerLogs \u003d commandLine.hasOption(AM_CONTAINER_OPTION);\n      if (getAMContainerLogs) {\n        String[] amContainers \u003d commandLine.getOptionValues(AM_CONTAINER_OPTION);\n        for (String am : amContainers) {\n          boolean errorInput \u003d false;\n          if (!am.trim().equalsIgnoreCase(\"ALL\")) {\n            try {\n              int id \u003d Integer.parseInt(am.trim());\n              if (id !\u003d -1 \u0026\u0026 id \u003c\u003d 0) {\n                errorInput \u003d true;\n              }\n            } catch (NumberFormatException ex) {\n              errorInput \u003d true;\n            }\n            if (errorInput) {\n              System.err.println(\n                \"Invalid input for option -am. Valid inputs are \u0027ALL\u0027, -1 \"\n                + \"and any other integer which is larger than 0.\");\n              printHelpMessage(printOpts);\n              return -1;\n            }\n            amContainersList.add(am.trim());\n          } else {\n            amContainersList.add(\"ALL\");\n            break;\n          }\n        }\n      }\n      if (commandLine.hasOption(CONTAINER_LOG_FILES)) {\n        logFiles \u003d commandLine.getOptionValues(CONTAINER_LOG_FILES);\n      }\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n\n    YarnApplicationState appState \u003d YarnApplicationState.NEW;\n    try {\n      appState \u003d getApplicationState(appId);\n      if (appState \u003d\u003d YarnApplicationState.NEW\n          || appState \u003d\u003d YarnApplicationState.NEW_SAVING\n          || appState \u003d\u003d YarnApplicationState.SUBMITTED) {\n        System.out.println(\"Logs are not avaiable right now.\");\n        return -1;\n      }\n    } catch (IOException | YarnException e) {\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    // To get am logs\n    if (getAMContainerLogs) {\n      // if we do not specify the value for CONTAINER_LOG_FILES option,\n      // we will only output syslog\n      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n        logFiles \u003d new String[] { \"syslog\" };\n      }\n      // If the application is running, we will call the RM WebService\n      // to get the AppAttempts which includes the nodeHttpAddress\n      // and containerId for all the AM Containers.\n      // After that, we will call NodeManager webService to get the\n      // related logs\n      if (appState \u003d\u003d YarnApplicationState.ACCEPTED\n          || appState \u003d\u003d YarnApplicationState.RUNNING) {\n        return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n          logFiles, logCliHelper, appOwner, false);\n      } else {\n        // If the application is in the final state, we will call RM webservice\n        // to get all AppAttempts information first. If we get nothing,\n        // we will try to call AHS webservice to get related AppAttempts\n        // which includes nodeAddress for the AM Containers.\n        // After that, we will use nodeAddress and containerId\n        // to get logs from HDFS directly.\n        if (getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n          YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n          return printAMContainerLogs(getConf(), appIdStr, amContainersList,\n            logFiles, logCliHelper, appOwner, true);\n        } else {\n          System.out\n            .println(\"Can not get AMContainers logs for the application:\"\n                + appId);\n          System.out.println(\"This application:\" + appId + \" is finished.\"\n              + \" Please enable the application history service. Or Using \"\n              + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n              + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n          return -1;\n        }\n      }\n    }\n\n    int resultCode \u003d 0;\n    if (containerIdStr !\u003d null) {\n      // if we provide the node address and the application is in the final\n      // state, we could directly get logs from HDFS.\n      if (nodeAddress !\u003d null \u0026\u0026 isApplicationFinished(appState)) {\n        return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n            containerIdStr, nodeAddress, appOwner, logFiles \u003d\u003d null ? null\n                : Arrays.asList(logFiles));\n      }\n      try {\n        // If the nodeAddress is not provided, we will try to get\n        // the ContainerReport. In the containerReport, we could get\n        // nodeAddress and nodeHttpAddress\n        ContainerReport report \u003d getContainerReport(containerIdStr);\n        String nodeHttpAddress \u003d\n            report.getNodeHttpAddress().replaceFirst(\n              WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        String nodeId \u003d report.getAssignedNode().toString();\n        // If the application is not in the final state,\n        // we will provide the NodeHttpAddress and get the container logs\n        // by calling NodeManager webservice.\n        if (!isApplicationFinished(appState)) {\n          if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n            logFiles \u003d new String[] { \"syslog\" };\n          }\n          printContainerLogsFromRunningApplication(getConf(), appIdStr,\n            containerIdStr, nodeHttpAddress, nodeId, logFiles, logCliHelper,\n            appOwner);\n        } else {\n          // If the application is in the final state, we will directly\n          // get the container logs from HDFS.\n          printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n            nodeId, logFiles, logCliHelper, appOwner);\n        }\n        return resultCode;\n      } catch (IOException | YarnException ex) {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appId);\n        if (!getConf().getBoolean(YarnConfiguration.APPLICATION_HISTORY_ENABLED,\n          YarnConfiguration.DEFAULT_APPLICATION_HISTORY_ENABLED)) {\n          System.out.println(\"Please enable the application history service. Or \");\n        }\n        System.out.println(\"Using \"\n            + \"yarn logs -applicationId \u003cappId\u003e -containerId \u003ccontainerId\u003e \"\n            + \"--nodeAddress \u003cnodeHttpAddress\u003e to get the container logs\");\n        return -1;\n      }\n    } else {\n      if (nodeAddress \u003d\u003d null) {\n        resultCode \u003d\n            logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n      } else {\n        System.out.println(\"Should at least provide ContainerId!\");\n        printHelpMessage(printOpts);\n        resultCode \u003d -1;\n      }\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "b610c68d4423a5a1ab342dc490cd0064f8983c07": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2797. Add -help to yarn logs and nodes CLI command. Contributed by\nJagadesh Kiran N.\n",
      "commitDate": "23/02/15 10:34 PM",
      "commitName": "b610c68d4423a5a1ab342dc490cd0064f8983c07",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "20/10/14 1:38 PM",
      "commitNameOld": "e90718fa5a0e7c18592af61534668acebb9db51b",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 126.41,
      "commitsBetweenForRepo": 1006,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,97 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n-    Option appIdOpt \u003d new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n+    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n+    Option appIdOpt \u003d\n+        new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n     appIdOpt.setRequired(true);\n     opts.addOption(appIdOpt);\n     opts.addOption(CONTAINER_ID_OPTION, true,\n       \"ContainerId (must be specified if node address is specified)\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n       + \"nodename:port (must be specified if container id is specified)\");\n     opts.addOption(APP_OWNER_OPTION, true,\n       \"AppOwner (assumed to be current user if not specified)\");\n     opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n     opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n     opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n     opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n \n     Options printOpts \u003d new Options();\n+    printOpts.addOption(opts.getOption(HELP_CMD));\n     printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n     printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n     printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n \n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n-\n+    if (args[0].equals(\"-help\")) {\n+      printHelpMessage(printOpts);\n+      return 0;\n+    }\n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n     try {\n       appId \u003d ConverterUtils.toApplicationId(appIdStr);\n     } catch (Exception e) {\n       System.err.println(\"Invalid ApplicationId specified\");\n       return -1;\n     }\n \n     try {\n       int resultCode \u003d verifyApplicationState(appId);\n       if (resultCode !\u003d 0) {\n         System.out.println(\"Logs are not avaiable right now.\");\n         return resultCode;\n       }\n     } catch (Exception e) {\n       System.err.println(\"Unable to get ApplicationState.\"\n           + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n     LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n     logCliHelper.setConf(getConf());\n     \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n     int resultCode \u003d 0;\n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n       resultCode \u003d logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n       printHelpMessage(printOpts);\n       resultCode \u003d -1;\n     } else {\n       resultCode \u003d\n           logCliHelper.dumpAContainersLogs(appIdStr, containerIdStr,\n             nodeAddress, appOwner);\n     }\n \n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n    Option appIdOpt \u003d\n        new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n    appIdOpt.setRequired(true);\n    opts.addOption(appIdOpt);\n    opts.addOption(CONTAINER_ID_OPTION, true,\n      \"ContainerId (must be specified if node address is specified)\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n      + \"nodename:port (must be specified if container id is specified)\");\n    opts.addOption(APP_OWNER_OPTION, true,\n      \"AppOwner (assumed to be current user if not specified)\");\n    opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n    opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n    opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n    opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n\n    Options printOpts \u003d new Options();\n    printOpts.addOption(opts.getOption(HELP_CMD));\n    printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n    printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n    printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n    if (args[0].equals(\"-help\")) {\n      printHelpMessage(printOpts);\n      return 0;\n    }\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n\n    try {\n      int resultCode \u003d verifyApplicationState(appId);\n      if (resultCode !\u003d 0) {\n        System.out.println(\"Logs are not avaiable right now.\");\n        return resultCode;\n      }\n    } catch (Exception e) {\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n    \n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n    int resultCode \u003d 0;\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      resultCode \u003d logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      printHelpMessage(printOpts);\n      resultCode \u003d -1;\n    } else {\n      resultCode \u003d\n          logCliHelper.dumpAContainersLogs(appIdStr, containerIdStr,\n            nodeAddress, appOwner);\n    }\n\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "e90718fa5a0e7c18592af61534668acebb9db51b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2582. Fixed Log CLI and Web UI for showing aggregated logs of LRS. Contributed Xuan Gong.\n",
      "commitDate": "20/10/14 1:38 PM",
      "commitName": "e90718fa5a0e7c18592af61534668acebb9db51b",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "03/10/13 7:36 PM",
      "commitNameOld": "6ff600d9e3496008d81361c17ea427a8675cd0d4",
      "commitAuthorOld": "Hitesh Shah",
      "daysBetweenCommits": 381.75,
      "commitsBetweenForRepo": 2873,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,91 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     Option appIdOpt \u003d new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n     appIdOpt.setRequired(true);\n     opts.addOption(appIdOpt);\n     opts.addOption(CONTAINER_ID_OPTION, true,\n       \"ContainerId (must be specified if node address is specified)\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n       + \"nodename:port (must be specified if container id is specified)\");\n     opts.addOption(APP_OWNER_OPTION, true,\n       \"AppOwner (assumed to be current user if not specified)\");\n     opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n     opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n     opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n     opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n \n     Options printOpts \u003d new Options();\n     printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n     printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n     printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n \n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n     } catch (ParseException e) {\n       System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     ApplicationId appId \u003d null;\n     try {\n       appId \u003d ConverterUtils.toApplicationId(appIdStr);\n     } catch (Exception e) {\n       System.err.println(\"Invalid ApplicationId specified\");\n       return -1;\n     }\n-    \n+\n     try {\n       int resultCode \u003d verifyApplicationState(appId);\n       if (resultCode !\u003d 0) {\n-        System.out.println(\"Application has not completed.\" +\n-        \t\t\" Logs are only available after an application completes\");\n+        System.out.println(\"Logs are not avaiable right now.\");\n         return resultCode;\n       }\n     } catch (Exception e) {\n-      System.err.println(\"Unable to get ApplicationState.\" +\n-      \t\t\" Attempting to fetch logs directly from the filesystem.\");\n+      System.err.println(\"Unable to get ApplicationState.\"\n+          + \" Attempting to fetch logs directly from the filesystem.\");\n     }\n \n     LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n     logCliHelper.setConf(getConf());\n     \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n     int resultCode \u003d 0;\n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n       resultCode \u003d logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n       printHelpMessage(printOpts);\n       resultCode \u003d -1;\n     } else {\n-      Path remoteRootLogDir \u003d\n-        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n-            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n-      AggregatedLogFormat.LogReader reader \u003d\n-          new AggregatedLogFormat.LogReader(getConf(),\n-              LogAggregationUtils.getRemoteNodeLogFileForApp(\n-                  remoteRootLogDir,\n-                  appId,\n-                  appOwner,\n-                  ConverterUtils.toNodeId(nodeAddress),\n-                  LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n-      resultCode \u003d logCliHelper.dumpAContainerLogs(containerIdStr, reader, System.out);\n+      resultCode \u003d\n+          logCliHelper.dumpAContainersLogs(appIdStr, containerIdStr,\n+            nodeAddress, appOwner);\n     }\n \n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    Option appIdOpt \u003d new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n    appIdOpt.setRequired(true);\n    opts.addOption(appIdOpt);\n    opts.addOption(CONTAINER_ID_OPTION, true,\n      \"ContainerId (must be specified if node address is specified)\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n      + \"nodename:port (must be specified if container id is specified)\");\n    opts.addOption(APP_OWNER_OPTION, true,\n      \"AppOwner (assumed to be current user if not specified)\");\n    opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n    opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n    opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n    opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n\n    Options printOpts \u003d new Options();\n    printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n    printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n    printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n\n    try {\n      int resultCode \u003d verifyApplicationState(appId);\n      if (resultCode !\u003d 0) {\n        System.out.println(\"Logs are not avaiable right now.\");\n        return resultCode;\n      }\n    } catch (Exception e) {\n      System.err.println(\"Unable to get ApplicationState.\"\n          + \" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n    \n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n    int resultCode \u003d 0;\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      resultCode \u003d logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      printHelpMessage(printOpts);\n      resultCode \u003d -1;\n    } else {\n      resultCode \u003d\n          logCliHelper.dumpAContainersLogs(appIdStr, containerIdStr,\n            nodeAddress, appOwner);\n    }\n\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "6ff600d9e3496008d81361c17ea427a8675cd0d4": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "YARN-1131.  logs command should return an appropriate error message if YARN application is still running. Contributed by Siddharth Seth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529068 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/10/13 7:36 PM",
      "commitName": "6ff600d9e3496008d81361c17ea427a8675cd0d4",
      "commitAuthor": "Hitesh Shah",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-1131.  logs command should return an appropriate error message if YARN application is still running. Contributed by Siddharth Seth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529068 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/10/13 7:36 PM",
          "commitName": "6ff600d9e3496008d81361c17ea427a8675cd0d4",
          "commitAuthor": "Hitesh Shah",
          "commitDateOld": "03/10/13 6:30 PM",
          "commitNameOld": "d8ea364d07f782f8693b1ac0c340d4bd8d471c32",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,101 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n-    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n+    Option appIdOpt \u003d new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n+    appIdOpt.setRequired(true);\n+    opts.addOption(appIdOpt);\n     opts.addOption(CONTAINER_ID_OPTION, true,\n       \"ContainerId (must be specified if node address is specified)\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n       + \"nodename:port (must be specified if container id is specified)\");\n     opts.addOption(APP_OWNER_OPTION, true,\n       \"AppOwner (assumed to be current user if not specified)\");\n     opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n     opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n     opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n     opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n \n     Options printOpts \u003d new Options();\n     printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n     printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n     printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n \n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n     } catch (ParseException e) {\n-      System.out.println(\"options parsing failed: \" + e.getMessage());\n+      System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n-      System.out.println(\"ApplicationId cannot be null!\");\n+      System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n-    RecordFactory recordFactory \u003d\n-        RecordFactoryProvider.getRecordFactory(getConf());\n-    ApplicationId appId \u003d\n-        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n+    ApplicationId appId \u003d null;\n+    try {\n+      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n+    } catch (Exception e) {\n+      System.err.println(\"Invalid ApplicationId specified\");\n+      return -1;\n+    }\n+    \n+    try {\n+      int resultCode \u003d verifyApplicationState(appId);\n+      if (resultCode !\u003d 0) {\n+        System.out.println(\"Application has not completed.\" +\n+        \t\t\" Logs are only available after an application completes\");\n+        return resultCode;\n+      }\n+    } catch (Exception e) {\n+      System.err.println(\"Unable to get ApplicationState.\" +\n+      \t\t\" Attempting to fetch logs directly from the filesystem.\");\n+    }\n \n+    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n+    logCliHelper.setConf(getConf());\n+    \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n     int resultCode \u003d 0;\n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n-      resultCode \u003d dumpAllContainersLogs(appId, appOwner, System.out);\n+      resultCode \u003d logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n       printHelpMessage(printOpts);\n       resultCode \u003d -1;\n     } else {\n       Path remoteRootLogDir \u003d\n         new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n       AggregatedLogFormat.LogReader reader \u003d\n           new AggregatedLogFormat.LogReader(getConf(),\n               LogAggregationUtils.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir,\n                   appId,\n                   appOwner,\n                   ConverterUtils.toNodeId(nodeAddress),\n                   LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n-      resultCode \u003d dumpAContainerLogs(containerIdStr, reader, System.out);\n+      resultCode \u003d logCliHelper.dumpAContainerLogs(containerIdStr, reader, System.out);\n     }\n \n     return resultCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    Option appIdOpt \u003d new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n    appIdOpt.setRequired(true);\n    opts.addOption(appIdOpt);\n    opts.addOption(CONTAINER_ID_OPTION, true,\n      \"ContainerId (must be specified if node address is specified)\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n      + \"nodename:port (must be specified if container id is specified)\");\n    opts.addOption(APP_OWNER_OPTION, true,\n      \"AppOwner (assumed to be current user if not specified)\");\n    opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n    opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n    opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n    opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n\n    Options printOpts \u003d new Options();\n    printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n    printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n    printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n    \n    try {\n      int resultCode \u003d verifyApplicationState(appId);\n      if (resultCode !\u003d 0) {\n        System.out.println(\"Application has not completed.\" +\n        \t\t\" Logs are only available after an application completes\");\n        return resultCode;\n      }\n    } catch (Exception e) {\n      System.err.println(\"Unable to get ApplicationState.\" +\n      \t\t\" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n    \n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n    int resultCode \u003d 0;\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      resultCode \u003d logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      printHelpMessage(printOpts);\n      resultCode \u003d -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir,\n                  appId,\n                  appOwner,\n                  ConverterUtils.toNodeId(nodeAddress),\n                  LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n      resultCode \u003d logCliHelper.dumpAContainerLogs(containerIdStr, reader, System.out);\n    }\n\n    return resultCode;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogDumper.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
            "oldMethodName": "run",
            "newMethodName": "run"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1131.  logs command should return an appropriate error message if YARN application is still running. Contributed by Siddharth Seth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529068 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/10/13 7:36 PM",
          "commitName": "6ff600d9e3496008d81361c17ea427a8675cd0d4",
          "commitAuthor": "Hitesh Shah",
          "commitDateOld": "03/10/13 6:30 PM",
          "commitNameOld": "d8ea364d07f782f8693b1ac0c340d4bd8d471c32",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,101 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n-    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n+    Option appIdOpt \u003d new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n+    appIdOpt.setRequired(true);\n+    opts.addOption(appIdOpt);\n     opts.addOption(CONTAINER_ID_OPTION, true,\n       \"ContainerId (must be specified if node address is specified)\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n       + \"nodename:port (must be specified if container id is specified)\");\n     opts.addOption(APP_OWNER_OPTION, true,\n       \"AppOwner (assumed to be current user if not specified)\");\n     opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n     opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n     opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n     opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n \n     Options printOpts \u003d new Options();\n     printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n     printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n     printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n \n     if (args.length \u003c 1) {\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n     } catch (ParseException e) {\n-      System.out.println(\"options parsing failed: \" + e.getMessage());\n+      System.err.println(\"options parsing failed: \" + e.getMessage());\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n-      System.out.println(\"ApplicationId cannot be null!\");\n+      System.err.println(\"ApplicationId cannot be null!\");\n       printHelpMessage(printOpts);\n       return -1;\n     }\n \n-    RecordFactory recordFactory \u003d\n-        RecordFactoryProvider.getRecordFactory(getConf());\n-    ApplicationId appId \u003d\n-        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n+    ApplicationId appId \u003d null;\n+    try {\n+      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n+    } catch (Exception e) {\n+      System.err.println(\"Invalid ApplicationId specified\");\n+      return -1;\n+    }\n+    \n+    try {\n+      int resultCode \u003d verifyApplicationState(appId);\n+      if (resultCode !\u003d 0) {\n+        System.out.println(\"Application has not completed.\" +\n+        \t\t\" Logs are only available after an application completes\");\n+        return resultCode;\n+      }\n+    } catch (Exception e) {\n+      System.err.println(\"Unable to get ApplicationState.\" +\n+      \t\t\" Attempting to fetch logs directly from the filesystem.\");\n+    }\n \n+    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n+    logCliHelper.setConf(getConf());\n+    \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n     int resultCode \u003d 0;\n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n-      resultCode \u003d dumpAllContainersLogs(appId, appOwner, System.out);\n+      resultCode \u003d logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n       printHelpMessage(printOpts);\n       resultCode \u003d -1;\n     } else {\n       Path remoteRootLogDir \u003d\n         new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n       AggregatedLogFormat.LogReader reader \u003d\n           new AggregatedLogFormat.LogReader(getConf(),\n               LogAggregationUtils.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir,\n                   appId,\n                   appOwner,\n                   ConverterUtils.toNodeId(nodeAddress),\n                   LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n-      resultCode \u003d dumpAContainerLogs(containerIdStr, reader, System.out);\n+      resultCode \u003d logCliHelper.dumpAContainerLogs(containerIdStr, reader, System.out);\n     }\n \n     return resultCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    Option appIdOpt \u003d new Option(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n    appIdOpt.setRequired(true);\n    opts.addOption(appIdOpt);\n    opts.addOption(CONTAINER_ID_OPTION, true,\n      \"ContainerId (must be specified if node address is specified)\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n      + \"nodename:port (must be specified if container id is specified)\");\n    opts.addOption(APP_OWNER_OPTION, true,\n      \"AppOwner (assumed to be current user if not specified)\");\n    opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n    opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n    opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n    opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n\n    Options printOpts \u003d new Options();\n    printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n    printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n    printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n    } catch (ParseException e) {\n      System.err.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.err.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    ApplicationId appId \u003d null;\n    try {\n      appId \u003d ConverterUtils.toApplicationId(appIdStr);\n    } catch (Exception e) {\n      System.err.println(\"Invalid ApplicationId specified\");\n      return -1;\n    }\n    \n    try {\n      int resultCode \u003d verifyApplicationState(appId);\n      if (resultCode !\u003d 0) {\n        System.out.println(\"Application has not completed.\" +\n        \t\t\" Logs are only available after an application completes\");\n        return resultCode;\n      }\n    } catch (Exception e) {\n      System.err.println(\"Unable to get ApplicationState.\" +\n      \t\t\" Attempting to fetch logs directly from the filesystem.\");\n    }\n\n    LogCLIHelpers logCliHelper \u003d new LogCLIHelpers();\n    logCliHelper.setConf(getConf());\n    \n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n    int resultCode \u003d 0;\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      resultCode \u003d logCliHelper.dumpAllContainersLogs(appId, appOwner, System.out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      printHelpMessage(printOpts);\n      resultCode \u003d -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir,\n                  appId,\n                  appOwner,\n                  ConverterUtils.toNodeId(nodeAddress),\n                  LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n      resultCode \u003d logCliHelper.dumpAContainerLogs(containerIdStr, reader, System.out);\n    }\n\n    return resultCode;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {}
        }
      ]
    },
    "febedd64e998c70594d84e2dc273cc0a469544e2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1080. Improved help message for \"yarn logs\" command. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1518731 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/08/13 10:55 AM",
      "commitName": "febedd64e998c70594d84e2dc273cc0a469544e2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/13 8:32 PM",
      "commitNameOld": "f5f8f3bca4eeaedeff8181812452ec363c4db744",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 73.6,
      "commitsBetweenForRepo": 434,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,81 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n     opts.addOption(CONTAINER_ID_OPTION, true,\n       \"ContainerId (must be specified if node address is specified)\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n       + \"nodename:port (must be specified if container id is specified)\");\n     opts.addOption(APP_OWNER_OPTION, true,\n       \"AppOwner (assumed to be current user if not specified)\");\n+    opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n+    opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n+    opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n+    opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n+\n+    Options printOpts \u003d new Options();\n+    printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n+    printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n+    printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n \n     if (args.length \u003c 1) {\n-      HelpFormatter formatter \u003d new HelpFormatter();\n-      formatter.printHelp(\"general options are: \", opts);\n+      printHelpMessage(printOpts);\n       return -1;\n     }\n \n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n     } catch (ParseException e) {\n       System.out.println(\"options parsing failed: \" + e.getMessage());\n-\n-      HelpFormatter formatter \u003d new HelpFormatter();\n-      formatter.printHelp(\"general options are: \", opts);\n+      printHelpMessage(printOpts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.out.println(\"ApplicationId cannot be null!\");\n-      HelpFormatter formatter \u003d new HelpFormatter();\n-      formatter.printHelp(\"general options are: \", opts);\n+      printHelpMessage(printOpts);\n       return -1;\n     }\n \n     RecordFactory recordFactory \u003d\n         RecordFactoryProvider.getRecordFactory(getConf());\n     ApplicationId appId \u003d\n         ConverterUtils.toApplicationId(recordFactory, appIdStr);\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n     int resultCode \u003d 0;\n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n       resultCode \u003d dumpAllContainersLogs(appId, appOwner, System.out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n-      HelpFormatter formatter \u003d new HelpFormatter();\n-      formatter.printHelp(\"general options are: \", opts);\n+      printHelpMessage(printOpts);\n       resultCode \u003d -1;\n     } else {\n       Path remoteRootLogDir \u003d\n         new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n       AggregatedLogFormat.LogReader reader \u003d\n           new AggregatedLogFormat.LogReader(getConf(),\n               LogAggregationUtils.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir,\n                   appId,\n                   appOwner,\n                   ConverterUtils.toNodeId(nodeAddress),\n                   LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n       resultCode \u003d dumpAContainerLogs(containerIdStr, reader, System.out);\n     }\n \n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n    opts.addOption(CONTAINER_ID_OPTION, true,\n      \"ContainerId (must be specified if node address is specified)\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n      + \"nodename:port (must be specified if container id is specified)\");\n    opts.addOption(APP_OWNER_OPTION, true,\n      \"AppOwner (assumed to be current user if not specified)\");\n    opts.getOption(APPLICATION_ID_OPTION).setArgName(\"Application ID\");\n    opts.getOption(CONTAINER_ID_OPTION).setArgName(\"Container ID\");\n    opts.getOption(NODE_ADDRESS_OPTION).setArgName(\"Node Address\");\n    opts.getOption(APP_OWNER_OPTION).setArgName(\"Application Owner\");\n\n    Options printOpts \u003d new Options();\n    printOpts.addOption(opts.getOption(CONTAINER_ID_OPTION));\n    printOpts.addOption(opts.getOption(NODE_ADDRESS_OPTION));\n    printOpts.addOption(opts.getOption(APP_OWNER_OPTION));\n\n    if (args.length \u003c 1) {\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      printHelpMessage(printOpts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n    int resultCode \u003d 0;\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      resultCode \u003d dumpAllContainersLogs(appId, appOwner, System.out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      printHelpMessage(printOpts);\n      resultCode \u003d -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir,\n                  appId,\n                  appOwner,\n                  ConverterUtils.toNodeId(nodeAddress),\n                  LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n      resultCode \u003d dumpAContainerLogs(containerIdStr, reader, System.out);\n    }\n\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogDumper.java",
      "extendedDetails": {}
    },
    "67699c2d187a8480a46acf5031652ff19196823d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-200. yarn log does not output all needed information, and is in a binary format. Contributed by Ravi Prakash\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1458466 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/03/13 12:29 PM",
      "commitName": "67699c2d187a8480a46acf5031652ff19196823d",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 223.59,
      "commitsBetweenForRepo": 1140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,77 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n-    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n-    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n-    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n-    opts.addOption(APP_OWNER_OPTION, true, \"AppOwner\");\n+    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n+    opts.addOption(CONTAINER_ID_OPTION, true,\n+      \"ContainerId (must be specified if node address is specified)\");\n+    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n+      + \"nodename:port (must be specified if container id is specified)\");\n+    opts.addOption(APP_OWNER_OPTION, true,\n+      \"AppOwner (assumed to be current user if not specified)\");\n \n     if (args.length \u003c 1) {\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n     } catch (ParseException e) {\n       System.out.println(\"options parsing failed: \" + e.getMessage());\n \n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.out.println(\"ApplicationId cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     RecordFactory recordFactory \u003d\n         RecordFactoryProvider.getRecordFactory(getConf());\n     ApplicationId appId \u003d\n         ConverterUtils.toApplicationId(recordFactory, appIdStr);\n \n-    DataOutputStream out \u003d new DataOutputStream(System.out);\n-\n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n     int resultCode \u003d 0;\n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n-      resultCode \u003d dumpAllContainersLogs(appId, appOwner, out);\n+      resultCode \u003d dumpAllContainersLogs(appId, appOwner, System.out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       resultCode \u003d -1;\n     } else {\n       Path remoteRootLogDir \u003d\n         new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n       AggregatedLogFormat.LogReader reader \u003d\n           new AggregatedLogFormat.LogReader(getConf(),\n               LogAggregationUtils.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir,\n                   appId,\n                   appOwner,\n                   ConverterUtils.toNodeId(nodeAddress),\n                   LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n-      resultCode \u003d dumpAContainerLogs(containerIdStr, reader, out);\n+      resultCode \u003d dumpAContainerLogs(containerIdStr, reader, System.out);\n     }\n \n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId (required)\");\n    opts.addOption(CONTAINER_ID_OPTION, true,\n      \"ContainerId (must be specified if node address is specified)\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress in the format \"\n      + \"nodename:port (must be specified if container id is specified)\");\n    opts.addOption(APP_OWNER_OPTION, true,\n      \"AppOwner (assumed to be current user if not specified)\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n    int resultCode \u003d 0;\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      resultCode \u003d dumpAllContainersLogs(appId, appOwner, System.out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      resultCode \u003d -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir,\n                  appId,\n                  appOwner,\n                  ConverterUtils.toNodeId(nodeAddress),\n                  LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n      resultCode \u003d dumpAContainerLogs(containerIdStr, reader, System.out);\n    }\n\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogDumper.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n    opts.addOption(APP_OWNER_OPTION, true, \"AppOwner\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n    int resultCode \u003d 0;\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      resultCode \u003d dumpAllContainersLogs(appId, appOwner, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      resultCode \u003d -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir,\n                  appId,\n                  appOwner,\n                  ConverterUtils.toNodeId(nodeAddress),\n                  LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n      resultCode \u003d dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogDumper.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogDumper.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogDumper.java"
      }
    },
    "6ba0375b21c4ce07d2b6b592c4963f705c35222b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3744. Fix the yarn logs command line. Improve error messages for mapred job -logs. (Contributed by Jason Lowe)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1239433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/02/12 5:43 PM",
      "commitName": "6ba0375b21c4ce07d2b6b592c4963f705c35222b",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "03/11/11 1:02 AM",
      "commitNameOld": "c27601fefebd0af887a12d684bfc6f90d9fc0321",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 90.74,
      "commitsBetweenForRepo": 447,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n     opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n     opts.addOption(APP_OWNER_OPTION, true, \"AppOwner\");\n \n     if (args.length \u003c 1) {\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n     } catch (ParseException e) {\n       System.out.println(\"options parsing failed: \" + e.getMessage());\n \n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.out.println(\"ApplicationId cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     RecordFactory recordFactory \u003d\n         RecordFactoryProvider.getRecordFactory(getConf());\n     ApplicationId appId \u003d\n         ConverterUtils.toApplicationId(recordFactory, appIdStr);\n \n     DataOutputStream out \u003d new DataOutputStream(System.out);\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n+    int resultCode \u003d 0;\n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n-      dumpAllContainersLogs(appId, appOwner, out);\n+      resultCode \u003d dumpAllContainersLogs(appId, appOwner, out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n-      return -1;\n+      resultCode \u003d -1;\n     } else {\n       Path remoteRootLogDir \u003d\n         new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n       AggregatedLogFormat.LogReader reader \u003d\n           new AggregatedLogFormat.LogReader(getConf(),\n               LogAggregationUtils.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir,\n                   appId,\n                   appOwner,\n                   ConverterUtils.toNodeId(nodeAddress),\n-                  getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR_SUFFIX,\n-                      YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR_SUFFIX)));\n-      return dumpAContainerLogs(containerIdStr, reader, out);\n+                  LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n+      resultCode \u003d dumpAContainerLogs(containerIdStr, reader, out);\n     }\n \n-    return 0;\n+    return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n    opts.addOption(APP_OWNER_OPTION, true, \"AppOwner\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n    int resultCode \u003d 0;\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      resultCode \u003d dumpAllContainersLogs(appId, appOwner, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      resultCode \u003d -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir,\n                  appId,\n                  appOwner,\n                  ConverterUtils.toNodeId(nodeAddress),\n                  LogAggregationUtils.getRemoteNodeLogDirSuffix(getConf())));\n      resultCode \u003d dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return resultCode;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogDumper.java",
      "extendedDetails": {}
    },
    "c27601fefebd0af887a12d684bfc6f90d9fc0321": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "MAPREDUCE-3297. Moved log related components into yarn-common so that HistoryServer and clients can use them without depending on the yarn-server-nodemanager module. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1196986 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/11/11 1:02 AM",
      "commitName": "c27601fefebd0af887a12d684bfc6f90d9fc0321",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "MAPREDUCE-3297. Moved log related components into yarn-common so that HistoryServer and clients can use them without depending on the yarn-server-nodemanager module. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1196986 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/11/11 1:02 AM",
          "commitName": "c27601fefebd0af887a12d684bfc6f90d9fc0321",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/11/11 12:06 AM",
          "commitNameOld": "0df4878033b797b9313c887ca9d75f8ea104d029",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,76 +1,76 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n     opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n     opts.addOption(APP_OWNER_OPTION, true, \"AppOwner\");\n \n     if (args.length \u003c 1) {\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n     } catch (ParseException e) {\n       System.out.println(\"options parsing failed: \" + e.getMessage());\n \n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.out.println(\"ApplicationId cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     RecordFactory recordFactory \u003d\n         RecordFactoryProvider.getRecordFactory(getConf());\n     ApplicationId appId \u003d\n         ConverterUtils.toApplicationId(recordFactory, appIdStr);\n \n     DataOutputStream out \u003d new DataOutputStream(System.out);\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n       dumpAllContainersLogs(appId, appOwner, out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     } else {\n       Path remoteRootLogDir \u003d\n         new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n       AggregatedLogFormat.LogReader reader \u003d\n           new AggregatedLogFormat.LogReader(getConf(),\n-              LogAggregationService.getRemoteNodeLogFileForApp(\n+              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir,\n                   appId,\n                   appOwner,\n                   ConverterUtils.toNodeId(nodeAddress),\n                   getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR_SUFFIX,\n                       YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR_SUFFIX)));\n       return dumpAContainerLogs(containerIdStr, reader, out);\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n    opts.addOption(APP_OWNER_OPTION, true, \"AppOwner\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      dumpAllContainersLogs(appId, appOwner, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir,\n                  appId,\n                  appOwner,\n                  ConverterUtils.toNodeId(nodeAddress),\n                  getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR_SUFFIX,\n                      YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR_SUFFIX)));\n      return dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return 0;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogDumper.java",
          "extendedDetails": {
            "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
            "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogDumper.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3297. Moved log related components into yarn-common so that HistoryServer and clients can use them without depending on the yarn-server-nodemanager module. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1196986 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/11/11 1:02 AM",
          "commitName": "c27601fefebd0af887a12d684bfc6f90d9fc0321",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/11/11 12:06 AM",
          "commitNameOld": "0df4878033b797b9313c887ca9d75f8ea104d029",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,76 +1,76 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n     opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n     opts.addOption(APP_OWNER_OPTION, true, \"AppOwner\");\n \n     if (args.length \u003c 1) {\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     String appOwner \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n       appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n     } catch (ParseException e) {\n       System.out.println(\"options parsing failed: \" + e.getMessage());\n \n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.out.println(\"ApplicationId cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     RecordFactory recordFactory \u003d\n         RecordFactoryProvider.getRecordFactory(getConf());\n     ApplicationId appId \u003d\n         ConverterUtils.toApplicationId(recordFactory, appIdStr);\n \n     DataOutputStream out \u003d new DataOutputStream(System.out);\n \n     if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n       appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n     }\n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n       dumpAllContainersLogs(appId, appOwner, out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     } else {\n       Path remoteRootLogDir \u003d\n         new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n       AggregatedLogFormat.LogReader reader \u003d\n           new AggregatedLogFormat.LogReader(getConf(),\n-              LogAggregationService.getRemoteNodeLogFileForApp(\n+              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir,\n                   appId,\n                   appOwner,\n                   ConverterUtils.toNodeId(nodeAddress),\n                   getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR_SUFFIX,\n                       YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR_SUFFIX)));\n       return dumpAContainerLogs(containerIdStr, reader, out);\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n    opts.addOption(APP_OWNER_OPTION, true, \"AppOwner\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      dumpAllContainersLogs(appId, appOwner, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir,\n                  appId,\n                  appOwner,\n                  ConverterUtils.toNodeId(nodeAddress),\n                  getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR_SUFFIX,\n                      YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR_SUFFIX)));\n      return dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return 0;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogDumper.java",
          "extendedDetails": {}
        }
      ]
    },
    "47a381e306877750b5a3ce5d76e0a5ff652ec188": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3146. Added a MR specific command line to dump logs for a given TaskAttemptID. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195349 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/10/11 11:42 PM",
      "commitName": "47a381e306877750b5a3ce5d76e0a5ff652ec188",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/10/11 11:45 PM",
      "commitNameOld": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,76 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n     opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n+    opts.addOption(APP_OWNER_OPTION, true, \"AppOwner\");\n \n     if (args.length \u003c 1) {\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n+    String appOwner \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n+      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n     } catch (ParseException e) {\n       System.out.println(\"options parsing failed: \" + e.getMessage());\n \n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.out.println(\"ApplicationId cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     RecordFactory recordFactory \u003d\n         RecordFactoryProvider.getRecordFactory(getConf());\n     ApplicationId appId \u003d\n         ConverterUtils.toApplicationId(recordFactory, appIdStr);\n \n     DataOutputStream out \u003d new DataOutputStream(System.out);\n \n+    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n+      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n+    }\n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n-      dumpAllContainersLogs(appId, out);\n+      dumpAllContainersLogs(appId, appOwner, out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     } else {\n       Path remoteRootLogDir \u003d\n         new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n       AggregatedLogFormat.LogReader reader \u003d\n           new AggregatedLogFormat.LogReader(getConf(),\n               LogAggregationService.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir,\n                   appId,\n-                  UserGroupInformation.getCurrentUser().getShortUserName(),\n+                  appOwner,\n                   ConverterUtils.toNodeId(nodeAddress),\n                   getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR_SUFFIX,\n                       YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR_SUFFIX)));\n       return dumpAContainerLogs(containerIdStr, reader, out);\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n    opts.addOption(APP_OWNER_OPTION, true, \"AppOwner\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    String appOwner \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n      appOwner \u003d commandLine.getOptionValue(APP_OWNER_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (appOwner \u003d\u003d null || appOwner.isEmpty()) {\n      appOwner \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n    }\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      dumpAllContainersLogs(appId, appOwner, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationService.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir,\n                  appId,\n                  appOwner,\n                  ConverterUtils.toNodeId(nodeAddress),\n                  getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR_SUFFIX,\n                      YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR_SUFFIX)));\n      return dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
      "extendedDetails": {}
    },
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2989. Modified JobHistory to link to task and AM logs from the JobHistoryServer. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 11:45 PM",
      "commitName": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "08/09/11 6:44 PM",
      "commitNameOld": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 49.21,
      "commitsBetweenForRepo": 395,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,70 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n     opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n \n     if (args.length \u003c 1) {\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n     } catch (ParseException e) {\n       System.out.println(\"options parsing failed: \" + e.getMessage());\n \n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.out.println(\"ApplicationId cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     RecordFactory recordFactory \u003d\n         RecordFactoryProvider.getRecordFactory(getConf());\n     ApplicationId appId \u003d\n         ConverterUtils.toApplicationId(recordFactory, appIdStr);\n \n     DataOutputStream out \u003d new DataOutputStream(System.out);\n \n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n       dumpAllContainersLogs(appId, out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     } else {\n       Path remoteRootLogDir \u003d\n         new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n       AggregatedLogFormat.LogReader reader \u003d\n           new AggregatedLogFormat.LogReader(getConf(),\n               LogAggregationService.getRemoteNodeLogFileForApp(\n-                  remoteRootLogDir, appId, nodeAddress));\n+                  remoteRootLogDir,\n+                  appId,\n+                  UserGroupInformation.getCurrentUser().getShortUserName(),\n+                  ConverterUtils.toNodeId(nodeAddress),\n+                  getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR_SUFFIX,\n+                      YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR_SUFFIX)));\n       return dumpAContainerLogs(containerIdStr, reader, out);\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      dumpAllContainersLogs(appId, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationService.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir,\n                  appId,\n                  UserGroupInformation.getCurrentUser().getShortUserName(),\n                  ConverterUtils.toNodeId(nodeAddress),\n                  getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR_SUFFIX,\n                      YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR_SUFFIX)));\n      return dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
      "extendedDetails": {}
    },
    "fafe8cd28e726566509c679e19d7da622f29f90d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2864. Normalize configuration variable names for YARN. Contributed by Robert Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166955 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 6:44 PM",
      "commitName": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 15.06,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n     opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n     opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n \n     if (args.length \u003c 1) {\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     CommandLineParser parser \u003d new GnuParser();\n     String appIdStr \u003d null;\n     String containerIdStr \u003d null;\n     String nodeAddress \u003d null;\n     try {\n       CommandLine commandLine \u003d parser.parse(opts, args, true);\n       appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n       containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n       nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n     } catch (ParseException e) {\n       System.out.println(\"options parsing failed: \" + e.getMessage());\n \n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     if (appIdStr \u003d\u003d null) {\n       System.out.println(\"ApplicationId cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     }\n \n     RecordFactory recordFactory \u003d\n         RecordFactoryProvider.getRecordFactory(getConf());\n     ApplicationId appId \u003d\n         ConverterUtils.toApplicationId(recordFactory, appIdStr);\n \n     DataOutputStream out \u003d new DataOutputStream(System.out);\n \n     if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n       dumpAllContainersLogs(appId, out);\n     } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n         || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n       System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n       HelpFormatter formatter \u003d new HelpFormatter();\n       formatter.printHelp(\"general options are: \", opts);\n       return -1;\n     } else {\n       Path remoteRootLogDir \u003d\n-        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n-            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n+        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n+            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n       AggregatedLogFormat.LogReader reader \u003d\n           new AggregatedLogFormat.LogReader(getConf(),\n               LogAggregationService.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir, appId, nodeAddress));\n       return dumpAContainerLogs(containerIdStr, reader, out);\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      dumpAllContainersLogs(appId, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationService.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, appId, nodeAddress));\n      return dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      dumpAllContainersLogs(appId, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationService.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, appId, nodeAddress));\n      return dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Yexceptionschange,Ybodychange,Yparameterchange)",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,65 @@\n-  public void run(JobConf job, final TaskUmbilicalProtocol umbilical)\n-    throws IOException, InterruptedException, ClassNotFoundException {\n-    job.setBoolean(JobContext.SKIP_RECORDS, isSkipping());\n+  public int run(String[] args) throws Exception {\n \n-    if (isMapOrReduce()) {\n-      copyPhase \u003d getProgress().addPhase(\"copy\");\n-      sortPhase  \u003d getProgress().addPhase(\"sort\");\n-      reducePhase \u003d getProgress().addPhase(\"reduce\");\n-    }\n-    // start thread that will handle communication with parent\n-    TaskReporter reporter \u003d startReporter(umbilical);\n-    \n-    boolean useNewApi \u003d job.getUseNewReducer();\n-    initialize(job, getJobID(), reporter, useNewApi);\n+    Options opts \u003d new Options();\n+    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n+    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n+    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n \n-    // check if it is a cleanupJobTask\n-    if (jobCleanup) {\n-      runJobCleanupTask(umbilical, reporter);\n-      return;\n+    if (args.length \u003c 1) {\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n     }\n-    if (jobSetup) {\n-      runJobSetupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (taskCleanup) {\n-      runTaskCleanupTask(umbilical, reporter);\n-      return;\n-    }\n-    \n-    // Initialize the codec\n-    codec \u003d initCodec();\n-    RawKeyValueIterator rIter \u003d null;\n-    boolean isLocal \u003d \"local\".equals(job.get(JTConfig.JT_IPC_ADDRESS, \"local\"));\n-    if (!isLocal) {\n-      Class combinerClass \u003d conf.getCombinerClass();\n-      CombineOutputCollector combineCollector \u003d \n-        (null !\u003d combinerClass) ? \n- \t     new CombineOutputCollector(reduceCombineOutputCounter, reporter, conf) : null;\n \n-      Shuffle shuffle \u003d \n-        new Shuffle(getTaskID(), job, FileSystem.getLocal(job), umbilical, \n-                    super.lDirAlloc, reporter, codec, \n-                    combinerClass, combineCollector, \n-                    spilledRecordsCounter, reduceCombineInputCounter,\n-                    shuffledMapsCounter,\n-                    reduceShuffleBytes, failedShuffleCounter,\n-                    mergedMapOutputsCounter,\n-                    taskStatus, copyPhase, sortPhase, this,\n-                    mapOutputFile);\n-      rIter \u003d shuffle.run();\n+    CommandLineParser parser \u003d new GnuParser();\n+    String appIdStr \u003d null;\n+    String containerIdStr \u003d null;\n+    String nodeAddress \u003d null;\n+    try {\n+      CommandLine commandLine \u003d parser.parse(opts, args, true);\n+      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n+      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n+      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n+    } catch (ParseException e) {\n+      System.out.println(\"options parsing failed: \" + e.getMessage());\n+\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n+    }\n+\n+    if (appIdStr \u003d\u003d null) {\n+      System.out.println(\"ApplicationId cannot be null!\");\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n+    }\n+\n+    RecordFactory recordFactory \u003d\n+        RecordFactoryProvider.getRecordFactory(getConf());\n+    ApplicationId appId \u003d\n+        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n+\n+    DataOutputStream out \u003d new DataOutputStream(System.out);\n+\n+    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n+      dumpAllContainersLogs(appId, out);\n+    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n+        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n+      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n     } else {\n-      // local job runner doesn\u0027t have a copy phase\n-      copyPhase.complete();\n-      final FileSystem rfs \u003d FileSystem.getLocal(job).getRaw();\n-      rIter \u003d Merger.merge(job, rfs, job.getMapOutputKeyClass(),\n-                           job.getMapOutputValueClass(), codec, \n-                           getMapFiles(rfs, true),\n-                           !conf.getKeepFailedTaskFiles(), \n-                           job.getInt(JobContext.IO_SORT_FACTOR, 100),\n-                           new Path(getTaskID().toString()), \n-                           job.getOutputKeyComparator(),\n-                           reporter, spilledRecordsCounter, null, null);\n+      Path remoteRootLogDir \u003d\n+        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n+            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n+      AggregatedLogFormat.LogReader reader \u003d\n+          new AggregatedLogFormat.LogReader(getConf(),\n+              LogAggregationService.getRemoteNodeLogFileForApp(\n+                  remoteRootLogDir, appId, nodeAddress));\n+      return dumpAContainerLogs(containerIdStr, reader, out);\n     }\n-    // free up the data structures\n-    mapOutputFilesOnDisk.clear();\n-    \n-    sortPhase.complete();                         // sort is complete\n-    setPhase(TaskStatus.Phase.REDUCE); \n-    statusUpdate(umbilical);\n-    Class keyClass \u003d job.getMapOutputKeyClass();\n-    Class valueClass \u003d job.getMapOutputValueClass();\n-    RawComparator comparator \u003d job.getOutputValueGroupingComparator();\n \n-    if (useNewApi) {\n-      runNewReducer(job, umbilical, reporter, rIter, comparator, \n-                    keyClass, valueClass);\n-    } else {\n-      runOldReducer(job, umbilical, reporter, rIter, comparator, \n-                    keyClass, valueClass);\n-    }\n-    done(umbilical, reporter);\n+    return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      dumpAllContainersLogs(appId, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationService.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, appId, nodeAddress));\n      return dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return 0;\n  }",
          "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
          "extendedDetails": {
            "oldPath": "mapreduce/src/java/org/apache/hadoop/mapred/ReduceTask.java",
            "newPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
            "oldMethodName": "run",
            "newMethodName": "run"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,65 @@\n-  public void run(JobConf job, final TaskUmbilicalProtocol umbilical)\n-    throws IOException, InterruptedException, ClassNotFoundException {\n-    job.setBoolean(JobContext.SKIP_RECORDS, isSkipping());\n+  public int run(String[] args) throws Exception {\n \n-    if (isMapOrReduce()) {\n-      copyPhase \u003d getProgress().addPhase(\"copy\");\n-      sortPhase  \u003d getProgress().addPhase(\"sort\");\n-      reducePhase \u003d getProgress().addPhase(\"reduce\");\n-    }\n-    // start thread that will handle communication with parent\n-    TaskReporter reporter \u003d startReporter(umbilical);\n-    \n-    boolean useNewApi \u003d job.getUseNewReducer();\n-    initialize(job, getJobID(), reporter, useNewApi);\n+    Options opts \u003d new Options();\n+    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n+    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n+    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n \n-    // check if it is a cleanupJobTask\n-    if (jobCleanup) {\n-      runJobCleanupTask(umbilical, reporter);\n-      return;\n+    if (args.length \u003c 1) {\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n     }\n-    if (jobSetup) {\n-      runJobSetupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (taskCleanup) {\n-      runTaskCleanupTask(umbilical, reporter);\n-      return;\n-    }\n-    \n-    // Initialize the codec\n-    codec \u003d initCodec();\n-    RawKeyValueIterator rIter \u003d null;\n-    boolean isLocal \u003d \"local\".equals(job.get(JTConfig.JT_IPC_ADDRESS, \"local\"));\n-    if (!isLocal) {\n-      Class combinerClass \u003d conf.getCombinerClass();\n-      CombineOutputCollector combineCollector \u003d \n-        (null !\u003d combinerClass) ? \n- \t     new CombineOutputCollector(reduceCombineOutputCounter, reporter, conf) : null;\n \n-      Shuffle shuffle \u003d \n-        new Shuffle(getTaskID(), job, FileSystem.getLocal(job), umbilical, \n-                    super.lDirAlloc, reporter, codec, \n-                    combinerClass, combineCollector, \n-                    spilledRecordsCounter, reduceCombineInputCounter,\n-                    shuffledMapsCounter,\n-                    reduceShuffleBytes, failedShuffleCounter,\n-                    mergedMapOutputsCounter,\n-                    taskStatus, copyPhase, sortPhase, this,\n-                    mapOutputFile);\n-      rIter \u003d shuffle.run();\n+    CommandLineParser parser \u003d new GnuParser();\n+    String appIdStr \u003d null;\n+    String containerIdStr \u003d null;\n+    String nodeAddress \u003d null;\n+    try {\n+      CommandLine commandLine \u003d parser.parse(opts, args, true);\n+      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n+      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n+      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n+    } catch (ParseException e) {\n+      System.out.println(\"options parsing failed: \" + e.getMessage());\n+\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n+    }\n+\n+    if (appIdStr \u003d\u003d null) {\n+      System.out.println(\"ApplicationId cannot be null!\");\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n+    }\n+\n+    RecordFactory recordFactory \u003d\n+        RecordFactoryProvider.getRecordFactory(getConf());\n+    ApplicationId appId \u003d\n+        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n+\n+    DataOutputStream out \u003d new DataOutputStream(System.out);\n+\n+    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n+      dumpAllContainersLogs(appId, out);\n+    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n+        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n+      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n     } else {\n-      // local job runner doesn\u0027t have a copy phase\n-      copyPhase.complete();\n-      final FileSystem rfs \u003d FileSystem.getLocal(job).getRaw();\n-      rIter \u003d Merger.merge(job, rfs, job.getMapOutputKeyClass(),\n-                           job.getMapOutputValueClass(), codec, \n-                           getMapFiles(rfs, true),\n-                           !conf.getKeepFailedTaskFiles(), \n-                           job.getInt(JobContext.IO_SORT_FACTOR, 100),\n-                           new Path(getTaskID().toString()), \n-                           job.getOutputKeyComparator(),\n-                           reporter, spilledRecordsCounter, null, null);\n+      Path remoteRootLogDir \u003d\n+        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n+            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n+      AggregatedLogFormat.LogReader reader \u003d\n+          new AggregatedLogFormat.LogReader(getConf(),\n+              LogAggregationService.getRemoteNodeLogFileForApp(\n+                  remoteRootLogDir, appId, nodeAddress));\n+      return dumpAContainerLogs(containerIdStr, reader, out);\n     }\n-    // free up the data structures\n-    mapOutputFilesOnDisk.clear();\n-    \n-    sortPhase.complete();                         // sort is complete\n-    setPhase(TaskStatus.Phase.REDUCE); \n-    statusUpdate(umbilical);\n-    Class keyClass \u003d job.getMapOutputKeyClass();\n-    Class valueClass \u003d job.getMapOutputValueClass();\n-    RawComparator comparator \u003d job.getOutputValueGroupingComparator();\n \n-    if (useNewApi) {\n-      runNewReducer(job, umbilical, reporter, rIter, comparator, \n-                    keyClass, valueClass);\n-    } else {\n-      runOldReducer(job, umbilical, reporter, rIter, comparator, \n-                    keyClass, valueClass);\n-    }\n-    done(umbilical, reporter);\n+    return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      dumpAllContainersLogs(appId, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationService.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, appId, nodeAddress));\n      return dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return 0;\n  }",
          "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "int"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,65 @@\n-  public void run(JobConf job, final TaskUmbilicalProtocol umbilical)\n-    throws IOException, InterruptedException, ClassNotFoundException {\n-    job.setBoolean(JobContext.SKIP_RECORDS, isSkipping());\n+  public int run(String[] args) throws Exception {\n \n-    if (isMapOrReduce()) {\n-      copyPhase \u003d getProgress().addPhase(\"copy\");\n-      sortPhase  \u003d getProgress().addPhase(\"sort\");\n-      reducePhase \u003d getProgress().addPhase(\"reduce\");\n-    }\n-    // start thread that will handle communication with parent\n-    TaskReporter reporter \u003d startReporter(umbilical);\n-    \n-    boolean useNewApi \u003d job.getUseNewReducer();\n-    initialize(job, getJobID(), reporter, useNewApi);\n+    Options opts \u003d new Options();\n+    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n+    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n+    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n \n-    // check if it is a cleanupJobTask\n-    if (jobCleanup) {\n-      runJobCleanupTask(umbilical, reporter);\n-      return;\n+    if (args.length \u003c 1) {\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n     }\n-    if (jobSetup) {\n-      runJobSetupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (taskCleanup) {\n-      runTaskCleanupTask(umbilical, reporter);\n-      return;\n-    }\n-    \n-    // Initialize the codec\n-    codec \u003d initCodec();\n-    RawKeyValueIterator rIter \u003d null;\n-    boolean isLocal \u003d \"local\".equals(job.get(JTConfig.JT_IPC_ADDRESS, \"local\"));\n-    if (!isLocal) {\n-      Class combinerClass \u003d conf.getCombinerClass();\n-      CombineOutputCollector combineCollector \u003d \n-        (null !\u003d combinerClass) ? \n- \t     new CombineOutputCollector(reduceCombineOutputCounter, reporter, conf) : null;\n \n-      Shuffle shuffle \u003d \n-        new Shuffle(getTaskID(), job, FileSystem.getLocal(job), umbilical, \n-                    super.lDirAlloc, reporter, codec, \n-                    combinerClass, combineCollector, \n-                    spilledRecordsCounter, reduceCombineInputCounter,\n-                    shuffledMapsCounter,\n-                    reduceShuffleBytes, failedShuffleCounter,\n-                    mergedMapOutputsCounter,\n-                    taskStatus, copyPhase, sortPhase, this,\n-                    mapOutputFile);\n-      rIter \u003d shuffle.run();\n+    CommandLineParser parser \u003d new GnuParser();\n+    String appIdStr \u003d null;\n+    String containerIdStr \u003d null;\n+    String nodeAddress \u003d null;\n+    try {\n+      CommandLine commandLine \u003d parser.parse(opts, args, true);\n+      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n+      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n+      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n+    } catch (ParseException e) {\n+      System.out.println(\"options parsing failed: \" + e.getMessage());\n+\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n+    }\n+\n+    if (appIdStr \u003d\u003d null) {\n+      System.out.println(\"ApplicationId cannot be null!\");\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n+    }\n+\n+    RecordFactory recordFactory \u003d\n+        RecordFactoryProvider.getRecordFactory(getConf());\n+    ApplicationId appId \u003d\n+        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n+\n+    DataOutputStream out \u003d new DataOutputStream(System.out);\n+\n+    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n+      dumpAllContainersLogs(appId, out);\n+    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n+        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n+      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n     } else {\n-      // local job runner doesn\u0027t have a copy phase\n-      copyPhase.complete();\n-      final FileSystem rfs \u003d FileSystem.getLocal(job).getRaw();\n-      rIter \u003d Merger.merge(job, rfs, job.getMapOutputKeyClass(),\n-                           job.getMapOutputValueClass(), codec, \n-                           getMapFiles(rfs, true),\n-                           !conf.getKeepFailedTaskFiles(), \n-                           job.getInt(JobContext.IO_SORT_FACTOR, 100),\n-                           new Path(getTaskID().toString()), \n-                           job.getOutputKeyComparator(),\n-                           reporter, spilledRecordsCounter, null, null);\n+      Path remoteRootLogDir \u003d\n+        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n+            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n+      AggregatedLogFormat.LogReader reader \u003d\n+          new AggregatedLogFormat.LogReader(getConf(),\n+              LogAggregationService.getRemoteNodeLogFileForApp(\n+                  remoteRootLogDir, appId, nodeAddress));\n+      return dumpAContainerLogs(containerIdStr, reader, out);\n     }\n-    // free up the data structures\n-    mapOutputFilesOnDisk.clear();\n-    \n-    sortPhase.complete();                         // sort is complete\n-    setPhase(TaskStatus.Phase.REDUCE); \n-    statusUpdate(umbilical);\n-    Class keyClass \u003d job.getMapOutputKeyClass();\n-    Class valueClass \u003d job.getMapOutputValueClass();\n-    RawComparator comparator \u003d job.getOutputValueGroupingComparator();\n \n-    if (useNewApi) {\n-      runNewReducer(job, umbilical, reporter, rIter, comparator, \n-                    keyClass, valueClass);\n-    } else {\n-      runOldReducer(job, umbilical, reporter, rIter, comparator, \n-                    keyClass, valueClass);\n-    }\n-    done(umbilical, reporter);\n+    return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      dumpAllContainersLogs(appId, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationService.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, appId, nodeAddress));\n      return dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return 0;\n  }",
          "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
          "extendedDetails": {
            "oldValue": "[IOException, InterruptedException, ClassNotFoundException]",
            "newValue": "[Exception]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,65 @@\n-  public void run(JobConf job, final TaskUmbilicalProtocol umbilical)\n-    throws IOException, InterruptedException, ClassNotFoundException {\n-    job.setBoolean(JobContext.SKIP_RECORDS, isSkipping());\n+  public int run(String[] args) throws Exception {\n \n-    if (isMapOrReduce()) {\n-      copyPhase \u003d getProgress().addPhase(\"copy\");\n-      sortPhase  \u003d getProgress().addPhase(\"sort\");\n-      reducePhase \u003d getProgress().addPhase(\"reduce\");\n-    }\n-    // start thread that will handle communication with parent\n-    TaskReporter reporter \u003d startReporter(umbilical);\n-    \n-    boolean useNewApi \u003d job.getUseNewReducer();\n-    initialize(job, getJobID(), reporter, useNewApi);\n+    Options opts \u003d new Options();\n+    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n+    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n+    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n \n-    // check if it is a cleanupJobTask\n-    if (jobCleanup) {\n-      runJobCleanupTask(umbilical, reporter);\n-      return;\n+    if (args.length \u003c 1) {\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n     }\n-    if (jobSetup) {\n-      runJobSetupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (taskCleanup) {\n-      runTaskCleanupTask(umbilical, reporter);\n-      return;\n-    }\n-    \n-    // Initialize the codec\n-    codec \u003d initCodec();\n-    RawKeyValueIterator rIter \u003d null;\n-    boolean isLocal \u003d \"local\".equals(job.get(JTConfig.JT_IPC_ADDRESS, \"local\"));\n-    if (!isLocal) {\n-      Class combinerClass \u003d conf.getCombinerClass();\n-      CombineOutputCollector combineCollector \u003d \n-        (null !\u003d combinerClass) ? \n- \t     new CombineOutputCollector(reduceCombineOutputCounter, reporter, conf) : null;\n \n-      Shuffle shuffle \u003d \n-        new Shuffle(getTaskID(), job, FileSystem.getLocal(job), umbilical, \n-                    super.lDirAlloc, reporter, codec, \n-                    combinerClass, combineCollector, \n-                    spilledRecordsCounter, reduceCombineInputCounter,\n-                    shuffledMapsCounter,\n-                    reduceShuffleBytes, failedShuffleCounter,\n-                    mergedMapOutputsCounter,\n-                    taskStatus, copyPhase, sortPhase, this,\n-                    mapOutputFile);\n-      rIter \u003d shuffle.run();\n+    CommandLineParser parser \u003d new GnuParser();\n+    String appIdStr \u003d null;\n+    String containerIdStr \u003d null;\n+    String nodeAddress \u003d null;\n+    try {\n+      CommandLine commandLine \u003d parser.parse(opts, args, true);\n+      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n+      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n+      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n+    } catch (ParseException e) {\n+      System.out.println(\"options parsing failed: \" + e.getMessage());\n+\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n+    }\n+\n+    if (appIdStr \u003d\u003d null) {\n+      System.out.println(\"ApplicationId cannot be null!\");\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n+    }\n+\n+    RecordFactory recordFactory \u003d\n+        RecordFactoryProvider.getRecordFactory(getConf());\n+    ApplicationId appId \u003d\n+        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n+\n+    DataOutputStream out \u003d new DataOutputStream(System.out);\n+\n+    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n+      dumpAllContainersLogs(appId, out);\n+    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n+        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n+      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n     } else {\n-      // local job runner doesn\u0027t have a copy phase\n-      copyPhase.complete();\n-      final FileSystem rfs \u003d FileSystem.getLocal(job).getRaw();\n-      rIter \u003d Merger.merge(job, rfs, job.getMapOutputKeyClass(),\n-                           job.getMapOutputValueClass(), codec, \n-                           getMapFiles(rfs, true),\n-                           !conf.getKeepFailedTaskFiles(), \n-                           job.getInt(JobContext.IO_SORT_FACTOR, 100),\n-                           new Path(getTaskID().toString()), \n-                           job.getOutputKeyComparator(),\n-                           reporter, spilledRecordsCounter, null, null);\n+      Path remoteRootLogDir \u003d\n+        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n+            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n+      AggregatedLogFormat.LogReader reader \u003d\n+          new AggregatedLogFormat.LogReader(getConf(),\n+              LogAggregationService.getRemoteNodeLogFileForApp(\n+                  remoteRootLogDir, appId, nodeAddress));\n+      return dumpAContainerLogs(containerIdStr, reader, out);\n     }\n-    // free up the data structures\n-    mapOutputFilesOnDisk.clear();\n-    \n-    sortPhase.complete();                         // sort is complete\n-    setPhase(TaskStatus.Phase.REDUCE); \n-    statusUpdate(umbilical);\n-    Class keyClass \u003d job.getMapOutputKeyClass();\n-    Class valueClass \u003d job.getMapOutputValueClass();\n-    RawComparator comparator \u003d job.getOutputValueGroupingComparator();\n \n-    if (useNewApi) {\n-      runNewReducer(job, umbilical, reporter, rIter, comparator, \n-                    keyClass, valueClass);\n-    } else {\n-      runOldReducer(job, umbilical, reporter, rIter, comparator, \n-                    keyClass, valueClass);\n-    }\n-    done(umbilical, reporter);\n+    return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      dumpAllContainersLogs(appId, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationService.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, appId, nodeAddress));\n      return dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return 0;\n  }",
          "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,65 @@\n-  public void run(JobConf job, final TaskUmbilicalProtocol umbilical)\n-    throws IOException, InterruptedException, ClassNotFoundException {\n-    job.setBoolean(JobContext.SKIP_RECORDS, isSkipping());\n+  public int run(String[] args) throws Exception {\n \n-    if (isMapOrReduce()) {\n-      copyPhase \u003d getProgress().addPhase(\"copy\");\n-      sortPhase  \u003d getProgress().addPhase(\"sort\");\n-      reducePhase \u003d getProgress().addPhase(\"reduce\");\n-    }\n-    // start thread that will handle communication with parent\n-    TaskReporter reporter \u003d startReporter(umbilical);\n-    \n-    boolean useNewApi \u003d job.getUseNewReducer();\n-    initialize(job, getJobID(), reporter, useNewApi);\n+    Options opts \u003d new Options();\n+    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n+    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n+    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n \n-    // check if it is a cleanupJobTask\n-    if (jobCleanup) {\n-      runJobCleanupTask(umbilical, reporter);\n-      return;\n+    if (args.length \u003c 1) {\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n     }\n-    if (jobSetup) {\n-      runJobSetupTask(umbilical, reporter);\n-      return;\n-    }\n-    if (taskCleanup) {\n-      runTaskCleanupTask(umbilical, reporter);\n-      return;\n-    }\n-    \n-    // Initialize the codec\n-    codec \u003d initCodec();\n-    RawKeyValueIterator rIter \u003d null;\n-    boolean isLocal \u003d \"local\".equals(job.get(JTConfig.JT_IPC_ADDRESS, \"local\"));\n-    if (!isLocal) {\n-      Class combinerClass \u003d conf.getCombinerClass();\n-      CombineOutputCollector combineCollector \u003d \n-        (null !\u003d combinerClass) ? \n- \t     new CombineOutputCollector(reduceCombineOutputCounter, reporter, conf) : null;\n \n-      Shuffle shuffle \u003d \n-        new Shuffle(getTaskID(), job, FileSystem.getLocal(job), umbilical, \n-                    super.lDirAlloc, reporter, codec, \n-                    combinerClass, combineCollector, \n-                    spilledRecordsCounter, reduceCombineInputCounter,\n-                    shuffledMapsCounter,\n-                    reduceShuffleBytes, failedShuffleCounter,\n-                    mergedMapOutputsCounter,\n-                    taskStatus, copyPhase, sortPhase, this,\n-                    mapOutputFile);\n-      rIter \u003d shuffle.run();\n+    CommandLineParser parser \u003d new GnuParser();\n+    String appIdStr \u003d null;\n+    String containerIdStr \u003d null;\n+    String nodeAddress \u003d null;\n+    try {\n+      CommandLine commandLine \u003d parser.parse(opts, args, true);\n+      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n+      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n+      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n+    } catch (ParseException e) {\n+      System.out.println(\"options parsing failed: \" + e.getMessage());\n+\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n+    }\n+\n+    if (appIdStr \u003d\u003d null) {\n+      System.out.println(\"ApplicationId cannot be null!\");\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n+    }\n+\n+    RecordFactory recordFactory \u003d\n+        RecordFactoryProvider.getRecordFactory(getConf());\n+    ApplicationId appId \u003d\n+        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n+\n+    DataOutputStream out \u003d new DataOutputStream(System.out);\n+\n+    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n+      dumpAllContainersLogs(appId, out);\n+    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n+        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n+      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n+      HelpFormatter formatter \u003d new HelpFormatter();\n+      formatter.printHelp(\"general options are: \", opts);\n+      return -1;\n     } else {\n-      // local job runner doesn\u0027t have a copy phase\n-      copyPhase.complete();\n-      final FileSystem rfs \u003d FileSystem.getLocal(job).getRaw();\n-      rIter \u003d Merger.merge(job, rfs, job.getMapOutputKeyClass(),\n-                           job.getMapOutputValueClass(), codec, \n-                           getMapFiles(rfs, true),\n-                           !conf.getKeepFailedTaskFiles(), \n-                           job.getInt(JobContext.IO_SORT_FACTOR, 100),\n-                           new Path(getTaskID().toString()), \n-                           job.getOutputKeyComparator(),\n-                           reporter, spilledRecordsCounter, null, null);\n+      Path remoteRootLogDir \u003d\n+        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n+            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n+      AggregatedLogFormat.LogReader reader \u003d\n+          new AggregatedLogFormat.LogReader(getConf(),\n+              LogAggregationService.getRemoteNodeLogFileForApp(\n+                  remoteRootLogDir, appId, nodeAddress));\n+      return dumpAContainerLogs(containerIdStr, reader, out);\n     }\n-    // free up the data structures\n-    mapOutputFilesOnDisk.clear();\n-    \n-    sortPhase.complete();                         // sort is complete\n-    setPhase(TaskStatus.Phase.REDUCE); \n-    statusUpdate(umbilical);\n-    Class keyClass \u003d job.getMapOutputKeyClass();\n-    Class valueClass \u003d job.getMapOutputValueClass();\n-    RawComparator comparator \u003d job.getOutputValueGroupingComparator();\n \n-    if (useNewApi) {\n-      runNewReducer(job, umbilical, reporter, rIter, comparator, \n-                    keyClass, valueClass);\n-    } else {\n-      runOldReducer(job, umbilical, reporter, rIter, comparator, \n-                    keyClass, valueClass);\n-    }\n-    done(umbilical, reporter);\n+    return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(APPLICATION_ID_OPTION, true, \"ApplicationId\");\n    opts.addOption(CONTAINER_ID_OPTION, true, \"ContainerId\");\n    opts.addOption(NODE_ADDRESS_OPTION, true, \"NodeAddress\");\n\n    if (args.length \u003c 1) {\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    CommandLineParser parser \u003d new GnuParser();\n    String appIdStr \u003d null;\n    String containerIdStr \u003d null;\n    String nodeAddress \u003d null;\n    try {\n      CommandLine commandLine \u003d parser.parse(opts, args, true);\n      appIdStr \u003d commandLine.getOptionValue(APPLICATION_ID_OPTION);\n      containerIdStr \u003d commandLine.getOptionValue(CONTAINER_ID_OPTION);\n      nodeAddress \u003d commandLine.getOptionValue(NODE_ADDRESS_OPTION);\n    } catch (ParseException e) {\n      System.out.println(\"options parsing failed: \" + e.getMessage());\n\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    if (appIdStr \u003d\u003d null) {\n      System.out.println(\"ApplicationId cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    }\n\n    RecordFactory recordFactory \u003d\n        RecordFactoryProvider.getRecordFactory(getConf());\n    ApplicationId appId \u003d\n        ConverterUtils.toApplicationId(recordFactory, appIdStr);\n\n    DataOutputStream out \u003d new DataOutputStream(System.out);\n\n    if (containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress \u003d\u003d null) {\n      dumpAllContainersLogs(appId, out);\n    } else if ((containerIdStr \u003d\u003d null \u0026\u0026 nodeAddress !\u003d null)\n        || (containerIdStr !\u003d null \u0026\u0026 nodeAddress \u003d\u003d null)) {\n      System.out.println(\"ContainerId or NodeAddress cannot be null!\");\n      HelpFormatter formatter \u003d new HelpFormatter();\n      formatter.printHelp(\"general options are: \", opts);\n      return -1;\n    } else {\n      Path remoteRootLogDir \u003d\n        new Path(getConf().get(NMConfig.REMOTE_USER_LOG_DIR,\n            NMConfig.DEFAULT_REMOTE_APP_LOG_DIR));\n      AggregatedLogFormat.LogReader reader \u003d\n          new AggregatedLogFormat.LogReader(getConf(),\n              LogAggregationService.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, appId, nodeAddress));\n      return dumpAContainerLogs(containerIdStr, reader, out);\n    }\n\n    return 0;\n  }",
          "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogDumper.java",
          "extendedDetails": {
            "oldValue": "[job-JobConf, umbilical-TaskUmbilicalProtocol(modifiers-final)]",
            "newValue": "[args-String[]]"
          }
        }
      ]
    },
    "ded6f225a55517deedc2bd502f2b68f1ca2ddee8": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2837. Ported bug fixes from y-merge to prepare for MAPREDUCE-279 merge. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1157249 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/11 2:00 PM",
      "commitName": "ded6f225a55517deedc2bd502f2b68f1ca2ddee8",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 10.92,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,82 @@\n   public void run(JobConf job, final TaskUmbilicalProtocol umbilical)\n     throws IOException, InterruptedException, ClassNotFoundException {\n     job.setBoolean(JobContext.SKIP_RECORDS, isSkipping());\n \n     if (isMapOrReduce()) {\n       copyPhase \u003d getProgress().addPhase(\"copy\");\n       sortPhase  \u003d getProgress().addPhase(\"sort\");\n       reducePhase \u003d getProgress().addPhase(\"reduce\");\n     }\n     // start thread that will handle communication with parent\n     TaskReporter reporter \u003d startReporter(umbilical);\n     \n     boolean useNewApi \u003d job.getUseNewReducer();\n     initialize(job, getJobID(), reporter, useNewApi);\n \n     // check if it is a cleanupJobTask\n     if (jobCleanup) {\n       runJobCleanupTask(umbilical, reporter);\n       return;\n     }\n     if (jobSetup) {\n       runJobSetupTask(umbilical, reporter);\n       return;\n     }\n     if (taskCleanup) {\n       runTaskCleanupTask(umbilical, reporter);\n       return;\n     }\n     \n     // Initialize the codec\n     codec \u003d initCodec();\n     RawKeyValueIterator rIter \u003d null;\n     boolean isLocal \u003d \"local\".equals(job.get(JTConfig.JT_IPC_ADDRESS, \"local\"));\n     if (!isLocal) {\n       Class combinerClass \u003d conf.getCombinerClass();\n       CombineOutputCollector combineCollector \u003d \n         (null !\u003d combinerClass) ? \n  \t     new CombineOutputCollector(reduceCombineOutputCounter, reporter, conf) : null;\n \n       Shuffle shuffle \u003d \n         new Shuffle(getTaskID(), job, FileSystem.getLocal(job), umbilical, \n                     super.lDirAlloc, reporter, codec, \n                     combinerClass, combineCollector, \n                     spilledRecordsCounter, reduceCombineInputCounter,\n                     shuffledMapsCounter,\n                     reduceShuffleBytes, failedShuffleCounter,\n                     mergedMapOutputsCounter,\n-                    taskStatus, copyPhase, sortPhase, this);\n+                    taskStatus, copyPhase, sortPhase, this,\n+                    mapOutputFile);\n       rIter \u003d shuffle.run();\n     } else {\n       // local job runner doesn\u0027t have a copy phase\n       copyPhase.complete();\n       final FileSystem rfs \u003d FileSystem.getLocal(job).getRaw();\n       rIter \u003d Merger.merge(job, rfs, job.getMapOutputKeyClass(),\n                            job.getMapOutputValueClass(), codec, \n                            getMapFiles(rfs, true),\n                            !conf.getKeepFailedTaskFiles(), \n                            job.getInt(JobContext.IO_SORT_FACTOR, 100),\n                            new Path(getTaskID().toString()), \n                            job.getOutputKeyComparator(),\n                            reporter, spilledRecordsCounter, null, null);\n     }\n     // free up the data structures\n     mapOutputFilesOnDisk.clear();\n     \n     sortPhase.complete();                         // sort is complete\n     setPhase(TaskStatus.Phase.REDUCE); \n     statusUpdate(umbilical);\n     Class keyClass \u003d job.getMapOutputKeyClass();\n     Class valueClass \u003d job.getMapOutputValueClass();\n     RawComparator comparator \u003d job.getOutputValueGroupingComparator();\n \n     if (useNewApi) {\n       runNewReducer(job, umbilical, reporter, rIter, comparator, \n                     keyClass, valueClass);\n     } else {\n       runOldReducer(job, umbilical, reporter, rIter, comparator, \n                     keyClass, valueClass);\n     }\n     done(umbilical, reporter);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run(JobConf job, final TaskUmbilicalProtocol umbilical)\n    throws IOException, InterruptedException, ClassNotFoundException {\n    job.setBoolean(JobContext.SKIP_RECORDS, isSkipping());\n\n    if (isMapOrReduce()) {\n      copyPhase \u003d getProgress().addPhase(\"copy\");\n      sortPhase  \u003d getProgress().addPhase(\"sort\");\n      reducePhase \u003d getProgress().addPhase(\"reduce\");\n    }\n    // start thread that will handle communication with parent\n    TaskReporter reporter \u003d startReporter(umbilical);\n    \n    boolean useNewApi \u003d job.getUseNewReducer();\n    initialize(job, getJobID(), reporter, useNewApi);\n\n    // check if it is a cleanupJobTask\n    if (jobCleanup) {\n      runJobCleanupTask(umbilical, reporter);\n      return;\n    }\n    if (jobSetup) {\n      runJobSetupTask(umbilical, reporter);\n      return;\n    }\n    if (taskCleanup) {\n      runTaskCleanupTask(umbilical, reporter);\n      return;\n    }\n    \n    // Initialize the codec\n    codec \u003d initCodec();\n    RawKeyValueIterator rIter \u003d null;\n    boolean isLocal \u003d \"local\".equals(job.get(JTConfig.JT_IPC_ADDRESS, \"local\"));\n    if (!isLocal) {\n      Class combinerClass \u003d conf.getCombinerClass();\n      CombineOutputCollector combineCollector \u003d \n        (null !\u003d combinerClass) ? \n \t     new CombineOutputCollector(reduceCombineOutputCounter, reporter, conf) : null;\n\n      Shuffle shuffle \u003d \n        new Shuffle(getTaskID(), job, FileSystem.getLocal(job), umbilical, \n                    super.lDirAlloc, reporter, codec, \n                    combinerClass, combineCollector, \n                    spilledRecordsCounter, reduceCombineInputCounter,\n                    shuffledMapsCounter,\n                    reduceShuffleBytes, failedShuffleCounter,\n                    mergedMapOutputsCounter,\n                    taskStatus, copyPhase, sortPhase, this,\n                    mapOutputFile);\n      rIter \u003d shuffle.run();\n    } else {\n      // local job runner doesn\u0027t have a copy phase\n      copyPhase.complete();\n      final FileSystem rfs \u003d FileSystem.getLocal(job).getRaw();\n      rIter \u003d Merger.merge(job, rfs, job.getMapOutputKeyClass(),\n                           job.getMapOutputValueClass(), codec, \n                           getMapFiles(rfs, true),\n                           !conf.getKeepFailedTaskFiles(), \n                           job.getInt(JobContext.IO_SORT_FACTOR, 100),\n                           new Path(getTaskID().toString()), \n                           job.getOutputKeyComparator(),\n                           reporter, spilledRecordsCounter, null, null);\n    }\n    // free up the data structures\n    mapOutputFilesOnDisk.clear();\n    \n    sortPhase.complete();                         // sort is complete\n    setPhase(TaskStatus.Phase.REDUCE); \n    statusUpdate(umbilical);\n    Class keyClass \u003d job.getMapOutputKeyClass();\n    Class valueClass \u003d job.getMapOutputValueClass();\n    RawComparator comparator \u003d job.getOutputValueGroupingComparator();\n\n    if (useNewApi) {\n      runNewReducer(job, umbilical, reporter, rIter, comparator, \n                    keyClass, valueClass);\n    } else {\n      runOldReducer(job, umbilical, reporter, rIter, comparator, \n                    keyClass, valueClass);\n    }\n    done(umbilical, reporter);\n  }",
      "path": "mapreduce/src/java/org/apache/hadoop/mapred/ReduceTask.java",
      "extendedDetails": {}
    },
    "9bac807cedbcff34e1a144fb475eff267e5ed86d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2187. Reporter sends progress during sort/merge. Contributed by Anupam Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152964 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/08/11 3:53 PM",
      "commitName": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "13/07/11 4:36 PM",
      "commitNameOld": "4796e1adcb912005198c9003305c97cf3a8b523e",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 18.97,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,81 @@\n   public void run(JobConf job, final TaskUmbilicalProtocol umbilical)\n     throws IOException, InterruptedException, ClassNotFoundException {\n     job.setBoolean(JobContext.SKIP_RECORDS, isSkipping());\n \n     if (isMapOrReduce()) {\n       copyPhase \u003d getProgress().addPhase(\"copy\");\n       sortPhase  \u003d getProgress().addPhase(\"sort\");\n       reducePhase \u003d getProgress().addPhase(\"reduce\");\n     }\n     // start thread that will handle communication with parent\n     TaskReporter reporter \u003d startReporter(umbilical);\n     \n     boolean useNewApi \u003d job.getUseNewReducer();\n     initialize(job, getJobID(), reporter, useNewApi);\n \n     // check if it is a cleanupJobTask\n     if (jobCleanup) {\n       runJobCleanupTask(umbilical, reporter);\n       return;\n     }\n     if (jobSetup) {\n       runJobSetupTask(umbilical, reporter);\n       return;\n     }\n     if (taskCleanup) {\n       runTaskCleanupTask(umbilical, reporter);\n       return;\n     }\n     \n     // Initialize the codec\n     codec \u003d initCodec();\n     RawKeyValueIterator rIter \u003d null;\n     boolean isLocal \u003d \"local\".equals(job.get(JTConfig.JT_IPC_ADDRESS, \"local\"));\n     if (!isLocal) {\n       Class combinerClass \u003d conf.getCombinerClass();\n       CombineOutputCollector combineCollector \u003d \n         (null !\u003d combinerClass) ? \n-            new CombineOutputCollector(reduceCombineOutputCounter) : null;\n+ \t     new CombineOutputCollector(reduceCombineOutputCounter, reporter, conf) : null;\n \n       Shuffle shuffle \u003d \n         new Shuffle(getTaskID(), job, FileSystem.getLocal(job), umbilical, \n                     super.lDirAlloc, reporter, codec, \n                     combinerClass, combineCollector, \n                     spilledRecordsCounter, reduceCombineInputCounter,\n                     shuffledMapsCounter,\n                     reduceShuffleBytes, failedShuffleCounter,\n                     mergedMapOutputsCounter,\n                     taskStatus, copyPhase, sortPhase, this);\n       rIter \u003d shuffle.run();\n     } else {\n       // local job runner doesn\u0027t have a copy phase\n       copyPhase.complete();\n       final FileSystem rfs \u003d FileSystem.getLocal(job).getRaw();\n       rIter \u003d Merger.merge(job, rfs, job.getMapOutputKeyClass(),\n                            job.getMapOutputValueClass(), codec, \n                            getMapFiles(rfs, true),\n                            !conf.getKeepFailedTaskFiles(), \n                            job.getInt(JobContext.IO_SORT_FACTOR, 100),\n                            new Path(getTaskID().toString()), \n                            job.getOutputKeyComparator(),\n                            reporter, spilledRecordsCounter, null, null);\n     }\n     // free up the data structures\n     mapOutputFilesOnDisk.clear();\n     \n     sortPhase.complete();                         // sort is complete\n     setPhase(TaskStatus.Phase.REDUCE); \n     statusUpdate(umbilical);\n     Class keyClass \u003d job.getMapOutputKeyClass();\n     Class valueClass \u003d job.getMapOutputValueClass();\n     RawComparator comparator \u003d job.getOutputValueGroupingComparator();\n \n     if (useNewApi) {\n       runNewReducer(job, umbilical, reporter, rIter, comparator, \n                     keyClass, valueClass);\n     } else {\n       runOldReducer(job, umbilical, reporter, rIter, comparator, \n                     keyClass, valueClass);\n     }\n     done(umbilical, reporter);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run(JobConf job, final TaskUmbilicalProtocol umbilical)\n    throws IOException, InterruptedException, ClassNotFoundException {\n    job.setBoolean(JobContext.SKIP_RECORDS, isSkipping());\n\n    if (isMapOrReduce()) {\n      copyPhase \u003d getProgress().addPhase(\"copy\");\n      sortPhase  \u003d getProgress().addPhase(\"sort\");\n      reducePhase \u003d getProgress().addPhase(\"reduce\");\n    }\n    // start thread that will handle communication with parent\n    TaskReporter reporter \u003d startReporter(umbilical);\n    \n    boolean useNewApi \u003d job.getUseNewReducer();\n    initialize(job, getJobID(), reporter, useNewApi);\n\n    // check if it is a cleanupJobTask\n    if (jobCleanup) {\n      runJobCleanupTask(umbilical, reporter);\n      return;\n    }\n    if (jobSetup) {\n      runJobSetupTask(umbilical, reporter);\n      return;\n    }\n    if (taskCleanup) {\n      runTaskCleanupTask(umbilical, reporter);\n      return;\n    }\n    \n    // Initialize the codec\n    codec \u003d initCodec();\n    RawKeyValueIterator rIter \u003d null;\n    boolean isLocal \u003d \"local\".equals(job.get(JTConfig.JT_IPC_ADDRESS, \"local\"));\n    if (!isLocal) {\n      Class combinerClass \u003d conf.getCombinerClass();\n      CombineOutputCollector combineCollector \u003d \n        (null !\u003d combinerClass) ? \n \t     new CombineOutputCollector(reduceCombineOutputCounter, reporter, conf) : null;\n\n      Shuffle shuffle \u003d \n        new Shuffle(getTaskID(), job, FileSystem.getLocal(job), umbilical, \n                    super.lDirAlloc, reporter, codec, \n                    combinerClass, combineCollector, \n                    spilledRecordsCounter, reduceCombineInputCounter,\n                    shuffledMapsCounter,\n                    reduceShuffleBytes, failedShuffleCounter,\n                    mergedMapOutputsCounter,\n                    taskStatus, copyPhase, sortPhase, this);\n      rIter \u003d shuffle.run();\n    } else {\n      // local job runner doesn\u0027t have a copy phase\n      copyPhase.complete();\n      final FileSystem rfs \u003d FileSystem.getLocal(job).getRaw();\n      rIter \u003d Merger.merge(job, rfs, job.getMapOutputKeyClass(),\n                           job.getMapOutputValueClass(), codec, \n                           getMapFiles(rfs, true),\n                           !conf.getKeepFailedTaskFiles(), \n                           job.getInt(JobContext.IO_SORT_FACTOR, 100),\n                           new Path(getTaskID().toString()), \n                           job.getOutputKeyComparator(),\n                           reporter, spilledRecordsCounter, null, null);\n    }\n    // free up the data structures\n    mapOutputFilesOnDisk.clear();\n    \n    sortPhase.complete();                         // sort is complete\n    setPhase(TaskStatus.Phase.REDUCE); \n    statusUpdate(umbilical);\n    Class keyClass \u003d job.getMapOutputKeyClass();\n    Class valueClass \u003d job.getMapOutputValueClass();\n    RawComparator comparator \u003d job.getOutputValueGroupingComparator();\n\n    if (useNewApi) {\n      runNewReducer(job, umbilical, reporter, rIter, comparator, \n                    keyClass, valueClass);\n    } else {\n      runOldReducer(job, umbilical, reporter, rIter, comparator, \n                    keyClass, valueClass);\n    }\n    done(umbilical, reporter);\n  }",
      "path": "mapreduce/src/java/org/apache/hadoop/mapred/ReduceTask.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,81 @@\n+  public void run(JobConf job, final TaskUmbilicalProtocol umbilical)\n+    throws IOException, InterruptedException, ClassNotFoundException {\n+    job.setBoolean(JobContext.SKIP_RECORDS, isSkipping());\n+\n+    if (isMapOrReduce()) {\n+      copyPhase \u003d getProgress().addPhase(\"copy\");\n+      sortPhase  \u003d getProgress().addPhase(\"sort\");\n+      reducePhase \u003d getProgress().addPhase(\"reduce\");\n+    }\n+    // start thread that will handle communication with parent\n+    TaskReporter reporter \u003d startReporter(umbilical);\n+    \n+    boolean useNewApi \u003d job.getUseNewReducer();\n+    initialize(job, getJobID(), reporter, useNewApi);\n+\n+    // check if it is a cleanupJobTask\n+    if (jobCleanup) {\n+      runJobCleanupTask(umbilical, reporter);\n+      return;\n+    }\n+    if (jobSetup) {\n+      runJobSetupTask(umbilical, reporter);\n+      return;\n+    }\n+    if (taskCleanup) {\n+      runTaskCleanupTask(umbilical, reporter);\n+      return;\n+    }\n+    \n+    // Initialize the codec\n+    codec \u003d initCodec();\n+    RawKeyValueIterator rIter \u003d null;\n+    boolean isLocal \u003d \"local\".equals(job.get(JTConfig.JT_IPC_ADDRESS, \"local\"));\n+    if (!isLocal) {\n+      Class combinerClass \u003d conf.getCombinerClass();\n+      CombineOutputCollector combineCollector \u003d \n+        (null !\u003d combinerClass) ? \n+            new CombineOutputCollector(reduceCombineOutputCounter) : null;\n+\n+      Shuffle shuffle \u003d \n+        new Shuffle(getTaskID(), job, FileSystem.getLocal(job), umbilical, \n+                    super.lDirAlloc, reporter, codec, \n+                    combinerClass, combineCollector, \n+                    spilledRecordsCounter, reduceCombineInputCounter,\n+                    shuffledMapsCounter,\n+                    reduceShuffleBytes, failedShuffleCounter,\n+                    mergedMapOutputsCounter,\n+                    taskStatus, copyPhase, sortPhase, this);\n+      rIter \u003d shuffle.run();\n+    } else {\n+      // local job runner doesn\u0027t have a copy phase\n+      copyPhase.complete();\n+      final FileSystem rfs \u003d FileSystem.getLocal(job).getRaw();\n+      rIter \u003d Merger.merge(job, rfs, job.getMapOutputKeyClass(),\n+                           job.getMapOutputValueClass(), codec, \n+                           getMapFiles(rfs, true),\n+                           !conf.getKeepFailedTaskFiles(), \n+                           job.getInt(JobContext.IO_SORT_FACTOR, 100),\n+                           new Path(getTaskID().toString()), \n+                           job.getOutputKeyComparator(),\n+                           reporter, spilledRecordsCounter, null, null);\n+    }\n+    // free up the data structures\n+    mapOutputFilesOnDisk.clear();\n+    \n+    sortPhase.complete();                         // sort is complete\n+    setPhase(TaskStatus.Phase.REDUCE); \n+    statusUpdate(umbilical);\n+    Class keyClass \u003d job.getMapOutputKeyClass();\n+    Class valueClass \u003d job.getMapOutputValueClass();\n+    RawComparator comparator \u003d job.getOutputValueGroupingComparator();\n+\n+    if (useNewApi) {\n+      runNewReducer(job, umbilical, reporter, rIter, comparator, \n+                    keyClass, valueClass);\n+    } else {\n+      runOldReducer(job, umbilical, reporter, rIter, comparator, \n+                    keyClass, valueClass);\n+    }\n+    done(umbilical, reporter);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void run(JobConf job, final TaskUmbilicalProtocol umbilical)\n    throws IOException, InterruptedException, ClassNotFoundException {\n    job.setBoolean(JobContext.SKIP_RECORDS, isSkipping());\n\n    if (isMapOrReduce()) {\n      copyPhase \u003d getProgress().addPhase(\"copy\");\n      sortPhase  \u003d getProgress().addPhase(\"sort\");\n      reducePhase \u003d getProgress().addPhase(\"reduce\");\n    }\n    // start thread that will handle communication with parent\n    TaskReporter reporter \u003d startReporter(umbilical);\n    \n    boolean useNewApi \u003d job.getUseNewReducer();\n    initialize(job, getJobID(), reporter, useNewApi);\n\n    // check if it is a cleanupJobTask\n    if (jobCleanup) {\n      runJobCleanupTask(umbilical, reporter);\n      return;\n    }\n    if (jobSetup) {\n      runJobSetupTask(umbilical, reporter);\n      return;\n    }\n    if (taskCleanup) {\n      runTaskCleanupTask(umbilical, reporter);\n      return;\n    }\n    \n    // Initialize the codec\n    codec \u003d initCodec();\n    RawKeyValueIterator rIter \u003d null;\n    boolean isLocal \u003d \"local\".equals(job.get(JTConfig.JT_IPC_ADDRESS, \"local\"));\n    if (!isLocal) {\n      Class combinerClass \u003d conf.getCombinerClass();\n      CombineOutputCollector combineCollector \u003d \n        (null !\u003d combinerClass) ? \n            new CombineOutputCollector(reduceCombineOutputCounter) : null;\n\n      Shuffle shuffle \u003d \n        new Shuffle(getTaskID(), job, FileSystem.getLocal(job), umbilical, \n                    super.lDirAlloc, reporter, codec, \n                    combinerClass, combineCollector, \n                    spilledRecordsCounter, reduceCombineInputCounter,\n                    shuffledMapsCounter,\n                    reduceShuffleBytes, failedShuffleCounter,\n                    mergedMapOutputsCounter,\n                    taskStatus, copyPhase, sortPhase, this);\n      rIter \u003d shuffle.run();\n    } else {\n      // local job runner doesn\u0027t have a copy phase\n      copyPhase.complete();\n      final FileSystem rfs \u003d FileSystem.getLocal(job).getRaw();\n      rIter \u003d Merger.merge(job, rfs, job.getMapOutputKeyClass(),\n                           job.getMapOutputValueClass(), codec, \n                           getMapFiles(rfs, true),\n                           !conf.getKeepFailedTaskFiles(), \n                           job.getInt(JobContext.IO_SORT_FACTOR, 100),\n                           new Path(getTaskID().toString()), \n                           job.getOutputKeyComparator(),\n                           reporter, spilledRecordsCounter, null, null);\n    }\n    // free up the data structures\n    mapOutputFilesOnDisk.clear();\n    \n    sortPhase.complete();                         // sort is complete\n    setPhase(TaskStatus.Phase.REDUCE); \n    statusUpdate(umbilical);\n    Class keyClass \u003d job.getMapOutputKeyClass();\n    Class valueClass \u003d job.getMapOutputValueClass();\n    RawComparator comparator \u003d job.getOutputValueGroupingComparator();\n\n    if (useNewApi) {\n      runNewReducer(job, umbilical, reporter, rIter, comparator, \n                    keyClass, valueClass);\n    } else {\n      runOldReducer(job, umbilical, reporter, rIter, comparator, \n                    keyClass, valueClass);\n    }\n    done(umbilical, reporter);\n  }",
      "path": "mapreduce/src/java/org/apache/hadoop/mapred/ReduceTask.java"
    }
  }
}