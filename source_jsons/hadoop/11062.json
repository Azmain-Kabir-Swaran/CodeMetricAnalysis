{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockReceiver.java",
  "functionName": "sendAckUpstreamUnprotected",
  "functionId": "sendAckUpstreamUnprotected___ack-PipelineAck__seqno-long__totalAckTimeNanos-long__offsetInBlock-long__myHeader-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
  "functionStartLine": 1597,
  "functionEndLine": 1662,
  "numCommitsSeen": 160,
  "timeTaken": 4589,
  "changeHistory": [
    "462e25a3b264e1148d0cbca00db7f10d43a0555f",
    "5daa8d8631835de97d4e4979e507a080017ca159",
    "b80457158daf0dc712fbe5695625cc17d70d4bb4",
    "c4980a2f343778544ca20ebea1338651793ea0d9",
    "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae",
    "1c6b5d2b5841e5219a98937088cde4ae63869f80"
  ],
  "changeHistoryShort": {
    "462e25a3b264e1148d0cbca00db7f10d43a0555f": "Ybodychange",
    "5daa8d8631835de97d4e4979e507a080017ca159": "Ybodychange",
    "b80457158daf0dc712fbe5695625cc17d70d4bb4": "Ybodychange",
    "c4980a2f343778544ca20ebea1338651793ea0d9": "Ymultichange(Yparameterchange,Ybodychange)",
    "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae": "Ybodychange",
    "1c6b5d2b5841e5219a98937088cde4ae63869f80": "Yintroduced"
  },
  "changeHistoryDetails": {
    "462e25a3b264e1148d0cbca00db7f10d43a0555f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12814. Add blockId when warning slow mirror/disk in BlockReceiver. Contributed by Jiandan Yang.\n",
      "commitDate": "16/11/17 12:19 AM",
      "commitName": "462e25a3b264e1148d0cbca00db7f10d43a0555f",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "28/08/17 3:49 PM",
      "commitNameOld": "a1e3f84afe6c02cc642699634052d2fb60b30179",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 79.4,
      "commitsBetweenForRepo": 781,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n     private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n         long totalAckTimeNanos, long offsetInBlock, int myHeader)\n         throws IOException {\n       final int[] replies;\n       if (ack \u003d\u003d null) {\n         // A new OOB response is being sent from this node. Regardless of\n         // downstream nodes, reply should contain one reply.\n         replies \u003d new int[] { myHeader };\n       } else if (mirrorError) { // ack read error\n         int h \u003d PipelineAck.combineHeader(datanode.getECN(), Status.SUCCESS);\n         int h1 \u003d PipelineAck.combineHeader(datanode.getECN(), Status.ERROR);\n         replies \u003d new int[] {h, h1};\n       } else {\n         short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n             .getNumOfReplies();\n         replies \u003d new int[ackLen + 1];\n         replies[0] \u003d myHeader;\n         for (int i \u003d 0; i \u003c ackLen; ++i) {\n           replies[i + 1] \u003d ack.getHeaderFlag(i);\n         }\n         // If the mirror has reported that it received a corrupt packet,\n         // do self-destruct to mark myself bad, instead of making the\n         // mirror node bad. The mirror is guaranteed to be good without\n         // corrupt data on disk.\n         if (ackLen \u003e 0 \u0026\u0026 PipelineAck.getStatusFromHeader(replies[1]) \u003d\u003d\n           Status.ERROR_CHECKSUM) {\n           throw new IOException(\"Shutting down writer and responder \"\n               + \"since the down streams reported the data sent by this \"\n               + \"thread is corrupt\");\n         }\n       }\n       PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n           totalAckTimeNanos);\n       if (replyAck.isSuccess()\n           \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n         replicaInfo.setBytesAcked(offsetInBlock);\n       }\n       // send my ack back to upstream datanode\n       long begin \u003d Time.monotonicNow();\n       /* for test only, no-op in production system */\n       DataNodeFaultInjector.get().delaySendingAckToUpstream(inAddr);\n       replyAck.write(upstreamOut);\n       upstreamOut.flush();\n       long duration \u003d Time.monotonicNow() - begin;\n       DataNodeFaultInjector.get().logDelaySendingAckToUpstream(\n           inAddr,\n           duration);\n       if (duration \u003e datanodeSlowLogThresholdMs) {\n         LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n             + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n-            + \", replyAck\u003d\" + replyAck);\n+            + \", replyAck\u003d\" + replyAck\n+            + \", downstream DNs\u003d\" + Arrays.toString(downstreamDNs)\n+            + \", blockId\u003d\" + replicaInfo.getBlockId());\n       } else if (LOG.isDebugEnabled()) {\n         LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n       }\n \n       // If a corruption was detected in the received data, terminate after\n       // sending ERROR_CHECKSUM back.\n       Status myStatus \u003d PipelineAck.getStatusFromHeader(myHeader);\n       if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n         throw new IOException(\"Shutting down writer and responder \"\n             + \"due to a checksum error in received data. The error \"\n             + \"response has been sent upstream.\");\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n        long totalAckTimeNanos, long offsetInBlock, int myHeader)\n        throws IOException {\n      final int[] replies;\n      if (ack \u003d\u003d null) {\n        // A new OOB response is being sent from this node. Regardless of\n        // downstream nodes, reply should contain one reply.\n        replies \u003d new int[] { myHeader };\n      } else if (mirrorError) { // ack read error\n        int h \u003d PipelineAck.combineHeader(datanode.getECN(), Status.SUCCESS);\n        int h1 \u003d PipelineAck.combineHeader(datanode.getECN(), Status.ERROR);\n        replies \u003d new int[] {h, h1};\n      } else {\n        short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n            .getNumOfReplies();\n        replies \u003d new int[ackLen + 1];\n        replies[0] \u003d myHeader;\n        for (int i \u003d 0; i \u003c ackLen; ++i) {\n          replies[i + 1] \u003d ack.getHeaderFlag(i);\n        }\n        // If the mirror has reported that it received a corrupt packet,\n        // do self-destruct to mark myself bad, instead of making the\n        // mirror node bad. The mirror is guaranteed to be good without\n        // corrupt data on disk.\n        if (ackLen \u003e 0 \u0026\u0026 PipelineAck.getStatusFromHeader(replies[1]) \u003d\u003d\n          Status.ERROR_CHECKSUM) {\n          throw new IOException(\"Shutting down writer and responder \"\n              + \"since the down streams reported the data sent by this \"\n              + \"thread is corrupt\");\n        }\n      }\n      PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n          totalAckTimeNanos);\n      if (replyAck.isSuccess()\n          \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n        replicaInfo.setBytesAcked(offsetInBlock);\n      }\n      // send my ack back to upstream datanode\n      long begin \u003d Time.monotonicNow();\n      /* for test only, no-op in production system */\n      DataNodeFaultInjector.get().delaySendingAckToUpstream(inAddr);\n      replyAck.write(upstreamOut);\n      upstreamOut.flush();\n      long duration \u003d Time.monotonicNow() - begin;\n      DataNodeFaultInjector.get().logDelaySendingAckToUpstream(\n          inAddr,\n          duration);\n      if (duration \u003e datanodeSlowLogThresholdMs) {\n        LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n            + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n            + \", replyAck\u003d\" + replyAck\n            + \", downstream DNs\u003d\" + Arrays.toString(downstreamDNs)\n            + \", blockId\u003d\" + replicaInfo.getBlockId());\n      } else if (LOG.isDebugEnabled()) {\n        LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n      }\n\n      // If a corruption was detected in the received data, terminate after\n      // sending ERROR_CHECKSUM back.\n      Status myStatus \u003d PipelineAck.getStatusFromHeader(myHeader);\n      if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n        throw new IOException(\"Shutting down writer and responder \"\n            + \"due to a checksum error in received data. The error \"\n            + \"response has been sent upstream.\");\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "5daa8d8631835de97d4e4979e507a080017ca159": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10913. Introduce fault injectors to simulate slow mirrors. Contributed by Xiaobing Zhou.\n",
      "commitDate": "20/12/16 1:17 PM",
      "commitName": "5daa8d8631835de97d4e4979e507a080017ca159",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "14/12/16 11:18 AM",
      "commitNameOld": "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 6.08,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,64 @@\n     private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n         long totalAckTimeNanos, long offsetInBlock, int myHeader)\n         throws IOException {\n       final int[] replies;\n       if (ack \u003d\u003d null) {\n         // A new OOB response is being sent from this node. Regardless of\n         // downstream nodes, reply should contain one reply.\n         replies \u003d new int[] { myHeader };\n       } else if (mirrorError) { // ack read error\n         int h \u003d PipelineAck.combineHeader(datanode.getECN(), Status.SUCCESS);\n         int h1 \u003d PipelineAck.combineHeader(datanode.getECN(), Status.ERROR);\n         replies \u003d new int[] {h, h1};\n       } else {\n         short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n             .getNumOfReplies();\n         replies \u003d new int[ackLen + 1];\n         replies[0] \u003d myHeader;\n         for (int i \u003d 0; i \u003c ackLen; ++i) {\n           replies[i + 1] \u003d ack.getHeaderFlag(i);\n         }\n         // If the mirror has reported that it received a corrupt packet,\n         // do self-destruct to mark myself bad, instead of making the\n         // mirror node bad. The mirror is guaranteed to be good without\n         // corrupt data on disk.\n         if (ackLen \u003e 0 \u0026\u0026 PipelineAck.getStatusFromHeader(replies[1]) \u003d\u003d\n           Status.ERROR_CHECKSUM) {\n           throw new IOException(\"Shutting down writer and responder \"\n               + \"since the down streams reported the data sent by this \"\n               + \"thread is corrupt\");\n         }\n       }\n       PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n           totalAckTimeNanos);\n       if (replyAck.isSuccess()\n           \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n         replicaInfo.setBytesAcked(offsetInBlock);\n       }\n       // send my ack back to upstream datanode\n       long begin \u003d Time.monotonicNow();\n+      /* for test only, no-op in production system */\n+      DataNodeFaultInjector.get().delaySendingAckToUpstream(inAddr);\n       replyAck.write(upstreamOut);\n       upstreamOut.flush();\n       long duration \u003d Time.monotonicNow() - begin;\n+      DataNodeFaultInjector.get().logDelaySendingAckToUpstream(\n+          inAddr,\n+          duration);\n       if (duration \u003e datanodeSlowLogThresholdMs) {\n         LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n             + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n             + \", replyAck\u003d\" + replyAck);\n       } else if (LOG.isDebugEnabled()) {\n         LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n       }\n \n       // If a corruption was detected in the received data, terminate after\n       // sending ERROR_CHECKSUM back.\n       Status myStatus \u003d PipelineAck.getStatusFromHeader(myHeader);\n       if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n         throw new IOException(\"Shutting down writer and responder \"\n             + \"due to a checksum error in received data. The error \"\n             + \"response has been sent upstream.\");\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n        long totalAckTimeNanos, long offsetInBlock, int myHeader)\n        throws IOException {\n      final int[] replies;\n      if (ack \u003d\u003d null) {\n        // A new OOB response is being sent from this node. Regardless of\n        // downstream nodes, reply should contain one reply.\n        replies \u003d new int[] { myHeader };\n      } else if (mirrorError) { // ack read error\n        int h \u003d PipelineAck.combineHeader(datanode.getECN(), Status.SUCCESS);\n        int h1 \u003d PipelineAck.combineHeader(datanode.getECN(), Status.ERROR);\n        replies \u003d new int[] {h, h1};\n      } else {\n        short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n            .getNumOfReplies();\n        replies \u003d new int[ackLen + 1];\n        replies[0] \u003d myHeader;\n        for (int i \u003d 0; i \u003c ackLen; ++i) {\n          replies[i + 1] \u003d ack.getHeaderFlag(i);\n        }\n        // If the mirror has reported that it received a corrupt packet,\n        // do self-destruct to mark myself bad, instead of making the\n        // mirror node bad. The mirror is guaranteed to be good without\n        // corrupt data on disk.\n        if (ackLen \u003e 0 \u0026\u0026 PipelineAck.getStatusFromHeader(replies[1]) \u003d\u003d\n          Status.ERROR_CHECKSUM) {\n          throw new IOException(\"Shutting down writer and responder \"\n              + \"since the down streams reported the data sent by this \"\n              + \"thread is corrupt\");\n        }\n      }\n      PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n          totalAckTimeNanos);\n      if (replyAck.isSuccess()\n          \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n        replicaInfo.setBytesAcked(offsetInBlock);\n      }\n      // send my ack back to upstream datanode\n      long begin \u003d Time.monotonicNow();\n      /* for test only, no-op in production system */\n      DataNodeFaultInjector.get().delaySendingAckToUpstream(inAddr);\n      replyAck.write(upstreamOut);\n      upstreamOut.flush();\n      long duration \u003d Time.monotonicNow() - begin;\n      DataNodeFaultInjector.get().logDelaySendingAckToUpstream(\n          inAddr,\n          duration);\n      if (duration \u003e datanodeSlowLogThresholdMs) {\n        LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n            + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n            + \", replyAck\u003d\" + replyAck);\n      } else if (LOG.isDebugEnabled()) {\n        LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n      }\n\n      // If a corruption was detected in the received data, terminate after\n      // sending ERROR_CHECKSUM back.\n      Status myStatus \u003d PipelineAck.getStatusFromHeader(myHeader);\n      if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n        throw new IOException(\"Shutting down writer and responder \"\n            + \"due to a checksum error in received data. The error \"\n            + \"response has been sent upstream.\");\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "b80457158daf0dc712fbe5695625cc17d70d4bb4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7748. Separate ECN flags from the Status in the DataTransferPipelineAck. Contributed by Anu Engineer and Haohui Mai.\n",
      "commitDate": "30/03/15 11:59 AM",
      "commitName": "b80457158daf0dc712fbe5695625cc17d70d4bb4",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "21/02/15 3:38 PM",
      "commitNameOld": "8b465b4b8caed31ca9daeaae108f9a868a30a455",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 36.81,
      "commitsBetweenForRepo": 313,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n     private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n         long totalAckTimeNanos, long offsetInBlock, int myHeader)\n         throws IOException {\n       final int[] replies;\n       if (ack \u003d\u003d null) {\n         // A new OOB response is being sent from this node. Regardless of\n         // downstream nodes, reply should contain one reply.\n         replies \u003d new int[] { myHeader };\n       } else if (mirrorError) { // ack read error\n         int h \u003d PipelineAck.combineHeader(datanode.getECN(), Status.SUCCESS);\n         int h1 \u003d PipelineAck.combineHeader(datanode.getECN(), Status.ERROR);\n         replies \u003d new int[] {h, h1};\n       } else {\n         short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n             .getNumOfReplies();\n         replies \u003d new int[ackLen + 1];\n         replies[0] \u003d myHeader;\n         for (int i \u003d 0; i \u003c ackLen; ++i) {\n-          replies[i + 1] \u003d ack.getReply(i);\n+          replies[i + 1] \u003d ack.getHeaderFlag(i);\n         }\n         // If the mirror has reported that it received a corrupt packet,\n         // do self-destruct to mark myself bad, instead of making the\n         // mirror node bad. The mirror is guaranteed to be good without\n         // corrupt data on disk.\n         if (ackLen \u003e 0 \u0026\u0026 PipelineAck.getStatusFromHeader(replies[1]) \u003d\u003d\n           Status.ERROR_CHECKSUM) {\n           throw new IOException(\"Shutting down writer and responder \"\n               + \"since the down streams reported the data sent by this \"\n               + \"thread is corrupt\");\n         }\n       }\n       PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n           totalAckTimeNanos);\n       if (replyAck.isSuccess()\n           \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n         replicaInfo.setBytesAcked(offsetInBlock);\n       }\n       // send my ack back to upstream datanode\n       long begin \u003d Time.monotonicNow();\n       replyAck.write(upstreamOut);\n       upstreamOut.flush();\n       long duration \u003d Time.monotonicNow() - begin;\n       if (duration \u003e datanodeSlowLogThresholdMs) {\n         LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n             + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n             + \", replyAck\u003d\" + replyAck);\n       } else if (LOG.isDebugEnabled()) {\n         LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n       }\n \n       // If a corruption was detected in the received data, terminate after\n       // sending ERROR_CHECKSUM back.\n       Status myStatus \u003d PipelineAck.getStatusFromHeader(myHeader);\n       if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n         throw new IOException(\"Shutting down writer and responder \"\n             + \"due to a checksum error in received data. The error \"\n             + \"response has been sent upstream.\");\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n        long totalAckTimeNanos, long offsetInBlock, int myHeader)\n        throws IOException {\n      final int[] replies;\n      if (ack \u003d\u003d null) {\n        // A new OOB response is being sent from this node. Regardless of\n        // downstream nodes, reply should contain one reply.\n        replies \u003d new int[] { myHeader };\n      } else if (mirrorError) { // ack read error\n        int h \u003d PipelineAck.combineHeader(datanode.getECN(), Status.SUCCESS);\n        int h1 \u003d PipelineAck.combineHeader(datanode.getECN(), Status.ERROR);\n        replies \u003d new int[] {h, h1};\n      } else {\n        short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n            .getNumOfReplies();\n        replies \u003d new int[ackLen + 1];\n        replies[0] \u003d myHeader;\n        for (int i \u003d 0; i \u003c ackLen; ++i) {\n          replies[i + 1] \u003d ack.getHeaderFlag(i);\n        }\n        // If the mirror has reported that it received a corrupt packet,\n        // do self-destruct to mark myself bad, instead of making the\n        // mirror node bad. The mirror is guaranteed to be good without\n        // corrupt data on disk.\n        if (ackLen \u003e 0 \u0026\u0026 PipelineAck.getStatusFromHeader(replies[1]) \u003d\u003d\n          Status.ERROR_CHECKSUM) {\n          throw new IOException(\"Shutting down writer and responder \"\n              + \"since the down streams reported the data sent by this \"\n              + \"thread is corrupt\");\n        }\n      }\n      PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n          totalAckTimeNanos);\n      if (replyAck.isSuccess()\n          \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n        replicaInfo.setBytesAcked(offsetInBlock);\n      }\n      // send my ack back to upstream datanode\n      long begin \u003d Time.monotonicNow();\n      replyAck.write(upstreamOut);\n      upstreamOut.flush();\n      long duration \u003d Time.monotonicNow() - begin;\n      if (duration \u003e datanodeSlowLogThresholdMs) {\n        LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n            + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n            + \", replyAck\u003d\" + replyAck);\n      } else if (LOG.isDebugEnabled()) {\n        LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n      }\n\n      // If a corruption was detected in the received data, terminate after\n      // sending ERROR_CHECKSUM back.\n      Status myStatus \u003d PipelineAck.getStatusFromHeader(myHeader);\n      if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n        throw new IOException(\"Shutting down writer and responder \"\n            + \"due to a checksum error in received data. The error \"\n            + \"response has been sent upstream.\");\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "c4980a2f343778544ca20ebea1338651793ea0d9": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7270. Add congestion signaling capability to DataNode write protocol. Contributed by Haohui Mai.\n",
      "commitDate": "05/02/15 10:58 AM",
      "commitName": "c4980a2f343778544ca20ebea1338651793ea0d9",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7270. Add congestion signaling capability to DataNode write protocol. Contributed by Haohui Mai.\n",
          "commitDate": "05/02/15 10:58 AM",
          "commitName": "c4980a2f343778544ca20ebea1338651793ea0d9",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "22/01/15 10:37 AM",
          "commitNameOld": "5f124efb3e090f96f217bee22f3c8897f9772f14",
          "commitAuthorOld": "yliu",
          "daysBetweenCommits": 14.01,
          "commitsBetweenForRepo": 115,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,56 +1,59 @@\n     private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n-        long totalAckTimeNanos, long offsetInBlock, Status myStatus)\n+        long totalAckTimeNanos, long offsetInBlock, int myHeader)\n         throws IOException {\n-      Status[] replies \u003d null;\n+      final int[] replies;\n       if (ack \u003d\u003d null) {\n         // A new OOB response is being sent from this node. Regardless of\n         // downstream nodes, reply should contain one reply.\n-        replies \u003d new Status[1];\n-        replies[0] \u003d myStatus;\n+        replies \u003d new int[] { myHeader };\n       } else if (mirrorError) { // ack read error\n-        replies \u003d MIRROR_ERROR_STATUS;\n+        int h \u003d PipelineAck.combineHeader(datanode.getECN(), Status.SUCCESS);\n+        int h1 \u003d PipelineAck.combineHeader(datanode.getECN(), Status.ERROR);\n+        replies \u003d new int[] {h, h1};\n       } else {\n         short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n             .getNumOfReplies();\n-        replies \u003d new Status[1 + ackLen];\n-        replies[0] \u003d myStatus;\n-        for (int i \u003d 0; i \u003c ackLen; i++) {\n+        replies \u003d new int[ackLen + 1];\n+        replies[0] \u003d myHeader;\n+        for (int i \u003d 0; i \u003c ackLen; ++i) {\n           replies[i + 1] \u003d ack.getReply(i);\n         }\n         // If the mirror has reported that it received a corrupt packet,\n-        // do self-destruct to mark myself bad, instead of making the \n+        // do self-destruct to mark myself bad, instead of making the\n         // mirror node bad. The mirror is guaranteed to be good without\n         // corrupt data on disk.\n-        if (ackLen \u003e 0 \u0026\u0026 replies[1] \u003d\u003d Status.ERROR_CHECKSUM) {\n+        if (ackLen \u003e 0 \u0026\u0026 PipelineAck.getStatusFromHeader(replies[1]) \u003d\u003d\n+          Status.ERROR_CHECKSUM) {\n           throw new IOException(\"Shutting down writer and responder \"\n               + \"since the down streams reported the data sent by this \"\n               + \"thread is corrupt\");\n         }\n       }\n       PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n           totalAckTimeNanos);\n       if (replyAck.isSuccess()\n           \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n         replicaInfo.setBytesAcked(offsetInBlock);\n       }\n       // send my ack back to upstream datanode\n       long begin \u003d Time.monotonicNow();\n       replyAck.write(upstreamOut);\n       upstreamOut.flush();\n       long duration \u003d Time.monotonicNow() - begin;\n       if (duration \u003e datanodeSlowLogThresholdMs) {\n         LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n             + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n             + \", replyAck\u003d\" + replyAck);\n       } else if (LOG.isDebugEnabled()) {\n         LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n       }\n \n       // If a corruption was detected in the received data, terminate after\n-      // sending ERROR_CHECKSUM back. \n+      // sending ERROR_CHECKSUM back.\n+      Status myStatus \u003d PipelineAck.getStatusFromHeader(myHeader);\n       if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n         throw new IOException(\"Shutting down writer and responder \"\n             + \"due to a checksum error in received data. The error \"\n             + \"response has been sent upstream.\");\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n        long totalAckTimeNanos, long offsetInBlock, int myHeader)\n        throws IOException {\n      final int[] replies;\n      if (ack \u003d\u003d null) {\n        // A new OOB response is being sent from this node. Regardless of\n        // downstream nodes, reply should contain one reply.\n        replies \u003d new int[] { myHeader };\n      } else if (mirrorError) { // ack read error\n        int h \u003d PipelineAck.combineHeader(datanode.getECN(), Status.SUCCESS);\n        int h1 \u003d PipelineAck.combineHeader(datanode.getECN(), Status.ERROR);\n        replies \u003d new int[] {h, h1};\n      } else {\n        short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n            .getNumOfReplies();\n        replies \u003d new int[ackLen + 1];\n        replies[0] \u003d myHeader;\n        for (int i \u003d 0; i \u003c ackLen; ++i) {\n          replies[i + 1] \u003d ack.getReply(i);\n        }\n        // If the mirror has reported that it received a corrupt packet,\n        // do self-destruct to mark myself bad, instead of making the\n        // mirror node bad. The mirror is guaranteed to be good without\n        // corrupt data on disk.\n        if (ackLen \u003e 0 \u0026\u0026 PipelineAck.getStatusFromHeader(replies[1]) \u003d\u003d\n          Status.ERROR_CHECKSUM) {\n          throw new IOException(\"Shutting down writer and responder \"\n              + \"since the down streams reported the data sent by this \"\n              + \"thread is corrupt\");\n        }\n      }\n      PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n          totalAckTimeNanos);\n      if (replyAck.isSuccess()\n          \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n        replicaInfo.setBytesAcked(offsetInBlock);\n      }\n      // send my ack back to upstream datanode\n      long begin \u003d Time.monotonicNow();\n      replyAck.write(upstreamOut);\n      upstreamOut.flush();\n      long duration \u003d Time.monotonicNow() - begin;\n      if (duration \u003e datanodeSlowLogThresholdMs) {\n        LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n            + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n            + \", replyAck\u003d\" + replyAck);\n      } else if (LOG.isDebugEnabled()) {\n        LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n      }\n\n      // If a corruption was detected in the received data, terminate after\n      // sending ERROR_CHECKSUM back.\n      Status myStatus \u003d PipelineAck.getStatusFromHeader(myHeader);\n      if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n        throw new IOException(\"Shutting down writer and responder \"\n            + \"due to a checksum error in received data. The error \"\n            + \"response has been sent upstream.\");\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
          "extendedDetails": {
            "oldValue": "[ack-PipelineAck, seqno-long, totalAckTimeNanos-long, offsetInBlock-long, myStatus-Status]",
            "newValue": "[ack-PipelineAck, seqno-long, totalAckTimeNanos-long, offsetInBlock-long, myHeader-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7270. Add congestion signaling capability to DataNode write protocol. Contributed by Haohui Mai.\n",
          "commitDate": "05/02/15 10:58 AM",
          "commitName": "c4980a2f343778544ca20ebea1338651793ea0d9",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "22/01/15 10:37 AM",
          "commitNameOld": "5f124efb3e090f96f217bee22f3c8897f9772f14",
          "commitAuthorOld": "yliu",
          "daysBetweenCommits": 14.01,
          "commitsBetweenForRepo": 115,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,56 +1,59 @@\n     private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n-        long totalAckTimeNanos, long offsetInBlock, Status myStatus)\n+        long totalAckTimeNanos, long offsetInBlock, int myHeader)\n         throws IOException {\n-      Status[] replies \u003d null;\n+      final int[] replies;\n       if (ack \u003d\u003d null) {\n         // A new OOB response is being sent from this node. Regardless of\n         // downstream nodes, reply should contain one reply.\n-        replies \u003d new Status[1];\n-        replies[0] \u003d myStatus;\n+        replies \u003d new int[] { myHeader };\n       } else if (mirrorError) { // ack read error\n-        replies \u003d MIRROR_ERROR_STATUS;\n+        int h \u003d PipelineAck.combineHeader(datanode.getECN(), Status.SUCCESS);\n+        int h1 \u003d PipelineAck.combineHeader(datanode.getECN(), Status.ERROR);\n+        replies \u003d new int[] {h, h1};\n       } else {\n         short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n             .getNumOfReplies();\n-        replies \u003d new Status[1 + ackLen];\n-        replies[0] \u003d myStatus;\n-        for (int i \u003d 0; i \u003c ackLen; i++) {\n+        replies \u003d new int[ackLen + 1];\n+        replies[0] \u003d myHeader;\n+        for (int i \u003d 0; i \u003c ackLen; ++i) {\n           replies[i + 1] \u003d ack.getReply(i);\n         }\n         // If the mirror has reported that it received a corrupt packet,\n-        // do self-destruct to mark myself bad, instead of making the \n+        // do self-destruct to mark myself bad, instead of making the\n         // mirror node bad. The mirror is guaranteed to be good without\n         // corrupt data on disk.\n-        if (ackLen \u003e 0 \u0026\u0026 replies[1] \u003d\u003d Status.ERROR_CHECKSUM) {\n+        if (ackLen \u003e 0 \u0026\u0026 PipelineAck.getStatusFromHeader(replies[1]) \u003d\u003d\n+          Status.ERROR_CHECKSUM) {\n           throw new IOException(\"Shutting down writer and responder \"\n               + \"since the down streams reported the data sent by this \"\n               + \"thread is corrupt\");\n         }\n       }\n       PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n           totalAckTimeNanos);\n       if (replyAck.isSuccess()\n           \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n         replicaInfo.setBytesAcked(offsetInBlock);\n       }\n       // send my ack back to upstream datanode\n       long begin \u003d Time.monotonicNow();\n       replyAck.write(upstreamOut);\n       upstreamOut.flush();\n       long duration \u003d Time.monotonicNow() - begin;\n       if (duration \u003e datanodeSlowLogThresholdMs) {\n         LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n             + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n             + \", replyAck\u003d\" + replyAck);\n       } else if (LOG.isDebugEnabled()) {\n         LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n       }\n \n       // If a corruption was detected in the received data, terminate after\n-      // sending ERROR_CHECKSUM back. \n+      // sending ERROR_CHECKSUM back.\n+      Status myStatus \u003d PipelineAck.getStatusFromHeader(myHeader);\n       if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n         throw new IOException(\"Shutting down writer and responder \"\n             + \"due to a checksum error in received data. The error \"\n             + \"response has been sent upstream.\");\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n        long totalAckTimeNanos, long offsetInBlock, int myHeader)\n        throws IOException {\n      final int[] replies;\n      if (ack \u003d\u003d null) {\n        // A new OOB response is being sent from this node. Regardless of\n        // downstream nodes, reply should contain one reply.\n        replies \u003d new int[] { myHeader };\n      } else if (mirrorError) { // ack read error\n        int h \u003d PipelineAck.combineHeader(datanode.getECN(), Status.SUCCESS);\n        int h1 \u003d PipelineAck.combineHeader(datanode.getECN(), Status.ERROR);\n        replies \u003d new int[] {h, h1};\n      } else {\n        short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n            .getNumOfReplies();\n        replies \u003d new int[ackLen + 1];\n        replies[0] \u003d myHeader;\n        for (int i \u003d 0; i \u003c ackLen; ++i) {\n          replies[i + 1] \u003d ack.getReply(i);\n        }\n        // If the mirror has reported that it received a corrupt packet,\n        // do self-destruct to mark myself bad, instead of making the\n        // mirror node bad. The mirror is guaranteed to be good without\n        // corrupt data on disk.\n        if (ackLen \u003e 0 \u0026\u0026 PipelineAck.getStatusFromHeader(replies[1]) \u003d\u003d\n          Status.ERROR_CHECKSUM) {\n          throw new IOException(\"Shutting down writer and responder \"\n              + \"since the down streams reported the data sent by this \"\n              + \"thread is corrupt\");\n        }\n      }\n      PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n          totalAckTimeNanos);\n      if (replyAck.isSuccess()\n          \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n        replicaInfo.setBytesAcked(offsetInBlock);\n      }\n      // send my ack back to upstream datanode\n      long begin \u003d Time.monotonicNow();\n      replyAck.write(upstreamOut);\n      upstreamOut.flush();\n      long duration \u003d Time.monotonicNow() - begin;\n      if (duration \u003e datanodeSlowLogThresholdMs) {\n        LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n            + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n            + \", replyAck\u003d\" + replyAck);\n      } else if (LOG.isDebugEnabled()) {\n        LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n      }\n\n      // If a corruption was detected in the received data, terminate after\n      // sending ERROR_CHECKSUM back.\n      Status myStatus \u003d PipelineAck.getStatusFromHeader(myHeader);\n      if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n        throw new IOException(\"Shutting down writer and responder \"\n            + \"due to a checksum error in received data. The error \"\n            + \"response has been sent upstream.\");\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
          "extendedDetails": {}
        }
      ]
    },
    "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae": {
      "type": "Ybodychange",
      "commitMessage": "HBASE-6110 adding more slow action log in critical write path (Liang Xie via stack)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1597633 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/05/14 12:38 PM",
      "commitName": "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae",
      "commitAuthor": "Michael Stack",
      "commitDateOld": "12/05/14 12:08 PM",
      "commitNameOld": "e9459baec5a46651c156fbae5f8f3c9cc8325ef0",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 14.02,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,56 @@\n     private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n         long totalAckTimeNanos, long offsetInBlock, Status myStatus)\n         throws IOException {\n       Status[] replies \u003d null;\n       if (ack \u003d\u003d null) {\n         // A new OOB response is being sent from this node. Regardless of\n         // downstream nodes, reply should contain one reply.\n         replies \u003d new Status[1];\n         replies[0] \u003d myStatus;\n       } else if (mirrorError) { // ack read error\n         replies \u003d MIRROR_ERROR_STATUS;\n       } else {\n         short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n             .getNumOfReplies();\n         replies \u003d new Status[1 + ackLen];\n         replies[0] \u003d myStatus;\n         for (int i \u003d 0; i \u003c ackLen; i++) {\n           replies[i + 1] \u003d ack.getReply(i);\n         }\n         // If the mirror has reported that it received a corrupt packet,\n         // do self-destruct to mark myself bad, instead of making the \n         // mirror node bad. The mirror is guaranteed to be good without\n         // corrupt data on disk.\n         if (ackLen \u003e 0 \u0026\u0026 replies[1] \u003d\u003d Status.ERROR_CHECKSUM) {\n           throw new IOException(\"Shutting down writer and responder \"\n               + \"since the down streams reported the data sent by this \"\n               + \"thread is corrupt\");\n         }\n       }\n       PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n           totalAckTimeNanos);\n       if (replyAck.isSuccess()\n           \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n         replicaInfo.setBytesAcked(offsetInBlock);\n       }\n       // send my ack back to upstream datanode\n+      long begin \u003d Time.monotonicNow();\n       replyAck.write(upstreamOut);\n       upstreamOut.flush();\n-      if (LOG.isDebugEnabled()) {\n+      long duration \u003d Time.monotonicNow() - begin;\n+      if (duration \u003e datanodeSlowLogThresholdMs) {\n+        LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n+            + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n+            + \", replyAck\u003d\" + replyAck);\n+      } else if (LOG.isDebugEnabled()) {\n         LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n       }\n \n       // If a corruption was detected in the received data, terminate after\n       // sending ERROR_CHECKSUM back. \n       if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n         throw new IOException(\"Shutting down writer and responder \"\n             + \"due to a checksum error in received data. The error \"\n             + \"response has been sent upstream.\");\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n        long totalAckTimeNanos, long offsetInBlock, Status myStatus)\n        throws IOException {\n      Status[] replies \u003d null;\n      if (ack \u003d\u003d null) {\n        // A new OOB response is being sent from this node. Regardless of\n        // downstream nodes, reply should contain one reply.\n        replies \u003d new Status[1];\n        replies[0] \u003d myStatus;\n      } else if (mirrorError) { // ack read error\n        replies \u003d MIRROR_ERROR_STATUS;\n      } else {\n        short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n            .getNumOfReplies();\n        replies \u003d new Status[1 + ackLen];\n        replies[0] \u003d myStatus;\n        for (int i \u003d 0; i \u003c ackLen; i++) {\n          replies[i + 1] \u003d ack.getReply(i);\n        }\n        // If the mirror has reported that it received a corrupt packet,\n        // do self-destruct to mark myself bad, instead of making the \n        // mirror node bad. The mirror is guaranteed to be good without\n        // corrupt data on disk.\n        if (ackLen \u003e 0 \u0026\u0026 replies[1] \u003d\u003d Status.ERROR_CHECKSUM) {\n          throw new IOException(\"Shutting down writer and responder \"\n              + \"since the down streams reported the data sent by this \"\n              + \"thread is corrupt\");\n        }\n      }\n      PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n          totalAckTimeNanos);\n      if (replyAck.isSuccess()\n          \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n        replicaInfo.setBytesAcked(offsetInBlock);\n      }\n      // send my ack back to upstream datanode\n      long begin \u003d Time.monotonicNow();\n      replyAck.write(upstreamOut);\n      upstreamOut.flush();\n      long duration \u003d Time.monotonicNow() - begin;\n      if (duration \u003e datanodeSlowLogThresholdMs) {\n        LOG.warn(\"Slow PacketResponder send ack to upstream took \" + duration\n            + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \" + myString\n            + \", replyAck\u003d\" + replyAck);\n      } else if (LOG.isDebugEnabled()) {\n        LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n      }\n\n      // If a corruption was detected in the received data, terminate after\n      // sending ERROR_CHECKSUM back. \n      if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n        throw new IOException(\"Shutting down writer and responder \"\n            + \"due to a checksum error in received data. The error \"\n            + \"response has been sent upstream.\");\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "1c6b5d2b5841e5219a98937088cde4ae63869f80": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5583. Make DN send an OOB Ack on shutdown before restarting. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1571491 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/02/14 3:38 PM",
      "commitName": "1c6b5d2b5841e5219a98937088cde4ae63869f80",
      "commitAuthor": "Kihwal Lee",
      "diff": "@@ -0,0 +1,51 @@\n+    private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n+        long totalAckTimeNanos, long offsetInBlock, Status myStatus)\n+        throws IOException {\n+      Status[] replies \u003d null;\n+      if (ack \u003d\u003d null) {\n+        // A new OOB response is being sent from this node. Regardless of\n+        // downstream nodes, reply should contain one reply.\n+        replies \u003d new Status[1];\n+        replies[0] \u003d myStatus;\n+      } else if (mirrorError) { // ack read error\n+        replies \u003d MIRROR_ERROR_STATUS;\n+      } else {\n+        short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n+            .getNumOfReplies();\n+        replies \u003d new Status[1 + ackLen];\n+        replies[0] \u003d myStatus;\n+        for (int i \u003d 0; i \u003c ackLen; i++) {\n+          replies[i + 1] \u003d ack.getReply(i);\n+        }\n+        // If the mirror has reported that it received a corrupt packet,\n+        // do self-destruct to mark myself bad, instead of making the \n+        // mirror node bad. The mirror is guaranteed to be good without\n+        // corrupt data on disk.\n+        if (ackLen \u003e 0 \u0026\u0026 replies[1] \u003d\u003d Status.ERROR_CHECKSUM) {\n+          throw new IOException(\"Shutting down writer and responder \"\n+              + \"since the down streams reported the data sent by this \"\n+              + \"thread is corrupt\");\n+        }\n+      }\n+      PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n+          totalAckTimeNanos);\n+      if (replyAck.isSuccess()\n+          \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n+        replicaInfo.setBytesAcked(offsetInBlock);\n+      }\n+\n+      // send my ack back to upstream datanode\n+      replyAck.write(upstreamOut);\n+      upstreamOut.flush();\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n+      }\n+\n+      // If a corruption was detected in the received data, terminate after\n+      // sending ERROR_CHECKSUM back. \n+      if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n+        throw new IOException(\"Shutting down writer and responder \"\n+            + \"due to a checksum error in received data. The error \"\n+            + \"response has been sent upstream.\");\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void sendAckUpstreamUnprotected(PipelineAck ack, long seqno,\n        long totalAckTimeNanos, long offsetInBlock, Status myStatus)\n        throws IOException {\n      Status[] replies \u003d null;\n      if (ack \u003d\u003d null) {\n        // A new OOB response is being sent from this node. Regardless of\n        // downstream nodes, reply should contain one reply.\n        replies \u003d new Status[1];\n        replies[0] \u003d myStatus;\n      } else if (mirrorError) { // ack read error\n        replies \u003d MIRROR_ERROR_STATUS;\n      } else {\n        short ackLen \u003d type \u003d\u003d PacketResponderType.LAST_IN_PIPELINE ? 0 : ack\n            .getNumOfReplies();\n        replies \u003d new Status[1 + ackLen];\n        replies[0] \u003d myStatus;\n        for (int i \u003d 0; i \u003c ackLen; i++) {\n          replies[i + 1] \u003d ack.getReply(i);\n        }\n        // If the mirror has reported that it received a corrupt packet,\n        // do self-destruct to mark myself bad, instead of making the \n        // mirror node bad. The mirror is guaranteed to be good without\n        // corrupt data on disk.\n        if (ackLen \u003e 0 \u0026\u0026 replies[1] \u003d\u003d Status.ERROR_CHECKSUM) {\n          throw new IOException(\"Shutting down writer and responder \"\n              + \"since the down streams reported the data sent by this \"\n              + \"thread is corrupt\");\n        }\n      }\n      PipelineAck replyAck \u003d new PipelineAck(seqno, replies,\n          totalAckTimeNanos);\n      if (replyAck.isSuccess()\n          \u0026\u0026 offsetInBlock \u003e replicaInfo.getBytesAcked()) {\n        replicaInfo.setBytesAcked(offsetInBlock);\n      }\n\n      // send my ack back to upstream datanode\n      replyAck.write(upstreamOut);\n      upstreamOut.flush();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(myString + \", replyAck\u003d\" + replyAck);\n      }\n\n      // If a corruption was detected in the received data, terminate after\n      // sending ERROR_CHECKSUM back. \n      if (myStatus \u003d\u003d Status.ERROR_CHECKSUM) {\n        throw new IOException(\"Shutting down writer and responder \"\n            + \"due to a checksum error in received data. The error \"\n            + \"response has been sent upstream.\");\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java"
    }
  }
}