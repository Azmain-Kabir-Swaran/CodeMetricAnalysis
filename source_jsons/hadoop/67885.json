{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SimpleCopyListing.java",
  "functionName": "traverseDirectory",
  "functionId": "traverseDirectory___fileListWriter-SequenceFile.Writer__sourceFS-FileSystem__sourceDirs-ArrayList__FileStatus____sourcePathRoot-Path__context-DistCpContext__excludeList-HashSet__String____fileStatuses-List__FileStatusInfo__",
  "sourceFilePath": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
  "functionStartLine": 618,
  "functionEndLine": 689,
  "numCommitsSeen": 101,
  "timeTaken": 7922,
  "changeHistory": [
    "26172a94d6431e70d7fe15d66be9a7e195f79f60",
    "bf3fb585aaf2b179836e139c041fc87920a3c886",
    "144f1cf76527e6c75aec77ef683a898580f3cc8d",
    "064c8b25eca9bc825dc07a54d9147d65c9290a03",
    "98bdb5139769eb55893971b43b9c23da9513a784",
    "0bc15cb6e60dc60885234e01dec1c7cb4557a926",
    "0790275f058b0cf41780ad337c9150a1e8ebebc6",
    "a287d2fb77d9873b61c6ab24134993d784ae8475",
    "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7",
    "932730df7d62077f7356464ad27f69469965d77a",
    "041b8326a1511b721958792a6b94ecfe27d7a1fb",
    "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9",
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
    "6f92ad9868b008eb523ae3279e05004de31a08ce",
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67"
  ],
  "changeHistoryShort": {
    "26172a94d6431e70d7fe15d66be9a7e195f79f60": "Ymultichange(Yparameterchange,Ybodychange)",
    "bf3fb585aaf2b179836e139c041fc87920a3c886": "Ybodychange",
    "144f1cf76527e6c75aec77ef683a898580f3cc8d": "Ybodychange",
    "064c8b25eca9bc825dc07a54d9147d65c9290a03": "Ybodychange",
    "98bdb5139769eb55893971b43b9c23da9513a784": "Ymultichange(Yparameterchange,Ybodychange)",
    "0bc15cb6e60dc60885234e01dec1c7cb4557a926": "Ymultichange(Yparameterchange,Ybodychange)",
    "0790275f058b0cf41780ad337c9150a1e8ebebc6": "Ybodychange",
    "a287d2fb77d9873b61c6ab24134993d784ae8475": "Ybodychange",
    "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7": "Ymultichange(Yparameterchange,Ybodychange)",
    "932730df7d62077f7356464ad27f69469965d77a": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "041b8326a1511b721958792a6b94ecfe27d7a1fb": "Ybodychange",
    "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9": "Ybodychange",
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05": "Ymultichange(Yparameterchange,Ybodychange)",
    "6f92ad9868b008eb523ae3279e05004de31a08ce": "Ymultichange(Yparameterchange,Ybodychange)",
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67": "Yintroduced"
  },
  "changeHistoryDetails": {
    "26172a94d6431e70d7fe15d66be9a7e195f79f60": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-14267. Make DistCpOptions immutable. Contributed by Mingliang Liu\n",
      "commitDate": "31/03/17 8:04 PM",
      "commitName": "26172a94d6431e70d7fe15d66be9a7e195f79f60",
      "commitAuthor": "Mingliang Liu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-14267. Make DistCpOptions immutable. Contributed by Mingliang Liu\n",
          "commitDate": "31/03/17 8:04 PM",
          "commitName": "26172a94d6431e70d7fe15d66be9a7e195f79f60",
          "commitAuthor": "Mingliang Liu",
          "commitDateOld": "30/03/17 5:38 PM",
          "commitNameOld": "bf3fb585aaf2b179836e139c041fc87920a3c886",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 1.1,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,72 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n                                  ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n-                                 DistCpOptions options,\n+                                 DistCpContext context,\n                                  HashSet\u003cString\u003e excludeList,\n                                  List\u003cFileStatusInfo\u003e fileStatuses)\n                                  throws IOException {\n-    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n-    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n-    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n+    final boolean preserveAcls \u003d context.shouldPreserve(FileAttribute.ACL);\n+    final boolean preserveXAttrs \u003d context.shouldPreserve(FileAttribute.XATTR);\n+    final boolean preserveRawXattrs \u003d context.shouldPreserveRawXattrs();\n \n     assert numListstatusThreads \u003e 0;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n           \" listStatus workers.\");\n     }\n     ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n         new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n     for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n       workers.addWorker(\n           new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n               excludeList));\n     }\n \n     for (FileStatus status : sourceDirs) {\n       workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n     }\n \n     while (workers.hasWork()) {\n       try {\n         WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n         int retry \u003d workResult.getRetry();\n         for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n           if (workResult.getSuccess()) {\n             LinkedList\u003cCopyListingFileStatus\u003e childCopyListingStatus \u003d\n               DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                 preserveAcls \u0026\u0026 child.isDirectory(),\n                 preserveXAttrs \u0026\u0026 child.isDirectory(),\n                 preserveRawXattrs \u0026\u0026 child.isDirectory(),\n-                options.getBlocksPerChunk());\n+                context.getBlocksPerChunk());\n \n             for (CopyListingFileStatus fs : childCopyListingStatus) {\n               if (randomizeFileListing) {\n                 addToFileListing(fileStatuses,\n                     new FileStatusInfo(fs, sourcePathRoot), fileListWriter);\n               } else {\n                 writeToFileListing(fileListWriter, fs, sourcePathRoot);\n               }\n             }\n           }\n           if (retry \u003c maxRetries) {\n             if (child.isDirectory()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Traversing into source dir: \" + child.getPath());\n               }\n               workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n             }\n           } else {\n             LOG.error(\"Giving up on \" + child.getPath() +\n                       \" after \" + retry + \" retries.\");\n           }\n         }\n       } catch (InterruptedException ie) {\n         LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n     workers.shutdown();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpContext context,\n                                 HashSet\u003cString\u003e excludeList,\n                                 List\u003cFileStatusInfo\u003e fileStatuses)\n                                 throws IOException {\n    final boolean preserveAcls \u003d context.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d context.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d context.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n          \" listStatus workers.\");\n    }\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n              excludeList));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (workResult.getSuccess()) {\n            LinkedList\u003cCopyListingFileStatus\u003e childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory(),\n                context.getBlocksPerChunk());\n\n            for (CopyListingFileStatus fs : childCopyListingStatus) {\n              if (randomizeFileListing) {\n                addToFileListing(fileStatuses,\n                    new FileStatusInfo(fs, sourcePathRoot), fileListWriter);\n              } else {\n                writeToFileListing(fileListWriter, fs, sourcePathRoot);\n              }\n            }\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {
            "oldValue": "[fileListWriter-SequenceFile.Writer, sourceFS-FileSystem, sourceDirs-ArrayList\u003cFileStatus\u003e, sourcePathRoot-Path, options-DistCpOptions, excludeList-HashSet\u003cString\u003e, fileStatuses-List\u003cFileStatusInfo\u003e]",
            "newValue": "[fileListWriter-SequenceFile.Writer, sourceFS-FileSystem, sourceDirs-ArrayList\u003cFileStatus\u003e, sourcePathRoot-Path, context-DistCpContext, excludeList-HashSet\u003cString\u003e, fileStatuses-List\u003cFileStatusInfo\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14267. Make DistCpOptions immutable. Contributed by Mingliang Liu\n",
          "commitDate": "31/03/17 8:04 PM",
          "commitName": "26172a94d6431e70d7fe15d66be9a7e195f79f60",
          "commitAuthor": "Mingliang Liu",
          "commitDateOld": "30/03/17 5:38 PM",
          "commitNameOld": "bf3fb585aaf2b179836e139c041fc87920a3c886",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 1.1,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,72 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n                                  ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n-                                 DistCpOptions options,\n+                                 DistCpContext context,\n                                  HashSet\u003cString\u003e excludeList,\n                                  List\u003cFileStatusInfo\u003e fileStatuses)\n                                  throws IOException {\n-    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n-    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n-    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n+    final boolean preserveAcls \u003d context.shouldPreserve(FileAttribute.ACL);\n+    final boolean preserveXAttrs \u003d context.shouldPreserve(FileAttribute.XATTR);\n+    final boolean preserveRawXattrs \u003d context.shouldPreserveRawXattrs();\n \n     assert numListstatusThreads \u003e 0;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n           \" listStatus workers.\");\n     }\n     ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n         new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n     for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n       workers.addWorker(\n           new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n               excludeList));\n     }\n \n     for (FileStatus status : sourceDirs) {\n       workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n     }\n \n     while (workers.hasWork()) {\n       try {\n         WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n         int retry \u003d workResult.getRetry();\n         for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n           if (workResult.getSuccess()) {\n             LinkedList\u003cCopyListingFileStatus\u003e childCopyListingStatus \u003d\n               DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                 preserveAcls \u0026\u0026 child.isDirectory(),\n                 preserveXAttrs \u0026\u0026 child.isDirectory(),\n                 preserveRawXattrs \u0026\u0026 child.isDirectory(),\n-                options.getBlocksPerChunk());\n+                context.getBlocksPerChunk());\n \n             for (CopyListingFileStatus fs : childCopyListingStatus) {\n               if (randomizeFileListing) {\n                 addToFileListing(fileStatuses,\n                     new FileStatusInfo(fs, sourcePathRoot), fileListWriter);\n               } else {\n                 writeToFileListing(fileListWriter, fs, sourcePathRoot);\n               }\n             }\n           }\n           if (retry \u003c maxRetries) {\n             if (child.isDirectory()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Traversing into source dir: \" + child.getPath());\n               }\n               workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n             }\n           } else {\n             LOG.error(\"Giving up on \" + child.getPath() +\n                       \" after \" + retry + \" retries.\");\n           }\n         }\n       } catch (InterruptedException ie) {\n         LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n     workers.shutdown();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpContext context,\n                                 HashSet\u003cString\u003e excludeList,\n                                 List\u003cFileStatusInfo\u003e fileStatuses)\n                                 throws IOException {\n    final boolean preserveAcls \u003d context.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d context.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d context.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n          \" listStatus workers.\");\n    }\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n              excludeList));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (workResult.getSuccess()) {\n            LinkedList\u003cCopyListingFileStatus\u003e childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory(),\n                context.getBlocksPerChunk());\n\n            for (CopyListingFileStatus fs : childCopyListingStatus) {\n              if (randomizeFileListing) {\n                addToFileListing(fileStatuses,\n                    new FileStatusInfo(fs, sourcePathRoot), fileListWriter);\n              } else {\n                writeToFileListing(fileListWriter, fs, sourcePathRoot);\n              }\n            }\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {}
        }
      ]
    },
    "bf3fb585aaf2b179836e139c041fc87920a3c886": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen, Rosie Li.\n",
      "commitDate": "30/03/17 5:38 PM",
      "commitName": "bf3fb585aaf2b179836e139c041fc87920a3c886",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "30/03/17 5:38 PM",
      "commitNameOld": "144f1cf76527e6c75aec77ef683a898580f3cc8d",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,72 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n                                  ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n                                  DistCpOptions options,\n                                  HashSet\u003cString\u003e excludeList,\n                                  List\u003cFileStatusInfo\u003e fileStatuses)\n                                  throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n \n     assert numListstatusThreads \u003e 0;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n           \" listStatus workers.\");\n     }\n     ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n         new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n     for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n       workers.addWorker(\n           new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n               excludeList));\n     }\n \n     for (FileStatus status : sourceDirs) {\n       workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n     }\n \n     while (workers.hasWork()) {\n       try {\n         WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n         int retry \u003d workResult.getRetry();\n         for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n           if (workResult.getSuccess()) {\n-            CopyListingFileStatus childCopyListingStatus \u003d\n+            LinkedList\u003cCopyListingFileStatus\u003e childCopyListingStatus \u003d\n               DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                 preserveAcls \u0026\u0026 child.isDirectory(),\n                 preserveXAttrs \u0026\u0026 child.isDirectory(),\n-                preserveRawXattrs \u0026\u0026 child.isDirectory());\n-            if (randomizeFileListing) {\n-              addToFileListing(fileStatuses,\n-                  new FileStatusInfo(childCopyListingStatus, sourcePathRoot),\n-                  fileListWriter);\n-            } else {\n-              writeToFileListing(fileListWriter, childCopyListingStatus,\n-                  sourcePathRoot);\n+                preserveRawXattrs \u0026\u0026 child.isDirectory(),\n+                options.getBlocksPerChunk());\n+\n+            for (CopyListingFileStatus fs : childCopyListingStatus) {\n+              if (randomizeFileListing) {\n+                addToFileListing(fileStatuses,\n+                    new FileStatusInfo(fs, sourcePathRoot), fileListWriter);\n+              } else {\n+                writeToFileListing(fileListWriter, fs, sourcePathRoot);\n+              }\n             }\n           }\n           if (retry \u003c maxRetries) {\n             if (child.isDirectory()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Traversing into source dir: \" + child.getPath());\n               }\n               workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n             }\n           } else {\n             LOG.error(\"Giving up on \" + child.getPath() +\n                       \" after \" + retry + \" retries.\");\n           }\n         }\n       } catch (InterruptedException ie) {\n         LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n     workers.shutdown();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options,\n                                 HashSet\u003cString\u003e excludeList,\n                                 List\u003cFileStatusInfo\u003e fileStatuses)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n          \" listStatus workers.\");\n    }\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n              excludeList));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (workResult.getSuccess()) {\n            LinkedList\u003cCopyListingFileStatus\u003e childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory(),\n                options.getBlocksPerChunk());\n\n            for (CopyListingFileStatus fs : childCopyListingStatus) {\n              if (randomizeFileListing) {\n                addToFileListing(fileStatuses,\n                    new FileStatusInfo(fs, sourcePathRoot), fileListWriter);\n              } else {\n                writeToFileListing(fileListWriter, fs, sourcePathRoot);\n              }\n            }\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
      "extendedDetails": {}
    },
    "144f1cf76527e6c75aec77ef683a898580f3cc8d": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen.\"\n\nThis reverts commit 064c8b25eca9bc825dc07a54d9147d65c9290a03.\n",
      "commitDate": "30/03/17 5:38 PM",
      "commitName": "144f1cf76527e6c75aec77ef683a898580f3cc8d",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "30/03/17 5:01 PM",
      "commitNameOld": "064c8b25eca9bc825dc07a54d9147d65c9290a03",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,70 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n                                  ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n                                  DistCpOptions options,\n                                  HashSet\u003cString\u003e excludeList,\n                                  List\u003cFileStatusInfo\u003e fileStatuses)\n                                  throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n \n     assert numListstatusThreads \u003e 0;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n           \" listStatus workers.\");\n     }\n     ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n         new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n     for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n       workers.addWorker(\n           new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n               excludeList));\n     }\n \n     for (FileStatus status : sourceDirs) {\n       workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n     }\n \n     while (workers.hasWork()) {\n       try {\n         WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n         int retry \u003d workResult.getRetry();\n         for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n           if (workResult.getSuccess()) {\n-            LinkedList\u003cCopyListingFileStatus\u003e childCopyListingStatus \u003d\n+            CopyListingFileStatus childCopyListingStatus \u003d\n               DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                 preserveAcls \u0026\u0026 child.isDirectory(),\n                 preserveXAttrs \u0026\u0026 child.isDirectory(),\n-                preserveRawXattrs \u0026\u0026 child.isDirectory(),\n-                options.getBlocksPerChunk());\n-\n-            for (CopyListingFileStatus fs : childCopyListingStatus) {\n-              if (randomizeFileListing) {\n-                addToFileListing(fileStatuses,\n-                    new FileStatusInfo(fs, sourcePathRoot), fileListWriter);\n-              } else {\n-                writeToFileListing(fileListWriter, fs, sourcePathRoot);\n-              }\n+                preserveRawXattrs \u0026\u0026 child.isDirectory());\n+            if (randomizeFileListing) {\n+              addToFileListing(fileStatuses,\n+                  new FileStatusInfo(childCopyListingStatus, sourcePathRoot),\n+                  fileListWriter);\n+            } else {\n+              writeToFileListing(fileListWriter, childCopyListingStatus,\n+                  sourcePathRoot);\n             }\n           }\n           if (retry \u003c maxRetries) {\n             if (child.isDirectory()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Traversing into source dir: \" + child.getPath());\n               }\n               workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n             }\n           } else {\n             LOG.error(\"Giving up on \" + child.getPath() +\n                       \" after \" + retry + \" retries.\");\n           }\n         }\n       } catch (InterruptedException ie) {\n         LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n     workers.shutdown();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options,\n                                 HashSet\u003cString\u003e excludeList,\n                                 List\u003cFileStatusInfo\u003e fileStatuses)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n          \" listStatus workers.\");\n    }\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n              excludeList));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (workResult.getSuccess()) {\n            CopyListingFileStatus childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory());\n            if (randomizeFileListing) {\n              addToFileListing(fileStatuses,\n                  new FileStatusInfo(childCopyListingStatus, sourcePathRoot),\n                  fileListWriter);\n            } else {\n              writeToFileListing(fileListWriter, childCopyListingStatus,\n                  sourcePathRoot);\n            }\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
      "extendedDetails": {}
    },
    "064c8b25eca9bc825dc07a54d9147d65c9290a03": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen.\n",
      "commitDate": "30/03/17 5:01 PM",
      "commitName": "064c8b25eca9bc825dc07a54d9147d65c9290a03",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "15/11/16 10:57 AM",
      "commitNameOld": "5af572b6443715b7a741296c1bd520a1840f9a7c",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 135.21,
      "commitsBetweenForRepo": 732,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,72 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n                                  ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n                                  DistCpOptions options,\n                                  HashSet\u003cString\u003e excludeList,\n                                  List\u003cFileStatusInfo\u003e fileStatuses)\n                                  throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n \n     assert numListstatusThreads \u003e 0;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n           \" listStatus workers.\");\n     }\n     ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n         new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n     for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n       workers.addWorker(\n           new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n               excludeList));\n     }\n \n     for (FileStatus status : sourceDirs) {\n       workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n     }\n \n     while (workers.hasWork()) {\n       try {\n         WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n         int retry \u003d workResult.getRetry();\n         for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n           if (workResult.getSuccess()) {\n-            CopyListingFileStatus childCopyListingStatus \u003d\n+            LinkedList\u003cCopyListingFileStatus\u003e childCopyListingStatus \u003d\n               DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                 preserveAcls \u0026\u0026 child.isDirectory(),\n                 preserveXAttrs \u0026\u0026 child.isDirectory(),\n-                preserveRawXattrs \u0026\u0026 child.isDirectory());\n-            if (randomizeFileListing) {\n-              addToFileListing(fileStatuses,\n-                  new FileStatusInfo(childCopyListingStatus, sourcePathRoot),\n-                  fileListWriter);\n-            } else {\n-              writeToFileListing(fileListWriter, childCopyListingStatus,\n-                  sourcePathRoot);\n+                preserveRawXattrs \u0026\u0026 child.isDirectory(),\n+                options.getBlocksPerChunk());\n+\n+            for (CopyListingFileStatus fs : childCopyListingStatus) {\n+              if (randomizeFileListing) {\n+                addToFileListing(fileStatuses,\n+                    new FileStatusInfo(fs, sourcePathRoot), fileListWriter);\n+              } else {\n+                writeToFileListing(fileListWriter, fs, sourcePathRoot);\n+              }\n             }\n           }\n           if (retry \u003c maxRetries) {\n             if (child.isDirectory()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Traversing into source dir: \" + child.getPath());\n               }\n               workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n             }\n           } else {\n             LOG.error(\"Giving up on \" + child.getPath() +\n                       \" after \" + retry + \" retries.\");\n           }\n         }\n       } catch (InterruptedException ie) {\n         LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n     workers.shutdown();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options,\n                                 HashSet\u003cString\u003e excludeList,\n                                 List\u003cFileStatusInfo\u003e fileStatuses)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n          \" listStatus workers.\");\n    }\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n              excludeList));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (workResult.getSuccess()) {\n            LinkedList\u003cCopyListingFileStatus\u003e childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory(),\n                options.getBlocksPerChunk());\n\n            for (CopyListingFileStatus fs : childCopyListingStatus) {\n              if (randomizeFileListing) {\n                addToFileListing(fileStatuses,\n                    new FileStatusInfo(fs, sourcePathRoot), fileListWriter);\n              } else {\n                writeToFileListing(fileListWriter, fs, sourcePathRoot);\n              }\n            }\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
      "extendedDetails": {}
    },
    "98bdb5139769eb55893971b43b9c23da9513a784": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-13169. Randomize file list in SimpleCopyListing. Contributed by Rajesh Balamohan.\n",
      "commitDate": "19/09/16 3:16 PM",
      "commitName": "98bdb5139769eb55893971b43b9c23da9513a784",
      "commitAuthor": "Chris Nauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13169. Randomize file list in SimpleCopyListing. Contributed by Rajesh Balamohan.\n",
          "commitDate": "19/09/16 3:16 PM",
          "commitName": "98bdb5139769eb55893971b43b9c23da9513a784",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "21/04/16 12:17 PM",
          "commitNameOld": "a749ba0ceaa843aa83146b6bea19e031c8dc3296",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 151.12,
          "commitsBetweenForRepo": 1103,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,70 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n                                  ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n                                  DistCpOptions options,\n-                                 HashSet\u003cString\u003e excludeList)\n+                                 HashSet\u003cString\u003e excludeList,\n+                                 List\u003cFileStatusInfo\u003e fileStatuses)\n                                  throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n \n     assert numListstatusThreads \u003e 0;\n-    LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n-              \" listStatus workers.\");\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n+          \" listStatus workers.\");\n+    }\n     ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n         new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n     for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n       workers.addWorker(\n           new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n               excludeList));\n     }\n \n     for (FileStatus status : sourceDirs) {\n       workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n     }\n \n     while (workers.hasWork()) {\n       try {\n         WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n         int retry \u003d workResult.getRetry();\n         for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n           if (workResult.getSuccess()) {\n             CopyListingFileStatus childCopyListingStatus \u003d\n               DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                 preserveAcls \u0026\u0026 child.isDirectory(),\n                 preserveXAttrs \u0026\u0026 child.isDirectory(),\n                 preserveRawXattrs \u0026\u0026 child.isDirectory());\n-            writeToFileListing(fileListWriter, childCopyListingStatus,\n-                 sourcePathRoot);\n+            if (randomizeFileListing) {\n+              addToFileListing(fileStatuses,\n+                  new FileStatusInfo(childCopyListingStatus, sourcePathRoot),\n+                  fileListWriter);\n+            } else {\n+              writeToFileListing(fileListWriter, childCopyListingStatus,\n+                  sourcePathRoot);\n+            }\n           }\n           if (retry \u003c maxRetries) {\n             if (child.isDirectory()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Traversing into source dir: \" + child.getPath());\n               }\n               workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n             }\n           } else {\n             LOG.error(\"Giving up on \" + child.getPath() +\n                       \" after \" + retry + \" retries.\");\n           }\n         }\n       } catch (InterruptedException ie) {\n         LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n     workers.shutdown();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options,\n                                 HashSet\u003cString\u003e excludeList,\n                                 List\u003cFileStatusInfo\u003e fileStatuses)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n          \" listStatus workers.\");\n    }\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n              excludeList));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (workResult.getSuccess()) {\n            CopyListingFileStatus childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory());\n            if (randomizeFileListing) {\n              addToFileListing(fileStatuses,\n                  new FileStatusInfo(childCopyListingStatus, sourcePathRoot),\n                  fileListWriter);\n            } else {\n              writeToFileListing(fileListWriter, childCopyListingStatus,\n                  sourcePathRoot);\n            }\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {
            "oldValue": "[fileListWriter-SequenceFile.Writer, sourceFS-FileSystem, sourceDirs-ArrayList\u003cFileStatus\u003e, sourcePathRoot-Path, options-DistCpOptions, excludeList-HashSet\u003cString\u003e]",
            "newValue": "[fileListWriter-SequenceFile.Writer, sourceFS-FileSystem, sourceDirs-ArrayList\u003cFileStatus\u003e, sourcePathRoot-Path, options-DistCpOptions, excludeList-HashSet\u003cString\u003e, fileStatuses-List\u003cFileStatusInfo\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13169. Randomize file list in SimpleCopyListing. Contributed by Rajesh Balamohan.\n",
          "commitDate": "19/09/16 3:16 PM",
          "commitName": "98bdb5139769eb55893971b43b9c23da9513a784",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "21/04/16 12:17 PM",
          "commitNameOld": "a749ba0ceaa843aa83146b6bea19e031c8dc3296",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 151.12,
          "commitsBetweenForRepo": 1103,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,70 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n                                  ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n                                  DistCpOptions options,\n-                                 HashSet\u003cString\u003e excludeList)\n+                                 HashSet\u003cString\u003e excludeList,\n+                                 List\u003cFileStatusInfo\u003e fileStatuses)\n                                  throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n \n     assert numListstatusThreads \u003e 0;\n-    LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n-              \" listStatus workers.\");\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n+          \" listStatus workers.\");\n+    }\n     ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n         new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n     for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n       workers.addWorker(\n           new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n               excludeList));\n     }\n \n     for (FileStatus status : sourceDirs) {\n       workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n     }\n \n     while (workers.hasWork()) {\n       try {\n         WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n         int retry \u003d workResult.getRetry();\n         for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n           if (workResult.getSuccess()) {\n             CopyListingFileStatus childCopyListingStatus \u003d\n               DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                 preserveAcls \u0026\u0026 child.isDirectory(),\n                 preserveXAttrs \u0026\u0026 child.isDirectory(),\n                 preserveRawXattrs \u0026\u0026 child.isDirectory());\n-            writeToFileListing(fileListWriter, childCopyListingStatus,\n-                 sourcePathRoot);\n+            if (randomizeFileListing) {\n+              addToFileListing(fileStatuses,\n+                  new FileStatusInfo(childCopyListingStatus, sourcePathRoot),\n+                  fileListWriter);\n+            } else {\n+              writeToFileListing(fileListWriter, childCopyListingStatus,\n+                  sourcePathRoot);\n+            }\n           }\n           if (retry \u003c maxRetries) {\n             if (child.isDirectory()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Traversing into source dir: \" + child.getPath());\n               }\n               workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n             }\n           } else {\n             LOG.error(\"Giving up on \" + child.getPath() +\n                       \" after \" + retry + \" retries.\");\n           }\n         }\n       } catch (InterruptedException ie) {\n         LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n     workers.shutdown();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options,\n                                 HashSet\u003cString\u003e excludeList,\n                                 List\u003cFileStatusInfo\u003e fileStatuses)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n          \" listStatus workers.\");\n    }\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n              excludeList));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (workResult.getSuccess()) {\n            CopyListingFileStatus childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory());\n            if (randomizeFileListing) {\n              addToFileListing(fileStatuses,\n                  new FileStatusInfo(childCopyListingStatus, sourcePathRoot),\n                  fileListWriter);\n            } else {\n              writeToFileListing(fileListWriter, childCopyListingStatus,\n                  sourcePathRoot);\n            }\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {}
        }
      ]
    },
    "0bc15cb6e60dc60885234e01dec1c7cb4557a926": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-8828. Utilize Snapshot diff report to build diff copy list in distcp. (Yufei Gu via Yongjun Zhang)\n",
      "commitDate": "20/08/15 8:02 AM",
      "commitName": "0bc15cb6e60dc60885234e01dec1c7cb4557a926",
      "commitAuthor": "Yongjun Zhang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8828. Utilize Snapshot diff report to build diff copy list in distcp. (Yufei Gu via Yongjun Zhang)\n",
          "commitDate": "20/08/15 8:02 AM",
          "commitName": "0bc15cb6e60dc60885234e01dec1c7cb4557a926",
          "commitAuthor": "Yongjun Zhang",
          "commitDateOld": "18/05/15 1:24 PM",
          "commitNameOld": "0790275f058b0cf41780ad337c9150a1e8ebebc6",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 93.78,
          "commitsBetweenForRepo": 595,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,61 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n                                  ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n-                                 DistCpOptions options)\n+                                 DistCpOptions options,\n+                                 HashSet\u003cString\u003e excludeList)\n                                  throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n \n     assert numListstatusThreads \u003e 0;\n     LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n               \" listStatus workers.\");\n     ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n         new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n     for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n       workers.addWorker(\n-          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf())));\n+          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n+              excludeList));\n     }\n \n     for (FileStatus status : sourceDirs) {\n       workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n     }\n \n     while (workers.hasWork()) {\n       try {\n         WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n         int retry \u003d workResult.getRetry();\n         for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n           if (workResult.getSuccess()) {\n             CopyListingFileStatus childCopyListingStatus \u003d\n               DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                 preserveAcls \u0026\u0026 child.isDirectory(),\n                 preserveXAttrs \u0026\u0026 child.isDirectory(),\n                 preserveRawXattrs \u0026\u0026 child.isDirectory());\n             writeToFileListing(fileListWriter, childCopyListingStatus,\n                  sourcePathRoot);\n           }\n           if (retry \u003c maxRetries) {\n             if (child.isDirectory()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Traversing into source dir: \" + child.getPath());\n               }\n               workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n             }\n           } else {\n             LOG.error(\"Giving up on \" + child.getPath() +\n                       \" after \" + retry + \" retries.\");\n           }\n         }\n       } catch (InterruptedException ie) {\n         LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n     workers.shutdown();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options,\n                                 HashSet\u003cString\u003e excludeList)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n              \" listStatus workers.\");\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n              excludeList));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (workResult.getSuccess()) {\n            CopyListingFileStatus childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory());\n            writeToFileListing(fileListWriter, childCopyListingStatus,\n                 sourcePathRoot);\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {
            "oldValue": "[fileListWriter-SequenceFile.Writer, sourceFS-FileSystem, sourceDirs-ArrayList\u003cFileStatus\u003e, sourcePathRoot-Path, options-DistCpOptions]",
            "newValue": "[fileListWriter-SequenceFile.Writer, sourceFS-FileSystem, sourceDirs-ArrayList\u003cFileStatus\u003e, sourcePathRoot-Path, options-DistCpOptions, excludeList-HashSet\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8828. Utilize Snapshot diff report to build diff copy list in distcp. (Yufei Gu via Yongjun Zhang)\n",
          "commitDate": "20/08/15 8:02 AM",
          "commitName": "0bc15cb6e60dc60885234e01dec1c7cb4557a926",
          "commitAuthor": "Yongjun Zhang",
          "commitDateOld": "18/05/15 1:24 PM",
          "commitNameOld": "0790275f058b0cf41780ad337c9150a1e8ebebc6",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 93.78,
          "commitsBetweenForRepo": 595,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,61 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n                                  ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n-                                 DistCpOptions options)\n+                                 DistCpOptions options,\n+                                 HashSet\u003cString\u003e excludeList)\n                                  throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n \n     assert numListstatusThreads \u003e 0;\n     LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n               \" listStatus workers.\");\n     ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n         new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n     for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n       workers.addWorker(\n-          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf())));\n+          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n+              excludeList));\n     }\n \n     for (FileStatus status : sourceDirs) {\n       workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n     }\n \n     while (workers.hasWork()) {\n       try {\n         WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n         int retry \u003d workResult.getRetry();\n         for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n           if (workResult.getSuccess()) {\n             CopyListingFileStatus childCopyListingStatus \u003d\n               DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                 preserveAcls \u0026\u0026 child.isDirectory(),\n                 preserveXAttrs \u0026\u0026 child.isDirectory(),\n                 preserveRawXattrs \u0026\u0026 child.isDirectory());\n             writeToFileListing(fileListWriter, childCopyListingStatus,\n                  sourcePathRoot);\n           }\n           if (retry \u003c maxRetries) {\n             if (child.isDirectory()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Traversing into source dir: \" + child.getPath());\n               }\n               workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n             }\n           } else {\n             LOG.error(\"Giving up on \" + child.getPath() +\n                       \" after \" + retry + \" retries.\");\n           }\n         }\n       } catch (InterruptedException ie) {\n         LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n     workers.shutdown();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options,\n                                 HashSet\u003cString\u003e excludeList)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n              \" listStatus workers.\");\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf()),\n              excludeList));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (workResult.getSuccess()) {\n            CopyListingFileStatus childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory());\n            writeToFileListing(fileListWriter, childCopyListingStatus,\n                 sourcePathRoot);\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {}
        }
      ]
    },
    "0790275f058b0cf41780ad337c9150a1e8ebebc6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-1540. Support file exclusion list in distcp. Contributed by Rich Haase.\n",
      "commitDate": "18/05/15 1:24 PM",
      "commitName": "0790275f058b0cf41780ad337c9150a1e8ebebc6",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "24/04/15 1:39 PM",
      "commitNameOld": "a287d2fb77d9873b61c6ab24134993d784ae8475",
      "commitAuthorOld": "Ravi Prakash",
      "daysBetweenCommits": 23.99,
      "commitsBetweenForRepo": 280,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n                                  ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n                                  DistCpOptions options)\n                                  throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n \n     assert numListstatusThreads \u003e 0;\n     LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n               \" listStatus workers.\");\n     ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n         new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n     for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n       workers.addWorker(\n           new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf())));\n     }\n \n     for (FileStatus status : sourceDirs) {\n       workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n     }\n \n     while (workers.hasWork()) {\n       try {\n         WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n         int retry \u003d workResult.getRetry();\n         for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n           if (workResult.getSuccess()) {\n             CopyListingFileStatus childCopyListingStatus \u003d\n               DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                 preserveAcls \u0026\u0026 child.isDirectory(),\n                 preserveXAttrs \u0026\u0026 child.isDirectory(),\n                 preserveRawXattrs \u0026\u0026 child.isDirectory());\n             writeToFileListing(fileListWriter, childCopyListingStatus,\n-                 sourcePathRoot, options);\n+                 sourcePathRoot);\n           }\n           if (retry \u003c maxRetries) {\n             if (child.isDirectory()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Traversing into source dir: \" + child.getPath());\n               }\n               workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n             }\n           } else {\n             LOG.error(\"Giving up on \" + child.getPath() +\n                       \" after \" + retry + \" retries.\");\n           }\n         }\n       } catch (InterruptedException ie) {\n         LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n     workers.shutdown();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n              \" listStatus workers.\");\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf())));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (workResult.getSuccess()) {\n            CopyListingFileStatus childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory());\n            writeToFileListing(fileListWriter, childCopyListingStatus,\n                 sourcePathRoot);\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
      "extendedDetails": {}
    },
    "a287d2fb77d9873b61c6ab24134993d784ae8475": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11876. Refactor code to make it more readable, minor maybePrintStats bug (Zoran Dimitrijevic via raviprak)\n",
      "commitDate": "24/04/15 1:39 PM",
      "commitName": "a287d2fb77d9873b61c6ab24134993d784ae8475",
      "commitAuthor": "Ravi Prakash",
      "commitDateOld": "21/04/15 4:49 PM",
      "commitNameOld": "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7",
      "commitAuthorOld": "Ravi Prakash",
      "daysBetweenCommits": 2.87,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,59 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n                                  ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n                                  DistCpOptions options)\n                                  throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n \n     assert numListstatusThreads \u003e 0;\n     LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n               \" listStatus workers.\");\n     ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n         new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n     for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n       workers.addWorker(\n           new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf())));\n     }\n \n     for (FileStatus status : sourceDirs) {\n       workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n-      maybePrintStats();\n     }\n \n     while (workers.hasWork()) {\n       try {\n         WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n         int retry \u003d workResult.getRetry();\n         for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n-          if (retry \u003d\u003d 0) {\n+          if (workResult.getSuccess()) {\n             CopyListingFileStatus childCopyListingStatus \u003d\n               DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                 preserveAcls \u0026\u0026 child.isDirectory(),\n                 preserveXAttrs \u0026\u0026 child.isDirectory(),\n                 preserveRawXattrs \u0026\u0026 child.isDirectory());\n             writeToFileListing(fileListWriter, childCopyListingStatus,\n                  sourcePathRoot, options);\n           }\n           if (retry \u003c maxRetries) {\n             if (child.isDirectory()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Traversing into source dir: \" + child.getPath());\n               }\n               workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n-              maybePrintStats();\n             }\n           } else {\n             LOG.error(\"Giving up on \" + child.getPath() +\n                       \" after \" + retry + \" retries.\");\n           }\n         }\n       } catch (InterruptedException ie) {\n         LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n     workers.shutdown();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n              \" listStatus workers.\");\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf())));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (workResult.getSuccess()) {\n            CopyListingFileStatus childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory());\n            writeToFileListing(fileListWriter, childCopyListingStatus,\n                 sourcePathRoot, options);\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
      "extendedDetails": {}
    },
    "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-11827. Speed-up distcp buildListing() using threadpool (Zoran Dimitrijevic via raviprak)\n",
      "commitDate": "21/04/15 4:49 PM",
      "commitName": "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7",
      "commitAuthor": "Ravi Prakash",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-11827. Speed-up distcp buildListing() using threadpool (Zoran Dimitrijevic via raviprak)\n",
          "commitDate": "21/04/15 4:49 PM",
          "commitName": "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7",
          "commitAuthor": "Ravi Prakash",
          "commitDateOld": "03/04/15 2:08 PM",
          "commitNameOld": "932730df7d62077f7356464ad27f69469965d77a",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 18.11,
          "commitsBetweenForRepo": 133,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,61 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n-                                 FileStatus sourceStatus,\n+                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n                                  DistCpOptions options)\n                                  throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n-    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n-    pathStack.push(sourceStatus);\n \n-    while (!pathStack.isEmpty()) {\n-      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n-        }\n-        CopyListingFileStatus childCopyListingStatus \u003d\n-          DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n-            preserveAcls \u0026\u0026 child.isDirectory(),\n-            preserveXAttrs \u0026\u0026 child.isDirectory(),\n-            preserveRawXattrs \u0026\u0026 child.isDirectory());\n-        writeToFileListing(fileListWriter, childCopyListingStatus,\n-             sourcePathRoot, options);\n-        if (child.isDirectory()) {\n+    assert numListstatusThreads \u003e 0;\n+    LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n+              \" listStatus workers.\");\n+    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n+        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n+    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n+      workers.addWorker(\n+          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf())));\n+    }\n+\n+    for (FileStatus status : sourceDirs) {\n+      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n+      maybePrintStats();\n+    }\n+\n+    while (workers.hasWork()) {\n+      try {\n+        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n+        int retry \u003d workResult.getRetry();\n+        for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Traversing into source dir: \" + child.getPath());\n+            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n-          pathStack.push(child);\n+          if (retry \u003d\u003d 0) {\n+            CopyListingFileStatus childCopyListingStatus \u003d\n+              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n+                preserveAcls \u0026\u0026 child.isDirectory(),\n+                preserveXAttrs \u0026\u0026 child.isDirectory(),\n+                preserveRawXattrs \u0026\u0026 child.isDirectory());\n+            writeToFileListing(fileListWriter, childCopyListingStatus,\n+                 sourcePathRoot, options);\n+          }\n+          if (retry \u003c maxRetries) {\n+            if (child.isDirectory()) {\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n+              }\n+              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n+              maybePrintStats();\n+            }\n+          } else {\n+            LOG.error(\"Giving up on \" + child.getPath() +\n+                      \" after \" + retry + \" retries.\");\n+          }\n         }\n+      } catch (InterruptedException ie) {\n+        LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n+    workers.shutdown();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n              \" listStatus workers.\");\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf())));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n      maybePrintStats();\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (retry \u003d\u003d 0) {\n            CopyListingFileStatus childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory());\n            writeToFileListing(fileListWriter, childCopyListingStatus,\n                 sourcePathRoot, options);\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n              maybePrintStats();\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {
            "oldValue": "[fileListWriter-SequenceFile.Writer, sourceFS-FileSystem, sourceStatus-FileStatus, sourcePathRoot-Path, options-DistCpOptions]",
            "newValue": "[fileListWriter-SequenceFile.Writer, sourceFS-FileSystem, sourceDirs-ArrayList\u003cFileStatus\u003e, sourcePathRoot-Path, options-DistCpOptions]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-11827. Speed-up distcp buildListing() using threadpool (Zoran Dimitrijevic via raviprak)\n",
          "commitDate": "21/04/15 4:49 PM",
          "commitName": "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7",
          "commitAuthor": "Ravi Prakash",
          "commitDateOld": "03/04/15 2:08 PM",
          "commitNameOld": "932730df7d62077f7356464ad27f69469965d77a",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 18.11,
          "commitsBetweenForRepo": 133,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,61 @@\n   private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                  FileSystem sourceFS,\n-                                 FileStatus sourceStatus,\n+                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                  Path sourcePathRoot,\n                                  DistCpOptions options)\n                                  throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n-    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n-    pathStack.push(sourceStatus);\n \n-    while (!pathStack.isEmpty()) {\n-      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n-        }\n-        CopyListingFileStatus childCopyListingStatus \u003d\n-          DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n-            preserveAcls \u0026\u0026 child.isDirectory(),\n-            preserveXAttrs \u0026\u0026 child.isDirectory(),\n-            preserveRawXattrs \u0026\u0026 child.isDirectory());\n-        writeToFileListing(fileListWriter, childCopyListingStatus,\n-             sourcePathRoot, options);\n-        if (child.isDirectory()) {\n+    assert numListstatusThreads \u003e 0;\n+    LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n+              \" listStatus workers.\");\n+    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n+        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n+    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n+      workers.addWorker(\n+          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf())));\n+    }\n+\n+    for (FileStatus status : sourceDirs) {\n+      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n+      maybePrintStats();\n+    }\n+\n+    while (workers.hasWork()) {\n+      try {\n+        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n+        int retry \u003d workResult.getRetry();\n+        for (FileStatus child: workResult.getItem()) {\n           if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Traversing into source dir: \" + child.getPath());\n+            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n           }\n-          pathStack.push(child);\n+          if (retry \u003d\u003d 0) {\n+            CopyListingFileStatus childCopyListingStatus \u003d\n+              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n+                preserveAcls \u0026\u0026 child.isDirectory(),\n+                preserveXAttrs \u0026\u0026 child.isDirectory(),\n+                preserveRawXattrs \u0026\u0026 child.isDirectory());\n+            writeToFileListing(fileListWriter, childCopyListingStatus,\n+                 sourcePathRoot, options);\n+          }\n+          if (retry \u003c maxRetries) {\n+            if (child.isDirectory()) {\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n+              }\n+              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n+              maybePrintStats();\n+            }\n+          } else {\n+            LOG.error(\"Giving up on \" + child.getPath() +\n+                      \" after \" + retry + \" retries.\");\n+          }\n         }\n+      } catch (InterruptedException ie) {\n+        LOG.error(\"Could not get item from childQueue. Retrying...\");\n       }\n     }\n+    workers.shutdown();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 ArrayList\u003cFileStatus\u003e sourceDirs,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n\n    assert numListstatusThreads \u003e 0;\n    LOG.debug(\"Starting thread pool of \" + numListstatusThreads +\n              \" listStatus workers.\");\n    ProducerConsumer\u003cFileStatus, FileStatus[]\u003e workers \u003d\n        new ProducerConsumer\u003cFileStatus, FileStatus[]\u003e(numListstatusThreads);\n    for (int i \u003d 0; i \u003c numListstatusThreads; i++) {\n      workers.addWorker(\n          new FileStatusProcessor(sourcePathRoot.getFileSystem(getConf())));\n    }\n\n    for (FileStatus status : sourceDirs) {\n      workers.put(new WorkRequest\u003cFileStatus\u003e(status, 0));\n      maybePrintStats();\n    }\n\n    while (workers.hasWork()) {\n      try {\n        WorkReport\u003cFileStatus[]\u003e workResult \u003d workers.take();\n        int retry \u003d workResult.getRetry();\n        for (FileStatus child: workResult.getItem()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n          }\n          if (retry \u003d\u003d 0) {\n            CopyListingFileStatus childCopyListingStatus \u003d\n              DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n                preserveAcls \u0026\u0026 child.isDirectory(),\n                preserveXAttrs \u0026\u0026 child.isDirectory(),\n                preserveRawXattrs \u0026\u0026 child.isDirectory());\n            writeToFileListing(fileListWriter, childCopyListingStatus,\n                 sourcePathRoot, options);\n          }\n          if (retry \u003c maxRetries) {\n            if (child.isDirectory()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Traversing into source dir: \" + child.getPath());\n              }\n              workers.put(new WorkRequest\u003cFileStatus\u003e(child, retry));\n              maybePrintStats();\n            }\n          } else {\n            LOG.error(\"Giving up on \" + child.getPath() +\n                      \" after \" + retry + \" retries.\");\n          }\n        }\n      } catch (InterruptedException ie) {\n        LOG.error(\"Could not get item from childQueue. Retrying...\");\n      }\n    }\n    workers.shutdown();\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {}
        }
      ]
    },
    "932730df7d62077f7356464ad27f69469965d77a": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-11785. Reduce the number of listStatus operation in distcp buildListing (Zoran Dimitrijevic via Colin P. McCabe)\n",
      "commitDate": "03/04/15 2:08 PM",
      "commitName": "932730df7d62077f7356464ad27f69469965d77a",
      "commitAuthor": "Colin Patrick Mccabe",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HADOOP-11785. Reduce the number of listStatus operation in distcp buildListing (Zoran Dimitrijevic via Colin P. McCabe)\n",
          "commitDate": "03/04/15 2:08 PM",
          "commitName": "932730df7d62077f7356464ad27f69469965d77a",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "17/03/15 12:09 AM",
          "commitNameOld": "ef9946cd52d54200c658987c1dbc3e6fce133f77",
          "commitAuthorOld": "Tsuyoshi Ozawa",
          "daysBetweenCommits": 17.58,
          "commitsBetweenForRepo": 182,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,33 @@\n-  private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n-                                         FileStatus sourceStatus,\n-                                         Path sourcePathRoot,\n-                                         DistCpOptions options)\n-                                         throws IOException {\n-    FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n+  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n+                                 FileSystem sourceFS,\n+                                 FileStatus sourceStatus,\n+                                 Path sourcePathRoot,\n+                                 DistCpOptions options)\n+                                 throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n     Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n     pathStack.push(sourceStatus);\n \n     while (!pathStack.isEmpty()) {\n       for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n-        if (LOG.isDebugEnabled())\n-          LOG.debug(\"Recording source-path: \"\n-                    + sourceStatus.getPath() + \" for copy.\");\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n+        }\n         CopyListingFileStatus childCopyListingStatus \u003d\n           DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n             preserveAcls \u0026\u0026 child.isDirectory(),\n             preserveXAttrs \u0026\u0026 child.isDirectory(),\n             preserveRawXattrs \u0026\u0026 child.isDirectory());\n         writeToFileListing(fileListWriter, childCopyListingStatus,\n              sourcePathRoot, options);\n-        if (isDirectoryAndNotEmpty(sourceFS, child)) {\n-          if (LOG.isDebugEnabled())\n-            LOG.debug(\"Traversing non-empty source dir: \"\n-                       + sourceStatus.getPath());\n+        if (child.isDirectory()) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Traversing into source dir: \" + child.getPath());\n+          }\n           pathStack.push(child);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 FileStatus sourceStatus,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n    pathStack.push(sourceStatus);\n\n    while (!pathStack.isEmpty()) {\n      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n        }\n        CopyListingFileStatus childCopyListingStatus \u003d\n          DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n            preserveAcls \u0026\u0026 child.isDirectory(),\n            preserveXAttrs \u0026\u0026 child.isDirectory(),\n            preserveRawXattrs \u0026\u0026 child.isDirectory());\n        writeToFileListing(fileListWriter, childCopyListingStatus,\n             sourcePathRoot, options);\n        if (child.isDirectory()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Traversing into source dir: \" + child.getPath());\n          }\n          pathStack.push(child);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {
            "oldValue": "traverseNonEmptyDirectory",
            "newValue": "traverseDirectory"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-11785. Reduce the number of listStatus operation in distcp buildListing (Zoran Dimitrijevic via Colin P. McCabe)\n",
          "commitDate": "03/04/15 2:08 PM",
          "commitName": "932730df7d62077f7356464ad27f69469965d77a",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "17/03/15 12:09 AM",
          "commitNameOld": "ef9946cd52d54200c658987c1dbc3e6fce133f77",
          "commitAuthorOld": "Tsuyoshi Ozawa",
          "daysBetweenCommits": 17.58,
          "commitsBetweenForRepo": 182,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,33 @@\n-  private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n-                                         FileStatus sourceStatus,\n-                                         Path sourcePathRoot,\n-                                         DistCpOptions options)\n-                                         throws IOException {\n-    FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n+  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n+                                 FileSystem sourceFS,\n+                                 FileStatus sourceStatus,\n+                                 Path sourcePathRoot,\n+                                 DistCpOptions options)\n+                                 throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n     Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n     pathStack.push(sourceStatus);\n \n     while (!pathStack.isEmpty()) {\n       for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n-        if (LOG.isDebugEnabled())\n-          LOG.debug(\"Recording source-path: \"\n-                    + sourceStatus.getPath() + \" for copy.\");\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n+        }\n         CopyListingFileStatus childCopyListingStatus \u003d\n           DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n             preserveAcls \u0026\u0026 child.isDirectory(),\n             preserveXAttrs \u0026\u0026 child.isDirectory(),\n             preserveRawXattrs \u0026\u0026 child.isDirectory());\n         writeToFileListing(fileListWriter, childCopyListingStatus,\n              sourcePathRoot, options);\n-        if (isDirectoryAndNotEmpty(sourceFS, child)) {\n-          if (LOG.isDebugEnabled())\n-            LOG.debug(\"Traversing non-empty source dir: \"\n-                       + sourceStatus.getPath());\n+        if (child.isDirectory()) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Traversing into source dir: \" + child.getPath());\n+          }\n           pathStack.push(child);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 FileStatus sourceStatus,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n    pathStack.push(sourceStatus);\n\n    while (!pathStack.isEmpty()) {\n      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n        }\n        CopyListingFileStatus childCopyListingStatus \u003d\n          DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n            preserveAcls \u0026\u0026 child.isDirectory(),\n            preserveXAttrs \u0026\u0026 child.isDirectory(),\n            preserveRawXattrs \u0026\u0026 child.isDirectory());\n        writeToFileListing(fileListWriter, childCopyListingStatus,\n             sourcePathRoot, options);\n        if (child.isDirectory()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Traversing into source dir: \" + child.getPath());\n          }\n          pathStack.push(child);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {
            "oldValue": "[fileListWriter-SequenceFile.Writer, sourceStatus-FileStatus, sourcePathRoot-Path, options-DistCpOptions]",
            "newValue": "[fileListWriter-SequenceFile.Writer, sourceFS-FileSystem, sourceStatus-FileStatus, sourcePathRoot-Path, options-DistCpOptions]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-11785. Reduce the number of listStatus operation in distcp buildListing (Zoran Dimitrijevic via Colin P. McCabe)\n",
          "commitDate": "03/04/15 2:08 PM",
          "commitName": "932730df7d62077f7356464ad27f69469965d77a",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "17/03/15 12:09 AM",
          "commitNameOld": "ef9946cd52d54200c658987c1dbc3e6fce133f77",
          "commitAuthorOld": "Tsuyoshi Ozawa",
          "daysBetweenCommits": 17.58,
          "commitsBetweenForRepo": 182,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,33 @@\n-  private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n-                                         FileStatus sourceStatus,\n-                                         Path sourcePathRoot,\n-                                         DistCpOptions options)\n-                                         throws IOException {\n-    FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n+  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n+                                 FileSystem sourceFS,\n+                                 FileStatus sourceStatus,\n+                                 Path sourcePathRoot,\n+                                 DistCpOptions options)\n+                                 throws IOException {\n     final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n     final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n     final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n     Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n     pathStack.push(sourceStatus);\n \n     while (!pathStack.isEmpty()) {\n       for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n-        if (LOG.isDebugEnabled())\n-          LOG.debug(\"Recording source-path: \"\n-                    + sourceStatus.getPath() + \" for copy.\");\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n+        }\n         CopyListingFileStatus childCopyListingStatus \u003d\n           DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n             preserveAcls \u0026\u0026 child.isDirectory(),\n             preserveXAttrs \u0026\u0026 child.isDirectory(),\n             preserveRawXattrs \u0026\u0026 child.isDirectory());\n         writeToFileListing(fileListWriter, childCopyListingStatus,\n              sourcePathRoot, options);\n-        if (isDirectoryAndNotEmpty(sourceFS, child)) {\n-          if (LOG.isDebugEnabled())\n-            LOG.debug(\"Traversing non-empty source dir: \"\n-                       + sourceStatus.getPath());\n+        if (child.isDirectory()) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Traversing into source dir: \" + child.getPath());\n+          }\n           pathStack.push(child);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseDirectory(SequenceFile.Writer fileListWriter,\n                                 FileSystem sourceFS,\n                                 FileStatus sourceStatus,\n                                 Path sourcePathRoot,\n                                 DistCpOptions options)\n                                 throws IOException {\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n    pathStack.push(sourceStatus);\n\n    while (!pathStack.isEmpty()) {\n      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Recording source-path: \" + child.getPath() + \" for copy.\");\n        }\n        CopyListingFileStatus childCopyListingStatus \u003d\n          DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n            preserveAcls \u0026\u0026 child.isDirectory(),\n            preserveXAttrs \u0026\u0026 child.isDirectory(),\n            preserveRawXattrs \u0026\u0026 child.isDirectory());\n        writeToFileListing(fileListWriter, childCopyListingStatus,\n             sourcePathRoot, options);\n        if (child.isDirectory()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Traversing into source dir: \" + child.getPath());\n          }\n          pathStack.push(child);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {}
        }
      ]
    },
    "041b8326a1511b721958792a6b94ecfe27d7a1fb": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6007. Add support to distcp to preserve raw.* namespace extended attributes. (clamb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1616657 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/14 6:32 PM",
      "commitName": "041b8326a1511b721958792a6b94ecfe27d7a1fb",
      "commitAuthor": "Charles Lamb",
      "commitDateOld": "06/06/14 7:45 AM",
      "commitNameOld": "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 62.45,
      "commitsBetweenForRepo": 482,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,33 @@\n   private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                          FileStatus sourceStatus,\n                                          Path sourcePathRoot,\n                                          DistCpOptions options)\n                                          throws IOException {\n     FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n+    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n+    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n+    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n     Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n     pathStack.push(sourceStatus);\n \n     while (!pathStack.isEmpty()) {\n       for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Recording source-path: \"\n                     + sourceStatus.getPath() + \" for copy.\");\n         CopyListingFileStatus childCopyListingStatus \u003d\n           DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n-            options.shouldPreserve(FileAttribute.ACL) \u0026\u0026 child.isDirectory(), \n-            options.shouldPreserve(FileAttribute.XATTR) \u0026\u0026 child.isDirectory());\n+            preserveAcls \u0026\u0026 child.isDirectory(),\n+            preserveXAttrs \u0026\u0026 child.isDirectory(),\n+            preserveRawXattrs \u0026\u0026 child.isDirectory());\n         writeToFileListing(fileListWriter, childCopyListingStatus,\n              sourcePathRoot, options);\n         if (isDirectoryAndNotEmpty(sourceFS, child)) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Traversing non-empty source dir: \"\n                        + sourceStatus.getPath());\n           pathStack.push(child);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                         FileStatus sourceStatus,\n                                         Path sourcePathRoot,\n                                         DistCpOptions options)\n                                         throws IOException {\n    FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n    final boolean preserveAcls \u003d options.shouldPreserve(FileAttribute.ACL);\n    final boolean preserveXAttrs \u003d options.shouldPreserve(FileAttribute.XATTR);\n    final boolean preserveRawXattrs \u003d options.shouldPreserveRawXattrs();\n    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n    pathStack.push(sourceStatus);\n\n    while (!pathStack.isEmpty()) {\n      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Recording source-path: \"\n                    + sourceStatus.getPath() + \" for copy.\");\n        CopyListingFileStatus childCopyListingStatus \u003d\n          DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n            preserveAcls \u0026\u0026 child.isDirectory(),\n            preserveXAttrs \u0026\u0026 child.isDirectory(),\n            preserveRawXattrs \u0026\u0026 child.isDirectory());\n        writeToFileListing(fileListWriter, childCopyListingStatus,\n             sourcePathRoot, options);\n        if (isDirectoryAndNotEmpty(sourceFS, child)) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Traversing non-empty source dir: \"\n                       + sourceStatus.getPath());\n          pathStack.push(child);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
      "extendedDetails": {}
    },
    "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5898. distcp to support preserving HDFS extended attributes(XAttrs). Contributed by Yi Liu.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1600900 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/14 7:45 AM",
      "commitName": "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "16/05/14 11:25 AM",
      "commitNameOld": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 20.85,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,29 @@\n   private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                          FileStatus sourceStatus,\n                                          Path sourcePathRoot,\n                                          DistCpOptions options)\n                                          throws IOException {\n     FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n     Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n     pathStack.push(sourceStatus);\n \n     while (!pathStack.isEmpty()) {\n       for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Recording source-path: \"\n                     + sourceStatus.getPath() + \" for copy.\");\n         CopyListingFileStatus childCopyListingStatus \u003d\n           DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n-            options.shouldPreserve(FileAttribute.ACL) \u0026\u0026 child.isDirectory());\n+            options.shouldPreserve(FileAttribute.ACL) \u0026\u0026 child.isDirectory(), \n+            options.shouldPreserve(FileAttribute.XATTR) \u0026\u0026 child.isDirectory());\n         writeToFileListing(fileListWriter, childCopyListingStatus,\n              sourcePathRoot, options);\n         if (isDirectoryAndNotEmpty(sourceFS, child)) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Traversing non-empty source dir: \"\n                        + sourceStatus.getPath());\n           pathStack.push(child);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                         FileStatus sourceStatus,\n                                         Path sourcePathRoot,\n                                         DistCpOptions options)\n                                         throws IOException {\n    FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n    pathStack.push(sourceStatus);\n\n    while (!pathStack.isEmpty()) {\n      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Recording source-path: \"\n                    + sourceStatus.getPath() + \" for copy.\");\n        CopyListingFileStatus childCopyListingStatus \u003d\n          DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n            options.shouldPreserve(FileAttribute.ACL) \u0026\u0026 child.isDirectory(), \n            options.shouldPreserve(FileAttribute.XATTR) \u0026\u0026 child.isDirectory());\n        writeToFileListing(fileListWriter, childCopyListingStatus,\n             sourcePathRoot, options);\n        if (isDirectoryAndNotEmpty(sourceFS, child)) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Traversing non-empty source dir: \"\n                       + sourceStatus.getPath());\n          pathStack.push(child);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
      "extendedDetails": {}
    },
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-5809. Enhance distcp to support preserving HDFS ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/14 11:25 AM",
      "commitName": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
      "commitAuthor": "Chris Nauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-5809. Enhance distcp to support preserving HDFS ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595283 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/05/14 11:25 AM",
          "commitName": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "02/04/14 5:32 PM",
          "commitNameOld": "640a097533e0883bf49504673228d5a327089b44",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 43.75,
          "commitsBetweenForRepo": 263,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,26 +1,28 @@\n   private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                          FileStatus sourceStatus,\n                                          Path sourcePathRoot,\n-                                         boolean localFile,\n                                          DistCpOptions options)\n                                          throws IOException {\n     FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n     Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n     pathStack.push(sourceStatus);\n \n     while (!pathStack.isEmpty()) {\n       for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Recording source-path: \"\n                     + sourceStatus.getPath() + \" for copy.\");\n-        writeToFileListing(fileListWriter, child, sourcePathRoot,\n-             localFile, options);\n+        CopyListingFileStatus childCopyListingStatus \u003d\n+          DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n+            options.shouldPreserve(FileAttribute.ACL) \u0026\u0026 child.isDirectory());\n+        writeToFileListing(fileListWriter, childCopyListingStatus,\n+             sourcePathRoot, options);\n         if (isDirectoryAndNotEmpty(sourceFS, child)) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Traversing non-empty source dir: \"\n                        + sourceStatus.getPath());\n           pathStack.push(child);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                         FileStatus sourceStatus,\n                                         Path sourcePathRoot,\n                                         DistCpOptions options)\n                                         throws IOException {\n    FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n    pathStack.push(sourceStatus);\n\n    while (!pathStack.isEmpty()) {\n      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Recording source-path: \"\n                    + sourceStatus.getPath() + \" for copy.\");\n        CopyListingFileStatus childCopyListingStatus \u003d\n          DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n            options.shouldPreserve(FileAttribute.ACL) \u0026\u0026 child.isDirectory());\n        writeToFileListing(fileListWriter, childCopyListingStatus,\n             sourcePathRoot, options);\n        if (isDirectoryAndNotEmpty(sourceFS, child)) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Traversing non-empty source dir: \"\n                       + sourceStatus.getPath());\n          pathStack.push(child);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {
            "oldValue": "[fileListWriter-SequenceFile.Writer, sourceStatus-FileStatus, sourcePathRoot-Path, localFile-boolean, options-DistCpOptions]",
            "newValue": "[fileListWriter-SequenceFile.Writer, sourceStatus-FileStatus, sourcePathRoot-Path, options-DistCpOptions]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-5809. Enhance distcp to support preserving HDFS ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595283 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/05/14 11:25 AM",
          "commitName": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "02/04/14 5:32 PM",
          "commitNameOld": "640a097533e0883bf49504673228d5a327089b44",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 43.75,
          "commitsBetweenForRepo": 263,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,26 +1,28 @@\n   private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                          FileStatus sourceStatus,\n                                          Path sourcePathRoot,\n-                                         boolean localFile,\n                                          DistCpOptions options)\n                                          throws IOException {\n     FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n     Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n     pathStack.push(sourceStatus);\n \n     while (!pathStack.isEmpty()) {\n       for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Recording source-path: \"\n                     + sourceStatus.getPath() + \" for copy.\");\n-        writeToFileListing(fileListWriter, child, sourcePathRoot,\n-             localFile, options);\n+        CopyListingFileStatus childCopyListingStatus \u003d\n+          DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n+            options.shouldPreserve(FileAttribute.ACL) \u0026\u0026 child.isDirectory());\n+        writeToFileListing(fileListWriter, childCopyListingStatus,\n+             sourcePathRoot, options);\n         if (isDirectoryAndNotEmpty(sourceFS, child)) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Traversing non-empty source dir: \"\n                        + sourceStatus.getPath());\n           pathStack.push(child);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                         FileStatus sourceStatus,\n                                         Path sourcePathRoot,\n                                         DistCpOptions options)\n                                         throws IOException {\n    FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n    pathStack.push(sourceStatus);\n\n    while (!pathStack.isEmpty()) {\n      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Recording source-path: \"\n                    + sourceStatus.getPath() + \" for copy.\");\n        CopyListingFileStatus childCopyListingStatus \u003d\n          DistCpUtils.toCopyListingFileStatus(sourceFS, child,\n            options.shouldPreserve(FileAttribute.ACL) \u0026\u0026 child.isDirectory());\n        writeToFileListing(fileListWriter, childCopyListingStatus,\n             sourcePathRoot, options);\n        if (isDirectoryAndNotEmpty(sourceFS, child)) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Traversing non-empty source dir: \"\n                       + sourceStatus.getPath());\n          pathStack.push(child);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {}
        }
      ]
    },
    "6f92ad9868b008eb523ae3279e05004de31a08ce": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-5014. Extend Distcp to accept a custom CopyListing. Contributed by Srikanth Sundarrajan\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459690 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/03/13 3:09 AM",
      "commitName": "6f92ad9868b008eb523ae3279e05004de31a08ce",
      "commitAuthor": "Amareshwari Sri Ramadasu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-5014. Extend Distcp to accept a custom CopyListing. Contributed by Srikanth Sundarrajan\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459690 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/03/13 3:09 AM",
          "commitName": "6f92ad9868b008eb523ae3279e05004de31a08ce",
          "commitAuthor": "Amareshwari Sri Ramadasu",
          "commitDateOld": "25/01/12 10:36 PM",
          "commitNameOld": "d06948002fb0cabf72cc0d46bf2fa67d45370f67",
          "commitAuthorOld": "Mahadev Konar",
          "daysBetweenCommits": 421.15,
          "commitsBetweenForRepo": 2459,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,26 @@\n   private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                          FileStatus sourceStatus,\n-                                         Path sourcePathRoot, boolean localFile)\n+                                         Path sourcePathRoot,\n+                                         boolean localFile,\n+                                         DistCpOptions options)\n                                          throws IOException {\n     FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n     Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n     pathStack.push(sourceStatus);\n \n     while (!pathStack.isEmpty()) {\n       for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Recording source-path: \"\n                     + sourceStatus.getPath() + \" for copy.\");\n-        writeToFileListing(fileListWriter, child, sourcePathRoot, localFile);\n+        writeToFileListing(fileListWriter, child, sourcePathRoot,\n+             localFile, options);\n         if (isDirectoryAndNotEmpty(sourceFS, child)) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Traversing non-empty source dir: \"\n                        + sourceStatus.getPath());\n           pathStack.push(child);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                         FileStatus sourceStatus,\n                                         Path sourcePathRoot,\n                                         boolean localFile,\n                                         DistCpOptions options)\n                                         throws IOException {\n    FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n    pathStack.push(sourceStatus);\n\n    while (!pathStack.isEmpty()) {\n      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Recording source-path: \"\n                    + sourceStatus.getPath() + \" for copy.\");\n        writeToFileListing(fileListWriter, child, sourcePathRoot,\n             localFile, options);\n        if (isDirectoryAndNotEmpty(sourceFS, child)) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Traversing non-empty source dir: \"\n                       + sourceStatus.getPath());\n          pathStack.push(child);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {
            "oldValue": "[fileListWriter-SequenceFile.Writer, sourceStatus-FileStatus, sourcePathRoot-Path, localFile-boolean]",
            "newValue": "[fileListWriter-SequenceFile.Writer, sourceStatus-FileStatus, sourcePathRoot-Path, localFile-boolean, options-DistCpOptions]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-5014. Extend Distcp to accept a custom CopyListing. Contributed by Srikanth Sundarrajan\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459690 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/03/13 3:09 AM",
          "commitName": "6f92ad9868b008eb523ae3279e05004de31a08ce",
          "commitAuthor": "Amareshwari Sri Ramadasu",
          "commitDateOld": "25/01/12 10:36 PM",
          "commitNameOld": "d06948002fb0cabf72cc0d46bf2fa67d45370f67",
          "commitAuthorOld": "Mahadev Konar",
          "daysBetweenCommits": 421.15,
          "commitsBetweenForRepo": 2459,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,26 @@\n   private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                          FileStatus sourceStatus,\n-                                         Path sourcePathRoot, boolean localFile)\n+                                         Path sourcePathRoot,\n+                                         boolean localFile,\n+                                         DistCpOptions options)\n                                          throws IOException {\n     FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n     Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n     pathStack.push(sourceStatus);\n \n     while (!pathStack.isEmpty()) {\n       for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Recording source-path: \"\n                     + sourceStatus.getPath() + \" for copy.\");\n-        writeToFileListing(fileListWriter, child, sourcePathRoot, localFile);\n+        writeToFileListing(fileListWriter, child, sourcePathRoot,\n+             localFile, options);\n         if (isDirectoryAndNotEmpty(sourceFS, child)) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Traversing non-empty source dir: \"\n                        + sourceStatus.getPath());\n           pathStack.push(child);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                         FileStatus sourceStatus,\n                                         Path sourcePathRoot,\n                                         boolean localFile,\n                                         DistCpOptions options)\n                                         throws IOException {\n    FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n    pathStack.push(sourceStatus);\n\n    while (!pathStack.isEmpty()) {\n      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Recording source-path: \"\n                    + sourceStatus.getPath() + \" for copy.\");\n        writeToFileListing(fileListWriter, child, sourcePathRoot,\n             localFile, options);\n        if (isDirectoryAndNotEmpty(sourceFS, child)) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Traversing non-empty source dir: \"\n                       + sourceStatus.getPath());\n          pathStack.push(child);\n        }\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java",
          "extendedDetails": {}
        }
      ]
    },
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2765. DistCp Rewrite. (Mithun Radhakrishnan via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1236045 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/12 10:36 PM",
      "commitName": "d06948002fb0cabf72cc0d46bf2fa67d45370f67",
      "commitAuthor": "Mahadev Konar",
      "diff": "@@ -0,0 +1,23 @@\n+  private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n+                                         FileStatus sourceStatus,\n+                                         Path sourcePathRoot, boolean localFile)\n+                                         throws IOException {\n+    FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n+    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n+    pathStack.push(sourceStatus);\n+\n+    while (!pathStack.isEmpty()) {\n+      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n+        if (LOG.isDebugEnabled())\n+          LOG.debug(\"Recording source-path: \"\n+                    + sourceStatus.getPath() + \" for copy.\");\n+        writeToFileListing(fileListWriter, child, sourcePathRoot, localFile);\n+        if (isDirectoryAndNotEmpty(sourceFS, child)) {\n+          if (LOG.isDebugEnabled())\n+            LOG.debug(\"Traversing non-empty source dir: \"\n+                       + sourceStatus.getPath());\n+          pathStack.push(child);\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void traverseNonEmptyDirectory(SequenceFile.Writer fileListWriter,\n                                         FileStatus sourceStatus,\n                                         Path sourcePathRoot, boolean localFile)\n                                         throws IOException {\n    FileSystem sourceFS \u003d sourcePathRoot.getFileSystem(getConf());\n    Stack\u003cFileStatus\u003e pathStack \u003d new Stack\u003cFileStatus\u003e();\n    pathStack.push(sourceStatus);\n\n    while (!pathStack.isEmpty()) {\n      for (FileStatus child: getChildren(sourceFS, pathStack.pop())) {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Recording source-path: \"\n                    + sourceStatus.getPath() + \" for copy.\");\n        writeToFileListing(fileListWriter, child, sourcePathRoot, localFile);\n        if (isDirectoryAndNotEmpty(sourceFS, child)) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Traversing non-empty source dir: \"\n                       + sourceStatus.getPath());\n          pathStack.push(child);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/SimpleCopyListing.java"
    }
  }
}