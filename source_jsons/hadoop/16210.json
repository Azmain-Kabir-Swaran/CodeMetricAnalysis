{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RouterRpcClient.java",
  "functionName": "invokeConcurrent",
  "functionId": "invokeConcurrent___locations-Collection__T__(modifiers-final)__method-RemoteMethod(modifiers-final)__standby-boolean__timeOutMs-long__clazz-Class__R__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java",
  "functionStartLine": 1213,
  "functionEndLine": 1329,
  "numCommitsSeen": 24,
  "timeTaken": 887,
  "changeHistory": [
    "203664e6b258b642239651fa6a17fd2561b903d2"
  ],
  "changeHistoryShort": {
    "203664e6b258b642239651fa6a17fd2561b903d2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "203664e6b258b642239651fa6a17fd2561b903d2": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-14454. RBF: getContentSummary() should allow non-existing folders. Contributed by Inigo Goiri.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "203664e6b258b642239651fa6a17fd2561b903d2",
      "commitAuthor": "Ayush Saxena",
      "diff": "@@ -0,0 +1,117 @@\n+      invokeConcurrent(final Collection\u003cT\u003e locations,\n+          final RemoteMethod method, boolean standby, long timeOutMs,\n+          Class\u003cR\u003e clazz) throws IOException {\n+\n+    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n+    final Method m \u003d method.getMethod();\n+\n+    if (locations.isEmpty()) {\n+      throw new IOException(\"No remote locations available\");\n+    } else if (locations.size() \u003d\u003d 1 \u0026\u0026 timeOutMs \u003c\u003d 0) {\n+      // Shortcut, just one call\n+      T location \u003d locations.iterator().next();\n+      String ns \u003d location.getNameserviceId();\n+      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n+          getNamenodesForNameservice(ns);\n+      try {\n+        Class\u003c?\u003e proto \u003d method.getProtocol();\n+        Object[] paramList \u003d method.getParams(location);\n+        R result \u003d (R) invokeMethod(ugi, namenodes, proto, m, paramList);\n+        RemoteResult\u003cT, R\u003e remoteResult \u003d new RemoteResult\u003c\u003e(location, result);\n+        return Collections.singletonList(remoteResult);\n+      } catch (IOException ioe) {\n+        // Localize the exception\n+        throw processException(ioe, location);\n+      }\n+    }\n+\n+    List\u003cT\u003e orderedLocations \u003d new ArrayList\u003c\u003e();\n+    List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n+    for (final T location : locations) {\n+      String nsId \u003d location.getNameserviceId();\n+      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n+          getNamenodesForNameservice(nsId);\n+      final Class\u003c?\u003e proto \u003d method.getProtocol();\n+      final Object[] paramList \u003d method.getParams(location);\n+      if (standby) {\n+        // Call the objectGetter to all NNs (including standby)\n+        for (final FederationNamenodeContext nn : namenodes) {\n+          String nnId \u003d nn.getNamenodeId();\n+          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n+              Collections.singletonList(nn);\n+          T nnLocation \u003d location;\n+          if (location instanceof RemoteLocation) {\n+            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n+          }\n+          orderedLocations.add(nnLocation);\n+          callables.add(() -\u003e invokeMethod(ugi, nnList, proto, m, paramList));\n+        }\n+      } else {\n+        // Call the objectGetter in order of nameservices in the NS list\n+        orderedLocations.add(location);\n+        callables.add(() -\u003e  invokeMethod(ugi, namenodes, proto, m, paramList));\n+      }\n+    }\n+\n+    if (rpcMonitor !\u003d null) {\n+      rpcMonitor.proxyOp();\n+    }\n+\n+    try {\n+      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n+      if (timeOutMs \u003e 0) {\n+        futures \u003d executorService.invokeAll(\n+            callables, timeOutMs, TimeUnit.MILLISECONDS);\n+      } else {\n+        futures \u003d executorService.invokeAll(callables);\n+      }\n+      List\u003cRemoteResult\u003cT, R\u003e\u003e results \u003d new ArrayList\u003c\u003e();\n+      for (int i\u003d0; i\u003cfutures.size(); i++) {\n+        T location \u003d orderedLocations.get(i);\n+        try {\n+          Future\u003cObject\u003e future \u003d futures.get(i);\n+          R result \u003d (R) future.get();\n+          results.add(new RemoteResult\u003c\u003e(location, result));\n+        } catch (CancellationException ce) {\n+          T loc \u003d orderedLocations.get(i);\n+          String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n+              + method.getMethodName() + \"\\\" timed out\";\n+          LOG.error(msg);\n+          IOException ioe \u003d new SubClusterTimeoutException(msg);\n+          results.add(new RemoteResult\u003c\u003e(location, ioe));\n+        } catch (ExecutionException ex) {\n+          Throwable cause \u003d ex.getCause();\n+          LOG.debug(\"Canot execute {} in {}: {}\",\n+              m.getName(), location, cause.getMessage());\n+\n+          // Convert into IOException if needed\n+          IOException ioe \u003d null;\n+          if (cause instanceof IOException) {\n+            ioe \u003d (IOException) cause;\n+          } else {\n+            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n+                m.getName() + \": \" + cause.getMessage(), cause);\n+          }\n+\n+          // Store the exceptions\n+          results.add(new RemoteResult\u003c\u003e(location, ioe));\n+        }\n+      }\n+\n+      return results;\n+    } catch (RejectedExecutionException e) {\n+      if (rpcMonitor !\u003d null) {\n+        rpcMonitor.proxyOpFailureClientOverloaded();\n+      }\n+      int active \u003d executorService.getActiveCount();\n+      int total \u003d executorService.getMaximumPoolSize();\n+      String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n+      LOG.error(msg);\n+      throw new StandbyException(\n+          \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n+    } catch (InterruptedException ex) {\n+      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n+      throw new IOException(\n+          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "      invokeConcurrent(final Collection\u003cT\u003e locations,\n          final RemoteMethod method, boolean standby, long timeOutMs,\n          Class\u003cR\u003e clazz) throws IOException {\n\n    final UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n    final Method m \u003d method.getMethod();\n\n    if (locations.isEmpty()) {\n      throw new IOException(\"No remote locations available\");\n    } else if (locations.size() \u003d\u003d 1 \u0026\u0026 timeOutMs \u003c\u003d 0) {\n      // Shortcut, just one call\n      T location \u003d locations.iterator().next();\n      String ns \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(ns);\n      try {\n        Class\u003c?\u003e proto \u003d method.getProtocol();\n        Object[] paramList \u003d method.getParams(location);\n        R result \u003d (R) invokeMethod(ugi, namenodes, proto, m, paramList);\n        RemoteResult\u003cT, R\u003e remoteResult \u003d new RemoteResult\u003c\u003e(location, result);\n        return Collections.singletonList(remoteResult);\n      } catch (IOException ioe) {\n        // Localize the exception\n        throw processException(ioe, location);\n      }\n    }\n\n    List\u003cT\u003e orderedLocations \u003d new ArrayList\u003c\u003e();\n    List\u003cCallable\u003cObject\u003e\u003e callables \u003d new ArrayList\u003c\u003e();\n    for (final T location : locations) {\n      String nsId \u003d location.getNameserviceId();\n      final List\u003c? extends FederationNamenodeContext\u003e namenodes \u003d\n          getNamenodesForNameservice(nsId);\n      final Class\u003c?\u003e proto \u003d method.getProtocol();\n      final Object[] paramList \u003d method.getParams(location);\n      if (standby) {\n        // Call the objectGetter to all NNs (including standby)\n        for (final FederationNamenodeContext nn : namenodes) {\n          String nnId \u003d nn.getNamenodeId();\n          final List\u003cFederationNamenodeContext\u003e nnList \u003d\n              Collections.singletonList(nn);\n          T nnLocation \u003d location;\n          if (location instanceof RemoteLocation) {\n            nnLocation \u003d (T)new RemoteLocation(nsId, nnId, location.getDest());\n          }\n          orderedLocations.add(nnLocation);\n          callables.add(() -\u003e invokeMethod(ugi, nnList, proto, m, paramList));\n        }\n      } else {\n        // Call the objectGetter in order of nameservices in the NS list\n        orderedLocations.add(location);\n        callables.add(() -\u003e  invokeMethod(ugi, namenodes, proto, m, paramList));\n      }\n    }\n\n    if (rpcMonitor !\u003d null) {\n      rpcMonitor.proxyOp();\n    }\n\n    try {\n      List\u003cFuture\u003cObject\u003e\u003e futures \u003d null;\n      if (timeOutMs \u003e 0) {\n        futures \u003d executorService.invokeAll(\n            callables, timeOutMs, TimeUnit.MILLISECONDS);\n      } else {\n        futures \u003d executorService.invokeAll(callables);\n      }\n      List\u003cRemoteResult\u003cT, R\u003e\u003e results \u003d new ArrayList\u003c\u003e();\n      for (int i\u003d0; i\u003cfutures.size(); i++) {\n        T location \u003d orderedLocations.get(i);\n        try {\n          Future\u003cObject\u003e future \u003d futures.get(i);\n          R result \u003d (R) future.get();\n          results.add(new RemoteResult\u003c\u003e(location, result));\n        } catch (CancellationException ce) {\n          T loc \u003d orderedLocations.get(i);\n          String msg \u003d \"Invocation to \\\"\" + loc + \"\\\" for \\\"\"\n              + method.getMethodName() + \"\\\" timed out\";\n          LOG.error(msg);\n          IOException ioe \u003d new SubClusterTimeoutException(msg);\n          results.add(new RemoteResult\u003c\u003e(location, ioe));\n        } catch (ExecutionException ex) {\n          Throwable cause \u003d ex.getCause();\n          LOG.debug(\"Canot execute {} in {}: {}\",\n              m.getName(), location, cause.getMessage());\n\n          // Convert into IOException if needed\n          IOException ioe \u003d null;\n          if (cause instanceof IOException) {\n            ioe \u003d (IOException) cause;\n          } else {\n            ioe \u003d new IOException(\"Unhandled exception while proxying API \" +\n                m.getName() + \": \" + cause.getMessage(), cause);\n          }\n\n          // Store the exceptions\n          results.add(new RemoteResult\u003c\u003e(location, ioe));\n        }\n      }\n\n      return results;\n    } catch (RejectedExecutionException e) {\n      if (rpcMonitor !\u003d null) {\n        rpcMonitor.proxyOpFailureClientOverloaded();\n      }\n      int active \u003d executorService.getActiveCount();\n      int total \u003d executorService.getMaximumPoolSize();\n      String msg \u003d \"Not enough client threads \" + active + \"/\" + total;\n      LOG.error(msg);\n      throw new StandbyException(\n          \"Router \" + router.getRouterId() + \" is overloaded: \" + msg);\n    } catch (InterruptedException ex) {\n      LOG.error(\"Unexpected error while invoking API: {}\", ex.getMessage());\n      throw new IOException(\n          \"Unexpected error while invoking API \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcClient.java"
    }
  }
}