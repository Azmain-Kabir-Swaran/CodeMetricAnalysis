{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMAppLogAggregation.java",
  "functionName": "getLogAggregationStatusForAppReport",
  "functionId": "getLogAggregationStatusForAppReport___rmApp-RMAppImpl",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppLogAggregation.java",
  "functionStartLine": 167,
  "functionEndLine": 243,
  "numCommitsSeen": 1,
  "timeTaken": 740,
  "changeHistory": [
    "4456ea67b949553b85e101e866b4b3f4b335f1f0"
  ],
  "changeHistoryShort": {
    "4456ea67b949553b85e101e866b4b3f4b335f1f0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4456ea67b949553b85e101e866b4b3f4b335f1f0": {
      "type": "Yintroduced",
      "commitMessage": "YARN-8586. Extract log aggregation related fields and methods from RMAppImpl. Contributed by Peter Bacsko\n",
      "commitDate": "16/08/19 2:36 AM",
      "commitName": "4456ea67b949553b85e101e866b4b3f4b335f1f0",
      "commitAuthor": "Szilard Nemeth",
      "diff": "@@ -0,0 +1,77 @@\n+  public LogAggregationStatus getLogAggregationStatusForAppReport(\n+      RMAppImpl rmApp) {\n+    boolean appInFinalState \u003d RMAppImpl.isAppInFinalState(rmApp);\n+    this.readLock.lock();\n+    try {\n+      if (!logAggregationEnabled) {\n+        return LogAggregationStatus.DISABLED;\n+      }\n+      if (isLogAggregationFinished()) {\n+        return this.logAggregationStatusForAppReport;\n+      }\n+      Map\u003cNodeId, LogAggregationReport\u003e reports \u003d\n+          getLogAggregationReportsForApp(rmApp);\n+      if (reports.size() \u003d\u003d 0) {\n+        return this.logAggregationStatusForAppReport;\n+      }\n+      int logNotStartCount \u003d 0;\n+      int logCompletedCount \u003d 0;\n+      int logTimeOutCount \u003d 0;\n+      int logFailedCount \u003d 0;\n+      int logRunningWithFailure \u003d 0;\n+      for (Map.Entry\u003cNodeId, LogAggregationReport\u003e report :\n+          reports.entrySet()) {\n+        switch (report.getValue().getLogAggregationStatus()) {\n+          case NOT_START:\n+            logNotStartCount++;\n+            break;\n+          case RUNNING_WITH_FAILURE:\n+            logRunningWithFailure ++;\n+            break;\n+          case SUCCEEDED:\n+            logCompletedCount++;\n+            break;\n+          case FAILED:\n+            logFailedCount++;\n+            logCompletedCount++;\n+            break;\n+          case TIME_OUT:\n+            logTimeOutCount++;\n+            logCompletedCount++;\n+            break;\n+          default:\n+            break;\n+        }\n+      }\n+      if (logNotStartCount \u003d\u003d reports.size()) {\n+        return LogAggregationStatus.NOT_START;\n+      } else if (logCompletedCount \u003d\u003d reports.size()) {\n+        // We should satisfy two condition in order to return\n+        // SUCCEEDED or FAILED.\n+        // 1) make sure the application is in final state\n+        // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT\n+        // The SUCCEEDED/FAILED status is the final status which means\n+        // the log aggregation is finished. And the log aggregation status will\n+        // not be updated anymore.\n+        if (logFailedCount \u003e 0 \u0026\u0026 appInFinalState) {\n+          this.logAggregationStatusForAppReport \u003d\n+              LogAggregationStatus.FAILED;\n+          return LogAggregationStatus.FAILED;\n+        } else if (logTimeOutCount \u003e 0) {\n+          this.logAggregationStatusForAppReport \u003d\n+              LogAggregationStatus.TIME_OUT;\n+          return LogAggregationStatus.TIME_OUT;\n+        }\n+        if (appInFinalState) {\n+          this.logAggregationStatusForAppReport \u003d\n+              LogAggregationStatus.SUCCEEDED;\n+          return LogAggregationStatus.SUCCEEDED;\n+        }\n+      } else if (logRunningWithFailure \u003e 0) {\n+        return LogAggregationStatus.RUNNING_WITH_FAILURE;\n+      }\n+      return LogAggregationStatus.RUNNING;\n+    } finally {\n+      this.readLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public LogAggregationStatus getLogAggregationStatusForAppReport(\n      RMAppImpl rmApp) {\n    boolean appInFinalState \u003d RMAppImpl.isAppInFinalState(rmApp);\n    this.readLock.lock();\n    try {\n      if (!logAggregationEnabled) {\n        return LogAggregationStatus.DISABLED;\n      }\n      if (isLogAggregationFinished()) {\n        return this.logAggregationStatusForAppReport;\n      }\n      Map\u003cNodeId, LogAggregationReport\u003e reports \u003d\n          getLogAggregationReportsForApp(rmApp);\n      if (reports.size() \u003d\u003d 0) {\n        return this.logAggregationStatusForAppReport;\n      }\n      int logNotStartCount \u003d 0;\n      int logCompletedCount \u003d 0;\n      int logTimeOutCount \u003d 0;\n      int logFailedCount \u003d 0;\n      int logRunningWithFailure \u003d 0;\n      for (Map.Entry\u003cNodeId, LogAggregationReport\u003e report :\n          reports.entrySet()) {\n        switch (report.getValue().getLogAggregationStatus()) {\n          case NOT_START:\n            logNotStartCount++;\n            break;\n          case RUNNING_WITH_FAILURE:\n            logRunningWithFailure ++;\n            break;\n          case SUCCEEDED:\n            logCompletedCount++;\n            break;\n          case FAILED:\n            logFailedCount++;\n            logCompletedCount++;\n            break;\n          case TIME_OUT:\n            logTimeOutCount++;\n            logCompletedCount++;\n            break;\n          default:\n            break;\n        }\n      }\n      if (logNotStartCount \u003d\u003d reports.size()) {\n        return LogAggregationStatus.NOT_START;\n      } else if (logCompletedCount \u003d\u003d reports.size()) {\n        // We should satisfy two condition in order to return\n        // SUCCEEDED or FAILED.\n        // 1) make sure the application is in final state\n        // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT\n        // The SUCCEEDED/FAILED status is the final status which means\n        // the log aggregation is finished. And the log aggregation status will\n        // not be updated anymore.\n        if (logFailedCount \u003e 0 \u0026\u0026 appInFinalState) {\n          this.logAggregationStatusForAppReport \u003d\n              LogAggregationStatus.FAILED;\n          return LogAggregationStatus.FAILED;\n        } else if (logTimeOutCount \u003e 0) {\n          this.logAggregationStatusForAppReport \u003d\n              LogAggregationStatus.TIME_OUT;\n          return LogAggregationStatus.TIME_OUT;\n        }\n        if (appInFinalState) {\n          this.logAggregationStatusForAppReport \u003d\n              LogAggregationStatus.SUCCEEDED;\n          return LogAggregationStatus.SUCCEEDED;\n        }\n      } else if (logRunningWithFailure \u003e 0) {\n        return LogAggregationStatus.RUNNING_WITH_FAILURE;\n      }\n      return LogAggregationStatus.RUNNING;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppLogAggregation.java"
    }
  }
}