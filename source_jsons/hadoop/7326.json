{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StandbyCheckpointer.java",
  "functionName": "doWork",
  "functionId": "doWork",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
  "functionStartLine": 423,
  "functionEndLine": 507,
  "numCommitsSeen": 37,
  "timeTaken": 4373,
  "changeHistory": [
    "5e6cc6fe8a11a638ba98913ca402efdc988fe73a",
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "169cdaa38eca1c0b78f608754eb15d4e6ca87bd9",
    "2536ece7b67ccfeac44314615a5f9dbe771ce373",
    "49dfad942970459297f72632ed8dfd353e0c86de",
    "64c50d9dfb2247852b9e03fd3e41ce426f872e94",
    "dedcc09e717fa810260ecf83a4abca746dbedd49",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
    "49a892056df7d73207f7a65ae5b4b905ba5e6ab8",
    "45b9d19f9d2b14e4d3c386af9de3df817da3c9df",
    "15ddb6634f8bdab37ce43f99f8338d84422c7232",
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae"
  ],
  "changeHistoryShort": {
    "5e6cc6fe8a11a638ba98913ca402efdc988fe73a": "Ybodychange",
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "169cdaa38eca1c0b78f608754eb15d4e6ca87bd9": "Ybodychange",
    "2536ece7b67ccfeac44314615a5f9dbe771ce373": "Ybodychange",
    "49dfad942970459297f72632ed8dfd353e0c86de": "Ybodychange",
    "64c50d9dfb2247852b9e03fd3e41ce426f872e94": "Ybodychange",
    "dedcc09e717fa810260ecf83a4abca746dbedd49": "Ybodychange",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": "Ybodychange",
    "49a892056df7d73207f7a65ae5b4b905ba5e6ab8": "Ybodychange",
    "45b9d19f9d2b14e4d3c386af9de3df817da3c9df": "Ybodychange",
    "15ddb6634f8bdab37ce43f99f8338d84422c7232": "Ybodychange",
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5e6cc6fe8a11a638ba98913ca402efdc988fe73a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12979. [SBN read] StandbyNode should upload FsImage to ObserverNode after checkpointing. Contributed by Chen Liang.\n",
      "commitDate": "17/07/19 2:37 PM",
      "commitName": "5e6cc6fe8a11a638ba98913ca402efdc988fe73a",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "14/02/18 8:20 AM",
      "commitNameOld": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 518.22,
      "commitsBetweenForRepo": 4504,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,85 @@\n     private void doWork() {\n       final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n       // Reset checkpoint time so that we don\u0027t always checkpoint\n       // on startup.\n       lastCheckpointTime \u003d monotonicNow();\n-      lastUploadTime \u003d monotonicNow();\n       while (shouldRun) {\n         boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n         if (!needRollbackCheckpoint) {\n           try {\n             Thread.sleep(checkPeriod);\n           } catch (InterruptedException ie) {\n           }\n           if (!shouldRun) {\n             break;\n           }\n         }\n         try {\n           // We may have lost our ticket since last checkpoint, log in again, just in case\n           if (UserGroupInformation.isSecurityEnabled()) {\n             UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n           }\n           \n           final long now \u003d monotonicNow();\n           final long uncheckpointed \u003d countUncheckpointedTxns();\n           final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n \n           // if we need a rollback checkpoint, always attempt to checkpoint\n           boolean needCheckpoint \u003d needRollbackCheckpoint;\n \n           if (needCheckpoint) {\n             LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n           } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n             LOG.info(\"Triggering checkpoint because there have been {} txns \" +\n                 \"since the last checkpoint, \" +\n                 \"which exceeds the configured threshold {}\",\n                 uncheckpointed, checkpointConf.getTxnCount());\n             needCheckpoint \u003d true;\n           } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n             LOG.info(\"Triggering checkpoint because it has been {} seconds \" +\n                 \"since the last checkpoint, which exceeds the configured \" +\n                 \"interval {}\", secsSinceLast, checkpointConf.getPeriod());\n             needCheckpoint \u003d true;\n           }\n \n           if (needCheckpoint) {\n             synchronized (cancelLock) {\n               if (now \u003c preventCheckpointsUntil) {\n                 LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n                 canceledCount++;\n                 continue;\n               }\n               assert canceler \u003d\u003d null;\n               canceler \u003d new Canceler();\n             }\n \n             // on all nodes, we build the checkpoint. However, we only ship the checkpoint if have a\n             // rollback request, are the checkpointer, are outside the quiet period.\n-            final long secsSinceLastUpload \u003d (now - lastUploadTime) / 1000;\n-            boolean sendRequest \u003d isPrimaryCheckPointer\n-                || secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n-            doCheckpoint(sendRequest);\n+            doCheckpoint();\n \n             // reset needRollbackCheckpoint to false only when we finish a ckpt\n             // for rollback image\n             if (needRollbackCheckpoint\n                 \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n               namesystem.setCreatedRollbackImages(true);\n               namesystem.setNeedRollbackFsImage(false);\n             }\n             lastCheckpointTime \u003d now;\n             LOG.info(\"Checkpoint finished successfully.\");\n           }\n         } catch (SaveNamespaceCancelledException ce) {\n           LOG.info(\"Checkpoint was cancelled: {}\", ce.getMessage());\n           canceledCount++;\n         } catch (InterruptedException ie) {\n           LOG.info(\"Interrupted during checkpointing\", ie);\n           // Probably requested shutdown.\n           continue;\n         } catch (Throwable t) {\n           LOG.error(\"Exception in doCheckpoint\", t);\n         } finally {\n           synchronized (cancelLock) {\n             canceler \u003d null;\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d monotonicNow();\n      while (shouldRun) {\n        boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n        if (!needRollbackCheckpoint) {\n          try {\n            Thread.sleep(checkPeriod);\n          } catch (InterruptedException ie) {\n          }\n          if (!shouldRun) {\n            break;\n          }\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n          }\n          \n          final long now \u003d monotonicNow();\n          final long uncheckpointed \u003d countUncheckpointedTxns();\n          final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n\n          // if we need a rollback checkpoint, always attempt to checkpoint\n          boolean needCheckpoint \u003d needRollbackCheckpoint;\n\n          if (needCheckpoint) {\n            LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n          } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been {} txns \" +\n                \"since the last checkpoint, \" +\n                \"which exceeds the configured threshold {}\",\n                uncheckpointed, checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been {} seconds \" +\n                \"since the last checkpoint, which exceeds the configured \" +\n                \"interval {}\", secsSinceLast, checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n\n          if (needCheckpoint) {\n            synchronized (cancelLock) {\n              if (now \u003c preventCheckpointsUntil) {\n                LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n                canceledCount++;\n                continue;\n              }\n              assert canceler \u003d\u003d null;\n              canceler \u003d new Canceler();\n            }\n\n            // on all nodes, we build the checkpoint. However, we only ship the checkpoint if have a\n            // rollback request, are the checkpointer, are outside the quiet period.\n            doCheckpoint();\n\n            // reset needRollbackCheckpoint to false only when we finish a ckpt\n            // for rollback image\n            if (needRollbackCheckpoint\n                \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n              namesystem.setCreatedRollbackImages(true);\n              namesystem.setNeedRollbackFsImage(false);\n            }\n            lastCheckpointTime \u003d now;\n            LOG.info(\"Checkpoint finished successfully.\");\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: {}\", ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          LOG.info(\"Interrupted during checkpointing\", ie);\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        } finally {\n          synchronized (cancelLock) {\n            canceler \u003d null;\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "03/11/17 8:34 PM",
      "commitNameOld": "169cdaa38eca1c0b78f608754eb15d4e6ca87bd9",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 102.53,
      "commitsBetweenForRepo": 673,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,89 @@\n     private void doWork() {\n       final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n       // Reset checkpoint time so that we don\u0027t always checkpoint\n       // on startup.\n       lastCheckpointTime \u003d monotonicNow();\n       lastUploadTime \u003d monotonicNow();\n       while (shouldRun) {\n         boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n         if (!needRollbackCheckpoint) {\n           try {\n             Thread.sleep(checkPeriod);\n           } catch (InterruptedException ie) {\n           }\n           if (!shouldRun) {\n             break;\n           }\n         }\n         try {\n           // We may have lost our ticket since last checkpoint, log in again, just in case\n           if (UserGroupInformation.isSecurityEnabled()) {\n             UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n           }\n           \n           final long now \u003d monotonicNow();\n           final long uncheckpointed \u003d countUncheckpointedTxns();\n           final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n \n           // if we need a rollback checkpoint, always attempt to checkpoint\n           boolean needCheckpoint \u003d needRollbackCheckpoint;\n \n           if (needCheckpoint) {\n             LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n           } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n-            LOG.info(\"Triggering checkpoint because there have been \" + \n-                uncheckpointed + \" txns since the last checkpoint, which \" +\n-                \"exceeds the configured threshold \" +\n-                checkpointConf.getTxnCount());\n+            LOG.info(\"Triggering checkpoint because there have been {} txns \" +\n+                \"since the last checkpoint, \" +\n+                \"which exceeds the configured threshold {}\",\n+                uncheckpointed, checkpointConf.getTxnCount());\n             needCheckpoint \u003d true;\n           } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n-            LOG.info(\"Triggering checkpoint because it has been \" +\n-                secsSinceLast + \" seconds since the last checkpoint, which \" +\n-                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n+            LOG.info(\"Triggering checkpoint because it has been {} seconds \" +\n+                \"since the last checkpoint, which exceeds the configured \" +\n+                \"interval {}\", secsSinceLast, checkpointConf.getPeriod());\n             needCheckpoint \u003d true;\n           }\n \n           if (needCheckpoint) {\n             synchronized (cancelLock) {\n               if (now \u003c preventCheckpointsUntil) {\n                 LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n                 canceledCount++;\n                 continue;\n               }\n               assert canceler \u003d\u003d null;\n               canceler \u003d new Canceler();\n             }\n \n             // on all nodes, we build the checkpoint. However, we only ship the checkpoint if have a\n             // rollback request, are the checkpointer, are outside the quiet period.\n             final long secsSinceLastUpload \u003d (now - lastUploadTime) / 1000;\n             boolean sendRequest \u003d isPrimaryCheckPointer\n                 || secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n             doCheckpoint(sendRequest);\n \n             // reset needRollbackCheckpoint to false only when we finish a ckpt\n             // for rollback image\n             if (needRollbackCheckpoint\n                 \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n               namesystem.setCreatedRollbackImages(true);\n               namesystem.setNeedRollbackFsImage(false);\n             }\n             lastCheckpointTime \u003d now;\n             LOG.info(\"Checkpoint finished successfully.\");\n           }\n         } catch (SaveNamespaceCancelledException ce) {\n-          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n+          LOG.info(\"Checkpoint was cancelled: {}\", ce.getMessage());\n           canceledCount++;\n         } catch (InterruptedException ie) {\n           LOG.info(\"Interrupted during checkpointing\", ie);\n           // Probably requested shutdown.\n           continue;\n         } catch (Throwable t) {\n           LOG.error(\"Exception in doCheckpoint\", t);\n         } finally {\n           synchronized (cancelLock) {\n             canceler \u003d null;\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d monotonicNow();\n      lastUploadTime \u003d monotonicNow();\n      while (shouldRun) {\n        boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n        if (!needRollbackCheckpoint) {\n          try {\n            Thread.sleep(checkPeriod);\n          } catch (InterruptedException ie) {\n          }\n          if (!shouldRun) {\n            break;\n          }\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n          }\n          \n          final long now \u003d monotonicNow();\n          final long uncheckpointed \u003d countUncheckpointedTxns();\n          final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n\n          // if we need a rollback checkpoint, always attempt to checkpoint\n          boolean needCheckpoint \u003d needRollbackCheckpoint;\n\n          if (needCheckpoint) {\n            LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n          } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been {} txns \" +\n                \"since the last checkpoint, \" +\n                \"which exceeds the configured threshold {}\",\n                uncheckpointed, checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been {} seconds \" +\n                \"since the last checkpoint, which exceeds the configured \" +\n                \"interval {}\", secsSinceLast, checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n\n          if (needCheckpoint) {\n            synchronized (cancelLock) {\n              if (now \u003c preventCheckpointsUntil) {\n                LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n                canceledCount++;\n                continue;\n              }\n              assert canceler \u003d\u003d null;\n              canceler \u003d new Canceler();\n            }\n\n            // on all nodes, we build the checkpoint. However, we only ship the checkpoint if have a\n            // rollback request, are the checkpointer, are outside the quiet period.\n            final long secsSinceLastUpload \u003d (now - lastUploadTime) / 1000;\n            boolean sendRequest \u003d isPrimaryCheckPointer\n                || secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n            doCheckpoint(sendRequest);\n\n            // reset needRollbackCheckpoint to false only when we finish a ckpt\n            // for rollback image\n            if (needRollbackCheckpoint\n                \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n              namesystem.setCreatedRollbackImages(true);\n              namesystem.setNeedRollbackFsImage(false);\n            }\n            lastCheckpointTime \u003d now;\n            LOG.info(\"Checkpoint finished successfully.\");\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: {}\", ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          LOG.info(\"Interrupted during checkpointing\", ie);\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        } finally {\n          synchronized (cancelLock) {\n            canceler \u003d null;\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "169cdaa38eca1c0b78f608754eb15d4e6ca87bd9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10528. Add logging to successful standby checkpointing. Contributed by Xiaoyu Yao.\n",
      "commitDate": "03/11/17 8:34 PM",
      "commitName": "169cdaa38eca1c0b78f608754eb15d4e6ca87bd9",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "14/09/17 11:17 AM",
      "commitNameOld": "65a941008d4bbf906772399d3f035f2a0da5abfa",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 50.39,
      "commitsBetweenForRepo": 378,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,89 @@\n     private void doWork() {\n       final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n       // Reset checkpoint time so that we don\u0027t always checkpoint\n       // on startup.\n       lastCheckpointTime \u003d monotonicNow();\n       lastUploadTime \u003d monotonicNow();\n       while (shouldRun) {\n         boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n         if (!needRollbackCheckpoint) {\n           try {\n             Thread.sleep(checkPeriod);\n           } catch (InterruptedException ie) {\n           }\n           if (!shouldRun) {\n             break;\n           }\n         }\n         try {\n           // We may have lost our ticket since last checkpoint, log in again, just in case\n           if (UserGroupInformation.isSecurityEnabled()) {\n             UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n           }\n           \n           final long now \u003d monotonicNow();\n           final long uncheckpointed \u003d countUncheckpointedTxns();\n           final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n \n           // if we need a rollback checkpoint, always attempt to checkpoint\n           boolean needCheckpoint \u003d needRollbackCheckpoint;\n \n           if (needCheckpoint) {\n             LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n           } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n             LOG.info(\"Triggering checkpoint because there have been \" + \n                 uncheckpointed + \" txns since the last checkpoint, which \" +\n                 \"exceeds the configured threshold \" +\n                 checkpointConf.getTxnCount());\n             needCheckpoint \u003d true;\n           } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n             LOG.info(\"Triggering checkpoint because it has been \" +\n                 secsSinceLast + \" seconds since the last checkpoint, which \" +\n                 \"exceeds the configured interval \" + checkpointConf.getPeriod());\n             needCheckpoint \u003d true;\n           }\n \n           if (needCheckpoint) {\n             synchronized (cancelLock) {\n               if (now \u003c preventCheckpointsUntil) {\n                 LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n                 canceledCount++;\n                 continue;\n               }\n               assert canceler \u003d\u003d null;\n               canceler \u003d new Canceler();\n             }\n \n             // on all nodes, we build the checkpoint. However, we only ship the checkpoint if have a\n             // rollback request, are the checkpointer, are outside the quiet period.\n             final long secsSinceLastUpload \u003d (now - lastUploadTime) / 1000;\n             boolean sendRequest \u003d isPrimaryCheckPointer\n                 || secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n             doCheckpoint(sendRequest);\n \n             // reset needRollbackCheckpoint to false only when we finish a ckpt\n             // for rollback image\n             if (needRollbackCheckpoint\n                 \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n               namesystem.setCreatedRollbackImages(true);\n               namesystem.setNeedRollbackFsImage(false);\n             }\n             lastCheckpointTime \u003d now;\n+            LOG.info(\"Checkpoint finished successfully.\");\n           }\n         } catch (SaveNamespaceCancelledException ce) {\n           LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n           canceledCount++;\n         } catch (InterruptedException ie) {\n           LOG.info(\"Interrupted during checkpointing\", ie);\n           // Probably requested shutdown.\n           continue;\n         } catch (Throwable t) {\n           LOG.error(\"Exception in doCheckpoint\", t);\n         } finally {\n           synchronized (cancelLock) {\n             canceler \u003d null;\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d monotonicNow();\n      lastUploadTime \u003d monotonicNow();\n      while (shouldRun) {\n        boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n        if (!needRollbackCheckpoint) {\n          try {\n            Thread.sleep(checkPeriod);\n          } catch (InterruptedException ie) {\n          }\n          if (!shouldRun) {\n            break;\n          }\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n          }\n          \n          final long now \u003d monotonicNow();\n          final long uncheckpointed \u003d countUncheckpointedTxns();\n          final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n\n          // if we need a rollback checkpoint, always attempt to checkpoint\n          boolean needCheckpoint \u003d needRollbackCheckpoint;\n\n          if (needCheckpoint) {\n            LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n          } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been \" + \n                uncheckpointed + \" txns since the last checkpoint, which \" +\n                \"exceeds the configured threshold \" +\n                checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been \" +\n                secsSinceLast + \" seconds since the last checkpoint, which \" +\n                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n\n          if (needCheckpoint) {\n            synchronized (cancelLock) {\n              if (now \u003c preventCheckpointsUntil) {\n                LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n                canceledCount++;\n                continue;\n              }\n              assert canceler \u003d\u003d null;\n              canceler \u003d new Canceler();\n            }\n\n            // on all nodes, we build the checkpoint. However, we only ship the checkpoint if have a\n            // rollback request, are the checkpointer, are outside the quiet period.\n            final long secsSinceLastUpload \u003d (now - lastUploadTime) / 1000;\n            boolean sendRequest \u003d isPrimaryCheckPointer\n                || secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n            doCheckpoint(sendRequest);\n\n            // reset needRollbackCheckpoint to false only when we finish a ckpt\n            // for rollback image\n            if (needRollbackCheckpoint\n                \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n              namesystem.setCreatedRollbackImages(true);\n              namesystem.setNeedRollbackFsImage(false);\n            }\n            lastCheckpointTime \u003d now;\n            LOG.info(\"Checkpoint finished successfully.\");\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          LOG.info(\"Interrupted during checkpointing\", ie);\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        } finally {\n          synchronized (cancelLock) {\n            canceler \u003d null;\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "2536ece7b67ccfeac44314615a5f9dbe771ce373": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9787. SNNs stop uploading FSImage to ANN once isPrimaryCheckPointer changed to false. (Contributed by Guocui Mi)\n",
      "commitDate": "16/02/16 9:11 PM",
      "commitName": "2536ece7b67ccfeac44314615a5f9dbe771ce373",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "23/06/15 5:26 PM",
      "commitNameOld": "49dfad942970459297f72632ed8dfd353e0c86de",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 238.2,
      "commitsBetweenForRepo": 1600,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,88 @@\n     private void doWork() {\n       final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n       // Reset checkpoint time so that we don\u0027t always checkpoint\n       // on startup.\n       lastCheckpointTime \u003d monotonicNow();\n+      lastUploadTime \u003d monotonicNow();\n       while (shouldRun) {\n         boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n         if (!needRollbackCheckpoint) {\n           try {\n             Thread.sleep(checkPeriod);\n           } catch (InterruptedException ie) {\n           }\n           if (!shouldRun) {\n             break;\n           }\n         }\n         try {\n           // We may have lost our ticket since last checkpoint, log in again, just in case\n           if (UserGroupInformation.isSecurityEnabled()) {\n             UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n           }\n           \n           final long now \u003d monotonicNow();\n           final long uncheckpointed \u003d countUncheckpointedTxns();\n           final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n \n           // if we need a rollback checkpoint, always attempt to checkpoint\n           boolean needCheckpoint \u003d needRollbackCheckpoint;\n \n           if (needCheckpoint) {\n             LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n           } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n             LOG.info(\"Triggering checkpoint because there have been \" + \n                 uncheckpointed + \" txns since the last checkpoint, which \" +\n                 \"exceeds the configured threshold \" +\n                 checkpointConf.getTxnCount());\n             needCheckpoint \u003d true;\n           } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n             LOG.info(\"Triggering checkpoint because it has been \" +\n                 secsSinceLast + \" seconds since the last checkpoint, which \" +\n                 \"exceeds the configured interval \" + checkpointConf.getPeriod());\n             needCheckpoint \u003d true;\n           }\n \n           if (needCheckpoint) {\n             synchronized (cancelLock) {\n               if (now \u003c preventCheckpointsUntil) {\n                 LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n                 canceledCount++;\n                 continue;\n               }\n               assert canceler \u003d\u003d null;\n               canceler \u003d new Canceler();\n             }\n \n             // on all nodes, we build the checkpoint. However, we only ship the checkpoint if have a\n             // rollback request, are the checkpointer, are outside the quiet period.\n-            boolean sendRequest \u003d isPrimaryCheckPointer || secsSinceLast \u003e\u003d checkpointConf.getQuietPeriod();\n+            final long secsSinceLastUpload \u003d (now - lastUploadTime) / 1000;\n+            boolean sendRequest \u003d isPrimaryCheckPointer\n+                || secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n             doCheckpoint(sendRequest);\n \n             // reset needRollbackCheckpoint to false only when we finish a ckpt\n             // for rollback image\n             if (needRollbackCheckpoint\n                 \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n               namesystem.setCreatedRollbackImages(true);\n               namesystem.setNeedRollbackFsImage(false);\n             }\n             lastCheckpointTime \u003d now;\n           }\n         } catch (SaveNamespaceCancelledException ce) {\n           LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n           canceledCount++;\n         } catch (InterruptedException ie) {\n           LOG.info(\"Interrupted during checkpointing\", ie);\n           // Probably requested shutdown.\n           continue;\n         } catch (Throwable t) {\n           LOG.error(\"Exception in doCheckpoint\", t);\n         } finally {\n           synchronized (cancelLock) {\n             canceler \u003d null;\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d monotonicNow();\n      lastUploadTime \u003d monotonicNow();\n      while (shouldRun) {\n        boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n        if (!needRollbackCheckpoint) {\n          try {\n            Thread.sleep(checkPeriod);\n          } catch (InterruptedException ie) {\n          }\n          if (!shouldRun) {\n            break;\n          }\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n          }\n          \n          final long now \u003d monotonicNow();\n          final long uncheckpointed \u003d countUncheckpointedTxns();\n          final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n\n          // if we need a rollback checkpoint, always attempt to checkpoint\n          boolean needCheckpoint \u003d needRollbackCheckpoint;\n\n          if (needCheckpoint) {\n            LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n          } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been \" + \n                uncheckpointed + \" txns since the last checkpoint, which \" +\n                \"exceeds the configured threshold \" +\n                checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been \" +\n                secsSinceLast + \" seconds since the last checkpoint, which \" +\n                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n\n          if (needCheckpoint) {\n            synchronized (cancelLock) {\n              if (now \u003c preventCheckpointsUntil) {\n                LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n                canceledCount++;\n                continue;\n              }\n              assert canceler \u003d\u003d null;\n              canceler \u003d new Canceler();\n            }\n\n            // on all nodes, we build the checkpoint. However, we only ship the checkpoint if have a\n            // rollback request, are the checkpointer, are outside the quiet period.\n            final long secsSinceLastUpload \u003d (now - lastUploadTime) / 1000;\n            boolean sendRequest \u003d isPrimaryCheckPointer\n                || secsSinceLastUpload \u003e\u003d checkpointConf.getQuietPeriod();\n            doCheckpoint(sendRequest);\n\n            // reset needRollbackCheckpoint to false only when we finish a ckpt\n            // for rollback image\n            if (needRollbackCheckpoint\n                \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n              namesystem.setCreatedRollbackImages(true);\n              namesystem.setNeedRollbackFsImage(false);\n            }\n            lastCheckpointTime \u003d now;\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          LOG.info(\"Interrupted during checkpointing\", ie);\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        } finally {\n          synchronized (cancelLock) {\n            canceler \u003d null;\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "49dfad942970459297f72632ed8dfd353e0c86de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6440. Support more than 2 NameNodes. Contributed by Jesse Yates.\n",
      "commitDate": "23/06/15 5:26 PM",
      "commitName": "49dfad942970459297f72632ed8dfd353e0c86de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "25/11/14 3:37 PM",
      "commitNameOld": "f43a20c529ac3f104add95b222de6580757b3763",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 210.03,
      "commitsBetweenForRepo": 1722,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,85 @@\n     private void doWork() {\n       final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n       // Reset checkpoint time so that we don\u0027t always checkpoint\n       // on startup.\n       lastCheckpointTime \u003d monotonicNow();\n       while (shouldRun) {\n         boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n         if (!needRollbackCheckpoint) {\n           try {\n             Thread.sleep(checkPeriod);\n           } catch (InterruptedException ie) {\n           }\n           if (!shouldRun) {\n             break;\n           }\n         }\n         try {\n           // We may have lost our ticket since last checkpoint, log in again, just in case\n           if (UserGroupInformation.isSecurityEnabled()) {\n             UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n           }\n           \n           final long now \u003d monotonicNow();\n           final long uncheckpointed \u003d countUncheckpointedTxns();\n           final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n-          \n+\n+          // if we need a rollback checkpoint, always attempt to checkpoint\n           boolean needCheckpoint \u003d needRollbackCheckpoint;\n+\n           if (needCheckpoint) {\n             LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n           } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n             LOG.info(\"Triggering checkpoint because there have been \" + \n                 uncheckpointed + \" txns since the last checkpoint, which \" +\n                 \"exceeds the configured threshold \" +\n                 checkpointConf.getTxnCount());\n             needCheckpoint \u003d true;\n           } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n             LOG.info(\"Triggering checkpoint because it has been \" +\n                 secsSinceLast + \" seconds since the last checkpoint, which \" +\n                 \"exceeds the configured interval \" + checkpointConf.getPeriod());\n             needCheckpoint \u003d true;\n           }\n-          \n-          synchronized (cancelLock) {\n-            if (now \u003c preventCheckpointsUntil) {\n-              LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n-              canceledCount++;\n-              continue;\n-            }\n-            assert canceler \u003d\u003d null;\n-            canceler \u003d new Canceler();\n-          }\n-          \n+\n           if (needCheckpoint) {\n-            doCheckpoint();\n+            synchronized (cancelLock) {\n+              if (now \u003c preventCheckpointsUntil) {\n+                LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n+                canceledCount++;\n+                continue;\n+              }\n+              assert canceler \u003d\u003d null;\n+              canceler \u003d new Canceler();\n+            }\n+\n+            // on all nodes, we build the checkpoint. However, we only ship the checkpoint if have a\n+            // rollback request, are the checkpointer, are outside the quiet period.\n+            boolean sendRequest \u003d isPrimaryCheckPointer || secsSinceLast \u003e\u003d checkpointConf.getQuietPeriod();\n+            doCheckpoint(sendRequest);\n+\n             // reset needRollbackCheckpoint to false only when we finish a ckpt\n             // for rollback image\n             if (needRollbackCheckpoint\n                 \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n               namesystem.setCreatedRollbackImages(true);\n               namesystem.setNeedRollbackFsImage(false);\n             }\n             lastCheckpointTime \u003d now;\n           }\n         } catch (SaveNamespaceCancelledException ce) {\n           LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n           canceledCount++;\n         } catch (InterruptedException ie) {\n           LOG.info(\"Interrupted during checkpointing\", ie);\n           // Probably requested shutdown.\n           continue;\n         } catch (Throwable t) {\n           LOG.error(\"Exception in doCheckpoint\", t);\n         } finally {\n           synchronized (cancelLock) {\n             canceler \u003d null;\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d monotonicNow();\n      while (shouldRun) {\n        boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n        if (!needRollbackCheckpoint) {\n          try {\n            Thread.sleep(checkPeriod);\n          } catch (InterruptedException ie) {\n          }\n          if (!shouldRun) {\n            break;\n          }\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n          }\n          \n          final long now \u003d monotonicNow();\n          final long uncheckpointed \u003d countUncheckpointedTxns();\n          final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n\n          // if we need a rollback checkpoint, always attempt to checkpoint\n          boolean needCheckpoint \u003d needRollbackCheckpoint;\n\n          if (needCheckpoint) {\n            LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n          } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been \" + \n                uncheckpointed + \" txns since the last checkpoint, which \" +\n                \"exceeds the configured threshold \" +\n                checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been \" +\n                secsSinceLast + \" seconds since the last checkpoint, which \" +\n                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n\n          if (needCheckpoint) {\n            synchronized (cancelLock) {\n              if (now \u003c preventCheckpointsUntil) {\n                LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n                canceledCount++;\n                continue;\n              }\n              assert canceler \u003d\u003d null;\n              canceler \u003d new Canceler();\n            }\n\n            // on all nodes, we build the checkpoint. However, we only ship the checkpoint if have a\n            // rollback request, are the checkpointer, are outside the quiet period.\n            boolean sendRequest \u003d isPrimaryCheckPointer || secsSinceLast \u003e\u003d checkpointConf.getQuietPeriod();\n            doCheckpoint(sendRequest);\n\n            // reset needRollbackCheckpoint to false only when we finish a ckpt\n            // for rollback image\n            if (needRollbackCheckpoint\n                \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n              namesystem.setCreatedRollbackImages(true);\n              namesystem.setNeedRollbackFsImage(false);\n            }\n            lastCheckpointTime \u003d now;\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          LOG.info(\"Interrupted during checkpointing\", ie);\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        } finally {\n          synchronized (cancelLock) {\n            canceler \u003d null;\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "64c50d9dfb2247852b9e03fd3e41ce426f872e94": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5591. Checkpointing should use monotonic time when calculating period. Contributed by Charles Lamb.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1583926 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/04/14 1:33 AM",
      "commitName": "64c50d9dfb2247852b9e03fd3e41ce426f872e94",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "24/03/14 4:32 PM",
      "commitNameOld": "c2ef7e239eb0e81cf8a3e971378e9e696202de67",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 8.38,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n     private void doWork() {\n       final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n       // Reset checkpoint time so that we don\u0027t always checkpoint\n       // on startup.\n-      lastCheckpointTime \u003d now();\n+      lastCheckpointTime \u003d monotonicNow();\n       while (shouldRun) {\n         boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n         if (!needRollbackCheckpoint) {\n           try {\n             Thread.sleep(checkPeriod);\n           } catch (InterruptedException ie) {\n           }\n           if (!shouldRun) {\n             break;\n           }\n         }\n         try {\n           // We may have lost our ticket since last checkpoint, log in again, just in case\n           if (UserGroupInformation.isSecurityEnabled()) {\n             UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n           }\n           \n-          long now \u003d now();\n-          long uncheckpointed \u003d countUncheckpointedTxns();\n-          long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n+          final long now \u003d monotonicNow();\n+          final long uncheckpointed \u003d countUncheckpointedTxns();\n+          final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n           \n           boolean needCheckpoint \u003d needRollbackCheckpoint;\n           if (needCheckpoint) {\n             LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n           } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n             LOG.info(\"Triggering checkpoint because there have been \" + \n                 uncheckpointed + \" txns since the last checkpoint, which \" +\n                 \"exceeds the configured threshold \" +\n                 checkpointConf.getTxnCount());\n             needCheckpoint \u003d true;\n           } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n             LOG.info(\"Triggering checkpoint because it has been \" +\n                 secsSinceLast + \" seconds since the last checkpoint, which \" +\n                 \"exceeds the configured interval \" + checkpointConf.getPeriod());\n             needCheckpoint \u003d true;\n           }\n           \n           synchronized (cancelLock) {\n             if (now \u003c preventCheckpointsUntil) {\n               LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n               canceledCount++;\n               continue;\n             }\n             assert canceler \u003d\u003d null;\n             canceler \u003d new Canceler();\n           }\n           \n           if (needCheckpoint) {\n             doCheckpoint();\n             // reset needRollbackCheckpoint to false only when we finish a ckpt\n             // for rollback image\n             if (needRollbackCheckpoint\n                 \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n               namesystem.setCreatedRollbackImages(true);\n               namesystem.setNeedRollbackFsImage(false);\n             }\n             lastCheckpointTime \u003d now;\n           }\n         } catch (SaveNamespaceCancelledException ce) {\n           LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n           canceledCount++;\n         } catch (InterruptedException ie) {\n           LOG.info(\"Interrupted during checkpointing\", ie);\n           // Probably requested shutdown.\n           continue;\n         } catch (Throwable t) {\n           LOG.error(\"Exception in doCheckpoint\", t);\n         } finally {\n           synchronized (cancelLock) {\n             canceler \u003d null;\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d monotonicNow();\n      while (shouldRun) {\n        boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n        if (!needRollbackCheckpoint) {\n          try {\n            Thread.sleep(checkPeriod);\n          } catch (InterruptedException ie) {\n          }\n          if (!shouldRun) {\n            break;\n          }\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n          }\n          \n          final long now \u003d monotonicNow();\n          final long uncheckpointed \u003d countUncheckpointedTxns();\n          final long secsSinceLast \u003d (now - lastCheckpointTime) / 1000;\n          \n          boolean needCheckpoint \u003d needRollbackCheckpoint;\n          if (needCheckpoint) {\n            LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n          } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been \" + \n                uncheckpointed + \" txns since the last checkpoint, which \" +\n                \"exceeds the configured threshold \" +\n                checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been \" +\n                secsSinceLast + \" seconds since the last checkpoint, which \" +\n                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n          \n          synchronized (cancelLock) {\n            if (now \u003c preventCheckpointsUntil) {\n              LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n              canceledCount++;\n              continue;\n            }\n            assert canceler \u003d\u003d null;\n            canceler \u003d new Canceler();\n          }\n          \n          if (needCheckpoint) {\n            doCheckpoint();\n            // reset needRollbackCheckpoint to false only when we finish a ckpt\n            // for rollback image\n            if (needRollbackCheckpoint\n                \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n              namesystem.setCreatedRollbackImages(true);\n              namesystem.setNeedRollbackFsImage(false);\n            }\n            lastCheckpointTime \u003d now;\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          LOG.info(\"Interrupted during checkpointing\", ie);\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        } finally {\n          synchronized (cancelLock) {\n            canceler \u003d null;\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "dedcc09e717fa810260ecf83a4abca746dbedd49": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6019. Standby NN might not checkpoint when processing the rolling upgrade marker. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1572182 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/02/14 10:20 AM",
      "commitName": "dedcc09e717fa810260ecf83a4abca746dbedd49",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "25/02/14 1:58 PM",
      "commitNameOld": "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.85,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,79 @@\n     private void doWork() {\n       final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n       // Reset checkpoint time so that we don\u0027t always checkpoint\n       // on startup.\n       lastCheckpointTime \u003d now();\n       while (shouldRun) {\n+        boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n         if (!needRollbackCheckpoint) {\n           try {\n             Thread.sleep(checkPeriod);\n           } catch (InterruptedException ie) {\n           }\n           if (!shouldRun) {\n             break;\n           }\n         }\n         try {\n           // We may have lost our ticket since last checkpoint, log in again, just in case\n           if (UserGroupInformation.isSecurityEnabled()) {\n             UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n           }\n           \n           long now \u003d now();\n           long uncheckpointed \u003d countUncheckpointedTxns();\n           long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n           \n           boolean needCheckpoint \u003d needRollbackCheckpoint;\n           if (needCheckpoint) {\n             LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n           } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n             LOG.info(\"Triggering checkpoint because there have been \" + \n                 uncheckpointed + \" txns since the last checkpoint, which \" +\n                 \"exceeds the configured threshold \" +\n                 checkpointConf.getTxnCount());\n             needCheckpoint \u003d true;\n           } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n             LOG.info(\"Triggering checkpoint because it has been \" +\n                 secsSinceLast + \" seconds since the last checkpoint, which \" +\n                 \"exceeds the configured interval \" + checkpointConf.getPeriod());\n             needCheckpoint \u003d true;\n           }\n           \n           synchronized (cancelLock) {\n             if (now \u003c preventCheckpointsUntil) {\n               LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n               canceledCount++;\n               continue;\n             }\n             assert canceler \u003d\u003d null;\n             canceler \u003d new Canceler();\n           }\n           \n           if (needCheckpoint) {\n             doCheckpoint();\n             // reset needRollbackCheckpoint to false only when we finish a ckpt\n             // for rollback image\n             if (needRollbackCheckpoint\n                 \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n               namesystem.setCreatedRollbackImages(true);\n-              needRollbackCheckpoint \u003d false;\n+              namesystem.setNeedRollbackFsImage(false);\n             }\n             lastCheckpointTime \u003d now;\n           }\n         } catch (SaveNamespaceCancelledException ce) {\n           LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n           canceledCount++;\n         } catch (InterruptedException ie) {\n           LOG.info(\"Interrupted during checkpointing\", ie);\n           // Probably requested shutdown.\n           continue;\n         } catch (Throwable t) {\n           LOG.error(\"Exception in doCheckpoint\", t);\n         } finally {\n           synchronized (cancelLock) {\n             canceler \u003d null;\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d now();\n      while (shouldRun) {\n        boolean needRollbackCheckpoint \u003d namesystem.isNeedRollbackFsImage();\n        if (!needRollbackCheckpoint) {\n          try {\n            Thread.sleep(checkPeriod);\n          } catch (InterruptedException ie) {\n          }\n          if (!shouldRun) {\n            break;\n          }\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n          }\n          \n          long now \u003d now();\n          long uncheckpointed \u003d countUncheckpointedTxns();\n          long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n          \n          boolean needCheckpoint \u003d needRollbackCheckpoint;\n          if (needCheckpoint) {\n            LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n          } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been \" + \n                uncheckpointed + \" txns since the last checkpoint, which \" +\n                \"exceeds the configured threshold \" +\n                checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been \" +\n                secsSinceLast + \" seconds since the last checkpoint, which \" +\n                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n          \n          synchronized (cancelLock) {\n            if (now \u003c preventCheckpointsUntil) {\n              LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n              canceledCount++;\n              continue;\n            }\n            assert canceler \u003d\u003d null;\n            canceler \u003d new Canceler();\n          }\n          \n          if (needCheckpoint) {\n            doCheckpoint();\n            // reset needRollbackCheckpoint to false only when we finish a ckpt\n            // for rollback image\n            if (needRollbackCheckpoint\n                \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n              namesystem.setCreatedRollbackImages(true);\n              namesystem.setNeedRollbackFsImage(false);\n            }\n            lastCheckpointTime \u003d now;\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          LOG.info(\"Interrupted during checkpointing\", ie);\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        } finally {\n          synchronized (cancelLock) {\n            canceler \u003d null;\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6000. Avoid saving namespace when starting rolling upgrade. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1571840 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/14 1:58 PM",
      "commitName": "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/02/14 12:04 AM",
      "commitNameOld": "4f9bbaa301194e3d20972a10f51638c7f4d121f0",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 12.58,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,78 @@\n     private void doWork() {\n+      final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n       // Reset checkpoint time so that we don\u0027t always checkpoint\n       // on startup.\n       lastCheckpointTime \u003d now();\n       while (shouldRun) {\n-        try {\n-          Thread.sleep(1000 * checkpointConf.getCheckPeriod());\n-        } catch (InterruptedException ie) {\n-        }\n-        if (!shouldRun) {\n-          break;\n+        if (!needRollbackCheckpoint) {\n+          try {\n+            Thread.sleep(checkPeriod);\n+          } catch (InterruptedException ie) {\n+          }\n+          if (!shouldRun) {\n+            break;\n+          }\n         }\n         try {\n           // We may have lost our ticket since last checkpoint, log in again, just in case\n           if (UserGroupInformation.isSecurityEnabled()) {\n             UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n           }\n           \n           long now \u003d now();\n           long uncheckpointed \u003d countUncheckpointedTxns();\n           long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n           \n-          boolean needCheckpoint \u003d false;\n-          if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n+          boolean needCheckpoint \u003d needRollbackCheckpoint;\n+          if (needCheckpoint) {\n+            LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n+          } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n             LOG.info(\"Triggering checkpoint because there have been \" + \n                 uncheckpointed + \" txns since the last checkpoint, which \" +\n                 \"exceeds the configured threshold \" +\n                 checkpointConf.getTxnCount());\n             needCheckpoint \u003d true;\n           } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n             LOG.info(\"Triggering checkpoint because it has been \" +\n                 secsSinceLast + \" seconds since the last checkpoint, which \" +\n                 \"exceeds the configured interval \" + checkpointConf.getPeriod());\n             needCheckpoint \u003d true;\n           }\n           \n           synchronized (cancelLock) {\n             if (now \u003c preventCheckpointsUntil) {\n               LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n               canceledCount++;\n               continue;\n             }\n             assert canceler \u003d\u003d null;\n             canceler \u003d new Canceler();\n           }\n           \n           if (needCheckpoint) {\n             doCheckpoint();\n+            // reset needRollbackCheckpoint to false only when we finish a ckpt\n+            // for rollback image\n+            if (needRollbackCheckpoint\n+                \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n+              namesystem.setCreatedRollbackImages(true);\n+              needRollbackCheckpoint \u003d false;\n+            }\n             lastCheckpointTime \u003d now;\n           }\n         } catch (SaveNamespaceCancelledException ce) {\n           LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n           canceledCount++;\n         } catch (InterruptedException ie) {\n           LOG.info(\"Interrupted during checkpointing\", ie);\n           // Probably requested shutdown.\n           continue;\n         } catch (Throwable t) {\n           LOG.error(\"Exception in doCheckpoint\", t);\n         } finally {\n           synchronized (cancelLock) {\n             canceler \u003d null;\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      final long checkPeriod \u003d 1000 * checkpointConf.getCheckPeriod();\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d now();\n      while (shouldRun) {\n        if (!needRollbackCheckpoint) {\n          try {\n            Thread.sleep(checkPeriod);\n          } catch (InterruptedException ie) {\n          }\n          if (!shouldRun) {\n            break;\n          }\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n          }\n          \n          long now \u003d now();\n          long uncheckpointed \u003d countUncheckpointedTxns();\n          long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n          \n          boolean needCheckpoint \u003d needRollbackCheckpoint;\n          if (needCheckpoint) {\n            LOG.info(\"Triggering a rollback fsimage for rolling upgrade.\");\n          } else if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been \" + \n                uncheckpointed + \" txns since the last checkpoint, which \" +\n                \"exceeds the configured threshold \" +\n                checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been \" +\n                secsSinceLast + \" seconds since the last checkpoint, which \" +\n                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n          \n          synchronized (cancelLock) {\n            if (now \u003c preventCheckpointsUntil) {\n              LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n              canceledCount++;\n              continue;\n            }\n            assert canceler \u003d\u003d null;\n            canceler \u003d new Canceler();\n          }\n          \n          if (needCheckpoint) {\n            doCheckpoint();\n            // reset needRollbackCheckpoint to false only when we finish a ckpt\n            // for rollback image\n            if (needRollbackCheckpoint\n                \u0026\u0026 namesystem.getFSImage().hasRollbackFSImage()) {\n              namesystem.setCreatedRollbackImages(true);\n              needRollbackCheckpoint \u003d false;\n            }\n            lastCheckpointTime \u003d now;\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          LOG.info(\"Interrupted during checkpointing\", ie);\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        } finally {\n          synchronized (cancelLock) {\n            canceler \u003d null;\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "49a892056df7d73207f7a65ae5b4b905ba5e6ab8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4816. transitionToActive blocks if the SBN is doing checkpoint image transfer. (Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1514095 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/13 4:32 PM",
      "commitName": "49a892056df7d73207f7a65ae5b4b905ba5e6ab8",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "28/05/13 8:47 AM",
      "commitNameOld": "45b9d19f9d2b14e4d3c386af9de3df817da3c9df",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 78.32,
      "commitsBetweenForRepo": 510,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,66 @@\n     private void doWork() {\n       // Reset checkpoint time so that we don\u0027t always checkpoint\n       // on startup.\n       lastCheckpointTime \u003d now();\n       while (shouldRun) {\n         try {\n           Thread.sleep(1000 * checkpointConf.getCheckPeriod());\n         } catch (InterruptedException ie) {\n         }\n         if (!shouldRun) {\n           break;\n         }\n         try {\n           // We may have lost our ticket since last checkpoint, log in again, just in case\n           if (UserGroupInformation.isSecurityEnabled()) {\n             UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n           }\n           \n           long now \u003d now();\n           long uncheckpointed \u003d countUncheckpointedTxns();\n           long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n           \n           boolean needCheckpoint \u003d false;\n           if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n             LOG.info(\"Triggering checkpoint because there have been \" + \n                 uncheckpointed + \" txns since the last checkpoint, which \" +\n                 \"exceeds the configured threshold \" +\n                 checkpointConf.getTxnCount());\n             needCheckpoint \u003d true;\n           } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n             LOG.info(\"Triggering checkpoint because it has been \" +\n                 secsSinceLast + \" seconds since the last checkpoint, which \" +\n                 \"exceeds the configured interval \" + checkpointConf.getPeriod());\n             needCheckpoint \u003d true;\n           }\n           \n           synchronized (cancelLock) {\n             if (now \u003c preventCheckpointsUntil) {\n               LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n               canceledCount++;\n               continue;\n             }\n             assert canceler \u003d\u003d null;\n             canceler \u003d new Canceler();\n           }\n           \n           if (needCheckpoint) {\n             doCheckpoint();\n             lastCheckpointTime \u003d now;\n           }\n         } catch (SaveNamespaceCancelledException ce) {\n           LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n           canceledCount++;\n         } catch (InterruptedException ie) {\n+          LOG.info(\"Interrupted during checkpointing\", ie);\n           // Probably requested shutdown.\n           continue;\n         } catch (Throwable t) {\n           LOG.error(\"Exception in doCheckpoint\", t);\n         } finally {\n           synchronized (cancelLock) {\n             canceler \u003d null;\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d now();\n      while (shouldRun) {\n        try {\n          Thread.sleep(1000 * checkpointConf.getCheckPeriod());\n        } catch (InterruptedException ie) {\n        }\n        if (!shouldRun) {\n          break;\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n          }\n          \n          long now \u003d now();\n          long uncheckpointed \u003d countUncheckpointedTxns();\n          long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n          \n          boolean needCheckpoint \u003d false;\n          if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been \" + \n                uncheckpointed + \" txns since the last checkpoint, which \" +\n                \"exceeds the configured threshold \" +\n                checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been \" +\n                secsSinceLast + \" seconds since the last checkpoint, which \" +\n                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n          \n          synchronized (cancelLock) {\n            if (now \u003c preventCheckpointsUntil) {\n              LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n              canceledCount++;\n              continue;\n            }\n            assert canceler \u003d\u003d null;\n            canceler \u003d new Canceler();\n          }\n          \n          if (needCheckpoint) {\n            doCheckpoint();\n            lastCheckpointTime \u003d now;\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          LOG.info(\"Interrupted during checkpointing\", ie);\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        } finally {\n          synchronized (cancelLock) {\n            canceler \u003d null;\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "45b9d19f9d2b14e4d3c386af9de3df817da3c9df": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4780. Use the correct relogin method for services. Contributed by Robert Parker.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1486974 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/05/13 8:47 AM",
      "commitName": "45b9d19f9d2b14e4d3c386af9de3df817da3c9df",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "12/07/12 12:01 PM",
      "commitNameOld": "4a5ba3b7bd2360fd9605863630b477d362874e1e",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 319.87,
      "commitsBetweenForRepo": 1803,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n     private void doWork() {\n       // Reset checkpoint time so that we don\u0027t always checkpoint\n       // on startup.\n       lastCheckpointTime \u003d now();\n       while (shouldRun) {\n         try {\n           Thread.sleep(1000 * checkpointConf.getCheckPeriod());\n         } catch (InterruptedException ie) {\n         }\n         if (!shouldRun) {\n           break;\n         }\n         try {\n           // We may have lost our ticket since last checkpoint, log in again, just in case\n           if (UserGroupInformation.isSecurityEnabled()) {\n-            UserGroupInformation.getCurrentUser().reloginFromKeytab();\n+            UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n           }\n           \n           long now \u003d now();\n           long uncheckpointed \u003d countUncheckpointedTxns();\n           long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n           \n           boolean needCheckpoint \u003d false;\n           if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n             LOG.info(\"Triggering checkpoint because there have been \" + \n                 uncheckpointed + \" txns since the last checkpoint, which \" +\n                 \"exceeds the configured threshold \" +\n                 checkpointConf.getTxnCount());\n             needCheckpoint \u003d true;\n           } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n             LOG.info(\"Triggering checkpoint because it has been \" +\n                 secsSinceLast + \" seconds since the last checkpoint, which \" +\n                 \"exceeds the configured interval \" + checkpointConf.getPeriod());\n             needCheckpoint \u003d true;\n           }\n           \n           synchronized (cancelLock) {\n             if (now \u003c preventCheckpointsUntil) {\n               LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n               canceledCount++;\n               continue;\n             }\n             assert canceler \u003d\u003d null;\n             canceler \u003d new Canceler();\n           }\n           \n           if (needCheckpoint) {\n             doCheckpoint();\n             lastCheckpointTime \u003d now;\n           }\n         } catch (SaveNamespaceCancelledException ce) {\n           LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n           canceledCount++;\n         } catch (InterruptedException ie) {\n           // Probably requested shutdown.\n           continue;\n         } catch (Throwable t) {\n           LOG.error(\"Exception in doCheckpoint\", t);\n         } finally {\n           synchronized (cancelLock) {\n             canceler \u003d null;\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d now();\n      while (shouldRun) {\n        try {\n          Thread.sleep(1000 * checkpointConf.getCheckPeriod());\n        } catch (InterruptedException ie) {\n        }\n        if (!shouldRun) {\n          break;\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n          }\n          \n          long now \u003d now();\n          long uncheckpointed \u003d countUncheckpointedTxns();\n          long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n          \n          boolean needCheckpoint \u003d false;\n          if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been \" + \n                uncheckpointed + \" txns since the last checkpoint, which \" +\n                \"exceeds the configured threshold \" +\n                checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been \" +\n                secsSinceLast + \" seconds since the last checkpoint, which \" +\n                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n          \n          synchronized (cancelLock) {\n            if (now \u003c preventCheckpointsUntil) {\n              LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n              canceledCount++;\n              continue;\n            }\n            assert canceler \u003d\u003d null;\n            canceler \u003d new Canceler();\n          }\n          \n          if (needCheckpoint) {\n            doCheckpoint();\n            lastCheckpointTime \u003d now;\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        } finally {\n          synchronized (cancelLock) {\n            canceler \u003d null;\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "15ddb6634f8bdab37ce43f99f8338d84422c7232": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2800. Fix cancellation of checkpoints in the standby node to be more reliable. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1339745 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/05/12 10:49 AM",
      "commitName": "15ddb6634f8bdab37ce43f99f8338d84422c7232",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "12/05/12 7:51 PM",
      "commitNameOld": "f22341ab1a9060a727abb0924a4cd996b2bd7fe7",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 4.62,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,65 @@\n     private void doWork() {\n       // Reset checkpoint time so that we don\u0027t always checkpoint\n       // on startup.\n       lastCheckpointTime \u003d now();\n       while (shouldRun) {\n         try {\n           Thread.sleep(1000 * checkpointConf.getCheckPeriod());\n         } catch (InterruptedException ie) {\n         }\n         if (!shouldRun) {\n           break;\n         }\n         try {\n           // We may have lost our ticket since last checkpoint, log in again, just in case\n           if (UserGroupInformation.isSecurityEnabled()) {\n             UserGroupInformation.getCurrentUser().reloginFromKeytab();\n           }\n           \n           long now \u003d now();\n           long uncheckpointed \u003d countUncheckpointedTxns();\n           long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n           \n           boolean needCheckpoint \u003d false;\n           if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n             LOG.info(\"Triggering checkpoint because there have been \" + \n                 uncheckpointed + \" txns since the last checkpoint, which \" +\n                 \"exceeds the configured threshold \" +\n                 checkpointConf.getTxnCount());\n             needCheckpoint \u003d true;\n           } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n             LOG.info(\"Triggering checkpoint because it has been \" +\n                 secsSinceLast + \" seconds since the last checkpoint, which \" +\n                 \"exceeds the configured interval \" + checkpointConf.getPeriod());\n             needCheckpoint \u003d true;\n           }\n-          if (needCheckpoint \u0026\u0026 now \u003c preventCheckpointsUntil) {\n-            LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n-            canceledCount++;\n-          } else if (needCheckpoint) {\n+          \n+          synchronized (cancelLock) {\n+            if (now \u003c preventCheckpointsUntil) {\n+              LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n+              canceledCount++;\n+              continue;\n+            }\n+            assert canceler \u003d\u003d null;\n+            canceler \u003d new Canceler();\n+          }\n+          \n+          if (needCheckpoint) {\n             doCheckpoint();\n             lastCheckpointTime \u003d now;\n           }\n         } catch (SaveNamespaceCancelledException ce) {\n           LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n           canceledCount++;\n         } catch (InterruptedException ie) {\n           // Probably requested shutdown.\n           continue;\n         } catch (Throwable t) {\n           LOG.error(\"Exception in doCheckpoint\", t);\n+        } finally {\n+          synchronized (cancelLock) {\n+            canceler \u003d null;\n+          }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d now();\n      while (shouldRun) {\n        try {\n          Thread.sleep(1000 * checkpointConf.getCheckPeriod());\n        } catch (InterruptedException ie) {\n        }\n        if (!shouldRun) {\n          break;\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().reloginFromKeytab();\n          }\n          \n          long now \u003d now();\n          long uncheckpointed \u003d countUncheckpointedTxns();\n          long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n          \n          boolean needCheckpoint \u003d false;\n          if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been \" + \n                uncheckpointed + \" txns since the last checkpoint, which \" +\n                \"exceeds the configured threshold \" +\n                checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been \" +\n                secsSinceLast + \" seconds since the last checkpoint, which \" +\n                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n          \n          synchronized (cancelLock) {\n            if (now \u003c preventCheckpointsUntil) {\n              LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n              canceledCount++;\n              continue;\n            }\n            assert canceler \u003d\u003d null;\n            canceler \u003d new Canceler();\n          }\n          \n          if (needCheckpoint) {\n            doCheckpoint();\n            lastCheckpointTime \u003d now;\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        } finally {\n          synchronized (cancelLock) {\n            canceler \u003d null;\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java",
      "extendedDetails": {}
    },
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2291. Allow the StandbyNode to make checkpoints in an HA setup. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1227411 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/01/12 4:22 PM",
      "commitName": "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,53 @@\n+    private void doWork() {\n+      // Reset checkpoint time so that we don\u0027t always checkpoint\n+      // on startup.\n+      lastCheckpointTime \u003d now();\n+      while (shouldRun) {\n+        try {\n+          Thread.sleep(1000 * checkpointConf.getCheckPeriod());\n+        } catch (InterruptedException ie) {\n+        }\n+        if (!shouldRun) {\n+          break;\n+        }\n+        try {\n+          // We may have lost our ticket since last checkpoint, log in again, just in case\n+          if (UserGroupInformation.isSecurityEnabled()) {\n+            UserGroupInformation.getCurrentUser().reloginFromKeytab();\n+          }\n+          \n+          long now \u003d now();\n+          long uncheckpointed \u003d countUncheckpointedTxns();\n+          long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n+          \n+          boolean needCheckpoint \u003d false;\n+          if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n+            LOG.info(\"Triggering checkpoint because there have been \" + \n+                uncheckpointed + \" txns since the last checkpoint, which \" +\n+                \"exceeds the configured threshold \" +\n+                checkpointConf.getTxnCount());\n+            needCheckpoint \u003d true;\n+          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n+            LOG.info(\"Triggering checkpoint because it has been \" +\n+                secsSinceLast + \" seconds since the last checkpoint, which \" +\n+                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n+            needCheckpoint \u003d true;\n+          }\n+          if (needCheckpoint \u0026\u0026 now \u003c preventCheckpointsUntil) {\n+            LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n+            canceledCount++;\n+          } else if (needCheckpoint) {\n+            doCheckpoint();\n+            lastCheckpointTime \u003d now;\n+          }\n+        } catch (SaveNamespaceCancelledException ce) {\n+          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n+          canceledCount++;\n+        } catch (InterruptedException ie) {\n+          // Probably requested shutdown.\n+          continue;\n+        } catch (Throwable t) {\n+          LOG.error(\"Exception in doCheckpoint\", t);\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void doWork() {\n      // Reset checkpoint time so that we don\u0027t always checkpoint\n      // on startup.\n      lastCheckpointTime \u003d now();\n      while (shouldRun) {\n        try {\n          Thread.sleep(1000 * checkpointConf.getCheckPeriod());\n        } catch (InterruptedException ie) {\n        }\n        if (!shouldRun) {\n          break;\n        }\n        try {\n          // We may have lost our ticket since last checkpoint, log in again, just in case\n          if (UserGroupInformation.isSecurityEnabled()) {\n            UserGroupInformation.getCurrentUser().reloginFromKeytab();\n          }\n          \n          long now \u003d now();\n          long uncheckpointed \u003d countUncheckpointedTxns();\n          long secsSinceLast \u003d (now - lastCheckpointTime)/1000;\n          \n          boolean needCheckpoint \u003d false;\n          if (uncheckpointed \u003e\u003d checkpointConf.getTxnCount()) {\n            LOG.info(\"Triggering checkpoint because there have been \" + \n                uncheckpointed + \" txns since the last checkpoint, which \" +\n                \"exceeds the configured threshold \" +\n                checkpointConf.getTxnCount());\n            needCheckpoint \u003d true;\n          } else if (secsSinceLast \u003e\u003d checkpointConf.getPeriod()) {\n            LOG.info(\"Triggering checkpoint because it has been \" +\n                secsSinceLast + \" seconds since the last checkpoint, which \" +\n                \"exceeds the configured interval \" + checkpointConf.getPeriod());\n            needCheckpoint \u003d true;\n          }\n          if (needCheckpoint \u0026\u0026 now \u003c preventCheckpointsUntil) {\n            LOG.info(\"But skipping this checkpoint since we are about to failover!\");\n            canceledCount++;\n          } else if (needCheckpoint) {\n            doCheckpoint();\n            lastCheckpointTime \u003d now;\n          }\n        } catch (SaveNamespaceCancelledException ce) {\n          LOG.info(\"Checkpoint was cancelled: \" + ce.getMessage());\n          canceledCount++;\n        } catch (InterruptedException ie) {\n          // Probably requested shutdown.\n          continue;\n        } catch (Throwable t) {\n          LOG.error(\"Exception in doCheckpoint\", t);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/StandbyCheckpointer.java"
    }
  }
}