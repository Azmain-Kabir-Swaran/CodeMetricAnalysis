{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FsVolumeImpl.java",
  "functionName": "compileReport",
  "functionId": "compileReport___bpFinalizedDir-File__dir-File__report-Collection__ScanInfo____reportCompiler-ReportCompiler",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
  "functionStartLine": 1352,
  "functionEndLine": 1418,
  "numCommitsSeen": 201,
  "timeTaken": 15813,
  "changeHistory": [
    "71ecd2e41129670b2aecdfd859b8110806b95281",
    "73c660b43f3d5311947d2acc9488f17c1caf4de0",
    "6eba79232f36b36e0196163adc8fe4219a6b6bf9",
    "603f3ef1386048111940b66f3a0750ab84d0588f",
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
    "1b5cceaffbdde50a87ede81552dc380832db8e79",
    "b9522e86a55564c2ccb5ca3f1ca871965cbe74de",
    "96b12662ea76e3ded4ef13944fc8df206cfb4613",
    "654cd1d0c0427c23e73804fc9d87208f76bbf6aa",
    "f67149ab08bb49381def6c535ab4c4610e0a4221",
    "7a3c381b39887a02e944fa98287afd0eb4db3560",
    "430b5371883e22abb65f37c3e3d4afc3f421fc89",
    "4f75b15628a76881efc39054612dc128e23d27be",
    "f0c980abed3843923e0eb16b626fa27334195eda",
    "662b1887af4e39f3eadd7dda4953c7f2529b43bc",
    "b6ffb08a467f1b5bc89e5114c462c3117b337be6",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "71ecd2e41129670b2aecdfd859b8110806b95281": "Ybodychange",
    "73c660b43f3d5311947d2acc9488f17c1caf4de0": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "6eba79232f36b36e0196163adc8fe4219a6b6bf9": "Ybodychange",
    "603f3ef1386048111940b66f3a0750ab84d0588f": "Ybodychange",
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389": "Ybodychange",
    "1b5cceaffbdde50a87ede81552dc380832db8e79": "Ybodychange",
    "b9522e86a55564c2ccb5ca3f1ca871965cbe74de": "Ybodychange",
    "96b12662ea76e3ded4ef13944fc8df206cfb4613": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
    "654cd1d0c0427c23e73804fc9d87208f76bbf6aa": "Ybodychange",
    "f67149ab08bb49381def6c535ab4c4610e0a4221": "Ybodychange",
    "7a3c381b39887a02e944fa98287afd0eb4db3560": "Ymultichange(Yexceptionschange,Ybodychange)",
    "430b5371883e22abb65f37c3e3d4afc3f421fc89": "Ybodychange",
    "4f75b15628a76881efc39054612dc128e23d27be": "Ybodychange",
    "f0c980abed3843923e0eb16b626fa27334195eda": "Ymultichange(Yparameterchange,Ybodychange)",
    "662b1887af4e39f3eadd7dda4953c7f2529b43bc": "Yparameterchange",
    "b6ffb08a467f1b5bc89e5114c462c3117b337be6": "Yparameterchange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "71ecd2e41129670b2aecdfd859b8110806b95281": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14303. check block directory logic not correct when there is only meta file, print no meaning warn log. Contributed by qiang Liu.\n",
      "commitDate": "19/06/19 10:27 AM",
      "commitName": "71ecd2e41129670b2aecdfd859b8110806b95281",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "18/06/19 12:35 AM",
      "commitNameOld": "335c1c9938147a464f893f5368c1851c6c0becc6",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 1.41,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,67 @@\n   private void compileReport(File bpFinalizedDir, File dir,\n       Collection\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n       throws InterruptedException {\n \n     reportCompiler.throttle();\n \n     List \u003cString\u003e fileNames;\n     try {\n       fileNames \u003d\n           fileIoProvider.listDirectory(this, dir, BlockDirFilter.INSTANCE);\n     } catch (IOException ioe) {\n       LOG.warn(\"Exception occurred while compiling report\", ioe);\n       // Volume error check moved to FileIoProvider.\n       // Ignore this directory and proceed.\n       return;\n     }\n     Collections.sort(fileNames);\n \n     /*\n      * Assumption: In the sorted list of files block file appears immediately\n      * before block metadata file. This is true for the current naming\n      * convention for block file blk_\u003cblockid\u003e and meta file\n      * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n      */\n     for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n       // Make sure this thread can make a timely exit. With a low throttle\n       // rate, completing a run can take a looooong time.\n       if (Thread.interrupted()) {\n         throw new InterruptedException();\n       }\n \n       File file \u003d new File(dir, fileNames.get(i));\n       if (file.isDirectory()) {\n         compileReport(bpFinalizedDir, file, report, reportCompiler);\n         continue;\n       }\n       if (!Block.isBlockFilename(file)) {\n         if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n           long blockId \u003d Block.getBlockId(file.getName());\n-          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n+          verifyFileLocation(file, bpFinalizedDir,\n               blockId);\n           report.add(new ScanInfo(blockId, null, file, this));\n         }\n         continue;\n       }\n       File blockFile \u003d file;\n       long blockId \u003d Block.filename2id(file.getName());\n       File metaFile \u003d null;\n \n       // Skip all the files that start with block name until\n       // getting to the metafile for the block\n       while (i + 1 \u003c fileNames.size()) {\n         File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n         if (!(blkMetaFile.isFile()\n             \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n           break;\n         }\n         i++;\n         if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n           metaFile \u003d blkMetaFile;\n           break;\n         }\n       }\n       verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n       report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void compileReport(File bpFinalizedDir, File dir,\n      Collection\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n      throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d\n          fileIoProvider.listDirectory(this, dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occurred while compiling report\", ioe);\n      // Volume error check moved to FileIoProvider.\n      // Ignore this directory and proceed.\n      return;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file, bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
      "extendedDetails": {}
    },
    "73c660b43f3d5311947d2acc9488f17c1caf4de0": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-13958. Miscellaneous Improvements for FsVolumeSpi. Contributed by BELUGA BEHR.\n",
      "commitDate": "05/10/18 9:32 AM",
      "commitName": "73c660b43f3d5311947d2acc9488f17c1caf4de0",
      "commitAuthor": "Inigo Goiri",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13958. Miscellaneous Improvements for FsVolumeSpi. Contributed by BELUGA BEHR.\n",
          "commitDate": "05/10/18 9:32 AM",
          "commitName": "73c660b43f3d5311947d2acc9488f17c1caf4de0",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "30/04/18 1:28 PM",
          "commitNameOld": "fc074a359c44e84dd9612be2bd772763f943eb04",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 157.84,
          "commitsBetweenForRepo": 1255,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,67 @@\n-  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n-      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n-        throws InterruptedException {\n+  private void compileReport(File bpFinalizedDir, File dir,\n+      Collection\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n+      throws InterruptedException {\n \n     reportCompiler.throttle();\n \n     List \u003cString\u003e fileNames;\n     try {\n-      fileNames \u003d fileIoProvider.listDirectory(\n-          this, dir, BlockDirFilter.INSTANCE);\n+      fileNames \u003d\n+          fileIoProvider.listDirectory(this, dir, BlockDirFilter.INSTANCE);\n     } catch (IOException ioe) {\n-      LOG.warn(\"Exception occurred while compiling report: \", ioe);\n+      LOG.warn(\"Exception occurred while compiling report\", ioe);\n       // Volume error check moved to FileIoProvider.\n       // Ignore this directory and proceed.\n-      return report;\n+      return;\n     }\n     Collections.sort(fileNames);\n \n     /*\n      * Assumption: In the sorted list of files block file appears immediately\n      * before block metadata file. This is true for the current naming\n      * convention for block file blk_\u003cblockid\u003e and meta file\n      * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n      */\n     for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n       // Make sure this thread can make a timely exit. With a low throttle\n       // rate, completing a run can take a looooong time.\n       if (Thread.interrupted()) {\n         throw new InterruptedException();\n       }\n \n       File file \u003d new File(dir, fileNames.get(i));\n       if (file.isDirectory()) {\n         compileReport(bpFinalizedDir, file, report, reportCompiler);\n         continue;\n       }\n       if (!Block.isBlockFilename(file)) {\n         if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n           long blockId \u003d Block.getBlockId(file.getName());\n           verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n               blockId);\n           report.add(new ScanInfo(blockId, null, file, this));\n         }\n         continue;\n       }\n       File blockFile \u003d file;\n       long blockId \u003d Block.filename2id(file.getName());\n       File metaFile \u003d null;\n \n       // Skip all the files that start with block name until\n       // getting to the metafile for the block\n       while (i + 1 \u003c fileNames.size()) {\n         File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n         if (!(blkMetaFile.isFile()\n             \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n           break;\n         }\n         i++;\n         if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n           metaFile \u003d blkMetaFile;\n           break;\n         }\n       }\n       verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n       report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n     }\n-    return report;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void compileReport(File bpFinalizedDir, File dir,\n      Collection\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n      throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d\n          fileIoProvider.listDirectory(this, dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occurred while compiling report\", ioe);\n      // Volume error check moved to FileIoProvider.\n      // Ignore this directory and proceed.\n      return;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
          "extendedDetails": {
            "oldValue": "[bpFinalizedDir-File, dir-File, report-LinkedList\u003cScanInfo\u003e, reportCompiler-ReportCompiler]",
            "newValue": "[bpFinalizedDir-File, dir-File, report-Collection\u003cScanInfo\u003e, reportCompiler-ReportCompiler]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-13958. Miscellaneous Improvements for FsVolumeSpi. Contributed by BELUGA BEHR.\n",
          "commitDate": "05/10/18 9:32 AM",
          "commitName": "73c660b43f3d5311947d2acc9488f17c1caf4de0",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "30/04/18 1:28 PM",
          "commitNameOld": "fc074a359c44e84dd9612be2bd772763f943eb04",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 157.84,
          "commitsBetweenForRepo": 1255,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,67 @@\n-  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n-      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n-        throws InterruptedException {\n+  private void compileReport(File bpFinalizedDir, File dir,\n+      Collection\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n+      throws InterruptedException {\n \n     reportCompiler.throttle();\n \n     List \u003cString\u003e fileNames;\n     try {\n-      fileNames \u003d fileIoProvider.listDirectory(\n-          this, dir, BlockDirFilter.INSTANCE);\n+      fileNames \u003d\n+          fileIoProvider.listDirectory(this, dir, BlockDirFilter.INSTANCE);\n     } catch (IOException ioe) {\n-      LOG.warn(\"Exception occurred while compiling report: \", ioe);\n+      LOG.warn(\"Exception occurred while compiling report\", ioe);\n       // Volume error check moved to FileIoProvider.\n       // Ignore this directory and proceed.\n-      return report;\n+      return;\n     }\n     Collections.sort(fileNames);\n \n     /*\n      * Assumption: In the sorted list of files block file appears immediately\n      * before block metadata file. This is true for the current naming\n      * convention for block file blk_\u003cblockid\u003e and meta file\n      * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n      */\n     for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n       // Make sure this thread can make a timely exit. With a low throttle\n       // rate, completing a run can take a looooong time.\n       if (Thread.interrupted()) {\n         throw new InterruptedException();\n       }\n \n       File file \u003d new File(dir, fileNames.get(i));\n       if (file.isDirectory()) {\n         compileReport(bpFinalizedDir, file, report, reportCompiler);\n         continue;\n       }\n       if (!Block.isBlockFilename(file)) {\n         if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n           long blockId \u003d Block.getBlockId(file.getName());\n           verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n               blockId);\n           report.add(new ScanInfo(blockId, null, file, this));\n         }\n         continue;\n       }\n       File blockFile \u003d file;\n       long blockId \u003d Block.filename2id(file.getName());\n       File metaFile \u003d null;\n \n       // Skip all the files that start with block name until\n       // getting to the metafile for the block\n       while (i + 1 \u003c fileNames.size()) {\n         File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n         if (!(blkMetaFile.isFile()\n             \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n           break;\n         }\n         i++;\n         if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n           metaFile \u003d blkMetaFile;\n           break;\n         }\n       }\n       verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n       report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n     }\n-    return report;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void compileReport(File bpFinalizedDir, File dir,\n      Collection\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n      throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d\n          fileIoProvider.listDirectory(this, dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occurred while compiling report\", ioe);\n      // Volume error check moved to FileIoProvider.\n      // Ignore this directory and proceed.\n      return;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
          "extendedDetails": {
            "oldValue": "LinkedList\u003cScanInfo\u003e",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13958. Miscellaneous Improvements for FsVolumeSpi. Contributed by BELUGA BEHR.\n",
          "commitDate": "05/10/18 9:32 AM",
          "commitName": "73c660b43f3d5311947d2acc9488f17c1caf4de0",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "30/04/18 1:28 PM",
          "commitNameOld": "fc074a359c44e84dd9612be2bd772763f943eb04",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 157.84,
          "commitsBetweenForRepo": 1255,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,67 @@\n-  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n-      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n-        throws InterruptedException {\n+  private void compileReport(File bpFinalizedDir, File dir,\n+      Collection\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n+      throws InterruptedException {\n \n     reportCompiler.throttle();\n \n     List \u003cString\u003e fileNames;\n     try {\n-      fileNames \u003d fileIoProvider.listDirectory(\n-          this, dir, BlockDirFilter.INSTANCE);\n+      fileNames \u003d\n+          fileIoProvider.listDirectory(this, dir, BlockDirFilter.INSTANCE);\n     } catch (IOException ioe) {\n-      LOG.warn(\"Exception occurred while compiling report: \", ioe);\n+      LOG.warn(\"Exception occurred while compiling report\", ioe);\n       // Volume error check moved to FileIoProvider.\n       // Ignore this directory and proceed.\n-      return report;\n+      return;\n     }\n     Collections.sort(fileNames);\n \n     /*\n      * Assumption: In the sorted list of files block file appears immediately\n      * before block metadata file. This is true for the current naming\n      * convention for block file blk_\u003cblockid\u003e and meta file\n      * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n      */\n     for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n       // Make sure this thread can make a timely exit. With a low throttle\n       // rate, completing a run can take a looooong time.\n       if (Thread.interrupted()) {\n         throw new InterruptedException();\n       }\n \n       File file \u003d new File(dir, fileNames.get(i));\n       if (file.isDirectory()) {\n         compileReport(bpFinalizedDir, file, report, reportCompiler);\n         continue;\n       }\n       if (!Block.isBlockFilename(file)) {\n         if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n           long blockId \u003d Block.getBlockId(file.getName());\n           verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n               blockId);\n           report.add(new ScanInfo(blockId, null, file, this));\n         }\n         continue;\n       }\n       File blockFile \u003d file;\n       long blockId \u003d Block.filename2id(file.getName());\n       File metaFile \u003d null;\n \n       // Skip all the files that start with block name until\n       // getting to the metafile for the block\n       while (i + 1 \u003c fileNames.size()) {\n         File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n         if (!(blkMetaFile.isFile()\n             \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n           break;\n         }\n         i++;\n         if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n           metaFile \u003d blkMetaFile;\n           break;\n         }\n       }\n       verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n       report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n     }\n-    return report;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void compileReport(File bpFinalizedDir, File dir,\n      Collection\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n      throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d\n          fileIoProvider.listDirectory(this, dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occurred while compiling report\", ioe);\n      // Volume error check moved to FileIoProvider.\n      // Ignore this directory and proceed.\n      return;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "6eba79232f36b36e0196163adc8fe4219a6b6bf9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14271. Correct spelling of \u0027occurred\u0027 and variants. Contributed by Yeliang Cang\n",
      "commitDate": "03/04/17 8:13 PM",
      "commitName": "6eba79232f36b36e0196163adc8fe4219a6b6bf9",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "16/01/17 1:45 PM",
      "commitNameOld": "a853b4e1b5742faadf7b667b0cebbc0dac001395",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 77.23,
      "commitsBetweenForRepo": 436,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n       File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n         throws InterruptedException {\n \n     reportCompiler.throttle();\n \n     List \u003cString\u003e fileNames;\n     try {\n       fileNames \u003d fileIoProvider.listDirectory(\n           this, dir, BlockDirFilter.INSTANCE);\n     } catch (IOException ioe) {\n-      LOG.warn(\"Exception occured while compiling report: \", ioe);\n+      LOG.warn(\"Exception occurred while compiling report: \", ioe);\n       // Volume error check moved to FileIoProvider.\n       // Ignore this directory and proceed.\n       return report;\n     }\n     Collections.sort(fileNames);\n \n     /*\n      * Assumption: In the sorted list of files block file appears immediately\n      * before block metadata file. This is true for the current naming\n      * convention for block file blk_\u003cblockid\u003e and meta file\n      * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n      */\n     for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n       // Make sure this thread can make a timely exit. With a low throttle\n       // rate, completing a run can take a looooong time.\n       if (Thread.interrupted()) {\n         throw new InterruptedException();\n       }\n \n       File file \u003d new File(dir, fileNames.get(i));\n       if (file.isDirectory()) {\n         compileReport(bpFinalizedDir, file, report, reportCompiler);\n         continue;\n       }\n       if (!Block.isBlockFilename(file)) {\n         if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n           long blockId \u003d Block.getBlockId(file.getName());\n           verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n               blockId);\n           report.add(new ScanInfo(blockId, null, file, this));\n         }\n         continue;\n       }\n       File blockFile \u003d file;\n       long blockId \u003d Block.filename2id(file.getName());\n       File metaFile \u003d null;\n \n       // Skip all the files that start with block name until\n       // getting to the metafile for the block\n       while (i + 1 \u003c fileNames.size()) {\n         File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n         if (!(blkMetaFile.isFile()\n             \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n           break;\n         }\n         i++;\n         if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n           metaFile \u003d blkMetaFile;\n           break;\n         }\n       }\n       verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n       report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n     }\n     return report;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n        throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d fileIoProvider.listDirectory(\n          this, dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occurred while compiling report: \", ioe);\n      // Volume error check moved to FileIoProvider.\n      // Ignore this directory and proceed.\n      return report;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n    return report;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
      "extendedDetails": {}
    },
    "603f3ef1386048111940b66f3a0750ab84d0588f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11274. Datanode should only check the failed volume upon IO errors. Contributed by Xiaoyu Yao.\n",
      "commitDate": "28/12/16 10:08 PM",
      "commitName": "603f3ef1386048111940b66f3a0750ab84d0588f",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "20/12/16 1:53 PM",
      "commitNameOld": "f678080dbd25a218e0406463a3c3a1fc03680702",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 8.34,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,68 @@\n   private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n       File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n         throws InterruptedException {\n \n     reportCompiler.throttle();\n \n     List \u003cString\u003e fileNames;\n     try {\n       fileNames \u003d fileIoProvider.listDirectory(\n           this, dir, BlockDirFilter.INSTANCE);\n     } catch (IOException ioe) {\n       LOG.warn(\"Exception occured while compiling report: \", ioe);\n-      // Initiate a check on disk failure.\n-      dataset.datanode.checkDiskErrorAsync();\n+      // Volume error check moved to FileIoProvider.\n       // Ignore this directory and proceed.\n       return report;\n     }\n     Collections.sort(fileNames);\n \n     /*\n      * Assumption: In the sorted list of files block file appears immediately\n      * before block metadata file. This is true for the current naming\n      * convention for block file blk_\u003cblockid\u003e and meta file\n      * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n      */\n     for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n       // Make sure this thread can make a timely exit. With a low throttle\n       // rate, completing a run can take a looooong time.\n       if (Thread.interrupted()) {\n         throw new InterruptedException();\n       }\n \n       File file \u003d new File(dir, fileNames.get(i));\n       if (file.isDirectory()) {\n         compileReport(bpFinalizedDir, file, report, reportCompiler);\n         continue;\n       }\n       if (!Block.isBlockFilename(file)) {\n         if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n           long blockId \u003d Block.getBlockId(file.getName());\n           verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n               blockId);\n           report.add(new ScanInfo(blockId, null, file, this));\n         }\n         continue;\n       }\n       File blockFile \u003d file;\n       long blockId \u003d Block.filename2id(file.getName());\n       File metaFile \u003d null;\n \n       // Skip all the files that start with block name until\n       // getting to the metafile for the block\n       while (i + 1 \u003c fileNames.size()) {\n         File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n         if (!(blkMetaFile.isFile()\n             \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n           break;\n         }\n         i++;\n         if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n           metaFile \u003d blkMetaFile;\n           break;\n         }\n       }\n       verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n       report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n     }\n     return report;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n        throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d fileIoProvider.listDirectory(\n          this, dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occured while compiling report: \", ioe);\n      // Volume error check moved to FileIoProvider.\n      // Ignore this directory and proceed.\n      return report;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n    return report;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
      "extendedDetails": {}
    },
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10958. Add instrumentation hooks around Datanode disk IO.\n",
      "commitDate": "14/12/16 11:18 AM",
      "commitName": "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "12/12/16 6:11 PM",
      "commitNameOld": "2d4731c067ff64cd88f496eac8faaf302faa2ccc",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 1.71,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,69 @@\n   private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n       File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n         throws InterruptedException {\n \n     reportCompiler.throttle();\n \n     List \u003cString\u003e fileNames;\n     try {\n-      fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n+      fileNames \u003d fileIoProvider.listDirectory(\n+          this, dir, BlockDirFilter.INSTANCE);\n     } catch (IOException ioe) {\n       LOG.warn(\"Exception occured while compiling report: \", ioe);\n       // Initiate a check on disk failure.\n       dataset.datanode.checkDiskErrorAsync();\n       // Ignore this directory and proceed.\n       return report;\n     }\n     Collections.sort(fileNames);\n \n     /*\n      * Assumption: In the sorted list of files block file appears immediately\n      * before block metadata file. This is true for the current naming\n      * convention for block file blk_\u003cblockid\u003e and meta file\n      * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n      */\n     for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n       // Make sure this thread can make a timely exit. With a low throttle\n       // rate, completing a run can take a looooong time.\n       if (Thread.interrupted()) {\n         throw new InterruptedException();\n       }\n \n       File file \u003d new File(dir, fileNames.get(i));\n       if (file.isDirectory()) {\n         compileReport(bpFinalizedDir, file, report, reportCompiler);\n         continue;\n       }\n       if (!Block.isBlockFilename(file)) {\n         if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n           long blockId \u003d Block.getBlockId(file.getName());\n           verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n               blockId);\n           report.add(new ScanInfo(blockId, null, file, this));\n         }\n         continue;\n       }\n       File blockFile \u003d file;\n       long blockId \u003d Block.filename2id(file.getName());\n       File metaFile \u003d null;\n \n       // Skip all the files that start with block name until\n       // getting to the metafile for the block\n       while (i + 1 \u003c fileNames.size()) {\n         File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n         if (!(blkMetaFile.isFile()\n             \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n           break;\n         }\n         i++;\n         if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n           metaFile \u003d blkMetaFile;\n           break;\n         }\n       }\n       verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n       report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n     }\n     return report;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n        throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d fileIoProvider.listDirectory(\n          this, dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occured while compiling report: \", ioe);\n      // Initiate a check on disk failure.\n      dataset.datanode.checkDiskErrorAsync();\n      // Ignore this directory and proceed.\n      return report;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n    return report;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
      "extendedDetails": {}
    },
    "1b5cceaffbdde50a87ede81552dc380832db8e79": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-11201. Spelling errors in the logging, help, assertions and exception messages. Contributed by Grant Sohn.\"\n\nThis reverts commit b9522e86a55564c2ccb5ca3f1ca871965cbe74de.\n",
      "commitDate": "05/12/16 10:54 AM",
      "commitName": "1b5cceaffbdde50a87ede81552dc380832db8e79",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "05/12/16 10:48 AM",
      "commitNameOld": "b9522e86a55564c2ccb5ca3f1ca871965cbe74de",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n       File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n         throws InterruptedException {\n \n     reportCompiler.throttle();\n \n     List \u003cString\u003e fileNames;\n     try {\n       fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n     } catch (IOException ioe) {\n-      LOG.warn(\"Exception occurred while compiling report: \", ioe);\n+      LOG.warn(\"Exception occured while compiling report: \", ioe);\n       // Initiate a check on disk failure.\n       dataset.datanode.checkDiskErrorAsync();\n       // Ignore this directory and proceed.\n       return report;\n     }\n     Collections.sort(fileNames);\n \n     /*\n      * Assumption: In the sorted list of files block file appears immediately\n      * before block metadata file. This is true for the current naming\n      * convention for block file blk_\u003cblockid\u003e and meta file\n      * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n      */\n     for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n       // Make sure this thread can make a timely exit. With a low throttle\n       // rate, completing a run can take a looooong time.\n       if (Thread.interrupted()) {\n         throw new InterruptedException();\n       }\n \n       File file \u003d new File(dir, fileNames.get(i));\n       if (file.isDirectory()) {\n         compileReport(bpFinalizedDir, file, report, reportCompiler);\n         continue;\n       }\n       if (!Block.isBlockFilename(file)) {\n         if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n           long blockId \u003d Block.getBlockId(file.getName());\n           verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n               blockId);\n           report.add(new ScanInfo(blockId, null, file, this));\n         }\n         continue;\n       }\n       File blockFile \u003d file;\n       long blockId \u003d Block.filename2id(file.getName());\n       File metaFile \u003d null;\n \n       // Skip all the files that start with block name until\n       // getting to the metafile for the block\n       while (i + 1 \u003c fileNames.size()) {\n         File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n         if (!(blkMetaFile.isFile()\n             \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n           break;\n         }\n         i++;\n         if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n           metaFile \u003d blkMetaFile;\n           break;\n         }\n       }\n       verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n       report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n     }\n     return report;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n        throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occured while compiling report: \", ioe);\n      // Initiate a check on disk failure.\n      dataset.datanode.checkDiskErrorAsync();\n      // Ignore this directory and proceed.\n      return report;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n    return report;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
      "extendedDetails": {}
    },
    "b9522e86a55564c2ccb5ca3f1ca871965cbe74de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11201. Spelling errors in the logging, help, assertions and exception messages. Contributed by Grant Sohn.\n",
      "commitDate": "05/12/16 10:48 AM",
      "commitName": "b9522e86a55564c2ccb5ca3f1ca871965cbe74de",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "29/11/16 8:52 PM",
      "commitNameOld": "aeecfa24f4fb6af289920cbf8830c394e66bd78e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 5.58,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n       File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n         throws InterruptedException {\n \n     reportCompiler.throttle();\n \n     List \u003cString\u003e fileNames;\n     try {\n       fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n     } catch (IOException ioe) {\n-      LOG.warn(\"Exception occured while compiling report: \", ioe);\n+      LOG.warn(\"Exception occurred while compiling report: \", ioe);\n       // Initiate a check on disk failure.\n       dataset.datanode.checkDiskErrorAsync();\n       // Ignore this directory and proceed.\n       return report;\n     }\n     Collections.sort(fileNames);\n \n     /*\n      * Assumption: In the sorted list of files block file appears immediately\n      * before block metadata file. This is true for the current naming\n      * convention for block file blk_\u003cblockid\u003e and meta file\n      * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n      */\n     for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n       // Make sure this thread can make a timely exit. With a low throttle\n       // rate, completing a run can take a looooong time.\n       if (Thread.interrupted()) {\n         throw new InterruptedException();\n       }\n \n       File file \u003d new File(dir, fileNames.get(i));\n       if (file.isDirectory()) {\n         compileReport(bpFinalizedDir, file, report, reportCompiler);\n         continue;\n       }\n       if (!Block.isBlockFilename(file)) {\n         if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n           long blockId \u003d Block.getBlockId(file.getName());\n           verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n               blockId);\n           report.add(new ScanInfo(blockId, null, file, this));\n         }\n         continue;\n       }\n       File blockFile \u003d file;\n       long blockId \u003d Block.filename2id(file.getName());\n       File metaFile \u003d null;\n \n       // Skip all the files that start with block name until\n       // getting to the metafile for the block\n       while (i + 1 \u003c fileNames.size()) {\n         File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n         if (!(blkMetaFile.isFile()\n             \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n           break;\n         }\n         i++;\n         if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n           metaFile \u003d blkMetaFile;\n           break;\n         }\n       }\n       verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n       report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n     }\n     return report;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n        throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occurred while compiling report: \", ioe);\n      // Initiate a check on disk failure.\n      dataset.datanode.checkDiskErrorAsync();\n      // Ignore this directory and proceed.\n      return report;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n    return report;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
      "extendedDetails": {}
    },
    "96b12662ea76e3ded4ef13944fc8df206cfb4613": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-10637. Modifications to remove the assumption that FsVolumes are backed by java.io.File. (Virajith Jalaparti via lei)\n",
      "commitDate": "10/10/16 3:30 PM",
      "commitName": "96b12662ea76e3ded4ef13944fc8df206cfb4613",
      "commitAuthor": "Lei Xu",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-10637. Modifications to remove the assumption that FsVolumes are backed by java.io.File. (Virajith Jalaparti via lei)\n",
          "commitDate": "10/10/16 3:30 PM",
          "commitName": "96b12662ea76e3ded4ef13944fc8df206cfb4613",
          "commitAuthor": "Lei Xu",
          "commitDateOld": "10/10/16 3:04 PM",
          "commitNameOld": "0773ffd0f8383384f8cf8599476565f78aae70c9",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,68 @@\n-    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n-        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report)\n+  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n+      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n         throws InterruptedException {\n \n-      throttle();\n+    reportCompiler.throttle();\n \n-      List \u003cString\u003e fileNames;\n-      try {\n-        fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n-      } catch (IOException ioe) {\n-        LOG.warn(\"Exception occured while compiling report: \", ioe);\n-        // Initiate a check on disk failure.\n-        datanode.checkDiskErrorAsync();\n-        // Ignore this directory and proceed.\n-        return report;\n-      }\n-      Collections.sort(fileNames);\n-\n-      /*\n-       * Assumption: In the sorted list of files block file appears immediately\n-       * before block metadata file. This is true for the current naming\n-       * convention for block file blk_\u003cblockid\u003e and meta file\n-       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n-       */\n-      for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n-        // Make sure this thread can make a timely exit. With a low throttle\n-        // rate, completing a run can take a looooong time.\n-        if (Thread.interrupted()) {\n-          throw new InterruptedException();\n-        }\n-\n-        File file \u003d new File(dir, fileNames.get(i));\n-        if (file.isDirectory()) {\n-          compileReport(vol, bpFinalizedDir, file, report);\n-          continue;\n-        }\n-        if (!Block.isBlockFilename(file)) {\n-          if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n-            long blockId \u003d Block.getBlockId(file.getName());\n-            verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n-                blockId);\n-            report.add(new ScanInfo(blockId, null, file, vol));\n-          }\n-          continue;\n-        }\n-        File blockFile \u003d file;\n-        long blockId \u003d Block.filename2id(file.getName());\n-        File metaFile \u003d null;\n-\n-        // Skip all the files that start with block name until\n-        // getting to the metafile for the block\n-        while (i + 1 \u003c fileNames.size()) {\n-          File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n-          if (!(blkMetaFile.isFile()\n-              \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n-            break;\n-          }\n-          i++;\n-          if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n-            metaFile \u003d blkMetaFile;\n-            break;\n-          }\n-        }\n-        verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n-        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n-      }\n+    List \u003cString\u003e fileNames;\n+    try {\n+      fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n+    } catch (IOException ioe) {\n+      LOG.warn(\"Exception occured while compiling report: \", ioe);\n+      // Initiate a check on disk failure.\n+      dataset.datanode.checkDiskErrorAsync();\n+      // Ignore this directory and proceed.\n       return report;\n-    }\n\\ No newline at end of file\n+    }\n+    Collections.sort(fileNames);\n+\n+    /*\n+     * Assumption: In the sorted list of files block file appears immediately\n+     * before block metadata file. This is true for the current naming\n+     * convention for block file blk_\u003cblockid\u003e and meta file\n+     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n+     */\n+    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n+      // Make sure this thread can make a timely exit. With a low throttle\n+      // rate, completing a run can take a looooong time.\n+      if (Thread.interrupted()) {\n+        throw new InterruptedException();\n+      }\n+\n+      File file \u003d new File(dir, fileNames.get(i));\n+      if (file.isDirectory()) {\n+        compileReport(bpFinalizedDir, file, report, reportCompiler);\n+        continue;\n+      }\n+      if (!Block.isBlockFilename(file)) {\n+        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n+          long blockId \u003d Block.getBlockId(file.getName());\n+          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n+              blockId);\n+          report.add(new ScanInfo(blockId, null, file, this));\n+        }\n+        continue;\n+      }\n+      File blockFile \u003d file;\n+      long blockId \u003d Block.filename2id(file.getName());\n+      File metaFile \u003d null;\n+\n+      // Skip all the files that start with block name until\n+      // getting to the metafile for the block\n+      while (i + 1 \u003c fileNames.size()) {\n+        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n+        if (!(blkMetaFile.isFile()\n+            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n+          break;\n+        }\n+        i++;\n+        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n+          metaFile \u003d blkMetaFile;\n+          break;\n+        }\n+      }\n+      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n+      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n+    }\n+    return report;\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n        throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occured while compiling report: \", ioe);\n      // Initiate a check on disk failure.\n      dataset.datanode.checkDiskErrorAsync();\n      // Ignore this directory and proceed.\n      return report;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n    return report;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
            "oldMethodName": "compileReport",
            "newMethodName": "compileReport"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10637. Modifications to remove the assumption that FsVolumes are backed by java.io.File. (Virajith Jalaparti via lei)\n",
          "commitDate": "10/10/16 3:30 PM",
          "commitName": "96b12662ea76e3ded4ef13944fc8df206cfb4613",
          "commitAuthor": "Lei Xu",
          "commitDateOld": "10/10/16 3:04 PM",
          "commitNameOld": "0773ffd0f8383384f8cf8599476565f78aae70c9",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,68 @@\n-    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n-        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report)\n+  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n+      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n         throws InterruptedException {\n \n-      throttle();\n+    reportCompiler.throttle();\n \n-      List \u003cString\u003e fileNames;\n-      try {\n-        fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n-      } catch (IOException ioe) {\n-        LOG.warn(\"Exception occured while compiling report: \", ioe);\n-        // Initiate a check on disk failure.\n-        datanode.checkDiskErrorAsync();\n-        // Ignore this directory and proceed.\n-        return report;\n-      }\n-      Collections.sort(fileNames);\n-\n-      /*\n-       * Assumption: In the sorted list of files block file appears immediately\n-       * before block metadata file. This is true for the current naming\n-       * convention for block file blk_\u003cblockid\u003e and meta file\n-       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n-       */\n-      for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n-        // Make sure this thread can make a timely exit. With a low throttle\n-        // rate, completing a run can take a looooong time.\n-        if (Thread.interrupted()) {\n-          throw new InterruptedException();\n-        }\n-\n-        File file \u003d new File(dir, fileNames.get(i));\n-        if (file.isDirectory()) {\n-          compileReport(vol, bpFinalizedDir, file, report);\n-          continue;\n-        }\n-        if (!Block.isBlockFilename(file)) {\n-          if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n-            long blockId \u003d Block.getBlockId(file.getName());\n-            verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n-                blockId);\n-            report.add(new ScanInfo(blockId, null, file, vol));\n-          }\n-          continue;\n-        }\n-        File blockFile \u003d file;\n-        long blockId \u003d Block.filename2id(file.getName());\n-        File metaFile \u003d null;\n-\n-        // Skip all the files that start with block name until\n-        // getting to the metafile for the block\n-        while (i + 1 \u003c fileNames.size()) {\n-          File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n-          if (!(blkMetaFile.isFile()\n-              \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n-            break;\n-          }\n-          i++;\n-          if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n-            metaFile \u003d blkMetaFile;\n-            break;\n-          }\n-        }\n-        verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n-        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n-      }\n+    List \u003cString\u003e fileNames;\n+    try {\n+      fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n+    } catch (IOException ioe) {\n+      LOG.warn(\"Exception occured while compiling report: \", ioe);\n+      // Initiate a check on disk failure.\n+      dataset.datanode.checkDiskErrorAsync();\n+      // Ignore this directory and proceed.\n       return report;\n-    }\n\\ No newline at end of file\n+    }\n+    Collections.sort(fileNames);\n+\n+    /*\n+     * Assumption: In the sorted list of files block file appears immediately\n+     * before block metadata file. This is true for the current naming\n+     * convention for block file blk_\u003cblockid\u003e and meta file\n+     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n+     */\n+    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n+      // Make sure this thread can make a timely exit. With a low throttle\n+      // rate, completing a run can take a looooong time.\n+      if (Thread.interrupted()) {\n+        throw new InterruptedException();\n+      }\n+\n+      File file \u003d new File(dir, fileNames.get(i));\n+      if (file.isDirectory()) {\n+        compileReport(bpFinalizedDir, file, report, reportCompiler);\n+        continue;\n+      }\n+      if (!Block.isBlockFilename(file)) {\n+        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n+          long blockId \u003d Block.getBlockId(file.getName());\n+          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n+              blockId);\n+          report.add(new ScanInfo(blockId, null, file, this));\n+        }\n+        continue;\n+      }\n+      File blockFile \u003d file;\n+      long blockId \u003d Block.filename2id(file.getName());\n+      File metaFile \u003d null;\n+\n+      // Skip all the files that start with block name until\n+      // getting to the metafile for the block\n+      while (i + 1 \u003c fileNames.size()) {\n+        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n+        if (!(blkMetaFile.isFile()\n+            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n+          break;\n+        }\n+        i++;\n+        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n+          metaFile \u003d blkMetaFile;\n+          break;\n+        }\n+      }\n+      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n+      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n+    }\n+    return report;\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n        throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occured while compiling report: \", ioe);\n      // Initiate a check on disk failure.\n      dataset.datanode.checkDiskErrorAsync();\n      // Ignore this directory and proceed.\n      return report;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n    return report;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10637. Modifications to remove the assumption that FsVolumes are backed by java.io.File. (Virajith Jalaparti via lei)\n",
          "commitDate": "10/10/16 3:30 PM",
          "commitName": "96b12662ea76e3ded4ef13944fc8df206cfb4613",
          "commitAuthor": "Lei Xu",
          "commitDateOld": "10/10/16 3:04 PM",
          "commitNameOld": "0773ffd0f8383384f8cf8599476565f78aae70c9",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,68 @@\n-    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n-        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report)\n+  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n+      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n         throws InterruptedException {\n \n-      throttle();\n+    reportCompiler.throttle();\n \n-      List \u003cString\u003e fileNames;\n-      try {\n-        fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n-      } catch (IOException ioe) {\n-        LOG.warn(\"Exception occured while compiling report: \", ioe);\n-        // Initiate a check on disk failure.\n-        datanode.checkDiskErrorAsync();\n-        // Ignore this directory and proceed.\n-        return report;\n-      }\n-      Collections.sort(fileNames);\n-\n-      /*\n-       * Assumption: In the sorted list of files block file appears immediately\n-       * before block metadata file. This is true for the current naming\n-       * convention for block file blk_\u003cblockid\u003e and meta file\n-       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n-       */\n-      for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n-        // Make sure this thread can make a timely exit. With a low throttle\n-        // rate, completing a run can take a looooong time.\n-        if (Thread.interrupted()) {\n-          throw new InterruptedException();\n-        }\n-\n-        File file \u003d new File(dir, fileNames.get(i));\n-        if (file.isDirectory()) {\n-          compileReport(vol, bpFinalizedDir, file, report);\n-          continue;\n-        }\n-        if (!Block.isBlockFilename(file)) {\n-          if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n-            long blockId \u003d Block.getBlockId(file.getName());\n-            verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n-                blockId);\n-            report.add(new ScanInfo(blockId, null, file, vol));\n-          }\n-          continue;\n-        }\n-        File blockFile \u003d file;\n-        long blockId \u003d Block.filename2id(file.getName());\n-        File metaFile \u003d null;\n-\n-        // Skip all the files that start with block name until\n-        // getting to the metafile for the block\n-        while (i + 1 \u003c fileNames.size()) {\n-          File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n-          if (!(blkMetaFile.isFile()\n-              \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n-            break;\n-          }\n-          i++;\n-          if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n-            metaFile \u003d blkMetaFile;\n-            break;\n-          }\n-        }\n-        verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n-        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n-      }\n+    List \u003cString\u003e fileNames;\n+    try {\n+      fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n+    } catch (IOException ioe) {\n+      LOG.warn(\"Exception occured while compiling report: \", ioe);\n+      // Initiate a check on disk failure.\n+      dataset.datanode.checkDiskErrorAsync();\n+      // Ignore this directory and proceed.\n       return report;\n-    }\n\\ No newline at end of file\n+    }\n+    Collections.sort(fileNames);\n+\n+    /*\n+     * Assumption: In the sorted list of files block file appears immediately\n+     * before block metadata file. This is true for the current naming\n+     * convention for block file blk_\u003cblockid\u003e and meta file\n+     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n+     */\n+    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n+      // Make sure this thread can make a timely exit. With a low throttle\n+      // rate, completing a run can take a looooong time.\n+      if (Thread.interrupted()) {\n+        throw new InterruptedException();\n+      }\n+\n+      File file \u003d new File(dir, fileNames.get(i));\n+      if (file.isDirectory()) {\n+        compileReport(bpFinalizedDir, file, report, reportCompiler);\n+        continue;\n+      }\n+      if (!Block.isBlockFilename(file)) {\n+        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n+          long blockId \u003d Block.getBlockId(file.getName());\n+          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n+              blockId);\n+          report.add(new ScanInfo(blockId, null, file, this));\n+        }\n+        continue;\n+      }\n+      File blockFile \u003d file;\n+      long blockId \u003d Block.filename2id(file.getName());\n+      File metaFile \u003d null;\n+\n+      // Skip all the files that start with block name until\n+      // getting to the metafile for the block\n+      while (i + 1 \u003c fileNames.size()) {\n+        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n+        if (!(blkMetaFile.isFile()\n+            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n+          break;\n+        }\n+        i++;\n+        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n+          metaFile \u003d blkMetaFile;\n+          break;\n+        }\n+      }\n+      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n+      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n+    }\n+    return report;\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  private LinkedList\u003cScanInfo\u003e compileReport(File bpFinalizedDir,\n      File dir, LinkedList\u003cScanInfo\u003e report, ReportCompiler reportCompiler)\n        throws InterruptedException {\n\n    reportCompiler.throttle();\n\n    List \u003cString\u003e fileNames;\n    try {\n      fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n    } catch (IOException ioe) {\n      LOG.warn(\"Exception occured while compiling report: \", ioe);\n      // Initiate a check on disk failure.\n      dataset.datanode.checkDiskErrorAsync();\n      // Ignore this directory and proceed.\n      return report;\n    }\n    Collections.sort(fileNames);\n\n    /*\n     * Assumption: In the sorted list of files block file appears immediately\n     * before block metadata file. This is true for the current naming\n     * convention for block file blk_\u003cblockid\u003e and meta file\n     * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n     */\n    for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n      // Make sure this thread can make a timely exit. With a low throttle\n      // rate, completing a run can take a looooong time.\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n\n      File file \u003d new File(dir, fileNames.get(i));\n      if (file.isDirectory()) {\n        compileReport(bpFinalizedDir, file, report, reportCompiler);\n        continue;\n      }\n      if (!Block.isBlockFilename(file)) {\n        if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n          long blockId \u003d Block.getBlockId(file.getName());\n          verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n              blockId);\n          report.add(new ScanInfo(blockId, null, file, this));\n        }\n        continue;\n      }\n      File blockFile \u003d file;\n      long blockId \u003d Block.filename2id(file.getName());\n      File metaFile \u003d null;\n\n      // Skip all the files that start with block name until\n      // getting to the metafile for the block\n      while (i + 1 \u003c fileNames.size()) {\n        File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n        if (!(blkMetaFile.isFile()\n            \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n          break;\n        }\n        i++;\n        if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n          metaFile \u003d blkMetaFile;\n          break;\n        }\n      }\n      verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n      report.add(new ScanInfo(blockId, blockFile, metaFile, this));\n    }\n    return report;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
          "extendedDetails": {
            "oldValue": "[vol-FsVolumeSpi, bpFinalizedDir-File, dir-File, report-LinkedList\u003cScanInfo\u003e]",
            "newValue": "[bpFinalizedDir-File, dir-File, report-LinkedList\u003cScanInfo\u003e, reportCompiler-ReportCompiler]"
          }
        }
      ]
    },
    "654cd1d0c0427c23e73804fc9d87208f76bbf6aa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10186. DirectoryScanner: Improve logs by adding full path of both actual and expected block directories.  Contributed by Rakesh R\n",
      "commitDate": "06/04/16 9:38 PM",
      "commitName": "654cd1d0c0427c23e73804fc9d87208f76bbf6aa",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "28/01/16 7:54 PM",
      "commitNameOld": "f67149ab08bb49381def6c535ab4c4610e0a4221",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 69.03,
      "commitsBetweenForRepo": 440,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,68 @@\n     private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n         File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report)\n         throws InterruptedException {\n \n       throttle();\n \n       List \u003cString\u003e fileNames;\n       try {\n         fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n       } catch (IOException ioe) {\n         LOG.warn(\"Exception occured while compiling report: \", ioe);\n         // Initiate a check on disk failure.\n         datanode.checkDiskErrorAsync();\n         // Ignore this directory and proceed.\n         return report;\n       }\n       Collections.sort(fileNames);\n \n       /*\n        * Assumption: In the sorted list of files block file appears immediately\n        * before block metadata file. This is true for the current naming\n        * convention for block file blk_\u003cblockid\u003e and meta file\n        * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n        */\n       for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n         // Make sure this thread can make a timely exit. With a low throttle\n         // rate, completing a run can take a looooong time.\n         if (Thread.interrupted()) {\n           throw new InterruptedException();\n         }\n \n         File file \u003d new File(dir, fileNames.get(i));\n         if (file.isDirectory()) {\n           compileReport(vol, bpFinalizedDir, file, report);\n           continue;\n         }\n         if (!Block.isBlockFilename(file)) {\n           if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n             long blockId \u003d Block.getBlockId(file.getName());\n             verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n                 blockId);\n             report.add(new ScanInfo(blockId, null, file, vol));\n           }\n           continue;\n         }\n         File blockFile \u003d file;\n         long blockId \u003d Block.filename2id(file.getName());\n         File metaFile \u003d null;\n \n         // Skip all the files that start with block name until\n         // getting to the metafile for the block\n         while (i + 1 \u003c fileNames.size()) {\n           File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n           if (!(blkMetaFile.isFile()\n               \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n             break;\n           }\n           i++;\n           if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n             metaFile \u003d blkMetaFile;\n             break;\n           }\n         }\n-        verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n-            blockId);\n+        verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n         report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n       }\n       return report;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report)\n        throws InterruptedException {\n\n      throttle();\n\n      List \u003cString\u003e fileNames;\n      try {\n        fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Initiate a check on disk failure.\n        datanode.checkDiskErrorAsync();\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Collections.sort(fileNames);\n\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n        // Make sure this thread can make a timely exit. With a low throttle\n        // rate, completing a run can take a looooong time.\n        if (Thread.interrupted()) {\n          throw new InterruptedException();\n        }\n\n        File file \u003d new File(dir, fileNames.get(i));\n        if (file.isDirectory()) {\n          compileReport(vol, bpFinalizedDir, file, report);\n          continue;\n        }\n        if (!Block.isBlockFilename(file)) {\n          if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n            long blockId \u003d Block.getBlockId(file.getName());\n            verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n                blockId);\n            report.add(new ScanInfo(blockId, null, file, vol));\n          }\n          continue;\n        }\n        File blockFile \u003d file;\n        long blockId \u003d Block.filename2id(file.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c fileNames.size()) {\n          File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n          if (!(blkMetaFile.isFile()\n              \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n            break;\n          }\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n            metaFile \u003d blkMetaFile;\n            break;\n          }\n        }\n        verifyFileLocation(blockFile, bpFinalizedDir, blockId);\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
      "extendedDetails": {}
    },
    "f67149ab08bb49381def6c535ab4c4610e0a4221": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7764. DirectoryScanner shouldn\u0027t abort the scan if one directory had an error (Rakesh R via cmccabe)\n",
      "commitDate": "28/01/16 7:54 PM",
      "commitName": "f67149ab08bb49381def6c535ab4c4610e0a4221",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "29/09/15 2:56 PM",
      "commitNameOld": "8703301b466cbc37ef53a96a55bcf6412792d5cf",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 121.25,
      "commitsBetweenForRepo": 828,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,69 @@\n     private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n         File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report)\n         throws InterruptedException {\n \n-      File[] files;\n-\n       throttle();\n \n+      List \u003cString\u003e fileNames;\n       try {\n-        files \u003d FileUtil.listFiles(dir);\n+        fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n       } catch (IOException ioe) {\n         LOG.warn(\"Exception occured while compiling report: \", ioe);\n         // Initiate a check on disk failure.\n         datanode.checkDiskErrorAsync();\n         // Ignore this directory and proceed.\n         return report;\n       }\n-      Arrays.sort(files);\n+      Collections.sort(fileNames);\n+\n       /*\n        * Assumption: In the sorted list of files block file appears immediately\n        * before block metadata file. This is true for the current naming\n        * convention for block file blk_\u003cblockid\u003e and meta file\n        * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n        */\n-      for (int i \u003d 0; i \u003c files.length; i++) {\n+      for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n         // Make sure this thread can make a timely exit. With a low throttle\n         // rate, completing a run can take a looooong time.\n         if (Thread.interrupted()) {\n           throw new InterruptedException();\n         }\n \n-        if (files[i].isDirectory()) {\n-          compileReport(vol, bpFinalizedDir, files[i], report);\n+        File file \u003d new File(dir, fileNames.get(i));\n+        if (file.isDirectory()) {\n+          compileReport(vol, bpFinalizedDir, file, report);\n           continue;\n         }\n-        if (!Block.isBlockFilename(files[i])) {\n-          if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, files[i].getName())) {\n-            long blockId \u003d Block.getBlockId(files[i].getName());\n-            verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n+        if (!Block.isBlockFilename(file)) {\n+          if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n+            long blockId \u003d Block.getBlockId(file.getName());\n+            verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n                 blockId);\n-            report.add(new ScanInfo(blockId, null, files[i], vol));\n+            report.add(new ScanInfo(blockId, null, file, vol));\n           }\n           continue;\n         }\n-        File blockFile \u003d files[i];\n-        long blockId \u003d Block.filename2id(blockFile.getName());\n+        File blockFile \u003d file;\n+        long blockId \u003d Block.filename2id(file.getName());\n         File metaFile \u003d null;\n \n         // Skip all the files that start with block name until\n         // getting to the metafile for the block\n-        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n-            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n+        while (i + 1 \u003c fileNames.size()) {\n+          File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n+          if (!(blkMetaFile.isFile()\n+              \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n+            break;\n+          }\n           i++;\n-          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n-            metaFile \u003d files[i];\n+          if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n+            metaFile \u003d blkMetaFile;\n             break;\n           }\n         }\n         verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n             blockId);\n         report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n       }\n       return report;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report)\n        throws InterruptedException {\n\n      throttle();\n\n      List \u003cString\u003e fileNames;\n      try {\n        fileNames \u003d IOUtils.listDirectory(dir, BlockDirFilter.INSTANCE);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Initiate a check on disk failure.\n        datanode.checkDiskErrorAsync();\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Collections.sort(fileNames);\n\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c fileNames.size(); i++) {\n        // Make sure this thread can make a timely exit. With a low throttle\n        // rate, completing a run can take a looooong time.\n        if (Thread.interrupted()) {\n          throw new InterruptedException();\n        }\n\n        File file \u003d new File(dir, fileNames.get(i));\n        if (file.isDirectory()) {\n          compileReport(vol, bpFinalizedDir, file, report);\n          continue;\n        }\n        if (!Block.isBlockFilename(file)) {\n          if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, file.getName())) {\n            long blockId \u003d Block.getBlockId(file.getName());\n            verifyFileLocation(file.getParentFile(), bpFinalizedDir,\n                blockId);\n            report.add(new ScanInfo(blockId, null, file, vol));\n          }\n          continue;\n        }\n        File blockFile \u003d file;\n        long blockId \u003d Block.filename2id(file.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c fileNames.size()) {\n          File blkMetaFile \u003d new File(dir, fileNames.get(i + 1));\n          if (!(blkMetaFile.isFile()\n              \u0026\u0026 blkMetaFile.getName().startsWith(blockFile.getName()))) {\n            break;\n          }\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), blkMetaFile.getName())) {\n            metaFile \u003d blkMetaFile;\n            break;\n          }\n        }\n        verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n            blockId);\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
      "extendedDetails": {}
    },
    "7a3c381b39887a02e944fa98287afd0eb4db3560": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-8873. Allow the directoryScanner to be rate-limited (Daniel Templeton via Colin P. McCabe)\n",
      "commitDate": "26/09/15 4:09 AM",
      "commitName": "7a3c381b39887a02e944fa98287afd0eb4db3560",
      "commitAuthor": "Colin Patrick Mccabe",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-8873. Allow the directoryScanner to be rate-limited (Daniel Templeton via Colin P. McCabe)\n",
          "commitDate": "26/09/15 4:09 AM",
          "commitName": "7a3c381b39887a02e944fa98287afd0eb4db3560",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "19/05/15 10:50 AM",
          "commitNameOld": "470c87dbc6c24dd3b370f1ad9e7ab1f6dabd2080",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 129.72,
          "commitsBetweenForRepo": 819,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,64 @@\n     private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n-        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report) {\n+        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report)\n+        throws InterruptedException {\n+\n       File[] files;\n+\n+      throttle();\n+\n       try {\n         files \u003d FileUtil.listFiles(dir);\n       } catch (IOException ioe) {\n         LOG.warn(\"Exception occured while compiling report: \", ioe);\n         // Initiate a check on disk failure.\n         datanode.checkDiskErrorAsync();\n         // Ignore this directory and proceed.\n         return report;\n       }\n       Arrays.sort(files);\n       /*\n        * Assumption: In the sorted list of files block file appears immediately\n        * before block metadata file. This is true for the current naming\n        * convention for block file blk_\u003cblockid\u003e and meta file\n        * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n        */\n       for (int i \u003d 0; i \u003c files.length; i++) {\n+        // Make sure this thread can make a timely exit. With a low throttle\n+        // rate, completing a run can take a looooong time.\n+        if (Thread.interrupted()) {\n+          throw new InterruptedException();\n+        }\n+\n         if (files[i].isDirectory()) {\n           compileReport(vol, bpFinalizedDir, files[i], report);\n           continue;\n         }\n         if (!Block.isBlockFilename(files[i])) {\n           if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, files[i].getName())) {\n             long blockId \u003d Block.getBlockId(files[i].getName());\n             verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n                 blockId);\n             report.add(new ScanInfo(blockId, null, files[i], vol));\n           }\n           continue;\n         }\n         File blockFile \u003d files[i];\n         long blockId \u003d Block.filename2id(blockFile.getName());\n         File metaFile \u003d null;\n \n         // Skip all the files that start with block name until\n         // getting to the metafile for the block\n         while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n             \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n           i++;\n           if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n             metaFile \u003d files[i];\n             break;\n           }\n         }\n         verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n             blockId);\n         report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n       }\n       return report;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report)\n        throws InterruptedException {\n\n      File[] files;\n\n      throttle();\n\n      try {\n        files \u003d FileUtil.listFiles(dir);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Initiate a check on disk failure.\n        datanode.checkDiskErrorAsync();\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Arrays.sort(files);\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c files.length; i++) {\n        // Make sure this thread can make a timely exit. With a low throttle\n        // rate, completing a run can take a looooong time.\n        if (Thread.interrupted()) {\n          throw new InterruptedException();\n        }\n\n        if (files[i].isDirectory()) {\n          compileReport(vol, bpFinalizedDir, files[i], report);\n          continue;\n        }\n        if (!Block.isBlockFilename(files[i])) {\n          if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, files[i].getName())) {\n            long blockId \u003d Block.getBlockId(files[i].getName());\n            verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n                blockId);\n            report.add(new ScanInfo(blockId, null, files[i], vol));\n          }\n          continue;\n        }\n        File blockFile \u003d files[i];\n        long blockId \u003d Block.filename2id(blockFile.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n            metaFile \u003d files[i];\n            break;\n          }\n        }\n        verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n            blockId);\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8873. Allow the directoryScanner to be rate-limited (Daniel Templeton via Colin P. McCabe)\n",
          "commitDate": "26/09/15 4:09 AM",
          "commitName": "7a3c381b39887a02e944fa98287afd0eb4db3560",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "19/05/15 10:50 AM",
          "commitNameOld": "470c87dbc6c24dd3b370f1ad9e7ab1f6dabd2080",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 129.72,
          "commitsBetweenForRepo": 819,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,64 @@\n     private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n-        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report) {\n+        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report)\n+        throws InterruptedException {\n+\n       File[] files;\n+\n+      throttle();\n+\n       try {\n         files \u003d FileUtil.listFiles(dir);\n       } catch (IOException ioe) {\n         LOG.warn(\"Exception occured while compiling report: \", ioe);\n         // Initiate a check on disk failure.\n         datanode.checkDiskErrorAsync();\n         // Ignore this directory and proceed.\n         return report;\n       }\n       Arrays.sort(files);\n       /*\n        * Assumption: In the sorted list of files block file appears immediately\n        * before block metadata file. This is true for the current naming\n        * convention for block file blk_\u003cblockid\u003e and meta file\n        * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n        */\n       for (int i \u003d 0; i \u003c files.length; i++) {\n+        // Make sure this thread can make a timely exit. With a low throttle\n+        // rate, completing a run can take a looooong time.\n+        if (Thread.interrupted()) {\n+          throw new InterruptedException();\n+        }\n+\n         if (files[i].isDirectory()) {\n           compileReport(vol, bpFinalizedDir, files[i], report);\n           continue;\n         }\n         if (!Block.isBlockFilename(files[i])) {\n           if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, files[i].getName())) {\n             long blockId \u003d Block.getBlockId(files[i].getName());\n             verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n                 blockId);\n             report.add(new ScanInfo(blockId, null, files[i], vol));\n           }\n           continue;\n         }\n         File blockFile \u003d files[i];\n         long blockId \u003d Block.filename2id(blockFile.getName());\n         File metaFile \u003d null;\n \n         // Skip all the files that start with block name until\n         // getting to the metafile for the block\n         while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n             \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n           i++;\n           if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n             metaFile \u003d files[i];\n             break;\n           }\n         }\n         verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n             blockId);\n         report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n       }\n       return report;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report)\n        throws InterruptedException {\n\n      File[] files;\n\n      throttle();\n\n      try {\n        files \u003d FileUtil.listFiles(dir);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Initiate a check on disk failure.\n        datanode.checkDiskErrorAsync();\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Arrays.sort(files);\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c files.length; i++) {\n        // Make sure this thread can make a timely exit. With a low throttle\n        // rate, completing a run can take a looooong time.\n        if (Thread.interrupted()) {\n          throw new InterruptedException();\n        }\n\n        if (files[i].isDirectory()) {\n          compileReport(vol, bpFinalizedDir, files[i], report);\n          continue;\n        }\n        if (!Block.isBlockFilename(files[i])) {\n          if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, files[i].getName())) {\n            long blockId \u003d Block.getBlockId(files[i].getName());\n            verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n                blockId);\n            report.add(new ScanInfo(blockId, null, files[i], vol));\n          }\n          continue;\n        }\n        File blockFile \u003d files[i];\n        long blockId \u003d Block.filename2id(blockFile.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n            metaFile \u003d files[i];\n            break;\n          }\n        }\n        verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n            blockId);\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
          "extendedDetails": {}
        }
      ]
    },
    "430b5371883e22abb65f37c3e3d4afc3f421fc89": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1522. Combine two BLOCK_FILE_PREFIX constants into one. Contributed by Dongming Liang.",
      "commitDate": "04/03/15 5:51 PM",
      "commitName": "430b5371883e22abb65f37c3e3d4afc3f421fc89",
      "commitAuthor": "Dongming Liang",
      "commitDateOld": "27/02/15 3:06 AM",
      "commitNameOld": "4f75b15628a76881efc39054612dc128e23d27be",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 5.61,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n         File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report) {\n       File[] files;\n       try {\n         files \u003d FileUtil.listFiles(dir);\n       } catch (IOException ioe) {\n         LOG.warn(\"Exception occured while compiling report: \", ioe);\n         // Initiate a check on disk failure.\n         datanode.checkDiskErrorAsync();\n         // Ignore this directory and proceed.\n         return report;\n       }\n       Arrays.sort(files);\n       /*\n        * Assumption: In the sorted list of files block file appears immediately\n        * before block metadata file. This is true for the current naming\n        * convention for block file blk_\u003cblockid\u003e and meta file\n        * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n        */\n       for (int i \u003d 0; i \u003c files.length; i++) {\n         if (files[i].isDirectory()) {\n           compileReport(vol, bpFinalizedDir, files[i], report);\n           continue;\n         }\n         if (!Block.isBlockFilename(files[i])) {\n-          if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n+          if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, files[i].getName())) {\n             long blockId \u003d Block.getBlockId(files[i].getName());\n             verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n                 blockId);\n             report.add(new ScanInfo(blockId, null, files[i], vol));\n           }\n           continue;\n         }\n         File blockFile \u003d files[i];\n         long blockId \u003d Block.filename2id(blockFile.getName());\n         File metaFile \u003d null;\n \n         // Skip all the files that start with block name until\n         // getting to the metafile for the block\n         while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n             \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n           i++;\n           if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n             metaFile \u003d files[i];\n             break;\n           }\n         }\n         verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n             blockId);\n         report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n       }\n       return report;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report) {\n      File[] files;\n      try {\n        files \u003d FileUtil.listFiles(dir);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Initiate a check on disk failure.\n        datanode.checkDiskErrorAsync();\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Arrays.sort(files);\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c files.length; i++) {\n        if (files[i].isDirectory()) {\n          compileReport(vol, bpFinalizedDir, files[i], report);\n          continue;\n        }\n        if (!Block.isBlockFilename(files[i])) {\n          if (isBlockMetaFile(Block.BLOCK_FILE_PREFIX, files[i].getName())) {\n            long blockId \u003d Block.getBlockId(files[i].getName());\n            verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n                blockId);\n            report.add(new ScanInfo(blockId, null, files[i], vol));\n          }\n          continue;\n        }\n        File blockFile \u003d files[i];\n        long blockId \u003d Block.filename2id(blockFile.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n            metaFile \u003d files[i];\n            break;\n          }\n        }\n        verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n            blockId);\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
      "extendedDetails": {}
    },
    "4f75b15628a76881efc39054612dc128e23d27be": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6753. Initialize checkDisk when DirectoryScanner not able to get files list for scanning (Contributed by J.Andreina)\n",
      "commitDate": "27/02/15 3:06 AM",
      "commitName": "4f75b15628a76881efc39054612dc128e23d27be",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "26/02/15 11:58 AM",
      "commitNameOld": "f0c980abed3843923e0eb16b626fa27334195eda",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.63,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,53 @@\n     private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n         File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report) {\n       File[] files;\n       try {\n         files \u003d FileUtil.listFiles(dir);\n       } catch (IOException ioe) {\n         LOG.warn(\"Exception occured while compiling report: \", ioe);\n+        // Initiate a check on disk failure.\n+        datanode.checkDiskErrorAsync();\n         // Ignore this directory and proceed.\n         return report;\n       }\n       Arrays.sort(files);\n       /*\n        * Assumption: In the sorted list of files block file appears immediately\n        * before block metadata file. This is true for the current naming\n        * convention for block file blk_\u003cblockid\u003e and meta file\n        * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n        */\n       for (int i \u003d 0; i \u003c files.length; i++) {\n         if (files[i].isDirectory()) {\n           compileReport(vol, bpFinalizedDir, files[i], report);\n           continue;\n         }\n         if (!Block.isBlockFilename(files[i])) {\n           if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n             long blockId \u003d Block.getBlockId(files[i].getName());\n             verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n                 blockId);\n             report.add(new ScanInfo(blockId, null, files[i], vol));\n           }\n           continue;\n         }\n         File blockFile \u003d files[i];\n         long blockId \u003d Block.filename2id(blockFile.getName());\n         File metaFile \u003d null;\n \n         // Skip all the files that start with block name until\n         // getting to the metafile for the block\n         while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n             \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n           i++;\n           if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n             metaFile \u003d files[i];\n             break;\n           }\n         }\n         verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n             blockId);\n         report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n       }\n       return report;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report) {\n      File[] files;\n      try {\n        files \u003d FileUtil.listFiles(dir);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Initiate a check on disk failure.\n        datanode.checkDiskErrorAsync();\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Arrays.sort(files);\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c files.length; i++) {\n        if (files[i].isDirectory()) {\n          compileReport(vol, bpFinalizedDir, files[i], report);\n          continue;\n        }\n        if (!Block.isBlockFilename(files[i])) {\n          if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n            long blockId \u003d Block.getBlockId(files[i].getName());\n            verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n                blockId);\n            report.add(new ScanInfo(blockId, null, files[i], vol));\n          }\n          continue;\n        }\n        File blockFile \u003d files[i];\n        long blockId \u003d Block.filename2id(blockFile.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n            metaFile \u003d files[i];\n            break;\n          }\n        }\n        verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n            blockId);\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
      "extendedDetails": {}
    },
    "f0c980abed3843923e0eb16b626fa27334195eda": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7819. Log WARN message for the blocks which are not in Block ID based layout (Rakesh R via Colin P. McCabe)\n",
      "commitDate": "26/02/15 11:58 AM",
      "commitName": "f0c980abed3843923e0eb16b626fa27334195eda",
      "commitAuthor": "Colin Patrick Mccabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7819. Log WARN message for the blocks which are not in Block ID based layout (Rakesh R via Colin P. McCabe)\n",
          "commitDate": "26/02/15 11:58 AM",
          "commitName": "f0c980abed3843923e0eb16b626fa27334195eda",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "12/09/14 10:13 PM",
          "commitNameOld": "9f22fb8c9a10952225e15c7b67b5f77fa44b155d",
          "commitAuthorOld": "arp",
          "daysBetweenCommits": 166.61,
          "commitsBetweenForRepo": 1397,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,51 @@\n-    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol, File dir,\n-        LinkedList\u003cScanInfo\u003e report) {\n+    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n+        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report) {\n       File[] files;\n       try {\n         files \u003d FileUtil.listFiles(dir);\n       } catch (IOException ioe) {\n         LOG.warn(\"Exception occured while compiling report: \", ioe);\n         // Ignore this directory and proceed.\n         return report;\n       }\n       Arrays.sort(files);\n       /*\n        * Assumption: In the sorted list of files block file appears immediately\n        * before block metadata file. This is true for the current naming\n        * convention for block file blk_\u003cblockid\u003e and meta file\n        * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n        */\n       for (int i \u003d 0; i \u003c files.length; i++) {\n         if (files[i].isDirectory()) {\n-          compileReport(vol, files[i], report);\n+          compileReport(vol, bpFinalizedDir, files[i], report);\n           continue;\n         }\n         if (!Block.isBlockFilename(files[i])) {\n           if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n             long blockId \u003d Block.getBlockId(files[i].getName());\n+            verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n+                blockId);\n             report.add(new ScanInfo(blockId, null, files[i], vol));\n           }\n           continue;\n         }\n         File blockFile \u003d files[i];\n         long blockId \u003d Block.filename2id(blockFile.getName());\n         File metaFile \u003d null;\n \n         // Skip all the files that start with block name until\n         // getting to the metafile for the block\n         while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n             \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n           i++;\n           if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n             metaFile \u003d files[i];\n             break;\n           }\n         }\n+        verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n+            blockId);\n         report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n       }\n       return report;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report) {\n      File[] files;\n      try {\n        files \u003d FileUtil.listFiles(dir);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Arrays.sort(files);\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c files.length; i++) {\n        if (files[i].isDirectory()) {\n          compileReport(vol, bpFinalizedDir, files[i], report);\n          continue;\n        }\n        if (!Block.isBlockFilename(files[i])) {\n          if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n            long blockId \u003d Block.getBlockId(files[i].getName());\n            verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n                blockId);\n            report.add(new ScanInfo(blockId, null, files[i], vol));\n          }\n          continue;\n        }\n        File blockFile \u003d files[i];\n        long blockId \u003d Block.filename2id(blockFile.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n            metaFile \u003d files[i];\n            break;\n          }\n        }\n        verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n            blockId);\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
          "extendedDetails": {
            "oldValue": "[vol-FsVolumeSpi, dir-File, report-LinkedList\u003cScanInfo\u003e]",
            "newValue": "[vol-FsVolumeSpi, bpFinalizedDir-File, dir-File, report-LinkedList\u003cScanInfo\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7819. Log WARN message for the blocks which are not in Block ID based layout (Rakesh R via Colin P. McCabe)\n",
          "commitDate": "26/02/15 11:58 AM",
          "commitName": "f0c980abed3843923e0eb16b626fa27334195eda",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "12/09/14 10:13 PM",
          "commitNameOld": "9f22fb8c9a10952225e15c7b67b5f77fa44b155d",
          "commitAuthorOld": "arp",
          "daysBetweenCommits": 166.61,
          "commitsBetweenForRepo": 1397,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,51 @@\n-    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol, File dir,\n-        LinkedList\u003cScanInfo\u003e report) {\n+    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n+        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report) {\n       File[] files;\n       try {\n         files \u003d FileUtil.listFiles(dir);\n       } catch (IOException ioe) {\n         LOG.warn(\"Exception occured while compiling report: \", ioe);\n         // Ignore this directory and proceed.\n         return report;\n       }\n       Arrays.sort(files);\n       /*\n        * Assumption: In the sorted list of files block file appears immediately\n        * before block metadata file. This is true for the current naming\n        * convention for block file blk_\u003cblockid\u003e and meta file\n        * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n        */\n       for (int i \u003d 0; i \u003c files.length; i++) {\n         if (files[i].isDirectory()) {\n-          compileReport(vol, files[i], report);\n+          compileReport(vol, bpFinalizedDir, files[i], report);\n           continue;\n         }\n         if (!Block.isBlockFilename(files[i])) {\n           if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n             long blockId \u003d Block.getBlockId(files[i].getName());\n+            verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n+                blockId);\n             report.add(new ScanInfo(blockId, null, files[i], vol));\n           }\n           continue;\n         }\n         File blockFile \u003d files[i];\n         long blockId \u003d Block.filename2id(blockFile.getName());\n         File metaFile \u003d null;\n \n         // Skip all the files that start with block name until\n         // getting to the metafile for the block\n         while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n             \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n           i++;\n           if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n             metaFile \u003d files[i];\n             break;\n           }\n         }\n+        verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n+            blockId);\n         report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n       }\n       return report;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol,\n        File bpFinalizedDir, File dir, LinkedList\u003cScanInfo\u003e report) {\n      File[] files;\n      try {\n        files \u003d FileUtil.listFiles(dir);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Arrays.sort(files);\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c files.length; i++) {\n        if (files[i].isDirectory()) {\n          compileReport(vol, bpFinalizedDir, files[i], report);\n          continue;\n        }\n        if (!Block.isBlockFilename(files[i])) {\n          if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n            long blockId \u003d Block.getBlockId(files[i].getName());\n            verifyFileLocation(files[i].getParentFile(), bpFinalizedDir,\n                blockId);\n            report.add(new ScanInfo(blockId, null, files[i], vol));\n          }\n          continue;\n        }\n        File blockFile \u003d files[i];\n        long blockId \u003d Block.filename2id(blockFile.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n            metaFile \u003d files[i];\n            break;\n          }\n        }\n        verifyFileLocation(blockFile.getParentFile(), bpFinalizedDir,\n            blockId);\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
          "extendedDetails": {}
        }
      ]
    },
    "662b1887af4e39f3eadd7dda4953c7f2529b43bc": {
      "type": "Yparameterchange",
      "commitMessage": "HDFS-3088. Move FSDatasetInterface inner classes to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1301661 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/03/12 10:32 AM",
      "commitName": "662b1887af4e39f3eadd7dda4953c7f2529b43bc",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "01/03/12 1:58 PM",
      "commitNameOld": "9e31bf675dd92183a9a74a66b7caf1a080581d65",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 14.82,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n-    private LinkedList\u003cScanInfo\u003e compileReport(FSVolumeInterface vol, File dir,\n+    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol, File dir,\n         LinkedList\u003cScanInfo\u003e report) {\n       File[] files;\n       try {\n         files \u003d FileUtil.listFiles(dir);\n       } catch (IOException ioe) {\n         LOG.warn(\"Exception occured while compiling report: \", ioe);\n         // Ignore this directory and proceed.\n         return report;\n       }\n       Arrays.sort(files);\n       /*\n        * Assumption: In the sorted list of files block file appears immediately\n        * before block metadata file. This is true for the current naming\n        * convention for block file blk_\u003cblockid\u003e and meta file\n        * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n        */\n       for (int i \u003d 0; i \u003c files.length; i++) {\n         if (files[i].isDirectory()) {\n           compileReport(vol, files[i], report);\n           continue;\n         }\n         if (!Block.isBlockFilename(files[i])) {\n           if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n             long blockId \u003d Block.getBlockId(files[i].getName());\n             report.add(new ScanInfo(blockId, null, files[i], vol));\n           }\n           continue;\n         }\n         File blockFile \u003d files[i];\n         long blockId \u003d Block.filename2id(blockFile.getName());\n         File metaFile \u003d null;\n \n         // Skip all the files that start with block name until\n         // getting to the metafile for the block\n         while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n             \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n           i++;\n           if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n             metaFile \u003d files[i];\n             break;\n           }\n         }\n         report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n       }\n       return report;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FsVolumeSpi vol, File dir,\n        LinkedList\u003cScanInfo\u003e report) {\n      File[] files;\n      try {\n        files \u003d FileUtil.listFiles(dir);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Arrays.sort(files);\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c files.length; i++) {\n        if (files[i].isDirectory()) {\n          compileReport(vol, files[i], report);\n          continue;\n        }\n        if (!Block.isBlockFilename(files[i])) {\n          if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n            long blockId \u003d Block.getBlockId(files[i].getName());\n            report.add(new ScanInfo(blockId, null, files[i], vol));\n          }\n          continue;\n        }\n        File blockFile \u003d files[i];\n        long blockId \u003d Block.filename2id(blockFile.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n            metaFile \u003d files[i];\n            break;\n          }\n        }\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
      "extendedDetails": {
        "oldValue": "[vol-FSVolumeInterface, dir-File, report-LinkedList\u003cScanInfo\u003e]",
        "newValue": "[vol-FsVolumeSpi, dir-File, report-LinkedList\u003cScanInfo\u003e]"
      }
    },
    "b6ffb08a467f1b5bc89e5114c462c3117b337be6": {
      "type": "Yparameterchange",
      "commitMessage": "HDFS-2887. FSVolume, is a part of FSDatasetInterface implementation, should not be referred outside FSDataset.  A new FSVolumeInterface is defined.  The BlockVolumeChoosingPolicy.chooseVolume(..) method signature is also updated.  (szetszwo)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1242087 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/02/12 12:58 PM",
      "commitName": "b6ffb08a467f1b5bc89e5114c462c3117b337be6",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 167.86,
      "commitsBetweenForRepo": 1072,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n-    private LinkedList\u003cScanInfo\u003e compileReport(FSVolume vol, File dir,\n+    private LinkedList\u003cScanInfo\u003e compileReport(FSVolumeInterface vol, File dir,\n         LinkedList\u003cScanInfo\u003e report) {\n       File[] files;\n       try {\n         files \u003d FileUtil.listFiles(dir);\n       } catch (IOException ioe) {\n         LOG.warn(\"Exception occured while compiling report: \", ioe);\n         // Ignore this directory and proceed.\n         return report;\n       }\n       Arrays.sort(files);\n       /*\n        * Assumption: In the sorted list of files block file appears immediately\n        * before block metadata file. This is true for the current naming\n        * convention for block file blk_\u003cblockid\u003e and meta file\n        * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n        */\n       for (int i \u003d 0; i \u003c files.length; i++) {\n         if (files[i].isDirectory()) {\n           compileReport(vol, files[i], report);\n           continue;\n         }\n         if (!Block.isBlockFilename(files[i])) {\n           if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n             long blockId \u003d Block.getBlockId(files[i].getName());\n             report.add(new ScanInfo(blockId, null, files[i], vol));\n           }\n           continue;\n         }\n         File blockFile \u003d files[i];\n         long blockId \u003d Block.filename2id(blockFile.getName());\n         File metaFile \u003d null;\n \n         // Skip all the files that start with block name until\n         // getting to the metafile for the block\n         while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n             \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n           i++;\n           if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n             metaFile \u003d files[i];\n             break;\n           }\n         }\n         report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n       }\n       return report;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FSVolumeInterface vol, File dir,\n        LinkedList\u003cScanInfo\u003e report) {\n      File[] files;\n      try {\n        files \u003d FileUtil.listFiles(dir);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Arrays.sort(files);\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c files.length; i++) {\n        if (files[i].isDirectory()) {\n          compileReport(vol, files[i], report);\n          continue;\n        }\n        if (!Block.isBlockFilename(files[i])) {\n          if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n            long blockId \u003d Block.getBlockId(files[i].getName());\n            report.add(new ScanInfo(blockId, null, files[i], vol));\n          }\n          continue;\n        }\n        File blockFile \u003d files[i];\n        long blockId \u003d Block.filename2id(blockFile.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n            metaFile \u003d files[i];\n            break;\n          }\n        }\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
      "extendedDetails": {
        "oldValue": "[vol-FSVolume, dir-File, report-LinkedList\u003cScanInfo\u003e]",
        "newValue": "[vol-FSVolumeInterface, dir-File, report-LinkedList\u003cScanInfo\u003e]"
      }
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FSVolume vol, File dir,\n        LinkedList\u003cScanInfo\u003e report) {\n      File[] files;\n      try {\n        files \u003d FileUtil.listFiles(dir);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Arrays.sort(files);\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c files.length; i++) {\n        if (files[i].isDirectory()) {\n          compileReport(vol, files[i], report);\n          continue;\n        }\n        if (!Block.isBlockFilename(files[i])) {\n          if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n            long blockId \u003d Block.getBlockId(files[i].getName());\n            report.add(new ScanInfo(blockId, null, files[i], vol));\n          }\n          continue;\n        }\n        File blockFile \u003d files[i];\n        long blockId \u003d Block.filename2id(blockFile.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n            metaFile \u003d files[i];\n            break;\n          }\n        }\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FSVolume vol, File dir,\n        LinkedList\u003cScanInfo\u003e report) {\n      File[] files;\n      try {\n        files \u003d FileUtil.listFiles(dir);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Arrays.sort(files);\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c files.length; i++) {\n        if (files[i].isDirectory()) {\n          compileReport(vol, files[i], report);\n          continue;\n        }\n        if (!Block.isBlockFilename(files[i])) {\n          if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n            long blockId \u003d Block.getBlockId(files[i].getName());\n            report.add(new ScanInfo(blockId, null, files[i], vol));\n          }\n          continue;\n        }\n        File blockFile \u003d files[i];\n        long blockId \u003d Block.filename2id(blockFile.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n            metaFile \u003d files[i];\n            break;\n          }\n        }\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,47 @@\n+    private LinkedList\u003cScanInfo\u003e compileReport(FSVolume vol, File dir,\n+        LinkedList\u003cScanInfo\u003e report) {\n+      File[] files;\n+      try {\n+        files \u003d FileUtil.listFiles(dir);\n+      } catch (IOException ioe) {\n+        LOG.warn(\"Exception occured while compiling report: \", ioe);\n+        // Ignore this directory and proceed.\n+        return report;\n+      }\n+      Arrays.sort(files);\n+      /*\n+       * Assumption: In the sorted list of files block file appears immediately\n+       * before block metadata file. This is true for the current naming\n+       * convention for block file blk_\u003cblockid\u003e and meta file\n+       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n+       */\n+      for (int i \u003d 0; i \u003c files.length; i++) {\n+        if (files[i].isDirectory()) {\n+          compileReport(vol, files[i], report);\n+          continue;\n+        }\n+        if (!Block.isBlockFilename(files[i])) {\n+          if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n+            long blockId \u003d Block.getBlockId(files[i].getName());\n+            report.add(new ScanInfo(blockId, null, files[i], vol));\n+          }\n+          continue;\n+        }\n+        File blockFile \u003d files[i];\n+        long blockId \u003d Block.filename2id(blockFile.getName());\n+        File metaFile \u003d null;\n+\n+        // Skip all the files that start with block name until\n+        // getting to the metafile for the block\n+        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n+            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n+          i++;\n+          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n+            metaFile \u003d files[i];\n+            break;\n+          }\n+        }\n+        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n+      }\n+      return report;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private LinkedList\u003cScanInfo\u003e compileReport(FSVolume vol, File dir,\n        LinkedList\u003cScanInfo\u003e report) {\n      File[] files;\n      try {\n        files \u003d FileUtil.listFiles(dir);\n      } catch (IOException ioe) {\n        LOG.warn(\"Exception occured while compiling report: \", ioe);\n        // Ignore this directory and proceed.\n        return report;\n      }\n      Arrays.sort(files);\n      /*\n       * Assumption: In the sorted list of files block file appears immediately\n       * before block metadata file. This is true for the current naming\n       * convention for block file blk_\u003cblockid\u003e and meta file\n       * blk_\u003cblockid\u003e_\u003cgenstamp\u003e.meta\n       */\n      for (int i \u003d 0; i \u003c files.length; i++) {\n        if (files[i].isDirectory()) {\n          compileReport(vol, files[i], report);\n          continue;\n        }\n        if (!Block.isBlockFilename(files[i])) {\n          if (isBlockMetaFile(\"blk_\", files[i].getName())) {\n            long blockId \u003d Block.getBlockId(files[i].getName());\n            report.add(new ScanInfo(blockId, null, files[i], vol));\n          }\n          continue;\n        }\n        File blockFile \u003d files[i];\n        long blockId \u003d Block.filename2id(blockFile.getName());\n        File metaFile \u003d null;\n\n        // Skip all the files that start with block name until\n        // getting to the metafile for the block\n        while (i + 1 \u003c files.length \u0026\u0026 files[i + 1].isFile()\n            \u0026\u0026 files[i + 1].getName().startsWith(blockFile.getName())) {\n          i++;\n          if (isBlockMetaFile(blockFile.getName(), files[i].getName())) {\n            metaFile \u003d files[i];\n            break;\n          }\n        }\n        report.add(new ScanInfo(blockId, blockFile, metaFile, vol));\n      }\n      return report;\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DirectoryScanner.java"
    }
  }
}