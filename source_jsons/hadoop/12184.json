{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataNode.java",
  "functionName": "transferBlock",
  "functionId": "transferBlock___block-ExtendedBlock__xferTargets-DatanodeInfo[]__xferTargetStorageTypes-StorageType[]__xferTargetStorageIDs-String[]",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
  "functionStartLine": 2343,
  "functionEndLine": 2405,
  "numCommitsSeen": 358,
  "timeTaken": 3157,
  "changeHistory": [
    "15d38b1bf9fbd41658f6980c1a484dd28f746654",
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
    "dfcb331ba3516264398121c9f23af3a79c0509cc"
  ],
  "changeHistoryShort": {
    "15d38b1bf9fbd41658f6980c1a484dd28f746654": "Ybodychange",
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": "Ybodychange",
    "dfcb331ba3516264398121c9f23af3a79c0509cc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "15d38b1bf9fbd41658f6980c1a484dd28f746654": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14295. Add Threadpool for DataTransfers. Contributed by David Mollitor.\n",
      "commitDate": "28/03/19 3:37 AM",
      "commitName": "15d38b1bf9fbd41658f6980c1a484dd28f746654",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "12/03/19 10:17 AM",
      "commitNameOld": "34b14061b38dccab25058dff1b8743d8a3f82734",
      "commitAuthorOld": "Stephen O\u0027Donnell",
      "daysBetweenCommits": 15.72,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   void transferBlock(ExtendedBlock block, DatanodeInfo[] xferTargets,\n       StorageType[] xferTargetStorageTypes, String[] xferTargetStorageIDs)\n       throws IOException {\n     BPOfferService bpos \u003d getBPOSForBlock(block);\n     DatanodeRegistration bpReg \u003d getDNRegistrationForBP(block.getBlockPoolId());\n \n     boolean replicaNotExist \u003d false;\n     boolean replicaStateNotFinalized \u003d false;\n     boolean blockFileNotExist \u003d false;\n     boolean lengthTooShort \u003d false;\n \n     try {\n       data.checkBlock(block, block.getNumBytes(), ReplicaState.FINALIZED);\n     } catch (ReplicaNotFoundException e) {\n       replicaNotExist \u003d true;\n     } catch (UnexpectedReplicaStateException e) {\n       replicaStateNotFinalized \u003d true;\n     } catch (FileNotFoundException e) {\n       blockFileNotExist \u003d true;\n     } catch (EOFException e) {\n       lengthTooShort \u003d true;\n     } catch (IOException e) {\n       // The IOException indicates not being able to access block file,\n       // treat it the same here as blockFileNotExist, to trigger \n       // reporting it as a bad block\n       blockFileNotExist \u003d true;      \n     }\n \n     if (replicaNotExist || replicaStateNotFinalized) {\n       String errStr \u003d \"Can\u0027t send invalid block \" + block;\n       LOG.info(errStr);\n       bpos.trySendErrorReport(DatanodeProtocol.INVALID_BLOCK, errStr);\n       return;\n     }\n     if (blockFileNotExist) {\n       // Report back to NN bad block caused by non-existent block file.\n       reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n           + \" because the block file doesn\u0027t exist, or is not accessible\");\n       return;\n     }\n     if (lengthTooShort) {\n       // Check if NN recorded length matches on-disk length \n       // Shorter on-disk len indicates corruption so report NN the corrupt block\n       reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n           + \" because on-disk length \" + data.getLength(block) \n           + \" is shorter than NameNode recorded length \" + block.getNumBytes());\n       return;\n     }\n     \n     int numTargets \u003d xferTargets.length;\n     if (numTargets \u003e 0) {\n-      StringBuilder xfersBuilder \u003d new StringBuilder();\n-      for (int i \u003d 0; i \u003c numTargets; i++) {\n-        xfersBuilder.append(xferTargets[i]).append(\" \");\n-      }\n-      LOG.info(bpReg + \" Starting thread to transfer \" + \n-               block + \" to \" + xfersBuilder);                       \n+      final String xferTargetsString \u003d\n+          StringUtils.join(\" \", Arrays.asList(xferTargets));\n+      LOG.info(\"{} Starting thread to transfer {} to {}\", bpReg, block,\n+          xferTargetsString);\n \n-      new Daemon(new DataTransfer(xferTargets, xferTargetStorageTypes,\n-          xferTargetStorageIDs, block,\n-          BlockConstructionStage.PIPELINE_SETUP_CREATE, \"\")).start();\n+      final DataTransfer dataTransferTask \u003d new DataTransfer(xferTargets,\n+          xferTargetStorageTypes, xferTargetStorageIDs, block,\n+          BlockConstructionStage.PIPELINE_SETUP_CREATE, \"\");\n+\n+      this.xferService.execute(dataTransferTask);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void transferBlock(ExtendedBlock block, DatanodeInfo[] xferTargets,\n      StorageType[] xferTargetStorageTypes, String[] xferTargetStorageIDs)\n      throws IOException {\n    BPOfferService bpos \u003d getBPOSForBlock(block);\n    DatanodeRegistration bpReg \u003d getDNRegistrationForBP(block.getBlockPoolId());\n\n    boolean replicaNotExist \u003d false;\n    boolean replicaStateNotFinalized \u003d false;\n    boolean blockFileNotExist \u003d false;\n    boolean lengthTooShort \u003d false;\n\n    try {\n      data.checkBlock(block, block.getNumBytes(), ReplicaState.FINALIZED);\n    } catch (ReplicaNotFoundException e) {\n      replicaNotExist \u003d true;\n    } catch (UnexpectedReplicaStateException e) {\n      replicaStateNotFinalized \u003d true;\n    } catch (FileNotFoundException e) {\n      blockFileNotExist \u003d true;\n    } catch (EOFException e) {\n      lengthTooShort \u003d true;\n    } catch (IOException e) {\n      // The IOException indicates not being able to access block file,\n      // treat it the same here as blockFileNotExist, to trigger \n      // reporting it as a bad block\n      blockFileNotExist \u003d true;      \n    }\n\n    if (replicaNotExist || replicaStateNotFinalized) {\n      String errStr \u003d \"Can\u0027t send invalid block \" + block;\n      LOG.info(errStr);\n      bpos.trySendErrorReport(DatanodeProtocol.INVALID_BLOCK, errStr);\n      return;\n    }\n    if (blockFileNotExist) {\n      // Report back to NN bad block caused by non-existent block file.\n      reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n          + \" because the block file doesn\u0027t exist, or is not accessible\");\n      return;\n    }\n    if (lengthTooShort) {\n      // Check if NN recorded length matches on-disk length \n      // Shorter on-disk len indicates corruption so report NN the corrupt block\n      reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n          + \" because on-disk length \" + data.getLength(block) \n          + \" is shorter than NameNode recorded length \" + block.getNumBytes());\n      return;\n    }\n    \n    int numTargets \u003d xferTargets.length;\n    if (numTargets \u003e 0) {\n      final String xferTargetsString \u003d\n          StringUtils.join(\" \", Arrays.asList(xferTargets));\n      LOG.info(\"{} Starting thread to transfer {} to {}\", bpReg, block,\n          xferTargetsString);\n\n      final DataTransfer dataTransferTask \u003d new DataTransfer(xferTargets,\n          xferTargetStorageTypes, xferTargetStorageIDs, block,\n          BlockConstructionStage.PIPELINE_SETUP_CREATE, \"\");\n\n      this.xferService.execute(dataTransferTask);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16029. Consecutive StringBuilder.append can be reused. Contributed by Ayush Saxena.\n",
      "commitDate": "11/01/19 10:54 AM",
      "commitName": "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "16/11/18 4:35 AM",
      "commitNameOld": "68d5dfdc78d121e89eeae4e577d670028a14a955",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 56.26,
      "commitsBetweenForRepo": 345,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,63 @@\n   void transferBlock(ExtendedBlock block, DatanodeInfo[] xferTargets,\n       StorageType[] xferTargetStorageTypes, String[] xferTargetStorageIDs)\n       throws IOException {\n     BPOfferService bpos \u003d getBPOSForBlock(block);\n     DatanodeRegistration bpReg \u003d getDNRegistrationForBP(block.getBlockPoolId());\n \n     boolean replicaNotExist \u003d false;\n     boolean replicaStateNotFinalized \u003d false;\n     boolean blockFileNotExist \u003d false;\n     boolean lengthTooShort \u003d false;\n \n     try {\n       data.checkBlock(block, block.getNumBytes(), ReplicaState.FINALIZED);\n     } catch (ReplicaNotFoundException e) {\n       replicaNotExist \u003d true;\n     } catch (UnexpectedReplicaStateException e) {\n       replicaStateNotFinalized \u003d true;\n     } catch (FileNotFoundException e) {\n       blockFileNotExist \u003d true;\n     } catch (EOFException e) {\n       lengthTooShort \u003d true;\n     } catch (IOException e) {\n       // The IOException indicates not being able to access block file,\n       // treat it the same here as blockFileNotExist, to trigger \n       // reporting it as a bad block\n       blockFileNotExist \u003d true;      \n     }\n \n     if (replicaNotExist || replicaStateNotFinalized) {\n       String errStr \u003d \"Can\u0027t send invalid block \" + block;\n       LOG.info(errStr);\n       bpos.trySendErrorReport(DatanodeProtocol.INVALID_BLOCK, errStr);\n       return;\n     }\n     if (blockFileNotExist) {\n       // Report back to NN bad block caused by non-existent block file.\n       reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n           + \" because the block file doesn\u0027t exist, or is not accessible\");\n       return;\n     }\n     if (lengthTooShort) {\n       // Check if NN recorded length matches on-disk length \n       // Shorter on-disk len indicates corruption so report NN the corrupt block\n       reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n           + \" because on-disk length \" + data.getLength(block) \n           + \" is shorter than NameNode recorded length \" + block.getNumBytes());\n       return;\n     }\n     \n     int numTargets \u003d xferTargets.length;\n     if (numTargets \u003e 0) {\n       StringBuilder xfersBuilder \u003d new StringBuilder();\n       for (int i \u003d 0; i \u003c numTargets; i++) {\n-        xfersBuilder.append(xferTargets[i]);\n-        xfersBuilder.append(\" \");\n+        xfersBuilder.append(xferTargets[i]).append(\" \");\n       }\n       LOG.info(bpReg + \" Starting thread to transfer \" + \n                block + \" to \" + xfersBuilder);                       \n \n       new Daemon(new DataTransfer(xferTargets, xferTargetStorageTypes,\n           xferTargetStorageIDs, block,\n           BlockConstructionStage.PIPELINE_SETUP_CREATE, \"\")).start();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void transferBlock(ExtendedBlock block, DatanodeInfo[] xferTargets,\n      StorageType[] xferTargetStorageTypes, String[] xferTargetStorageIDs)\n      throws IOException {\n    BPOfferService bpos \u003d getBPOSForBlock(block);\n    DatanodeRegistration bpReg \u003d getDNRegistrationForBP(block.getBlockPoolId());\n\n    boolean replicaNotExist \u003d false;\n    boolean replicaStateNotFinalized \u003d false;\n    boolean blockFileNotExist \u003d false;\n    boolean lengthTooShort \u003d false;\n\n    try {\n      data.checkBlock(block, block.getNumBytes(), ReplicaState.FINALIZED);\n    } catch (ReplicaNotFoundException e) {\n      replicaNotExist \u003d true;\n    } catch (UnexpectedReplicaStateException e) {\n      replicaStateNotFinalized \u003d true;\n    } catch (FileNotFoundException e) {\n      blockFileNotExist \u003d true;\n    } catch (EOFException e) {\n      lengthTooShort \u003d true;\n    } catch (IOException e) {\n      // The IOException indicates not being able to access block file,\n      // treat it the same here as blockFileNotExist, to trigger \n      // reporting it as a bad block\n      blockFileNotExist \u003d true;      \n    }\n\n    if (replicaNotExist || replicaStateNotFinalized) {\n      String errStr \u003d \"Can\u0027t send invalid block \" + block;\n      LOG.info(errStr);\n      bpos.trySendErrorReport(DatanodeProtocol.INVALID_BLOCK, errStr);\n      return;\n    }\n    if (blockFileNotExist) {\n      // Report back to NN bad block caused by non-existent block file.\n      reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n          + \" because the block file doesn\u0027t exist, or is not accessible\");\n      return;\n    }\n    if (lengthTooShort) {\n      // Check if NN recorded length matches on-disk length \n      // Shorter on-disk len indicates corruption so report NN the corrupt block\n      reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n          + \" because on-disk length \" + data.getLength(block) \n          + \" is shorter than NameNode recorded length \" + block.getNumBytes());\n      return;\n    }\n    \n    int numTargets \u003d xferTargets.length;\n    if (numTargets \u003e 0) {\n      StringBuilder xfersBuilder \u003d new StringBuilder();\n      for (int i \u003d 0; i \u003c numTargets; i++) {\n        xfersBuilder.append(xferTargets[i]).append(\" \");\n      }\n      LOG.info(bpReg + \" Starting thread to transfer \" + \n               block + \" to \" + xfersBuilder);                       \n\n      new Daemon(new DataTransfer(xferTargets, xferTargetStorageTypes,\n          xferTargetStorageIDs, block,\n          BlockConstructionStage.PIPELINE_SETUP_CREATE, \"\")).start();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "dfcb331ba3516264398121c9f23af3a79c0509cc": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-13076: [SPS]: Addendum. Resolve conflicts after rebasing branch to trunk. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "dfcb331ba3516264398121c9f23af3a79c0509cc",
      "commitAuthor": "Rakesh Radhakrishnan",
      "diff": "@@ -0,0 +1,64 @@\n+  void transferBlock(ExtendedBlock block, DatanodeInfo[] xferTargets,\n+      StorageType[] xferTargetStorageTypes, String[] xferTargetStorageIDs)\n+      throws IOException {\n+    BPOfferService bpos \u003d getBPOSForBlock(block);\n+    DatanodeRegistration bpReg \u003d getDNRegistrationForBP(block.getBlockPoolId());\n+\n+    boolean replicaNotExist \u003d false;\n+    boolean replicaStateNotFinalized \u003d false;\n+    boolean blockFileNotExist \u003d false;\n+    boolean lengthTooShort \u003d false;\n+\n+    try {\n+      data.checkBlock(block, block.getNumBytes(), ReplicaState.FINALIZED);\n+    } catch (ReplicaNotFoundException e) {\n+      replicaNotExist \u003d true;\n+    } catch (UnexpectedReplicaStateException e) {\n+      replicaStateNotFinalized \u003d true;\n+    } catch (FileNotFoundException e) {\n+      blockFileNotExist \u003d true;\n+    } catch (EOFException e) {\n+      lengthTooShort \u003d true;\n+    } catch (IOException e) {\n+      // The IOException indicates not being able to access block file,\n+      // treat it the same here as blockFileNotExist, to trigger \n+      // reporting it as a bad block\n+      blockFileNotExist \u003d true;      \n+    }\n+\n+    if (replicaNotExist || replicaStateNotFinalized) {\n+      String errStr \u003d \"Can\u0027t send invalid block \" + block;\n+      LOG.info(errStr);\n+      bpos.trySendErrorReport(DatanodeProtocol.INVALID_BLOCK, errStr);\n+      return;\n+    }\n+    if (blockFileNotExist) {\n+      // Report back to NN bad block caused by non-existent block file.\n+      reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n+          + \" because the block file doesn\u0027t exist, or is not accessible\");\n+      return;\n+    }\n+    if (lengthTooShort) {\n+      // Check if NN recorded length matches on-disk length \n+      // Shorter on-disk len indicates corruption so report NN the corrupt block\n+      reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n+          + \" because on-disk length \" + data.getLength(block) \n+          + \" is shorter than NameNode recorded length \" + block.getNumBytes());\n+      return;\n+    }\n+    \n+    int numTargets \u003d xferTargets.length;\n+    if (numTargets \u003e 0) {\n+      StringBuilder xfersBuilder \u003d new StringBuilder();\n+      for (int i \u003d 0; i \u003c numTargets; i++) {\n+        xfersBuilder.append(xferTargets[i]);\n+        xfersBuilder.append(\" \");\n+      }\n+      LOG.info(bpReg + \" Starting thread to transfer \" + \n+               block + \" to \" + xfersBuilder);                       \n+\n+      new Daemon(new DataTransfer(xferTargets, xferTargetStorageTypes,\n+          xferTargetStorageIDs, block,\n+          BlockConstructionStage.PIPELINE_SETUP_CREATE, \"\")).start();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void transferBlock(ExtendedBlock block, DatanodeInfo[] xferTargets,\n      StorageType[] xferTargetStorageTypes, String[] xferTargetStorageIDs)\n      throws IOException {\n    BPOfferService bpos \u003d getBPOSForBlock(block);\n    DatanodeRegistration bpReg \u003d getDNRegistrationForBP(block.getBlockPoolId());\n\n    boolean replicaNotExist \u003d false;\n    boolean replicaStateNotFinalized \u003d false;\n    boolean blockFileNotExist \u003d false;\n    boolean lengthTooShort \u003d false;\n\n    try {\n      data.checkBlock(block, block.getNumBytes(), ReplicaState.FINALIZED);\n    } catch (ReplicaNotFoundException e) {\n      replicaNotExist \u003d true;\n    } catch (UnexpectedReplicaStateException e) {\n      replicaStateNotFinalized \u003d true;\n    } catch (FileNotFoundException e) {\n      blockFileNotExist \u003d true;\n    } catch (EOFException e) {\n      lengthTooShort \u003d true;\n    } catch (IOException e) {\n      // The IOException indicates not being able to access block file,\n      // treat it the same here as blockFileNotExist, to trigger \n      // reporting it as a bad block\n      blockFileNotExist \u003d true;      \n    }\n\n    if (replicaNotExist || replicaStateNotFinalized) {\n      String errStr \u003d \"Can\u0027t send invalid block \" + block;\n      LOG.info(errStr);\n      bpos.trySendErrorReport(DatanodeProtocol.INVALID_BLOCK, errStr);\n      return;\n    }\n    if (blockFileNotExist) {\n      // Report back to NN bad block caused by non-existent block file.\n      reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n          + \" because the block file doesn\u0027t exist, or is not accessible\");\n      return;\n    }\n    if (lengthTooShort) {\n      // Check if NN recorded length matches on-disk length \n      // Shorter on-disk len indicates corruption so report NN the corrupt block\n      reportBadBlock(bpos, block, \"Can\u0027t replicate block \" + block\n          + \" because on-disk length \" + data.getLength(block) \n          + \" is shorter than NameNode recorded length \" + block.getNumBytes());\n      return;\n    }\n    \n    int numTargets \u003d xferTargets.length;\n    if (numTargets \u003e 0) {\n      StringBuilder xfersBuilder \u003d new StringBuilder();\n      for (int i \u003d 0; i \u003c numTargets; i++) {\n        xfersBuilder.append(xferTargets[i]);\n        xfersBuilder.append(\" \");\n      }\n      LOG.info(bpReg + \" Starting thread to transfer \" + \n               block + \" to \" + xfersBuilder);                       \n\n      new Daemon(new DataTransfer(xferTargets, xferTargetStorageTypes,\n          xferTargetStorageIDs, block,\n          BlockConstructionStage.PIPELINE_SETUP_CREATE, \"\")).start();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
    }
  }
}