{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FiCaSchedulerApp.java",
  "functionName": "accept",
  "functionId": "accept___cluster-Resource__request-ResourceCommitRequest__FiCaSchedulerApp,FiCaSchedulerNode____checkPending-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
  "functionStartLine": 428,
  "functionEndLine": 551,
  "numCommitsSeen": 169,
  "timeTaken": 7335,
  "changeHistory": [
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "0a71bf145293adbd3728525ab4c36c08d51377d3",
    "88d8d3f40b2923fab23a933bce1cd2e9c320ae84",
    "b26e30ab1655a8cdf369862a5512db5c2a88ec46",
    "a957f1c60e1308d1d70a1803381994f59949c5f8",
    "0d781dd03b979d65de94978071b2faa55005b34a",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621",
    "f64cfeaf61ec65a465decdd8215f567d4e6677a9",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c"
  ],
  "changeHistoryShort": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "0a71bf145293adbd3728525ab4c36c08d51377d3": "Ybodychange",
    "88d8d3f40b2923fab23a933bce1cd2e9c320ae84": "Ymultichange(Yparameterchange,Ybodychange)",
    "b26e30ab1655a8cdf369862a5512db5c2a88ec46": "Ybodychange",
    "a957f1c60e1308d1d70a1803381994f59949c5f8": "Ybodychange",
    "0d781dd03b979d65de94978071b2faa55005b34a": "Ybodychange",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": "Ybodychange",
    "f64cfeaf61ec65a465decdd8215f567d4e6677a9": "Ybodychange",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": "Ybodychange",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,124 @@\n   public boolean accept(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request,\n       boolean checkPending) {\n     ContainerRequest containerRequest \u003d null;\n     boolean reReservation \u003d false;\n \n+    readLock.lock();\n     try {\n-      readLock.lock();\n \n       // First make sure no container in release list in final state\n       if (anyContainerInFinalState(request)) {\n         return false;\n       }\n \n       // TODO, make sure all scheduler nodes are existed\n       // TODO, make sure all node labels are not changed\n \n       if (request.anythingAllocatedOrReserved()) {\n         /*\n          * 1) If this is a newly allocated container, check if the node is reserved\n          *    / not-reserved by any other application\n          * 2) If this is a newly reserved container, check if the node is reserved or not\n          */\n         // Assume we have only one container allocated or reserved\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         // Make sure node is in RUNNING state\n         if (schedulerContainer.getSchedulerNode().getRMNode().getState()\n             !\u003d NodeState.RUNNING) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Failed to accept this proposal because node \"\n                 + schedulerContainer.getSchedulerNode().getNodeID() + \" is in \"\n                 + schedulerContainer.getSchedulerNode().getRMNode().getState()\n                 + \" state (not RUNNING)\");\n           }\n           return false;\n         }\n         if (schedulerContainer.isAllocated()) {\n           // When allocate a new container\n           containerRequest \u003d\n               schedulerContainer.getRmContainer().getContainerRequest();\n \n           // Check pending resource request\n           if (checkPending \u0026\u0026\n               !appSchedulingInfo.checkAllocation(\n                   allocation.getAllocationLocalityType(),\n                   schedulerContainer.getSchedulerNode(),\n                   schedulerContainer.getSchedulerRequestKey())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                   .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                   .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                   .getSchedulerRequestKey() + \", application\u003d\"\n                   + getApplicationAttemptId());\n             }\n \n             return false;\n           }\n \n           // Common part of check container allocation regardless if it is a\n           // increase container or regular container\n           if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n             return false;\n           }\n         } else {\n           // Container reserved first time will be NEW, after the container\n           // accepted \u0026 confirmed, it will become RESERVED state\n           if (schedulerContainer.getRmContainer().getState()\n               \u003d\u003d RMContainerState.RESERVED) {\n             // Check if node currently reserved by other application, there may\n             // be some outdated proposals in async-scheduling environment\n             if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                 .getSchedulerNode().getReservedContainer()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to re-reserve a container, but node \"\n                     + schedulerContainer.getSchedulerNode()\n                     + \" is already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer());\n               }\n               return false;\n             }\n             // Set reReservation \u003d\u003d true\n             reReservation \u003d true;\n           } else {\n             // When reserve a resource (state \u003d\u003d NEW is for new container,\n             // state \u003d\u003d RUNNING is for increase container).\n             // Just check if the node is not already reserved by someone\n             if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                 !\u003d null) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to reserve a container, but the node is \"\n                     + \"already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n           }\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     // Skip check parent if this is a re-reservation container\n     boolean accepted \u003d true;\n     if (!reReservation) {\n       // Check parent if anything allocated or reserved\n       if (request.anythingAllocatedOrReserved()) {\n         accepted \u003d getCSLeafQueue().accept(cluster, request);\n       }\n     }\n \n     // When rejected, recover resource requests for this app\n     if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n       recoverResourceRequestsForContainer(containerRequest);\n     }\n \n     return accepted;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request,\n      boolean checkPending) {\n    ContainerRequest containerRequest \u003d null;\n    boolean reReservation \u003d false;\n\n    readLock.lock();\n    try {\n\n      // First make sure no container in release list in final state\n      if (anyContainerInFinalState(request)) {\n        return false;\n      }\n\n      // TODO, make sure all scheduler nodes are existed\n      // TODO, make sure all node labels are not changed\n\n      if (request.anythingAllocatedOrReserved()) {\n        /*\n         * 1) If this is a newly allocated container, check if the node is reserved\n         *    / not-reserved by any other application\n         * 2) If this is a newly reserved container, check if the node is reserved or not\n         */\n        // Assume we have only one container allocated or reserved\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        // Make sure node is in RUNNING state\n        if (schedulerContainer.getSchedulerNode().getRMNode().getState()\n            !\u003d NodeState.RUNNING) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Failed to accept this proposal because node \"\n                + schedulerContainer.getSchedulerNode().getNodeID() + \" is in \"\n                + schedulerContainer.getSchedulerNode().getRMNode().getState()\n                + \" state (not RUNNING)\");\n          }\n          return false;\n        }\n        if (schedulerContainer.isAllocated()) {\n          // When allocate a new container\n          containerRequest \u003d\n              schedulerContainer.getRmContainer().getContainerRequest();\n\n          // Check pending resource request\n          if (checkPending \u0026\u0026\n              !appSchedulingInfo.checkAllocation(\n                  allocation.getAllocationLocalityType(),\n                  schedulerContainer.getSchedulerNode(),\n                  schedulerContainer.getSchedulerRequestKey())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                  .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                  .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                  .getSchedulerRequestKey() + \", application\u003d\"\n                  + getApplicationAttemptId());\n            }\n\n            return false;\n          }\n\n          // Common part of check container allocation regardless if it is a\n          // increase container or regular container\n          if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n            return false;\n          }\n        } else {\n          // Container reserved first time will be NEW, after the container\n          // accepted \u0026 confirmed, it will become RESERVED state\n          if (schedulerContainer.getRmContainer().getState()\n              \u003d\u003d RMContainerState.RESERVED) {\n            // Check if node currently reserved by other application, there may\n            // be some outdated proposals in async-scheduling environment\n            if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                .getSchedulerNode().getReservedContainer()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to re-reserve a container, but node \"\n                    + schedulerContainer.getSchedulerNode()\n                    + \" is already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer());\n              }\n              return false;\n            }\n            // Set reReservation \u003d\u003d true\n            reReservation \u003d true;\n          } else {\n            // When reserve a resource (state \u003d\u003d NEW is for new container,\n            // state \u003d\u003d RUNNING is for increase container).\n            // Just check if the node is not already reserved by someone\n            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                !\u003d null) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to reserve a container, but the node is \"\n                    + \"already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n          }\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    // Skip check parent if this is a re-reservation container\n    boolean accepted \u003d true;\n    if (!reReservation) {\n      // Check parent if anything allocated or reserved\n      if (request.anythingAllocatedOrReserved()) {\n        accepted \u003d getCSLeafQueue().accept(cluster, request);\n      }\n    }\n\n    // When rejected, recover resource requests for this app\n    if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n      recoverResourceRequestsForContainer(containerRequest);\n    }\n\n    return accepted;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "0a71bf145293adbd3728525ab4c36c08d51377d3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8575. Avoid committing allocation proposal to unavailable nodes in async scheduling. Contributed by Tao Yang.\n",
      "commitDate": "09/08/18 11:37 PM",
      "commitName": "0a71bf145293adbd3728525ab4c36c08d51377d3",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "25/07/18 2:35 AM",
      "commitNameOld": "5be9f4a5d05c9cb99348719fe35626b1de3055db",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 15.88,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,124 @@\n   public boolean accept(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request,\n       boolean checkPending) {\n     ContainerRequest containerRequest \u003d null;\n     boolean reReservation \u003d false;\n \n     try {\n       readLock.lock();\n \n       // First make sure no container in release list in final state\n       if (anyContainerInFinalState(request)) {\n         return false;\n       }\n \n       // TODO, make sure all scheduler nodes are existed\n       // TODO, make sure all node labels are not changed\n \n       if (request.anythingAllocatedOrReserved()) {\n         /*\n          * 1) If this is a newly allocated container, check if the node is reserved\n          *    / not-reserved by any other application\n          * 2) If this is a newly reserved container, check if the node is reserved or not\n          */\n         // Assume we have only one container allocated or reserved\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n+        // Make sure node is in RUNNING state\n+        if (schedulerContainer.getSchedulerNode().getRMNode().getState()\n+            !\u003d NodeState.RUNNING) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Failed to accept this proposal because node \"\n+                + schedulerContainer.getSchedulerNode().getNodeID() + \" is in \"\n+                + schedulerContainer.getSchedulerNode().getRMNode().getState()\n+                + \" state (not RUNNING)\");\n+          }\n+          return false;\n+        }\n         if (schedulerContainer.isAllocated()) {\n           // When allocate a new container\n           containerRequest \u003d\n               schedulerContainer.getRmContainer().getContainerRequest();\n \n           // Check pending resource request\n           if (checkPending \u0026\u0026\n               !appSchedulingInfo.checkAllocation(\n                   allocation.getAllocationLocalityType(),\n                   schedulerContainer.getSchedulerNode(),\n                   schedulerContainer.getSchedulerRequestKey())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                   .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                   .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                   .getSchedulerRequestKey() + \", application\u003d\"\n                   + getApplicationAttemptId());\n             }\n \n             return false;\n           }\n \n           // Common part of check container allocation regardless if it is a\n           // increase container or regular container\n           if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n             return false;\n           }\n         } else {\n           // Container reserved first time will be NEW, after the container\n           // accepted \u0026 confirmed, it will become RESERVED state\n           if (schedulerContainer.getRmContainer().getState()\n               \u003d\u003d RMContainerState.RESERVED) {\n             // Check if node currently reserved by other application, there may\n             // be some outdated proposals in async-scheduling environment\n             if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                 .getSchedulerNode().getReservedContainer()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to re-reserve a container, but node \"\n                     + schedulerContainer.getSchedulerNode()\n                     + \" is already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer());\n               }\n               return false;\n             }\n             // Set reReservation \u003d\u003d true\n             reReservation \u003d true;\n           } else {\n             // When reserve a resource (state \u003d\u003d NEW is for new container,\n             // state \u003d\u003d RUNNING is for increase container).\n             // Just check if the node is not already reserved by someone\n             if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                 !\u003d null) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to reserve a container, but the node is \"\n                     + \"already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n           }\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     // Skip check parent if this is a re-reservation container\n     boolean accepted \u003d true;\n     if (!reReservation) {\n       // Check parent if anything allocated or reserved\n       if (request.anythingAllocatedOrReserved()) {\n         accepted \u003d getCSLeafQueue().accept(cluster, request);\n       }\n     }\n \n     // When rejected, recover resource requests for this app\n     if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n       recoverResourceRequestsForContainer(containerRequest);\n     }\n \n     return accepted;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request,\n      boolean checkPending) {\n    ContainerRequest containerRequest \u003d null;\n    boolean reReservation \u003d false;\n\n    try {\n      readLock.lock();\n\n      // First make sure no container in release list in final state\n      if (anyContainerInFinalState(request)) {\n        return false;\n      }\n\n      // TODO, make sure all scheduler nodes are existed\n      // TODO, make sure all node labels are not changed\n\n      if (request.anythingAllocatedOrReserved()) {\n        /*\n         * 1) If this is a newly allocated container, check if the node is reserved\n         *    / not-reserved by any other application\n         * 2) If this is a newly reserved container, check if the node is reserved or not\n         */\n        // Assume we have only one container allocated or reserved\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        // Make sure node is in RUNNING state\n        if (schedulerContainer.getSchedulerNode().getRMNode().getState()\n            !\u003d NodeState.RUNNING) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Failed to accept this proposal because node \"\n                + schedulerContainer.getSchedulerNode().getNodeID() + \" is in \"\n                + schedulerContainer.getSchedulerNode().getRMNode().getState()\n                + \" state (not RUNNING)\");\n          }\n          return false;\n        }\n        if (schedulerContainer.isAllocated()) {\n          // When allocate a new container\n          containerRequest \u003d\n              schedulerContainer.getRmContainer().getContainerRequest();\n\n          // Check pending resource request\n          if (checkPending \u0026\u0026\n              !appSchedulingInfo.checkAllocation(\n                  allocation.getAllocationLocalityType(),\n                  schedulerContainer.getSchedulerNode(),\n                  schedulerContainer.getSchedulerRequestKey())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                  .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                  .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                  .getSchedulerRequestKey() + \", application\u003d\"\n                  + getApplicationAttemptId());\n            }\n\n            return false;\n          }\n\n          // Common part of check container allocation regardless if it is a\n          // increase container or regular container\n          if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n            return false;\n          }\n        } else {\n          // Container reserved first time will be NEW, after the container\n          // accepted \u0026 confirmed, it will become RESERVED state\n          if (schedulerContainer.getRmContainer().getState()\n              \u003d\u003d RMContainerState.RESERVED) {\n            // Check if node currently reserved by other application, there may\n            // be some outdated proposals in async-scheduling environment\n            if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                .getSchedulerNode().getReservedContainer()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to re-reserve a container, but node \"\n                    + schedulerContainer.getSchedulerNode()\n                    + \" is already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer());\n              }\n              return false;\n            }\n            // Set reReservation \u003d\u003d true\n            reReservation \u003d true;\n          } else {\n            // When reserve a resource (state \u003d\u003d NEW is for new container,\n            // state \u003d\u003d RUNNING is for increase container).\n            // Just check if the node is not already reserved by someone\n            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                !\u003d null) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to reserve a container, but the node is \"\n                    + \"already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n          }\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    // Skip check parent if this is a re-reservation container\n    boolean accepted \u003d true;\n    if (!reReservation) {\n      // Check parent if anything allocated or reserved\n      if (request.anythingAllocatedOrReserved()) {\n        accepted \u003d getCSLeafQueue().accept(cluster, request);\n      }\n    }\n\n    // When rejected, recover resource requests for this app\n    if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n      recoverResourceRequestsForContainer(containerRequest);\n    }\n\n    return accepted;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "88d8d3f40b2923fab23a933bce1cd2e9c320ae84": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7670. Modifications to the ResourceScheduler API to support SchedulingRequests. (asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "88d8d3f40b2923fab23a933bce1cd2e9c320ae84",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7670. Modifications to the ResourceScheduler API to support SchedulingRequests. (asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "88d8d3f40b2923fab23a933bce1cd2e9c320ae84",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "09/01/18 4:27 AM",
          "commitNameOld": "b26e30ab1655a8cdf369862a5512db5c2a88ec46",
          "commitAuthorOld": "bibinchundatt",
          "daysBetweenCommits": 21.88,
          "commitsBetweenForRepo": 128,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,113 @@\n   public boolean accept(Resource cluster,\n-      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n+      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request,\n+      boolean checkPending) {\n     ContainerRequest containerRequest \u003d null;\n     boolean reReservation \u003d false;\n \n     try {\n       readLock.lock();\n \n       // First make sure no container in release list in final state\n       if (anyContainerInFinalState(request)) {\n         return false;\n       }\n \n       // TODO, make sure all scheduler nodes are existed\n       // TODO, make sure all node labels are not changed\n \n       if (request.anythingAllocatedOrReserved()) {\n         /*\n          * 1) If this is a newly allocated container, check if the node is reserved\n          *    / not-reserved by any other application\n          * 2) If this is a newly reserved container, check if the node is reserved or not\n          */\n         // Assume we have only one container allocated or reserved\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         if (schedulerContainer.isAllocated()) {\n           // When allocate a new container\n           containerRequest \u003d\n               schedulerContainer.getRmContainer().getContainerRequest();\n \n           // Check pending resource request\n-          if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n-              schedulerContainer.getSchedulerNode(),\n-              schedulerContainer.getSchedulerRequestKey())) {\n+          if (checkPending \u0026\u0026\n+              !appSchedulingInfo.checkAllocation(\n+                  allocation.getAllocationLocalityType(),\n+                  schedulerContainer.getSchedulerNode(),\n+                  schedulerContainer.getSchedulerRequestKey())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                   .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                   .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                   .getSchedulerRequestKey() + \", application\u003d\"\n                   + getApplicationAttemptId());\n             }\n \n             return false;\n           }\n \n           // Common part of check container allocation regardless if it is a\n           // increase container or regular container\n           if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n             return false;\n           }\n         } else {\n           // Container reserved first time will be NEW, after the container\n           // accepted \u0026 confirmed, it will become RESERVED state\n           if (schedulerContainer.getRmContainer().getState()\n               \u003d\u003d RMContainerState.RESERVED) {\n             // Check if node currently reserved by other application, there may\n             // be some outdated proposals in async-scheduling environment\n             if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                 .getSchedulerNode().getReservedContainer()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to re-reserve a container, but node \"\n                     + schedulerContainer.getSchedulerNode()\n                     + \" is already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer());\n               }\n               return false;\n             }\n             // Set reReservation \u003d\u003d true\n             reReservation \u003d true;\n           } else {\n             // When reserve a resource (state \u003d\u003d NEW is for new container,\n             // state \u003d\u003d RUNNING is for increase container).\n             // Just check if the node is not already reserved by someone\n             if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                 !\u003d null) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to reserve a container, but the node is \"\n                     + \"already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n           }\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     // Skip check parent if this is a re-reservation container\n     boolean accepted \u003d true;\n     if (!reReservation) {\n       // Check parent if anything allocated or reserved\n       if (request.anythingAllocatedOrReserved()) {\n         accepted \u003d getCSLeafQueue().accept(cluster, request);\n       }\n     }\n \n     // When rejected, recover resource requests for this app\n     if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n       recoverResourceRequestsForContainer(containerRequest);\n     }\n \n     return accepted;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request,\n      boolean checkPending) {\n    ContainerRequest containerRequest \u003d null;\n    boolean reReservation \u003d false;\n\n    try {\n      readLock.lock();\n\n      // First make sure no container in release list in final state\n      if (anyContainerInFinalState(request)) {\n        return false;\n      }\n\n      // TODO, make sure all scheduler nodes are existed\n      // TODO, make sure all node labels are not changed\n\n      if (request.anythingAllocatedOrReserved()) {\n        /*\n         * 1) If this is a newly allocated container, check if the node is reserved\n         *    / not-reserved by any other application\n         * 2) If this is a newly reserved container, check if the node is reserved or not\n         */\n        // Assume we have only one container allocated or reserved\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        if (schedulerContainer.isAllocated()) {\n          // When allocate a new container\n          containerRequest \u003d\n              schedulerContainer.getRmContainer().getContainerRequest();\n\n          // Check pending resource request\n          if (checkPending \u0026\u0026\n              !appSchedulingInfo.checkAllocation(\n                  allocation.getAllocationLocalityType(),\n                  schedulerContainer.getSchedulerNode(),\n                  schedulerContainer.getSchedulerRequestKey())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                  .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                  .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                  .getSchedulerRequestKey() + \", application\u003d\"\n                  + getApplicationAttemptId());\n            }\n\n            return false;\n          }\n\n          // Common part of check container allocation regardless if it is a\n          // increase container or regular container\n          if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n            return false;\n          }\n        } else {\n          // Container reserved first time will be NEW, after the container\n          // accepted \u0026 confirmed, it will become RESERVED state\n          if (schedulerContainer.getRmContainer().getState()\n              \u003d\u003d RMContainerState.RESERVED) {\n            // Check if node currently reserved by other application, there may\n            // be some outdated proposals in async-scheduling environment\n            if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                .getSchedulerNode().getReservedContainer()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to re-reserve a container, but node \"\n                    + schedulerContainer.getSchedulerNode()\n                    + \" is already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer());\n              }\n              return false;\n            }\n            // Set reReservation \u003d\u003d true\n            reReservation \u003d true;\n          } else {\n            // When reserve a resource (state \u003d\u003d NEW is for new container,\n            // state \u003d\u003d RUNNING is for increase container).\n            // Just check if the node is not already reserved by someone\n            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                !\u003d null) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to reserve a container, but the node is \"\n                    + \"already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n          }\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    // Skip check parent if this is a re-reservation container\n    boolean accepted \u003d true;\n    if (!reReservation) {\n      // Check parent if anything allocated or reserved\n      if (request.anythingAllocatedOrReserved()) {\n        accepted \u003d getCSLeafQueue().accept(cluster, request);\n      }\n    }\n\n    // When rejected, recover resource requests for this app\n    if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n      recoverResourceRequestsForContainer(containerRequest);\n    }\n\n    return accepted;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {
            "oldValue": "[cluster-Resource, request-ResourceCommitRequest\u003cFiCaSchedulerApp,FiCaSchedulerNode\u003e]",
            "newValue": "[cluster-Resource, request-ResourceCommitRequest\u003cFiCaSchedulerApp,FiCaSchedulerNode\u003e, checkPending-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7670. Modifications to the ResourceScheduler API to support SchedulingRequests. (asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "88d8d3f40b2923fab23a933bce1cd2e9c320ae84",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "09/01/18 4:27 AM",
          "commitNameOld": "b26e30ab1655a8cdf369862a5512db5c2a88ec46",
          "commitAuthorOld": "bibinchundatt",
          "daysBetweenCommits": 21.88,
          "commitsBetweenForRepo": 128,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,113 @@\n   public boolean accept(Resource cluster,\n-      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n+      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request,\n+      boolean checkPending) {\n     ContainerRequest containerRequest \u003d null;\n     boolean reReservation \u003d false;\n \n     try {\n       readLock.lock();\n \n       // First make sure no container in release list in final state\n       if (anyContainerInFinalState(request)) {\n         return false;\n       }\n \n       // TODO, make sure all scheduler nodes are existed\n       // TODO, make sure all node labels are not changed\n \n       if (request.anythingAllocatedOrReserved()) {\n         /*\n          * 1) If this is a newly allocated container, check if the node is reserved\n          *    / not-reserved by any other application\n          * 2) If this is a newly reserved container, check if the node is reserved or not\n          */\n         // Assume we have only one container allocated or reserved\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         if (schedulerContainer.isAllocated()) {\n           // When allocate a new container\n           containerRequest \u003d\n               schedulerContainer.getRmContainer().getContainerRequest();\n \n           // Check pending resource request\n-          if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n-              schedulerContainer.getSchedulerNode(),\n-              schedulerContainer.getSchedulerRequestKey())) {\n+          if (checkPending \u0026\u0026\n+              !appSchedulingInfo.checkAllocation(\n+                  allocation.getAllocationLocalityType(),\n+                  schedulerContainer.getSchedulerNode(),\n+                  schedulerContainer.getSchedulerRequestKey())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                   .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                   .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                   .getSchedulerRequestKey() + \", application\u003d\"\n                   + getApplicationAttemptId());\n             }\n \n             return false;\n           }\n \n           // Common part of check container allocation regardless if it is a\n           // increase container or regular container\n           if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n             return false;\n           }\n         } else {\n           // Container reserved first time will be NEW, after the container\n           // accepted \u0026 confirmed, it will become RESERVED state\n           if (schedulerContainer.getRmContainer().getState()\n               \u003d\u003d RMContainerState.RESERVED) {\n             // Check if node currently reserved by other application, there may\n             // be some outdated proposals in async-scheduling environment\n             if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                 .getSchedulerNode().getReservedContainer()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to re-reserve a container, but node \"\n                     + schedulerContainer.getSchedulerNode()\n                     + \" is already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer());\n               }\n               return false;\n             }\n             // Set reReservation \u003d\u003d true\n             reReservation \u003d true;\n           } else {\n             // When reserve a resource (state \u003d\u003d NEW is for new container,\n             // state \u003d\u003d RUNNING is for increase container).\n             // Just check if the node is not already reserved by someone\n             if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                 !\u003d null) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to reserve a container, but the node is \"\n                     + \"already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n           }\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     // Skip check parent if this is a re-reservation container\n     boolean accepted \u003d true;\n     if (!reReservation) {\n       // Check parent if anything allocated or reserved\n       if (request.anythingAllocatedOrReserved()) {\n         accepted \u003d getCSLeafQueue().accept(cluster, request);\n       }\n     }\n \n     // When rejected, recover resource requests for this app\n     if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n       recoverResourceRequestsForContainer(containerRequest);\n     }\n \n     return accepted;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request,\n      boolean checkPending) {\n    ContainerRequest containerRequest \u003d null;\n    boolean reReservation \u003d false;\n\n    try {\n      readLock.lock();\n\n      // First make sure no container in release list in final state\n      if (anyContainerInFinalState(request)) {\n        return false;\n      }\n\n      // TODO, make sure all scheduler nodes are existed\n      // TODO, make sure all node labels are not changed\n\n      if (request.anythingAllocatedOrReserved()) {\n        /*\n         * 1) If this is a newly allocated container, check if the node is reserved\n         *    / not-reserved by any other application\n         * 2) If this is a newly reserved container, check if the node is reserved or not\n         */\n        // Assume we have only one container allocated or reserved\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        if (schedulerContainer.isAllocated()) {\n          // When allocate a new container\n          containerRequest \u003d\n              schedulerContainer.getRmContainer().getContainerRequest();\n\n          // Check pending resource request\n          if (checkPending \u0026\u0026\n              !appSchedulingInfo.checkAllocation(\n                  allocation.getAllocationLocalityType(),\n                  schedulerContainer.getSchedulerNode(),\n                  schedulerContainer.getSchedulerRequestKey())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                  .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                  .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                  .getSchedulerRequestKey() + \", application\u003d\"\n                  + getApplicationAttemptId());\n            }\n\n            return false;\n          }\n\n          // Common part of check container allocation regardless if it is a\n          // increase container or regular container\n          if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n            return false;\n          }\n        } else {\n          // Container reserved first time will be NEW, after the container\n          // accepted \u0026 confirmed, it will become RESERVED state\n          if (schedulerContainer.getRmContainer().getState()\n              \u003d\u003d RMContainerState.RESERVED) {\n            // Check if node currently reserved by other application, there may\n            // be some outdated proposals in async-scheduling environment\n            if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                .getSchedulerNode().getReservedContainer()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to re-reserve a container, but node \"\n                    + schedulerContainer.getSchedulerNode()\n                    + \" is already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer());\n              }\n              return false;\n            }\n            // Set reReservation \u003d\u003d true\n            reReservation \u003d true;\n          } else {\n            // When reserve a resource (state \u003d\u003d NEW is for new container,\n            // state \u003d\u003d RUNNING is for increase container).\n            // Just check if the node is not already reserved by someone\n            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                !\u003d null) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to reserve a container, but the node is \"\n                    + \"already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n          }\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    // Skip check parent if this is a re-reservation container\n    boolean accepted \u003d true;\n    if (!reReservation) {\n      // Check parent if anything allocated or reserved\n      if (request.anythingAllocatedOrReserved()) {\n        accepted \u003d getCSLeafQueue().accept(cluster, request);\n      }\n    }\n\n    // When rejected, recover resource requests for this app\n    if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n      recoverResourceRequestsForContainer(containerRequest);\n    }\n\n    return accepted;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {}
        }
      ]
    },
    "b26e30ab1655a8cdf369862a5512db5c2a88ec46": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7508. NPE in FiCaSchedulerApp when debug log enabled in async-scheduling mode. Contributed by Tao Yang.\n",
      "commitDate": "09/01/18 4:27 AM",
      "commitName": "b26e30ab1655a8cdf369862a5512db5c2a88ec46",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "07/01/18 9:09 PM",
      "commitNameOld": "c2d6fa36560d122ff24dd7db84f68f4ba3fb8123",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 1.3,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   public boolean accept(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n     ContainerRequest containerRequest \u003d null;\n     boolean reReservation \u003d false;\n \n     try {\n       readLock.lock();\n \n       // First make sure no container in release list in final state\n       if (anyContainerInFinalState(request)) {\n         return false;\n       }\n \n       // TODO, make sure all scheduler nodes are existed\n       // TODO, make sure all node labels are not changed\n \n       if (request.anythingAllocatedOrReserved()) {\n         /*\n          * 1) If this is a newly allocated container, check if the node is reserved\n          *    / not-reserved by any other application\n          * 2) If this is a newly reserved container, check if the node is reserved or not\n          */\n         // Assume we have only one container allocated or reserved\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         if (schedulerContainer.isAllocated()) {\n           // When allocate a new container\n           containerRequest \u003d\n               schedulerContainer.getRmContainer().getContainerRequest();\n \n           // Check pending resource request\n           if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getSchedulerRequestKey())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                   .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                   .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                   .getSchedulerRequestKey() + \", application\u003d\"\n                   + getApplicationAttemptId());\n             }\n \n             return false;\n           }\n \n           // Common part of check container allocation regardless if it is a\n           // increase container or regular container\n           if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n             return false;\n           }\n         } else {\n           // Container reserved first time will be NEW, after the container\n           // accepted \u0026 confirmed, it will become RESERVED state\n           if (schedulerContainer.getRmContainer().getState()\n               \u003d\u003d RMContainerState.RESERVED) {\n             // Check if node currently reserved by other application, there may\n             // be some outdated proposals in async-scheduling environment\n             if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                 .getSchedulerNode().getReservedContainer()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to re-reserve a container, but node \"\n                     + schedulerContainer.getSchedulerNode()\n-                    + \" is already reserved by another container\"\n+                    + \" is already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n-                    .getReservedContainer().getContainerId());\n+                    .getReservedContainer());\n               }\n               return false;\n             }\n             // Set reReservation \u003d\u003d true\n             reReservation \u003d true;\n           } else {\n             // When reserve a resource (state \u003d\u003d NEW is for new container,\n             // state \u003d\u003d RUNNING is for increase container).\n             // Just check if the node is not already reserved by someone\n             if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                 !\u003d null) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to reserve a container, but the node is \"\n                     + \"already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n           }\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     // Skip check parent if this is a re-reservation container\n     boolean accepted \u003d true;\n     if (!reReservation) {\n       // Check parent if anything allocated or reserved\n       if (request.anythingAllocatedOrReserved()) {\n         accepted \u003d getCSLeafQueue().accept(cluster, request);\n       }\n     }\n \n     // When rejected, recover resource requests for this app\n     if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n       recoverResourceRequestsForContainer(containerRequest);\n     }\n \n     return accepted;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    ContainerRequest containerRequest \u003d null;\n    boolean reReservation \u003d false;\n\n    try {\n      readLock.lock();\n\n      // First make sure no container in release list in final state\n      if (anyContainerInFinalState(request)) {\n        return false;\n      }\n\n      // TODO, make sure all scheduler nodes are existed\n      // TODO, make sure all node labels are not changed\n\n      if (request.anythingAllocatedOrReserved()) {\n        /*\n         * 1) If this is a newly allocated container, check if the node is reserved\n         *    / not-reserved by any other application\n         * 2) If this is a newly reserved container, check if the node is reserved or not\n         */\n        // Assume we have only one container allocated or reserved\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        if (schedulerContainer.isAllocated()) {\n          // When allocate a new container\n          containerRequest \u003d\n              schedulerContainer.getRmContainer().getContainerRequest();\n\n          // Check pending resource request\n          if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getSchedulerRequestKey())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                  .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                  .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                  .getSchedulerRequestKey() + \", application\u003d\"\n                  + getApplicationAttemptId());\n            }\n\n            return false;\n          }\n\n          // Common part of check container allocation regardless if it is a\n          // increase container or regular container\n          if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n            return false;\n          }\n        } else {\n          // Container reserved first time will be NEW, after the container\n          // accepted \u0026 confirmed, it will become RESERVED state\n          if (schedulerContainer.getRmContainer().getState()\n              \u003d\u003d RMContainerState.RESERVED) {\n            // Check if node currently reserved by other application, there may\n            // be some outdated proposals in async-scheduling environment\n            if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                .getSchedulerNode().getReservedContainer()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to re-reserve a container, but node \"\n                    + schedulerContainer.getSchedulerNode()\n                    + \" is already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer());\n              }\n              return false;\n            }\n            // Set reReservation \u003d\u003d true\n            reReservation \u003d true;\n          } else {\n            // When reserve a resource (state \u003d\u003d NEW is for new container,\n            // state \u003d\u003d RUNNING is for increase container).\n            // Just check if the node is not already reserved by someone\n            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                !\u003d null) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to reserve a container, but the node is \"\n                    + \"already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n          }\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    // Skip check parent if this is a re-reservation container\n    boolean accepted \u003d true;\n    if (!reReservation) {\n      // Check parent if anything allocated or reserved\n      if (request.anythingAllocatedOrReserved()) {\n        accepted \u003d getCSLeafQueue().accept(cluster, request);\n      }\n    }\n\n    // When rejected, recover resource requests for this app\n    if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n      recoverResourceRequestsForContainer(containerRequest);\n    }\n\n    return accepted;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "a957f1c60e1308d1d70a1803381994f59949c5f8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7438. Additional changes to make SchedulingPlacementSet agnostic to ResourceRequest / placement algorithm. Contributed by Wangda Tan\n",
      "commitDate": "05/12/17 9:20 AM",
      "commitName": "a957f1c60e1308d1d70a1803381994f59949c5f8",
      "commitAuthor": "Sunil G",
      "commitDateOld": "27/11/17 10:19 AM",
      "commitNameOld": "fedabcad42067ac7dd24de40fab6be2d3485a540",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 7.96,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   public boolean accept(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n-    List\u003cResourceRequest\u003e resourceRequests \u003d null;\n+    ContainerRequest containerRequest \u003d null;\n     boolean reReservation \u003d false;\n \n     try {\n       readLock.lock();\n \n       // First make sure no container in release list in final state\n       if (anyContainerInFinalState(request)) {\n         return false;\n       }\n \n       // TODO, make sure all scheduler nodes are existed\n       // TODO, make sure all node labels are not changed\n \n       if (request.anythingAllocatedOrReserved()) {\n         /*\n          * 1) If this is a newly allocated container, check if the node is reserved\n          *    / not-reserved by any other application\n          * 2) If this is a newly reserved container, check if the node is reserved or not\n          */\n         // Assume we have only one container allocated or reserved\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         if (schedulerContainer.isAllocated()) {\n           // When allocate a new container\n-          resourceRequests \u003d\n-              schedulerContainer.getRmContainer().getResourceRequests();\n+          containerRequest \u003d\n+              schedulerContainer.getRmContainer().getContainerRequest();\n \n           // Check pending resource request\n           if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getSchedulerRequestKey())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                   .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                   .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                   .getSchedulerRequestKey() + \", application\u003d\"\n                   + getApplicationAttemptId());\n             }\n \n             return false;\n           }\n \n           // Common part of check container allocation regardless if it is a\n           // increase container or regular container\n           if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n             return false;\n           }\n         } else {\n           // Container reserved first time will be NEW, after the container\n           // accepted \u0026 confirmed, it will become RESERVED state\n           if (schedulerContainer.getRmContainer().getState()\n               \u003d\u003d RMContainerState.RESERVED) {\n             // Check if node currently reserved by other application, there may\n             // be some outdated proposals in async-scheduling environment\n             if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                 .getSchedulerNode().getReservedContainer()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to re-reserve a container, but node \"\n                     + schedulerContainer.getSchedulerNode()\n                     + \" is already reserved by another container\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n             // Set reReservation \u003d\u003d true\n             reReservation \u003d true;\n           } else {\n             // When reserve a resource (state \u003d\u003d NEW is for new container,\n             // state \u003d\u003d RUNNING is for increase container).\n             // Just check if the node is not already reserved by someone\n             if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                 !\u003d null) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to reserve a container, but the node is \"\n                     + \"already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n           }\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     // Skip check parent if this is a re-reservation container\n     boolean accepted \u003d true;\n     if (!reReservation) {\n       // Check parent if anything allocated or reserved\n       if (request.anythingAllocatedOrReserved()) {\n         accepted \u003d getCSLeafQueue().accept(cluster, request);\n       }\n     }\n \n     // When rejected, recover resource requests for this app\n-    if (!accepted \u0026\u0026 resourceRequests !\u003d null) {\n-      recoverResourceRequestsForContainer(resourceRequests);\n+    if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n+      recoverResourceRequestsForContainer(containerRequest);\n     }\n \n     return accepted;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    ContainerRequest containerRequest \u003d null;\n    boolean reReservation \u003d false;\n\n    try {\n      readLock.lock();\n\n      // First make sure no container in release list in final state\n      if (anyContainerInFinalState(request)) {\n        return false;\n      }\n\n      // TODO, make sure all scheduler nodes are existed\n      // TODO, make sure all node labels are not changed\n\n      if (request.anythingAllocatedOrReserved()) {\n        /*\n         * 1) If this is a newly allocated container, check if the node is reserved\n         *    / not-reserved by any other application\n         * 2) If this is a newly reserved container, check if the node is reserved or not\n         */\n        // Assume we have only one container allocated or reserved\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        if (schedulerContainer.isAllocated()) {\n          // When allocate a new container\n          containerRequest \u003d\n              schedulerContainer.getRmContainer().getContainerRequest();\n\n          // Check pending resource request\n          if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getSchedulerRequestKey())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                  .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                  .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                  .getSchedulerRequestKey() + \", application\u003d\"\n                  + getApplicationAttemptId());\n            }\n\n            return false;\n          }\n\n          // Common part of check container allocation regardless if it is a\n          // increase container or regular container\n          if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n            return false;\n          }\n        } else {\n          // Container reserved first time will be NEW, after the container\n          // accepted \u0026 confirmed, it will become RESERVED state\n          if (schedulerContainer.getRmContainer().getState()\n              \u003d\u003d RMContainerState.RESERVED) {\n            // Check if node currently reserved by other application, there may\n            // be some outdated proposals in async-scheduling environment\n            if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                .getSchedulerNode().getReservedContainer()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to re-reserve a container, but node \"\n                    + schedulerContainer.getSchedulerNode()\n                    + \" is already reserved by another container\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n            // Set reReservation \u003d\u003d true\n            reReservation \u003d true;\n          } else {\n            // When reserve a resource (state \u003d\u003d NEW is for new container,\n            // state \u003d\u003d RUNNING is for increase container).\n            // Just check if the node is not already reserved by someone\n            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                !\u003d null) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to reserve a container, but the node is \"\n                    + \"already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n          }\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    // Skip check parent if this is a re-reservation container\n    boolean accepted \u003d true;\n    if (!reReservation) {\n      // Check parent if anything allocated or reserved\n      if (request.anythingAllocatedOrReserved()) {\n        accepted \u003d getCSLeafQueue().accept(cluster, request);\n      }\n    }\n\n    // When rejected, recover resource requests for this app\n    if (!accepted \u0026\u0026 containerRequest !\u003d null) {\n      recoverResourceRequestsForContainer(containerRequest);\n    }\n\n    return accepted;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "0d781dd03b979d65de94978071b2faa55005b34a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7527. Over-allocate node resource in async-scheduling mode of CapacityScheduler. (Tao Yang via wangda)\n\nChange-Id: I51ae6c2ab7a3d1febdd7d8d0519b63a13295ac7d\n",
      "commitDate": "20/11/17 11:48 AM",
      "commitName": "0d781dd03b979d65de94978071b2faa55005b34a",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/11/17 1:01 PM",
      "commitNameOld": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
      "commitAuthorOld": "Konstantinos Karanasos",
      "daysBetweenCommits": 10.95,
      "commitsBetweenForRepo": 54,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,110 @@\n   public boolean accept(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n     List\u003cResourceRequest\u003e resourceRequests \u003d null;\n     boolean reReservation \u003d false;\n \n     try {\n       readLock.lock();\n \n       // First make sure no container in release list in final state\n       if (anyContainerInFinalState(request)) {\n         return false;\n       }\n \n       // TODO, make sure all scheduler nodes are existed\n       // TODO, make sure all node labels are not changed\n \n       if (request.anythingAllocatedOrReserved()) {\n         /*\n          * 1) If this is a newly allocated container, check if the node is reserved\n          *    / not-reserved by any other application\n          * 2) If this is a newly reserved container, check if the node is reserved or not\n          */\n         // Assume we have only one container allocated or reserved\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         if (schedulerContainer.isAllocated()) {\n           // When allocate a new container\n           resourceRequests \u003d\n               schedulerContainer.getRmContainer().getResourceRequests();\n \n           // Check pending resource request\n           if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getSchedulerRequestKey())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                   .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                   .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                   .getSchedulerRequestKey() + \", application\u003d\"\n                   + getApplicationAttemptId());\n             }\n \n             return false;\n           }\n \n           // Common part of check container allocation regardless if it is a\n           // increase container or regular container\n-          commonCheckContainerAllocation(allocation, schedulerContainer);\n+          if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n+            return false;\n+          }\n         } else {\n           // Container reserved first time will be NEW, after the container\n           // accepted \u0026 confirmed, it will become RESERVED state\n           if (schedulerContainer.getRmContainer().getState()\n               \u003d\u003d RMContainerState.RESERVED) {\n             // Check if node currently reserved by other application, there may\n             // be some outdated proposals in async-scheduling environment\n             if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                 .getSchedulerNode().getReservedContainer()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to re-reserve a container, but node \"\n                     + schedulerContainer.getSchedulerNode()\n                     + \" is already reserved by another container\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n             // Set reReservation \u003d\u003d true\n             reReservation \u003d true;\n           } else {\n             // When reserve a resource (state \u003d\u003d NEW is for new container,\n             // state \u003d\u003d RUNNING is for increase container).\n             // Just check if the node is not already reserved by someone\n             if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                 !\u003d null) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to reserve a container, but the node is \"\n                     + \"already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n           }\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     // Skip check parent if this is a re-reservation container\n     boolean accepted \u003d true;\n     if (!reReservation) {\n       // Check parent if anything allocated or reserved\n       if (request.anythingAllocatedOrReserved()) {\n         accepted \u003d getCSLeafQueue().accept(cluster, request);\n       }\n     }\n \n     // When rejected, recover resource requests for this app\n     if (!accepted \u0026\u0026 resourceRequests !\u003d null) {\n       recoverResourceRequestsForContainer(resourceRequests);\n     }\n \n     return accepted;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    List\u003cResourceRequest\u003e resourceRequests \u003d null;\n    boolean reReservation \u003d false;\n\n    try {\n      readLock.lock();\n\n      // First make sure no container in release list in final state\n      if (anyContainerInFinalState(request)) {\n        return false;\n      }\n\n      // TODO, make sure all scheduler nodes are existed\n      // TODO, make sure all node labels are not changed\n\n      if (request.anythingAllocatedOrReserved()) {\n        /*\n         * 1) If this is a newly allocated container, check if the node is reserved\n         *    / not-reserved by any other application\n         * 2) If this is a newly reserved container, check if the node is reserved or not\n         */\n        // Assume we have only one container allocated or reserved\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        if (schedulerContainer.isAllocated()) {\n          // When allocate a new container\n          resourceRequests \u003d\n              schedulerContainer.getRmContainer().getResourceRequests();\n\n          // Check pending resource request\n          if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getSchedulerRequestKey())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                  .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                  .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                  .getSchedulerRequestKey() + \", application\u003d\"\n                  + getApplicationAttemptId());\n            }\n\n            return false;\n          }\n\n          // Common part of check container allocation regardless if it is a\n          // increase container or regular container\n          if (!commonCheckContainerAllocation(allocation, schedulerContainer)) {\n            return false;\n          }\n        } else {\n          // Container reserved first time will be NEW, after the container\n          // accepted \u0026 confirmed, it will become RESERVED state\n          if (schedulerContainer.getRmContainer().getState()\n              \u003d\u003d RMContainerState.RESERVED) {\n            // Check if node currently reserved by other application, there may\n            // be some outdated proposals in async-scheduling environment\n            if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                .getSchedulerNode().getReservedContainer()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to re-reserve a container, but node \"\n                    + schedulerContainer.getSchedulerNode()\n                    + \" is already reserved by another container\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n            // Set reReservation \u003d\u003d true\n            reReservation \u003d true;\n          } else {\n            // When reserve a resource (state \u003d\u003d NEW is for new container,\n            // state \u003d\u003d RUNNING is for increase container).\n            // Just check if the node is not already reserved by someone\n            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                !\u003d null) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to reserve a container, but the node is \"\n                    + \"already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n          }\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    // Skip check parent if this is a re-reservation container\n    boolean accepted \u003d true;\n    if (!reReservation) {\n      // Check parent if anything allocated or reserved\n      if (request.anythingAllocatedOrReserved()) {\n        accepted \u003d getCSLeafQueue().accept(cluster, request);\n      }\n    }\n\n    // When rejected, recover resource requests for this app\n    if (!accepted \u0026\u0026 resourceRequests !\u003d null) {\n      recoverResourceRequestsForContainer(resourceRequests);\n    }\n\n    return accepted;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7172. ResourceCalculator.fitsIn() should not take a cluster resource parameter. (Sen Zhao via wangda)\n\nChange-Id: Icc3670c9381ce7591ca69ec12da5aa52d3612d34\n",
      "commitDate": "17/09/17 9:20 PM",
      "commitName": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "03/08/17 6:57 AM",
      "commitNameOld": "f64cfeaf61ec65a465decdd8215f567d4e6677a9",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 45.6,
      "commitsBetweenForRepo": 408,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,108 @@\n   public boolean accept(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n     List\u003cResourceRequest\u003e resourceRequests \u003d null;\n     boolean reReservation \u003d false;\n \n     try {\n       readLock.lock();\n \n       // First make sure no container in release list in final state\n       if (anyContainerInFinalState(request)) {\n         return false;\n       }\n \n       // TODO, make sure all scheduler nodes are existed\n       // TODO, make sure all node labels are not changed\n \n       if (request.anythingAllocatedOrReserved()) {\n         /*\n          * 1) If this is a newly allocated container, check if the node is reserved\n          *    / not-reserved by any other application\n          * 2) If this is a newly reserved container, check if the node is reserved or not\n          */\n         // Assume we have only one container allocated or reserved\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         if (schedulerContainer.isAllocated()) {\n           // When allocate a new container\n           resourceRequests \u003d\n               schedulerContainer.getRmContainer().getResourceRequests();\n \n           // Check pending resource request\n           if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getSchedulerRequestKey())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                   .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                   .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                   .getSchedulerRequestKey() + \", application\u003d\"\n                   + getApplicationAttemptId());\n             }\n \n             return false;\n           }\n \n           // Common part of check container allocation regardless if it is a\n           // increase container or regular container\n-          commonCheckContainerAllocation(cluster, allocation,\n-              schedulerContainer);\n+          commonCheckContainerAllocation(allocation, schedulerContainer);\n         } else {\n           // Container reserved first time will be NEW, after the container\n           // accepted \u0026 confirmed, it will become RESERVED state\n           if (schedulerContainer.getRmContainer().getState()\n               \u003d\u003d RMContainerState.RESERVED) {\n             // Check if node currently reserved by other application, there may\n             // be some outdated proposals in async-scheduling environment\n             if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                 .getSchedulerNode().getReservedContainer()) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to re-reserve a container, but node \"\n                     + schedulerContainer.getSchedulerNode()\n                     + \" is already reserved by another container\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n             // Set reReservation \u003d\u003d true\n             reReservation \u003d true;\n           } else {\n             // When reserve a resource (state \u003d\u003d NEW is for new container,\n             // state \u003d\u003d RUNNING is for increase container).\n             // Just check if the node is not already reserved by someone\n             if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                 !\u003d null) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to reserve a container, but the node is \"\n                     + \"already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n           }\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     // Skip check parent if this is a re-reservation container\n     boolean accepted \u003d true;\n     if (!reReservation) {\n       // Check parent if anything allocated or reserved\n       if (request.anythingAllocatedOrReserved()) {\n         accepted \u003d getCSLeafQueue().accept(cluster, request);\n       }\n     }\n \n     // When rejected, recover resource requests for this app\n     if (!accepted \u0026\u0026 resourceRequests !\u003d null) {\n       recoverResourceRequestsForContainer(resourceRequests);\n     }\n \n     return accepted;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    List\u003cResourceRequest\u003e resourceRequests \u003d null;\n    boolean reReservation \u003d false;\n\n    try {\n      readLock.lock();\n\n      // First make sure no container in release list in final state\n      if (anyContainerInFinalState(request)) {\n        return false;\n      }\n\n      // TODO, make sure all scheduler nodes are existed\n      // TODO, make sure all node labels are not changed\n\n      if (request.anythingAllocatedOrReserved()) {\n        /*\n         * 1) If this is a newly allocated container, check if the node is reserved\n         *    / not-reserved by any other application\n         * 2) If this is a newly reserved container, check if the node is reserved or not\n         */\n        // Assume we have only one container allocated or reserved\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        if (schedulerContainer.isAllocated()) {\n          // When allocate a new container\n          resourceRequests \u003d\n              schedulerContainer.getRmContainer().getResourceRequests();\n\n          // Check pending resource request\n          if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getSchedulerRequestKey())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                  .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                  .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                  .getSchedulerRequestKey() + \", application\u003d\"\n                  + getApplicationAttemptId());\n            }\n\n            return false;\n          }\n\n          // Common part of check container allocation regardless if it is a\n          // increase container or regular container\n          commonCheckContainerAllocation(allocation, schedulerContainer);\n        } else {\n          // Container reserved first time will be NEW, after the container\n          // accepted \u0026 confirmed, it will become RESERVED state\n          if (schedulerContainer.getRmContainer().getState()\n              \u003d\u003d RMContainerState.RESERVED) {\n            // Check if node currently reserved by other application, there may\n            // be some outdated proposals in async-scheduling environment\n            if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                .getSchedulerNode().getReservedContainer()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to re-reserve a container, but node \"\n                    + schedulerContainer.getSchedulerNode()\n                    + \" is already reserved by another container\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n            // Set reReservation \u003d\u003d true\n            reReservation \u003d true;\n          } else {\n            // When reserve a resource (state \u003d\u003d NEW is for new container,\n            // state \u003d\u003d RUNNING is for increase container).\n            // Just check if the node is not already reserved by someone\n            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                !\u003d null) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to reserve a container, but the node is \"\n                    + \"already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n          }\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    // Skip check parent if this is a re-reservation container\n    boolean accepted \u003d true;\n    if (!reReservation) {\n      // Check parent if anything allocated or reserved\n      if (request.anythingAllocatedOrReserved()) {\n        accepted \u003d getCSLeafQueue().accept(cluster, request);\n      }\n    }\n\n    // When rejected, recover resource requests for this app\n    if (!accepted \u0026\u0026 resourceRequests !\u003d null) {\n      recoverResourceRequestsForContainer(resourceRequests);\n    }\n\n    return accepted;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "f64cfeaf61ec65a465decdd8215f567d4e6677a9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6678. Handle IllegalStateException in Async Scheduling mode of CapacityScheduler. Contributed by Tao Yang.\n",
      "commitDate": "03/08/17 6:57 AM",
      "commitName": "f64cfeaf61ec65a465decdd8215f567d4e6677a9",
      "commitAuthor": "Sunil G",
      "commitDateOld": "22/06/17 11:50 PM",
      "commitNameOld": "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 41.3,
      "commitsBetweenForRepo": 257,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,109 @@\n   public boolean accept(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n     List\u003cResourceRequest\u003e resourceRequests \u003d null;\n     boolean reReservation \u003d false;\n \n     try {\n       readLock.lock();\n \n       // First make sure no container in release list in final state\n       if (anyContainerInFinalState(request)) {\n         return false;\n       }\n \n       // TODO, make sure all scheduler nodes are existed\n       // TODO, make sure all node labels are not changed\n \n       if (request.anythingAllocatedOrReserved()) {\n         /*\n          * 1) If this is a newly allocated container, check if the node is reserved\n          *    / not-reserved by any other application\n          * 2) If this is a newly reserved container, check if the node is reserved or not\n          */\n         // Assume we have only one container allocated or reserved\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         if (schedulerContainer.isAllocated()) {\n           // When allocate a new container\n           resourceRequests \u003d\n               schedulerContainer.getRmContainer().getResourceRequests();\n \n           // Check pending resource request\n           if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getSchedulerRequestKey())) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                   .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                   .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                   .getSchedulerRequestKey() + \", application\u003d\"\n                   + getApplicationAttemptId());\n             }\n \n             return false;\n           }\n \n           // Common part of check container allocation regardless if it is a\n           // increase container or regular container\n           commonCheckContainerAllocation(cluster, allocation,\n               schedulerContainer);\n         } else {\n           // Container reserved first time will be NEW, after the container\n           // accepted \u0026 confirmed, it will become RESERVED state\n           if (schedulerContainer.getRmContainer().getState()\n               \u003d\u003d RMContainerState.RESERVED) {\n+            // Check if node currently reserved by other application, there may\n+            // be some outdated proposals in async-scheduling environment\n+            if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n+                .getSchedulerNode().getReservedContainer()) {\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Try to re-reserve a container, but node \"\n+                    + schedulerContainer.getSchedulerNode()\n+                    + \" is already reserved by another container\"\n+                    + schedulerContainer.getSchedulerNode()\n+                    .getReservedContainer().getContainerId());\n+              }\n+              return false;\n+            }\n             // Set reReservation \u003d\u003d true\n             reReservation \u003d true;\n           } else {\n             // When reserve a resource (state \u003d\u003d NEW is for new container,\n             // state \u003d\u003d RUNNING is for increase container).\n             // Just check if the node is not already reserved by someone\n             if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                 !\u003d null) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to reserve a container, but the node is \"\n                     + \"already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n           }\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     // Skip check parent if this is a re-reservation container\n     boolean accepted \u003d true;\n     if (!reReservation) {\n       // Check parent if anything allocated or reserved\n       if (request.anythingAllocatedOrReserved()) {\n         accepted \u003d getCSLeafQueue().accept(cluster, request);\n       }\n     }\n \n     // When rejected, recover resource requests for this app\n     if (!accepted \u0026\u0026 resourceRequests !\u003d null) {\n       recoverResourceRequestsForContainer(resourceRequests);\n     }\n \n     return accepted;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    List\u003cResourceRequest\u003e resourceRequests \u003d null;\n    boolean reReservation \u003d false;\n\n    try {\n      readLock.lock();\n\n      // First make sure no container in release list in final state\n      if (anyContainerInFinalState(request)) {\n        return false;\n      }\n\n      // TODO, make sure all scheduler nodes are existed\n      // TODO, make sure all node labels are not changed\n\n      if (request.anythingAllocatedOrReserved()) {\n        /*\n         * 1) If this is a newly allocated container, check if the node is reserved\n         *    / not-reserved by any other application\n         * 2) If this is a newly reserved container, check if the node is reserved or not\n         */\n        // Assume we have only one container allocated or reserved\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        if (schedulerContainer.isAllocated()) {\n          // When allocate a new container\n          resourceRequests \u003d\n              schedulerContainer.getRmContainer().getResourceRequests();\n\n          // Check pending resource request\n          if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getSchedulerRequestKey())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                  .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                  .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                  .getSchedulerRequestKey() + \", application\u003d\"\n                  + getApplicationAttemptId());\n            }\n\n            return false;\n          }\n\n          // Common part of check container allocation regardless if it is a\n          // increase container or regular container\n          commonCheckContainerAllocation(cluster, allocation,\n              schedulerContainer);\n        } else {\n          // Container reserved first time will be NEW, after the container\n          // accepted \u0026 confirmed, it will become RESERVED state\n          if (schedulerContainer.getRmContainer().getState()\n              \u003d\u003d RMContainerState.RESERVED) {\n            // Check if node currently reserved by other application, there may\n            // be some outdated proposals in async-scheduling environment\n            if (schedulerContainer.getRmContainer() !\u003d schedulerContainer\n                .getSchedulerNode().getReservedContainer()) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to re-reserve a container, but node \"\n                    + schedulerContainer.getSchedulerNode()\n                    + \" is already reserved by another container\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n            // Set reReservation \u003d\u003d true\n            reReservation \u003d true;\n          } else {\n            // When reserve a resource (state \u003d\u003d NEW is for new container,\n            // state \u003d\u003d RUNNING is for increase container).\n            // Just check if the node is not already reserved by someone\n            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                !\u003d null) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to reserve a container, but the node is \"\n                    + \"already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n          }\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    // Skip check parent if this is a re-reservation container\n    boolean accepted \u003d true;\n    if (!reReservation) {\n      // Check parent if anything allocated or reserved\n      if (request.anythingAllocatedOrReserved()) {\n        accepted \u003d getCSLeafQueue().accept(cluster, request);\n      }\n    }\n\n    // When rejected, recover resource requests for this app\n    if (!accepted \u0026\u0026 resourceRequests !\u003d null) {\n      recoverResourceRequestsForContainer(resourceRequests);\n    }\n\n    return accepted;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6216. Unify Container Resizing code paths with Container Updates making it scheduler agnostic. (Arun Suresh via wangda)\n",
      "commitDate": "28/02/17 10:35 AM",
      "commitName": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/02/17 10:23 AM",
      "commitNameOld": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 19.01,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,96 @@\n   public boolean accept(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n     List\u003cResourceRequest\u003e resourceRequests \u003d null;\n     boolean reReservation \u003d false;\n \n     try {\n       readLock.lock();\n \n       // First make sure no container in release list in final state\n       if (anyContainerInFinalState(request)) {\n         return false;\n       }\n \n       // TODO, make sure all scheduler nodes are existed\n       // TODO, make sure all node labels are not changed\n \n       if (request.anythingAllocatedOrReserved()) {\n         /*\n          * 1) If this is a newly allocated container, check if the node is reserved\n          *    / not-reserved by any other application\n          * 2) If this is a newly reserved container, check if the node is reserved or not\n          */\n         // Assume we have only one container allocated or reserved\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         if (schedulerContainer.isAllocated()) {\n-          if (!allocation.isIncreasedAllocation()) {\n-            // When allocate a new container\n-            resourceRequests \u003d\n-                schedulerContainer.getRmContainer().getResourceRequests();\n+          // When allocate a new container\n+          resourceRequests \u003d\n+              schedulerContainer.getRmContainer().getResourceRequests();\n \n-            // Check pending resource request\n-            if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n-                schedulerContainer.getSchedulerNode(),\n-                schedulerContainer.getSchedulerRequestKey())) {\n-              if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n-                    .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n-                    .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n-                    .getSchedulerRequestKey() + \", application\u003d\"\n-                    + getApplicationAttemptId());\n-              }\n+          // Check pending resource request\n+          if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n+              schedulerContainer.getSchedulerNode(),\n+              schedulerContainer.getSchedulerRequestKey())) {\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n+                  .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n+                  .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n+                  .getSchedulerRequestKey() + \", application\u003d\"\n+                  + getApplicationAttemptId());\n+            }\n \n-              return false;\n-            }\n-          } else {\n-            if (!checkIncreaseContainerAllocation(allocation,\n-                schedulerContainer)) {\n-              return false;\n-            }\n+            return false;\n           }\n \n           // Common part of check container allocation regardless if it is a\n           // increase container or regular container\n           commonCheckContainerAllocation(cluster, allocation,\n               schedulerContainer);\n         } else {\n           // Container reserved first time will be NEW, after the container\n           // accepted \u0026 confirmed, it will become RESERVED state\n           if (schedulerContainer.getRmContainer().getState()\n               \u003d\u003d RMContainerState.RESERVED) {\n             // Set reReservation \u003d\u003d true\n             reReservation \u003d true;\n           } else {\n             // When reserve a resource (state \u003d\u003d NEW is for new container,\n             // state \u003d\u003d RUNNING is for increase container).\n             // Just check if the node is not already reserved by someone\n             if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                 !\u003d null) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Try to reserve a container, but the node is \"\n                     + \"already reserved by another container\u003d\"\n                     + schedulerContainer.getSchedulerNode()\n                     .getReservedContainer().getContainerId());\n               }\n               return false;\n             }\n           }\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     // Skip check parent if this is a re-reservation container\n     boolean accepted \u003d true;\n     if (!reReservation) {\n       // Check parent if anything allocated or reserved\n       if (request.anythingAllocatedOrReserved()) {\n         accepted \u003d getCSLeafQueue().accept(cluster, request);\n       }\n     }\n \n     // When rejected, recover resource requests for this app\n     if (!accepted \u0026\u0026 resourceRequests !\u003d null) {\n       recoverResourceRequestsForContainer(resourceRequests);\n     }\n \n     return accepted;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    List\u003cResourceRequest\u003e resourceRequests \u003d null;\n    boolean reReservation \u003d false;\n\n    try {\n      readLock.lock();\n\n      // First make sure no container in release list in final state\n      if (anyContainerInFinalState(request)) {\n        return false;\n      }\n\n      // TODO, make sure all scheduler nodes are existed\n      // TODO, make sure all node labels are not changed\n\n      if (request.anythingAllocatedOrReserved()) {\n        /*\n         * 1) If this is a newly allocated container, check if the node is reserved\n         *    / not-reserved by any other application\n         * 2) If this is a newly reserved container, check if the node is reserved or not\n         */\n        // Assume we have only one container allocated or reserved\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        if (schedulerContainer.isAllocated()) {\n          // When allocate a new container\n          resourceRequests \u003d\n              schedulerContainer.getRmContainer().getResourceRequests();\n\n          // Check pending resource request\n          if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getSchedulerRequestKey())) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                  .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                  .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                  .getSchedulerRequestKey() + \", application\u003d\"\n                  + getApplicationAttemptId());\n            }\n\n            return false;\n          }\n\n          // Common part of check container allocation regardless if it is a\n          // increase container or regular container\n          commonCheckContainerAllocation(cluster, allocation,\n              schedulerContainer);\n        } else {\n          // Container reserved first time will be NEW, after the container\n          // accepted \u0026 confirmed, it will become RESERVED state\n          if (schedulerContainer.getRmContainer().getState()\n              \u003d\u003d RMContainerState.RESERVED) {\n            // Set reReservation \u003d\u003d true\n            reReservation \u003d true;\n          } else {\n            // When reserve a resource (state \u003d\u003d NEW is for new container,\n            // state \u003d\u003d RUNNING is for increase container).\n            // Just check if the node is not already reserved by someone\n            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                !\u003d null) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to reserve a container, but the node is \"\n                    + \"already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n          }\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    // Skip check parent if this is a re-reservation container\n    boolean accepted \u003d true;\n    if (!reReservation) {\n      // Check parent if anything allocated or reserved\n      if (request.anythingAllocatedOrReserved()) {\n        accepted \u003d getCSLeafQueue().accept(cluster, request);\n      }\n    }\n\n    // When rejected, recover resource requests for this app\n    if (!accepted \u0026\u0026 resourceRequests !\u003d null) {\n      recoverResourceRequestsForContainer(resourceRequests);\n    }\n\n    return accepted;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,103 @@\n+  public boolean accept(Resource cluster,\n+      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n+    List\u003cResourceRequest\u003e resourceRequests \u003d null;\n+    boolean reReservation \u003d false;\n+\n+    try {\n+      readLock.lock();\n+\n+      // First make sure no container in release list in final state\n+      if (anyContainerInFinalState(request)) {\n+        return false;\n+      }\n+\n+      // TODO, make sure all scheduler nodes are existed\n+      // TODO, make sure all node labels are not changed\n+\n+      if (request.anythingAllocatedOrReserved()) {\n+        /*\n+         * 1) If this is a newly allocated container, check if the node is reserved\n+         *    / not-reserved by any other application\n+         * 2) If this is a newly reserved container, check if the node is reserved or not\n+         */\n+        // Assume we have only one container allocated or reserved\n+        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n+            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n+        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n+            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n+\n+        if (schedulerContainer.isAllocated()) {\n+          if (!allocation.isIncreasedAllocation()) {\n+            // When allocate a new container\n+            resourceRequests \u003d\n+                schedulerContainer.getRmContainer().getResourceRequests();\n+\n+            // Check pending resource request\n+            if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n+                schedulerContainer.getSchedulerNode(),\n+                schedulerContainer.getSchedulerRequestKey())) {\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n+                    .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n+                    .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n+                    .getSchedulerRequestKey() + \", application\u003d\"\n+                    + getApplicationAttemptId());\n+              }\n+\n+              return false;\n+            }\n+          } else {\n+            if (!checkIncreaseContainerAllocation(allocation,\n+                schedulerContainer)) {\n+              return false;\n+            }\n+          }\n+\n+          // Common part of check container allocation regardless if it is a\n+          // increase container or regular container\n+          commonCheckContainerAllocation(cluster, allocation,\n+              schedulerContainer);\n+        } else {\n+          // Container reserved first time will be NEW, after the container\n+          // accepted \u0026 confirmed, it will become RESERVED state\n+          if (schedulerContainer.getRmContainer().getState()\n+              \u003d\u003d RMContainerState.RESERVED) {\n+            // Set reReservation \u003d\u003d true\n+            reReservation \u003d true;\n+          } else {\n+            // When reserve a resource (state \u003d\u003d NEW is for new container,\n+            // state \u003d\u003d RUNNING is for increase container).\n+            // Just check if the node is not already reserved by someone\n+            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n+                !\u003d null) {\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Try to reserve a container, but the node is \"\n+                    + \"already reserved by another container\u003d\"\n+                    + schedulerContainer.getSchedulerNode()\n+                    .getReservedContainer().getContainerId());\n+              }\n+              return false;\n+            }\n+          }\n+        }\n+      }\n+    } finally {\n+      readLock.unlock();\n+    }\n+\n+    // Skip check parent if this is a re-reservation container\n+    boolean accepted \u003d true;\n+    if (!reReservation) {\n+      // Check parent if anything allocated or reserved\n+      if (request.anythingAllocatedOrReserved()) {\n+        accepted \u003d getCSLeafQueue().accept(cluster, request);\n+      }\n+    }\n+\n+    // When rejected, recover resource requests for this app\n+    if (!accepted \u0026\u0026 resourceRequests !\u003d null) {\n+      recoverResourceRequestsForContainer(resourceRequests);\n+    }\n+\n+    return accepted;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean accept(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    List\u003cResourceRequest\u003e resourceRequests \u003d null;\n    boolean reReservation \u003d false;\n\n    try {\n      readLock.lock();\n\n      // First make sure no container in release list in final state\n      if (anyContainerInFinalState(request)) {\n        return false;\n      }\n\n      // TODO, make sure all scheduler nodes are existed\n      // TODO, make sure all node labels are not changed\n\n      if (request.anythingAllocatedOrReserved()) {\n        /*\n         * 1) If this is a newly allocated container, check if the node is reserved\n         *    / not-reserved by any other application\n         * 2) If this is a newly reserved container, check if the node is reserved or not\n         */\n        // Assume we have only one container allocated or reserved\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        if (schedulerContainer.isAllocated()) {\n          if (!allocation.isIncreasedAllocation()) {\n            // When allocate a new container\n            resourceRequests \u003d\n                schedulerContainer.getRmContainer().getResourceRequests();\n\n            // Check pending resource request\n            if (!appSchedulingInfo.checkAllocation(allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey())) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No pending resource for: nodeType\u003d\" + allocation\n                    .getAllocationLocalityType() + \", node\u003d\" + schedulerContainer\n                    .getSchedulerNode() + \", requestKey\u003d\" + schedulerContainer\n                    .getSchedulerRequestKey() + \", application\u003d\"\n                    + getApplicationAttemptId());\n              }\n\n              return false;\n            }\n          } else {\n            if (!checkIncreaseContainerAllocation(allocation,\n                schedulerContainer)) {\n              return false;\n            }\n          }\n\n          // Common part of check container allocation regardless if it is a\n          // increase container or regular container\n          commonCheckContainerAllocation(cluster, allocation,\n              schedulerContainer);\n        } else {\n          // Container reserved first time will be NEW, after the container\n          // accepted \u0026 confirmed, it will become RESERVED state\n          if (schedulerContainer.getRmContainer().getState()\n              \u003d\u003d RMContainerState.RESERVED) {\n            // Set reReservation \u003d\u003d true\n            reReservation \u003d true;\n          } else {\n            // When reserve a resource (state \u003d\u003d NEW is for new container,\n            // state \u003d\u003d RUNNING is for increase container).\n            // Just check if the node is not already reserved by someone\n            if (schedulerContainer.getSchedulerNode().getReservedContainer()\n                !\u003d null) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Try to reserve a container, but the node is \"\n                    + \"already reserved by another container\u003d\"\n                    + schedulerContainer.getSchedulerNode()\n                    .getReservedContainer().getContainerId());\n              }\n              return false;\n            }\n          }\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    // Skip check parent if this is a re-reservation container\n    boolean accepted \u003d true;\n    if (!reReservation) {\n      // Check parent if anything allocated or reserved\n      if (request.anythingAllocatedOrReserved()) {\n        accepted \u003d getCSLeafQueue().accept(cluster, request);\n      }\n    }\n\n    // When rejected, recover resource requests for this app\n    if (!accepted \u0026\u0026 resourceRequests !\u003d null) {\n      recoverResourceRequestsForContainer(resourceRequests);\n    }\n\n    return accepted;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java"
    }
  }
}