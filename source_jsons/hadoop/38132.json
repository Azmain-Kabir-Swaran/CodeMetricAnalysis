{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FifoIntraQueuePreemptionPlugin.java",
  "functionName": "calculateIdealAssignedResourcePerApp",
  "functionId": "calculateIdealAssignedResourcePerApp___clusterResource-Resource__tq-TempQueuePerPartition__selectedCandidates-Map__ApplicationAttemptId,Set__RMContainer______queueReassignableResource-Resource__orderedByPriority-PriorityQueue__TempAppPerPartition__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoIntraQueuePreemptionPlugin.java",
  "functionStartLine": 261,
  "functionEndLine": 338,
  "numCommitsSeen": 13,
  "timeTaken": 3773,
  "changeHistory": [
    "7c343669baf660df3b70d58987d6e68aec54d6fa",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9"
  ],
  "changeHistoryShort": {
    "7c343669baf660df3b70d58987d6e68aec54d6fa": "Ybodychange",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": "Ybodychange",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": "Ymultichange(Yparameterchange,Ybodychange)",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": "Ybodychange",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7c343669baf660df3b70d58987d6e68aec54d6fa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4781. Support intra-queue preemption for fairness ordering policy. Contributed by Eric Payne.\n",
      "commitDate": "28/05/18 4:02 AM",
      "commitName": "7c343669baf660df3b70d58987d6e68aec54d6fa",
      "commitAuthor": "Sunil G",
      "commitDateOld": "25/05/18 9:06 AM",
      "commitNameOld": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
      "commitAuthorOld": "Eric E Payne",
      "daysBetweenCommits": 2.79,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,78 @@\n   private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n       Resource clusterResource, TempQueuePerPartition tq,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource queueReassignableResource,\n       PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority) {\n \n-    Comparator\u003cTempAppPerPartition\u003e reverseComp \u003d Collections\n-        .reverseOrder(new TAPriorityComparator());\n+    Comparator\u003cTempAppPerPartition\u003e reverseComp;\n+    OrderingPolicy\u003cFiCaSchedulerApp\u003e queueOrderingPolicy \u003d\n+        tq.leafQueue.getOrderingPolicy();\n+    if (queueOrderingPolicy instanceof FairOrderingPolicy\n+        \u0026\u0026 (context.getIntraQueuePreemptionOrderPolicy()\n+            \u003d\u003d IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n+      reverseComp \u003d Collections.reverseOrder(\n+          new TAFairOrderingComparator(this.rc, clusterResource));\n+    } else {\n+      reverseComp \u003d Collections.reverseOrder(new TAPriorityComparator());\n+    }\n     TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n \n     String partition \u003d tq.partition;\n     Map\u003cString, TempUserPerPartition\u003e usersPerPartition \u003d tq.getUsersPerPartition();\n \n     while (!orderedByPriority.isEmpty()) {\n       // Remove app from the next highest remaining priority and process it to\n       // calculate idealAssigned per app.\n       TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n       orderedApps.add(tmpApp);\n \n       // Once unallocated resource is 0, we can stop assigning ideal per app.\n       if (Resources.lessThanOrEqual(rc, clusterResource,\n           queueReassignableResource, Resources.none()) || rc\n           .isAnyMajorResourceZeroOrNegative(queueReassignableResource)) {\n         continue;\n       }\n \n       String userName \u003d tmpApp.app.getUser();\n       TempUserPerPartition tmpUser \u003d usersPerPartition.get(userName);\n       Resource userLimitResource \u003d tmpUser.getUserLimit();\n       Resource idealAssignedForUser \u003d tmpUser.idealAssigned;\n \n       // Calculate total selected container resources from current app.\n       getAlreadySelectedPreemptionCandidatesResource(selectedCandidates, tmpApp,\n           tmpUser, partition);\n \n       // For any app, used+pending will give its idealAssigned. However it will\n       // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n       // idealAssigned may fall to 0 if higher priority apps demand is more.\n       Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n           tmpApp.getPending());\n       Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n \n       if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n           userLimitResource)) {\n         Resource idealAssigned \u003d Resources.min(rc, clusterResource,\n             appIdealAssigned,\n             Resources.subtract(userLimitResource, idealAssignedForUser));\n         tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n             clusterResource, queueReassignableResource, idealAssigned));\n         Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n       } else {\n         continue;\n       }\n \n       // Also set how much resource is needed by this app from others.\n       Resource appUsedExcludedSelected \u003d Resources\n           .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n       if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n           appUsedExcludedSelected)) {\n         tmpApp.setToBePreemptFromOther(\n             Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n       }\n \n       Resources.subtractFromNonNegative(queueReassignableResource,\n           tmpApp.idealAssigned);\n     }\n \n     return orderedApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n      Resource clusterResource, TempQueuePerPartition tq,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource queueReassignableResource,\n      PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority) {\n\n    Comparator\u003cTempAppPerPartition\u003e reverseComp;\n    OrderingPolicy\u003cFiCaSchedulerApp\u003e queueOrderingPolicy \u003d\n        tq.leafQueue.getOrderingPolicy();\n    if (queueOrderingPolicy instanceof FairOrderingPolicy\n        \u0026\u0026 (context.getIntraQueuePreemptionOrderPolicy()\n            \u003d\u003d IntraQueuePreemptionOrderPolicy.USERLIMIT_FIRST)) {\n      reverseComp \u003d Collections.reverseOrder(\n          new TAFairOrderingComparator(this.rc, clusterResource));\n    } else {\n      reverseComp \u003d Collections.reverseOrder(new TAPriorityComparator());\n    }\n    TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n\n    String partition \u003d tq.partition;\n    Map\u003cString, TempUserPerPartition\u003e usersPerPartition \u003d tq.getUsersPerPartition();\n\n    while (!orderedByPriority.isEmpty()) {\n      // Remove app from the next highest remaining priority and process it to\n      // calculate idealAssigned per app.\n      TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n      orderedApps.add(tmpApp);\n\n      // Once unallocated resource is 0, we can stop assigning ideal per app.\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n          queueReassignableResource, Resources.none()) || rc\n          .isAnyMajorResourceZeroOrNegative(queueReassignableResource)) {\n        continue;\n      }\n\n      String userName \u003d tmpApp.app.getUser();\n      TempUserPerPartition tmpUser \u003d usersPerPartition.get(userName);\n      Resource userLimitResource \u003d tmpUser.getUserLimit();\n      Resource idealAssignedForUser \u003d tmpUser.idealAssigned;\n\n      // Calculate total selected container resources from current app.\n      getAlreadySelectedPreemptionCandidatesResource(selectedCandidates, tmpApp,\n          tmpUser, partition);\n\n      // For any app, used+pending will give its idealAssigned. However it will\n      // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n      // idealAssigned may fall to 0 if higher priority apps demand is more.\n      Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n          tmpApp.getPending());\n      Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n\n      if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n          userLimitResource)) {\n        Resource idealAssigned \u003d Resources.min(rc, clusterResource,\n            appIdealAssigned,\n            Resources.subtract(userLimitResource, idealAssignedForUser));\n        tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n            clusterResource, queueReassignableResource, idealAssigned));\n        Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n      } else {\n        continue;\n      }\n\n      // Also set how much resource is needed by this app from others.\n      Resource appUsedExcludedSelected \u003d Resources\n          .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n      if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n          appUsedExcludedSelected)) {\n        tmpApp.setToBePreemptFromOther(\n            Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n      }\n\n      Resources.subtractFromNonNegative(queueReassignableResource,\n          tmpApp.idealAssigned);\n    }\n\n    return orderedApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoIntraQueuePreemptionPlugin.java",
      "extendedDetails": {}
    },
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8292: Fix the dominant resource preemption cannot happen when some of the resource vector becomes negative. Contributed by Wangda Tan.\n",
      "commitDate": "25/05/18 9:06 AM",
      "commitName": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
      "commitAuthor": "Eric E Payne",
      "commitDateOld": "21/02/18 1:05 AM",
      "commitNameOld": "bdd2a184d78379d99c802a43ebec7d2cef0bbaf7",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 93.29,
      "commitsBetweenForRepo": 1301,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n   private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n       Resource clusterResource, TempQueuePerPartition tq,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource queueReassignableResource,\n       PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority) {\n \n     Comparator\u003cTempAppPerPartition\u003e reverseComp \u003d Collections\n         .reverseOrder(new TAPriorityComparator());\n     TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n \n     String partition \u003d tq.partition;\n     Map\u003cString, TempUserPerPartition\u003e usersPerPartition \u003d tq.getUsersPerPartition();\n \n     while (!orderedByPriority.isEmpty()) {\n       // Remove app from the next highest remaining priority and process it to\n       // calculate idealAssigned per app.\n       TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n       orderedApps.add(tmpApp);\n \n       // Once unallocated resource is 0, we can stop assigning ideal per app.\n       if (Resources.lessThanOrEqual(rc, clusterResource,\n-          queueReassignableResource, Resources.none())\n-          || Resources.isAnyMajorResourceZero(rc, queueReassignableResource)) {\n+          queueReassignableResource, Resources.none()) || rc\n+          .isAnyMajorResourceZeroOrNegative(queueReassignableResource)) {\n         continue;\n       }\n \n       String userName \u003d tmpApp.app.getUser();\n       TempUserPerPartition tmpUser \u003d usersPerPartition.get(userName);\n       Resource userLimitResource \u003d tmpUser.getUserLimit();\n       Resource idealAssignedForUser \u003d tmpUser.idealAssigned;\n \n       // Calculate total selected container resources from current app.\n       getAlreadySelectedPreemptionCandidatesResource(selectedCandidates, tmpApp,\n           tmpUser, partition);\n \n       // For any app, used+pending will give its idealAssigned. However it will\n       // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n       // idealAssigned may fall to 0 if higher priority apps demand is more.\n       Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n           tmpApp.getPending());\n       Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n \n       if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n           userLimitResource)) {\n         Resource idealAssigned \u003d Resources.min(rc, clusterResource,\n             appIdealAssigned,\n             Resources.subtract(userLimitResource, idealAssignedForUser));\n         tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n             clusterResource, queueReassignableResource, idealAssigned));\n         Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n       } else {\n         continue;\n       }\n \n       // Also set how much resource is needed by this app from others.\n       Resource appUsedExcludedSelected \u003d Resources\n           .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n       if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n           appUsedExcludedSelected)) {\n         tmpApp.setToBePreemptFromOther(\n             Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n       }\n \n       Resources.subtractFromNonNegative(queueReassignableResource,\n           tmpApp.idealAssigned);\n     }\n \n     return orderedApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n      Resource clusterResource, TempQueuePerPartition tq,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource queueReassignableResource,\n      PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority) {\n\n    Comparator\u003cTempAppPerPartition\u003e reverseComp \u003d Collections\n        .reverseOrder(new TAPriorityComparator());\n    TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n\n    String partition \u003d tq.partition;\n    Map\u003cString, TempUserPerPartition\u003e usersPerPartition \u003d tq.getUsersPerPartition();\n\n    while (!orderedByPriority.isEmpty()) {\n      // Remove app from the next highest remaining priority and process it to\n      // calculate idealAssigned per app.\n      TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n      orderedApps.add(tmpApp);\n\n      // Once unallocated resource is 0, we can stop assigning ideal per app.\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n          queueReassignableResource, Resources.none()) || rc\n          .isAnyMajorResourceZeroOrNegative(queueReassignableResource)) {\n        continue;\n      }\n\n      String userName \u003d tmpApp.app.getUser();\n      TempUserPerPartition tmpUser \u003d usersPerPartition.get(userName);\n      Resource userLimitResource \u003d tmpUser.getUserLimit();\n      Resource idealAssignedForUser \u003d tmpUser.idealAssigned;\n\n      // Calculate total selected container resources from current app.\n      getAlreadySelectedPreemptionCandidatesResource(selectedCandidates, tmpApp,\n          tmpUser, partition);\n\n      // For any app, used+pending will give its idealAssigned. However it will\n      // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n      // idealAssigned may fall to 0 if higher priority apps demand is more.\n      Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n          tmpApp.getPending());\n      Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n\n      if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n          userLimitResource)) {\n        Resource idealAssigned \u003d Resources.min(rc, clusterResource,\n            appIdealAssigned,\n            Resources.subtract(userLimitResource, idealAssignedForUser));\n        tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n            clusterResource, queueReassignableResource, idealAssigned));\n        Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n      } else {\n        continue;\n      }\n\n      // Also set how much resource is needed by this app from others.\n      Resource appUsedExcludedSelected \u003d Resources\n          .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n      if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n          appUsedExcludedSelected)) {\n        tmpApp.setToBePreemptFromOther(\n            Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n      }\n\n      Resources.subtractFromNonNegative(queueReassignableResource,\n          tmpApp.idealAssigned);\n    }\n\n    return orderedApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoIntraQueuePreemptionPlugin.java",
      "extendedDetails": {}
    },
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2113. Add cross-user preemption within CapacityScheduler\u0027s leaf-queue. (Sunil G via wangda)\n\nChange-Id: I9b19f69788068be05b3295247cdd7b972f8a573c\n",
      "commitDate": "22/05/17 2:26 PM",
      "commitName": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2113. Add cross-user preemption within CapacityScheduler\u0027s leaf-queue. (Sunil G via wangda)\n\nChange-Id: I9b19f69788068be05b3295247cdd7b972f8a573c\n",
          "commitDate": "22/05/17 2:26 PM",
          "commitName": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "09/02/17 10:23 AM",
          "commitNameOld": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 102.13,
          "commitsBetweenForRepo": 587,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,69 @@\n   private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n-      Resource clusterResource, Resource partitionBasedResource,\n-      TempQueuePerPartition tq,\n+      Resource clusterResource, TempQueuePerPartition tq,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource queueReassignableResource,\n-      PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority,\n-      Map\u003cString, Resource\u003e perUserAMUsed) {\n+      PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority) {\n \n     Comparator\u003cTempAppPerPartition\u003e reverseComp \u003d Collections\n         .reverseOrder(new TAPriorityComparator());\n     TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n \n-    Map\u003cString, Resource\u003e userIdealAssignedMapping \u003d new HashMap\u003c\u003e();\n     String partition \u003d tq.partition;\n-\n-    Map\u003cString, Resource\u003e preCalculatedUserLimit \u003d\n-        new HashMap\u003cString, Resource\u003e();\n+    Map\u003cString, TempUserPerPartition\u003e usersPerPartition \u003d tq.getUsersPerPartition();\n \n     while (!orderedByPriority.isEmpty()) {\n       // Remove app from the next highest remaining priority and process it to\n       // calculate idealAssigned per app.\n       TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n       orderedApps.add(tmpApp);\n \n       // Once unallocated resource is 0, we can stop assigning ideal per app.\n       if (Resources.lessThanOrEqual(rc, clusterResource,\n-          queueReassignableResource, Resources.none())) {\n+          queueReassignableResource, Resources.none())\n+          || Resources.isAnyMajorResourceZero(rc, queueReassignableResource)) {\n         continue;\n       }\n \n       String userName \u003d tmpApp.app.getUser();\n-      Resource userLimitResource \u003d preCalculatedUserLimit.get(userName);\n-\n-      // Verify whether we already calculated headroom for this user.\n-      if (userLimitResource \u003d\u003d null) {\n-        userLimitResource \u003d Resources.clone(\n-            tq.leafQueue.getResourceLimitForAllUsers(userName, clusterResource,\n-                partition, SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY));\n-\n-        Resource amUsed \u003d perUserAMUsed.get(userName);\n-        if (null \u003d\u003d amUsed) {\n-          amUsed \u003d Resources.createResource(0, 0);\n-        }\n-\n-        // Real AM used need not have to be considered for user-limit as well.\n-        userLimitResource \u003d Resources.subtract(userLimitResource, amUsed);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Userlimit for user \u0027\" + userName + \"\u0027 is :\"\n-              + userLimitResource + \", and amUsed is:\" + amUsed);\n-        }\n-\n-        preCalculatedUserLimit.put(userName, userLimitResource);\n-      }\n-\n-      Resource idealAssignedForUser \u003d userIdealAssignedMapping.get(userName);\n-\n-      if (idealAssignedForUser \u003d\u003d null) {\n-        idealAssignedForUser \u003d Resources.createResource(0, 0);\n-        userIdealAssignedMapping.put(userName, idealAssignedForUser);\n-      }\n+      TempUserPerPartition tmpUser \u003d usersPerPartition.get(userName);\n+      Resource userLimitResource \u003d tmpUser.getUserLimit();\n+      Resource idealAssignedForUser \u003d tmpUser.idealAssigned;\n \n       // Calculate total selected container resources from current app.\n-      getAlreadySelectedPreemptionCandidatesResource(selectedCandidates,\n-          tmpApp, partition);\n+      getAlreadySelectedPreemptionCandidatesResource(selectedCandidates, tmpApp,\n+          tmpUser, partition);\n \n       // For any app, used+pending will give its idealAssigned. However it will\n       // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n       // idealAssigned may fall to 0 if higher priority apps demand is more.\n       Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n           tmpApp.getPending());\n       Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n \n       if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n           userLimitResource)) {\n-        appIdealAssigned \u003d Resources.min(rc, clusterResource, appIdealAssigned,\n+        Resource idealAssigned \u003d Resources.min(rc, clusterResource,\n+            appIdealAssigned,\n             Resources.subtract(userLimitResource, idealAssignedForUser));\n         tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n-            clusterResource, queueReassignableResource, appIdealAssigned));\n+            clusterResource, queueReassignableResource, idealAssigned));\n         Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n       } else {\n         continue;\n       }\n \n       // Also set how much resource is needed by this app from others.\n       Resource appUsedExcludedSelected \u003d Resources\n           .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n       if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n           appUsedExcludedSelected)) {\n         tmpApp.setToBePreemptFromOther(\n             Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n       }\n \n-      Resources.subtractFrom(queueReassignableResource, tmpApp.idealAssigned);\n+      Resources.subtractFromNonNegative(queueReassignableResource,\n+          tmpApp.idealAssigned);\n     }\n \n     return orderedApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n      Resource clusterResource, TempQueuePerPartition tq,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource queueReassignableResource,\n      PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority) {\n\n    Comparator\u003cTempAppPerPartition\u003e reverseComp \u003d Collections\n        .reverseOrder(new TAPriorityComparator());\n    TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n\n    String partition \u003d tq.partition;\n    Map\u003cString, TempUserPerPartition\u003e usersPerPartition \u003d tq.getUsersPerPartition();\n\n    while (!orderedByPriority.isEmpty()) {\n      // Remove app from the next highest remaining priority and process it to\n      // calculate idealAssigned per app.\n      TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n      orderedApps.add(tmpApp);\n\n      // Once unallocated resource is 0, we can stop assigning ideal per app.\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n          queueReassignableResource, Resources.none())\n          || Resources.isAnyMajorResourceZero(rc, queueReassignableResource)) {\n        continue;\n      }\n\n      String userName \u003d tmpApp.app.getUser();\n      TempUserPerPartition tmpUser \u003d usersPerPartition.get(userName);\n      Resource userLimitResource \u003d tmpUser.getUserLimit();\n      Resource idealAssignedForUser \u003d tmpUser.idealAssigned;\n\n      // Calculate total selected container resources from current app.\n      getAlreadySelectedPreemptionCandidatesResource(selectedCandidates, tmpApp,\n          tmpUser, partition);\n\n      // For any app, used+pending will give its idealAssigned. However it will\n      // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n      // idealAssigned may fall to 0 if higher priority apps demand is more.\n      Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n          tmpApp.getPending());\n      Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n\n      if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n          userLimitResource)) {\n        Resource idealAssigned \u003d Resources.min(rc, clusterResource,\n            appIdealAssigned,\n            Resources.subtract(userLimitResource, idealAssignedForUser));\n        tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n            clusterResource, queueReassignableResource, idealAssigned));\n        Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n      } else {\n        continue;\n      }\n\n      // Also set how much resource is needed by this app from others.\n      Resource appUsedExcludedSelected \u003d Resources\n          .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n      if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n          appUsedExcludedSelected)) {\n        tmpApp.setToBePreemptFromOther(\n            Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n      }\n\n      Resources.subtractFromNonNegative(queueReassignableResource,\n          tmpApp.idealAssigned);\n    }\n\n    return orderedApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoIntraQueuePreemptionPlugin.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, partitionBasedResource-Resource, tq-TempQueuePerPartition, selectedCandidates-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, queueReassignableResource-Resource, orderedByPriority-PriorityQueue\u003cTempAppPerPartition\u003e, perUserAMUsed-Map\u003cString,Resource\u003e]",
            "newValue": "[clusterResource-Resource, tq-TempQueuePerPartition, selectedCandidates-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, queueReassignableResource-Resource, orderedByPriority-PriorityQueue\u003cTempAppPerPartition\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2113. Add cross-user preemption within CapacityScheduler\u0027s leaf-queue. (Sunil G via wangda)\n\nChange-Id: I9b19f69788068be05b3295247cdd7b972f8a573c\n",
          "commitDate": "22/05/17 2:26 PM",
          "commitName": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "09/02/17 10:23 AM",
          "commitNameOld": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 102.13,
          "commitsBetweenForRepo": 587,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,69 @@\n   private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n-      Resource clusterResource, Resource partitionBasedResource,\n-      TempQueuePerPartition tq,\n+      Resource clusterResource, TempQueuePerPartition tq,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource queueReassignableResource,\n-      PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority,\n-      Map\u003cString, Resource\u003e perUserAMUsed) {\n+      PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority) {\n \n     Comparator\u003cTempAppPerPartition\u003e reverseComp \u003d Collections\n         .reverseOrder(new TAPriorityComparator());\n     TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n \n-    Map\u003cString, Resource\u003e userIdealAssignedMapping \u003d new HashMap\u003c\u003e();\n     String partition \u003d tq.partition;\n-\n-    Map\u003cString, Resource\u003e preCalculatedUserLimit \u003d\n-        new HashMap\u003cString, Resource\u003e();\n+    Map\u003cString, TempUserPerPartition\u003e usersPerPartition \u003d tq.getUsersPerPartition();\n \n     while (!orderedByPriority.isEmpty()) {\n       // Remove app from the next highest remaining priority and process it to\n       // calculate idealAssigned per app.\n       TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n       orderedApps.add(tmpApp);\n \n       // Once unallocated resource is 0, we can stop assigning ideal per app.\n       if (Resources.lessThanOrEqual(rc, clusterResource,\n-          queueReassignableResource, Resources.none())) {\n+          queueReassignableResource, Resources.none())\n+          || Resources.isAnyMajorResourceZero(rc, queueReassignableResource)) {\n         continue;\n       }\n \n       String userName \u003d tmpApp.app.getUser();\n-      Resource userLimitResource \u003d preCalculatedUserLimit.get(userName);\n-\n-      // Verify whether we already calculated headroom for this user.\n-      if (userLimitResource \u003d\u003d null) {\n-        userLimitResource \u003d Resources.clone(\n-            tq.leafQueue.getResourceLimitForAllUsers(userName, clusterResource,\n-                partition, SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY));\n-\n-        Resource amUsed \u003d perUserAMUsed.get(userName);\n-        if (null \u003d\u003d amUsed) {\n-          amUsed \u003d Resources.createResource(0, 0);\n-        }\n-\n-        // Real AM used need not have to be considered for user-limit as well.\n-        userLimitResource \u003d Resources.subtract(userLimitResource, amUsed);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Userlimit for user \u0027\" + userName + \"\u0027 is :\"\n-              + userLimitResource + \", and amUsed is:\" + amUsed);\n-        }\n-\n-        preCalculatedUserLimit.put(userName, userLimitResource);\n-      }\n-\n-      Resource idealAssignedForUser \u003d userIdealAssignedMapping.get(userName);\n-\n-      if (idealAssignedForUser \u003d\u003d null) {\n-        idealAssignedForUser \u003d Resources.createResource(0, 0);\n-        userIdealAssignedMapping.put(userName, idealAssignedForUser);\n-      }\n+      TempUserPerPartition tmpUser \u003d usersPerPartition.get(userName);\n+      Resource userLimitResource \u003d tmpUser.getUserLimit();\n+      Resource idealAssignedForUser \u003d tmpUser.idealAssigned;\n \n       // Calculate total selected container resources from current app.\n-      getAlreadySelectedPreemptionCandidatesResource(selectedCandidates,\n-          tmpApp, partition);\n+      getAlreadySelectedPreemptionCandidatesResource(selectedCandidates, tmpApp,\n+          tmpUser, partition);\n \n       // For any app, used+pending will give its idealAssigned. However it will\n       // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n       // idealAssigned may fall to 0 if higher priority apps demand is more.\n       Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n           tmpApp.getPending());\n       Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n \n       if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n           userLimitResource)) {\n-        appIdealAssigned \u003d Resources.min(rc, clusterResource, appIdealAssigned,\n+        Resource idealAssigned \u003d Resources.min(rc, clusterResource,\n+            appIdealAssigned,\n             Resources.subtract(userLimitResource, idealAssignedForUser));\n         tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n-            clusterResource, queueReassignableResource, appIdealAssigned));\n+            clusterResource, queueReassignableResource, idealAssigned));\n         Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n       } else {\n         continue;\n       }\n \n       // Also set how much resource is needed by this app from others.\n       Resource appUsedExcludedSelected \u003d Resources\n           .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n       if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n           appUsedExcludedSelected)) {\n         tmpApp.setToBePreemptFromOther(\n             Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n       }\n \n-      Resources.subtractFrom(queueReassignableResource, tmpApp.idealAssigned);\n+      Resources.subtractFromNonNegative(queueReassignableResource,\n+          tmpApp.idealAssigned);\n     }\n \n     return orderedApps;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n      Resource clusterResource, TempQueuePerPartition tq,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource queueReassignableResource,\n      PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority) {\n\n    Comparator\u003cTempAppPerPartition\u003e reverseComp \u003d Collections\n        .reverseOrder(new TAPriorityComparator());\n    TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n\n    String partition \u003d tq.partition;\n    Map\u003cString, TempUserPerPartition\u003e usersPerPartition \u003d tq.getUsersPerPartition();\n\n    while (!orderedByPriority.isEmpty()) {\n      // Remove app from the next highest remaining priority and process it to\n      // calculate idealAssigned per app.\n      TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n      orderedApps.add(tmpApp);\n\n      // Once unallocated resource is 0, we can stop assigning ideal per app.\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n          queueReassignableResource, Resources.none())\n          || Resources.isAnyMajorResourceZero(rc, queueReassignableResource)) {\n        continue;\n      }\n\n      String userName \u003d tmpApp.app.getUser();\n      TempUserPerPartition tmpUser \u003d usersPerPartition.get(userName);\n      Resource userLimitResource \u003d tmpUser.getUserLimit();\n      Resource idealAssignedForUser \u003d tmpUser.idealAssigned;\n\n      // Calculate total selected container resources from current app.\n      getAlreadySelectedPreemptionCandidatesResource(selectedCandidates, tmpApp,\n          tmpUser, partition);\n\n      // For any app, used+pending will give its idealAssigned. However it will\n      // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n      // idealAssigned may fall to 0 if higher priority apps demand is more.\n      Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n          tmpApp.getPending());\n      Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n\n      if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n          userLimitResource)) {\n        Resource idealAssigned \u003d Resources.min(rc, clusterResource,\n            appIdealAssigned,\n            Resources.subtract(userLimitResource, idealAssignedForUser));\n        tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n            clusterResource, queueReassignableResource, idealAssigned));\n        Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n      } else {\n        continue;\n      }\n\n      // Also set how much resource is needed by this app from others.\n      Resource appUsedExcludedSelected \u003d Resources\n          .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n      if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n          appUsedExcludedSelected)) {\n        tmpApp.setToBePreemptFromOther(\n            Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n      }\n\n      Resources.subtractFromNonNegative(queueReassignableResource,\n          tmpApp.idealAssigned);\n    }\n\n    return orderedApps;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoIntraQueuePreemptionPlugin.java",
          "extendedDetails": {}
        }
      ]
    },
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5889. Improve and refactor user-limit calculation in Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "09/02/17 10:23 AM",
      "commitName": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "31/10/16 3:18 PM",
      "commitNameOld": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 100.84,
      "commitsBetweenForRepo": 568,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,97 @@\n   private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n       Resource clusterResource, Resource partitionBasedResource,\n       TempQueuePerPartition tq,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource queueReassignableResource,\n       PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority,\n       Map\u003cString, Resource\u003e perUserAMUsed) {\n \n     Comparator\u003cTempAppPerPartition\u003e reverseComp \u003d Collections\n         .reverseOrder(new TAPriorityComparator());\n     TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n \n     Map\u003cString, Resource\u003e userIdealAssignedMapping \u003d new HashMap\u003c\u003e();\n     String partition \u003d tq.partition;\n \n     Map\u003cString, Resource\u003e preCalculatedUserLimit \u003d\n         new HashMap\u003cString, Resource\u003e();\n \n     while (!orderedByPriority.isEmpty()) {\n       // Remove app from the next highest remaining priority and process it to\n       // calculate idealAssigned per app.\n       TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n       orderedApps.add(tmpApp);\n \n       // Once unallocated resource is 0, we can stop assigning ideal per app.\n       if (Resources.lessThanOrEqual(rc, clusterResource,\n           queueReassignableResource, Resources.none())) {\n         continue;\n       }\n \n       String userName \u003d tmpApp.app.getUser();\n       Resource userLimitResource \u003d preCalculatedUserLimit.get(userName);\n \n       // Verify whether we already calculated headroom for this user.\n       if (userLimitResource \u003d\u003d null) {\n-        userLimitResource \u003d Resources.clone(tq.leafQueue\n-            .getUserLimitPerUser(userName, partitionBasedResource, partition));\n+        userLimitResource \u003d Resources.clone(\n+            tq.leafQueue.getResourceLimitForAllUsers(userName, clusterResource,\n+                partition, SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY));\n \n         Resource amUsed \u003d perUserAMUsed.get(userName);\n         if (null \u003d\u003d amUsed) {\n           amUsed \u003d Resources.createResource(0, 0);\n         }\n \n         // Real AM used need not have to be considered for user-limit as well.\n         userLimitResource \u003d Resources.subtract(userLimitResource, amUsed);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Userlimit for user \u0027\" + userName + \"\u0027 is :\"\n               + userLimitResource + \", and amUsed is:\" + amUsed);\n         }\n \n         preCalculatedUserLimit.put(userName, userLimitResource);\n       }\n \n       Resource idealAssignedForUser \u003d userIdealAssignedMapping.get(userName);\n \n       if (idealAssignedForUser \u003d\u003d null) {\n         idealAssignedForUser \u003d Resources.createResource(0, 0);\n         userIdealAssignedMapping.put(userName, idealAssignedForUser);\n       }\n \n       // Calculate total selected container resources from current app.\n       getAlreadySelectedPreemptionCandidatesResource(selectedCandidates,\n           tmpApp, partition);\n \n       // For any app, used+pending will give its idealAssigned. However it will\n       // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n       // idealAssigned may fall to 0 if higher priority apps demand is more.\n       Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n           tmpApp.getPending());\n       Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n \n       if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n           userLimitResource)) {\n         appIdealAssigned \u003d Resources.min(rc, clusterResource, appIdealAssigned,\n             Resources.subtract(userLimitResource, idealAssignedForUser));\n         tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n             clusterResource, queueReassignableResource, appIdealAssigned));\n         Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n       } else {\n         continue;\n       }\n \n       // Also set how much resource is needed by this app from others.\n       Resource appUsedExcludedSelected \u003d Resources\n           .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n       if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n           appUsedExcludedSelected)) {\n         tmpApp.setToBePreemptFromOther(\n             Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n       }\n \n       Resources.subtractFrom(queueReassignableResource, tmpApp.idealAssigned);\n     }\n \n     return orderedApps;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n      Resource clusterResource, Resource partitionBasedResource,\n      TempQueuePerPartition tq,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource queueReassignableResource,\n      PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority,\n      Map\u003cString, Resource\u003e perUserAMUsed) {\n\n    Comparator\u003cTempAppPerPartition\u003e reverseComp \u003d Collections\n        .reverseOrder(new TAPriorityComparator());\n    TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n\n    Map\u003cString, Resource\u003e userIdealAssignedMapping \u003d new HashMap\u003c\u003e();\n    String partition \u003d tq.partition;\n\n    Map\u003cString, Resource\u003e preCalculatedUserLimit \u003d\n        new HashMap\u003cString, Resource\u003e();\n\n    while (!orderedByPriority.isEmpty()) {\n      // Remove app from the next highest remaining priority and process it to\n      // calculate idealAssigned per app.\n      TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n      orderedApps.add(tmpApp);\n\n      // Once unallocated resource is 0, we can stop assigning ideal per app.\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n          queueReassignableResource, Resources.none())) {\n        continue;\n      }\n\n      String userName \u003d tmpApp.app.getUser();\n      Resource userLimitResource \u003d preCalculatedUserLimit.get(userName);\n\n      // Verify whether we already calculated headroom for this user.\n      if (userLimitResource \u003d\u003d null) {\n        userLimitResource \u003d Resources.clone(\n            tq.leafQueue.getResourceLimitForAllUsers(userName, clusterResource,\n                partition, SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY));\n\n        Resource amUsed \u003d perUserAMUsed.get(userName);\n        if (null \u003d\u003d amUsed) {\n          amUsed \u003d Resources.createResource(0, 0);\n        }\n\n        // Real AM used need not have to be considered for user-limit as well.\n        userLimitResource \u003d Resources.subtract(userLimitResource, amUsed);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Userlimit for user \u0027\" + userName + \"\u0027 is :\"\n              + userLimitResource + \", and amUsed is:\" + amUsed);\n        }\n\n        preCalculatedUserLimit.put(userName, userLimitResource);\n      }\n\n      Resource idealAssignedForUser \u003d userIdealAssignedMapping.get(userName);\n\n      if (idealAssignedForUser \u003d\u003d null) {\n        idealAssignedForUser \u003d Resources.createResource(0, 0);\n        userIdealAssignedMapping.put(userName, idealAssignedForUser);\n      }\n\n      // Calculate total selected container resources from current app.\n      getAlreadySelectedPreemptionCandidatesResource(selectedCandidates,\n          tmpApp, partition);\n\n      // For any app, used+pending will give its idealAssigned. However it will\n      // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n      // idealAssigned may fall to 0 if higher priority apps demand is more.\n      Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n          tmpApp.getPending());\n      Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n\n      if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n          userLimitResource)) {\n        appIdealAssigned \u003d Resources.min(rc, clusterResource, appIdealAssigned,\n            Resources.subtract(userLimitResource, idealAssignedForUser));\n        tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n            clusterResource, queueReassignableResource, appIdealAssigned));\n        Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n      } else {\n        continue;\n      }\n\n      // Also set how much resource is needed by this app from others.\n      Resource appUsedExcludedSelected \u003d Resources\n          .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n      if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n          appUsedExcludedSelected)) {\n        tmpApp.setToBePreemptFromOther(\n            Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n      }\n\n      Resources.subtractFrom(queueReassignableResource, tmpApp.idealAssigned);\n    }\n\n    return orderedApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoIntraQueuePreemptionPlugin.java",
      "extendedDetails": {}
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,96 @@\n+  private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n+      Resource clusterResource, Resource partitionBasedResource,\n+      TempQueuePerPartition tq,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n+      Resource queueReassignableResource,\n+      PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority,\n+      Map\u003cString, Resource\u003e perUserAMUsed) {\n+\n+    Comparator\u003cTempAppPerPartition\u003e reverseComp \u003d Collections\n+        .reverseOrder(new TAPriorityComparator());\n+    TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n+\n+    Map\u003cString, Resource\u003e userIdealAssignedMapping \u003d new HashMap\u003c\u003e();\n+    String partition \u003d tq.partition;\n+\n+    Map\u003cString, Resource\u003e preCalculatedUserLimit \u003d\n+        new HashMap\u003cString, Resource\u003e();\n+\n+    while (!orderedByPriority.isEmpty()) {\n+      // Remove app from the next highest remaining priority and process it to\n+      // calculate idealAssigned per app.\n+      TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n+      orderedApps.add(tmpApp);\n+\n+      // Once unallocated resource is 0, we can stop assigning ideal per app.\n+      if (Resources.lessThanOrEqual(rc, clusterResource,\n+          queueReassignableResource, Resources.none())) {\n+        continue;\n+      }\n+\n+      String userName \u003d tmpApp.app.getUser();\n+      Resource userLimitResource \u003d preCalculatedUserLimit.get(userName);\n+\n+      // Verify whether we already calculated headroom for this user.\n+      if (userLimitResource \u003d\u003d null) {\n+        userLimitResource \u003d Resources.clone(tq.leafQueue\n+            .getUserLimitPerUser(userName, partitionBasedResource, partition));\n+\n+        Resource amUsed \u003d perUserAMUsed.get(userName);\n+        if (null \u003d\u003d amUsed) {\n+          amUsed \u003d Resources.createResource(0, 0);\n+        }\n+\n+        // Real AM used need not have to be considered for user-limit as well.\n+        userLimitResource \u003d Resources.subtract(userLimitResource, amUsed);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Userlimit for user \u0027\" + userName + \"\u0027 is :\"\n+              + userLimitResource + \", and amUsed is:\" + amUsed);\n+        }\n+\n+        preCalculatedUserLimit.put(userName, userLimitResource);\n+      }\n+\n+      Resource idealAssignedForUser \u003d userIdealAssignedMapping.get(userName);\n+\n+      if (idealAssignedForUser \u003d\u003d null) {\n+        idealAssignedForUser \u003d Resources.createResource(0, 0);\n+        userIdealAssignedMapping.put(userName, idealAssignedForUser);\n+      }\n+\n+      // Calculate total selected container resources from current app.\n+      getAlreadySelectedPreemptionCandidatesResource(selectedCandidates,\n+          tmpApp, partition);\n+\n+      // For any app, used+pending will give its idealAssigned. However it will\n+      // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n+      // idealAssigned may fall to 0 if higher priority apps demand is more.\n+      Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n+          tmpApp.getPending());\n+      Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n+\n+      if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n+          userLimitResource)) {\n+        appIdealAssigned \u003d Resources.min(rc, clusterResource, appIdealAssigned,\n+            Resources.subtract(userLimitResource, idealAssignedForUser));\n+        tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n+            clusterResource, queueReassignableResource, appIdealAssigned));\n+        Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n+      } else {\n+        continue;\n+      }\n+\n+      // Also set how much resource is needed by this app from others.\n+      Resource appUsedExcludedSelected \u003d Resources\n+          .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n+      if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n+          appUsedExcludedSelected)) {\n+        tmpApp.setToBePreemptFromOther(\n+            Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n+      }\n+\n+      Resources.subtractFrom(queueReassignableResource, tmpApp.idealAssigned);\n+    }\n+\n+    return orderedApps;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private TreeSet\u003cTempAppPerPartition\u003e calculateIdealAssignedResourcePerApp(\n      Resource clusterResource, Resource partitionBasedResource,\n      TempQueuePerPartition tq,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource queueReassignableResource,\n      PriorityQueue\u003cTempAppPerPartition\u003e orderedByPriority,\n      Map\u003cString, Resource\u003e perUserAMUsed) {\n\n    Comparator\u003cTempAppPerPartition\u003e reverseComp \u003d Collections\n        .reverseOrder(new TAPriorityComparator());\n    TreeSet\u003cTempAppPerPartition\u003e orderedApps \u003d new TreeSet\u003c\u003e(reverseComp);\n\n    Map\u003cString, Resource\u003e userIdealAssignedMapping \u003d new HashMap\u003c\u003e();\n    String partition \u003d tq.partition;\n\n    Map\u003cString, Resource\u003e preCalculatedUserLimit \u003d\n        new HashMap\u003cString, Resource\u003e();\n\n    while (!orderedByPriority.isEmpty()) {\n      // Remove app from the next highest remaining priority and process it to\n      // calculate idealAssigned per app.\n      TempAppPerPartition tmpApp \u003d orderedByPriority.remove();\n      orderedApps.add(tmpApp);\n\n      // Once unallocated resource is 0, we can stop assigning ideal per app.\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n          queueReassignableResource, Resources.none())) {\n        continue;\n      }\n\n      String userName \u003d tmpApp.app.getUser();\n      Resource userLimitResource \u003d preCalculatedUserLimit.get(userName);\n\n      // Verify whether we already calculated headroom for this user.\n      if (userLimitResource \u003d\u003d null) {\n        userLimitResource \u003d Resources.clone(tq.leafQueue\n            .getUserLimitPerUser(userName, partitionBasedResource, partition));\n\n        Resource amUsed \u003d perUserAMUsed.get(userName);\n        if (null \u003d\u003d amUsed) {\n          amUsed \u003d Resources.createResource(0, 0);\n        }\n\n        // Real AM used need not have to be considered for user-limit as well.\n        userLimitResource \u003d Resources.subtract(userLimitResource, amUsed);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Userlimit for user \u0027\" + userName + \"\u0027 is :\"\n              + userLimitResource + \", and amUsed is:\" + amUsed);\n        }\n\n        preCalculatedUserLimit.put(userName, userLimitResource);\n      }\n\n      Resource idealAssignedForUser \u003d userIdealAssignedMapping.get(userName);\n\n      if (idealAssignedForUser \u003d\u003d null) {\n        idealAssignedForUser \u003d Resources.createResource(0, 0);\n        userIdealAssignedMapping.put(userName, idealAssignedForUser);\n      }\n\n      // Calculate total selected container resources from current app.\n      getAlreadySelectedPreemptionCandidatesResource(selectedCandidates,\n          tmpApp, partition);\n\n      // For any app, used+pending will give its idealAssigned. However it will\n      // be tightly linked to queue\u0027s unallocated quota. So lower priority apps\n      // idealAssigned may fall to 0 if higher priority apps demand is more.\n      Resource appIdealAssigned \u003d Resources.add(tmpApp.getUsedDeductAM(),\n          tmpApp.getPending());\n      Resources.subtractFrom(appIdealAssigned, tmpApp.selected);\n\n      if (Resources.lessThan(rc, clusterResource, idealAssignedForUser,\n          userLimitResource)) {\n        appIdealAssigned \u003d Resources.min(rc, clusterResource, appIdealAssigned,\n            Resources.subtract(userLimitResource, idealAssignedForUser));\n        tmpApp.idealAssigned \u003d Resources.clone(Resources.min(rc,\n            clusterResource, queueReassignableResource, appIdealAssigned));\n        Resources.addTo(idealAssignedForUser, tmpApp.idealAssigned);\n      } else {\n        continue;\n      }\n\n      // Also set how much resource is needed by this app from others.\n      Resource appUsedExcludedSelected \u003d Resources\n          .subtract(tmpApp.getUsedDeductAM(), tmpApp.selected);\n      if (Resources.greaterThan(rc, clusterResource, tmpApp.idealAssigned,\n          appUsedExcludedSelected)) {\n        tmpApp.setToBePreemptFromOther(\n            Resources.subtract(tmpApp.idealAssigned, appUsedExcludedSelected));\n      }\n\n      Resources.subtractFrom(queueReassignableResource, tmpApp.idealAssigned);\n    }\n\n    return orderedApps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoIntraQueuePreemptionPlugin.java"
    }
  }
}