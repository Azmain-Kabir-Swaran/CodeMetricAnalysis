{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ProportionalCapacityPreemptionPolicy.java",
  "functionName": "updateConfigIfNeeded",
  "functionId": "updateConfigIfNeeded",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
  "functionStartLine": 174,
  "functionEndLine": 305,
  "numCommitsSeen": 49,
  "timeTaken": 2148,
  "changeHistory": [
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
    "e6ec02001fc4eed9eb51c8653d8f931135e49eda"
  ],
  "changeHistoryShort": {
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": "Ybodychange",
    "e6ec02001fc4eed9eb51c8653d8f931135e49eda": "Yintroduced"
  },
  "changeHistoryDetails": {
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
      "commitDate": "28/06/18 10:23 AM",
      "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
      "commitAuthor": "Sunil G",
      "commitDateOld": "12/06/18 8:35 AM",
      "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 16.07,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,132 @@\n   private void updateConfigIfNeeded() {\n     CapacitySchedulerConfiguration config \u003d scheduler.getConfiguration();\n     if (config \u003d\u003d csConfig) {\n       return;\n     }\n \n     maxIgnoredOverCapacity \u003d config.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n \n     naturalTerminationFactor \u003d config.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n \n     maxWaitTime \u003d config.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n \n     monitoringInterval \u003d config.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n \n     percentageClusterPreemptionAllowed \u003d config.getFloat(\n         CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n         CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n \n     observeOnly \u003d config.getBoolean(\n         CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n \n     lazyPreempionEnabled \u003d config.getBoolean(\n         CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENABLED,\n         CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n \n     maxAllowableLimitForIntraQueuePreemption \u003d config.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n \n     minimumThresholdForIntraQueuePreemption \u003d config.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n \n     intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n         .valueOf(config\n             .get(\n                 CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n                 CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n             .toUpperCase());\n \n     candidatesSelectionPolicies \u003d new ArrayList\u003c\u003e();\n \n     // Do we need white queue-priority preemption policy?\n     boolean isQueuePriorityPreemptionEnabled \u003d\n         config.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n     if (isQueuePriorityPreemptionEnabled) {\n       candidatesSelectionPolicies.add(\n           new QueuePriorityContainerCandidateSelector(this));\n     }\n \n     // Do we need to specially consider reserved containers?\n     boolean selectCandidatesForResevedContainers \u003d config.getBoolean(\n         CapacitySchedulerConfiguration.\n         PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n         CapacitySchedulerConfiguration.\n         DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n     if (selectCandidatesForResevedContainers) {\n       candidatesSelectionPolicies\n           .add(new ReservedContainerCandidatesSelector(this));\n     }\n \n     boolean additionalPreemptionBasedOnReservedResource \u003d config.getBoolean(\n         CapacitySchedulerConfiguration.ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS,\n         CapacitySchedulerConfiguration.DEFAULT_ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS);\n \n     // initialize candidates preemption selection policies\n     candidatesSelectionPolicies.add(new FifoCandidatesSelector(this,\n-        additionalPreemptionBasedOnReservedResource));\n+        additionalPreemptionBasedOnReservedResource, false));\n+\n+    // Do we need to do preemption to balance queue even after queues get satisfied?\n+    boolean isPreemptionToBalanceRequired \u003d config.getBoolean(\n+        CapacitySchedulerConfiguration.PREEMPTION_TO_BALANCE_QUEUES_BEYOND_GUARANTEED,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_TO_BALANCE_QUEUES_BEYOND_GUARANTEED);\n+    long maximumKillWaitTimeForPreemptionToQueueBalance \u003d config.getLong(\n+        CapacitySchedulerConfiguration.MAX_WAIT_BEFORE_KILL_FOR_QUEUE_BALANCE_PREEMPTION,\n+        CapacitySchedulerConfiguration.DEFAULT_MAX_WAIT_BEFORE_KILL_FOR_QUEUE_BALANCE_PREEMPTION);\n+    if (isPreemptionToBalanceRequired) {\n+      PreemptionCandidatesSelector selector \u003d new FifoCandidatesSelector(this,\n+          false, true);\n+      selector.setMaximumKillWaitTime(maximumKillWaitTimeForPreemptionToQueueBalance);\n+      candidatesSelectionPolicies.add(selector);\n+    }\n \n     // Do we need to specially consider intra queue\n     boolean isIntraQueuePreemptionEnabled \u003d config.getBoolean(\n         CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n         CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n     if (isIntraQueuePreemptionEnabled) {\n       candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n     }\n \n     LOG.info(\"Capacity Scheduler configuration changed, updated preemption \" +\n         \"properties to:\\n\" +\n         \"max_ignored_over_capacity \u003d \" + maxIgnoredOverCapacity + \"\\n\" +\n         \"natural_termination_factor \u003d \" + naturalTerminationFactor + \"\\n\" +\n         \"max_wait_before_kill \u003d \" + maxWaitTime + \"\\n\" +\n         \"monitoring_interval \u003d \" + monitoringInterval + \"\\n\" +\n         \"total_preemption_per_round \u003d \" + percentageClusterPreemptionAllowed +\n           \"\\n\" +\n         \"observe_only \u003d \" + observeOnly + \"\\n\" +\n         \"lazy-preemption-enabled \u003d \" + lazyPreempionEnabled + \"\\n\" +\n         \"intra-queue-preemption.enabled \u003d \" + isIntraQueuePreemptionEnabled +\n           \"\\n\" +\n         \"intra-queue-preemption.max-allowable-limit \u003d \" +\n           maxAllowableLimitForIntraQueuePreemption + \"\\n\" +\n         \"intra-queue-preemption.minimum-threshold \u003d \" +\n           minimumThresholdForIntraQueuePreemption + \"\\n\" +\n         \"intra-queue-preemption.preemption-order-policy \u003d \" +\n           intraQueuePreemptionOrderPolicy + \"\\n\" +\n         \"priority-utilization.underutilized-preemption.enabled \u003d \" +\n           isQueuePriorityPreemptionEnabled + \"\\n\" +\n         \"select_based_on_reserved_containers \u003d \" +\n           selectCandidatesForResevedContainers + \"\\n\" +\n         \"additional_res_balance_based_on_reserved_containers \u003d \" +\n-          additionalPreemptionBasedOnReservedResource);\n+          additionalPreemptionBasedOnReservedResource + \"\\n\" +\n+        \"Preemption-to-balance-queue-enabled \u003d \" + isPreemptionToBalanceRequired);\n \n     csConfig \u003d config;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateConfigIfNeeded() {\n    CapacitySchedulerConfiguration config \u003d scheduler.getConfiguration();\n    if (config \u003d\u003d csConfig) {\n      return;\n    }\n\n    maxIgnoredOverCapacity \u003d config.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n\n    naturalTerminationFactor \u003d config.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n\n    maxWaitTime \u003d config.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n\n    monitoringInterval \u003d config.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n\n    percentageClusterPreemptionAllowed \u003d config.getFloat(\n        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n\n    observeOnly \u003d config.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n\n    lazyPreempionEnabled \u003d config.getBoolean(\n        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENABLED,\n        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n\n    maxAllowableLimitForIntraQueuePreemption \u003d config.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n\n    minimumThresholdForIntraQueuePreemption \u003d config.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n\n    intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n        .valueOf(config\n            .get(\n                CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n                CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n            .toUpperCase());\n\n    candidatesSelectionPolicies \u003d new ArrayList\u003c\u003e();\n\n    // Do we need white queue-priority preemption policy?\n    boolean isQueuePriorityPreemptionEnabled \u003d\n        config.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n    if (isQueuePriorityPreemptionEnabled) {\n      candidatesSelectionPolicies.add(\n          new QueuePriorityContainerCandidateSelector(this));\n    }\n\n    // Do we need to specially consider reserved containers?\n    boolean selectCandidatesForResevedContainers \u003d config.getBoolean(\n        CapacitySchedulerConfiguration.\n        PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.\n        DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n    if (selectCandidatesForResevedContainers) {\n      candidatesSelectionPolicies\n          .add(new ReservedContainerCandidatesSelector(this));\n    }\n\n    boolean additionalPreemptionBasedOnReservedResource \u003d config.getBoolean(\n        CapacitySchedulerConfiguration.ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.DEFAULT_ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS);\n\n    // initialize candidates preemption selection policies\n    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this,\n        additionalPreemptionBasedOnReservedResource, false));\n\n    // Do we need to do preemption to balance queue even after queues get satisfied?\n    boolean isPreemptionToBalanceRequired \u003d config.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_TO_BALANCE_QUEUES_BEYOND_GUARANTEED,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_TO_BALANCE_QUEUES_BEYOND_GUARANTEED);\n    long maximumKillWaitTimeForPreemptionToQueueBalance \u003d config.getLong(\n        CapacitySchedulerConfiguration.MAX_WAIT_BEFORE_KILL_FOR_QUEUE_BALANCE_PREEMPTION,\n        CapacitySchedulerConfiguration.DEFAULT_MAX_WAIT_BEFORE_KILL_FOR_QUEUE_BALANCE_PREEMPTION);\n    if (isPreemptionToBalanceRequired) {\n      PreemptionCandidatesSelector selector \u003d new FifoCandidatesSelector(this,\n          false, true);\n      selector.setMaximumKillWaitTime(maximumKillWaitTimeForPreemptionToQueueBalance);\n      candidatesSelectionPolicies.add(selector);\n    }\n\n    // Do we need to specially consider intra queue\n    boolean isIntraQueuePreemptionEnabled \u003d config.getBoolean(\n        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n        CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n    if (isIntraQueuePreemptionEnabled) {\n      candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n    }\n\n    LOG.info(\"Capacity Scheduler configuration changed, updated preemption \" +\n        \"properties to:\\n\" +\n        \"max_ignored_over_capacity \u003d \" + maxIgnoredOverCapacity + \"\\n\" +\n        \"natural_termination_factor \u003d \" + naturalTerminationFactor + \"\\n\" +\n        \"max_wait_before_kill \u003d \" + maxWaitTime + \"\\n\" +\n        \"monitoring_interval \u003d \" + monitoringInterval + \"\\n\" +\n        \"total_preemption_per_round \u003d \" + percentageClusterPreemptionAllowed +\n          \"\\n\" +\n        \"observe_only \u003d \" + observeOnly + \"\\n\" +\n        \"lazy-preemption-enabled \u003d \" + lazyPreempionEnabled + \"\\n\" +\n        \"intra-queue-preemption.enabled \u003d \" + isIntraQueuePreemptionEnabled +\n          \"\\n\" +\n        \"intra-queue-preemption.max-allowable-limit \u003d \" +\n          maxAllowableLimitForIntraQueuePreemption + \"\\n\" +\n        \"intra-queue-preemption.minimum-threshold \u003d \" +\n          minimumThresholdForIntraQueuePreemption + \"\\n\" +\n        \"intra-queue-preemption.preemption-order-policy \u003d \" +\n          intraQueuePreemptionOrderPolicy + \"\\n\" +\n        \"priority-utilization.underutilized-preemption.enabled \u003d \" +\n          isQueuePriorityPreemptionEnabled + \"\\n\" +\n        \"select_based_on_reserved_containers \u003d \" +\n          selectCandidatesForResevedContainers + \"\\n\" +\n        \"additional_res_balance_based_on_reserved_containers \u003d \" +\n          additionalPreemptionBasedOnReservedResource + \"\\n\" +\n        \"Preemption-to-balance-queue-enabled \u003d \" + isPreemptionToBalanceRequired);\n\n    csConfig \u003d config;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "e6ec02001fc4eed9eb51c8653d8f931135e49eda": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7370: Preemption properties should be refreshable. Contrubted by Gergely Novák.\n",
      "commitDate": "02/11/17 10:37 AM",
      "commitName": "e6ec02001fc4eed9eb51c8653d8f931135e49eda",
      "commitAuthor": "Eric Payne",
      "diff": "@@ -0,0 +1,117 @@\n+  private void updateConfigIfNeeded() {\n+    CapacitySchedulerConfiguration config \u003d scheduler.getConfiguration();\n+    if (config \u003d\u003d csConfig) {\n+      return;\n+    }\n+\n+    maxIgnoredOverCapacity \u003d config.getDouble(\n+        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n+\n+    naturalTerminationFactor \u003d config.getDouble(\n+        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n+\n+    maxWaitTime \u003d config.getLong(\n+        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n+\n+    monitoringInterval \u003d config.getLong(\n+        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n+\n+    percentageClusterPreemptionAllowed \u003d config.getFloat(\n+        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n+        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n+\n+    observeOnly \u003d config.getBoolean(\n+        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n+\n+    lazyPreempionEnabled \u003d config.getBoolean(\n+        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENABLED,\n+        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n+\n+    maxAllowableLimitForIntraQueuePreemption \u003d config.getFloat(\n+        CapacitySchedulerConfiguration.\n+        INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n+        CapacitySchedulerConfiguration.\n+        DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n+\n+    minimumThresholdForIntraQueuePreemption \u003d config.getFloat(\n+        CapacitySchedulerConfiguration.\n+        INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n+        CapacitySchedulerConfiguration.\n+        DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n+\n+    intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n+        .valueOf(config\n+            .get(\n+                CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n+                CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n+            .toUpperCase());\n+\n+    candidatesSelectionPolicies \u003d new ArrayList\u003c\u003e();\n+\n+    // Do we need white queue-priority preemption policy?\n+    boolean isQueuePriorityPreemptionEnabled \u003d\n+        config.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n+    if (isQueuePriorityPreemptionEnabled) {\n+      candidatesSelectionPolicies.add(\n+          new QueuePriorityContainerCandidateSelector(this));\n+    }\n+\n+    // Do we need to specially consider reserved containers?\n+    boolean selectCandidatesForResevedContainers \u003d config.getBoolean(\n+        CapacitySchedulerConfiguration.\n+        PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n+        CapacitySchedulerConfiguration.\n+        DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n+    if (selectCandidatesForResevedContainers) {\n+      candidatesSelectionPolicies\n+          .add(new ReservedContainerCandidatesSelector(this));\n+    }\n+\n+    boolean additionalPreemptionBasedOnReservedResource \u003d config.getBoolean(\n+        CapacitySchedulerConfiguration.ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS,\n+        CapacitySchedulerConfiguration.DEFAULT_ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS);\n+\n+    // initialize candidates preemption selection policies\n+    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this,\n+        additionalPreemptionBasedOnReservedResource));\n+\n+    // Do we need to specially consider intra queue\n+    boolean isIntraQueuePreemptionEnabled \u003d config.getBoolean(\n+        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n+        CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n+    if (isIntraQueuePreemptionEnabled) {\n+      candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n+    }\n+\n+    LOG.info(\"Capacity Scheduler configuration changed, updated preemption \" +\n+        \"properties to:\\n\" +\n+        \"max_ignored_over_capacity \u003d \" + maxIgnoredOverCapacity + \"\\n\" +\n+        \"natural_termination_factor \u003d \" + naturalTerminationFactor + \"\\n\" +\n+        \"max_wait_before_kill \u003d \" + maxWaitTime + \"\\n\" +\n+        \"monitoring_interval \u003d \" + monitoringInterval + \"\\n\" +\n+        \"total_preemption_per_round \u003d \" + percentageClusterPreemptionAllowed +\n+          \"\\n\" +\n+        \"observe_only \u003d \" + observeOnly + \"\\n\" +\n+        \"lazy-preemption-enabled \u003d \" + lazyPreempionEnabled + \"\\n\" +\n+        \"intra-queue-preemption.enabled \u003d \" + isIntraQueuePreemptionEnabled +\n+          \"\\n\" +\n+        \"intra-queue-preemption.max-allowable-limit \u003d \" +\n+          maxAllowableLimitForIntraQueuePreemption + \"\\n\" +\n+        \"intra-queue-preemption.minimum-threshold \u003d \" +\n+          minimumThresholdForIntraQueuePreemption + \"\\n\" +\n+        \"intra-queue-preemption.preemption-order-policy \u003d \" +\n+          intraQueuePreemptionOrderPolicy + \"\\n\" +\n+        \"priority-utilization.underutilized-preemption.enabled \u003d \" +\n+          isQueuePriorityPreemptionEnabled + \"\\n\" +\n+        \"select_based_on_reserved_containers \u003d \" +\n+          selectCandidatesForResevedContainers + \"\\n\" +\n+        \"additional_res_balance_based_on_reserved_containers \u003d \" +\n+          additionalPreemptionBasedOnReservedResource);\n+\n+    csConfig \u003d config;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateConfigIfNeeded() {\n    CapacitySchedulerConfiguration config \u003d scheduler.getConfiguration();\n    if (config \u003d\u003d csConfig) {\n      return;\n    }\n\n    maxIgnoredOverCapacity \u003d config.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n\n    naturalTerminationFactor \u003d config.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n\n    maxWaitTime \u003d config.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n\n    monitoringInterval \u003d config.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n\n    percentageClusterPreemptionAllowed \u003d config.getFloat(\n        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n\n    observeOnly \u003d config.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n\n    lazyPreempionEnabled \u003d config.getBoolean(\n        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENABLED,\n        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n\n    maxAllowableLimitForIntraQueuePreemption \u003d config.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n\n    minimumThresholdForIntraQueuePreemption \u003d config.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n\n    intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n        .valueOf(config\n            .get(\n                CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n                CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n            .toUpperCase());\n\n    candidatesSelectionPolicies \u003d new ArrayList\u003c\u003e();\n\n    // Do we need white queue-priority preemption policy?\n    boolean isQueuePriorityPreemptionEnabled \u003d\n        config.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n    if (isQueuePriorityPreemptionEnabled) {\n      candidatesSelectionPolicies.add(\n          new QueuePriorityContainerCandidateSelector(this));\n    }\n\n    // Do we need to specially consider reserved containers?\n    boolean selectCandidatesForResevedContainers \u003d config.getBoolean(\n        CapacitySchedulerConfiguration.\n        PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.\n        DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n    if (selectCandidatesForResevedContainers) {\n      candidatesSelectionPolicies\n          .add(new ReservedContainerCandidatesSelector(this));\n    }\n\n    boolean additionalPreemptionBasedOnReservedResource \u003d config.getBoolean(\n        CapacitySchedulerConfiguration.ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.DEFAULT_ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS);\n\n    // initialize candidates preemption selection policies\n    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this,\n        additionalPreemptionBasedOnReservedResource));\n\n    // Do we need to specially consider intra queue\n    boolean isIntraQueuePreemptionEnabled \u003d config.getBoolean(\n        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n        CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n    if (isIntraQueuePreemptionEnabled) {\n      candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n    }\n\n    LOG.info(\"Capacity Scheduler configuration changed, updated preemption \" +\n        \"properties to:\\n\" +\n        \"max_ignored_over_capacity \u003d \" + maxIgnoredOverCapacity + \"\\n\" +\n        \"natural_termination_factor \u003d \" + naturalTerminationFactor + \"\\n\" +\n        \"max_wait_before_kill \u003d \" + maxWaitTime + \"\\n\" +\n        \"monitoring_interval \u003d \" + monitoringInterval + \"\\n\" +\n        \"total_preemption_per_round \u003d \" + percentageClusterPreemptionAllowed +\n          \"\\n\" +\n        \"observe_only \u003d \" + observeOnly + \"\\n\" +\n        \"lazy-preemption-enabled \u003d \" + lazyPreempionEnabled + \"\\n\" +\n        \"intra-queue-preemption.enabled \u003d \" + isIntraQueuePreemptionEnabled +\n          \"\\n\" +\n        \"intra-queue-preemption.max-allowable-limit \u003d \" +\n          maxAllowableLimitForIntraQueuePreemption + \"\\n\" +\n        \"intra-queue-preemption.minimum-threshold \u003d \" +\n          minimumThresholdForIntraQueuePreemption + \"\\n\" +\n        \"intra-queue-preemption.preemption-order-policy \u003d \" +\n          intraQueuePreemptionOrderPolicy + \"\\n\" +\n        \"priority-utilization.underutilized-preemption.enabled \u003d \" +\n          isQueuePriorityPreemptionEnabled + \"\\n\" +\n        \"select_based_on_reserved_containers \u003d \" +\n          selectCandidatesForResevedContainers + \"\\n\" +\n        \"additional_res_balance_based_on_reserved_containers \u003d \" +\n          additionalPreemptionBasedOnReservedResource);\n\n    csConfig \u003d config;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java"
    }
  }
}