{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3ARetryPolicy.java",
  "functionName": "createExceptionMap",
  "functionId": "createExceptionMap",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3ARetryPolicy.java",
  "functionStartLine": 176,
  "functionEndLine": 243,
  "numCommitsSeen": 10,
  "timeTaken": 3416,
  "changeHistory": [
    "e77767bb1e8dfb8b0bd7af4664c900f7238b4fa0",
    "0af4011580878566213016af0c32633eabd15100",
    "6fa229891e06eea62cb9634efde755f40247e816",
    "da9a39eed138210de29b59b90c449b28da1c04f9",
    "b0aff8a96221fbf40d1eafe51b4f530b73146a20",
    "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35"
  ],
  "changeHistoryShort": {
    "e77767bb1e8dfb8b0bd7af4664c900f7238b4fa0": "Ybodychange",
    "0af4011580878566213016af0c32633eabd15100": "Ybodychange",
    "6fa229891e06eea62cb9634efde755f40247e816": "Ybodychange",
    "da9a39eed138210de29b59b90c449b28da1c04f9": "Ybodychange",
    "b0aff8a96221fbf40d1eafe51b4f530b73146a20": "Ybodychange",
    "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e77767bb1e8dfb8b0bd7af4664c900f7238b4fa0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16711.\n\nThis adds a new option fs.s3a.bucket.probe, range (0-2) to\ncontrol which probe for a bucket existence to perform on startup.\n\n0: no checks\n1: v1 check (as has been performend until now)\n2: v2 bucket check, which also incudes a permission check. Default.\n\nWhen set to 0, bucket existence checks won\u0027t be done\nduring initialization thus making it faster.\nWhen the bucket is not available in S3,\nor if fs.s3a.endpoint points to the wrong instance of a private S3 store\nconsecutive calls like listing, read, write etc. will fail with\nan UnknownStoreException.\n\nContributed by:\n  * Mukund Thakur (main patch and tests)\n  * Rajesh Balamohan (v0 list and performance tests)\n  * lqjacklee (HADOOP-15990/v2 list)\n  * Steve Loughran (UnknownStoreException support)\n\n       modified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/Constants.java\n       modified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java\n       modified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3ARetryPolicy.java\n       modified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AUtils.java\n       new file:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/UnknownStoreException.java\n       new file:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/impl/ErrorTranslation.java\n       modified:   hadoop-tools/hadoop-aws/src/site/markdown/tools/hadoop-aws/index.md\n       modified:   hadoop-tools/hadoop-aws/src/site/markdown/tools/hadoop-aws/performance.md\n       modified:   hadoop-tools/hadoop-aws/src/site/markdown/tools/hadoop-aws/troubleshooting_s3a.md\n       modified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/AbstractS3AMockTest.java\n       new file:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/ITestS3ABucketExistence.java\n       modified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/MockS3ClientFactory.java\n       modified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/TestS3AExceptionTranslation.java\n       modified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/AbstractS3GuardToolTestBase.java\n       modified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestS3GuardToolDynamoDB.java\n       modified:   hadoop-tools/hadoop-aws/src/test/resources/core-site.xml\n\nChange-Id: Ic174f803e655af172d81c1274ed92b51bdceb384\n",
      "commitDate": "21/02/20 5:44 AM",
      "commitName": "e77767bb1e8dfb8b0bd7af4664c900f7238b4fa0",
      "commitAuthor": "Mukund Thakur",
      "commitDateOld": "11/09/19 8:46 AM",
      "commitNameOld": "9221704f857e33a5f9e00c19d3705e46e94f427b",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 162.92,
      "commitsBetweenForRepo": 720,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,68 @@\n   protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n     // the policy map maps the exact classname; subclasses do not\n     // inherit policies.\n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n \n     // failfast exceptions which we consider unrecoverable\n     policyMap.put(UnknownHostException.class, fail);\n     policyMap.put(NoRouteToHostException.class, fail);\n     policyMap.put(InterruptedException.class, fail);\n     // note this does not pick up subclasses (like socket timeout)\n     policyMap.put(InterruptedIOException.class, fail);\n     // Access denial and auth exceptions are not retried\n     policyMap.put(AccessDeniedException.class, fail);\n     policyMap.put(NoAuthWithAWSException.class, fail);\n     policyMap.put(FileNotFoundException.class, fail);\n+    policyMap.put(UnknownStoreException.class, fail);\n     policyMap.put(InvalidRequestException.class, fail);\n \n     // metadata stores should do retries internally when it makes sense\n     // so there is no point doing another layer of retries after that\n     policyMap.put(MetadataPersistenceException.class, fail);\n \n     // once the file has changed, trying again is not going to help\n     policyMap.put(RemoteFileChangedException.class, fail);\n \n     // likely only recovered by changing the policy configuration or s3\n     // implementation\n     policyMap.put(NoVersionAttributeException.class, fail);\n \n     // should really be handled by resubmitting to new location;\n     // that\u0027s beyond the scope of this retry policy\n     policyMap.put(AWSRedirectException.class, fail);\n \n     // throttled requests are can be retried, always\n     policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n \n     // connectivity problems are retried without worrying about idempotency\n     policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n \n     // this can be a sign of an HTTP connection breaking early.\n     // which can be reacted to by another attempt if the request was idempotent.\n     // But: could also be a sign of trying to read past the EOF on a GET,\n     // which isn\u0027t going to be recovered from\n     policyMap.put(EOFException.class, retryIdempotentCalls);\n \n     // policy on a 400/bad request still ambiguous.\n     // Treated as an immediate failure\n     policyMap.put(AWSBadRequestException.class, fail);\n \n     // Status 500 error code is also treated as a connectivity problem\n     policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n \n     // server didn\u0027t respond.\n     policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n \n     // other operations\n     policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n     policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n     policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n     policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n \n     // Dynamo DB exceptions\n     // asking for more than you should get. It\u0027s a retry but should be logged\n     // trigger sleep\n     policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n \n     return policyMap;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n    // the policy map maps the exact classname; subclasses do not\n    // inherit policies.\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n\n    // failfast exceptions which we consider unrecoverable\n    policyMap.put(UnknownHostException.class, fail);\n    policyMap.put(NoRouteToHostException.class, fail);\n    policyMap.put(InterruptedException.class, fail);\n    // note this does not pick up subclasses (like socket timeout)\n    policyMap.put(InterruptedIOException.class, fail);\n    // Access denial and auth exceptions are not retried\n    policyMap.put(AccessDeniedException.class, fail);\n    policyMap.put(NoAuthWithAWSException.class, fail);\n    policyMap.put(FileNotFoundException.class, fail);\n    policyMap.put(UnknownStoreException.class, fail);\n    policyMap.put(InvalidRequestException.class, fail);\n\n    // metadata stores should do retries internally when it makes sense\n    // so there is no point doing another layer of retries after that\n    policyMap.put(MetadataPersistenceException.class, fail);\n\n    // once the file has changed, trying again is not going to help\n    policyMap.put(RemoteFileChangedException.class, fail);\n\n    // likely only recovered by changing the policy configuration or s3\n    // implementation\n    policyMap.put(NoVersionAttributeException.class, fail);\n\n    // should really be handled by resubmitting to new location;\n    // that\u0027s beyond the scope of this retry policy\n    policyMap.put(AWSRedirectException.class, fail);\n\n    // throttled requests are can be retried, always\n    policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n\n    // connectivity problems are retried without worrying about idempotency\n    policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n\n    // this can be a sign of an HTTP connection breaking early.\n    // which can be reacted to by another attempt if the request was idempotent.\n    // But: could also be a sign of trying to read past the EOF on a GET,\n    // which isn\u0027t going to be recovered from\n    policyMap.put(EOFException.class, retryIdempotentCalls);\n\n    // policy on a 400/bad request still ambiguous.\n    // Treated as an immediate failure\n    policyMap.put(AWSBadRequestException.class, fail);\n\n    // Status 500 error code is also treated as a connectivity problem\n    policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n\n    // server didn\u0027t respond.\n    policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n\n    // other operations\n    policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n    policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n\n    // Dynamo DB exceptions\n    // asking for more than you should get. It\u0027s a retry but should be logged\n    // trigger sleep\n    policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n\n    return policyMap;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3ARetryPolicy.java",
      "extendedDetails": {}
    },
    "0af4011580878566213016af0c32633eabd15100": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16221. S3Guard: add option to fail operation on metadata write failure.\n",
      "commitDate": "30/04/19 3:53 AM",
      "commitName": "0af4011580878566213016af0c32633eabd15100",
      "commitAuthor": "Ben Roling",
      "commitDateOld": "13/03/19 1:37 PM",
      "commitNameOld": "6fa229891e06eea62cb9634efde755f40247e816",
      "commitAuthorOld": "Ben Roling",
      "daysBetweenCommits": 47.59,
      "commitsBetweenForRepo": 310,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,67 @@\n   protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n     // the policy map maps the exact classname; subclasses do not\n     // inherit policies.\n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n \n     // failfast exceptions which we consider unrecoverable\n     policyMap.put(UnknownHostException.class, fail);\n     policyMap.put(NoRouteToHostException.class, fail);\n     policyMap.put(InterruptedException.class, fail);\n     // note this does not pick up subclasses (like socket timeout)\n     policyMap.put(InterruptedIOException.class, fail);\n     // Access denial and auth exceptions are not retried\n     policyMap.put(AccessDeniedException.class, fail);\n     policyMap.put(NoAuthWithAWSException.class, fail);\n     policyMap.put(FileNotFoundException.class, fail);\n     policyMap.put(InvalidRequestException.class, fail);\n \n+    // metadata stores should do retries internally when it makes sense\n+    // so there is no point doing another layer of retries after that\n+    policyMap.put(MetadataPersistenceException.class, fail);\n+\n     // once the file has changed, trying again is not going to help\n     policyMap.put(RemoteFileChangedException.class, fail);\n \n     // likely only recovered by changing the policy configuration or s3\n     // implementation\n     policyMap.put(NoVersionAttributeException.class, fail);\n \n     // should really be handled by resubmitting to new location;\n     // that\u0027s beyond the scope of this retry policy\n     policyMap.put(AWSRedirectException.class, fail);\n \n     // throttled requests are can be retried, always\n     policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n \n     // connectivity problems are retried without worrying about idempotency\n     policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n \n     // this can be a sign of an HTTP connection breaking early.\n     // which can be reacted to by another attempt if the request was idempotent.\n     // But: could also be a sign of trying to read past the EOF on a GET,\n     // which isn\u0027t going to be recovered from\n     policyMap.put(EOFException.class, retryIdempotentCalls);\n \n     // policy on a 400/bad request still ambiguous.\n     // Treated as an immediate failure\n     policyMap.put(AWSBadRequestException.class, fail);\n \n     // Status 500 error code is also treated as a connectivity problem\n     policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n \n     // server didn\u0027t respond.\n     policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n \n     // other operations\n     policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n     policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n     policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n     policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n \n     // Dynamo DB exceptions\n     // asking for more than you should get. It\u0027s a retry but should be logged\n     // trigger sleep\n     policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n \n     return policyMap;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n    // the policy map maps the exact classname; subclasses do not\n    // inherit policies.\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n\n    // failfast exceptions which we consider unrecoverable\n    policyMap.put(UnknownHostException.class, fail);\n    policyMap.put(NoRouteToHostException.class, fail);\n    policyMap.put(InterruptedException.class, fail);\n    // note this does not pick up subclasses (like socket timeout)\n    policyMap.put(InterruptedIOException.class, fail);\n    // Access denial and auth exceptions are not retried\n    policyMap.put(AccessDeniedException.class, fail);\n    policyMap.put(NoAuthWithAWSException.class, fail);\n    policyMap.put(FileNotFoundException.class, fail);\n    policyMap.put(InvalidRequestException.class, fail);\n\n    // metadata stores should do retries internally when it makes sense\n    // so there is no point doing another layer of retries after that\n    policyMap.put(MetadataPersistenceException.class, fail);\n\n    // once the file has changed, trying again is not going to help\n    policyMap.put(RemoteFileChangedException.class, fail);\n\n    // likely only recovered by changing the policy configuration or s3\n    // implementation\n    policyMap.put(NoVersionAttributeException.class, fail);\n\n    // should really be handled by resubmitting to new location;\n    // that\u0027s beyond the scope of this retry policy\n    policyMap.put(AWSRedirectException.class, fail);\n\n    // throttled requests are can be retried, always\n    policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n\n    // connectivity problems are retried without worrying about idempotency\n    policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n\n    // this can be a sign of an HTTP connection breaking early.\n    // which can be reacted to by another attempt if the request was idempotent.\n    // But: could also be a sign of trying to read past the EOF on a GET,\n    // which isn\u0027t going to be recovered from\n    policyMap.put(EOFException.class, retryIdempotentCalls);\n\n    // policy on a 400/bad request still ambiguous.\n    // Treated as an immediate failure\n    policyMap.put(AWSBadRequestException.class, fail);\n\n    // Status 500 error code is also treated as a connectivity problem\n    policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n\n    // server didn\u0027t respond.\n    policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n\n    // other operations\n    policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n    policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n\n    // Dynamo DB exceptions\n    // asking for more than you should get. It\u0027s a retry but should be logged\n    // trigger sleep\n    policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n\n    return policyMap;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3ARetryPolicy.java",
      "extendedDetails": {}
    },
    "6fa229891e06eea62cb9634efde755f40247e816": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15625. S3A input stream to use etags/version number to detect changed source files.\n\nAuthor: Ben Roling \u003cben.roling@gmail.com\u003e\n\nInitial patch from Brahma Reddy Battula.\n",
      "commitDate": "13/03/19 1:37 PM",
      "commitName": "6fa229891e06eea62cb9634efde755f40247e816",
      "commitAuthor": "Ben Roling",
      "commitDateOld": "12/09/18 9:04 PM",
      "commitNameOld": "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 181.69,
      "commitsBetweenForRepo": 1461,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,63 @@\n   protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n     // the policy map maps the exact classname; subclasses do not\n     // inherit policies.\n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n \n     // failfast exceptions which we consider unrecoverable\n     policyMap.put(UnknownHostException.class, fail);\n     policyMap.put(NoRouteToHostException.class, fail);\n     policyMap.put(InterruptedException.class, fail);\n     // note this does not pick up subclasses (like socket timeout)\n     policyMap.put(InterruptedIOException.class, fail);\n     // Access denial and auth exceptions are not retried\n     policyMap.put(AccessDeniedException.class, fail);\n     policyMap.put(NoAuthWithAWSException.class, fail);\n     policyMap.put(FileNotFoundException.class, fail);\n     policyMap.put(InvalidRequestException.class, fail);\n \n+    // once the file has changed, trying again is not going to help\n+    policyMap.put(RemoteFileChangedException.class, fail);\n+\n+    // likely only recovered by changing the policy configuration or s3\n+    // implementation\n+    policyMap.put(NoVersionAttributeException.class, fail);\n+\n     // should really be handled by resubmitting to new location;\n     // that\u0027s beyond the scope of this retry policy\n     policyMap.put(AWSRedirectException.class, fail);\n \n     // throttled requests are can be retried, always\n     policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n \n     // connectivity problems are retried without worrying about idempotency\n     policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n \n     // this can be a sign of an HTTP connection breaking early.\n     // which can be reacted to by another attempt if the request was idempotent.\n     // But: could also be a sign of trying to read past the EOF on a GET,\n     // which isn\u0027t going to be recovered from\n     policyMap.put(EOFException.class, retryIdempotentCalls);\n \n     // policy on a 400/bad request still ambiguous.\n     // Treated as an immediate failure\n     policyMap.put(AWSBadRequestException.class, fail);\n \n     // Status 500 error code is also treated as a connectivity problem\n     policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n \n     // server didn\u0027t respond.\n     policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n \n     // other operations\n     policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n     policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n     policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n     policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n \n     // Dynamo DB exceptions\n     // asking for more than you should get. It\u0027s a retry but should be logged\n     // trigger sleep\n     policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n \n     return policyMap;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n    // the policy map maps the exact classname; subclasses do not\n    // inherit policies.\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n\n    // failfast exceptions which we consider unrecoverable\n    policyMap.put(UnknownHostException.class, fail);\n    policyMap.put(NoRouteToHostException.class, fail);\n    policyMap.put(InterruptedException.class, fail);\n    // note this does not pick up subclasses (like socket timeout)\n    policyMap.put(InterruptedIOException.class, fail);\n    // Access denial and auth exceptions are not retried\n    policyMap.put(AccessDeniedException.class, fail);\n    policyMap.put(NoAuthWithAWSException.class, fail);\n    policyMap.put(FileNotFoundException.class, fail);\n    policyMap.put(InvalidRequestException.class, fail);\n\n    // once the file has changed, trying again is not going to help\n    policyMap.put(RemoteFileChangedException.class, fail);\n\n    // likely only recovered by changing the policy configuration or s3\n    // implementation\n    policyMap.put(NoVersionAttributeException.class, fail);\n\n    // should really be handled by resubmitting to new location;\n    // that\u0027s beyond the scope of this retry policy\n    policyMap.put(AWSRedirectException.class, fail);\n\n    // throttled requests are can be retried, always\n    policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n\n    // connectivity problems are retried without worrying about idempotency\n    policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n\n    // this can be a sign of an HTTP connection breaking early.\n    // which can be reacted to by another attempt if the request was idempotent.\n    // But: could also be a sign of trying to read past the EOF on a GET,\n    // which isn\u0027t going to be recovered from\n    policyMap.put(EOFException.class, retryIdempotentCalls);\n\n    // policy on a 400/bad request still ambiguous.\n    // Treated as an immediate failure\n    policyMap.put(AWSBadRequestException.class, fail);\n\n    // Status 500 error code is also treated as a connectivity problem\n    policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n\n    // server didn\u0027t respond.\n    policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n\n    // other operations\n    policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n    policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n\n    // Dynamo DB exceptions\n    // asking for more than you should get. It\u0027s a retry but should be logged\n    // trigger sleep\n    policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n\n    return policyMap;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3ARetryPolicy.java",
      "extendedDetails": {}
    },
    "da9a39eed138210de29b59b90c449b28da1c04f9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15583. Stabilize S3A Assumed Role support.\nContributed by Steve Loughran.\n",
      "commitDate": "08/08/18 10:57 PM",
      "commitName": "da9a39eed138210de29b59b90c449b28da1c04f9",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "10/04/18 11:55 PM",
      "commitNameOld": "b0aff8a96221fbf40d1eafe51b4f530b73146a20",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 119.96,
      "commitsBetweenForRepo": 1350,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,56 @@\n   protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n     // the policy map maps the exact classname; subclasses do not\n     // inherit policies.\n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n \n     // failfast exceptions which we consider unrecoverable\n     policyMap.put(UnknownHostException.class, fail);\n     policyMap.put(NoRouteToHostException.class, fail);\n     policyMap.put(InterruptedException.class, fail);\n     // note this does not pick up subclasses (like socket timeout)\n     policyMap.put(InterruptedIOException.class, fail);\n-    // interesting question: should this be retried ever?\n+    // Access denial and auth exceptions are not retried\n     policyMap.put(AccessDeniedException.class, fail);\n+    policyMap.put(NoAuthWithAWSException.class, fail);\n     policyMap.put(FileNotFoundException.class, fail);\n     policyMap.put(InvalidRequestException.class, fail);\n \n     // should really be handled by resubmitting to new location;\n     // that\u0027s beyond the scope of this retry policy\n     policyMap.put(AWSRedirectException.class, fail);\n \n     // throttled requests are can be retried, always\n     policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n \n     // connectivity problems are retried without worrying about idempotency\n     policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n \n     // this can be a sign of an HTTP connection breaking early.\n     // which can be reacted to by another attempt if the request was idempotent.\n     // But: could also be a sign of trying to read past the EOF on a GET,\n     // which isn\u0027t going to be recovered from\n     policyMap.put(EOFException.class, retryIdempotentCalls);\n \n     // policy on a 400/bad request still ambiguous.\n     // Treated as an immediate failure\n     policyMap.put(AWSBadRequestException.class, fail);\n \n     // Status 500 error code is also treated as a connectivity problem\n     policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n \n     // server didn\u0027t respond.\n     policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n \n     // other operations\n     policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n     policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n     policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n     policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n \n     // Dynamo DB exceptions\n     // asking for more than you should get. It\u0027s a retry but should be logged\n     // trigger sleep\n     policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n \n     return policyMap;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n    // the policy map maps the exact classname; subclasses do not\n    // inherit policies.\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n\n    // failfast exceptions which we consider unrecoverable\n    policyMap.put(UnknownHostException.class, fail);\n    policyMap.put(NoRouteToHostException.class, fail);\n    policyMap.put(InterruptedException.class, fail);\n    // note this does not pick up subclasses (like socket timeout)\n    policyMap.put(InterruptedIOException.class, fail);\n    // Access denial and auth exceptions are not retried\n    policyMap.put(AccessDeniedException.class, fail);\n    policyMap.put(NoAuthWithAWSException.class, fail);\n    policyMap.put(FileNotFoundException.class, fail);\n    policyMap.put(InvalidRequestException.class, fail);\n\n    // should really be handled by resubmitting to new location;\n    // that\u0027s beyond the scope of this retry policy\n    policyMap.put(AWSRedirectException.class, fail);\n\n    // throttled requests are can be retried, always\n    policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n\n    // connectivity problems are retried without worrying about idempotency\n    policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n\n    // this can be a sign of an HTTP connection breaking early.\n    // which can be reacted to by another attempt if the request was idempotent.\n    // But: could also be a sign of trying to read past the EOF on a GET,\n    // which isn\u0027t going to be recovered from\n    policyMap.put(EOFException.class, retryIdempotentCalls);\n\n    // policy on a 400/bad request still ambiguous.\n    // Treated as an immediate failure\n    policyMap.put(AWSBadRequestException.class, fail);\n\n    // Status 500 error code is also treated as a connectivity problem\n    policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n\n    // server didn\u0027t respond.\n    policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n\n    // other operations\n    policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n    policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n\n    // Dynamo DB exceptions\n    // asking for more than you should get. It\u0027s a retry but should be logged\n    // trigger sleep\n    policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n\n    return policyMap;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3ARetryPolicy.java",
      "extendedDetails": {}
    },
    "b0aff8a96221fbf40d1eafe51b4f530b73146a20": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15346 S3ARetryPolicy for 400/BadArgument to be \"fail\". Contributed by Steve Loughran.\n",
      "commitDate": "10/04/18 11:55 PM",
      "commitName": "b0aff8a96221fbf40d1eafe51b4f530b73146a20",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "05/03/18 6:06 AM",
      "commitNameOld": "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 36.7,
      "commitsBetweenForRepo": 375,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n     // the policy map maps the exact classname; subclasses do not\n     // inherit policies.\n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n \n     // failfast exceptions which we consider unrecoverable\n     policyMap.put(UnknownHostException.class, fail);\n     policyMap.put(NoRouteToHostException.class, fail);\n     policyMap.put(InterruptedException.class, fail);\n     // note this does not pick up subclasses (like socket timeout)\n     policyMap.put(InterruptedIOException.class, fail);\n     // interesting question: should this be retried ever?\n     policyMap.put(AccessDeniedException.class, fail);\n     policyMap.put(FileNotFoundException.class, fail);\n     policyMap.put(InvalidRequestException.class, fail);\n \n     // should really be handled by resubmitting to new location;\n     // that\u0027s beyond the scope of this retry policy\n     policyMap.put(AWSRedirectException.class, fail);\n \n     // throttled requests are can be retried, always\n     policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n \n     // connectivity problems are retried without worrying about idempotency\n     policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n \n     // this can be a sign of an HTTP connection breaking early.\n     // which can be reacted to by another attempt if the request was idempotent.\n     // But: could also be a sign of trying to read past the EOF on a GET,\n     // which isn\u0027t going to be recovered from\n     policyMap.put(EOFException.class, retryIdempotentCalls);\n \n-    // policy on a 400/bad request still ambiguous. Given it\n-    // comes and goes on test runs: try again\n-    policyMap.put(AWSBadRequestException.class, connectivityFailure);\n+    // policy on a 400/bad request still ambiguous.\n+    // Treated as an immediate failure\n+    policyMap.put(AWSBadRequestException.class, fail);\n \n     // Status 500 error code is also treated as a connectivity problem\n     policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n \n     // server didn\u0027t respond.\n     policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n \n     // other operations\n     policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n     policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n     policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n     policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n \n     // Dynamo DB exceptions\n     // asking for more than you should get. It\u0027s a retry but should be logged\n     // trigger sleep\n     policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n \n     return policyMap;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n    // the policy map maps the exact classname; subclasses do not\n    // inherit policies.\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n\n    // failfast exceptions which we consider unrecoverable\n    policyMap.put(UnknownHostException.class, fail);\n    policyMap.put(NoRouteToHostException.class, fail);\n    policyMap.put(InterruptedException.class, fail);\n    // note this does not pick up subclasses (like socket timeout)\n    policyMap.put(InterruptedIOException.class, fail);\n    // interesting question: should this be retried ever?\n    policyMap.put(AccessDeniedException.class, fail);\n    policyMap.put(FileNotFoundException.class, fail);\n    policyMap.put(InvalidRequestException.class, fail);\n\n    // should really be handled by resubmitting to new location;\n    // that\u0027s beyond the scope of this retry policy\n    policyMap.put(AWSRedirectException.class, fail);\n\n    // throttled requests are can be retried, always\n    policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n\n    // connectivity problems are retried without worrying about idempotency\n    policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n\n    // this can be a sign of an HTTP connection breaking early.\n    // which can be reacted to by another attempt if the request was idempotent.\n    // But: could also be a sign of trying to read past the EOF on a GET,\n    // which isn\u0027t going to be recovered from\n    policyMap.put(EOFException.class, retryIdempotentCalls);\n\n    // policy on a 400/bad request still ambiguous.\n    // Treated as an immediate failure\n    policyMap.put(AWSBadRequestException.class, fail);\n\n    // Status 500 error code is also treated as a connectivity problem\n    policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n\n    // server didn\u0027t respond.\n    policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n\n    // other operations\n    policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n    policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n\n    // Dynamo DB exceptions\n    // asking for more than you should get. It\u0027s a retry but should be logged\n    // trigger sleep\n    policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n\n    return policyMap;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3ARetryPolicy.java",
      "extendedDetails": {}
    },
    "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13761. S3Guard: implement retries for DDB failures and throttling; translate exceptions.\nContributed by Aaron Fabbri.\n",
      "commitDate": "05/03/18 6:06 AM",
      "commitName": "8110d6a0d59e7dc2ddb25fa424fab188c5e9ce35",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,55 @@\n+  protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n+    // the policy map maps the exact classname; subclasses do not\n+    // inherit policies.\n+    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n+\n+    // failfast exceptions which we consider unrecoverable\n+    policyMap.put(UnknownHostException.class, fail);\n+    policyMap.put(NoRouteToHostException.class, fail);\n+    policyMap.put(InterruptedException.class, fail);\n+    // note this does not pick up subclasses (like socket timeout)\n+    policyMap.put(InterruptedIOException.class, fail);\n+    // interesting question: should this be retried ever?\n+    policyMap.put(AccessDeniedException.class, fail);\n+    policyMap.put(FileNotFoundException.class, fail);\n+    policyMap.put(InvalidRequestException.class, fail);\n+\n+    // should really be handled by resubmitting to new location;\n+    // that\u0027s beyond the scope of this retry policy\n+    policyMap.put(AWSRedirectException.class, fail);\n+\n+    // throttled requests are can be retried, always\n+    policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n+\n+    // connectivity problems are retried without worrying about idempotency\n+    policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n+\n+    // this can be a sign of an HTTP connection breaking early.\n+    // which can be reacted to by another attempt if the request was idempotent.\n+    // But: could also be a sign of trying to read past the EOF on a GET,\n+    // which isn\u0027t going to be recovered from\n+    policyMap.put(EOFException.class, retryIdempotentCalls);\n+\n+    // policy on a 400/bad request still ambiguous. Given it\n+    // comes and goes on test runs: try again\n+    policyMap.put(AWSBadRequestException.class, connectivityFailure);\n+\n+    // Status 500 error code is also treated as a connectivity problem\n+    policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n+\n+    // server didn\u0027t respond.\n+    policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n+\n+    // other operations\n+    policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n+    policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n+    policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n+    policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n+\n+    // Dynamo DB exceptions\n+    // asking for more than you should get. It\u0027s a retry but should be logged\n+    // trigger sleep\n+    policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n+\n+    return policyMap;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e createExceptionMap() {\n    // the policy map maps the exact classname; subclasses do not\n    // inherit policies.\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e policyMap \u003d new HashMap\u003c\u003e();\n\n    // failfast exceptions which we consider unrecoverable\n    policyMap.put(UnknownHostException.class, fail);\n    policyMap.put(NoRouteToHostException.class, fail);\n    policyMap.put(InterruptedException.class, fail);\n    // note this does not pick up subclasses (like socket timeout)\n    policyMap.put(InterruptedIOException.class, fail);\n    // interesting question: should this be retried ever?\n    policyMap.put(AccessDeniedException.class, fail);\n    policyMap.put(FileNotFoundException.class, fail);\n    policyMap.put(InvalidRequestException.class, fail);\n\n    // should really be handled by resubmitting to new location;\n    // that\u0027s beyond the scope of this retry policy\n    policyMap.put(AWSRedirectException.class, fail);\n\n    // throttled requests are can be retried, always\n    policyMap.put(AWSServiceThrottledException.class, throttlePolicy);\n\n    // connectivity problems are retried without worrying about idempotency\n    policyMap.put(ConnectTimeoutException.class, connectivityFailure);\n\n    // this can be a sign of an HTTP connection breaking early.\n    // which can be reacted to by another attempt if the request was idempotent.\n    // But: could also be a sign of trying to read past the EOF on a GET,\n    // which isn\u0027t going to be recovered from\n    policyMap.put(EOFException.class, retryIdempotentCalls);\n\n    // policy on a 400/bad request still ambiguous. Given it\n    // comes and goes on test runs: try again\n    policyMap.put(AWSBadRequestException.class, connectivityFailure);\n\n    // Status 500 error code is also treated as a connectivity problem\n    policyMap.put(AWSStatus500Exception.class, connectivityFailure);\n\n    // server didn\u0027t respond.\n    policyMap.put(AWSNoResponseException.class, retryIdempotentCalls);\n\n    // other operations\n    policyMap.put(AWSClientIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSServiceIOException.class, retryIdempotentCalls);\n    policyMap.put(AWSS3IOException.class, retryIdempotentCalls);\n    policyMap.put(SocketTimeoutException.class, retryIdempotentCalls);\n\n    // Dynamo DB exceptions\n    // asking for more than you should get. It\u0027s a retry but should be logged\n    // trigger sleep\n    policyMap.put(ProvisionedThroughputExceededException.class, throttlePolicy);\n\n    return policyMap;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3ARetryPolicy.java"
    }
  }
}