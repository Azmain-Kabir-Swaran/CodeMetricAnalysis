{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "QueueManagementDynamicEditPolicy.java",
  "functionName": "computeQueueManagementChanges",
  "functionId": "computeQueueManagementChanges___parentQueue-ManagedParentQueue",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/QueueManagementDynamicEditPolicy.java",
  "functionStartLine": 182,
  "functionEndLine": 230,
  "numCommitsSeen": 4,
  "timeTaken": 3095,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
    "344c335a920e6f32a35ebace0a118a9dc4a22fb7",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd": "Ybodychange",
    "344c335a920e6f32a35ebace0a118a9dc4a22fb7": "Ybodychange",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "18/03/19 10:57 AM",
      "commitNameOld": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 372.72,
      "commitsBetweenForRepo": 2179,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n   List\u003cQueueManagementChange\u003e computeQueueManagementChanges\n       (ManagedParentQueue parentQueue) {\n \n     List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n         Collections.emptyList();\n     if (!parentQueue.shouldFailAutoCreationWhenGuaranteedCapacityExceeded()) {\n \n       AutoCreatedQueueManagementPolicy policyClazz \u003d\n           parentQueue.getAutoCreatedQueueManagementPolicy();\n       long startTime \u003d 0;\n       try {\n         startTime \u003d clock.getTime();\n \n         queueManagementChanges \u003d policyClazz.computeQueueManagementChanges();\n \n         //Scheduler update is asynchronous\n         if (queueManagementChanges.size() \u003e 0) {\n           QueueManagementChangeEvent queueManagementChangeEvent \u003d\n               new QueueManagementChangeEvent(parentQueue,\n                   queueManagementChanges);\n           scheduler.getRMContext().getDispatcher().getEventHandler().handle(\n               queueManagementChangeEvent);\n         }\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"{} uses {} millisecond\" + \" to run\",\n               policyClazz.getClass().getName(), clock.getTime() - startTime);\n           if (queueManagementChanges.size() \u003e 0) {\n             LOG.debug(\" Updated queue management changes for parent queue\" + \" \"\n-                    + \"{}: [{}]\", parentQueue.getQueueName(),\n+                    + \"{}: [{}]\", parentQueue.getQueuePath(),\n                 queueManagementChanges.size() \u003c 25 ?\n                     queueManagementChanges.toString() :\n                     queueManagementChanges.size());\n           }\n         }\n       } catch (YarnException e) {\n         LOG.error(\n             \"Could not compute child queue management updates for parent \"\n                 + \"queue \"\n-                + parentQueue.getQueueName(), e);\n+                + parentQueue.getQueuePath(), e);\n       }\n     } else{\n       LOG.debug(\"Skipping queue management updates for parent queue {} \"\n           + \"since configuration for auto creating queues beyond \"\n           + \"parent\u0027s guaranteed capacity is disabled\",\n           parentQueue.getQueuePath());\n     }\n     return queueManagementChanges;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cQueueManagementChange\u003e computeQueueManagementChanges\n      (ManagedParentQueue parentQueue) {\n\n    List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n        Collections.emptyList();\n    if (!parentQueue.shouldFailAutoCreationWhenGuaranteedCapacityExceeded()) {\n\n      AutoCreatedQueueManagementPolicy policyClazz \u003d\n          parentQueue.getAutoCreatedQueueManagementPolicy();\n      long startTime \u003d 0;\n      try {\n        startTime \u003d clock.getTime();\n\n        queueManagementChanges \u003d policyClazz.computeQueueManagementChanges();\n\n        //Scheduler update is asynchronous\n        if (queueManagementChanges.size() \u003e 0) {\n          QueueManagementChangeEvent queueManagementChangeEvent \u003d\n              new QueueManagementChangeEvent(parentQueue,\n                  queueManagementChanges);\n          scheduler.getRMContext().getDispatcher().getEventHandler().handle(\n              queueManagementChangeEvent);\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"{} uses {} millisecond\" + \" to run\",\n              policyClazz.getClass().getName(), clock.getTime() - startTime);\n          if (queueManagementChanges.size() \u003e 0) {\n            LOG.debug(\" Updated queue management changes for parent queue\" + \" \"\n                    + \"{}: [{}]\", parentQueue.getQueuePath(),\n                queueManagementChanges.size() \u003c 25 ?\n                    queueManagementChanges.toString() :\n                    queueManagementChanges.size());\n          }\n        }\n      } catch (YarnException e) {\n        LOG.error(\n            \"Could not compute child queue management updates for parent \"\n                + \"queue \"\n                + parentQueue.getQueuePath(), e);\n      }\n    } else{\n      LOG.debug(\"Skipping queue management updates for parent queue {} \"\n          + \"since configuration for auto creating queues beyond \"\n          + \"parent\u0027s guaranteed capacity is disabled\",\n          parentQueue.getQueuePath());\n    }\n    return queueManagementChanges;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/QueueManagementDynamicEditPolicy.java",
      "extendedDetails": {}
    },
    "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9363.  Replaced debug logging with SLF4J parameterized log message.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "18/03/19 10:57 AM",
      "commitName": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "09/08/18 11:04 AM",
      "commitNameOld": "344c335a920e6f32a35ebace0a118a9dc4a22fb7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 221.0,
      "commitsBetweenForRepo": 1801,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,49 @@\n   List\u003cQueueManagementChange\u003e computeQueueManagementChanges\n       (ManagedParentQueue parentQueue) {\n \n     List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n         Collections.emptyList();\n     if (!parentQueue.shouldFailAutoCreationWhenGuaranteedCapacityExceeded()) {\n \n       AutoCreatedQueueManagementPolicy policyClazz \u003d\n           parentQueue.getAutoCreatedQueueManagementPolicy();\n       long startTime \u003d 0;\n       try {\n         startTime \u003d clock.getTime();\n \n         queueManagementChanges \u003d policyClazz.computeQueueManagementChanges();\n \n         //Scheduler update is asynchronous\n         if (queueManagementChanges.size() \u003e 0) {\n           QueueManagementChangeEvent queueManagementChangeEvent \u003d\n               new QueueManagementChangeEvent(parentQueue,\n                   queueManagementChanges);\n           scheduler.getRMContext().getDispatcher().getEventHandler().handle(\n               queueManagementChangeEvent);\n         }\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"{} uses {} millisecond\" + \" to run\",\n               policyClazz.getClass().getName(), clock.getTime() - startTime);\n           if (queueManagementChanges.size() \u003e 0) {\n             LOG.debug(\" Updated queue management changes for parent queue\" + \" \"\n                     + \"{}: [{}]\", parentQueue.getQueueName(),\n                 queueManagementChanges.size() \u003c 25 ?\n                     queueManagementChanges.toString() :\n                     queueManagementChanges.size());\n           }\n         }\n       } catch (YarnException e) {\n         LOG.error(\n             \"Could not compute child queue management updates for parent \"\n                 + \"queue \"\n                 + parentQueue.getQueueName(), e);\n       }\n     } else{\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\n-            \"Skipping queue management updates for parent queue \"\n-                + parentQueue\n-                .getQueuePath() + \" \"\n-                + \"since configuration for auto creating queues beyond \"\n-                + \"parent\u0027s \"\n-                + \"guaranteed capacity is disabled\");\n-      }\n+      LOG.debug(\"Skipping queue management updates for parent queue {} \"\n+          + \"since configuration for auto creating queues beyond \"\n+          + \"parent\u0027s guaranteed capacity is disabled\",\n+          parentQueue.getQueuePath());\n     }\n     return queueManagementChanges;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cQueueManagementChange\u003e computeQueueManagementChanges\n      (ManagedParentQueue parentQueue) {\n\n    List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n        Collections.emptyList();\n    if (!parentQueue.shouldFailAutoCreationWhenGuaranteedCapacityExceeded()) {\n\n      AutoCreatedQueueManagementPolicy policyClazz \u003d\n          parentQueue.getAutoCreatedQueueManagementPolicy();\n      long startTime \u003d 0;\n      try {\n        startTime \u003d clock.getTime();\n\n        queueManagementChanges \u003d policyClazz.computeQueueManagementChanges();\n\n        //Scheduler update is asynchronous\n        if (queueManagementChanges.size() \u003e 0) {\n          QueueManagementChangeEvent queueManagementChangeEvent \u003d\n              new QueueManagementChangeEvent(parentQueue,\n                  queueManagementChanges);\n          scheduler.getRMContext().getDispatcher().getEventHandler().handle(\n              queueManagementChangeEvent);\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"{} uses {} millisecond\" + \" to run\",\n              policyClazz.getClass().getName(), clock.getTime() - startTime);\n          if (queueManagementChanges.size() \u003e 0) {\n            LOG.debug(\" Updated queue management changes for parent queue\" + \" \"\n                    + \"{}: [{}]\", parentQueue.getQueueName(),\n                queueManagementChanges.size() \u003c 25 ?\n                    queueManagementChanges.toString() :\n                    queueManagementChanges.size());\n          }\n        }\n      } catch (YarnException e) {\n        LOG.error(\n            \"Could not compute child queue management updates for parent \"\n                + \"queue \"\n                + parentQueue.getQueueName(), e);\n      }\n    } else{\n      LOG.debug(\"Skipping queue management updates for parent queue {} \"\n          + \"since configuration for auto creating queues beyond \"\n          + \"parent\u0027s guaranteed capacity is disabled\",\n          parentQueue.getQueuePath());\n    }\n    return queueManagementChanges;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/QueueManagementDynamicEditPolicy.java",
      "extendedDetails": {}
    },
    "344c335a920e6f32a35ebace0a118a9dc4a22fb7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8588. Logging improvements for better debuggability. (Suma Shivaprasad via wangda)\n\nChange-Id: I66aa4b0ec031ae5ce0fae558e2f8cbcbbfebc442\n",
      "commitDate": "09/08/18 11:04 AM",
      "commitName": "344c335a920e6f32a35ebace0a118a9dc4a22fb7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/12/17 3:10 PM",
      "commitNameOld": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 243.79,
      "commitsBetweenForRepo": 2240,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,54 @@\n   List\u003cQueueManagementChange\u003e computeQueueManagementChanges\n       (ManagedParentQueue parentQueue) {\n \n     List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n         Collections.emptyList();\n     if (!parentQueue.shouldFailAutoCreationWhenGuaranteedCapacityExceeded()) {\n \n       AutoCreatedQueueManagementPolicy policyClazz \u003d\n           parentQueue.getAutoCreatedQueueManagementPolicy();\n       long startTime \u003d 0;\n       try {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(MessageFormat\n-              .format(\"Trying to use {0} to compute preemption \"\n-                      + \"candidates\",\n-                  policyClazz.getClass().getName()));\n-          startTime \u003d clock.getTime();\n-        }\n+        startTime \u003d clock.getTime();\n \n         queueManagementChanges \u003d policyClazz.computeQueueManagementChanges();\n \n         //Scheduler update is asynchronous\n         if (queueManagementChanges.size() \u003e 0) {\n           QueueManagementChangeEvent queueManagementChangeEvent \u003d\n               new QueueManagementChangeEvent(parentQueue,\n                   queueManagementChanges);\n           scheduler.getRMContext().getDispatcher().getEventHandler().handle(\n               queueManagementChangeEvent);\n         }\n \n         if (LOG.isDebugEnabled()) {\n-          LOG.debug(MessageFormat.format(\"{0} uses {1} millisecond\"\n-                  + \" to run\",\n-              policyClazz.getClass().getName(), clock.getTime()\n-                  - startTime));\n+          LOG.debug(\"{} uses {} millisecond\" + \" to run\",\n+              policyClazz.getClass().getName(), clock.getTime() - startTime);\n           if (queueManagementChanges.size() \u003e 0) {\n-            LOG.debug(\" Updated queue management updates for parent queue\"\n-                + \" [\"\n-                + parentQueue.getQueueName() + \": [\\n\" + queueManagementChanges\n-                .toString() + \"\\n]\");\n+            LOG.debug(\" Updated queue management changes for parent queue\" + \" \"\n+                    + \"{}: [{}]\", parentQueue.getQueueName(),\n+                queueManagementChanges.size() \u003c 25 ?\n+                    queueManagementChanges.toString() :\n+                    queueManagementChanges.size());\n           }\n         }\n       } catch (YarnException e) {\n         LOG.error(\n             \"Could not compute child queue management updates for parent \"\n                 + \"queue \"\n                 + parentQueue.getQueueName(), e);\n       }\n     } else{\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\n             \"Skipping queue management updates for parent queue \"\n                 + parentQueue\n                 .getQueuePath() + \" \"\n-                + \"since configuration for  auto creating queue\u0027s beyond \"\n+                + \"since configuration for auto creating queues beyond \"\n                 + \"parent\u0027s \"\n                 + \"guaranteed capacity is disabled\");\n       }\n     }\n     return queueManagementChanges;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cQueueManagementChange\u003e computeQueueManagementChanges\n      (ManagedParentQueue parentQueue) {\n\n    List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n        Collections.emptyList();\n    if (!parentQueue.shouldFailAutoCreationWhenGuaranteedCapacityExceeded()) {\n\n      AutoCreatedQueueManagementPolicy policyClazz \u003d\n          parentQueue.getAutoCreatedQueueManagementPolicy();\n      long startTime \u003d 0;\n      try {\n        startTime \u003d clock.getTime();\n\n        queueManagementChanges \u003d policyClazz.computeQueueManagementChanges();\n\n        //Scheduler update is asynchronous\n        if (queueManagementChanges.size() \u003e 0) {\n          QueueManagementChangeEvent queueManagementChangeEvent \u003d\n              new QueueManagementChangeEvent(parentQueue,\n                  queueManagementChanges);\n          scheduler.getRMContext().getDispatcher().getEventHandler().handle(\n              queueManagementChangeEvent);\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"{} uses {} millisecond\" + \" to run\",\n              policyClazz.getClass().getName(), clock.getTime() - startTime);\n          if (queueManagementChanges.size() \u003e 0) {\n            LOG.debug(\" Updated queue management changes for parent queue\" + \" \"\n                    + \"{}: [{}]\", parentQueue.getQueueName(),\n                queueManagementChanges.size() \u003c 25 ?\n                    queueManagementChanges.toString() :\n                    queueManagementChanges.size());\n          }\n        }\n      } catch (YarnException e) {\n        LOG.error(\n            \"Could not compute child queue management updates for parent \"\n                + \"queue \"\n                + parentQueue.getQueueName(), e);\n      }\n    } else{\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\n            \"Skipping queue management updates for parent queue \"\n                + parentQueue\n                .getQueuePath() + \" \"\n                + \"since configuration for auto creating queues beyond \"\n                + \"parent\u0027s \"\n                + \"guaranteed capacity is disabled\");\n      }\n    }\n    return queueManagementChanges;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/QueueManagementDynamicEditPolicy.java",
      "extendedDetails": {}
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,61 @@\n+  List\u003cQueueManagementChange\u003e computeQueueManagementChanges\n+      (ManagedParentQueue parentQueue) {\n+\n+    List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n+        Collections.emptyList();\n+    if (!parentQueue.shouldFailAutoCreationWhenGuaranteedCapacityExceeded()) {\n+\n+      AutoCreatedQueueManagementPolicy policyClazz \u003d\n+          parentQueue.getAutoCreatedQueueManagementPolicy();\n+      long startTime \u003d 0;\n+      try {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(MessageFormat\n+              .format(\"Trying to use {0} to compute preemption \"\n+                      + \"candidates\",\n+                  policyClazz.getClass().getName()));\n+          startTime \u003d clock.getTime();\n+        }\n+\n+        queueManagementChanges \u003d policyClazz.computeQueueManagementChanges();\n+\n+        //Scheduler update is asynchronous\n+        if (queueManagementChanges.size() \u003e 0) {\n+          QueueManagementChangeEvent queueManagementChangeEvent \u003d\n+              new QueueManagementChangeEvent(parentQueue,\n+                  queueManagementChanges);\n+          scheduler.getRMContext().getDispatcher().getEventHandler().handle(\n+              queueManagementChangeEvent);\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(MessageFormat.format(\"{0} uses {1} millisecond\"\n+                  + \" to run\",\n+              policyClazz.getClass().getName(), clock.getTime()\n+                  - startTime));\n+          if (queueManagementChanges.size() \u003e 0) {\n+            LOG.debug(\" Updated queue management updates for parent queue\"\n+                + \" [\"\n+                + parentQueue.getQueueName() + \": [\\n\" + queueManagementChanges\n+                .toString() + \"\\n]\");\n+          }\n+        }\n+      } catch (YarnException e) {\n+        LOG.error(\n+            \"Could not compute child queue management updates for parent \"\n+                + \"queue \"\n+                + parentQueue.getQueueName(), e);\n+      }\n+    } else{\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\n+            \"Skipping queue management updates for parent queue \"\n+                + parentQueue\n+                .getQueuePath() + \" \"\n+                + \"since configuration for  auto creating queue\u0027s beyond \"\n+                + \"parent\u0027s \"\n+                + \"guaranteed capacity is disabled\");\n+      }\n+    }\n+    return queueManagementChanges;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cQueueManagementChange\u003e computeQueueManagementChanges\n      (ManagedParentQueue parentQueue) {\n\n    List\u003cQueueManagementChange\u003e queueManagementChanges \u003d\n        Collections.emptyList();\n    if (!parentQueue.shouldFailAutoCreationWhenGuaranteedCapacityExceeded()) {\n\n      AutoCreatedQueueManagementPolicy policyClazz \u003d\n          parentQueue.getAutoCreatedQueueManagementPolicy();\n      long startTime \u003d 0;\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(MessageFormat\n              .format(\"Trying to use {0} to compute preemption \"\n                      + \"candidates\",\n                  policyClazz.getClass().getName()));\n          startTime \u003d clock.getTime();\n        }\n\n        queueManagementChanges \u003d policyClazz.computeQueueManagementChanges();\n\n        //Scheduler update is asynchronous\n        if (queueManagementChanges.size() \u003e 0) {\n          QueueManagementChangeEvent queueManagementChangeEvent \u003d\n              new QueueManagementChangeEvent(parentQueue,\n                  queueManagementChanges);\n          scheduler.getRMContext().getDispatcher().getEventHandler().handle(\n              queueManagementChangeEvent);\n        }\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(MessageFormat.format(\"{0} uses {1} millisecond\"\n                  + \" to run\",\n              policyClazz.getClass().getName(), clock.getTime()\n                  - startTime));\n          if (queueManagementChanges.size() \u003e 0) {\n            LOG.debug(\" Updated queue management updates for parent queue\"\n                + \" [\"\n                + parentQueue.getQueueName() + \": [\\n\" + queueManagementChanges\n                .toString() + \"\\n]\");\n          }\n        }\n      } catch (YarnException e) {\n        LOG.error(\n            \"Could not compute child queue management updates for parent \"\n                + \"queue \"\n                + parentQueue.getQueueName(), e);\n      }\n    } else{\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\n            \"Skipping queue management updates for parent queue \"\n                + parentQueue\n                .getQueuePath() + \" \"\n                + \"since configuration for  auto creating queue\u0027s beyond \"\n                + \"parent\u0027s \"\n                + \"guaranteed capacity is disabled\");\n      }\n    }\n    return queueManagementChanges;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/QueueManagementDynamicEditPolicy.java"
    }
  }
}